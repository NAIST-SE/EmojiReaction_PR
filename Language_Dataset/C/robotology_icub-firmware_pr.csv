robotology/icub-firmware,https://github.com/robotology/icub-firmware,55,2016-01-26T14:13:05Z,2016-01-26T16:12:30Z,2016-05-03T09:27:09Z,MERGED,True,503,190,16,https://github.com/valegagge,New control interfaces,7,[],https://github.com/robotology/icub-firmware/pull/55,https://github.com/valegagge,1,https://github.com/robotology/icub-firmware/pull/55,"in this branch following features are implemented:

get motor pwm
get/set pwm limit
get/set nominal current
get/set peak current
get position reference
get velocity reference
get iDirect reference
following features are almost implemented:
get temperature
get/set temperature limit
get supply power voltage","in this branch following features are implemented:

get motor pwm
get/set pwm limit
get/set nominal current
get/set peak current
get position reference
get velocity reference
get iDirect reference
following features are almost implemented:
get temperature
get/set temperature limit
get supply power voltage",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,62,2016-05-02T07:42:48Z,2016-05-02T07:48:34Z,2019-10-14T15:23:29Z,MERGED,True,1747,2947,53,https://github.com/marcoaccame,runtime configuration,35,[],https://github.com/robotology/icub-firmware/pull/62,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/62,"This FW allows to receive configuration for services of skin, mais, strain, inertials from robotInterface. The application verifies if the requested resources (CAN boards etc) are available and if everything is OK it activates the service and sends OK to robotInterface. At this point, robotInterface can start the service.
It is to be used alongside the proper versions of repositories icub-firmware-shared and icub-main.","This FW allows to receive configuration for services of skin, mais, strain, inertials from robotInterface. The application verifies if the requested resources (CAN boards etc) are available and if everything is OK it activates the service and sends OK to robotInterface. At this point, robotInterface can start the service.
It is to be used alongside the proper versions of repositories icub-firmware-shared and icub-main.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,80,2017-03-02T09:41:42Z,2017-03-02T09:53:45Z,2017-03-22T12:26:46Z,MERGED,True,1148,328,32,https://github.com/valegagge,Rtcmc3,32,[],https://github.com/robotology/icub-firmware/pull/80,https://github.com/valegagge,1,https://github.com/robotology/icub-firmware/pull/80,"This branch implements motion control run time configuration.
Note that the minor  versions number of applications are bigger the 100. I used this trick in order to discriminate applications compiled with this branch from applications compiled with devel branch.
When this branch will be merged in devel I will change the major version number of all applications to 3.","This branch implements motion control run time configuration.
Note that the minor  versions number of applications are bigger the 100. I used this trick in order to discriminate applications compiled with this branch from applications compiled with devel branch.
When this branch will be merged in devel I will change the major version number of all applications to 3.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,81,2017-06-27T01:40:50Z,2017-06-30T10:14:27Z,2017-06-30T10:14:30Z,MERGED,True,27,28,2,https://github.com/traversaro,Cleanup README,1,[],https://github.com/robotology/icub-firmware/pull/81,https://github.com/traversaro,1,https://github.com/robotology/icub-firmware/pull/81,"The build directories are now available at https://github.com/robotology/icub-firmware-build , so I updated the README to point there. I also took the occasion to convert the README to markdown so it would be rendered nicely on GitHub.","The build directories are now available at https://github.com/robotology/icub-firmware-build , so I updated the README to point there. I also took the occasion to convert the README to markdown so it would be rendered nicely on GitHub.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,82,2018-01-04T10:13:02Z,2018-01-04T10:13:16Z,2019-10-14T15:23:42Z,MERGED,True,22,19,4,https://github.com/marcoaccame,strain2support,4,[],https://github.com/robotology/icub-firmware/pull/82,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/82,so that strain2 can be managed by ETH boards,so that strain2 can be managed by ETH boards,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,85,2018-03-20T12:58:57Z,2021-02-11T14:31:14Z,2021-02-11T14:31:29Z,CLOSED,False,87,4,3,https://github.com/ale-git,Added PID parameter soft change.,2,['Status: In Progress'],https://github.com/robotology/icub-firmware/pull/85,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/85,,,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,85,2018-03-20T12:58:57Z,2021-02-11T14:31:14Z,2021-02-11T14:31:29Z,CLOSED,False,87,4,3,https://github.com/ale-git,Added PID parameter soft change.,2,['Status: In Progress'],https://github.com/robotology/icub-firmware/pull/85,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/85#issuecomment-777501339,,having talked w/ @ale-git ... we can close this old PR without merging,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,88,2019-07-24T15:36:57Z,2019-07-25T13:22:44Z,2020-04-01T11:20:16Z,MERGED,True,1481,471,22,https://github.com/ale-git,Flexible motor input,5,[],https://github.com/robotology/icub-firmware/pull/88,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/88,"EMS, MC4+ and MC2+ firmwares compatible to the flexible motor input version of icub-main software.","EMS, MC4+ and MC2+ firmwares compatible to the flexible motor input version of icub-main software.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,88,2019-07-24T15:36:57Z,2019-07-25T13:22:44Z,2020-04-01T11:20:16Z,MERGED,True,1481,471,22,https://github.com/ale-git,Flexible motor input,5,[],https://github.com/robotology/icub-firmware/pull/88,https://github.com/nunoguedelha,2,https://github.com/robotology/icub-firmware/pull/88#issuecomment-516372777,"EMS, MC4+ and MC2+ firmwares compatible to the flexible motor input version of icub-main software.",@ale-git only EMS and MC4+ builds have been flashed to the respective boards as far as I know. Do the changes on MC2+ concern other specific boards?,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,88,2019-07-24T15:36:57Z,2019-07-25T13:22:44Z,2020-04-01T11:20:16Z,MERGED,True,1481,471,22,https://github.com/ale-git,Flexible motor input,5,[],https://github.com/robotology/icub-firmware/pull/88,https://github.com/nunoguedelha,3,https://github.com/robotology/icub-firmware/pull/88#issuecomment-516443193,"EMS, MC4+ and MC2+ firmwares compatible to the flexible motor input version of icub-main software.",I guess the ETH/MC2PLUS/bin/application/mc2plus.hex (MC2+ boards) is only for the R1 robot...,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,88,2019-07-24T15:36:57Z,2019-07-25T13:22:44Z,2020-04-01T11:20:16Z,MERGED,True,1481,471,22,https://github.com/ale-git,Flexible motor input,5,[],https://github.com/robotology/icub-firmware/pull/88,https://github.com/nunoguedelha,4,https://github.com/robotology/icub-firmware/pull/88#issuecomment-516449520,"EMS, MC4+ and MC2+ firmwares compatible to the flexible motor input version of icub-main software.",The icub-firmware-build aligned with this change is: robotology/icub-firmware-build@02728b7.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,90,2019-08-07T00:27:35Z,2019-08-08T13:22:04Z,2019-08-30T10:01:12Z,MERGED,True,16,8,4,https://github.com/nunoguedelha,Increased PWM freq to 40kHz,1,[],https://github.com/robotology/icub-firmware/pull/90,https://github.com/nunoguedelha,1,https://github.com/robotology/icub-firmware/pull/90,"Implements #87. List of changes:

set PWMFREQUENCY define.
re-scale Vq, Vd with respect to the PWM resolution and fullscale.
fixed PTPER computation.
set P1SECMPbits instead of SEVTCMPbits.","Implements #87. List of changes:

set PWMFREQUENCY define.
re-scale Vq, Vd with respect to the PWM resolution and fullscale.
fixed PTPER computation.
set P1SECMPbits instead of SEVTCMPbits.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,90,2019-08-07T00:27:35Z,2019-08-08T13:22:04Z,2019-08-30T10:01:12Z,MERGED,True,16,8,4,https://github.com/nunoguedelha,Increased PWM freq to 40kHz,1,[],https://github.com/robotology/icub-firmware/pull/90,https://github.com/nunoguedelha,2,https://github.com/robotology/icub-firmware/pull/90#issuecomment-526543325,"Implements #87. List of changes:

set PWMFREQUENCY define.
re-scale Vq, Vd with respect to the PWM resolution and fullscale.
fixed PTPER computation.
set P1SECMPbits instead of SEVTCMPbits.","The following non-regression tests have been run on iCubGenova04 (Green iCub):

balancing on two feet with left-right trajectory of the center of mass.
Yoga on left foot (balancing on one foot and moving right leg and arms).
These tests were run while the controllers were configured in PWM output mode, the 2FOC running at 40kHz.
The Current Control mode (on yarpmotorgui) has been tested on one of the legs (left).

All tests passed.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/91,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.","Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/ale-git,2,https://github.com/robotology/icub-firmware/pull/91#issuecomment-522236012,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.","Some improvements have been added:

now the integer arithmetic of the Clarke-Park transformations is more precise thanks to rounding terms
gain calibration of the ADC converter is now performed at startup in addition to offset calibration",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/nunoguedelha,3,https://github.com/robotology/icub-firmware/pull/91#issuecomment-523036550,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.",We have to test on the robot before merging the PR.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/nunoguedelha,4,https://github.com/robotology/icub-firmware/pull/91#issuecomment-525082387,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.",@ale-git why have we duplicated the whole folder? Are maintaining 2 releases? If it's the case it's better to create release branches. It makes it easier to compare/merge changes between the 2 releases.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/nunoguedelha,5,https://github.com/robotology/icub-firmware/pull/91#issuecomment-527168241,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.","Moving the files from 2FOC-V35 to 2FOC-V3
@ale-git I ported the changes into the original folder 2FOC-V3, merging them with the changes for:

the PWM clock rate increase
the fix of the memory alignment issue.

Once the review is finished, we can delete the files in 2FOC-V35 folder.
@marcoaccame, as agreed with @ale-git , we moved the files instead of keeping duplicates, for the following reasons:

keeping a clear history of all the changes so far
if eventually we keep two releases V3.5.x and V3.3.x (I strongly suggest not to), it will be easier to deploy common fixes to both releases and track those changes. For that we need to use two release branches, but that can be discussed in a next meeting..

I suggest we discuss on this today on skype (I'm working from home today and tomorrow morning), or tomorrow afternoon.",True,"{'THUMBS_UP': ['https://github.com/ale-git', 'https://github.com/marcoaccame']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/nunoguedelha,6,https://github.com/robotology/icub-firmware/pull/91#issuecomment-529587815,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.","We agreed with @ale-git to revert the HES/ADC offset calibration to the former original method: PWM on all phases is set to OFF prior measuring the offset currents on terminals A and C. Refer to #96 (comment).
Changes pushed in 41b228b. But this change was done on the old folder 2FOC-V35. Porting now to 2FOC-V3.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/nunoguedelha,7,https://github.com/robotology/icub-firmware/pull/91#issuecomment-532710800,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.","ciao @ale-git , here are the tests I think would be performance improvement indicators for this pull request, illustrating the two main expected improvements:

obtain a clean current waveform on each stator phase, without current discontinuities through a full electric cycle.
have a stator direct field (Id) always well aligned with the rotor, even after a few laps and transitions between sectors 1 & 6.

Here's a proposal for the tests to run...
Test 1: clean current waveform on each stator phase
We have to verify that there are no current discontinuities through a full electric cycle. These discontinuities were previously observed at the switching between sectors 1<->2<->3<->4<->5<->6, while the rotor position detection was hybrid, using the optical encoder and the HES.
With the new solution you've implemented, there could still be a small step, but just between sectors 1 & 6, when the variable tracking the rotor position is reset.
Two possible approaches...
While rotating the rotor at very low speed (~ 1 deg/s)

Measure the phase currents on the oscilloscope (I can help you on this) and check that there are no discontinuities.
or...
Log the computed PWM, on phase A for instance (computed from the rotor angle delta which is a priori impacted by the sector transition 6->1) and compare with a PWM computed from the raw motor enc (enc = QEgetElettrDeg()).

Test 2: stator direct field (Id) always well aligned with the rotor
After a few laps and switching between sectors 1 & 6, there could be a slight misalignment between the stator field and the rotor. We can measure that error through the following procedure (while the rotor has no mechanical load):

run the usual rotor alignment procedure,
set Iq = 0, and wait a few ms that the rotor position stabilizes (cogging effects),
stop the rotor position tracking (delta is fixed),
set Id to a high value. If there is a misalignment, the rotor moves a fraction or a few degrees.
measure final rotor position and compare to delta.

@ale-git, does this seem reasonable with respect to the new rotor alignment you have implemented?",True,{'THUMBS_UP': ['https://github.com/maggia80']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,91,2019-08-14T07:56:32Z,2021-02-11T14:32:33Z,2021-02-11T14:33:03Z,CLOSED,False,686,283,18,https://github.com/ale-git,Added 2FOC V3.5 application.,8,[],https://github.com/robotology/icub-firmware/pull/91,https://github.com/marcoaccame,8,https://github.com/robotology/icub-firmware/pull/91#issuecomment-777502467,"Now the 2.5 motors are controlled in a way as much similar as possible to 3.0 motors in the experimental release V3.5 of the 2FOC firmware:

the quadrature encoder alone is used to measure the rotor angle
the Hall effect sensors are used to reset the quadrature encoder (1 <-> 6 sector transition), in the same way the Index tick is used with 3.0 motors.",having talked w/ @ale-git we can close this old PR w/out merging and delete the branch,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,94,2019-08-28T13:43:48Z,2019-08-28T14:46:43Z,2019-08-28T14:48:32Z,MERGED,True,14,18,2,https://github.com/nunoguedelha,Fix access to non aligned memory through (int*),1,[],https://github.com/robotology/icub-firmware/pull/94,https://github.com/nunoguedelha,1,https://github.com/robotology/icub-firmware/pull/94,"Fixes issue #93.
Reverted the parsing of the Kp, Ki, Ks parameters back to the a copy byte by byte.","Fixes issue #93.
Reverted the parsing of the Kp, Ki, Ks parameters back to the a copy byte by byte.",True,{'THUMBS_UP': ['https://github.com/traversaro']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,97,2019-09-02T12:49:49Z,2019-09-02T12:50:40Z,2020-04-01T11:20:15Z,MERGED,True,7240,35921,145,https://github.com/marcoaccame,restyle,6,[],https://github.com/robotology/icub-firmware/pull/97,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/97,,,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,99,2019-09-13T12:13:35Z,2019-09-13T12:24:04Z,2019-10-14T15:22:31Z,MERGED,True,109341,0,239,https://github.com/marcoaccame,cmsisos2,3,[],https://github.com/robotology/icub-firmware/pull/99,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/99,"added a new rtos library: cmsis os2, the standard de facto for cortex arm","added a new rtos library: cmsis os2, the standard de facto for cortex arm",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,100,2019-10-14T11:48:36Z,2019-10-14T15:22:01Z,2020-04-01T11:20:13Z,MERGED,True,37,10,15,https://github.com/marcoaccame,more ram in eth boards,1,[],https://github.com/robotology/icub-firmware/pull/100,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/100,"enabled the secondary ram bank to give extra 64k.
pls @triccyx: have a look ta the changes","enabled the secondary ram bank to give extra 64k.
pls @triccyx: have a look ta the changes",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,1,https://github.com/robotology/icub-firmware/pull/101,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,True,"{'HEART': ['https://github.com/GiulioRomualdi'], 'ROCKET': ['https://github.com/DanielePucci']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,2,https://github.com/robotology/icub-firmware/pull/101#issuecomment-545079104,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,CC @DanielePucci,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/DanielePucci,3,https://github.com/robotology/icub-firmware/pull/101#issuecomment-545105866,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,CC @marcoaccame @ale-git @S-Dafarra,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/S-Dafarra,4,https://github.com/robotology/icub-firmware/pull/101#issuecomment-545398354,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"I am actually interested in commit 3f1b6d3 since we are having a problem with F/T robotology/icub-tech-support#854, causing several demo failures.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/marcoaccame,5,https://github.com/robotology/icub-firmware/pull/101#issuecomment-545426254,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"You tested the changes on iCubGenova04, did you not? Can you please build binaries and test also for mc4plus?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/marcoaccame,6,https://github.com/robotology/icub-firmware/pull/101#issuecomment-545426960,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"then: @ale-git would you please have a look at the changes proposed in motor control files, as you wrote them?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/ale-git,7,https://github.com/robotology/icub-firmware/pull/101#issuecomment-545937461,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,Hi @marcoaccame it seems fine with me.,True,{'THUMBS_UP': ['https://github.com/nunoguedelha']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,8,https://github.com/robotology/icub-firmware/pull/101#issuecomment-546426967,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"because value 103 is used only to recognise a wip or debug application.

Hi @marcoaccame . Sure, as we discussed afterwards F2F, I still had tests to run on the robot (iCubGenova04), for that reason I left [WIP] in the PR description. Sorry if it was not clear.

Moreover,
the increment of minor version and date are needed also for mc4plus and mc2plus boards.

I will update the versions accordingly after the tests and check with @ale-git .

You tested the changes on iCubGenova04, did you not? Can you please build binaries and test also for mc4plus?

Sure. Is the building environment for mc4plus the same as for the EMS? If not, I will either need a license or ask @ale-git to build the binaries for me after the tests on the EMS boards.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,9,https://github.com/robotology/icub-firmware/pull/101#issuecomment-549712726,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"This branch has been tested on iCubGenova04:

on yarpmotorgui in torque control mode with current output, on individual joints (legs, torso)
running the Simulink model https://github.com/robotology/whole-body-controllers/blob/master/controllers/fixed-base-joints-control/jointsControl.mdl with the robot on the pole.

Remaining actions:



the increment of minor version and date are needed also for mc4plus and mc2plus boards.


rebuild mc4plus and mc2plus
We should wait for robotology/yarp#2115 to be ready for merge before merging this PR.
rebase the branch.
port the changes from robotology/yarp#2115 in this PR.
retest on iCubGenova02 & iCubGenova04.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,10,https://github.com/robotology/icub-firmware/pull/101#issuecomment-549714689,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"@ale-git , @marcoaccame , what is the policy for incrementing the firmware Major/Minor versions?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/marcoaccame,11,https://github.com/robotology/icub-firmware/pull/101#issuecomment-550296311,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"Hi @nunoguedelha, you just need to increase the minor number",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,12,https://github.com/robotology/icub-firmware/pull/101#issuecomment-600515337,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,Edited remaining actions in #101 (comment).,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/marcoaccame,13,https://github.com/robotology/icub-firmware/pull/101#issuecomment-777505206,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,having talked w/ @ale-git we can close this old PR which has been in [WIP] state for long. i shall keep the branch for some more time however. cc @nunoguedelha,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/DanielePucci,14,https://github.com/robotology/icub-firmware/pull/101#issuecomment-777572546,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,CC @GiulioRomualdi @isorrentino @giovannipizzolante,True,"{'THUMBS_UP': ['https://github.com/giovannipizzolante', 'https://github.com/isorrentino']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/nunoguedelha,15,https://github.com/robotology/icub-firmware/pull/101#issuecomment-777601559,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,"Hi @marcoaccame , thank you for the heads up. I'm reviewing my pld branches now to make sure they are pushed to my fork. It is worth keeping at least feature/impl-static-friction-comp-rebase in the robotology icub-firmware repo as it had some developments worth integrating soon enough. I need to discuss with the team to figure out the proper plan to address this, as I don't have the bandwidth right now to address it myself.
we'll get back to you ASAP.",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,101,2019-10-22T17:52:04Z,2021-02-11T14:36:02Z,2021-02-11T20:45:35Z,CLOSED,False,164,63,7,https://github.com/nunoguedelha,"[WIP] Implement a static model with Stiction/Stribeck, Coulomb and Viscous components",16,[],https://github.com/robotology/icub-firmware/pull/101,https://github.com/marcoaccame,16,https://github.com/robotology/icub-firmware/pull/101#issuecomment-777778168,These changes are the implementation of ami-iit/element_torque-control-via-current#81 and a dependency of robotology/robots-configuration#122.,hi @nunoguedelha pls ping me when you have any news about how to proceed,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,103,2019-11-14T17:36:12Z,2019-11-14T17:40:22Z,2020-04-01T11:20:12Z,MERGED,True,1064,393,14,https://github.com/marcoaccame,feat/rfe-enhanced,5,[],https://github.com/robotology/icub-firmware/pull/103,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/103,"In here we enhance the behavior of the board RFE master with respect to face expressions.
The boards was already able to change the expressions by choosing amongst the following: neutral, happy, sad, surprised, angry, evil, shy, cunning.
With the changes in this PR it will be possible to drive the board to produce more complex expressions.
This change adds the following commands which make possible to change in runtime:

the color of the LEDs of the current face expression according to a pre-defined palette: black , white, red, lime,  blue, yellow, cyan, magenta, silver, gray, maroon, olive, green, purple, teal, navy.
the intensity of the LEDs of the current face expression according to predefined values: dark, minimum, low, medium, high, maximum.
the triple (expression, color, intensity) for each face part separately or for all them.
the shape, color, intensity of all the face parts, so that one can apply user-defined expressions with a single command (it sets the color, the brightness, the ON/OFF information of all the LEDs).","In here we enhance the behavior of the board RFE master with respect to face expressions.
The boards was already able to change the expressions by choosing amongst the following: neutral, happy, sad, surprised, angry, evil, shy, cunning.
With the changes in this PR it will be possible to drive the board to produce more complex expressions.
This change adds the following commands which make possible to change in runtime:

the color of the LEDs of the current face expression according to a pre-defined palette: black , white, red, lime,  blue, yellow, cyan, magenta, silver, gray, maroon, olive, green, purple, teal, navy.
the intensity of the LEDs of the current face expression according to predefined values: dark, minimum, low, medium, high, maximum.
the triple (expression, color, intensity) for each face part separately or for all them.
the shape, color, intensity of all the face parts, so that one can apply user-defined expressions with a single command (it sets the color, the brightness, the ON/OFF information of all the LEDs).",True,{'THUMBS_UP': ['https://github.com/traversaro']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,106,2020-02-18T20:26:41Z,2020-02-18T20:27:38Z,2020-02-18T20:27:38Z,MERGED,True,894041,32163,697,https://github.com/marcoaccame,merge of devel into master,6,[],https://github.com/robotology/icub-firmware/pull/106,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/106,merge for sw distro 2020.02,merge for sw distro 2020.02,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,107,2020-03-03T13:31:48Z,2020-03-03T13:32:25Z,2020-04-01T11:20:01Z,MERGED,True,854,238,28,https://github.com/marcoaccame,embot::hw stand-alone ,1,[],https://github.com/robotology/icub-firmware/pull/107,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/107,"improved the embot::hw so that we can use it stand-alone.
added bsp support for nucleo-h7 board","improved the embot::hw so that we can use it stand-alone.
added bsp support for nucleo-h7 board",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,108,2020-03-03T14:39:16Z,2020-03-03T14:39:52Z,2020-04-01T11:19:57Z,MERGED,True,51,3,4,https://github.com/marcoaccame,strain2 ADC check,2,[],https://github.com/robotology/icub-firmware/pull/108,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/108,the strain2 now blinks differently if the ADC gets = 0. i also changed the configuration of onewire pins to attempt solving a very rare failure of the pgas,the strain2 now blinks differently if the ADC gets = 0. i also changed the configuration of onewire pins to attempt solving a very rare failure of the pgas,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,109,2020-03-15T20:33:46Z,2020-03-16T08:34:38Z,2020-04-01T11:19:57Z,MERGED,True,6072,6058,202,https://github.com/marcoaccame,preparation to split of embot,2,[],https://github.com/robotology/icub-firmware/pull/109,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/109,"this change is a preparation of a future split of embot between icub-firmware and icub-firmware-shared.
the split is required because there is further code which is required to share between icub-main and the ETH boards.
the embot library of classe is now divided in parts:

embot::core contains basic data structures and functions used by other namespeces.
embot::prot contains protocol data and classes for CAN protocol and soon for diagnostics over ETH protocol. it uses references to only embot::core
the other embot::hw, embot::os, embot::app are related only to embedded boards.

the change of embot has so far impact on the FW of: strain2, mtb4, psc, sg3, rfe and on nucleoh7 development board.
the embot objects have changed in reorganization of code in namespaces, name of files, et. but not in actual code manipulating peripheral or critical parts.
I have done extensive tests on the mtb4 and on nucleoh7 which should give enough reliability.","this change is a preparation of a future split of embot between icub-firmware and icub-firmware-shared.
the split is required because there is further code which is required to share between icub-main and the ETH boards.
the embot library of classe is now divided in parts:

embot::core contains basic data structures and functions used by other namespeces.
embot::prot contains protocol data and classes for CAN protocol and soon for diagnostics over ETH protocol. it uses references to only embot::core
the other embot::hw, embot::os, embot::app are related only to embedded boards.

the change of embot has so far impact on the FW of: strain2, mtb4, psc, sg3, rfe and on nucleoh7 development board.
the embot objects have changed in reorganization of code in namespaces, name of files, et. but not in actual code manipulating peripheral or critical parts.
I have done extensive tests on the mtb4 and on nucleoh7 which should give enough reliability.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,110,2020-03-17T18:14:20Z,2020-03-18T08:17:13Z,2020-03-18T08:17:28Z,MERGED,True,182,1717,50,https://github.com/marcoaccame,move of embot::core and embot::tools to icub-firmware-shared,4,[],https://github.com/robotology/icub-firmware/pull/110,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/110,"see the reasons of this change in robotology/icub-firmware-shared#32
this PR just splits in two the  embot library of classes for the embedded boards so that the required classes can be used also in the software parts of icub-head which talks to the boards.
in here I have adapted the projects of all boards using the embot to retrieve embot::core and embot::tools from icub-firmware-shared
the embedded boards can use embot in the following ways:

using the platform independent embot::core and classes / namespaces dependent only from that.
using the namespace embot::hw which requires the services of a HAL underneath (e.g., STM32HAL).
using the namespaces embot::os which requires the services of embot::hw and of an RTOS underneath.","see the reasons of this change in robotology/icub-firmware-shared#32
this PR just splits in two the  embot library of classes for the embedded boards so that the required classes can be used also in the software parts of icub-head which talks to the boards.
in here I have adapted the projects of all boards using the embot to retrieve embot::core and embot::tools from icub-firmware-shared
the embedded boards can use embot in the following ways:

using the platform independent embot::core and classes / namespaces dependent only from that.
using the namespace embot::hw which requires the services of a HAL underneath (e.g., STM32HAL).
using the namespaces embot::os which requires the services of embot::hw and of an RTOS underneath.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,112,2020-03-31T22:06:55Z,2020-04-01T11:55:15Z,2020-04-01T11:55:16Z,MERGED,True,2472,322,27,https://github.com/marcoaccame,support-to-diagnostic2,46,[],https://github.com/robotology/icub-firmware/pull/112,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/112,"the changes in this PR

maintain by default the standard robotoloy's behavior of the ETH boards.
add extra code to use the new diagnostic, named diagnostic2  when some macros are defined in dedicated uvproj projects .

The  standard robotoloy's behavior  of point 1 was verified on a setup formed by

a Linux PC acting as icub-head,
an ems board with FW compiled using this icub-firmware branch and robotology/icub-firmware-shared in devel.
a strain2 board

where it was launched yarprobotinterface with embObjStrain device.
Here are further details of the changes

guaranteed that ETH boards (ems, mc4plus, mc2plus) have the same behavior as robotology's ones, as long as it is used the standard projects: ems4rd.uvprojx, mc4plus.uvprojx and mc2plus.uvprojx
moved all diagnostic2 behavior into projects ems4rd.diagnostic2ready.uvprojx, mc4plus.diagnostic2ready.uvprojx
and mc2plus.diagnostic2ready.uvprojx.
allowed the diagnostic2ready projects to have three modes, configurable w/ macro definition

diagnostic2-disabled mode (default behavior)
diagnostic2-yri mode to yarprobotinterface only (w/ -DDIAGNOSTIC2_enabled -DDIAGNOSTIC2_send_to_yarprobotinterface)
diagnostic2-dd mode to diagnostic-daemon only (w/ -DDIAGNOSTIC2_enabled -DDIAGNOSTIC2_send_to_daemon)
diagnostic2-both mode to yarprobotinterface and to daemon (w/ -DDIAGNOSTIC2_enabled -DDIAGNOSTIC2_send_to_yarprobotinterface -DDIAGNOSTIC2_send_to_daemon)


added a macro named DIAGNOSTIC2_test_longbursts which when defined make theSTRAIN send long bursts of diagnostic errors.","the changes in this PR

maintain by default the standard robotoloy's behavior of the ETH boards.
add extra code to use the new diagnostic, named diagnostic2  when some macros are defined in dedicated uvproj projects .

The  standard robotoloy's behavior  of point 1 was verified on a setup formed by

a Linux PC acting as icub-head,
an ems board with FW compiled using this icub-firmware branch and robotology/icub-firmware-shared in devel.
a strain2 board

where it was launched yarprobotinterface with embObjStrain device.
Here are further details of the changes

guaranteed that ETH boards (ems, mc4plus, mc2plus) have the same behavior as robotology's ones, as long as it is used the standard projects: ems4rd.uvprojx, mc4plus.uvprojx and mc2plus.uvprojx
moved all diagnostic2 behavior into projects ems4rd.diagnostic2ready.uvprojx, mc4plus.diagnostic2ready.uvprojx
and mc2plus.diagnostic2ready.uvprojx.
allowed the diagnostic2ready projects to have three modes, configurable w/ macro definition

diagnostic2-disabled mode (default behavior)
diagnostic2-yri mode to yarprobotinterface only (w/ -DDIAGNOSTIC2_enabled -DDIAGNOSTIC2_send_to_yarprobotinterface)
diagnostic2-dd mode to diagnostic-daemon only (w/ -DDIAGNOSTIC2_enabled -DDIAGNOSTIC2_send_to_daemon)
diagnostic2-both mode to yarprobotinterface and to daemon (w/ -DDIAGNOSTIC2_enabled -DDIAGNOSTIC2_send_to_yarprobotinterface -DDIAGNOSTIC2_send_to_daemon)


added a macro named DIAGNOSTIC2_test_longbursts which when defined make theSTRAIN send long bursts of diagnostic errors.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,113,2020-04-01T10:59:05Z,2020-04-01T13:23:12Z,2020-04-01T13:23:13Z,MERGED,True,99,99,10,https://github.com/marcoaccame,strain2-FT-streaming-at-1khz,4,[],https://github.com/robotology/icub-firmware/pull/113,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/113,"This PR enables the strain2 to stream FT values at 1KHz.
That is achieved by setting the CPU clock at faster speed (80MHz instead of 16MHz) and using a slightly large averaging time for ADC (ADC_SAMPLETIME_12CYCLES_5 instead of ADC_SAMPLETIME_6CYCLES_5)  which reduce the averaging time of the ADC peripheral of a factor 2.5 which:

allows to complete acquisition of the six ADC values of the strain gauges to about 550 usec (it was abouth 1100 usec) allowing in such a way the tx rate to be every 1000 usec.
still allows a good averaging for noise removal

Comprehensive tests have been done on:

the correctness of the acquired values even with a reduced averaging time (brief of which you can read below)
coexistence of the FT @ 1 KHz with other sources of streaming (e.g., w/ IMU).","This PR enables the strain2 to stream FT values at 1KHz.
That is achieved by setting the CPU clock at faster speed (80MHz instead of 16MHz) and using a slightly large averaging time for ADC (ADC_SAMPLETIME_12CYCLES_5 instead of ADC_SAMPLETIME_6CYCLES_5)  which reduce the averaging time of the ADC peripheral of a factor 2.5 which:

allows to complete acquisition of the six ADC values of the strain gauges to about 550 usec (it was abouth 1100 usec) allowing in such a way the tx rate to be every 1000 usec.
still allows a good averaging for noise removal

Comprehensive tests have been done on:

the correctness of the acquired values even with a reduced averaging time (brief of which you can read below)
coexistence of the FT @ 1 KHz with other sources of streaming (e.g., w/ IMU).",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,113,2020-04-01T10:59:05Z,2020-04-01T13:23:12Z,2020-04-01T13:23:13Z,MERGED,True,99,99,10,https://github.com/marcoaccame,strain2-FT-streaming-at-1khz,4,[],https://github.com/robotology/icub-firmware/pull/113,https://github.com/traversaro,2,https://github.com/robotology/icub-firmware/pull/113#issuecomment-607182386,"This PR enables the strain2 to stream FT values at 1KHz.
That is achieved by setting the CPU clock at faster speed (80MHz instead of 16MHz) and using a slightly large averaging time for ADC (ADC_SAMPLETIME_12CYCLES_5 instead of ADC_SAMPLETIME_6CYCLES_5)  which reduce the averaging time of the ADC peripheral of a factor 2.5 which:

allows to complete acquisition of the six ADC values of the strain gauges to about 550 usec (it was abouth 1100 usec) allowing in such a way the tx rate to be every 1000 usec.
still allows a good averaging for noise removal

Comprehensive tests have been done on:

the correctness of the acquired values even with a reduced averaging time (brief of which you can read below)
coexistence of the FT @ 1 KHz with other sources of streaming (e.g., w/ IMU).",fyi @fjandrad @isorrentino @nunoguedelha @Gianlucamilani,True,{'HOORAY': ['https://github.com/fjandrad']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,116,2020-06-11T13:10:24Z,2020-06-11T13:11:35Z,2020-06-11T13:11:36Z,MERGED,True,1860,1884,21,https://github.com/marcoaccame,Feat/nucleoh7 exti,16,[],https://github.com/robotology/icub-firmware/pull/116,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/116,added exti + adc support for board nucleo-h7,added exti + adc support for board nucleo-h7,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,117,2020-07-24T07:52:19Z,2020-07-24T10:09:37Z,2020-07-24T10:09:38Z,MERGED,True,295,47,13,https://github.com/marcoaccame,feat/timesynch,6,[],https://github.com/robotology/icub-firmware/pull/117,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/117,"This PR is associated with a PR in icub-firmware-shared with the same name.
The purpose of these two joint PRs is to give to the ETH boards the possibility to synchronize their clock reference by means of suitable messages which carry the desired time in micro-seconds format.
See the PR for more details about what code is in icub-firmware-shared.
In icub-firmware there is the use of such messages by the boards ems, mc4plus, mc2plus.
The boards, by default, are able to decode them when they arrive to port 12345, which is the one used by yarprobotinterface. The produced binary has been tested to work successfully with  yarprobotinterface even if , so far, it does not manage the sending of these messages.
However, by special macro definition, it is possible to produce a binary which is able to decode the messages also when they arrive on port 11000. This port can be used by any process, maybe dedicated to the synchronization task of the embedded boards.
One of such processes is the diagnostic-daemon, which can be always running and is able to broadcast in the ETH network to port 11000 a time synchronization beacon which uses the set<..microsecondvalue> message with time aligned to Linux/YARP/NTP server. Details on the diagnostic-daemon will soon be available.
Just after the merging of this PR and of the PR, I shall produce the relevant binaries ems.hex, mc4plus.hex, mc2plus.hex in icub-firmware-build:devel able to decode from port 12345 and also from port 11000.","This PR is associated with a PR in icub-firmware-shared with the same name.
The purpose of these two joint PRs is to give to the ETH boards the possibility to synchronize their clock reference by means of suitable messages which carry the desired time in micro-seconds format.
See the PR for more details about what code is in icub-firmware-shared.
In icub-firmware there is the use of such messages by the boards ems, mc4plus, mc2plus.
The boards, by default, are able to decode them when they arrive to port 12345, which is the one used by yarprobotinterface. The produced binary has been tested to work successfully with  yarprobotinterface even if , so far, it does not manage the sending of these messages.
However, by special macro definition, it is possible to produce a binary which is able to decode the messages also when they arrive on port 11000. This port can be used by any process, maybe dedicated to the synchronization task of the embedded boards.
One of such processes is the diagnostic-daemon, which can be always running and is able to broadcast in the ETH network to port 11000 a time synchronization beacon which uses the set<..microsecondvalue> message with time aligned to Linux/YARP/NTP server. Details on the diagnostic-daemon will soon be available.
Just after the merging of this PR and of the PR, I shall produce the relevant binaries ems.hex, mc4plus.hex, mc2plus.hex in icub-firmware-build:devel able to decode from port 12345 and also from port 11000.",True,"{'ROCKET': ['https://github.com/S-Dafarra'], 'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/nunoguedelha']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,117,2020-07-24T07:52:19Z,2020-07-24T10:09:37Z,2020-07-24T10:09:38Z,MERGED,True,295,47,13,https://github.com/marcoaccame,feat/timesynch,6,[],https://github.com/robotology/icub-firmware/pull/117,https://github.com/traversaro,2,https://github.com/robotology/icub-firmware/pull/117#issuecomment-663405938,"This PR is associated with a PR in icub-firmware-shared with the same name.
The purpose of these two joint PRs is to give to the ETH boards the possibility to synchronize their clock reference by means of suitable messages which carry the desired time in micro-seconds format.
See the PR for more details about what code is in icub-firmware-shared.
In icub-firmware there is the use of such messages by the boards ems, mc4plus, mc2plus.
The boards, by default, are able to decode them when they arrive to port 12345, which is the one used by yarprobotinterface. The produced binary has been tested to work successfully with  yarprobotinterface even if , so far, it does not manage the sending of these messages.
However, by special macro definition, it is possible to produce a binary which is able to decode the messages also when they arrive on port 11000. This port can be used by any process, maybe dedicated to the synchronization task of the embedded boards.
One of such processes is the diagnostic-daemon, which can be always running and is able to broadcast in the ETH network to port 11000 a time synchronization beacon which uses the set<..microsecondvalue> message with time aligned to Linux/YARP/NTP server. Details on the diagnostic-daemon will soon be available.
Just after the merging of this PR and of the PR, I shall produce the relevant binaries ems.hex, mc4plus.hex, mc2plus.hex in icub-firmware-build:devel able to decode from port 12345 and also from port 11000.",Fyi @robotology/iit-dynamic-interaction-control,True,{'THUMBS_UP': ['https://github.com/diegoferigo']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,118,2020-07-24T11:36:46Z,2020-07-24T14:04:10Z,2020-07-24T14:04:11Z,MERGED,True,1323764,374,959,https://github.com/marcoaccame,board/pmc,26,[],https://github.com/robotology/icub-firmware/pull/118,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/118,"This PR starts support for the new pmc board.
The pmc board will be available in September 2020 for its use in iCub's new hand. It is based onto a MPU of the STM32G4 family from STMicroelectronics.
This branch was created to start development on such an MPU, at first with the associated evaluation board stm32g4eval then directly on the pmc board.
For this MPU we don't have much yet, hence we had to start support from scratch. What we did is:
for board stm32g4eval:

built a stm32hal.lib library for the board stm32g4eval. We started from cube-mx.
produced a simple bare-metal project for the board which uses the stm32hal.lib to ... blink a LED and print on the trace port. tested and works.
produced an embot::osproject whuch initially did the same thing but in a multi-thread environment. The benefit is that with a limited amount of adaptation we can then exploit the functionalities  embot C++ library of classes (CAN communication and protocol handling, device drivers for some chips etc).

The embot support was initially for the basic functionalities required to blink a LED in a multi-thread environment: embot::core, embot::hw::lowlevel, embot::hw::bsp, embot::hw::gpio, embot::hw::led, embot::os, ... so that we could use embot::app::theLEDmanager. tested and works.
Later we added embot::hw::tlv493d and embot::hw::tlv493d so that we could validate the newly arrived fap board which mounts a tlv493d chip available through I2C. tested and works.


produced a cmsisos2 project. cmisos2 is a new RTOS which is the evolution of the one used inside our osal. this project is just for test in view of an imminent support of cmisos2 inside embot::os. More details on cmsisos2 in a new imminent PR.
mild cleaning of embot::hw::can driver for putting placeholders of FDCAN support. The aim is the have a single driver for both CAN (as used in mtb4 and strain2, ...`) and FDCAN peripherals. The FDCAN is the new peripheral available in STM32G4 and STM32H7 MPUs which will be used onto the new iCub's hand. In this PR there is not yet any FDCAN support. More details in a future PR.

for board pmc:

built a stm32hal.lib library for the board pmc. We started from cube-mx.
produced two projects for board pmc which link the proper stm32hal.lib: one bare-metal and the other with embot::os. They will be tested when the board arrives in September.","This PR starts support for the new pmc board.
The pmc board will be available in September 2020 for its use in iCub's new hand. It is based onto a MPU of the STM32G4 family from STMicroelectronics.
This branch was created to start development on such an MPU, at first with the associated evaluation board stm32g4eval then directly on the pmc board.
For this MPU we don't have much yet, hence we had to start support from scratch. What we did is:
for board stm32g4eval:

built a stm32hal.lib library for the board stm32g4eval. We started from cube-mx.
produced a simple bare-metal project for the board which uses the stm32hal.lib to ... blink a LED and print on the trace port. tested and works.
produced an embot::osproject whuch initially did the same thing but in a multi-thread environment. The benefit is that with a limited amount of adaptation we can then exploit the functionalities  embot C++ library of classes (CAN communication and protocol handling, device drivers for some chips etc).

The embot support was initially for the basic functionalities required to blink a LED in a multi-thread environment: embot::core, embot::hw::lowlevel, embot::hw::bsp, embot::hw::gpio, embot::hw::led, embot::os, ... so that we could use embot::app::theLEDmanager. tested and works.
Later we added embot::hw::tlv493d and embot::hw::tlv493d so that we could validate the newly arrived fap board which mounts a tlv493d chip available through I2C. tested and works.


produced a cmsisos2 project. cmisos2 is a new RTOS which is the evolution of the one used inside our osal. this project is just for test in view of an imminent support of cmisos2 inside embot::os. More details on cmsisos2 in a new imminent PR.
mild cleaning of embot::hw::can driver for putting placeholders of FDCAN support. The aim is the have a single driver for both CAN (as used in mtb4 and strain2, ...`) and FDCAN peripherals. The FDCAN is the new peripheral available in STM32G4 and STM32H7 MPUs which will be used onto the new iCub's hand. In this PR there is not yet any FDCAN support. More details in a future PR.

for board pmc:

built a stm32hal.lib library for the board pmc. We started from cube-mx.
produced two projects for board pmc which link the proper stm32hal.lib: one bare-metal and the other with embot::os. They will be tested when the board arrives in September.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,119,2020-07-31T12:38:11Z,2020-07-31T14:50:41Z,2020-07-31T14:50:43Z,MERGED,True,15232,3372,171,https://github.com/marcoaccame,feat/embot-os-cmsisos2,17,[],https://github.com/robotology/icub-firmware/pull/119,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/119,"This PR introduces the use of the CMSIS-RTOS2 in embot::os.
This new RTOS is required because arm KEIL recommends it for new developments and we shall soon need to integrate arm KEIL solutions, namely its most recent IP stack, in a new ETH board for the new iCub's forearm.
So far, the ETH boards and the CAN boards based on embot (strain2, mtb4, etc.) have all used multi-threading RTOS services offered by the osal library. Even if quite old, the osal has demonstrated working very well, hence we still want using it for legacy boards.
For this reason, I have refactored the embot::os namespace so that both RTOS dependencies are incapsulated inside embot::os::rtos.
By defining proper macros (EMBOT_USE_rtos_osal and EMBOT_USE_rtos_cmsios2) we can activate either the osal or the cmsisos2 RTOS.
We have done extensive tests for both RTOS modes on some legacy boards and on a new development board: everything works fine.
In particular,

the legacy CAN boards strain2 and mtb4 correctly run the bootloader and the application with both RTOS modes.
the new stm32g4eval board correctly runs a demo program with both RTOS modes.

The default RTOS mode will be EMBOT_USE_rtos_osal, so that the legacy embot-based boards will keep using osal.
The mode EMBOT_USE_rtos_cmsios2 will be used for all new developments.
NOTE: the ETH boards don't use embot::os, hence are not touched by this PR.","This PR introduces the use of the CMSIS-RTOS2 in embot::os.
This new RTOS is required because arm KEIL recommends it for new developments and we shall soon need to integrate arm KEIL solutions, namely its most recent IP stack, in a new ETH board for the new iCub's forearm.
So far, the ETH boards and the CAN boards based on embot (strain2, mtb4, etc.) have all used multi-threading RTOS services offered by the osal library. Even if quite old, the osal has demonstrated working very well, hence we still want using it for legacy boards.
For this reason, I have refactored the embot::os namespace so that both RTOS dependencies are incapsulated inside embot::os::rtos.
By defining proper macros (EMBOT_USE_rtos_osal and EMBOT_USE_rtos_cmsios2) we can activate either the osal or the cmsisos2 RTOS.
We have done extensive tests for both RTOS modes on some legacy boards and on a new development board: everything works fine.
In particular,

the legacy CAN boards strain2 and mtb4 correctly run the bootloader and the application with both RTOS modes.
the new stm32g4eval board correctly runs a demo program with both RTOS modes.

The default RTOS mode will be EMBOT_USE_rtos_osal, so that the legacy embot-based boards will keep using osal.
The mode EMBOT_USE_rtos_cmsios2 will be used for all new developments.
NOTE: the ETH boards don't use embot::os, hence are not touched by this PR.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,120,2020-08-06T11:51:00Z,2020-08-06T12:04:30Z,2020-08-06T12:17:32Z,MERGED,True,84,40,8,https://github.com/marcoaccame,feat/adcstrain2-get-all,2,[],https://github.com/robotology/icub-firmware/pull/120,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/120,"Basic Description
This PR introduces a backward-compatible enhancement for the CAN message GET_CH_ADC when managed by board strain2.
If the field CHN of this message is 0x0f, then the board strain2 interprets it as StrainChannel::all and sends back a burst of six messages with the values of the size ADC channels.
For more details see section 3.3.2 3.3.2 Messages for managing the FT and HES data service of document TSD-ICUBUNIT-canprotocol-sensorboards
Use case
An agent wants to retrieve in polling mode the 6 values of the ADC with minimal jitters time.
In the past, one had to send six separate GET_CH_ADC  commands. That resulted in a complete operation executed in longer time (> 3 ms) and with values coming from separated ADC acquisitions. If one wanted values from a single acquisition teh only ways was to use the streaming mode with messages such as set tx rate, start tx and eventually stop message.
Now a single request is enough. All values come from a single ADC acquisition and the measured jitters time as measured w/ CANreal is 920 usec. This time is equal to time to send the single GET_CH_ADC  request +  ADC acquisition time + time to send back the six replies.
See picture where the request command is highlighted.

Compatibility issues
The request message GET_CH_ADC  keeps the same format. It only has an extra possible value in field CHN. If this values is 0xF it is normally discarded by every board but strain2 boards w/ version >= 2.08 (soon in icub-firmware-build:devel). Values from 0 to 5 are normally managed as before.
The reply messages are unchanged.","Basic Description
This PR introduces a backward-compatible enhancement for the CAN message GET_CH_ADC when managed by board strain2.
If the field CHN of this message is 0x0f, then the board strain2 interprets it as StrainChannel::all and sends back a burst of six messages with the values of the size ADC channels.
For more details see section 3.3.2 3.3.2 Messages for managing the FT and HES data service of document TSD-ICUBUNIT-canprotocol-sensorboards
Use case
An agent wants to retrieve in polling mode the 6 values of the ADC with minimal jitters time.
In the past, one had to send six separate GET_CH_ADC  commands. That resulted in a complete operation executed in longer time (> 3 ms) and with values coming from separated ADC acquisitions. If one wanted values from a single acquisition teh only ways was to use the streaming mode with messages such as set tx rate, start tx and eventually stop message.
Now a single request is enough. All values come from a single ADC acquisition and the measured jitters time as measured w/ CANreal is 920 usec. This time is equal to time to send the single GET_CH_ADC  request +  ADC acquisition time + time to send back the six replies.
See picture where the request command is highlighted.

Compatibility issues
The request message GET_CH_ADC  keeps the same format. It only has an extra possible value in field CHN. If this values is 0xF it is normally discarded by every board but strain2 boards w/ version >= 2.08 (soon in icub-firmware-build:devel). Values from 0 to 5 are normally managed as before.
The reply messages are unchanged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,120,2020-08-06T11:51:00Z,2020-08-06T12:04:30Z,2020-08-06T12:17:32Z,MERGED,True,84,40,8,https://github.com/marcoaccame,feat/adcstrain2-get-all,2,[],https://github.com/robotology/icub-firmware/pull/120,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/120#issuecomment-669892166,"Basic Description
This PR introduces a backward-compatible enhancement for the CAN message GET_CH_ADC when managed by board strain2.
If the field CHN of this message is 0x0f, then the board strain2 interprets it as StrainChannel::all and sends back a burst of six messages with the values of the size ADC channels.
For more details see section 3.3.2 3.3.2 Messages for managing the FT and HES data service of document TSD-ICUBUNIT-canprotocol-sensorboards
Use case
An agent wants to retrieve in polling mode the 6 values of the ADC with minimal jitters time.
In the past, one had to send six separate GET_CH_ADC  commands. That resulted in a complete operation executed in longer time (> 3 ms) and with values coming from separated ADC acquisitions. If one wanted values from a single acquisition teh only ways was to use the streaming mode with messages such as set tx rate, start tx and eventually stop message.
Now a single request is enough. All values come from a single ADC acquisition and the measured jitters time as measured w/ CANreal is 920 usec. This time is equal to time to send the single GET_CH_ADC  request +  ADC acquisition time + time to send back the six replies.
See picture where the request command is highlighted.

Compatibility issues
The request message GET_CH_ADC  keeps the same format. It only has an extra possible value in field CHN. If this values is 0xF it is normally discarded by every board but strain2 boards w/ version >= 2.08 (soon in icub-firmware-build:devel). Values from 0 to 5 are normally managed as before.
The reply messages are unchanged.",added the binary for the strain2 board,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,123,2020-08-07T10:25:21Z,2020-08-07T10:39:26Z,2020-08-07T10:39:27Z,MERGED,True,1132,445,40,https://github.com/marcoaccame,separation of embot::os from embot::hw,1,[],https://github.com/robotology/icub-firmware/pull/123,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/123,"Object of the PR
This PR is required so that we have a better separation of embot::os from embot::w.
So far, we could use embot::os only in boards where a full embot::hw based onto stm32hal.lib was also used.
The minimum required of embot::hw was surely embot::hw::bsp, embot::hw::sys, embot::hw::lowlevel. Maybe also embot::hw::gpio and embot::hw::led are needed because ... we surely like to blink a LED the first time a board gets alive .
Now, the above namespaces are tightly coupled to the API of stm32hal as generated by cube-mx.
However, we need to use the embot::os also on some legacy boards such as ems, mc4plus, mc2plus where we don't
have  stm32hal.lib.
For this reason, here is this work. More details of the changes are in the commit logs.
Tests
All embot-based projects have been tested and they compile.
Also tested some projects to run on real boards. I have used: strain2, nucleoh7and stm32g4eval so that we have all MPUs tested. They run OK.
Tested also the use of embot::core and embot::os on the ems board which uses the hal.lib. The program eUpdater runs smoothly and talks to FirmwareUpdater. This code however, will be subject of a next imminent PR.","Object of the PR
This PR is required so that we have a better separation of embot::os from embot::w.
So far, we could use embot::os only in boards where a full embot::hw based onto stm32hal.lib was also used.
The minimum required of embot::hw was surely embot::hw::bsp, embot::hw::sys, embot::hw::lowlevel. Maybe also embot::hw::gpio and embot::hw::led are needed because ... we surely like to blink a LED the first time a board gets alive .
Now, the above namespaces are tightly coupled to the API of stm32hal as generated by cube-mx.
However, we need to use the embot::os also on some legacy boards such as ems, mc4plus, mc2plus where we don't
have  stm32hal.lib.
For this reason, here is this work. More details of the changes are in the commit logs.
Tests
All embot-based projects have been tested and they compile.
Also tested some projects to run on real boards. I have used: strain2, nucleoh7and stm32g4eval so that we have all MPUs tested. They run OK.
Tested also the use of embot::core and embot::os on the ems board which uses the hal.lib. The program eUpdater runs smoothly and talks to FirmwareUpdater. This code however, will be subject of a next imminent PR.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,124,2020-08-18T13:41:44Z,2020-08-18T13:44:30Z,2020-08-18T13:44:31Z,MERGED,True,9,9,9,https://github.com/marcoaccame,fix/canframedecoding,2,[],https://github.com/robotology/icub-firmware/pull/124,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/124,"This PR is required because of a bug on the size of the received can frame in embot-based boards (strain2, mtb4, rfe, psc and sg3) for which size was erroneously set always equal 8.
This bug affects only the correct decoding of the CAN message bootloader::DATA which is used by bootloader and updaterofbootloader.
For this reason I have also released new versions for bootloader and updaterofbootloader of the above boards.","This PR is required because of a bug on the size of the received can frame in embot-based boards (strain2, mtb4, rfe, psc and sg3) for which size was erroneously set always equal 8.
This bug affects only the correct decoding of the CAN message bootloader::DATA which is used by bootloader and updaterofbootloader.
For this reason I have also released new versions for bootloader and updaterofbootloader of the above boards.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,125,2020-08-18T15:36:39Z,2020-08-31T13:45:23Z,2020-08-31T13:45:24Z,MERGED,True,1451437,0,1464,https://github.com/davidetome,bdc bcb and bat fw migration,2,[],https://github.com/robotology/icub-firmware/pull/125,https://github.com/davidetome,1,https://github.com/robotology/icub-firmware/pull/125,#121,#121,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,126,2020-09-03T12:48:27Z,2020-09-03T12:49:19Z,2020-09-03T12:49:20Z,MERGED,True,1390,299,14,https://github.com/marcoaccame,extension of embot::hw::i2c driver,4,[],https://github.com/robotology/icub-firmware/pull/126,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/126,"This PR introduces an extension of the embot::hw::i2c driver so that it can manage chips with registers mapped in both 8 bits space and 16 bit space.
This feature is required to manage the driver of the CDC chip AD7147 used to manage the skin patches","This PR introduces an extension of the embot::hw::i2c driver so that it can manage chips with registers mapped in both 8 bits space and 16 bit space.
This feature is required to manage the driver of the CDC chip AD7147 used to manage the skin patches",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,127,2020-09-09T13:27:15Z,2020-09-09T13:27:47Z,2020-09-09T13:27:48Z,MERGED,True,14458,18,42,https://github.com/marcoaccame,feat/embot-updater,5,[],https://github.com/robotology/icub-firmware/pull/127,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/127,"This PR enables the eUpdater running on the ems board to use the embot library of C++ classes.
This new program is called eUpdater-embot and uses a dedicted project and (so far) partially duplicated files.
This program is a demo UDP application which acts as an intermediate step to allow the reuse of the code of programs running on the ems (eLoader, eUpdater, eApplication) on a new MPU where we shall use cubemx-generated stm32hal library for hardware abstraction layer and the embot for os and utility services.
For this demo UDP application i had to remove osal (the OS abstraction layer used in the ETH baords) and adapt the use of embot::os namespace.
I have written alternative implementations of some objects (EOMmutex, EOMtask,  EOMtheCallbackManager, EOMtheSystem and EOMtheTimerManager) which is used only if the project explicitly use it. They use embot::os::Thread, etc.
For them, ther is no danger that these implementation affect the legacy code running on the ETH boards: we don't explicitly comple them.
However, I had also to modify the EOMtheIPnet object which is the core of our IP communication.
The intervention on  EOMtheIPnet  just removes the osal calls and changes with the relevant calls inside embot::os::rtos, as in the following code excerpt.
#if !defined(EMBOBJ_USE_EMBOT)
#include ""osal.h""
#else
#include ""embot_os_rtos.h""
#endif // #if !defined(EMBOBJ_USE_EMBOT)

...

    // i get cmd.blockingsemaphore, initted with zero tokens
#if !defined(EMBOBJ_USE_EMBOT)    
    s_eom_theipnet.cmd.blockingsemaphore = osal_semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
#else
    s_eom_theipnet.cmd.blockingsemaphore = embot::os::rtos::semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
#endif // #if !defined(EMBOBJ_USE_EMBOT)

...

Its modifications are triggered only if macro EMBOBJ_USE_EMBOT is defined., so that legacy projects are not affected.
Nevertheless, tests were required to insure no effect on legacy code.
The tests have shown that both the legacy eUpdater and the eUpdater-embot work fine.
They successfully:

talk to FirmwareUpdater,
perform a CAN firmware update of a strain2 board,
jump to application and maintenance mode,
perform other maintenance operations.

I have also tested the ems application compiled with the new EOMtheIPnet.c but with EMBOBJ_USE_EMBOT undefined and it works just fine.
I can say that we are ready to merge into devel.","This PR enables the eUpdater running on the ems board to use the embot library of C++ classes.
This new program is called eUpdater-embot and uses a dedicted project and (so far) partially duplicated files.
This program is a demo UDP application which acts as an intermediate step to allow the reuse of the code of programs running on the ems (eLoader, eUpdater, eApplication) on a new MPU where we shall use cubemx-generated stm32hal library for hardware abstraction layer and the embot for os and utility services.
For this demo UDP application i had to remove osal (the OS abstraction layer used in the ETH baords) and adapt the use of embot::os namespace.
I have written alternative implementations of some objects (EOMmutex, EOMtask,  EOMtheCallbackManager, EOMtheSystem and EOMtheTimerManager) which is used only if the project explicitly use it. They use embot::os::Thread, etc.
For them, ther is no danger that these implementation affect the legacy code running on the ETH boards: we don't explicitly comple them.
However, I had also to modify the EOMtheIPnet object which is the core of our IP communication.
The intervention on  EOMtheIPnet  just removes the osal calls and changes with the relevant calls inside embot::os::rtos, as in the following code excerpt.
#if !defined(EMBOBJ_USE_EMBOT)
#include ""osal.h""
#else
#include ""embot_os_rtos.h""
#endif // #if !defined(EMBOBJ_USE_EMBOT)

...

    // i get cmd.blockingsemaphore, initted with zero tokens
#if !defined(EMBOBJ_USE_EMBOT)    
    s_eom_theipnet.cmd.blockingsemaphore = osal_semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
#else
    s_eom_theipnet.cmd.blockingsemaphore = embot::os::rtos::semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
#endif // #if !defined(EMBOBJ_USE_EMBOT)

...

Its modifications are triggered only if macro EMBOBJ_USE_EMBOT is defined., so that legacy projects are not affected.
Nevertheless, tests were required to insure no effect on legacy code.
The tests have shown that both the legacy eUpdater and the eUpdater-embot work fine.
They successfully:

talk to FirmwareUpdater,
perform a CAN firmware update of a strain2 board,
jump to application and maintenance mode,
perform other maintenance operations.

I have also tested the ems application compiled with the new EOMtheIPnet.c but with EMBOBJ_USE_EMBOT undefined and it works just fine.
I can say that we are ready to merge into devel.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,128,2020-09-09T13:50:31Z,2020-09-09T13:51:37Z,2020-09-09T13:51:38Z,MERGED,True,8882,408,19,https://github.com/marcoaccame,feat/fdcandriver,5,[],https://github.com/robotology/icub-firmware/pull/128,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/128,"This PR introduces an improvement of the embot::hw::can driver so that it can work with FDCAN peripherals still maintaining teh same high level API.
This feature is required for imminent board pmc used in the new version of the hand.
The driver has code which does different low level calls to the STM32 relevant HAL depending on a macro definition. See code excerpt below.
static void can::RX_IRQdisable(embot::hw::CAN p)
{
    std::uint8_t index = embot::core::tointegral(p);
#if defined(HAL_CAN_MODULE_ENABLED)
    HAL_CAN_DeactivateNotification(_candata_array[index].handle, CAN_IT_RX_FIFO0_MSG_PENDING);
#elif defined(HAL_FDCAN_MODULE_ENABLED)  
    #warning TODO: ... check it   
    HAL_FDCAN_DeactivateNotification(_candata_array[index].handle, FDCAN_IT_RX_FIFO0_NEW_MESSAGE); 
#endif        
}

For the case of legacy CAN boards (strain2, mtb4, etc.) the code under the HAL_CAN_MODULE_ENABLED is more or less unchanged.
Nevertheless I tested the new driver on the strain2 board building a new bootloader and application and running on it a firmware upgrade through an ems using FirmwareUpdater.
The operation was successful.
Than means to me that the changes of teh embot::hw::can can be taken into devel even if the tests for the case of HAL_FDCAN_MODULE_ENABLED are not yet completed.","This PR introduces an improvement of the embot::hw::can driver so that it can work with FDCAN peripherals still maintaining teh same high level API.
This feature is required for imminent board pmc used in the new version of the hand.
The driver has code which does different low level calls to the STM32 relevant HAL depending on a macro definition. See code excerpt below.
static void can::RX_IRQdisable(embot::hw::CAN p)
{
    std::uint8_t index = embot::core::tointegral(p);
#if defined(HAL_CAN_MODULE_ENABLED)
    HAL_CAN_DeactivateNotification(_candata_array[index].handle, CAN_IT_RX_FIFO0_MSG_PENDING);
#elif defined(HAL_FDCAN_MODULE_ENABLED)  
    #warning TODO: ... check it   
    HAL_FDCAN_DeactivateNotification(_candata_array[index].handle, FDCAN_IT_RX_FIFO0_NEW_MESSAGE); 
#endif        
}

For the case of legacy CAN boards (strain2, mtb4, etc.) the code under the HAL_CAN_MODULE_ENABLED is more or less unchanged.
Nevertheless I tested the new driver on the strain2 board building a new bootloader and application and running on it a firmware upgrade through an ems using FirmwareUpdater.
The operation was successful.
Than means to me that the changes of teh embot::hw::can can be taken into devel even if the tests for the case of HAL_FDCAN_MODULE_ENABLED are not yet completed.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,129,2020-09-15T06:45:20Z,2020-09-15T08:49:40Z,2020-09-15T11:13:02Z,MERGED,True,14834,55,47,https://github.com/marcoaccame,embot-udp-comm: first steps,9,[],https://github.com/robotology/icub-firmware/pull/129,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/129,"This PR introduces two projects for UDP communication which use the embot plus the stm32hal library. One is already working on the ems board, the other is the starting point of the development of UDP stack to a new MPU.
Both projects run the same program eUpdater which is used to perform maintenance and FW update over UDP by means of the FirmwareUpdater.
The two projects are:


eUpdater-embot-ems running on the ems board. This code effectively talks over UDP with the FirmwareUpdater. It will be the golden reference for the development.


eUpdater-embot-stm32g4eval running on the evaluation board stm32g4eval.  This code is very similar to the code of the above project  but does not yet talk over UDP. It will be the starting point of the development.


The changes in this PR do not modify the behavior of the legacy code. I have tested the correct behaviour of the eUpdater and eApplication of the ems board.
Hence, the merge into devel will not have any side effect.
More on the the project eUpdater-embot-ems
The purpose of the first project eUpdater-embot-ems is to be the golden reference for the development of UDP communication on a ST's MPU of latest generation, the STM32H757XI, for which we use the HAL code generated by cube-mx wrapped around stm32hal and the embot library of classes.
The project eUpdater-embot-ems is a derivation of the eUpdater project which we have used so far for the maintainance and fw update of the ems, a board based onto the STM32F407.
The legacy project eUpdater uses an abstraction layer formed by hal, osal and ipal plus the embobj C objects which add functionalities to the above abstraction layer.
The emboj code is inside two different repositories: in icub-firmware-shared there is code used in embedded boards and also in high level applications and in icub-firmware there is code used exclusively in embedded boards.
However, the code partitioning of the legacy eUpdater does not use the development approach we have introduced later on which starts with cube-mx which generates the ST's HAL which we wrap inside the stm32hal library  and the use of  the embot library of C++ classes for RTOS  with the embot::os namespace and HW drivers with the embot::hw.
here in the following table are the major differences between the legacy and the new mode.



legacy embobj mode
new embot mode




It is based onto C code developed on top of abstratcion layers for HW and RTOS. Here are the main modules.
It is based onto the HAL generated by cube-MX which is just compiled into a library and on C++ code developed on top. Here are the main modules.


hal.lib
stm32hal.lib which wraps ST's HAL generated by cubeMX + embot::hw which implements more complex drivers


osal.lib
embot::os::rtos which wraps either osal or latest cmsis-os2 depending on a macro definition.


the EOMx C objects such as EOMtask etc.
embot::os namespace which contains for instance embot::os::Thread, etc.







As the legacy eUpdater  is so much different from the development mode we are using now, we needed a program running on the same board and offering the same functionalities and with as much as possible the same code as the legacy eUpdater  but using the new code architecture.
The project  eUpdater-embot-ems is the result of this effort.
hence I:

added the embot library,
added a fake stm32hal library (as its purpose is already done by the hal library),
modified some embobj modules to use the embot underneath.

The changes to the embobj are very limited and are those in icub-firmware repo. In particular:


i refactored the code in EOMtheIPnet.c so that it can use either the osal code or the embot::os::rtos code depending on the value of macro EMBOBJ_USE_EMBOT, but left unchanged their API. The legacy projects do not define this macro and have the same behavior as before. See code excerpt for an example.
  ...

  #if !defined(EMBOBJ_USE_EMBOT)
  #include ""osal.h""
  #else
  #include ""embot_core.h""
  #include ""embot_os_rtos.h""
  //#define USE_EMBOT_PRINT
  #endif // #if !defined(EMBOBJ_USE_EMBOT)

  ...

      // i get cmd.blockingsemaphore, initted with zero tokens
  #if !defined(EMBOBJ_USE_EMBOT)    
      s_eom_theipnet.cmd.blockingsemaphore = osal_semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
  #else
      s_eom_theipnet.cmd.blockingsemaphore = embot::os::rtos::semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
  #endif // #if !defined(EMBOBJ_USE_EMBOT)
  ...



i added alternative implementations of modules EOMtheSystem, EOMmutex, EOMtask, EOMtheCallbackManager, EOMtheTimerManager, but left unchanged their API. The legacy project use the same code as now and only the new projects use the new implementation. See a code excerpt of teh new implementation.
  ...
  extern EOMtask * eom_task_New(eOmtaskType_t type, uint8_t priority, uint16_t stacksize,
                                         void (*startup_fn)(EOMtask *tsk, uint32_t zero),
                                         void (*run_fn)(EOMtask *tsk, uint32_t evtmsgper), 
                                         uint32_t queuesizeORalleventsmask, eOreltime_t timeoutORperiod,
                                         void *extdata,
                                         void (*nameofthetask_fn)(void *tsk),
                                         const char *name
                                         )

  {
      
      EOMtask *task = nullptr;
      
      switch(type)
      {
          case eom_mtask_EventDriven:
          {
              task = new EOMtask;
              task->thr = new embot::os::EventThread;            
          } break;
          
          case eom_mtask_MessageDriven:
          {
              task = new EOMtask;
              task->thr = new embot::os::MessageThread;        
          } break;
  ...


More on the project eUpdater-embot-stm32g4eval
This project is just a porting of the above project onto a development board of latest generation, the stm32g4eval.
It would have been better using the final board stm32h757eval which has ETH peripheral, but ... at the time of the development this board did not work properly so I moved to another already available.
The main differences between this project and the eUpdater-embot-ems are:

it changes the hal with stm32hal plus some code in embot::hw.
it does not have yet implemented the hal_eth_* functions
it does not yet have UDP communication

Future developments
We want to replicate the same behavior of the eUpdater-embot-ems on the board  stm32h757eval starting from the project eUpdater-embot-stm32g4eval.
P.S. After the merge I corrected the URLs to point to -/tree/devel/- rather than to the now not existing `-/tree/feat/udpcomm/-'","This PR introduces two projects for UDP communication which use the embot plus the stm32hal library. One is already working on the ems board, the other is the starting point of the development of UDP stack to a new MPU.
Both projects run the same program eUpdater which is used to perform maintenance and FW update over UDP by means of the FirmwareUpdater.
The two projects are:


eUpdater-embot-ems running on the ems board. This code effectively talks over UDP with the FirmwareUpdater. It will be the golden reference for the development.


eUpdater-embot-stm32g4eval running on the evaluation board stm32g4eval.  This code is very similar to the code of the above project  but does not yet talk over UDP. It will be the starting point of the development.


The changes in this PR do not modify the behavior of the legacy code. I have tested the correct behaviour of the eUpdater and eApplication of the ems board.
Hence, the merge into devel will not have any side effect.
More on the the project eUpdater-embot-ems
The purpose of the first project eUpdater-embot-ems is to be the golden reference for the development of UDP communication on a ST's MPU of latest generation, the STM32H757XI, for which we use the HAL code generated by cube-mx wrapped around stm32hal and the embot library of classes.
The project eUpdater-embot-ems is a derivation of the eUpdater project which we have used so far for the maintainance and fw update of the ems, a board based onto the STM32F407.
The legacy project eUpdater uses an abstraction layer formed by hal, osal and ipal plus the embobj C objects which add functionalities to the above abstraction layer.
The emboj code is inside two different repositories: in icub-firmware-shared there is code used in embedded boards and also in high level applications and in icub-firmware there is code used exclusively in embedded boards.
However, the code partitioning of the legacy eUpdater does not use the development approach we have introduced later on which starts with cube-mx which generates the ST's HAL which we wrap inside the stm32hal library  and the use of  the embot library of C++ classes for RTOS  with the embot::os namespace and HW drivers with the embot::hw.
here in the following table are the major differences between the legacy and the new mode.



legacy embobj mode
new embot mode




It is based onto C code developed on top of abstratcion layers for HW and RTOS. Here are the main modules.
It is based onto the HAL generated by cube-MX which is just compiled into a library and on C++ code developed on top. Here are the main modules.


hal.lib
stm32hal.lib which wraps ST's HAL generated by cubeMX + embot::hw which implements more complex drivers


osal.lib
embot::os::rtos which wraps either osal or latest cmsis-os2 depending on a macro definition.


the EOMx C objects such as EOMtask etc.
embot::os namespace which contains for instance embot::os::Thread, etc.







As the legacy eUpdater  is so much different from the development mode we are using now, we needed a program running on the same board and offering the same functionalities and with as much as possible the same code as the legacy eUpdater  but using the new code architecture.
The project  eUpdater-embot-ems is the result of this effort.
hence I:

added the embot library,
added a fake stm32hal library (as its purpose is already done by the hal library),
modified some embobj modules to use the embot underneath.

The changes to the embobj are very limited and are those in icub-firmware repo. In particular:


i refactored the code in EOMtheIPnet.c so that it can use either the osal code or the embot::os::rtos code depending on the value of macro EMBOBJ_USE_EMBOT, but left unchanged their API. The legacy projects do not define this macro and have the same behavior as before. See code excerpt for an example.
  ...

  #if !defined(EMBOBJ_USE_EMBOT)
  #include ""osal.h""
  #else
  #include ""embot_core.h""
  #include ""embot_os_rtos.h""
  //#define USE_EMBOT_PRINT
  #endif // #if !defined(EMBOBJ_USE_EMBOT)

  ...

      // i get cmd.blockingsemaphore, initted with zero tokens
  #if !defined(EMBOBJ_USE_EMBOT)    
      s_eom_theipnet.cmd.blockingsemaphore = osal_semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
  #else
      s_eom_theipnet.cmd.blockingsemaphore = embot::os::rtos::semaphore_new(_MAXTOKENS_SEM_CMD_, 0);
  #endif // #if !defined(EMBOBJ_USE_EMBOT)
  ...



i added alternative implementations of modules EOMtheSystem, EOMmutex, EOMtask, EOMtheCallbackManager, EOMtheTimerManager, but left unchanged their API. The legacy project use the same code as now and only the new projects use the new implementation. See a code excerpt of teh new implementation.
  ...
  extern EOMtask * eom_task_New(eOmtaskType_t type, uint8_t priority, uint16_t stacksize,
                                         void (*startup_fn)(EOMtask *tsk, uint32_t zero),
                                         void (*run_fn)(EOMtask *tsk, uint32_t evtmsgper), 
                                         uint32_t queuesizeORalleventsmask, eOreltime_t timeoutORperiod,
                                         void *extdata,
                                         void (*nameofthetask_fn)(void *tsk),
                                         const char *name
                                         )

  {
      
      EOMtask *task = nullptr;
      
      switch(type)
      {
          case eom_mtask_EventDriven:
          {
              task = new EOMtask;
              task->thr = new embot::os::EventThread;            
          } break;
          
          case eom_mtask_MessageDriven:
          {
              task = new EOMtask;
              task->thr = new embot::os::MessageThread;        
          } break;
  ...


More on the project eUpdater-embot-stm32g4eval
This project is just a porting of the above project onto a development board of latest generation, the stm32g4eval.
It would have been better using the final board stm32h757eval which has ETH peripheral, but ... at the time of the development this board did not work properly so I moved to another already available.
The main differences between this project and the eUpdater-embot-ems are:

it changes the hal with stm32hal plus some code in embot::hw.
it does not have yet implemented the hal_eth_* functions
it does not yet have UDP communication

Future developments
We want to replicate the same behavior of the eUpdater-embot-ems on the board  stm32h757eval starting from the project eUpdater-embot-stm32g4eval.
P.S. After the merge I corrected the URLs to point to -/tree/devel/- rather than to the now not existing `-/tree/feat/udpcomm/-'",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,130,2020-09-22T07:22:48Z,2020-09-22T07:36:56Z,2020-09-22T08:06:40Z,MERGED,True,1921022,26,957,https://github.com/marcoaccame,support of board stm32h754disco,3,[],https://github.com/robotology/icub-firmware/pull/130,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/130,"This PR adds some demo programs for the board stm32h745disco.
In particular it was added:

a target in stm32h7.uvproj to support the board stm32h745disco with ST's HAL version 1.9.0.0;
a simple demo program based upon the above stm32hal.lib;
and embot-os2 project based onto the above stm32hal.lib and the embot;
the eupdater-embot-stm32h7disco which is the porting on this board of the project eupdater-embot-stm32g4eval introduced in this PR.

The eupdater-embot-stm32h7disco project is still WIP.
The changes do no affect other boards.","This PR adds some demo programs for the board stm32h745disco.
In particular it was added:

a target in stm32h7.uvproj to support the board stm32h745disco with ST's HAL version 1.9.0.0;
a simple demo program based upon the above stm32hal.lib;
and embot-os2 project based onto the above stm32hal.lib and the embot;
the eupdater-embot-stm32h7disco which is the porting on this board of the project eupdater-embot-stm32g4eval introduced in this PR.

The eupdater-embot-stm32h7disco project is still WIP.
The changes do no affect other boards.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,131,2020-09-22T15:52:52Z,2020-09-22T15:53:05Z,2020-09-22T15:53:06Z,MERGED,True,573320,19477,770,https://github.com/marcoaccame,stm32hal.lib update for boards pmc and stm32g4eval,2,[],https://github.com/robotology/icub-firmware/pull/131,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/131,"This PR updates the stm32hal + test applications for boards pmc and companion development board stm32g4eval
The update is done:

to the latest version of the ST's HAL for both boards
to the latest version of cube-mx project of board pmc from the electronics guys.

All application were tested on the stm32g4eval board.","This PR updates the stm32hal + test applications for boards pmc and companion development board stm32g4eval
The update is done:

to the latest version of the ST's HAL for both boards
to the latest version of cube-mx project of board pmc from the electronics guys.

All application were tested on the stm32g4eval board.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,133,2020-10-13T13:44:13Z,2020-10-13T13:49:23Z,2020-10-13T13:49:24Z,MERGED,True,208,214,18,https://github.com/marcoaccame,embot::hw::can driver for board pmc,5,[],https://github.com/robotology/icub-firmware/pull/133,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/133,"This PR adds the FDCAN communication the the embot::hw::can driver for the pmc board
The driver has been tested vs communication over CAN using CANreal:

reply to discover CAN frame
transmission of long burst of CAN frames","This PR adds the FDCAN communication the the embot::hw::can driver for the pmc board
The driver has been tested vs communication over CAN using CANreal:

reply to discover CAN frame
transmission of long burst of CAN frames",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,134,2020-10-21T12:24:55Z,2020-10-21T12:27:20Z,2020-10-21T12:27:21Z,MERGED,True,173815,7411,232,https://github.com/marcoaccame,nucleoh7 @ 320mhz,2,[],https://github.com/robotology/icub-firmware/pull/134,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/134,"This PR updates the application running on nucleoh7 in the following aspects

updates its stm32hal to the latest version from STM (STM32H7xx HAL Driver version number V1.8.0)
uses a clock speed of 320mhz
cleans the application code
adds documentation about the structure of the code

The application works fine on the development board and is still able to read sensors and transmit effectively over USART.","This PR updates the application running on nucleoh7 in the following aspects

updates its stm32hal to the latest version from STM (STM32H7xx HAL Driver version number V1.8.0)
uses a clock speed of 320mhz
cleans the application code
adds documentation about the structure of the code

The application works fine on the development board and is still able to read sensors and transmit effectively over USART.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,135,2020-10-22T09:10:05Z,2020-10-22T09:13:10Z,2022-01-11T09:44:17Z,MERGED,True,0,13223,18,https://github.com/marcoaccame,fix/bat,1,[],https://github.com/robotology/icub-firmware/pull/135,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/135,"the PR is for removing un-used files from the BAT project.
tested compilation w/out the removed files and it is OK.","the PR is for removing un-used files from the BAT project.
tested compilation w/out the removed files and it is OK.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,136,2020-10-22T09:31:44Z,2020-10-22T09:34:41Z,2020-10-22T09:34:41Z,MERGED,True,16,9,1,https://github.com/MrAndrea,BAT changes: added delay between multiple switch on and off of the power,1,[],https://github.com/robotology/icub-firmware/pull/136,https://github.com/MrAndrea,1,https://github.com/robotology/icub-firmware/pull/136,Added delay between multiple switch on and off of the power,Added delay between multiple switch on and off of the power,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,137,2020-10-22T10:07:41Z,2020-10-22T10:08:11Z,2020-10-22T10:08:11Z,MERGED,True,0,205316,690,https://github.com/marcoaccame,cleaning of BAT project files,2,[],https://github.com/robotology/icub-firmware/pull/137,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/137,together w/ @MrAndrea we have cleaned the BAT projects off of unnecessary files.,together w/ @MrAndrea we have cleaned the BAT projects off of unnecessary files.,True,{'THUMBS_UP': ['https://github.com/MrAndrea']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,138,2020-10-22T13:27:57Z,2020-10-28T08:29:23Z,2020-10-28T08:29:23Z,MERGED,True,67,154,286,https://github.com/MrAndrea,"BAT firmware update revision 1.0.0, project renamed",2,[],https://github.com/robotology/icub-firmware/pull/138,https://github.com/MrAndrea,1,https://github.com/robotology/icub-firmware/pull/138,"I updated the information of firmware revision: 1.0.0
I renamed the project and the project folder from BAT-Rev-B to BAT_Rev_B","I updated the information of firmware revision: 1.0.0
I renamed the project and the project folder from BAT-Rev-B to BAT_Rev_B",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,139,2020-10-28T08:24:11Z,2020-10-28T08:27:07Z,2020-10-28T08:27:07Z,MERGED,True,14826,4720,180,https://github.com/marcoaccame,embot::hw::bsp is now split amongst the different boards,2,[],https://github.com/robotology/icub-firmware/pull/139,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/139,"The embot::hw::bsp namespace contains the adaptation to a specific board of hw drivers such as embot::hw::can, embot::hw::i2c, embot::hw::bno055` etc.
For adaptation we mean to specify information such as pinout, bus specification or actions required by specific boards.
In such a way we can keep the same code for a driver, for instance to read IMU data from a Bosch BNO055, and use it in multiple boards with minor adaptation which are all contained in a specific file.
The adaptations for all drivers and all boards were originally contained inside the files embot_hw_bsp.[h, cpp].  It approach was OK when we had just a few boards, but now its monolithic aspect takes confusion and difficulty in parallel work.
In this PR the adaptation is split into a set of files dedicated to each board. For instance for board pmc, we have a folder bsp which contains:

embot_hw_bsp_pmc_config.h with the drivers the board requires expressed as macros (e.g., #define EMBOT_ENABLE_hw_i2c, #define EMBOT_ENABLE_hw_tlv493d etc.);
embot_hw_bsp_pmc.cpp with the effective adaptation code required by the hw drivers (e.g., by embot_hw_ic2.cpp and embot_hw_tlv493d.cpp);
embot_hw_bsp_config.h which includes embot_hw_bsp_pmc_config.h and enables / disables compilation of the above hw drivers if added to the project.

The fileembot_hw_bsp.cpp contains now only the initialization of the stm32hal (or others if needed) and the adaptation for the print() function which in our implementation puts characters over the ITM port.
The changes were successfully tested on several boards for a set of different HW features: mtb4, nucleoh7, stm32g4eval, stm32h745disco for can communication, IMU and FAP reading etc.","The embot::hw::bsp namespace contains the adaptation to a specific board of hw drivers such as embot::hw::can, embot::hw::i2c, embot::hw::bno055` etc.
For adaptation we mean to specify information such as pinout, bus specification or actions required by specific boards.
In such a way we can keep the same code for a driver, for instance to read IMU data from a Bosch BNO055, and use it in multiple boards with minor adaptation which are all contained in a specific file.
The adaptations for all drivers and all boards were originally contained inside the files embot_hw_bsp.[h, cpp].  It approach was OK when we had just a few boards, but now its monolithic aspect takes confusion and difficulty in parallel work.
In this PR the adaptation is split into a set of files dedicated to each board. For instance for board pmc, we have a folder bsp which contains:

embot_hw_bsp_pmc_config.h with the drivers the board requires expressed as macros (e.g., #define EMBOT_ENABLE_hw_i2c, #define EMBOT_ENABLE_hw_tlv493d etc.);
embot_hw_bsp_pmc.cpp with the effective adaptation code required by the hw drivers (e.g., by embot_hw_ic2.cpp and embot_hw_tlv493d.cpp);
embot_hw_bsp_config.h which includes embot_hw_bsp_pmc_config.h and enables / disables compilation of the above hw drivers if added to the project.

The fileembot_hw_bsp.cpp contains now only the initialization of the stm32hal (or others if needed) and the adaptation for the print() function which in our implementation puts characters over the ITM port.
The changes were successfully tested on several boards for a set of different HW features: mtb4, nucleoh7, stm32g4eval, stm32h745disco for can communication, IMU and FAP reading etc.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,140,2020-11-06T10:43:44Z,2020-11-06T10:49:14Z,2020-11-06T10:49:14Z,MERGED,True,6113,245,25,https://github.com/marcoaccame,pmc: added theFAPreader,6,[],https://github.com/robotology/icub-firmware/pull/140,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/140,"This PR introduces a new object, theFAPreader, which is used by the pmc board to read its attached FAP sensors (based on embot::hw::tlv493d) and produce the CAN frames which carry their POS values espressed in deciDEG (see CAN protocol specification for analog sensors for details).
The theFAPreader has been successfully tested both on the pmc board using an emulated mode for its embot::hw::tlv493d sensors. On teh pmc board it is possible to activate the CAN streaming of the six FAP sensors and to deactivate it by using CAN commands. See figure below.

Figure. The CANreal GUI sends and a command frame and orders the pmc board to stream data at 100 ms.
The theFAPreader implements a two stage parallel acquisition mode which allows to use two sensors on the same I2C bus. this mode is called AcquisitionMode::mod2parallel. It is also present a timeout mechanism which detects if any sensor does not respond anymore. In such a case its streams out a non-valid POS value and also a canprint message.
See behaviour of the  AcquisitionMode::mod2parallel in figures below.
The acquisition chain the sensors attached to the pmc board is the following.

Figure.  Sequence diagram for the AcquisitionMode::mod2parallel mode.
The acquisition cycle is triggered by a embot::os::Timer tick which is configure to emit the event acquire in periodic mode every T_acq.
As we can see from the above picture, the sensors are read in two steps:

first step: we read in parallel the sensors J4, J5 and J6 and J7. We can read them in parallel because they are on different I2C buses (I2C1, I2C2,, I2C3 and I2C4 respectively).
second step: we read in parallel the sensors J13 and U27. We can read them in parallel because they are on different I2C buses (I2C1 and I2C2 respectively).

The time of acquisition of all sensors is hence of order 2T (T = 1 ms about).
We can manage any possible missing reply from the sensors by adding a second embot::os::Timer tout which is started in oneshot mode at every step  and stopped when every sensor of the step have replied.
See following picture.

Figure.  Sequence diagram for the AcquisitionMode::mod2parallel mode w/ addition of control of data reception from all sensors.
In case a sensor does not reply the timer tout is not stopped and it emits a noreply events which is managed by theFAPreader which: marks the sensor as not available and re-starts teh acquisition chain. See picture below:

Figure.  Sequence diagram for the AcquisitionMode::mod2parallel mode when a sensor does not reply.
If needed / allowed / wanted, we could read them also in daisy chain (J4, J5, J6, J7, J13 and U27). That would distribute the burden of the I2C IRQ handlers over time but would increase acquisition time to be of order 6T.
See following picture.

Figure.  Sequence diagram for the AcquisitionMode::daisychain mode.
The management of the timeout can be done in the same ways as for the previous case. The tout timer is started at each acquisition and stopped when the acquisition is over. If no reply from teh sensor the error handling mode trigggers. See pictures.

Figure.  Sequence diagram for the AcquisitionMode::daisychain mode when the sensor replies.

Figure.  Sequence diagram for the AcquisitionMode::daisychain mode when the sensor does not reply.","This PR introduces a new object, theFAPreader, which is used by the pmc board to read its attached FAP sensors (based on embot::hw::tlv493d) and produce the CAN frames which carry their POS values espressed in deciDEG (see CAN protocol specification for analog sensors for details).
The theFAPreader has been successfully tested both on the pmc board using an emulated mode for its embot::hw::tlv493d sensors. On teh pmc board it is possible to activate the CAN streaming of the six FAP sensors and to deactivate it by using CAN commands. See figure below.

Figure. The CANreal GUI sends and a command frame and orders the pmc board to stream data at 100 ms.
The theFAPreader implements a two stage parallel acquisition mode which allows to use two sensors on the same I2C bus. this mode is called AcquisitionMode::mod2parallel. It is also present a timeout mechanism which detects if any sensor does not respond anymore. In such a case its streams out a non-valid POS value and also a canprint message.
See behaviour of the  AcquisitionMode::mod2parallel in figures below.
The acquisition chain the sensors attached to the pmc board is the following.

Figure.  Sequence diagram for the AcquisitionMode::mod2parallel mode.
The acquisition cycle is triggered by a embot::os::Timer tick which is configure to emit the event acquire in periodic mode every T_acq.
As we can see from the above picture, the sensors are read in two steps:

first step: we read in parallel the sensors J4, J5 and J6 and J7. We can read them in parallel because they are on different I2C buses (I2C1, I2C2,, I2C3 and I2C4 respectively).
second step: we read in parallel the sensors J13 and U27. We can read them in parallel because they are on different I2C buses (I2C1 and I2C2 respectively).

The time of acquisition of all sensors is hence of order 2T (T = 1 ms about).
We can manage any possible missing reply from the sensors by adding a second embot::os::Timer tout which is started in oneshot mode at every step  and stopped when every sensor of the step have replied.
See following picture.

Figure.  Sequence diagram for the AcquisitionMode::mod2parallel mode w/ addition of control of data reception from all sensors.
In case a sensor does not reply the timer tout is not stopped and it emits a noreply events which is managed by theFAPreader which: marks the sensor as not available and re-starts teh acquisition chain. See picture below:

Figure.  Sequence diagram for the AcquisitionMode::mod2parallel mode when a sensor does not reply.
If needed / allowed / wanted, we could read them also in daisy chain (J4, J5, J6, J7, J13 and U27). That would distribute the burden of the I2C IRQ handlers over time but would increase acquisition time to be of order 6T.
See following picture.

Figure.  Sequence diagram for the AcquisitionMode::daisychain mode.
The management of the timeout can be done in the same ways as for the previous case. The tout timer is started at each acquisition and stopped when the acquisition is over. If no reply from teh sensor the error handling mode trigggers. See pictures.

Figure.  Sequence diagram for the AcquisitionMode::daisychain mode when the sensor replies.

Figure.  Sequence diagram for the AcquisitionMode::daisychain mode when the sensor does not reply.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,141,2020-11-09T10:15:42Z,2020-11-09T10:17:21Z,2020-11-09T10:17:21Z,MERGED,True,21,18,4,https://github.com/marcoaccame,nucleoh7 -> small changes,1,[],https://github.com/robotology/icub-firmware/pull/141,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/141,added a macro_enableEXTItransmitBLUEbutton which makes it easier the debug,added a macro_enableEXTItransmitBLUEbutton which makes it easier the debug,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,143,2020-11-18T12:11:48Z,2020-11-18T12:22:32Z,2020-11-18T12:55:49Z,MERGED,True,3970,1450,112,https://github.com/marcoaccame,magnetic encoders for pmc board + configuration of cdc offset in ad7147 chip,10,[],https://github.com/robotology/icub-firmware/pull/143,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/143,"This PR introduces:

the streaming of the values of the magnetic encoders acquired by the pmc board
some  improvements in the driver of  ad7147.

Magnetic encoders acquired by the pmc board
The pmc board manages the reading of six magnetic encoders with the i2c-based tlv493d chip. Five of them are on the FAP boards attached to the pmc via flat cables and one is mounted on the pmc itself.
The six sensors are distributed on four I2C buses, hence to give full support to their reading the required changes were as follow:

full support of the bus embot::hw::I2C::four inside the I2C driver,
addition of a bool  embot::hw::i2c::discover(embot::hw::I2C b, std::vector<embot::hw::i2c::ADR> &adrs) for getting addressed of all chips attached to a I2C bus.
assignment of different addresses to the tlv493d chips which coexist on the same I2C bus (at first on a cube-mx demo project but then on the embot::hw::bsp::specialize() function proper of the bsp of the pmc board.
revision of the I2C-based drivers so that the mapping into I2C bus and address is assigned inside the bsp of the board and not anymore by the application software. The drivers are those for chips:  ad7147,  ads122c04, bno055, si7051, and tlv493d`.
improvement of the APIs of chip  ad7147, so that the cdc offset can be imposed at its initialization

Improvements in the driver of  ad7147.
Moreover in here is also improved the driver of  ad7147:

so that it can be configure the cdc offset at initialization of the sensor by means of result_t init(embot::hw::AD7147 s, const Config &config),
or even later on by means of new function `result_t configure(AD7147 s, const Config &config)'.

And the test program on nucleoh7 which uses two ad7147 chips also allows to use them alone or together with the bno055 and ads122c04 chips.
In here is excerpt of code which explain how to configure the cdc offset to be 0x2000 as used by some skin patches as tested inside the nucleoh7 project.
#include ""embot_hw_ad7147.h""
// equal to {0x2000} -> it applies a positive AFE offset of 32 * 0.32 pF
constexpr embot::hw::ad7147::Config ad7147config {32, 0}; 

...

#if defined(macro_enableSENSOR_ad7147)        
    volatile embot::hw::result_t rr1 = embot::hw::result_t::NOK;
    volatile embot::hw::result_t rr2 = embot::hw::result_t::NOK;
    rr1 = embot::hw::ad7147::init(embot::hw::AD7147::one, ad7147config);
    rr2 = embot::hw::ad7147::init(embot::hw::AD7147::two, ad7147config);           
    rr1 = rr1;
    rr2 = rr2;
#endif
The code was tested in presence of the two AD7147 chips alone using
// section for sensors' enabling
#undef macro_enableSENSOR_bno055
#undef macro_enableSENSOR_ads122c04
#define macro_enableSENSOR_ad7147
and also with all the other chips using
// section for sensors' enabling
#define macro_enableSENSOR_bno055
#define macro_enableSENSOR_ads122c04
#define macro_enableSENSOR_ad7147","This PR introduces:

the streaming of the values of the magnetic encoders acquired by the pmc board
some  improvements in the driver of  ad7147.

Magnetic encoders acquired by the pmc board
The pmc board manages the reading of six magnetic encoders with the i2c-based tlv493d chip. Five of them are on the FAP boards attached to the pmc via flat cables and one is mounted on the pmc itself.
The six sensors are distributed on four I2C buses, hence to give full support to their reading the required changes were as follow:

full support of the bus embot::hw::I2C::four inside the I2C driver,
addition of a bool  embot::hw::i2c::discover(embot::hw::I2C b, std::vector<embot::hw::i2c::ADR> &adrs) for getting addressed of all chips attached to a I2C bus.
assignment of different addresses to the tlv493d chips which coexist on the same I2C bus (at first on a cube-mx demo project but then on the embot::hw::bsp::specialize() function proper of the bsp of the pmc board.
revision of the I2C-based drivers so that the mapping into I2C bus and address is assigned inside the bsp of the board and not anymore by the application software. The drivers are those for chips:  ad7147,  ads122c04, bno055, si7051, and tlv493d`.
improvement of the APIs of chip  ad7147, so that the cdc offset can be imposed at its initialization

Improvements in the driver of  ad7147.
Moreover in here is also improved the driver of  ad7147:

so that it can be configure the cdc offset at initialization of the sensor by means of result_t init(embot::hw::AD7147 s, const Config &config),
or even later on by means of new function `result_t configure(AD7147 s, const Config &config)'.

And the test program on nucleoh7 which uses two ad7147 chips also allows to use them alone or together with the bno055 and ads122c04 chips.
In here is excerpt of code which explain how to configure the cdc offset to be 0x2000 as used by some skin patches as tested inside the nucleoh7 project.
#include ""embot_hw_ad7147.h""
// equal to {0x2000} -> it applies a positive AFE offset of 32 * 0.32 pF
constexpr embot::hw::ad7147::Config ad7147config {32, 0}; 

...

#if defined(macro_enableSENSOR_ad7147)        
    volatile embot::hw::result_t rr1 = embot::hw::result_t::NOK;
    volatile embot::hw::result_t rr2 = embot::hw::result_t::NOK;
    rr1 = embot::hw::ad7147::init(embot::hw::AD7147::one, ad7147config);
    rr2 = embot::hw::ad7147::init(embot::hw::AD7147::two, ad7147config);           
    rr1 = rr1;
    rr2 = rr2;
#endif
The code was tested in presence of the two AD7147 chips alone using
// section for sensors' enabling
#undef macro_enableSENSOR_bno055
#undef macro_enableSENSOR_ads122c04
#define macro_enableSENSOR_ad7147
and also with all the other chips using
// section for sensors' enabling
#define macro_enableSENSOR_bno055
#define macro_enableSENSOR_ads122c04
#define macro_enableSENSOR_ad7147",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,144,2020-11-19T16:06:34Z,2020-11-19T19:42:02Z,2020-11-19T19:42:02Z,MERGED,True,1325,57,18,https://github.com/marcoaccame,Added support in ETH boards for disabling some services at compile time,3,[],https://github.com/robotology/icub-firmware/pull/144,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/144,"This PR adds the support for for disabling some services at compile time in order to save RAM in some special configurations.
That is done by defining in the projects of ems, mc4plus or mc2plus special macros which changes the standard definition of the public functions and provide a dummy one.
These macros are disabled by default, so they do not change the standard behaviour of the ETH boards.
These macros are
#if 0
#undef EOTHESERVICES_disable_theInertials2
#undef EOTHESERVICES_disable_theInertials3
#undef EOTHESERVICES_disable_theMEMs
#undef EOTHESERVICES_disable_theTemperatures
#undef EOTHESERVICES_disable_theMAIS
#undef EOTHESERVICES_disable_theSTRAIN
#undef EOTHESERVICES_disable_theSKIN
#undef EOTHESERVICES_disable_thePSC
#undef EOTHESERVICES_disable_theMC4boards
#undef EOTHESERVICES_disable_theMotionController
#undef EOTHESERVICES_disable_theEncoderReader
#undef EOTHESERVICES_disable_CurrentsWatchdog

#if defined(EOTHESERVICES_disable_theInertials2) && defined(EOTHESERVICES_disable_theInertials3)
    #define EOTHESERVICES_disable_theMEMs
#endif

#endif

They could for instance compile w/ the -DEOTHESERVICES_disable_theInertials3 option in a demo project where we don need for the EOtheInertials3 service.
In doing the test, I have also computed an estimate of RAM requirements of some services. I report them in the following tables.



Service
Used RAM (bytes)




EOtheSKIN
2944


EOtheInertials3
1248


EOtheInertials2
896


EOtheTemperatures
456


EOtheMAIS
200


EOtheSTRAIN
200


EOthePSC
176


Total of the above
6120






EOtheMotionController
Used RAM (bytes)




EOtheEncoderReader
112


EOCurrentsWatchdog
0, but it is called in runtime


MController
5224


EOtheMotionController as a wrapper only
352


EOtheMAIS
200


EOthePSC
176


Total of the above
6064","This PR adds the support for for disabling some services at compile time in order to save RAM in some special configurations.
That is done by defining in the projects of ems, mc4plus or mc2plus special macros which changes the standard definition of the public functions and provide a dummy one.
These macros are disabled by default, so they do not change the standard behaviour of the ETH boards.
These macros are
#if 0
#undef EOTHESERVICES_disable_theInertials2
#undef EOTHESERVICES_disable_theInertials3
#undef EOTHESERVICES_disable_theMEMs
#undef EOTHESERVICES_disable_theTemperatures
#undef EOTHESERVICES_disable_theMAIS
#undef EOTHESERVICES_disable_theSTRAIN
#undef EOTHESERVICES_disable_theSKIN
#undef EOTHESERVICES_disable_thePSC
#undef EOTHESERVICES_disable_theMC4boards
#undef EOTHESERVICES_disable_theMotionController
#undef EOTHESERVICES_disable_theEncoderReader
#undef EOTHESERVICES_disable_CurrentsWatchdog

#if defined(EOTHESERVICES_disable_theInertials2) && defined(EOTHESERVICES_disable_theInertials3)
    #define EOTHESERVICES_disable_theMEMs
#endif

#endif

They could for instance compile w/ the -DEOTHESERVICES_disable_theInertials3 option in a demo project where we don need for the EOtheInertials3 service.
In doing the test, I have also computed an estimate of RAM requirements of some services. I report them in the following tables.



Service
Used RAM (bytes)




EOtheSKIN
2944


EOtheInertials3
1248


EOtheInertials2
896


EOtheTemperatures
456


EOtheMAIS
200


EOtheSTRAIN
200


EOthePSC
176


Total of the above
6120






EOtheMotionController
Used RAM (bytes)




EOtheEncoderReader
112


EOCurrentsWatchdog
0, but it is called in runtime


MController
5224


EOtheMotionController as a wrapper only
352


EOtheMAIS
200


EOthePSC
176


Total of the above
6064",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,145,2020-11-23T12:19:11Z,2020-11-23T12:24:10Z,2020-11-23T12:24:10Z,MERGED,True,384,460,15,https://github.com/marcoaccame,ETH boards: all services now have _AcceptCANframe() to manage incoming CAN frames,1,[],https://github.com/robotology/icub-firmware/pull/145,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/145,"In this PR we continue the refactoring of the ETH services started with #144. The refactoring is required so that we can more easily change the way some services run on a ETH board. One uses could be to add an alternative MotionController service in the boards of the new hand/wrist without changing too much code and in such a way that it could be decided at compile time what to controller to load.
In this refactoring iteration, now all the services have their _AcceptCANframe(...) method to accept CAN frames and process them
according to their own needs. The benefit is that the processing is all inside the correct software module and not spread anymore in multiple files.
The following services, though, still have an empty _AcceptCANframe() method and the handling of CAN frames inside multiple files: EOtheMC4boards, EOtheMotionController. The fill of eo_motioncontrol_AcceptCANframe() and of eo_mc4boards_AcceptCANframe() will be done at a later stage.
The changes in the PR are just a refactoring where code handling reception of CAN frames was moved for instance from file EoCANprotASperiodic.c to EOtheMAIS.c.","In this PR we continue the refactoring of the ETH services started with #144. The refactoring is required so that we can more easily change the way some services run on a ETH board. One uses could be to add an alternative MotionController service in the boards of the new hand/wrist without changing too much code and in such a way that it could be decided at compile time what to controller to load.
In this refactoring iteration, now all the services have their _AcceptCANframe(...) method to accept CAN frames and process them
according to their own needs. The benefit is that the processing is all inside the correct software module and not spread anymore in multiple files.
The following services, though, still have an empty _AcceptCANframe() method and the handling of CAN frames inside multiple files: EOtheMC4boards, EOtheMotionController. The fill of eo_motioncontrol_AcceptCANframe() and of eo_mc4boards_AcceptCANframe() will be done at a later stage.
The changes in the PR are just a refactoring where code handling reception of CAN frames was moved for instance from file EoCANprotASperiodic.c to EOtheMAIS.c.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,146,2020-11-26T10:45:28Z,2020-11-26T10:48:24Z,2020-11-26T10:48:24Z,MERGED,True,109,140,6,https://github.com/marcoaccame,ETH boards: reception of POL_AS_CMD__GET_FULL_SCALES message is managed with eo_strain_AcceptCANframe(),3,[],https://github.com/robotology/icub-firmware/pull/146,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/146,"The POL_AS_CMD__GET_FULL_SCALES message is managed by object EOtheSTRAIN  with eo_strain_AcceptCANframe().
The code is the same as before, it is just moved into a different file and a different function.
The benefit in here is that the action upon reception of the message is managed entirely inside the relevant object which behaves as an agent.
With this PR all the actions upon reception of messages of classes analog-sensors polling, analog sensors streaming, skin streaming and inertials streaming are all managed by the relevant objects / agents.
Still missing the two motion control classes.","The POL_AS_CMD__GET_FULL_SCALES message is managed by object EOtheSTRAIN  with eo_strain_AcceptCANframe().
The code is the same as before, it is just moved into a different file and a different function.
The benefit in here is that the action upon reception of the message is managed entirely inside the relevant object which behaves as an agent.
With this PR all the actions upon reception of messages of classes analog-sensors polling, analog sensors streaming, skin streaming and inertials streaming are all managed by the relevant objects / agents.
Still missing the two motion control classes.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,147,2020-12-02T17:46:22Z,2020-12-03T08:29:28Z,2020-12-03T08:29:29Z,MERGED,True,2185,385,37,https://github.com/marcoaccame,POS service,8,[],https://github.com/robotology/icub-firmware/pull/147,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/147,"This PR introduces the POS service.
Description of the service
The POS service is used to stream position values from an ETH board towards the relevant device started by yarprobotinterface, the embObjPOS. The values are retrieved from up to 14 encoders, so far only magnetic encoders from the pmc board. The POS service is required to get position values of the fingers of the new hand.
Changes
This PR is to be processed together with two other PRs: one for icub-firmware-shared  and one for icub-main.
In here are the main changes in each of these repositories:


icub-firmware:  added the EOthePOS object in ems, mc4plus, mc2plus; enabled in EOtheServices; added handlers for the required ETH and CAN messages. At the moment the  EOthePOS is disabled in the projects of the three ETH boards with macro EOTHESERVICES_disable_thePOS being defined at project level (-DEOTHESERVICES_disable_thePOS in section Misc Controls of C/C++ options).


icub-firmware-shared: added the new entity eoprot_entity_as_pos  in endpoint eoprot_endpoint_analogsensors with all required stuff; added runtime configuration of the POS service inside the management entity with a new eOmn_serv_config_data_as_pos_t; advanced protocol versions of entities analogsensors and management.


icub-main: added the embObjPOS device inside icubmod + all required stuff required to run the service (parser of xml files, handling of relevant ETH protocol messages); changed some of the obsolete NetworkBase::getEnvironment() calls with teh suggested yarp::conf::environment::getEnvironment().


Tests
All the chain was tested on a setup made of:

linux pc with most recent yarp (master branch) plus the repos under PR plus a suitable set of xml files.
ems board with macro EOTHESERVICES_disable_thePOS disabled,
pmc board with a fake acquisition of magnetic encoders.

The service runs with success and streams the values of the target YARP port. The following shows the plot from yarpscope reading on that port.

Figure. Outcome of the POS service on yarpscope.
And in here is a video of one experiment. The talk is lost, hence in here i summarize the steps:

launch yarp server w/ yarp server.
launch yarprobotinterface w/ yarprobotinterface --config handV3.xml
read the relevant yarp port w/ yarp read ... /hv3/left_hand/POS:o
launch the yarpscope w/ yarpscope --xml yarpscope.pos.xml
resizing the window which shows the time variation from sensors J4 to U27.


Figure. Video of one test of the POS service.
Impact on iCub
The above test worked fine as expected. And the changes done to support the new device are pretty standard and safe and used only if one uses the POS service by starting the embObjPOS device from yarprobotinterface.
Hence, ... I expect no harm on iCub.","This PR introduces the POS service.
Description of the service
The POS service is used to stream position values from an ETH board towards the relevant device started by yarprobotinterface, the embObjPOS. The values are retrieved from up to 14 encoders, so far only magnetic encoders from the pmc board. The POS service is required to get position values of the fingers of the new hand.
Changes
This PR is to be processed together with two other PRs: one for icub-firmware-shared  and one for icub-main.
In here are the main changes in each of these repositories:


icub-firmware:  added the EOthePOS object in ems, mc4plus, mc2plus; enabled in EOtheServices; added handlers for the required ETH and CAN messages. At the moment the  EOthePOS is disabled in the projects of the three ETH boards with macro EOTHESERVICES_disable_thePOS being defined at project level (-DEOTHESERVICES_disable_thePOS in section Misc Controls of C/C++ options).


icub-firmware-shared: added the new entity eoprot_entity_as_pos  in endpoint eoprot_endpoint_analogsensors with all required stuff; added runtime configuration of the POS service inside the management entity with a new eOmn_serv_config_data_as_pos_t; advanced protocol versions of entities analogsensors and management.


icub-main: added the embObjPOS device inside icubmod + all required stuff required to run the service (parser of xml files, handling of relevant ETH protocol messages); changed some of the obsolete NetworkBase::getEnvironment() calls with teh suggested yarp::conf::environment::getEnvironment().


Tests
All the chain was tested on a setup made of:

linux pc with most recent yarp (master branch) plus the repos under PR plus a suitable set of xml files.
ems board with macro EOTHESERVICES_disable_thePOS disabled,
pmc board with a fake acquisition of magnetic encoders.

The service runs with success and streams the values of the target YARP port. The following shows the plot from yarpscope reading on that port.

Figure. Outcome of the POS service on yarpscope.
And in here is a video of one experiment. The talk is lost, hence in here i summarize the steps:

launch yarp server w/ yarp server.
launch yarprobotinterface w/ yarprobotinterface --config handV3.xml
read the relevant yarp port w/ yarp read ... /hv3/left_hand/POS:o
launch the yarpscope w/ yarpscope --xml yarpscope.pos.xml
resizing the window which shows the time variation from sensors J4 to U27.


Figure. Video of one test of the POS service.
Impact on iCub
The above test worked fine as expected. And the changes done to support the new device are pretty standard and safe and used only if one uses the POS service by starting the embObjPOS device from yarprobotinterface.
Hence, ... I expect no harm on iCub.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,148,2020-12-09T18:34:47Z,2020-12-09T18:43:56Z,2020-12-09T18:43:57Z,MERGED,True,507,54,7,https://github.com/marcoaccame,Implementation of MC service of the new hand: open/close of fingers,3,[],https://github.com/robotology/icub-firmware/pull/148,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/148,"This PR implements changes in the application of the mc4plus application for supporting the new case in EOtheMotionControl service for eo_motcon_mode_mc4plusfaps.
This PR uses code of icub-firmware-shared as in following PR: robotology/icub-firmware-shared#44.
The test of the service was done using the testRTC feature on a ems board with a pmc board streaming POS values. It works in stopping, verifying, activationg, starting, stopping and deactivating the service.
The above features have been tested running effectively using an ems board (on the mc4plus it would be the same) which has the macro TESTRTC_IS_ACTIVE defined. In this way, the ETH boards acts as if it would receive from yarprobotinterface commands related to a service.

I have used the following service configuration inside file testRTC.c and all worked fine. The MC service and the required POS service were effectively verified and started. The encoders would get that values from the POS service and pass them to the MController  which ... would do nothing so far.
// eo_motcon_mode_mc4plusfaps

static const eOmn_serv_configuration_t s_serv_config_mc_mc4plusfaps =
{   
    .type       = eomn_serv_MC_mc4plusfaps,
    .filler     = {0},
    .data.mc.mc4plusfaps = 
    {
        .pos   =
        {
            .version = 
            {
                .firmware = 
                {
                    .major = 1, .minor = 0, .build = 0
                },
                .protocol = 
                {
                    .major = 2, .minor = 0
                }
            },
            .boardInfo = 
            {
                .canloc = 
                {
                    { 
                        .port = eOcanport1, 
                        .addr = 1, 
                        .insideindex = eobrd_caninsideindex_none, 
                        .dummy = 0 
                    }        
                }
            }        
            
        },
        .filler                 = {0},
        .arrayofjomodescriptors =
        {
            .head   = 
            {
                .capacity       = 4,
                .itemsize       = sizeof(eOmc_jomo_descriptor_t),
                .size           = 4,
                .internalmem    = 0                    
            },
            .data   =
            {
                { // joint 0
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP2,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_thumb,  
                        .pos    = eomc_pos_atjoint
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                },
                { // joint 1
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP3,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_index, 
                        .pos    = eomc_pos_atjoint                            
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                },                    
                { // joint 2
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP4,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_medium,  
                        .pos    = eomc_pos_atjoint
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                },               
                { // joint 3
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP5,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_pinky,    
                        .pos    = eomc_pos_atjoint
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                }                    
            }   
        },  
        .jomocoupling       =
        {
            .joint2set      = 
            {   // each joint is on a different set 
                0, 1, 2, 3 
            },
            .joint2motor    = 
            {   // tbd
                { EO_COMMON_FLOAT_TO_Q17_14(1.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f) }        
            },
            .encoder2joint  = 
            {   // identical matrix
                { EO_COMMON_FLOAT_TO_Q17_14(1.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f) } 
            }  
        }        
    }
};

In here is a screenshot of the TRACE port of the ems board telling that all is working fine.

STILL TODO
We still have to integrate the case inside the files of MController, but that can be done later on a proper setup with a mc4plus board and DC motors and xml files and ... changes in icub-main.","This PR implements changes in the application of the mc4plus application for supporting the new case in EOtheMotionControl service for eo_motcon_mode_mc4plusfaps.
This PR uses code of icub-firmware-shared as in following PR: robotology/icub-firmware-shared#44.
The test of the service was done using the testRTC feature on a ems board with a pmc board streaming POS values. It works in stopping, verifying, activationg, starting, stopping and deactivating the service.
The above features have been tested running effectively using an ems board (on the mc4plus it would be the same) which has the macro TESTRTC_IS_ACTIVE defined. In this way, the ETH boards acts as if it would receive from yarprobotinterface commands related to a service.

I have used the following service configuration inside file testRTC.c and all worked fine. The MC service and the required POS service were effectively verified and started. The encoders would get that values from the POS service and pass them to the MController  which ... would do nothing so far.
// eo_motcon_mode_mc4plusfaps

static const eOmn_serv_configuration_t s_serv_config_mc_mc4plusfaps =
{   
    .type       = eomn_serv_MC_mc4plusfaps,
    .filler     = {0},
    .data.mc.mc4plusfaps = 
    {
        .pos   =
        {
            .version = 
            {
                .firmware = 
                {
                    .major = 1, .minor = 0, .build = 0
                },
                .protocol = 
                {
                    .major = 2, .minor = 0
                }
            },
            .boardInfo = 
            {
                .canloc = 
                {
                    { 
                        .port = eOcanport1, 
                        .addr = 1, 
                        .insideindex = eobrd_caninsideindex_none, 
                        .dummy = 0 
                    }        
                }
            }        
            
        },
        .filler                 = {0},
        .arrayofjomodescriptors =
        {
            .head   = 
            {
                .capacity       = 4,
                .itemsize       = sizeof(eOmc_jomo_descriptor_t),
                .size           = 4,
                .internalmem    = 0                    
            },
            .data   =
            {
                { // joint 0
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP2,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_thumb,  
                        .pos    = eomc_pos_atjoint
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                },
                { // joint 1
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP3,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_index, 
                        .pos    = eomc_pos_atjoint                            
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                },                    
                { // joint 2
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP4,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_medium,  
                        .pos    = eomc_pos_atjoint
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                },               
                { // joint 3
                    .actuator.pwm    =
                    {
                        .port           = eobrd_port_mc4plusP5,
                        .dummy          = 0                             
                    },
                    .encoder1         =
                    {
                        .type   = eomc_enc_pos,
                        .port   = eobrd_portpos_hand_pinky,    
                        .pos    = eomc_pos_atjoint
                    },
                    .encoder2    =
                    {
                        .type   = eomc_enc_none,
                        .port   = eobrd_port_none,
                        .pos    = eomc_pos_none
                    }
                }                    
            }   
        },  
        .jomocoupling       =
        {
            .joint2set      = 
            {   // each joint is on a different set 
                0, 1, 2, 3 
            },
            .joint2motor    = 
            {   // tbd
                { EO_COMMON_FLOAT_TO_Q17_14(1.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f) }        
            },
            .encoder2joint  = 
            {   // identical matrix
                { EO_COMMON_FLOAT_TO_Q17_14(1.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f) },
                { EO_COMMON_FLOAT_TO_Q17_14(0.0f),      EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(0.0f),    EO_COMMON_FLOAT_TO_Q17_14(1.0f) } 
            }  
        }        
    }
};

In here is a screenshot of the TRACE port of the ems board telling that all is working fine.

STILL TODO
We still have to integrate the case inside the files of MController, but that can be done later on a proper setup with a mc4plus board and DC motors and xml files and ... changes in icub-main.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,149,2020-12-11T16:23:06Z,2020-12-11T16:23:35Z,2020-12-11T16:23:35Z,MERGED,True,5612,15,59,https://github.com/marcoaccame,PZM driver for `pmc` board,2,[],https://github.com/robotology/icub-firmware/pull/149,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/149,"This PR adds the driver for moving the Piezo Electric Motor plus related encoders as used in the pmc board.
The code is added and compiles in the pmc application project if we define macro USE_PZMdriver.","This PR adds the driver for moving the Piezo Electric Motor plus related encoders as used in the pmc board.
The code is added and compiles in the pmc application project if we define macro USE_PZMdriver.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,150,2020-12-14T14:27:53Z,2020-12-14T14:28:09Z,2020-12-14T14:28:09Z,MERGED,True,1343,871,74,https://github.com/marcoaccame,pmc board: realigned the cube-mx project,3,[],https://github.com/robotology/icub-firmware/pull/150,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/150,"This PR is required to realign the cube-mx project after the work done to integrate the piezo electric motors and their sensors.
The stm32hal library was tested on the pmc board which shows a correct can behaviour in CAN communication and i2c reading.","This PR is required to realign the cube-mx project after the work done to integrate the piezo electric motors and their sensors.
The stm32hal library was tested on the pmc board which shows a correct can behaviour in CAN communication and i2c reading.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,151,2020-12-15T10:37:55Z,2020-12-15T15:17:28Z,2020-12-15T15:17:29Z,MERGED,True,12,12,3,https://github.com/davidetome,updated revision and date,2,[],https://github.com/robotology/icub-firmware/pull/151,https://github.com/davidetome,1,https://github.com/robotology/icub-firmware/pull/151,"mc4plus 3.28 - mc2plus 3.19 - ems004 3.35
see robotology/community#423
cc @marcoaccame  @pattacini","mc4plus 3.28 - mc2plus 3.19 - ems004 3.35
see robotology/community#423
cc @marcoaccame  @pattacini",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/isorrentino,1,https://github.com/robotology/icub-firmware/pull/153,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame","This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame",True,"{'HOORAY': ['https://github.com/GiulioRomualdi'], 'ROCKET': ['https://github.com/DanielePucci']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/153#issuecomment-747365507,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame","Hi @ale-git, can you pls have a look at that?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/isorrentino,3,https://github.com/robotology/icub-firmware/pull/153#issuecomment-749461677,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame","Hi @marcoaccame, sorry for the late reply.

i have spotted that the PR is vs master. we typically do development in devel, hence most PR are vs devel unless there is some nasty bug which we want to solve and which affects robots around. is there a reason for you having used master? if not, would it be possible to use devel instead?

There is no reason in using master instead of devel, so I will rebase my branches on devel. Thank you for the information.

i would rather remove all the 8 lines w/ the typedef and put a nice and standard #include ""stdint.h"" instead. can you pls test if it solves the compilation problem?

I will test the change as soon as possible.",True,{'THUMBS_UP': ['https://github.com/traversaro']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/isorrentino,4,https://github.com/robotology/icub-firmware/pull/153#issuecomment-759330179,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame",cc @giovannipizzolante,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/giovannipizzolante,5,https://github.com/robotology/icub-firmware/pull/153#issuecomment-760909650,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame","I have open another PR vs devel where I removed all the 8 lines w/ the typedef and put a nice and standard #include ""stdint.h"" instead and this solves compilation problem.",True,{'THUMBS_UP': ['https://github.com/isorrentino']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/traversaro,6,https://github.com/robotology/icub-firmware/pull/153#issuecomment-765246600,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame","@isorrentino @giovannipizzolante I think we can close this PR as it has been superseded by #158, right?",True,{'THUMBS_UP': ['https://github.com/giovannipizzolante']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,153,2020-12-15T13:46:53Z,2021-01-22T08:56:59Z,2021-01-22T08:57:47Z,CLOSED,False,1,1,1,https://github.com/isorrentino,2foc firmware - fix compilation error. ,1,[],https://github.com/robotology/icub-firmware/pull/153,https://github.com/isorrentino,7,https://github.com/robotology/icub-firmware/pull/153#issuecomment-765247261,"This fix #152.
cc @GiulioRomualdi @traversaro @nunoguedelha @marcoaccame",Yes. Closing.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/Nicogene,1,https://github.com/robotology/icub-firmware/pull/154,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.",True,"{'ROCKET': ['https://github.com/S-Dafarra', 'https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/traversaro,2,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747356452,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.",cc @S-Dafarra,True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/traversaro,3,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747357883,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","I just realized that there is something we should pay attention for the future: at the moment the hot fix is done in a part of the code that at first sight seems to be quite device independent, while it is definitely a device-dependent change. At the moment as we just support the bno055 sensor in embot it is not a problem, but this is something we should remember if we ever had support for other IMUs in embot.",True,{'THUMBS_UP': ['https://github.com/Nicogene']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/S-Dafarra,4,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747358331,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","I have to say that I found that mapping a bit ""empirically"", matching the expected RPY data with the measured ones. I wonder if that mapping can be found from datasheet, and hence documented.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/Nicogene,5,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747361207,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","I have to say that I found that mapping a bit ""empirically"", matching the expected RPY data with the measured ones. I wonder if that mapping can be found from datasheet, and hence documented.

In the datasheet there is written that the euler representation can be either the windows(default) or android one, but I didn't find a clear definition of those representations",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/traversaro,6,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747365054,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","I have to say that I found that mapping a bit ""empirically"", matching the expected RPY data with the measured ones. I wonder if that mapping can be found from datasheet, and hence documented.

The only documentation is in section 3.6.2 of the BNO055 datasheet ( https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bno055-ds000.pdf, archived: http://web.archive.org/web/20201217104844/https://www.bosch-sensortec.com/media/boschsensortec/downloads/datasheets/bst-bno055-ds000.pdf ), but as @Nicogene was mentioned these kind of descriptions are unfortunately quite ambiguous and not precise from a mathematical point of view. Nevertheless, we could add a link to it. We could try to contact Bosch for more details, but in my experience getting in contact with someone that actually is getting the problem and knows how to answer is not trivial.
In this sense, inspecting directly the data a done by @S-Dafarra seems to be a much less error-prone process that trying to interpreter ambiguous technical documentation.",True,"{'THUMBS_UP': ['https://github.com/S-Dafarra', 'https://github.com/Nicogene']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/Nicogene,7,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747367010,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","I just realized that there is something we should pay attention for the future: at the moment the hot fix is done in a part of the code that at first sight seems to be quite device independent, while it is definitely a device-dependent change. At the moment as we just support the bno055 sensor in embot it is not a problem, but this is something we should remember if we ever had support for other IMUs in embot.

BTW I found a place HW dependent where introduce this fix, stay tuned",True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/Nicogene,8,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747396375,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","that it does not introduces unexpected problems for instance in some other high-level software that is relying on the current order of values.

This should not happen because the high-level software(e.g. iKinGazeCtrl) uses only the acc and gyro measurements.

BTW I found a place HW dependent where introduce this fix, stay tuned

After a chat with @marcoaccame, we decided to keep the fix where it is, since that cpp file has already references to the bno055 then, when we will need to support another type of imu we have to refactor it.
Moreover move it in the specific bno055 cpp file is quite laborious, we can ship this fix as it is and address this refactor when we will want to support a different IMU",True,{'THUMBS_UP': ['https://github.com/traversaro']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/S-Dafarra,9,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747417418,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","After a chat with @marcoaccame, we decided to keep the fix where it is, since that cpp file has already references to the bno055 then, when we will need to support another type of imu we have to refactor it.
Moreover move it in the specific bno055 cpp file is quite laborious, we can ship this fix as it is and address this refactor when we will want to support a different IMU

It may be stupid, but applying the mapping to https://github.com/robotology/icub-firmware/blob/b6c0a716bb/emBODY/eBcode/arch-arm/embot/hw/embot_hw_bno055.h#L141 would make sense? Just trying 
Edit. I also tried to look a bit on the code. I was thinking that the load method of the data was called every time the IMU data was set. But on the other hand, I don't know if this is the case for every communication interface (e.g. i2c). So feel free to simply ignore what I wrote ",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/Nicogene,10,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747430632,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","It may be stupid, but applying the mapping to https://github.com/robotology/icub-firmware/blob/b6c0a716bb/emBODY/eBcode/arch-arm/embot/hw/embot_hw_bno055.h#L141 would make sense? Just trying 

Play on the memory mapping is a way to do it, another way is to manipulate the Data structure when populated by i2c, they are both absolutely doable but require changes that have to be done and checked carefully.
On the other hand, the changes of this PR gives fewer headaches ",True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/S-Dafarra,11,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747431194,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","It may be stupid, but applying the mapping to https://github.com/robotology/icub-firmware/blob/b6c0a716bb/emBODY/eBcode/arch-arm/embot/hw/embot_hw_bno055.h#L141 would make sense? Just trying grin

Play on the memory mapping is a way to do it, another way is to manipulate the Data structure when populated by i2c, they are both absolutely doable but require changes that have to be done and checked carefully.
On the other hand, the changes of this PR gives fewer headaches

Clear ",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/marcoaccame,12,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747433049,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","It may be stupid, but applying the mapping to https://github.com/robotology/icub-firmware/blob/b6c0a716bb/emBODY/eBcode/arch-arm/embot/hw/embot_hw_bno055.h#L141 would make sense? Just trying 

it would not solve the bug.
because the code we use does not call the above load() method. the code we use just tells the i2c driver to write in dma, hence without the possibility to call any transformation.
we surely can add an extra callback function which the embot::hw::bno055 calls at end of the dma transfer and to do the permutation in there. it is feasible and nice to do but it needs some more effort than the elegant solution proposed by @Nicogene.
we could implement it and test thoroughly at a later stage.",True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/S-Dafarra,13,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747434263,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","It may be stupid, but applying the mapping to https://github.com/robotology/icub-firmware/blob/b6c0a716bb/emBODY/eBcode/arch-arm/embot/hw/embot_hw_bno055.h#L141 would make sense? Just trying grin

it would not solve the bug.
because the code we use does not call the above load() method. the code we use just tells the i2c driver to write in dma, hence without the possibility to call any transformation.
we surely can add an extra callback function which the embot::hw::bno055 calls at end of the dma transfer and to do the permutation in there. it is feasible and nice to do but it needs some more effort than the elegant solution proposed by @Nicogene.
we could implement it and test thoroughly at a later stage.

Thanks for the explanation. Consider mine a simple curiosity. I am totally fine with the current solution",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/traversaro,14,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747448157,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.",Just a curiosity: why we bumped the version of the STRAIN2 and not the one of the other boards affected by this change?,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/Nicogene,15,https://github.com/robotology/icub-firmware/pull/154#issuecomment-747458430,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","Just a curiosity: why we bumped the version of the STRAIN2 and not the one of the other boards affected by this change?

Because I forgot it  thanks for spotting it
@marcoaccame please correct if I put wrong versions",True,"{'THUMBS_UP': ['https://github.com/traversaro', 'https://github.com/marcoaccame']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/S-Dafarra,16,https://github.com/robotology/icub-firmware/pull/154#issuecomment-774210379,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","I wanted to test this, but it seems that the STRAIN2 firmware version of icub-firmware-build is not aligned: https://github.com/robotology/icub-firmware-build/tree/devel/CAN/strain2",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/marcoaccame,17,https://github.com/robotology/icub-firmware/pull/154#issuecomment-775793528,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.",Hi @S-Dafarra. I am looking into that. I will come back to you soon.,True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/marcoaccame,18,https://github.com/robotology/icub-firmware/pull/154#issuecomment-775934782,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","Hi @S-Dafarra, the binaries are in devel now. pls see robotology/icub-firmware-build#22",True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,154,2020-12-17T10:29:15Z,2020-12-17T15:30:54Z,2021-06-20T07:41:32Z,MERGED,True,9,5,4,https://github.com/Nicogene,embot_app_application_theIMU: fix euler angle representation,1,"['bug', 'CAN']",https://github.com/robotology/icub-firmware/pull/154,https://github.com/S-Dafarra,19,https://github.com/robotology/icub-firmware/pull/154#issuecomment-775935541,"The Bosch Euler representation can be either the windows(default) or android but in YARP
we have a different representation(see https://github.com/robotology/yarp/blob/0481f994c6e03897d038c5f1d1078145646a1772/src/libYARP_dev/src/yarp/dev/MultipleAnalogSensorsInterfaces.h#L302-L348).
It fixes robotology/icub-main#701
The application version has been increased to 2.0.10
THIS HAS TO BE TESTED BEFORE MERGING.","Hi @S-Dafarra, the binaries are in devel now. pls see robotology/icub-firmware-build#22

Thanks @marcoaccame  and @Nicogene, I will test it soon.",True,{'THUMBS_UP': ['https://github.com/Nicogene']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,155,2020-12-18T14:49:01Z,2020-12-18T14:49:16Z,2020-12-18T14:49:16Z,MERGED,True,245,85,5,https://github.com/marcoaccame,changes for control of the new hand,4,[],https://github.com/robotology/icub-firmware/pull/155,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/155,"This PR move to devel some development done for the new hand.
In particular:

mc4plus / ems: it adds management of eomc_enc_pos to the MController
pmc: if a specific macro is defined it calibrates in range [0, 90]  the position of the fingers of the hand v3-2021

the merge affects nothing but the applications used for the demo of the new hand v3.","This PR move to devel some development done for the new hand.
In particular:

mc4plus / ems: it adds management of eomc_enc_pos to the MController
pmc: if a specific macro is defined it calibrates in range [0, 90]  the position of the fingers of the hand v3-2021

the merge affects nothing but the applications used for the demo of the new hand v3.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,156,2020-12-18T15:01:42Z,2020-12-18T15:02:10Z,2020-12-18T15:02:10Z,MERGED,True,1,1,1,https://github.com/marcoaccame,C++ compilation of ETH protocol callback funtions,1,[],https://github.com/robotology/icub-firmware/pull/156,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/156,"This PR solves the case of C++ compilation of the file which contains the callbacks of ETH protocol handling for the motion control endpoint. The other endpoints are already OK.
If we use C++ compilation and we don't include the proper API file, then the linker cannot find the correct definition of eoprot_fun_UPDT_mc_*() files required by any C compiled module due to different decoration standard.
This file is not, so fare, compiled in C++ mode, but ... we must be ready.","This PR solves the case of C++ compilation of the file which contains the callbacks of ETH protocol handling for the motion control endpoint. The other endpoints are already OK.
If we use C++ compilation and we don't include the proper API file, then the linker cannot find the correct definition of eoprot_fun_UPDT_mc_*() files required by any C compiled module due to different decoration standard.
This file is not, so fare, compiled in C++ mode, but ... we must be ready.",True,"{'THUMBS_UP': ['https://github.com/Nicogene', 'https://github.com/ale-git']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,157,2021-01-04T12:10:53Z,2021-01-04T12:11:07Z,2021-01-04T12:11:07Z,MERGED,True,10507,46,19,https://github.com/marcoaccame,mc4plus for open/close of the fingers of handv3,11,[],https://github.com/robotology/icub-firmware/pull/157,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/157,"This PR adds features in the mc4plus code which allow to drive the four DC motors used to open / close the fingers of the new hand V3.
The mc4plus uses a new type of MC service called eomn_serv_MC_mc4plusfaps.  This mode was successfully tested running on a mc4plus board compiled with a dedicated project which sets the proper macros. This approach keeps compatibility with the code of the standard mc4plus.
The tests was done with a yarprobotinterface compiled with this fork of icub-main).","This PR adds features in the mc4plus code which allow to drive the four DC motors used to open / close the fingers of the new hand V3.
The mc4plus uses a new type of MC service called eomn_serv_MC_mc4plusfaps.  This mode was successfully tested running on a mc4plus board compiled with a dedicated project which sets the proper macros. This approach keeps compatibility with the code of the standard mc4plus.
The tests was done with a yarprobotinterface compiled with this fork of icub-main).",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,158,2021-01-15T12:14:44Z,2021-01-28T14:30:09Z,2021-01-28T14:30:09Z,MERGED,True,2,11,1,https://github.com/giovannipizzolante, 2FOC Firmware -  fix compilation error,2,[],https://github.com/robotology/icub-firmware/pull/158,https://github.com/giovannipizzolante,1,https://github.com/robotology/icub-firmware/pull/158,"This fix #152 . As suggested by @marcoaccame the compilation error has been fixed by removing typedef lines and putting an #include ""stdint.h"" .","This fix #152 . As suggested by @marcoaccame the compilation error has been fixed by removing typedef lines and putting an #include ""stdint.h"" .",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,158,2021-01-15T12:14:44Z,2021-01-28T14:30:09Z,2021-01-28T14:30:09Z,MERGED,True,2,11,1,https://github.com/giovannipizzolante, 2FOC Firmware -  fix compilation error,2,[],https://github.com/robotology/icub-firmware/pull/158,https://github.com/traversaro,2,https://github.com/robotology/icub-firmware/pull/158#issuecomment-766716974,"This fix #152 . As suggested by @marcoaccame the compilation error has been fixed by removing typedef lines and putting an #include ""stdint.h"" .","@marcoaccame Feel free to let @giovannipizzolante if you prefer brackets or commas for the include (see #158 (comment)), thanks!",True,{'THUMBS_UP': ['https://github.com/GiulioRomualdi']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,158,2021-01-15T12:14:44Z,2021-01-28T14:30:09Z,2021-01-28T14:30:09Z,MERGED,True,2,11,1,https://github.com/giovannipizzolante, 2FOC Firmware -  fix compilation error,2,[],https://github.com/robotology/icub-firmware/pull/158,https://github.com/marcoaccame,3,https://github.com/robotology/icub-firmware/pull/158#issuecomment-769098133,"This fix #152 . As suggested by @marcoaccame the compilation error has been fixed by removing typedef lines and putting an #include ""stdint.h"" .",Hi @traversaro: thanks for the suggestion. i have committed it. an thanks @giovannipizzolante for the test.,True,"{'THUMBS_UP': ['https://github.com/traversaro'], 'HOORAY': ['https://github.com/GiulioRomualdi']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,1,https://github.com/robotology/icub-firmware/pull/159,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/S-Dafarra,2,https://github.com/robotology/icub-firmware/pull/159#issuecomment-762956344,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","Thanks @Nicogene! Just to understand, the message will appear also as a warning in the logger right?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,3,https://github.com/robotology/icub-firmware/pull/159#issuecomment-762960325,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","It will appear an error, but no HW fault should be triggered
We can change it to warning but since the robot should be stopped at some point maybe is better to mark it as a problem",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/S-Dafarra,4,https://github.com/robotology/icub-firmware/pull/159#issuecomment-762961587,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","It will appear an error, but no HW fault should be triggered
We can change it to warning but since the robot should be stopped at some point maybe is better to mark it as a problem

No need to change, indeed I prefer if it still appears as an error. I was trying to understand the code ",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/Nicogene']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/pattacini,5,https://github.com/robotology/icub-firmware/pull/159#issuecomment-762964756,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","This PR will be applied FW-wide to all robots, in my understanding.
Do we want to go this way? What would the impact be on for example iCub 2.x?
Assessing this is not easy, I think. Probably, we could go for an experimental FW to address @S-Dafarra needs first.
What do you think @S-Dafarra @Nicogene ?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/pattacini,6,https://github.com/robotology/icub-firmware/pull/159#issuecomment-765245321,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","After a discussion with @ale-git, we think it's safe to proceed with merging the PR also considering the iCub 2.5 robots.",True,"{'THUMBS_UP': ['https://github.com/Nicogene', 'https://github.com/GiulioRomualdi']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/S-Dafarra,7,https://github.com/robotology/icub-firmware/pull/159#issuecomment-768981560,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",cc @isorrentino,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/GiulioRomualdi,8,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769295394,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","Hi all, we tried to test the firmware. We flashed the 2foc and everything went fine and we were able to run the robot.
Then we flashed the ems and we got the following error while running the yarprobotinterface.
We have the latest version of icub-firmware-shared and icub-main of devel.
[1611859326.601956] [ERROR] /usr/local/src/robot/robotology-superbuild/robotology/ICUB/src/libraries/icubmod/embObjLib/ethResource.cpp:298 bool eth::EthResource::verifyBoardTransceiver() (0x0000314f) EthResource::verifyBoardTransceiver() detected different mn protocol minor versions: local = 17 , remote = 16 : cannot proceed any further.
[1611859326.602063] [ERROR] /usr/local/src/robot/robotology-superbuild/robotology/ICUB/src/libraries/icubmod/embObjLib/ethResource.cpp:299 bool eth::EthResource::verifyBoardTransceiver() (0x0000314f) ACTION REQUIRED: BOARD right_arm-eb29-j12_15 with IP 10.0.1.29 needs a FW update.
[1611859326.602191] [ERROR] /usr/local/src/robot/robotology-superbuild/robotology/ICUB/src/libraries/icubmod/embObjLib/ethResource.cpp:499 virtual bool eth::EthResource::verifyEPprotocol(eOprot_endpoint_t) (0x0000314f) EthResource::verifyEPprotocol() cannot verify BOARD right_arm-eb29-j12_15 with IP 10.0.1.29 : cannot proceed any further
[1611859326.602327] [ERROR] /usr/local/src/robot/robotology-superbuild/robotology/ICUB/src/libraries/icubmod/embObjMotionControl/embObjMotionControl.cpp:376 virtual bool yarp::dev::embObjMotionControl::open(yarp::os::Searchable&) (0x0000314f) embObjMotionControl: failed verifyEPprotocol. Cannot continue!",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/isorrentino,9,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769718215,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","We understood which was the problem. After flashed the EMS boards, we needed to update icub_firmware_shared to the latest devel. After that the firmware of the mc4plus boards was unable to start and the yarprobotinterface was requesting a firmware update. Then, we flashed also the mc4plus boards with the latest devel of icub-firmware-build and the yarprobotinterface started but it prints on the terminal the following error saturating immediatly the logger:

Now, we are going to test the walking.",True,{'ROCKET': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/S-Dafarra,10,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769720512,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","We understood which was the problem. After flashed the EMS boards, we needed to update icub_firmware_shared to the latest devel. After that the firmware of the mc4plus boards was unable to start and the yarprobotinterface was requesting a firmware update. Then, we flashed also the mc4plus boards with the latest devel of icub-firmware-build and the yarprobotinterface started but it prints on the terminal the following error saturating immediatly the logger:

Now, we are going to test the walking.

Interestingly, it is happening on the right leg. I wonder if it is related to icub-tech-iit/task-force-miscellanea#69. I also wonder how the encoder can be broken and the motor still be able to move.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/isorrentino,11,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769728351,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",The Walking is working fine.,True,"{'ROCKET': ['https://github.com/Nicogene', 'https://github.com/S-Dafarra', 'https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,12,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769730428,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","We understood which was the problem. After flashed the EMS boards, we needed to update icub_firmware_shared to the latest devel. After that the firmware of the mc4plus boards was unable to start and the yarprobotinterface was requesting a firmware update.

I suspected that might be the problem, I created the binaries using the latest icub-firmware-shared, good that you solved it!
About the print, the idea is to keep the error printed but not trigger HW fault.

the Walking is working fine

Super!
I hope that the encoder is actually broken and it is not a false error",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/pattacini,13,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769730593,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","Good that the walking is working 

Interestingly, it is happening on the right leg. I wonder if it is related to icub-tech-iit/task-force-miscellanea#69. I also wonder how the encoder can be broken and the motor still be able to move.

This PR just disables the HF to raise error messages instead, so I'd expect that the HF was triggered formerly.
Is that correct? Maybe not as continuously as it seems now.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/pattacini,14,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769735264,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","For this PR, @Nicogene could you please address @marcoaccame 's comments and then proceed with merging/uploading the FW?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,15,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769736242,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","For this PR, @Nicogene could you please address @marcoaccame 's comments and then proceed with merging/uploading the FW?

For the ems I can figure out how to change the version, but I might need help for the 2foc, @marcoaccame I will contact you!",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/isorrentino,16,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769740538,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",@Nicogene here is an example of how to change the 2foc firmware version isorrentino@45951ab.,True,{'THUMBS_UP': ['https://github.com/Nicogene']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,17,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769787389,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","@marcoaccame I increased the version of all the board you mentioned
Did I do it correctly?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/marcoaccame,18,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769787676,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","@marcoaccame I increased the version of all the board you mentioned
Did I do it correctly?

let me check ...",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/marcoaccame,19,https://github.com/robotology/icub-firmware/pull/159#issuecomment-769794434,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","ok, correct",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/GiulioRomualdi,20,https://github.com/robotology/icub-firmware/pull/159#issuecomment-770118302,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",Could you push the new version of the firmware on icub-firmware-build? So we can update it with the latest modifications,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/pattacini,21,https://github.com/robotology/icub-firmware/pull/159#issuecomment-770841782,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",@Nicogene could you do that?,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,22,https://github.com/robotology/icub-firmware/pull/159#issuecomment-770898468,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","I can do it for ems, mc4plus and mc2plus, but I don't know how to build the 2foc firmware",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/pattacini,23,https://github.com/robotology/icub-firmware/pull/159#issuecomment-770924746,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini",@marcoaccame @ale-git any clue on the 2FOC?,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/isorrentino,24,https://github.com/robotology/icub-firmware/pull/159#issuecomment-770930277,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","@Nicogene I think this comment ami-iit/element_torque-control-via-current#126 (comment) can help you (I dont' know if you have the rights to read it). I copy the comment here.

Installing the MPLAB X IDE

Goto https://www.microchip.com/mplab/mplab-x-ide and browse down to ""Downloads"" section and download the latest version of MPLAB X IDE driver for Windows (currently v5.40).
follow the instruction and default options

Installing the MPLAB XC Compilers
All the compilers and related dependencies can be downloaded from https://www.microchip.com/mplab/compilers, in the last section, in the tab ""Compiler Downloads"".

The latest version for the compiler and dependencies on Windows is v1.50.

After the install of the MPLAB X IDE is complete, follow the suggestion to download the ""MPLAB XC compiler 16 bits"" for dsPICs, and download the ""MPLAB XC16 Compiler vX.XX"" compiler for Windows, in ""Compiler Downloads"" tab (as shown above), ""Compilers"" subsection.
Launch the compiler installation: select the ""free"" option, and select the default options in the steps that follow.
Download Install the ""MPLAB XC16 Compiler Part-Support Patch vX.XX"" from the subsection ""Latest Part Support Patch Files"". This is a priori for supporting new parts, but actually the dsPIC used in our setup, version 33FJ128MC802, appears in the ""supported parts in the update"" secttion of the release notes of the patch.
Download Install the ""Current Peripheral Libraries"" -> ""16-bit dsPIC33, PIC24E, PIC24H MCUs: Legacy Peripheral Libraries"" from the subsection ""Peripheral Libraries (PLIBS)"" (latest version of ""PIC24/dsPIC Peripheral Libraries v2.00 - Windows"" here).

Note on the ""MPLAB XC16 Compiler vX.XX"" compiler
The compiler ""MPLAB XC16 Compiler v1.50"" alone is missing some dependencies like the include <pwm12.h>. If you build the project without the mentioned additonnal patches, you'll get the error:
CLEAN SUCCESSFUL (total time: 8ms)
make -f nbproject/Makefile-default.mk SUBPROJECTS= .build-conf
make[1]: Entering directory 'C:/Users/icub/git/icub-firmware/emBODY/eBcode/arch-dspic/board/2foc/appl/2FOC-V3/2FOC-V3.X'
make  -f nbproject/Makefile-default.mk dist/default/production/2FOC-V3.X.production.hex
make[2]: Entering directory 'C:/Users/icub/git/icub-firmware/emBODY/eBcode/arch-dspic/board/2foc/appl/2FOC-V3/2FOC-V3.X'
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/2FOC.c  -o build/default/production/_ext/1360937237/2FOC.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/2FOC.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/DHES.c  -o build/default/production/_ext/1360937237/DHES.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/DHES.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../asm/MeasCurr.s  -o build/default/production/_ext/1360919980/MeasCurr.o  -c -mcpu=33FJ128MC802  -omf=elf -DXPRJ_default=default  -legacy-libc  -I""../asm"" -Wa,-MD,""build/default/production/_ext/1360919980/MeasCurr.o.d"",--defsym=__MPLAB_BUILD=1,--no-relax  -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/Faults.c  -o build/default/production/_ext/1360937237/Faults.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/Faults.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/PWM.c  -o build/default/production/_ext/1360937237/PWM.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/PWM.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/ADC.c  -o build/default/production/_ext/1360937237/ADC.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/ADC.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/System.c  -o build/default/production/_ext/1360937237/System.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/System.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/DCLink.c  -o build/default/production/_ext/1360937237/DCLink.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/DCLink.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
""C:\Program Files\Microchip\xc16\v1.50\bin\xc16-gcc.exe""   ../src/can_icubProto.c  -o build/default/production/_ext/1360937237/can_icubProto.o  -c -mcpu=33FJ128MC802  -MMD -MF ""build/default/production/_ext/1360937237/can_icubProto.o.d""        -omf=elf -DXPRJ_default=default  -legacy-libc    -ffunction-sections -mlarge-data -O3 -I""../include"" -msmart-io=1 -Wall -msfr-warn=off    -mdfp=""C:/Program Files (x86)/Microchip/MPLABX/v5.40/packs/Microchip/dsPIC33F-GP-MC_DFP/1.2.35/xc16""
Options have been disabled due to restricted license
Visit https://www.microchip.com/compilers to purchase a new key.
In file included from ../src/Faults.c:5:0:
../include/PWM.h:10:19: fatal error: pwm12.h: No such file or directory
compilation terminated.

This is a known issue with the latest drivers released after version v1.24. The fast workaround in the previous setuhttps://github.com/robotology/icub-firmware/issues/161p was to revert the driver back to version 1.24. That version should be available in https://www.microchip.com/development-tools/pic-and-dspic-downloads-archive, but does not clearly appear in section ""MPLAB C Compiler for PIC24 and dsPIC DSCs"" and seems to be available only as ""Source Archives"". The real cause of the issue is actually explained in the v1.25 release notes:
The peripheral libraries are no longer shipped with the compiler package. These may be downloaded separately from the MPLAB XC download page.

So, the proper fix is to download the additional Legacy Peripheral Libraries as explained int the previous section.
Running the MPLAB X IDE [WIP]

Run app MPLAB X IDE v5.40.
Open the project 2FOC-V3.X (shortcut CTRL+SHIFT+O on windows).
you should see in the lower left pane:


The 2FOC device is the dsPIC33FJ128MC802.

Then click on Packs - dsPIC33F-GP-...   You should see a popup window with the project properties


just click ""OK"".

Clean and Build the project as shown below:



If you include also @GiulioRomualdi's modifications you can compile it also on Ubuntu (GiulioRomualdi@e31a04b).
I think we should open an issue similar to #161.
cc @pattacini",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/Nicogene']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,159,2021-01-19T16:19:04Z,2021-01-29T13:08:46Z,2021-02-10T14:28:02Z,MERGED,True,130,134,8,https://github.com/Nicogene,Deal with dirty encoder or broken phase as non-HF errors,8,[],https://github.com/robotology/icub-firmware/pull/159,https://github.com/Nicogene,25,https://github.com/robotology/icub-firmware/pull/159#issuecomment-770981590,"These errors used to trigger HW, now just print out the problem
Please review code.
cc @S-Dafarra @pattacini","@ale-git compiled for me the 2foc firmware, here is the PR for integrating it in icub-firmware-build robotology/icub-firmware-build#20",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,163,2021-02-01T08:32:43Z,2021-02-02T08:06:18Z,2021-02-02T08:26:51Z,MERGED,True,11,11,8,https://github.com/GiulioRomualdi,Fix linux compilation of 2FOC firmware,2,[],https://github.com/robotology/icub-firmware/pull/163,https://github.com/GiulioRomualdi,1,https://github.com/robotology/icub-firmware/pull/163,"This PR fixes #162
cc @marcoaccame @ale-git @traversaro @isorrentino","This PR fixes #162
cc @marcoaccame @ale-git @traversaro @isorrentino",True,{'HOORAY': ['https://github.com/isorrentino']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,163,2021-02-01T08:32:43Z,2021-02-02T08:06:18Z,2021-02-02T08:26:51Z,MERGED,True,11,11,8,https://github.com/GiulioRomualdi,Fix linux compilation of 2FOC firmware,2,[],https://github.com/robotology/icub-firmware/pull/163,https://github.com/GiulioRomualdi,2,https://github.com/robotology/icub-firmware/pull/163#issuecomment-770678377,"This PR fixes #162
cc @marcoaccame @ale-git @traversaro @isorrentino",The PR has been already tested on the motor setup we have. In detail @isorrentino compiled the firmware in Ubuntu Linux 20.04 and then she flashed on the setup.,True,{'THUMBS_UP': ['https://github.com/isorrentino']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,166,2021-02-11T08:18:30Z,2021-02-11T08:19:12Z,2021-02-11T08:19:12Z,MERGED,True,118,10,7,https://github.com/marcoaccame,The LED of pmc board are associated to FAP readings,3,[],https://github.com/robotology/icub-firmware/pull/166,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/166,"As per title.
The application of the pmc board now activates teh LEDs according to the rules in the following picture, which is also in this description file: xxx.

This info is very much useful for verifying the correct cabling of the pmc on the hand framework so that all sensors can effectively read. Caveat: if one sensor does not read at startup it will never be seen again. One must, for now, power off, adjust flat wires, restart. Or use a dedicated test program which will be in repository soon.","As per title.
The application of the pmc board now activates teh LEDs according to the rules in the following picture, which is also in this description file: xxx.

This info is very much useful for verifying the correct cabling of the pmc on the hand framework so that all sensors can effectively read. Caveat: if one sensor does not read at startup it will never be seen again. One must, for now, power off, adjust flat wires, restart. Or use a dedicated test program which will be in repository soon.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,167,2021-02-11T13:18:57Z,2021-02-11T13:19:57Z,2021-02-11T13:19:57Z,MERGED,True,2181,1045,89,https://github.com/marcoaccame,pmc board w/ piezo motor driver,11,[],https://github.com/robotology/icub-firmware/pull/167,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/167,"The pmc board implements the movement of the piezo motors (PZM) and the reading of every position sensor.
The PZM are activated by velocity setpoints received over CAN. The messages are of type motor::periodic::CMD::EMSTO2FOC_DESIRED_CURRENT, the same accepted by the 2foc board. The board applies the received velocity values to all is three motors until either a new setpoint arrives or a timeout expires. The timeout is for now imposed by the application and is equal 100 ms.
Moreover, the pmc application starts the reading of all its position sensors: the absolute magnetic rotational sensors applied at the joints and read by the tlv chips, the absolute encoder for the rotation of the thumb, the two incremental quadrature encoder at the PZM motors (index adduction and thumb metacarpus).
This code was thoroughly tested on the setup of the new hand.","The pmc board implements the movement of the piezo motors (PZM) and the reading of every position sensor.
The PZM are activated by velocity setpoints received over CAN. The messages are of type motor::periodic::CMD::EMSTO2FOC_DESIRED_CURRENT, the same accepted by the 2foc board. The board applies the received velocity values to all is three motors until either a new setpoint arrives or a timeout expires. The timeout is for now imposed by the application and is equal 100 ms.
Moreover, the pmc application starts the reading of all its position sensors: the absolute magnetic rotational sensors applied at the joints and read by the tlv chips, the absolute encoder for the rotation of the thumb, the two incremental quadrature encoder at the PZM motors (index adduction and thumb metacarpus).
This code was thoroughly tested on the setup of the new hand.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,168,2021-02-12T17:12:10Z,2021-02-12T17:13:17Z,2021-02-12T17:13:17Z,MERGED,True,7923,84,24,https://github.com/marcoaccame,Added bootloader for board amcbldc,3,[],https://github.com/robotology/icub-firmware/pull/168,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/168,"as per title.
successfully tested CAN communication w/ CANreal","as per title.
successfully tested CAN communication w/ CANreal",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,169,2021-02-18T09:36:53Z,2021-02-18T09:37:40Z,2021-02-18T09:37:40Z,MERGED,True,3849,0,8,https://github.com/marcoaccame,amcbldc: added a simple application,1,[],https://github.com/robotology/icub-firmware/pull/169,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/169,"w/ following features:

it starts on top of bootloader
it blinks LEDs (LED::one @ 1 Hz, LED::two w/ a waveform)
it manages some CAN messages (basic ones + EMSTO2FOC_DESIRED_CURRENT)","w/ following features:

it starts on top of bootloader
it blinks LEDs (LED::one @ 1 Hz, LED::two w/ a waveform)
it manages some CAN messages (basic ones + EMSTO2FOC_DESIRED_CURRENT)",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/AlexAntn,1,https://github.com/robotology/icub-firmware/pull/170,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra",True,"{'ROCKET': ['https://github.com/S-Dafarra', 'https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/170#issuecomment-784298117,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","@AlexAntn I would add up the info message following @marcoaccame 's how-to guide.
Needs to be carefully tested any how.

It is also required a small change in icub-firmware-shared, possibly w/ increase of its version and another one in icub-main so that it is forced to use the new version of icub-firmware-shared: here.",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/AlexAntn']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/pattacini,3,https://github.com/robotology/icub-firmware/pull/170#issuecomment-784318705,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","It is also required a small change in icub-firmware-shared, possibly w/ increase of its version and another one in icub-main so that it is forced to use the new version of icub-firmware-shared: here.

Yep, indeed we agreed on waiting until distro 2021.02 is out and the rush is over given the complexity of such a change.
cc @Nicogene",True,"{'THUMBS_UP': ['https://github.com/Nicogene', 'https://github.com/AlexAntn', 'https://github.com/marcoaccame']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/AlexAntn,4,https://github.com/robotology/icub-firmware/pull/170#issuecomment-789607975,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","I have updated this PR and opened this PR on icub-firmware-shared with the changes for the info message: robotology/icub-firmware-shared#46.
I have also implemented the changes on icub-main (to force the last version, for testing), but I have only committed them to my fork of icub-main, should I also open a PR?
We are testing these changes thoroughly to make sure nothing is affected.",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/pattacini,5,https://github.com/robotology/icub-firmware/pull/170#issuecomment-789609047,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","I have also implemented the changes on icub-main (to force the last version, for testing), but I have only committed them to my fork of icub-main, should I also open a PR?

Sure! Thanks @AlexAntn
The PR shall target icub-main@devel.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/pattacini,6,https://github.com/robotology/icub-firmware/pull/170#issuecomment-789679268,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra",Here's the PR on icub-main: robotology/icub-main#723.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/AlexAntn,7,https://github.com/robotology/icub-firmware/pull/170#issuecomment-800303882,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","I have managed to test the firmware with the single motor setup we have, and the mechanism for sending the messages is working as intended (send 10 messages, stop, reset when the error is gone and inform the user).
The only issue I am currently trying to understand has to do with the actual string sent in the Info message that should inform the user that the error has disappeared. Regarding this issue, I have realized the following:

I implemented a new eoerror_value_MC_motor_qencoder_phase_disappeared value for the info message, which has the value 17 (incremented the enum to account for this new value) in these lines
I implemented also the corresponding string here
When I try sending this code through the Motor_send_diagnostic function (defined here and called here) it prints the following message:

from BOARD 10.0.1.1 ([m:), src LOCAL, adr 0, time 2057s 743m 838u: (code 0x02000011, par16 0x0000 par64 0x0000000000000000) -> eoerror_INTERNALERROR__stringatwrongplace + .

After looking at the code, I figured this is because the actual value being used to query for the message string is higher than the maximum number of entries (18).

I tried re-ordering the entries on both the enum of values and the list of messages, and found that when I use the value eoerror_value_MC_motor_qencoder_phase_disappeared it always accesses the message string corresponding to the subsequent entry (basically, like it was incremented by 1). This would explain the value being higher than the maximum (since this entry was the last one in the enum);
Furthermore, I noticed that when I place this entry somewhere in the middle of the list (and re-order all entries accordingly), this error propagates to all the entries that come after this one (in that when I use them to send a message, it takes the value of the subsequent entry like it was incremented by 1).

I have tried getting to the bottom of this, but debugging at this level is proving to be challenging. Any possible hints on what could be generating this error, @marcoaccame (or others)?
NOTE: I have tried the re-ordering just for the sake of debugging, and only on the setup we have upstairs, since this should not be done in the actual implementation.
NOTE2: I have tried using the new Motor_send_diagnostic and the Motor_send_error functions to debug this issue, and both of them presented the same behavior.
NOTE3: In fact, looking at the message I inserted above, we can see that the code (0x02000011) is correct (0x02 corresponding to MC, 000011 - 17, corresponding to the correct value...)",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/pattacini,8,https://github.com/robotology/icub-firmware/pull/170#issuecomment-800310027,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","Thanks a lot @AlexAntn for the very accurate test 
So, we have potentially hit a lurking bug that impacts the handling of the info messages.",True,{'THUMBS_UP': ['https://github.com/AlexAntn']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/AlexAntn,9,https://github.com/robotology/icub-firmware/pull/170#issuecomment-800488214,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","After a quick chat with @marcoaccame , I double-checked the configuration of icub-main, and tested again, and the message is now correctly displayed!
This completes the pending tests, the PR can go forward!",True,"{'ROCKET': ['https://github.com/pattacini'], 'THUMBS_UP': ['https://github.com/marcoaccame']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,170,2021-02-19T14:43:52Z,2021-03-16T18:13:17Z,2021-03-16T18:13:17Z,MERGED,True,54,20,5,https://github.com/AlexAntn,Implement error counter so the logs don't overflow,4,[],https://github.com/robotology/icub-firmware/pull/170,https://github.com/pattacini,10,https://github.com/robotology/icub-firmware/pull/170#issuecomment-800494266,"This PR introduces an error counter and corresponding threshold to prevent an overflow of the logger when there is a non-HW-fault related issue.
Current behavior sends an error message up to 10 times, then stops sending the same error.
This counter is reset if/when the error disappears (allowing to see if the error is consistent during an experiment, or just pops up a couple of times).
Please review code.
CC @pattacini @S-Dafarra","That's great!
Let's upload the build as the final step, while I'll be merging all the involved PR's.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,171,2021-02-22T11:41:37Z,2021-02-23T14:17:16Z,2021-02-23T14:17:17Z,CLOSED,False,0,0,0,https://github.com/ale-git,Hand mk 2: added cable tension management,0,[],https://github.com/robotology/icub-firmware/pull/171,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/171,Added cable tension management to Mc4+ Mk 2 hand version. Compilation is acrivated by FINGER_MK3 macro.,Added cable tension management to Mc4+ Mk 2 hand version. Compilation is acrivated by FINGER_MK3 macro.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,173,2021-02-23T14:59:23Z,2021-02-23T15:40:07Z,2021-02-23T15:40:07Z,MERGED,True,58,3,5,https://github.com/ale-git,"Added cable management to hand Mk3, activated by FINGER_MK3 macro",1,[],https://github.com/robotology/icub-firmware/pull/173,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/173,"This PR is required to avoid too much stress on the steel tendons which drive the open-close movements of the hand mk3.
Its code is enabled only if macro FINGER_MK3 is defined. This macro is defined only in a special project, mc4plus.handv3.uvprojx used only for the new hand.
If not defined, the code is exactly the same as the one running on actual iCub's boards.","This PR is required to avoid too much stress on the steel tendons which drive the open-close movements of the hand mk3.
Its code is enabled only if macro FINGER_MK3 is defined. This macro is defined only in a special project, mc4plus.handv3.uvprojx used only for the new hand.
If not defined, the code is exactly the same as the one running on actual iCub's boards.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,176,2021-03-22T17:54:17Z,2021-03-25T11:43:08Z,2021-03-25T11:43:08Z,MERGED,True,766,81,23,https://github.com/marcoaccame,Multiple start of MC service,9,[],https://github.com/robotology/icub-firmware/pull/176,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/176,"As investigated in #174, the ems, mc4plus and mc2plus need a fix which solves their disappearance when yarprobotinterface is started / stopped several times.
This PR solves the problem.
As described in #174 (comment), the change was extensively tested, so it is ready to be merged.
A dual PR on icub-firmware-build is available so that we can merge both of them at the same time.","As investigated in #174, the ems, mc4plus and mc2plus need a fix which solves their disappearance when yarprobotinterface is started / stopped several times.
This PR solves the problem.
As described in #174 (comment), the change was extensively tested, so it is ready to be merged.
A dual PR on icub-firmware-build is available so that we can merge both of them at the same time.",True,{'THUMBS_UP': ['https://github.com/maggia80']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,176,2021-03-22T17:54:17Z,2021-03-25T11:43:08Z,2021-03-25T11:43:08Z,MERGED,True,766,81,23,https://github.com/marcoaccame,Multiple start of MC service,9,[],https://github.com/robotology/icub-firmware/pull/176,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/176#issuecomment-806583300,"As investigated in #174, the ems, mc4plus and mc2plus need a fix which solves their disappearance when yarprobotinterface is started / stopped several times.
This PR solves the problem.
As described in #174 (comment), the change was extensively tested, so it is ready to be merged.
A dual PR on icub-firmware-build is available so that we can merge both of them at the same time.",tested the binaries once more (see robotology/icub-firmware-build#25 (comment)),True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/177,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69","This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/177#issuecomment-807061345,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69","@ale-git it's also crucial to clarify the following points from the discussion we're having on the related issue:


Does this mean that the PIDs were indeed affected?
Do the PID gains need to be changed after this fix to maintain the existing behavior? In that case, this could involve a non-trivial robots-configuration migration



How does this change affect all the iCub robots?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/pattacini,3,https://github.com/robotology/icub-firmware/pull/177#issuecomment-814413149,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69","Hi @ale-git we'd need to accelerate the pace on this in order to complete the process.
As said above, we need to:

clean up the PR in order to retain only what's really relevant to it (you can do that by force-pushing new commits on the compare branch)
yield the new binaries",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/pattacini,4,https://github.com/robotology/icub-firmware/pull/177#issuecomment-816511134,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69","It's all good now from my side.
@marcoaccame could you review it again?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/pattacini,5,https://github.com/robotology/icub-firmware/pull/177#issuecomment-817656366,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69",@ale-git we'd need now to upload the new binaries.,True,"{'THUMBS_UP': ['https://github.com/marcoaccame', 'https://github.com/ale-git']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/marcoaccame,6,https://github.com/robotology/icub-firmware/pull/177#issuecomment-817656446,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69","Hi @ale-git:

Also, pls remember to build new binaries for the 2foc board (in icub-firmware-build I can see also the ones for R1) and prepare the associated PR.",True,{'THUMBS_UP': ['https://github.com/ale-git']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,177,2021-03-25T16:26:18Z,2021-04-12T09:38:10Z,2021-05-04T12:40:03Z,MERGED,True,4,3,4,https://github.com/ale-git,2FOC pwm feedback 5 bits shift bugfix,1,[],https://github.com/robotology/icub-firmware/pull/177,https://github.com/ale-git,7,https://github.com/robotology/icub-firmware/pull/177#issuecomment-831910222,"This PR fixes the 2FOC pwm feedback bug, that caused a 32x factor in the pwm feedback sent by the 2FOC to the EMS board, related to issue icub-tech-iit/task-force-miscellanea#69","I've generated the binaries:
robotology/icub-firmware-build#28",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,178,2021-03-30T15:53:06Z,2021-03-30T15:56:21Z,2021-03-30T15:56:28Z,MERGED,True,1122,6043,58,https://github.com/marcoaccame,ETH peripheral in stm32hal for stm32h745disco,2,[],https://github.com/robotology/icub-firmware/pull/178,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/178,"This PR integrates into the stm32hal library for board stm32h745disco the ETH peripheral required for UDP communication. It also configures the CM7 core to work at 400MHz.
This change does not interfere w/ other boards. As such the required tests were only to verify that some demo programs for the board which link the stm32hal library work fine. I tested basic and embot-os2 and they were successful.
Here is a video of demo embot-os2

  
    
    

    stm32h745disco-embot-os2.mp4","This PR integrates into the stm32hal library for board stm32h745disco the ETH peripheral required for UDP communication. It also configures the CM7 core to work at 400MHz.
This change does not interfere w/ other boards. As such the required tests were only to verify that some demo programs for the board which link the stm32hal library work fine. I tested basic and embot-os2 and they were successful.
Here is a video of demo embot-os2

  
    
    

    stm32h745disco-embot-os2.mp4",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,179,2021-04-12T10:13:44Z,2021-04-27T07:53:28Z,2022-01-11T09:44:13Z,MERGED,True,1857,393,41,https://github.com/marcoaccame,Support of 7 joints in the mk3 hand,15,[],https://github.com/robotology/icub-firmware/pull/179,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/179,"Aim of the PR
This PR is part of a set of PRs which adds support to manage the movement of the 7 joints of the mk3 hand.
The new MC mode is offered by the pair mc4plus and pmc and is hence nicknamed eomn_serv_MC_mc4pluspmc.
In order to do that, some features in icub-firmware and icub-firmware-shared are required in order to:

provide proper configuration of the new mode eomn_serv_MC_mc4pluspmc,
extend the data structures managed by the mc4plus board for the MC from 4 to 7.

The first feature adds changes to the data structures transmitted over ETH and hence has required an increase of the MN protocol version.
To limit the effect of the latter feature (which needs more RAM) the changes have been been conditioned to the macro EOTHESERVICES_customize_handV3_7joints, which is defined so far only by the project mc4plus.handv3.uvprojx.
For this reason the FW of the standard ems, mc4plus and mc2plus boards does not have much impact.
Description of the changes
The mc4plus directly moves the four joints of the hand in open close mode (thumb, index, medium, pinky) by controlling 4 DC motors. That is standard behaviour for the mc4plus.
However, the mc4plus also manages other three joints (thumb metacarpus, thumb rotation, index adduction) which are actuated by piezo electric motors driven by the pmc board.
As such, the MController inside the mc4plus board has been extended to contain data structures for 7 joints/motors rather than for 4 as it happens so far.
The extension of data structures to hold more entities (and hence use more RAM) and the addition of some extra functions is enabled by macro EOTHESERVICES_customize_handV3_7joints.
The aim is that with macro EOTHESERVICES_customize_handV3_7joints being not defined the ems and mc4plus don't compile some parts of code, don't use additional RAM and don't  change much their behaviour.
Associated PRs
This PR is a part of a set of related PRs:

PR on icub-firmware-shared: it adds required data structures;
PR on icub-firmware: it adds the FW of the mc4plus in a dedicated project called mc4plus.handv3.uvprojx;
PR on icub-firmware-build: it adds the FW of the recompiled versions of the ems, mc4plus, mc2plus;
PR on icub-main: it adds capability of parsing xml file for the mode eomn_serv_MC_mc4pluspmc;
PR on robots-configuration: it adds the xml files for the experimental setup wristmk2_handmk3.

Tests
Two kind of tests were done. Both of them were successful.

 Compatibility tests. They were done on the iCubGenova04 robot so that we can be sure that the FW produced for ems and mc4plus still works fine. The test showed that the robot, in its iRonCub version is able to move the head and the upper arms using the new versions of mc4plus and ems.
 Tests on the 7 joints of the hand mk3. They were done on the dedicated setup. The tests showed the correct behaviour of yarprobotinterface  and of the yarpmotorgui for the case of emulated piezo motors and emulated magnetic encoders.

Final comment
This PR adds support for the movement of the new hand and does not add any new features to the standard robots. We have now yarprobotinterface running properly for the new hand with 7 fingers. But we also made sure that the robots keep on working as before.","Aim of the PR
This PR is part of a set of PRs which adds support to manage the movement of the 7 joints of the mk3 hand.
The new MC mode is offered by the pair mc4plus and pmc and is hence nicknamed eomn_serv_MC_mc4pluspmc.
In order to do that, some features in icub-firmware and icub-firmware-shared are required in order to:

provide proper configuration of the new mode eomn_serv_MC_mc4pluspmc,
extend the data structures managed by the mc4plus board for the MC from 4 to 7.

The first feature adds changes to the data structures transmitted over ETH and hence has required an increase of the MN protocol version.
To limit the effect of the latter feature (which needs more RAM) the changes have been been conditioned to the macro EOTHESERVICES_customize_handV3_7joints, which is defined so far only by the project mc4plus.handv3.uvprojx.
For this reason the FW of the standard ems, mc4plus and mc2plus boards does not have much impact.
Description of the changes
The mc4plus directly moves the four joints of the hand in open close mode (thumb, index, medium, pinky) by controlling 4 DC motors. That is standard behaviour for the mc4plus.
However, the mc4plus also manages other three joints (thumb metacarpus, thumb rotation, index adduction) which are actuated by piezo electric motors driven by the pmc board.
As such, the MController inside the mc4plus board has been extended to contain data structures for 7 joints/motors rather than for 4 as it happens so far.
The extension of data structures to hold more entities (and hence use more RAM) and the addition of some extra functions is enabled by macro EOTHESERVICES_customize_handV3_7joints.
The aim is that with macro EOTHESERVICES_customize_handV3_7joints being not defined the ems and mc4plus don't compile some parts of code, don't use additional RAM and don't  change much their behaviour.
Associated PRs
This PR is a part of a set of related PRs:

PR on icub-firmware-shared: it adds required data structures;
PR on icub-firmware: it adds the FW of the mc4plus in a dedicated project called mc4plus.handv3.uvprojx;
PR on icub-firmware-build: it adds the FW of the recompiled versions of the ems, mc4plus, mc2plus;
PR on icub-main: it adds capability of parsing xml file for the mode eomn_serv_MC_mc4pluspmc;
PR on robots-configuration: it adds the xml files for the experimental setup wristmk2_handmk3.

Tests
Two kind of tests were done. Both of them were successful.

 Compatibility tests. They were done on the iCubGenova04 robot so that we can be sure that the FW produced for ems and mc4plus still works fine. The test showed that the robot, in its iRonCub version is able to move the head and the upper arms using the new versions of mc4plus and ems.
 Tests on the 7 joints of the hand mk3. They were done on the dedicated setup. The tests showed the correct behaviour of yarprobotinterface  and of the yarpmotorgui for the case of emulated piezo motors and emulated magnetic encoders.

Final comment
This PR adds support for the movement of the new hand and does not add any new features to the standard robots. We have now yarprobotinterface running properly for the new hand with 7 fingers. But we also made sure that the robots keep on working as before.",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,180,2021-04-13T08:26:09Z,2021-04-27T10:19:37Z,2021-04-27T11:35:21Z,MERGED,True,1134,129,11,https://github.com/triccyx,Add MBD-based FT FW ,9,[],https://github.com/robotology/icub-firmware/pull/180,https://github.com/triccyx,1,https://github.com/robotology/icub-firmware/pull/180,"Used MBD generated code from Simulink as new FT sensor code.
Check Simulink model in robotology/icub-firmware-models#2.","Used MBD generated code from Simulink as new FT sensor code.
Check Simulink model in robotology/icub-firmware-models#2.",True,"{'THUMBS_UP': ['https://github.com/marcoaccame'], 'ROCKET': ['https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,180,2021-04-13T08:26:09Z,2021-04-27T10:19:37Z,2021-04-27T11:35:21Z,MERGED,True,1134,129,11,https://github.com/triccyx,Add MBD-based FT FW ,9,[],https://github.com/robotology/icub-firmware/pull/180,https://github.com/triccyx,2,https://github.com/robotology/icub-firmware/pull/180#issuecomment-819348222,"Used MBD generated code from Simulink as new FT sensor code.
Check Simulink model in robotology/icub-firmware-models#2.","... sake of simplicity

Agree",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/simeonedussoni']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,180,2021-04-13T08:26:09Z,2021-04-27T10:19:37Z,2021-04-27T11:35:21Z,MERGED,True,1134,129,11,https://github.com/triccyx,Add MBD-based FT FW ,9,[],https://github.com/robotology/icub-firmware/pull/180,https://github.com/marcoaccame,3,https://github.com/robotology/icub-firmware/pull/180#issuecomment-824004164,"Used MBD generated code from Simulink as new FT sensor code.
Check Simulink model in robotology/icub-firmware-models#2.","Hence, @marcoaccame you can now review the code.

Hi @pattacini and @triccyx, I'm having a look at it.",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/triccyx']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,180,2021-04-13T08:26:09Z,2021-04-27T10:19:37Z,2021-04-27T11:35:21Z,MERGED,True,1134,129,11,https://github.com/triccyx,Add MBD-based FT FW ,9,[],https://github.com/robotology/icub-firmware/pull/180,https://github.com/simeonedussoni,4,https://github.com/robotology/icub-firmware/pull/180#issuecomment-827492218,"Used MBD generated code from Simulink as new FT sensor code.
Check Simulink model in robotology/icub-firmware-models#2.","fixed few minor issues:

version number is now 2.0.13 (note: it is already higher than the IMU remap)
tabs are replaced with spaces
included file is without explicit path, which is in the configuration tab",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,181,2021-04-21T16:22:57Z,2021-04-22T07:27:29Z,2021-04-22T07:27:35Z,MERGED,True,108,52,8,https://github.com/marcoaccame,PMC board: added support for flash pages of 4k,1,[],https://github.com/robotology/icub-firmware/pull/181,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/181,"This PR adds support for FLASH pages of size 4K to the bootloader and the application of the PMC board.
The modern CAN board, such as the mtb4 or the strain2 use FLASH to emulate EEPROM so that they can store CAN address, application version, CAN protocol version and private data.
They all use a FLASH which is organized in pages of 2K bytes each. There is support to specify a variable inside the embot::hw::flash namespace which tells the size of the page, but the functions which manage the FLASH for simplicity have used so far just ... 2048.
The first produced batch  of pmc boards were programmed with FLASH option bytes which had two banks and page size of 2K. That let them work in the same way as their older sisters.
However, I recently spotted a bug which shows only on the new batch of produced pmc boards. The writing to emulated EEPROM did not work.
The reason is due to a different configuration of their FLASH: it had now a single bank and pages of size 4K. This new mode is better (more efficient and more compatible w/ our code) but we need to use the size of the page as a variable.
As a result of that, I have modified some parts of code so that every board can use the proper page size.
For the pmc board only I also added some check code inside bool embot::hw::bsp::specialize() which executes at startup and performs special operations on the HW.  In here we now detect possible incoherencies between the page size imposed at production and the page size imposed inside our code.
I also moved some FLASH related functions inside namespace embot::hw::flash so that we avoid duplications.
I did tests on pmc boards of both batches (with pages size of 2K and of 4K) and they all work fine now. The other boards cannot be affected because still keep on using the value 2K as before.","This PR adds support for FLASH pages of size 4K to the bootloader and the application of the PMC board.
The modern CAN board, such as the mtb4 or the strain2 use FLASH to emulate EEPROM so that they can store CAN address, application version, CAN protocol version and private data.
They all use a FLASH which is organized in pages of 2K bytes each. There is support to specify a variable inside the embot::hw::flash namespace which tells the size of the page, but the functions which manage the FLASH for simplicity have used so far just ... 2048.
The first produced batch  of pmc boards were programmed with FLASH option bytes which had two banks and page size of 2K. That let them work in the same way as their older sisters.
However, I recently spotted a bug which shows only on the new batch of produced pmc boards. The writing to emulated EEPROM did not work.
The reason is due to a different configuration of their FLASH: it had now a single bank and pages of size 4K. This new mode is better (more efficient and more compatible w/ our code) but we need to use the size of the page as a variable.
As a result of that, I have modified some parts of code so that every board can use the proper page size.
For the pmc board only I also added some check code inside bool embot::hw::bsp::specialize() which executes at startup and performs special operations on the HW.  In here we now detect possible incoherencies between the page size imposed at production and the page size imposed inside our code.
I also moved some FLASH related functions inside namespace embot::hw::flash so that we avoid duplications.
I did tests on pmc boards of both batches (with pages size of 2K and of 4K) and they all work fine now. The other boards cannot be affected because still keep on using the value 2K as before.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,181,2021-04-21T16:22:57Z,2021-04-22T07:27:29Z,2021-04-22T07:27:35Z,MERGED,True,108,52,8,https://github.com/marcoaccame,PMC board: added support for flash pages of 4k,1,[],https://github.com/robotology/icub-firmware/pull/181,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/181#issuecomment-824609021,"This PR adds support for FLASH pages of size 4K to the bootloader and the application of the PMC board.
The modern CAN board, such as the mtb4 or the strain2 use FLASH to emulate EEPROM so that they can store CAN address, application version, CAN protocol version and private data.
They all use a FLASH which is organized in pages of 2K bytes each. There is support to specify a variable inside the embot::hw::flash namespace which tells the size of the page, but the functions which manage the FLASH for simplicity have used so far just ... 2048.
The first produced batch  of pmc boards were programmed with FLASH option bytes which had two banks and page size of 2K. That let them work in the same way as their older sisters.
However, I recently spotted a bug which shows only on the new batch of produced pmc boards. The writing to emulated EEPROM did not work.
The reason is due to a different configuration of their FLASH: it had now a single bank and pages of size 4K. This new mode is better (more efficient and more compatible w/ our code) but we need to use the size of the page as a variable.
As a result of that, I have modified some parts of code so that every board can use the proper page size.
For the pmc board only I also added some check code inside bool embot::hw::bsp::specialize() which executes at startup and performs special operations on the HW.  In here we now detect possible incoherencies between the page size imposed at production and the page size imposed inside our code.
I also moved some FLASH related functions inside namespace embot::hw::flash so that we avoid duplications.
I did tests on pmc boards of both batches (with pages size of 2K and of 4K) and they all work fine now. The other boards cannot be affected because still keep on using the value 2K as before.",Did further back-compatibility tests on a mtb4 board.  The EEPROM works fine as expected.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/simeonedussoni,1,https://github.com/robotology/icub-firmware/pull/182,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/traversaro,2,https://github.com/robotology/icub-firmware/pull/182#issuecomment-826921131,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","Not critical, but it would be also great to avoid mixing space and tabs, as these results in rendering issues (#if and #else should be aligned):",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/marcoaccame']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/pattacini,3,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827358733,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","Good point @traversaro 

Can you please clean up the PR in order to remove changes to the project files?

Of course, I meant referring only to those files that do not need to be changed as I guess that the define has to be saved somewhere in the project.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/marcoaccame,4,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827364864,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","Not critical, but it would be also great to avoid mixing space and tabs, as these results in rendering issues (#if and #else should be aligned):

yes, I opened the PR this morning because yesterday I spotted that and I wanted address this point.
To avoid presence of tabs it is wise to configure the text editor to substitute the tab w/ 4 spaces.
All (most of) the code in icub-firmware and icub-firmware-shared is edited w/out tabs because they give a different alignment which depends on the configuration of the editor.
I have spotted presence of un-aligned code due to presence of tabs also in file embot_app_application_theSTRAIN.cpp of this other PR.

Can you please clean up the PR in order to remove changes to the project files?

If the project does not change an option such as optimization, include path or similar, we don't need / want to commit its changes.",True,{'THUMBS_UP': ['https://github.com/traversaro']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/simeonedussoni,5,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827438957,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.",changes requested are implemented.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/simeonedussoni,6,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827456169,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","it's defined in the strain2-application-v6 project file, in a tab dedicated to preprocessor macros.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/simeonedussoni,7,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827456642,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","The macro STM32HAL_BOARD_STRAIN2 must be (and is) defined in all the projects running on the strain2 boards. It is designed to offer specialized behaviour to one board and not others. There are similar macros for other boards such as STM32HAL_BOARD_RFE etc.

as is stated from @marcoaccame here",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/pattacini,8,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827458785,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","This file doesn't seem to be contained in this PR though.
So, how could one download the icub-firmware repo anew and build the project for the FT FW from scratch?
Am I missing a step?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/simeonedussoni,9,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827468269,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","This file doesn't seem to be contained in this PR though.
So, how could one download the icub-firmware repo anew and build the project for the FT FW from scratch?
Am I missing a step?

BTW this is the PR for the IMU remap, after f2f briefing with @marcoaccame we decided to keep the two PR separated.
In the default project file there is defined among others the preprocessor macro quoted by marco.
Thus one just needs to download the repo icub-firmware, its sibling icub-firmware-shared and build the project to obtain a local copy of the executable file.
As stated above by marco, the project file (which is unchanged from the original one) strain2-application-v6.uvproj is not been included in the PR (actually it is just updated by the Keil toolchain when opened with some local environment options which do not impact the binary file generation)",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/pattacini,10,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827470412,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","As stated above by marco, the project file (which is unchanged from the original one) strain2-application-v6.uvproj is not been included in the PR

So, you're saying that the macro was already defined in the project file? If so, we're ok 
It wasn't clear from the posts above.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,182,2021-04-26T14:25:38Z,2021-04-27T10:06:01Z,2021-04-27T10:06:28Z,MERGED,True,55,14,2,https://github.com/simeonedussoni,Strain2: remap IMU to stream wrt FT main frame,2,[],https://github.com/robotology/icub-firmware/pull/182,https://github.com/pattacini,11,https://github.com/robotology/icub-firmware/pull/182#issuecomment-827485304,"Modified strain project to have the following axis exchange in the IMU data

$ x \to y$
$ y \to -x$
$ z \to z $

In this way, the FT and the IMU have the same reference frame.
The code is modified with a conditional preprocessing to insure the compatibility b/w the strain and the other boards equipped with the BNO055, which don't need to have the axis remapped.","Merged 
@simeonedussoni could you yield the binaries now?",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,183,2021-05-06T14:17:46Z,2021-05-07T10:11:33Z,2021-05-07T10:11:41Z,MERGED,True,2432,4685,16,https://github.com/marcoaccame,AMCBLDC board: some improvements,7,[],https://github.com/robotology/icub-firmware/pull/183,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/183,"This PR improves the code of the amcbldc board in these aspects:

it uses FLASH pages of size of 4K as already done for the PMC;
it adds a periodic CTRL thread to the application where we can add code for the motor control algorithm;
it adds to the CTRL thread code for measuring execution time of generic code (but soon we want to test motor control MBD-generated code) using three different methods:

simple print on the TRACE port,
visual tracing using Event Viewer,
GPIO writing: a GPIO is set at low and high value so that the generated waveform can be measured with an external oscilloscope.



The changes were successfully tested on the amcbldc board.
Here are some videos showing the measurement of time w/ simple print  and visual tracing. The mode GPIO writing was tested to produce blinks on the embot::hw::LED::three and for that we don't show a video.


  
    
    

    amcbldc-measure-by-print.mp4
    
  

  

  


Video - Measurement of execution time for the case of simple print. Three times are printed: two absolute times of start and stop of the test function plus its duration. These values are printed over the ITM port at each execution of the measure and shown on the relevant window..


  
    
    

    amcbldc-measure-by-eventviewer.mp4
    
  

  

  


Video - Measurement of execution time for the case of visual tracing. The start and stop of the test function are sent over the ITM port and displayed on a graphical tool which also reports the activity of the other threads and of some IRQ handlers.","This PR improves the code of the amcbldc board in these aspects:

it uses FLASH pages of size of 4K as already done for the PMC;
it adds a periodic CTRL thread to the application where we can add code for the motor control algorithm;
it adds to the CTRL thread code for measuring execution time of generic code (but soon we want to test motor control MBD-generated code) using three different methods:

simple print on the TRACE port,
visual tracing using Event Viewer,
GPIO writing: a GPIO is set at low and high value so that the generated waveform can be measured with an external oscilloscope.



The changes were successfully tested on the amcbldc board.
Here are some videos showing the measurement of time w/ simple print  and visual tracing. The mode GPIO writing was tested to produce blinks on the embot::hw::LED::three and for that we don't show a video.


  
    
    

    amcbldc-measure-by-print.mp4
    
  

  

  


Video - Measurement of execution time for the case of simple print. Three times are printed: two absolute times of start and stop of the test function plus its duration. These values are printed over the ITM port at each execution of the measure and shown on the relevant window..


  
    
    

    amcbldc-measure-by-eventviewer.mp4
    
  

  

  


Video - Measurement of execution time for the case of visual tracing. The start and stop of the test function are sent over the ITM port and displayed on a graphical tool which also reports the activity of the other threads and of some IRQ handlers.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,184,2021-05-19T07:14:49Z,2021-05-19T07:27:52Z,2022-01-11T09:43:59Z,MERGED,True,16133,42,48,https://github.com/marcoaccame,MBD FOC code optimized with CMSIS-DSP,3,[],https://github.com/robotology/icub-firmware/pull/184,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/184,"The PR adds a test for MBD (Model Based Designed) code implementing the FOC algorithm (Field Oriented Control).
The FOC code was generated from a Simulink model using some optimization:

tuning for Cortex M4 with floating point in single precision,
use of the CMSIS-DSP library for heavy optimized mathematical operations.

The code was tested on the amcbldc board which will run the FOC algorithm inside an IRQ Handler at 80/3 kHz  26.6 kHz.
But where does the frequency of 26.6 kHz come from? It is the frequency of acquisition of the three currents. The PWM on the amcbldc can run at 80 kHz, the three currents are measured in daisy-chain using an ADC converter synchronized with the PWM waveform and are available at the execution of the third IRQ Handler on DMA completion. Hence, at a rate 80/3 kHz  26.6 kHz.
But how does the code performs on the amcbldc running at 160 MHz?
The tick of the FOC algorithm measures inside a range of [2.5, 4.0] s depending on optimization.








Figure. Measure of execution time for the fully optimized MATLAB-generated code: use of single precision, CMSIS-DSP, and compiler armclang. Left w/  no optimization (-O0) and right w/ full speed optimization (-Ospeed).
These values surely allow use of the FOC algorithm inside the IRQ Handler.","The PR adds a test for MBD (Model Based Designed) code implementing the FOC algorithm (Field Oriented Control).
The FOC code was generated from a Simulink model using some optimization:

tuning for Cortex M4 with floating point in single precision,
use of the CMSIS-DSP library for heavy optimized mathematical operations.

The code was tested on the amcbldc board which will run the FOC algorithm inside an IRQ Handler at 80/3 kHz  26.6 kHz.
But where does the frequency of 26.6 kHz come from? It is the frequency of acquisition of the three currents. The PWM on the amcbldc can run at 80 kHz, the three currents are measured in daisy-chain using an ADC converter synchronized with the PWM waveform and are available at the execution of the third IRQ Handler on DMA completion. Hence, at a rate 80/3 kHz  26.6 kHz.
But how does the code performs on the amcbldc running at 160 MHz?
The tick of the FOC algorithm measures inside a range of [2.5, 4.0] s depending on optimization.








Figure. Measure of execution time for the fully optimized MATLAB-generated code: use of single precision, CMSIS-DSP, and compiler armclang. Left w/  no optimization (-O0) and right w/ full speed optimization (-Ospeed).
These values surely allow use of the FOC algorithm inside the IRQ Handler.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,184,2021-05-19T07:14:49Z,2021-05-19T07:27:52Z,2022-01-11T09:43:59Z,MERGED,True,16133,42,48,https://github.com/marcoaccame,MBD FOC code optimized with CMSIS-DSP,3,[],https://github.com/robotology/icub-firmware/pull/184,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/184#issuecomment-843814708,"The PR adds a test for MBD (Model Based Designed) code implementing the FOC algorithm (Field Oriented Control).
The FOC code was generated from a Simulink model using some optimization:

tuning for Cortex M4 with floating point in single precision,
use of the CMSIS-DSP library for heavy optimized mathematical operations.

The code was tested on the amcbldc board which will run the FOC algorithm inside an IRQ Handler at 80/3 kHz  26.6 kHz.
But where does the frequency of 26.6 kHz come from? It is the frequency of acquisition of the three currents. The PWM on the amcbldc can run at 80 kHz, the three currents are measured in daisy-chain using an ADC converter synchronized with the PWM waveform and are available at the execution of the third IRQ Handler on DMA completion. Hence, at a rate 80/3 kHz  26.6 kHz.
But how does the code performs on the amcbldc running at 160 MHz?
The tick of the FOC algorithm measures inside a range of [2.5, 4.0] s depending on optimization.








Figure. Measure of execution time for the fully optimized MATLAB-generated code: use of single precision, CMSIS-DSP, and compiler armclang. Left w/  no optimization (-O0) and right w/ full speed optimization (-Ospeed).
These values surely allow use of the FOC algorithm inside the IRQ Handler.","The changes in this PR affects only code used for the amcbldc board and do not interfere w/ other code used for the boards on on iCub, so it can be safely merged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,185,2021-06-04T13:12:14Z,2021-06-14T11:58:50Z,2021-06-14T11:58:50Z,MERGED,True,5087,13,14,https://github.com/ale-git,Wrist control integrated to EMS firmware,1,[],https://github.com/robotology/icub-firmware/pull/185,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/185,"This PR adds wrist control to the latest devel version of the EMS firmware, with a dedicated project file that defines the WRIST_MK2 compilation macro.","This PR adds wrist control to the latest devel version of the EMS firmware, with a dedicated project file that defines the WRIST_MK2 compilation macro.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,186,2021-06-07T13:00:57Z,2021-06-14T13:02:17Z,2021-06-15T17:27:14Z,MERGED,True,138,2321,11,https://github.com/ale-git,2foc diagnostics and encoder fault detection heuristics,3,[],https://github.com/robotology/icub-firmware/pull/186,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/186,"I have added 2FOC diagnostics and encoder fault detection heuristics as described below:
I have added feedback CAN transmission that can be enabled by the ""verbose"" configuration bit in hardware/mechanicals configuration files:

The transmitted data are:
        // diagnostics for iCub3
        payload.b[0] = Iafbk>>8; // channel A current in 256 mA units
        payload.b[1] = Icfbk>>8; // channel C current in 256 mA units
        payload.b[2] = Vqfbk/10; // PWM % (differs from PWM reference if limiting current)   
        payload.b[3] = (int)(VqRef>>IKs)/10; // PWM reference %
                
        payload.w[2] = maxCountfbk; // max encoder count when Index detected
        
        switch (iQprot)
        {
            // limiting negative current
            case -1: payload.w[3] = 0x8000 | ElDegfbk; 
                         break;   
            // limiting positive current
            case  1: payload.w[3] = 0x4000 | ElDegfbk; 
                         break;  
            // normal operation ==> PWM == PWMref
            default: payload.w[3] = ElDegfbk; // rotor electric position degrees 
                         break;         
        }

The maxCountfbk value provides detailed information about the amount of encoder missing ticks on a complete revolution.","I have added 2FOC diagnostics and encoder fault detection heuristics as described below:
I have added feedback CAN transmission that can be enabled by the ""verbose"" configuration bit in hardware/mechanicals configuration files:

The transmitted data are:
        // diagnostics for iCub3
        payload.b[0] = Iafbk>>8; // channel A current in 256 mA units
        payload.b[1] = Icfbk>>8; // channel C current in 256 mA units
        payload.b[2] = Vqfbk/10; // PWM % (differs from PWM reference if limiting current)   
        payload.b[3] = (int)(VqRef>>IKs)/10; // PWM reference %
                
        payload.w[2] = maxCountfbk; // max encoder count when Index detected
        
        switch (iQprot)
        {
            // limiting negative current
            case -1: payload.w[3] = 0x8000 | ElDegfbk; 
                         break;   
            // limiting positive current
            case  1: payload.w[3] = 0x4000 | ElDegfbk; 
                         break;  
            // normal operation ==> PWM == PWMref
            default: payload.w[3] = ElDegfbk; // rotor electric position degrees 
                         break;         
        }

The maxCountfbk value provides detailed information about the amount of encoder missing ticks on a complete revolution.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,187,2021-06-08T14:31:06Z,2021-06-08T18:51:50Z,2022-01-11T09:43:53Z,MERGED,True,546,135,15,https://github.com/marcoaccame,AMO diagnostics,10,[],https://github.com/robotology/icub-firmware/pull/187,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/187,"Description
This PR adds runtime configuration of additional diagnostics useful for debugging services on the robot.
Runtime configuration means that yarprobotinterface collects some parameters from xml files and sends them to the ETH boards so that this one can use them to activate / tune some actions.
So far, only the AMO diagnostics in MC service is supported.
In the following is how the AMO diagnostics can be configured and what it does.
How to activate / deactivate the AMO diagnostics
The AMO diagnostics is disabled by default.
If one wants to activate that, he/she must add the group named DIAGNOSTICS in the xml file which describes the MC service on a ETH board, as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_MC_AMO         </param>
           <param name=""par16"">    100                                 </param>
       </group> 
       
        ...
Code list. The DIAGNOSTICS group has two parameters: mode equal to eomn_serv_diagn_mode_MC_AMO  activates the AMO diagnostics with a maximum reporting rate in ms expressed by par16. In this case 100 ms. The minimum value is 2, meaning that the board can potentially emit diagnostics every 2 ms.
The service can be disable also by using a special mode called eomn_serv_diagn_mode_NONE as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_NONE           </param>
           <param name=""par16"">    100                                 </param>
       </group> 
       
        ...
Code list. The diagnostics is disabled if the group DIAGNOSTICS is not present or if it has  mode equal to eomn_serv_diagn_mode_NONE .

What the AMO diagnostics produces
When the AMO diagnostics is enabled with a maximum rate, let's say equal 100 ms, the board evaluates every 2 ms the content of the two status registers of the attached AMO encoders and it produces a stream of diagnostic messages which go to the yarplogger.  See the following listing.
4375,461389 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0,
time 159s 59m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff610000030c) 
-> DEBUG: tag05 + . 
 
4375,461530 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 59m 831u: (code 0x04000006, par16 0x0027 par64 0x000003930000038b) 
-> DEBUG: tag06 + . 
 
4375,471472 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 549u: (code 0x04000005, par16 0x0800 par64 0x000c5d17fffffcd6) 
-> DEBUG: tag05 + . 
 
4375,481599 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 642u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f) 
-> DEBUG: tag06 + . 
 
4375,562310 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff6100000324) 
-> DEBUG: tag05 + . 

4375,562449 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 833u: (code 0x04000006, par16 0x0023 par64 0x000003910000038b) 
-> DEBUG: tag06 + . 

4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 


Log excerpt. There are two boards, the left_leg-eb6-j0_1 and the left_leg-eb7-j2_3 which signals errors at their maximum rate of 100 ms. The pair of diagnostic messages emitted by the board have code 0x04000005 and 0x040000056 and are recognized by  -> DEBUG: tag05 + . and -> DEBUG: tag06 + .
The information inside the log messages
If the board has an AMO encoder and the reading of its two status registers shows any error flags, then it emits a pair of diagnostics messages which contains the values of:

the value of the status registers of the AMO as read by hal_spiencoder_get_value2(),
the joint number which uses the AMO,
the number of times the status registers were in error since the previous diagnostic messages,
some additional information such:

the raw value of the AMO encoder as read by hal_spiencoder_get_value2(),
the position of the joint as processed by the MController (eOmc_joint_status_t::core.measures.meas_position),
the PWM applied by the MController (eOmc_motor_status_t::basic.mot_pwm),
the motor current measured by the actuator eOmc_motor_status_t::basic.mot_current)



The pair of diagnostics messages are emitted with a maximum rate (configurable by xml file) to avoid to flood the log with continuous messages.
The above values are enclosed inside the fields of the diagnostic messages as later described. First I show an example of such messages with a maximum rate of 100 ms.
4375,461389 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0,
time 159s 59m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff610000030c) 
-> DEBUG: tag05 + . 
 
4375,461530 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 59m 831u: (code 0x04000006, par16 0x0027 par64 0x000003930000038b) 
-> DEBUG: tag06 + . 
 
4375,471472 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 549u: (code 0x04000005, par16 0x0800 par64 0x000c5d17fffffcd6) 
-> DEBUG: tag05 + . 
 
4375,481599 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 642u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f) 
-> DEBUG: tag06 + . 
 
4375,562310 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff6100000324) 
-> DEBUG: tag05 + . 

4375,562449 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 833u: (code 0x04000006, par16 0x0023 par64 0x000003910000038b) 
-> DEBUG: tag06 + . 

4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 


Log excerpt. There are two boards, the left_leg-eb6-j0_1 and the left_leg-eb7-j2_3 which signals errors at their maximum rate of 100 ms. The pair of diagnostic messages emitted by the board have code 0x04000005 and 0x040000056 and are recognized by  -> DEBUG: tag05 + . and -> DEBUG: tag06 + .
How the information is stored inside the two messages
An example of message pairs is in the following
4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 



Value
place inside message
Value in above list




AMO status registers status0, status1
par16 of DEBUG: tag05, where status0 is the least significant byte and status1 the most significant byte
par16 = 0x0800, status0 = 0x00, status1 = 0x08


The joint number inside the board
adr of DEBUG: tag06 or DEBUG: tag06
adr = 0, thus the first joint that is left_leg_j2


The number of times the board found errors since previous messages
par16 of DEBUG: tag06.
par16 = 0x0032 = 50, hence 50 times, hence always. See Note 1.


AMO raw value
the most significant four bytes of par64 of DEBUG: tag05
par64 = 0x000c5d15fffffc2d, value  = 0x000c5d15 = 810261


Motor current
the least significant four bytes of par64 of DEBUG: tag05
par64 = 0x000c5d15fffffc2d, value  = 0xfffffc2d = -979


Motor PWM
the most significant four bytes of par64 of DEBUG: tag06
par64 = 0xfffffb9bffffff9f, value  =  0xfffffb9b = -1125


Motor current
the least significant four bytes of par64 of DEBUG: tag06
par64 = 0xfffffb9bffffff9f, value  =  0xffffff9f = -97


Time of ETH board
written explicitly in message
time 159s 175m 550u


Time of yarplogger
the first number of the row
4375,572393 which is 4375 s 572393 us



Table. Mapping of the values inside the two diagnostics messages
Note 1. The ETH boards signals errors at most every 2 ms because it reads register status0 and status1 at each millisecond. So, if  between two pair of messages which are 100 ms far apart we see that the number of errors have been 50, it means that every time we checked we found an error, hence 100 % of the times.
Requirements of this PR
It needs also similar PRs:

in icub-firmware-shared which contains the data structures used for diagnostic s configuration,
in icub-main which contains code to extract configuration from the xml files.
in icub-firmware-build to give the new binaries for the ems, mc4plus, mc2plus.

So far we omit any PR in robots-configuration.
Executed tests
Tests were done extensively and with success on a dedicated setup and on iCubGenova09.","Description
This PR adds runtime configuration of additional diagnostics useful for debugging services on the robot.
Runtime configuration means that yarprobotinterface collects some parameters from xml files and sends them to the ETH boards so that this one can use them to activate / tune some actions.
So far, only the AMO diagnostics in MC service is supported.
In the following is how the AMO diagnostics can be configured and what it does.
How to activate / deactivate the AMO diagnostics
The AMO diagnostics is disabled by default.
If one wants to activate that, he/she must add the group named DIAGNOSTICS in the xml file which describes the MC service on a ETH board, as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_MC_AMO         </param>
           <param name=""par16"">    100                                 </param>
       </group> 
       
        ...
Code list. The DIAGNOSTICS group has two parameters: mode equal to eomn_serv_diagn_mode_MC_AMO  activates the AMO diagnostics with a maximum reporting rate in ms expressed by par16. In this case 100 ms. The minimum value is 2, meaning that the board can potentially emit diagnostics every 2 ms.
The service can be disable also by using a special mode called eomn_serv_diagn_mode_NONE as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_NONE           </param>
           <param name=""par16"">    100                                 </param>
       </group> 
       
        ...
Code list. The diagnostics is disabled if the group DIAGNOSTICS is not present or if it has  mode equal to eomn_serv_diagn_mode_NONE .

What the AMO diagnostics produces
When the AMO diagnostics is enabled with a maximum rate, let's say equal 100 ms, the board evaluates every 2 ms the content of the two status registers of the attached AMO encoders and it produces a stream of diagnostic messages which go to the yarplogger.  See the following listing.
4375,461389 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0,
time 159s 59m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff610000030c) 
-> DEBUG: tag05 + . 
 
4375,461530 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 59m 831u: (code 0x04000006, par16 0x0027 par64 0x000003930000038b) 
-> DEBUG: tag06 + . 
 
4375,471472 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 549u: (code 0x04000005, par16 0x0800 par64 0x000c5d17fffffcd6) 
-> DEBUG: tag05 + . 
 
4375,481599 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 642u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f) 
-> DEBUG: tag06 + . 
 
4375,562310 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff6100000324) 
-> DEBUG: tag05 + . 

4375,562449 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 833u: (code 0x04000006, par16 0x0023 par64 0x000003910000038b) 
-> DEBUG: tag06 + . 

4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 


Log excerpt. There are two boards, the left_leg-eb6-j0_1 and the left_leg-eb7-j2_3 which signals errors at their maximum rate of 100 ms. The pair of diagnostic messages emitted by the board have code 0x04000005 and 0x040000056 and are recognized by  -> DEBUG: tag05 + . and -> DEBUG: tag06 + .
The information inside the log messages
If the board has an AMO encoder and the reading of its two status registers shows any error flags, then it emits a pair of diagnostics messages which contains the values of:

the value of the status registers of the AMO as read by hal_spiencoder_get_value2(),
the joint number which uses the AMO,
the number of times the status registers were in error since the previous diagnostic messages,
some additional information such:

the raw value of the AMO encoder as read by hal_spiencoder_get_value2(),
the position of the joint as processed by the MController (eOmc_joint_status_t::core.measures.meas_position),
the PWM applied by the MController (eOmc_motor_status_t::basic.mot_pwm),
the motor current measured by the actuator eOmc_motor_status_t::basic.mot_current)



The pair of diagnostics messages are emitted with a maximum rate (configurable by xml file) to avoid to flood the log with continuous messages.
The above values are enclosed inside the fields of the diagnostic messages as later described. First I show an example of such messages with a maximum rate of 100 ms.
4375,461389 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0,
time 159s 59m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff610000030c) 
-> DEBUG: tag05 + . 
 
4375,461530 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 59m 831u: (code 0x04000006, par16 0x0027 par64 0x000003930000038b) 
-> DEBUG: tag06 + . 
 
4375,471472 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 549u: (code 0x04000005, par16 0x0800 par64 0x000c5d17fffffcd6) 
-> DEBUG: tag05 + . 
 
4375,481599 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 642u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f) 
-> DEBUG: tag06 + . 
 
4375,562310 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff6100000324) 
-> DEBUG: tag05 + . 

4375,562449 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 833u: (code 0x04000006, par16 0x0023 par64 0x000003910000038b) 
-> DEBUG: tag06 + . 

4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 


Log excerpt. There are two boards, the left_leg-eb6-j0_1 and the left_leg-eb7-j2_3 which signals errors at their maximum rate of 100 ms. The pair of diagnostic messages emitted by the board have code 0x04000005 and 0x040000056 and are recognized by  -> DEBUG: tag05 + . and -> DEBUG: tag06 + .
How the information is stored inside the two messages
An example of message pairs is in the following
4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 



Value
place inside message
Value in above list




AMO status registers status0, status1
par16 of DEBUG: tag05, where status0 is the least significant byte and status1 the most significant byte
par16 = 0x0800, status0 = 0x00, status1 = 0x08


The joint number inside the board
adr of DEBUG: tag06 or DEBUG: tag06
adr = 0, thus the first joint that is left_leg_j2


The number of times the board found errors since previous messages
par16 of DEBUG: tag06.
par16 = 0x0032 = 50, hence 50 times, hence always. See Note 1.


AMO raw value
the most significant four bytes of par64 of DEBUG: tag05
par64 = 0x000c5d15fffffc2d, value  = 0x000c5d15 = 810261


Motor current
the least significant four bytes of par64 of DEBUG: tag05
par64 = 0x000c5d15fffffc2d, value  = 0xfffffc2d = -979


Motor PWM
the most significant four bytes of par64 of DEBUG: tag06
par64 = 0xfffffb9bffffff9f, value  =  0xfffffb9b = -1125


Motor current
the least significant four bytes of par64 of DEBUG: tag06
par64 = 0xfffffb9bffffff9f, value  =  0xffffff9f = -97


Time of ETH board
written explicitly in message
time 159s 175m 550u


Time of yarplogger
the first number of the row
4375,572393 which is 4375 s 572393 us



Table. Mapping of the values inside the two diagnostics messages
Note 1. The ETH boards signals errors at most every 2 ms because it reads register status0 and status1 at each millisecond. So, if  between two pair of messages which are 100 ms far apart we see that the number of errors have been 50, it means that every time we checked we found an error, hence 100 % of the times.
Requirements of this PR
It needs also similar PRs:

in icub-firmware-shared which contains the data structures used for diagnostic s configuration,
in icub-main which contains code to extract configuration from the xml files.
in icub-firmware-build to give the new binaries for the ems, mc4plus, mc2plus.

So far we omit any PR in robots-configuration.
Executed tests
Tests were done extensively and with success on a dedicated setup and on iCubGenova09.",True,"{'ROCKET': ['https://github.com/pattacini', 'https://github.com/S-Dafarra']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,187,2021-06-08T14:31:06Z,2021-06-08T18:51:50Z,2022-01-11T09:43:53Z,MERGED,True,546,135,15,https://github.com/marcoaccame,AMO diagnostics,10,[],https://github.com/robotology/icub-firmware/pull/187,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/187#issuecomment-856916305,"Description
This PR adds runtime configuration of additional diagnostics useful for debugging services on the robot.
Runtime configuration means that yarprobotinterface collects some parameters from xml files and sends them to the ETH boards so that this one can use them to activate / tune some actions.
So far, only the AMO diagnostics in MC service is supported.
In the following is how the AMO diagnostics can be configured and what it does.
How to activate / deactivate the AMO diagnostics
The AMO diagnostics is disabled by default.
If one wants to activate that, he/she must add the group named DIAGNOSTICS in the xml file which describes the MC service on a ETH board, as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_MC_AMO         </param>
           <param name=""par16"">    100                                 </param>
       </group> 
       
        ...
Code list. The DIAGNOSTICS group has two parameters: mode equal to eomn_serv_diagn_mode_MC_AMO  activates the AMO diagnostics with a maximum reporting rate in ms expressed by par16. In this case 100 ms. The minimum value is 2, meaning that the board can potentially emit diagnostics every 2 ms.
The service can be disable also by using a special mode called eomn_serv_diagn_mode_NONE as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_NONE           </param>
           <param name=""par16"">    100                                 </param>
       </group> 
       
        ...
Code list. The diagnostics is disabled if the group DIAGNOSTICS is not present or if it has  mode equal to eomn_serv_diagn_mode_NONE .

What the AMO diagnostics produces
When the AMO diagnostics is enabled with a maximum rate, let's say equal 100 ms, the board evaluates every 2 ms the content of the two status registers of the attached AMO encoders and it produces a stream of diagnostic messages which go to the yarplogger.  See the following listing.
4375,461389 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0,
time 159s 59m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff610000030c) 
-> DEBUG: tag05 + . 
 
4375,461530 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 59m 831u: (code 0x04000006, par16 0x0027 par64 0x000003930000038b) 
-> DEBUG: tag06 + . 
 
4375,471472 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 549u: (code 0x04000005, par16 0x0800 par64 0x000c5d17fffffcd6) 
-> DEBUG: tag05 + . 
 
4375,481599 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 642u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f) 
-> DEBUG: tag06 + . 
 
4375,562310 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff6100000324) 
-> DEBUG: tag05 + . 

4375,562449 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 833u: (code 0x04000006, par16 0x0023 par64 0x000003910000038b) 
-> DEBUG: tag06 + . 

4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 


Log excerpt. There are two boards, the left_leg-eb6-j0_1 and the left_leg-eb7-j2_3 which signals errors at their maximum rate of 100 ms. The pair of diagnostic messages emitted by the board have code 0x04000005 and 0x040000056 and are recognized by  -> DEBUG: tag05 + . and -> DEBUG: tag06 + .
The information inside the log messages
If the board has an AMO encoder and the reading of its two status registers shows any error flags, then it emits a pair of diagnostics messages which contains the values of:

the value of the status registers of the AMO as read by hal_spiencoder_get_value2(),
the joint number which uses the AMO,
the number of times the status registers were in error since the previous diagnostic messages,
some additional information such:

the raw value of the AMO encoder as read by hal_spiencoder_get_value2(),
the position of the joint as processed by the MController (eOmc_joint_status_t::core.measures.meas_position),
the PWM applied by the MController (eOmc_motor_status_t::basic.mot_pwm),
the motor current measured by the actuator eOmc_motor_status_t::basic.mot_current)



The pair of diagnostics messages are emitted with a maximum rate (configurable by xml file) to avoid to flood the log with continuous messages.
The above values are enclosed inside the fields of the diagnostic messages as later described. First I show an example of such messages with a maximum rate of 100 ms.
4375,461389 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0,
time 159s 59m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff610000030c) 
-> DEBUG: tag05 + . 
 
4375,461530 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 59m 831u: (code 0x04000006, par16 0x0027 par64 0x000003930000038b) 
-> DEBUG: tag06 + . 
 
4375,471472 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 549u: (code 0x04000005, par16 0x0800 par64 0x000c5d17fffffcd6) 
-> DEBUG: tag05 + . 
 
4375,481599 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 75m 642u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f) 
-> DEBUG: tag06 + . 
 
4375,562310 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 740u: (code 0x04000005, par16 0x0800 par64 0x0009ff6100000324) 
-> DEBUG: tag05 + . 

4375,562449 <ERROR>  from BOARD 10.0.1.6 (left_leg-eb6-j0_1), src LOCAL, adr 0, 
time 159s 159m 833u: (code 0x04000006, par16 0x0023 par64 0x000003910000038b) 
-> DEBUG: tag06 + . 

4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 


Log excerpt. There are two boards, the left_leg-eb6-j0_1 and the left_leg-eb7-j2_3 which signals errors at their maximum rate of 100 ms. The pair of diagnostic messages emitted by the board have code 0x04000005 and 0x040000056 and are recognized by  -> DEBUG: tag05 + . and -> DEBUG: tag06 + .
How the information is stored inside the two messages
An example of message pairs is in the following
4375,572393 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0, 
time 159s 175m 550u: (code 0x04000005, par16 0x0800 par64 0x000c5d15fffffc2d) 
-> DEBUG: tag05 + . 

4375,572534 <ERROR>  from BOARD 10.0.1.7 (left_leg-eb7-j2_3), src LOCAL, adr 0,
time 159s 175m 643u: (code 0x04000006, par16 0x0032 par64 0xfffffb9bffffff9f)
-> DEBUG: tag06 + . 



Value
place inside message
Value in above list




AMO status registers status0, status1
par16 of DEBUG: tag05, where status0 is the least significant byte and status1 the most significant byte
par16 = 0x0800, status0 = 0x00, status1 = 0x08


The joint number inside the board
adr of DEBUG: tag06 or DEBUG: tag06
adr = 0, thus the first joint that is left_leg_j2


The number of times the board found errors since previous messages
par16 of DEBUG: tag06.
par16 = 0x0032 = 50, hence 50 times, hence always. See Note 1.


AMO raw value
the most significant four bytes of par64 of DEBUG: tag05
par64 = 0x000c5d15fffffc2d, value  = 0x000c5d15 = 810261


Motor current
the least significant four bytes of par64 of DEBUG: tag05
par64 = 0x000c5d15fffffc2d, value  = 0xfffffc2d = -979


Motor PWM
the most significant four bytes of par64 of DEBUG: tag06
par64 = 0xfffffb9bffffff9f, value  =  0xfffffb9b = -1125


Motor current
the least significant four bytes of par64 of DEBUG: tag06
par64 = 0xfffffb9bffffff9f, value  =  0xffffff9f = -97


Time of ETH board
written explicitly in message
time 159s 175m 550u


Time of yarplogger
the first number of the row
4375,572393 which is 4375 s 572393 us



Table. Mapping of the values inside the two diagnostics messages
Note 1. The ETH boards signals errors at most every 2 ms because it reads register status0 and status1 at each millisecond. So, if  between two pair of messages which are 100 ms far apart we see that the number of errors have been 50, it means that every time we checked we found an error, hence 100 % of the times.
Requirements of this PR
It needs also similar PRs:

in icub-firmware-shared which contains the data structures used for diagnostic s configuration,
in icub-main which contains code to extract configuration from the xml files.
in icub-firmware-build to give the new binaries for the ems, mc4plus, mc2plus.

So far we omit any PR in robots-configuration.
Executed tests
Tests were done extensively and with success on a dedicated setup and on iCubGenova09.",cc @S-Dafarra,True,{'THUMBS_UP': ['https://github.com/S-Dafarra']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,188,2021-06-10T14:57:07Z,2021-06-10T16:31:03Z,2021-06-10T17:14:37Z,MERGED,True,243,58,9,https://github.com/marcoaccame,AMO data to YARP ports,3,[],https://github.com/robotology/icub-firmware/pull/188,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/188,"Description
This PR belongs to a set of PRs which enable to stream AMO data towards YARP ports for debugging purposes.
It extends the content of a previous PR called AMO diagnostics by allowing an alternative diagnostics path which sends the content of AMO registers and values to YARP ports.
This mode can be configured in runtime by acting on the xml files of the MC service.
In the following is shown how the AMO dat to YARP ports can be configured and what it does.
How to activate / deactivate the AMO diagnostics
The AMO to YARP ports is disabled by default.
If one wants to activate that, he/she must add the group named DIAGNOSTICS in the xml file which describes the MC service on a ETH board, as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_MC_AMOyarp     </param>
           <param name=""par16"">    1000                                </param>
       </group> 
       
        ...
Code list. The DIAGNOSTICS group has two parameters: mode equal to eomn_serv_diagn_mode_MC_AMOyarp  activates the AMO streaming. The parameters par16 expressed the time in ms of delay of application of motor configuration to the 2foc board. In this case 1 second.
The service can be disable also by using a special mode called eomn_serv_diagn_mode_NONE as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_NONE           </param>
           <param name=""par16"">    1000                                </param>
       </group> 
       
        ...
Code list. The diagnostics is disabled if the group DIAGNOSTICS is not present or if it has  mode equal to eomn_serv_diagn_mode_NONE .

What the AMO streaming produces
When the AMO streaming is enabled, the board sends to YARP ports which contains the name of the board and of the relevant joint number as show in the following. The name of the ETH board is the same in ETH_BOARD.ETH_BOARD_SETTINGS.Name as specified in the relevant xml file.
$ yarp read ... /amo/left_leg-eb6-j0_1/j0
[yt, amo, reg, pos] 111111.000000 333333 2048 444444
[yt, amo, reg, pos] 111111.005000 333333 2048 444444
...
Log excerpt. The YARP port opened for the first joint (j0) of board left_leg-eb6-j0_1 signals what is described inside brackets:  YARP time, AMO raw value, content of registers of the AMO, eOmc_joint_status_t::core.measures.meas_position.
Use of the delay in activation of the motors
If the AMO streaming is enabled with a given delay of motors, let's say par16 = 1000 which corresponds to 1 second, the effect is the following:

The ETH boards starts to stream the values to icub-head which publish them on the relevant port (which must be already opened) and after 1 second it applies the configuration to the motors.
During this time of  1 second the MC device is temporarily stopped, so that the calibrator is not activated until the motor on the ETH board is initted.
The time of delay of motor activation can be up to 65 seconds.

In such a way, we can read values without the effect of the activation of the motor (which may emit EM noise).
Requirements of this PR
Requirements of this PR
To enable the features of this PR we also need similar PRs. They are:

in icub-firmware-shared which contains the data structures,
in  icub-firmware we have the code for the ETH boards
in icub-main which contains code to publish on the YARP port.
in icub-firmware-build to give the new binaries for the ems, mc4plus, mc2plus.

So far we omit any PR in robots-configuration.
Executed tests
Tests were extensively done on a dedicated setup but not yet on iCubGenova09.","Description
This PR belongs to a set of PRs which enable to stream AMO data towards YARP ports for debugging purposes.
It extends the content of a previous PR called AMO diagnostics by allowing an alternative diagnostics path which sends the content of AMO registers and values to YARP ports.
This mode can be configured in runtime by acting on the xml files of the MC service.
In the following is shown how the AMO dat to YARP ports can be configured and what it does.
How to activate / deactivate the AMO diagnostics
The AMO to YARP ports is disabled by default.
If one wants to activate that, he/she must add the group named DIAGNOSTICS in the xml file which describes the MC service on a ETH board, as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_MC_AMOyarp     </param>
           <param name=""par16"">    1000                                </param>
       </group> 
       
        ...
Code list. The DIAGNOSTICS group has two parameters: mode equal to eomn_serv_diagn_mode_MC_AMOyarp  activates the AMO streaming. The parameters par16 expressed the time in ms of delay of application of motor configuration to the 2foc board. In this case 1 second.
The service can be disable also by using a special mode called eomn_serv_diagn_mode_NONE as in the following.
<group name=""SERVICE"">

    <param name=""type""> eomn_serv_MC_foc </param> 
   
    <group name=""PROPERTIES"">
    
       <group name=""DIAGNOSTICS"">
           <param name=""mode"">     eomn_serv_diagn_mode_NONE           </param>
           <param name=""par16"">    1000                                </param>
       </group> 
       
        ...
Code list. The diagnostics is disabled if the group DIAGNOSTICS is not present or if it has  mode equal to eomn_serv_diagn_mode_NONE .

What the AMO streaming produces
When the AMO streaming is enabled, the board sends to YARP ports which contains the name of the board and of the relevant joint number as show in the following. The name of the ETH board is the same in ETH_BOARD.ETH_BOARD_SETTINGS.Name as specified in the relevant xml file.
$ yarp read ... /amo/left_leg-eb6-j0_1/j0
[yt, amo, reg, pos] 111111.000000 333333 2048 444444
[yt, amo, reg, pos] 111111.005000 333333 2048 444444
...
Log excerpt. The YARP port opened for the first joint (j0) of board left_leg-eb6-j0_1 signals what is described inside brackets:  YARP time, AMO raw value, content of registers of the AMO, eOmc_joint_status_t::core.measures.meas_position.
Use of the delay in activation of the motors
If the AMO streaming is enabled with a given delay of motors, let's say par16 = 1000 which corresponds to 1 second, the effect is the following:

The ETH boards starts to stream the values to icub-head which publish them on the relevant port (which must be already opened) and after 1 second it applies the configuration to the motors.
During this time of  1 second the MC device is temporarily stopped, so that the calibrator is not activated until the motor on the ETH board is initted.
The time of delay of motor activation can be up to 65 seconds.

In such a way, we can read values without the effect of the activation of the motor (which may emit EM noise).
Requirements of this PR
Requirements of this PR
To enable the features of this PR we also need similar PRs. They are:

in icub-firmware-shared which contains the data structures,
in  icub-firmware we have the code for the ETH boards
in icub-main which contains code to publish on the YARP port.
in icub-firmware-build to give the new binaries for the ems, mc4plus, mc2plus.

So far we omit any PR in robots-configuration.
Executed tests
Tests were extensively done on a dedicated setup but not yet on iCubGenova09.",True,"{'ROCKET': ['https://github.com/pattacini', 'https://github.com/S-Dafarra']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,189,2021-06-15T09:50:04Z,2021-06-15T10:05:25Z,2021-06-15T10:05:38Z,MERGED,True,4,4,3,https://github.com/marcoaccame,mc4plus : fixed compilation of hal2,1,[],https://github.com/robotology/icub-firmware/pull/189,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/189,"This PR fixes something left behind by a previous PR.
In that PR we did some changes in the source code of hal2 to manage SPI-based encoders, but we did not recompile the associated hal2.mc4plus.ethdbg.lib library.
In here we add the correctly recompiled library plus we advance version number to the mc4plus application for producing a new binary to be soon placed into icub-firmware-build.","This PR fixes something left behind by a previous PR.
In that PR we did some changes in the source code of hal2 to manage SPI-based encoders, but we did not recompile the associated hal2.mc4plus.ethdbg.lib library.
In here we add the correctly recompiled library plus we advance version number to the mc4plus application for producing a new binary to be soon placed into icub-firmware-build.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,191,2021-06-22T11:09:29Z,2021-06-23T08:28:28Z,2022-01-11T09:43:47Z,MERGED,True,1628,376,42,https://github.com/marcoaccame,Fatal error handler,3,[],https://github.com/robotology/icub-firmware/pull/191,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/191,"This PR introduces a more powerful fatal error handler which:

saves info about the fatal error on NZI RAM,
forces a restart of the MPU,
and then sends such info to yarprobotinterface

This PR addresses issue in here.
The relevant binaries are in this PR.
Description of the information sent to yarprobotinterface
In case of a fatal error, the board will restart and send messages such as:
[**INFO**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 953m 401u: 
(code 0x0000003b, par16 0x0000 par64 0x0000000000000000) -> SYS: the board is bootstrapping + . 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 7u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + RESTARTED after FATAL error 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 117u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + @ 20000 ms 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 235u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + handler OSAL, code 0xe5 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 348u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + type osal_stackovf 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 467u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + IRQHan SVCall Thread runDO 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 581u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + ipsr 11, tid 11
List. Board 10.0.1.1 has detected a fatal error (first message of type DEBUG: tag00 w/ string RESTARTED after FATAL error) at its execution time 20 sec (second message with string 20000 ms). The third and fourth message tell that the error was caused by the OSAL handler and is due to stack overflow (see string ype osal_stackovf). The handler was called by a thread the I_RQHandler SVCall_ which is the one which does thread switching and the error was caused by last scheduled thread called runDO (it is the one which ticks all teh services at 1 kHz.
For the case of  hw_HardFault handler, we also send the content of the CFSR register which can help detecting the cause of fault.
1068,141704 <INFO>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 781m 884u: 
(code 0x0000003b, par16 0x0000 par64 0x0000000000000000)
 -> SYS: the board is bootstrapping + . 

1068,141765 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 489u:
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + RESTARTED after FATAL error 

1068,141838 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 600u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e) -> 
DEBUG: tag00 + @ 1286766 ms 

 1068,141890 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 722u: 
 (code 0x04000000, par16 0x0000 par64 0x030364060013a26e) ->
 DEBUG: tag00 + handler hw_HardFault, code 0x64 

1068,151700 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 832u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + type see TBL 

1068,151839 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 952u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
-> DEBUG: tag00 + IRQHan HardFault Thread tmrma 

1068,151902 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 784m 68u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + ipsr 3, tid 3 
 
1068,151902 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 784m 68u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + CFSR 0x00000000 
List. Board 10.0.1.20 has detected a fatal error of type hw_HardFault. In such a case we also transmit teh content of the CFSR register.
Tests
The resulting binaries have been extensively tested on a test bench with an ems board and also on the iCubGenova09 robot, which actually produced the messages emitted by board 10.0.1.20.","This PR introduces a more powerful fatal error handler which:

saves info about the fatal error on NZI RAM,
forces a restart of the MPU,
and then sends such info to yarprobotinterface

This PR addresses issue in here.
The relevant binaries are in this PR.
Description of the information sent to yarprobotinterface
In case of a fatal error, the board will restart and send messages such as:
[**INFO**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 953m 401u: 
(code 0x0000003b, par16 0x0000 par64 0x0000000000000000) -> SYS: the board is bootstrapping + . 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 7u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + RESTARTED after FATAL error 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 117u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + @ 20000 ms 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 235u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + handler OSAL, code 0xe5 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 348u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + type osal_stackovf 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 467u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + IRQHan SVCall Thread runDO 

[**ERROR**]  from BOARD 10.0.1.1 (l-hv3-hand), src LOCAL, adr 0, time 1s 955m 581u: 
(code 0x04000000, par16 0x0000 par64 0x0b0be50300004e20) -> DEBUG: tag00 + ipsr 11, tid 11
List. Board 10.0.1.1 has detected a fatal error (first message of type DEBUG: tag00 w/ string RESTARTED after FATAL error) at its execution time 20 sec (second message with string 20000 ms). The third and fourth message tell that the error was caused by the OSAL handler and is due to stack overflow (see string ype osal_stackovf). The handler was called by a thread the I_RQHandler SVCall_ which is the one which does thread switching and the error was caused by last scheduled thread called runDO (it is the one which ticks all teh services at 1 kHz.
For the case of  hw_HardFault handler, we also send the content of the CFSR register which can help detecting the cause of fault.
1068,141704 <INFO>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 781m 884u: 
(code 0x0000003b, par16 0x0000 par64 0x0000000000000000)
 -> SYS: the board is bootstrapping + . 

1068,141765 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 489u:
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + RESTARTED after FATAL error 

1068,141838 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 600u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e) -> 
DEBUG: tag00 + @ 1286766 ms 

 1068,141890 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 722u: 
 (code 0x04000000, par16 0x0000 par64 0x030364060013a26e) ->
 DEBUG: tag00 + handler hw_HardFault, code 0x64 

1068,151700 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 832u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + type see TBL 

1068,151839 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 783m 952u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
-> DEBUG: tag00 + IRQHan HardFault Thread tmrma 

1068,151902 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 784m 68u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + ipsr 3, tid 3 
 
1068,151902 <ERROR>  from BOARD 10.0.1.20 (head-eb20-j0_1), src LOCAL, adr 0, time 3s 784m 68u: 
(code 0x04000000, par16 0x0000 par64 0x030364060013a26e)
 -> DEBUG: tag00 + CFSR 0x00000000 
List. Board 10.0.1.20 has detected a fatal error of type hw_HardFault. In such a case we also transmit teh content of the CFSR register.
Tests
The resulting binaries have been extensively tested on a test bench with an ems board and also on the iCubGenova09 robot, which actually produced the messages emitted by board 10.0.1.20.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,192,2021-06-23T09:29:39Z,2021-06-23T09:50:12Z,2021-06-23T09:50:12Z,MERGED,True,2539,69,7,https://github.com/marcoaccame,Versions for ems mc4plus of the hand wrist,1,[],https://github.com/robotology/icub-firmware/pull/192,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/192,"This PR adjusts the application versions of the ems and mc4plus used for the new hand wrist.
For the control of the wrist we use the project called ems4rd.wristmk2.uvprojx which defines a macro which sets the application version of the ems to have major number equal to 23 (normal ems has value of 3)
For the control of the hand we use project mc4plus.handv3.uvprojx which defines macros which sets the major number version to be 33 (case of only open-close of fingers) or 73 (open close of fingers plus the 3 piezo motors).
So, to summarize, here are the versions.



board
version
project
macro




ems
3.42
ems4rd.diagnostic2ready.uvprojx
N/A


ems wrist
23.42
ems4rd.wristmk2.uvprojx
WRIST_MK2


mc4plus
3.36
mc4plus.diagnostic2ready.uvprojx
N/A


mc4plus 4 joints
43.36
mc4plus.handv3.uvprojx
EOTHESERVICES_customize_handV3


mc4plus 7 joints
73.36
mc4plus.handv3.uvprojx
EOTHESERVICES_customize_handV3 EOTHESERVICES_customize_handV3_7joints","This PR adjusts the application versions of the ems and mc4plus used for the new hand wrist.
For the control of the wrist we use the project called ems4rd.wristmk2.uvprojx which defines a macro which sets the application version of the ems to have major number equal to 23 (normal ems has value of 3)
For the control of the hand we use project mc4plus.handv3.uvprojx which defines macros which sets the major number version to be 33 (case of only open-close of fingers) or 73 (open close of fingers plus the 3 piezo motors).
So, to summarize, here are the versions.



board
version
project
macro




ems
3.42
ems4rd.diagnostic2ready.uvprojx
N/A


ems wrist
23.42
ems4rd.wristmk2.uvprojx
WRIST_MK2


mc4plus
3.36
mc4plus.diagnostic2ready.uvprojx
N/A


mc4plus 4 joints
43.36
mc4plus.handv3.uvprojx
EOTHESERVICES_customize_handV3


mc4plus 7 joints
73.36
mc4plus.handv3.uvprojx
EOTHESERVICES_customize_handV3 EOTHESERVICES_customize_handV3_7joints",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,193,2021-07-01T11:13:27Z,2021-07-01T11:16:37Z,2021-07-01T11:17:15Z,MERGED,True,767,349,28,https://github.com/marcoaccame,The board amcbldc runs at 168 MHz,1,[],https://github.com/robotology/icub-firmware/pull/193,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/193,"This PR prepares the low level HW layer formed by the drivers supplied by STMicroelectronics to
be ready for implementing drivers for PWM and encoders for the amcbldc board.
I have realigned the .ioc file w/ the required HW configurations, regenerated the C code, updated the library stm32hal and finally the embot::hw::bsp:: namespace used by bootloader and application of the amcbldc.
Finally I have tested bootloader and application vs CAN communication towards the CANreal.
Here the main changes in HW configuration:

the MPU now runs at 168 MHz
the CAN bus is hence at 84 MHz (tested w/ CANreal)
the timers are configured to run PWM and get encoders values

We can safely merge.","This PR prepares the low level HW layer formed by the drivers supplied by STMicroelectronics to
be ready for implementing drivers for PWM and encoders for the amcbldc board.
I have realigned the .ioc file w/ the required HW configurations, regenerated the C code, updated the library stm32hal and finally the embot::hw::bsp:: namespace used by bootloader and application of the amcbldc.
Finally I have tested bootloader and application vs CAN communication towards the CANreal.
Here the main changes in HW configuration:

the MPU now runs at 168 MHz
the CAN bus is hence at 84 MHz (tested w/ CANreal)
the timers are configured to run PWM and get encoders values

We can safely merge.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,194,2021-07-09T09:24:38Z,2021-07-09T09:38:23Z,2021-07-09T09:49:16Z,MERGED,True,2803,50,22,https://github.com/marcoaccame,Low level motor control for board amcbldc,5,[],https://github.com/robotology/icub-firmware/pull/194,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/194,"This PR adds low level motor control for the board amcbldc.
The control is done through the APIs of embot::hw::motor and so far offers only:

application of a target PWM w/ a 6-steps control.
retrieval of hall counter and of incremental encoder value.

The lower level code is targeted for the board amcbld and so far manages only a specific motor.
It used the HAL drivers provided by STMicroelectronics on top of which we have used some further specialization code provided by @GiorgioZini which was properly adapted to run in our applications.
The code was tested inside a specific application which moves the motor through a fixed cycle: counterwise, stop, anticonterwise, stop.
Here is a video of the test.

  
    
    

    motor-spins.mov
    
  

  

  


Video.  The motor spins.
The code added / changed in the PR does not interfere w/ the code used by other boards and can be safely merged.","This PR adds low level motor control for the board amcbldc.
The control is done through the APIs of embot::hw::motor and so far offers only:

application of a target PWM w/ a 6-steps control.
retrieval of hall counter and of incremental encoder value.

The lower level code is targeted for the board amcbld and so far manages only a specific motor.
It used the HAL drivers provided by STMicroelectronics on top of which we have used some further specialization code provided by @GiorgioZini which was properly adapted to run in our applications.
The code was tested inside a specific application which moves the motor through a fixed cycle: counterwise, stop, anticonterwise, stop.
Here is a video of the test.

  
    
    

    motor-spins.mov
    
  

  

  


Video.  The motor spins.
The code added / changed in the PR does not interfere w/ the code used by other boards and can be safely merged.",True,"{'ROCKET': ['https://github.com/pattacini'], 'HEART': ['https://github.com/GiorgioZini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,195,2021-07-13T11:46:38Z,2021-07-13T11:52:22Z,2021-07-13T11:52:34Z,MERGED,True,388,24,12,https://github.com/marcoaccame,Board amcbldc: control of a motor by CAN messages,5,[],https://github.com/robotology/icub-firmware/pull/195,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/195,"This PR introduces support for CAN protocol of messages SET_CONTROL_MODE and GET_CONTROL_MODE.
In application01 of the amcbldc the previous messages and also EMSTO2FOC_DESIRED_CURRENT produce the movement of a motor using what we added in a previous PR: #194
In here is a video which demonstrates the movement.

  
    
    

    02-amcbldc-can-controlled.mov
    
  

  

  


Video. The amcbldc board is controlled over CAN w/ messages such as SET_CONTROL_MODE and EMSTO2FOC_DESIRED_CURRENT.
This PR does not interfere w/ code of other boards and can be safely merged.","This PR introduces support for CAN protocol of messages SET_CONTROL_MODE and GET_CONTROL_MODE.
In application01 of the amcbldc the previous messages and also EMSTO2FOC_DESIRED_CURRENT produce the movement of a motor using what we added in a previous PR: #194
In here is a video which demonstrates the movement.

  
    
    

    02-amcbldc-can-controlled.mov
    
  

  

  


Video. The amcbldc board is controlled over CAN w/ messages such as SET_CONTROL_MODE and EMSTO2FOC_DESIRED_CURRENT.
This PR does not interfere w/ code of other boards and can be safely merged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,196,2021-07-14T07:16:09Z,2021-07-14T07:17:54Z,2021-07-14T09:47:07Z,MERGED,True,7554,2,18,https://github.com/marcoaccame,Skeleton of amcbldc ready for MBD,2,[],https://github.com/robotology/icub-firmware/pull/196,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/196,"This PR adds application02 for the amcbldc board.
We have two threads: tCOMM and tCTRL.
The thread  tCOMM manages CAN handling to and from the embot::hw::can driver, decode / encode the basic messages of the CAN protocol but forwards those related to MC to the second thread.
The threads tCTRL manages decoding of the MC messages and in case of transmissions to CAN prepares the frames and forwards them to the tCOMM thread so that it can transmit them.
The threads tCTRL  also manages motor control.
For now the application02 moves a motor and sends back its status entirely w/ hand-written C++ code, but there are already hooks where to put MBD generated code.","This PR adds application02 for the amcbldc board.
We have two threads: tCOMM and tCTRL.
The thread  tCOMM manages CAN handling to and from the embot::hw::can driver, decode / encode the basic messages of the CAN protocol but forwards those related to MC to the second thread.
The threads tCTRL manages decoding of the MC messages and in case of transmissions to CAN prepares the frames and forwards them to the tCOMM thread so that it can transmit them.
The threads tCTRL  also manages motor control.
For now the application02 moves a motor and sends back its status entirely w/ hand-written C++ code, but there are already hooks where to put MBD generated code.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,197,2021-07-14T09:50:36Z,2021-07-14T09:50:57Z,2021-07-14T09:51:02Z,MERGED,True,57,22,3,https://github.com/marcoaccame,amcbldc: mild cleaning of application02,1,[],https://github.com/robotology/icub-firmware/pull/197,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/197,"As per title.
The cleaning is about moving all high level management of the motor inside the object theMCagent2: all calls to embot::hw::motor and soon also MBD generated code
The demo has been tested worked fine.","As per title.
The cleaning is about moving all high level management of the motor inside the object theMCagent2: all calls to embot::hw::motor and soon also MBD generated code
The demo has been tested worked fine.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,198,2021-07-15T08:16:17Z,2021-07-15T10:19:40Z,2021-07-15T10:19:40Z,MERGED,True,3838,11,36,https://github.com/ale-git,Added Simulink FOC control code for amc-bldc,1,[],https://github.com/robotology/icub-firmware/pull/198,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/198,"This PR adds the source code generated by Simulink for motor control (FOC) to the AMC-BLDC board project.
It doesn't control the motor yet, but only includes the required files in the software building.
@marcoaccame already verified that the communication parts is still working fine.","This PR adds the source code generated by Simulink for motor control (FOC) to the AMC-BLDC board project.
It doesn't control the motor yet, but only includes the required files in the software building.
@marcoaccame already verified that the communication parts is still working fine.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,199,2021-07-16T09:22:18Z,2021-07-16T09:22:45Z,2021-07-16T09:22:45Z,MERGED,True,7844,0,19,https://github.com/marcoaccame,MBD framework in board amcbldc for CAN decoding,2,[],https://github.com/robotology/icub-firmware/pull/199,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/199,"This PR adds a dedicated application for board amcbld, application03, where there are hooks for the code which manages CAN frames w/ the  MBD approach .
In particular, we can place initialization and processing done by the MBD decoding class in following functions:
bool embot::app::application::theCANparserMBD::Impl::initialise(const Config &cfg)
{
...
}

bool embot::app::application::theCANparserMBD::Impl::process(const embot::prot::can::Frame &frame, 
                                                             std::vector<embot::prot::can::Frame> &replies)
{
  ...
}

There are also examples of how to convert from the struct embot::prot::can::Frame to / from basic raw data types used by MBD code for the CAN frames.
    uint8_t rx_data[8] {0};
    uint8_t rx_size {0};
    uint32_t rx_id {0};

    frame.copyto(rx_id, rx_size, rx_data);
    
    uint8_t tx_data[8] {0};
    uint8_t tx_size {0};
    uint32_t tx_id {0};
    
    replies.push_back({tx_id, tx_size, tx_data});
The code was tested on the amcbldc board and it works as expected.","This PR adds a dedicated application for board amcbld, application03, where there are hooks for the code which manages CAN frames w/ the  MBD approach .
In particular, we can place initialization and processing done by the MBD decoding class in following functions:
bool embot::app::application::theCANparserMBD::Impl::initialise(const Config &cfg)
{
...
}

bool embot::app::application::theCANparserMBD::Impl::process(const embot::prot::can::Frame &frame, 
                                                             std::vector<embot::prot::can::Frame> &replies)
{
  ...
}

There are also examples of how to convert from the struct embot::prot::can::Frame to / from basic raw data types used by MBD code for the CAN frames.
    uint8_t rx_data[8] {0};
    uint8_t rx_size {0};
    uint32_t rx_id {0};

    frame.copyto(rx_id, rx_size, rx_data);
    
    uint8_t tx_data[8] {0};
    uint8_t tx_size {0};
    uint32_t tx_id {0};
    
    replies.push_back({tx_id, tx_size, tx_data});
The code was tested on the amcbldc board and it works as expected.",True,{'THUMBS_UP': ['https://github.com/vvasco']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,200,2021-08-04T15:22:55Z,2021-08-06T10:29:15Z,2021-08-06T10:29:15Z,MERGED,True,6187,47,49,https://github.com/GrmanRodriguez,Integrated code for AMC BLDC (Messaging & Supervisor),7,[],https://github.com/robotology/icub-firmware/pull/200,https://github.com/GrmanRodriguez,1,https://github.com/robotology/icub-firmware/pull/200,"This PR integrates the code generated from the mvp-0.2 branch of the AMC BLDC Model into the board in the application03 directory created here.
The code generated by MATLAB is saved in the application03/src/model-based-design directory, including files for the CAN raw2struct, CAN decoder, CAN encoder, Supervisor RX and Supervisor TX blocks.
The code was placed in the embot::app::application::theMBDagent::Impl::tick method, which is called every 1ms. Initializers were placed in the embot::app::application::theMBDagent::Impl::initialise method.
The functionality has been tested in the board and can be seen in the following video:

  
    
    

    mvp-02.mp4
    
  

  

  


cc @vvasco @sgiraz @pattacini @marcoaccame","This PR integrates the code generated from the mvp-0.2 branch of the AMC BLDC Model into the board in the application03 directory created here.
The code generated by MATLAB is saved in the application03/src/model-based-design directory, including files for the CAN raw2struct, CAN decoder, CAN encoder, Supervisor RX and Supervisor TX blocks.
The code was placed in the embot::app::application::theMBDagent::Impl::tick method, which is called every 1ms. Initializers were placed in the embot::app::application::theMBDagent::Impl::initialise method.
The functionality has been tested in the board and can be seen in the following video:

  
    
    

    mvp-02.mp4
    
  

  

  


cc @vvasco @sgiraz @pattacini @marcoaccame",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,201,2021-09-16T15:53:35Z,2021-09-21T12:33:23Z,2022-01-11T09:44:33Z,MERGED,True,395,31,15,https://github.com/marcoaccame,HardFault_Handler() collects full MPU context,2,[],https://github.com/robotology/icub-firmware/pull/201,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/201,"With this PR we have the HardFault_Handler() collect and save in non volatile RAM the full context of the MPU, so that at the restart the board sends this information over diagnostic messages.
This behaviour applies to ems, mc4plus and mc2plus.
There is an associated PR for the binaries in  robotology/icub-firmware-build#35
Behaviour of the improved diagnostics
The HardFault_Handler() now sends improved information which contains:

execution registers at the moment of the exception such as PC (program counter) and others which help understand which instruction caused the fault
system registers such as CFSR and others which tell more about the cause of the fault.

Here is an example of what the board sends when we induce a HF by some sample code which access not existing RAM.
extern void eo_fatalerror_AtStartup(EOtheFatalError *p)
{
...
    volatile unsigned int* pp;
    volatile unsigned int n;
    pp = (unsigned int*)0xCCCCCCCC;
    n = *pp;
Listing. Offending code
[INFO] (EOtheServices tsk2 @S5:m632:u625)-> {0x3b, p16 0x0000, p64 0x0000000000000000, dev 0, adr 0}: SYS: the board is bootstrapping.
[ERROR] (EOtheFatalError tsk2 @S5:m634:u218)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = RESTARTED after FATAL error
[ERROR] (EOtheFatalError tsk2 @S5:m634:u344)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = @ 5636 ms
[ERROR] (EOtheFatalError tsk2 @S5:m634:u469)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = handler hw_HardFault, code 0x0
[ERROR] (EOtheFatalError tsk2 @S5:m634:u596)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = type see TBL
[ERROR] (EOtheFatalError tsk2 @S5:m634:u723)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = IRQHan HardFault Thread tINIT
[ERROR] (EOtheFatalError tsk2 @S5:m634:u852)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ipsr 3, tid 2
[ERROR] (EOtheFatalError tsk2 @S5:m634:u973)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR 0x8200
[ERROR] (EOtheFatalError tsk2 @S5:m635:u89)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = MORE INFO
[ERROR] (EOtheFatalError tsk2 @S5:m635:u216)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ICSR = 0x00000803 SHCSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u354)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR = 0x00008200 HFSR = 0x40000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u492)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = DFSR = 0x00000000 MMFAR = 0xcccccccc
[ERROR] (EOtheFatalError tsk2 @S5:m635:u629)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = BFAR = 0xcccccccc AFSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u765)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r0 = 0xcccccccc r1 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u899)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r2 = 0x00000000 r3 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m636:u36)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r12 = 0x00000000 lr = 0x08048ab9
[ERROR] (EOtheFatalError tsk2 @S5:m636:u171)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = pc = 0x0802f87a psr = 0x41000000
Listing. Diagnostics messages
The interpretation of the diagnostic messages is not trivial. We need to refer to the ARM Cortex M4 documentation (see here) and we also need the .map file of the running application for mapping the hex addresses of the program counter for instance to the assembly and C code. We very likely will also need to re-run the very same project on the debugger.  As a fact, post mortem diagnosis w/out a debugger is very complicate.
As an example for the above situation:

with the .map we can locate the pc = 0x0802f87a to the offending function. in this case it is inside  eo_fatalerror_AtStartup() as expected




however, only w/ the debugger running we can find the offending instruction inside the C function



by looking at the system registers we can for instance see that address 0xcccccccc is the one giving problems.


Tests
The code was tested on an ems on a dedicated testbench where we caused several HF faults such as divide by zero, access to not-existing addresses but also others such as missing memory for RTOS.
The binaries of the mc4plus have been validated also with tests on icub3 (see here), hence we can merge the PR
Note
This PR addresses the problem in #174","With this PR we have the HardFault_Handler() collect and save in non volatile RAM the full context of the MPU, so that at the restart the board sends this information over diagnostic messages.
This behaviour applies to ems, mc4plus and mc2plus.
There is an associated PR for the binaries in  robotology/icub-firmware-build#35
Behaviour of the improved diagnostics
The HardFault_Handler() now sends improved information which contains:

execution registers at the moment of the exception such as PC (program counter) and others which help understand which instruction caused the fault
system registers such as CFSR and others which tell more about the cause of the fault.

Here is an example of what the board sends when we induce a HF by some sample code which access not existing RAM.
extern void eo_fatalerror_AtStartup(EOtheFatalError *p)
{
...
    volatile unsigned int* pp;
    volatile unsigned int n;
    pp = (unsigned int*)0xCCCCCCCC;
    n = *pp;
Listing. Offending code
[INFO] (EOtheServices tsk2 @S5:m632:u625)-> {0x3b, p16 0x0000, p64 0x0000000000000000, dev 0, adr 0}: SYS: the board is bootstrapping.
[ERROR] (EOtheFatalError tsk2 @S5:m634:u218)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = RESTARTED after FATAL error
[ERROR] (EOtheFatalError tsk2 @S5:m634:u344)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = @ 5636 ms
[ERROR] (EOtheFatalError tsk2 @S5:m634:u469)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = handler hw_HardFault, code 0x0
[ERROR] (EOtheFatalError tsk2 @S5:m634:u596)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = type see TBL
[ERROR] (EOtheFatalError tsk2 @S5:m634:u723)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = IRQHan HardFault Thread tINIT
[ERROR] (EOtheFatalError tsk2 @S5:m634:u852)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ipsr 3, tid 2
[ERROR] (EOtheFatalError tsk2 @S5:m634:u973)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR 0x8200
[ERROR] (EOtheFatalError tsk2 @S5:m635:u89)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = MORE INFO
[ERROR] (EOtheFatalError tsk2 @S5:m635:u216)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ICSR = 0x00000803 SHCSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u354)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR = 0x00008200 HFSR = 0x40000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u492)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = DFSR = 0x00000000 MMFAR = 0xcccccccc
[ERROR] (EOtheFatalError tsk2 @S5:m635:u629)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = BFAR = 0xcccccccc AFSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u765)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r0 = 0xcccccccc r1 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u899)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r2 = 0x00000000 r3 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m636:u36)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r12 = 0x00000000 lr = 0x08048ab9
[ERROR] (EOtheFatalError tsk2 @S5:m636:u171)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = pc = 0x0802f87a psr = 0x41000000
Listing. Diagnostics messages
The interpretation of the diagnostic messages is not trivial. We need to refer to the ARM Cortex M4 documentation (see here) and we also need the .map file of the running application for mapping the hex addresses of the program counter for instance to the assembly and C code. We very likely will also need to re-run the very same project on the debugger.  As a fact, post mortem diagnosis w/out a debugger is very complicate.
As an example for the above situation:

with the .map we can locate the pc = 0x0802f87a to the offending function. in this case it is inside  eo_fatalerror_AtStartup() as expected




however, only w/ the debugger running we can find the offending instruction inside the C function



by looking at the system registers we can for instance see that address 0xcccccccc is the one giving problems.


Tests
The code was tested on an ems on a dedicated testbench where we caused several HF faults such as divide by zero, access to not-existing addresses but also others such as missing memory for RTOS.
The binaries of the mc4plus have been validated also with tests on icub3 (see here), hence we can merge the PR
Note
This PR addresses the problem in #174",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,201,2021-09-16T15:53:35Z,2021-09-21T12:33:23Z,2022-01-11T09:44:33Z,MERGED,True,395,31,15,https://github.com/marcoaccame,HardFault_Handler() collects full MPU context,2,[],https://github.com/robotology/icub-firmware/pull/201,https://github.com/traversaro,2,https://github.com/robotology/icub-firmware/pull/201#issuecomment-921574216,"With this PR we have the HardFault_Handler() collect and save in non volatile RAM the full context of the MPU, so that at the restart the board sends this information over diagnostic messages.
This behaviour applies to ems, mc4plus and mc2plus.
There is an associated PR for the binaries in  robotology/icub-firmware-build#35
Behaviour of the improved diagnostics
The HardFault_Handler() now sends improved information which contains:

execution registers at the moment of the exception such as PC (program counter) and others which help understand which instruction caused the fault
system registers such as CFSR and others which tell more about the cause of the fault.

Here is an example of what the board sends when we induce a HF by some sample code which access not existing RAM.
extern void eo_fatalerror_AtStartup(EOtheFatalError *p)
{
...
    volatile unsigned int* pp;
    volatile unsigned int n;
    pp = (unsigned int*)0xCCCCCCCC;
    n = *pp;
Listing. Offending code
[INFO] (EOtheServices tsk2 @S5:m632:u625)-> {0x3b, p16 0x0000, p64 0x0000000000000000, dev 0, adr 0}: SYS: the board is bootstrapping.
[ERROR] (EOtheFatalError tsk2 @S5:m634:u218)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = RESTARTED after FATAL error
[ERROR] (EOtheFatalError tsk2 @S5:m634:u344)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = @ 5636 ms
[ERROR] (EOtheFatalError tsk2 @S5:m634:u469)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = handler hw_HardFault, code 0x0
[ERROR] (EOtheFatalError tsk2 @S5:m634:u596)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = type see TBL
[ERROR] (EOtheFatalError tsk2 @S5:m634:u723)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = IRQHan HardFault Thread tINIT
[ERROR] (EOtheFatalError tsk2 @S5:m634:u852)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ipsr 3, tid 2
[ERROR] (EOtheFatalError tsk2 @S5:m634:u973)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR 0x8200
[ERROR] (EOtheFatalError tsk2 @S5:m635:u89)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = MORE INFO
[ERROR] (EOtheFatalError tsk2 @S5:m635:u216)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ICSR = 0x00000803 SHCSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u354)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR = 0x00008200 HFSR = 0x40000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u492)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = DFSR = 0x00000000 MMFAR = 0xcccccccc
[ERROR] (EOtheFatalError tsk2 @S5:m635:u629)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = BFAR = 0xcccccccc AFSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u765)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r0 = 0xcccccccc r1 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u899)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r2 = 0x00000000 r3 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m636:u36)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r12 = 0x00000000 lr = 0x08048ab9
[ERROR] (EOtheFatalError tsk2 @S5:m636:u171)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = pc = 0x0802f87a psr = 0x41000000
Listing. Diagnostics messages
The interpretation of the diagnostic messages is not trivial. We need to refer to the ARM Cortex M4 documentation (see here) and we also need the .map file of the running application for mapping the hex addresses of the program counter for instance to the assembly and C code. We very likely will also need to re-run the very same project on the debugger.  As a fact, post mortem diagnosis w/out a debugger is very complicate.
As an example for the above situation:

with the .map we can locate the pc = 0x0802f87a to the offending function. in this case it is inside  eo_fatalerror_AtStartup() as expected




however, only w/ the debugger running we can find the offending instruction inside the C function



by looking at the system registers we can for instance see that address 0xcccccccc is the one giving problems.


Tests
The code was tested on an ems on a dedicated testbench where we caused several HF faults such as divide by zero, access to not-existing addresses but also others such as missing memory for RTOS.
The binaries of the mc4plus have been validated also with tests on icub3 (see here), hence we can merge the PR
Note
This PR addresses the problem in #174",fyi @S-Dafarra @isorrentino @paolo-viceconte,True,{'THUMBS_UP': ['https://github.com/paolo-viceconte']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,201,2021-09-16T15:53:35Z,2021-09-21T12:33:23Z,2022-01-11T09:44:33Z,MERGED,True,395,31,15,https://github.com/marcoaccame,HardFault_Handler() collects full MPU context,2,[],https://github.com/robotology/icub-firmware/pull/201,https://github.com/marcoaccame,3,https://github.com/robotology/icub-firmware/pull/201#issuecomment-923941411,"With this PR we have the HardFault_Handler() collect and save in non volatile RAM the full context of the MPU, so that at the restart the board sends this information over diagnostic messages.
This behaviour applies to ems, mc4plus and mc2plus.
There is an associated PR for the binaries in  robotology/icub-firmware-build#35
Behaviour of the improved diagnostics
The HardFault_Handler() now sends improved information which contains:

execution registers at the moment of the exception such as PC (program counter) and others which help understand which instruction caused the fault
system registers such as CFSR and others which tell more about the cause of the fault.

Here is an example of what the board sends when we induce a HF by some sample code which access not existing RAM.
extern void eo_fatalerror_AtStartup(EOtheFatalError *p)
{
...
    volatile unsigned int* pp;
    volatile unsigned int n;
    pp = (unsigned int*)0xCCCCCCCC;
    n = *pp;
Listing. Offending code
[INFO] (EOtheServices tsk2 @S5:m632:u625)-> {0x3b, p16 0x0000, p64 0x0000000000000000, dev 0, adr 0}: SYS: the board is bootstrapping.
[ERROR] (EOtheFatalError tsk2 @S5:m634:u218)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = RESTARTED after FATAL error
[ERROR] (EOtheFatalError tsk2 @S5:m634:u344)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = @ 5636 ms
[ERROR] (EOtheFatalError tsk2 @S5:m634:u469)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = handler hw_HardFault, code 0x0
[ERROR] (EOtheFatalError tsk2 @S5:m634:u596)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = type see TBL
[ERROR] (EOtheFatalError tsk2 @S5:m634:u723)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = IRQHan HardFault Thread tINIT
[ERROR] (EOtheFatalError tsk2 @S5:m634:u852)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ipsr 3, tid 2
[ERROR] (EOtheFatalError tsk2 @S5:m634:u973)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR 0x8200
[ERROR] (EOtheFatalError tsk2 @S5:m635:u89)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = MORE INFO
[ERROR] (EOtheFatalError tsk2 @S5:m635:u216)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = ICSR = 0x00000803 SHCSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u354)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = CFSR = 0x00008200 HFSR = 0x40000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u492)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = DFSR = 0x00000000 MMFAR = 0xcccccccc
[ERROR] (EOtheFatalError tsk2 @S5:m635:u629)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = BFAR = 0xcccccccc AFSR = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u765)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r0 = 0xcccccccc r1 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m635:u899)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r2 = 0x00000000 r3 = 0x00000000
[ERROR] (EOtheFatalError tsk2 @S5:m636:u36)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = r12 = 0x00000000 lr = 0x08048ab9
[ERROR] (EOtheFatalError tsk2 @S5:m636:u171)-> {0x4000000 p16 0x0000, p64 0x0203000600001604, dev 0, adr 0}: DEBUG: tag00. INFO = pc = 0x0802f87a psr = 0x41000000
Listing. Diagnostics messages
The interpretation of the diagnostic messages is not trivial. We need to refer to the ARM Cortex M4 documentation (see here) and we also need the .map file of the running application for mapping the hex addresses of the program counter for instance to the assembly and C code. We very likely will also need to re-run the very same project on the debugger.  As a fact, post mortem diagnosis w/out a debugger is very complicate.
As an example for the above situation:

with the .map we can locate the pc = 0x0802f87a to the offending function. in this case it is inside  eo_fatalerror_AtStartup() as expected




however, only w/ the debugger running we can find the offending instruction inside the C function



by looking at the system registers we can for instance see that address 0xcccccccc is the one giving problems.


Tests
The code was tested on an ems on a dedicated testbench where we caused several HF faults such as divide by zero, access to not-existing addresses but also others such as missing memory for RTOS.
The binaries of the mc4plus have been validated also with tests on icub3 (see here), hence we can merge the PR
Note
This PR addresses the problem in #174","The binaries of the mc4plus have been validated also with tests on icub3 (see here), hence we can merge the PR",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,203,2021-09-21T12:30:18Z,2021-09-21T14:48:43Z,2021-10-07T12:01:28Z,MERGED,True,942,1211,44,https://github.com/GrmanRodriguez,Updated AMC BLDC Application 03 to use generated code with nonvirtual buses,1,[],https://github.com/robotology/icub-firmware/pull/203,https://github.com/GrmanRodriguez,1,https://github.com/robotology/icub-firmware/pull/203,"This PR updates application 03 from MVP 0.2 to the recent change in using nonvirtual buses (from this PR in study-amc-bldc).
C++ code was re-generated using nonvirtual buses and added as part of the project files. The theMBDagent class has been updated to use the new code.
As expected, adapting the new code was significantly easier and required less variables than before. Here is an example in the previous code:
-               can_decoder.step(&decoder_available, &packet_CLS, &packet_SRC, &packet_DST_TYP, &packet_LEN, &packet_M, &packet_OPC, &packet_ARG[0],
-                                &rtb_motor, &rtb_mode, &rtb_motor_e, &rtb_nominal, &rtb_peak, &rtb_overload, &rtb_current_o, &rtb_control_mode, &rtb_current_limit, &rtb_desired_current, &rtb_event, &rtb_type);
+               can_decoder.step(bus_can_rx, bus_messages_rx, bus_events_rx, bus_can_rx_errors);

-    supervisor_rx.step((const BoardState*)board_state_gnd, (const BoardCommand*)board_command_gnd,
-                       &iabc[0], &angle, &omega, &temperature, &motor_sensors_voltage,
-                       &current_threshold, &cu_k_threshold, &voltage_threshold, &vo_k_threshold, &temperature_threshold, &te_c_threshold,
-                       &motor_sensors_current,
-                       &rtb_event, &rtb_control_mode, &rtb_current_limit, &rtb_desired_current,
-                       &rtb_motor, &rtb_mode, &rtb_motor_e, &rtb_nominal, &rtb_peak, &rtb_overload, &rtb_current_o,
-                       &supervisor_control_mode, &pid_reset, &position, &velocity, &current, &voltage);
+    supervisor_rx.step(internal_messages, motor_sensors, bus_events_rx, bus_messages_rx, bus_can_rx_errors, flags, targets);

The application has been tested using CANReal and the behavior remains identical to before. Particularly when using the scan, set control mode idle and set control mode speedvoltage commands.
This PR addresses #747.
cc @sgiraz @valegagge @pattacini","This PR updates application 03 from MVP 0.2 to the recent change in using nonvirtual buses (from this PR in study-amc-bldc).
C++ code was re-generated using nonvirtual buses and added as part of the project files. The theMBDagent class has been updated to use the new code.
As expected, adapting the new code was significantly easier and required less variables than before. Here is an example in the previous code:
-               can_decoder.step(&decoder_available, &packet_CLS, &packet_SRC, &packet_DST_TYP, &packet_LEN, &packet_M, &packet_OPC, &packet_ARG[0],
-                                &rtb_motor, &rtb_mode, &rtb_motor_e, &rtb_nominal, &rtb_peak, &rtb_overload, &rtb_current_o, &rtb_control_mode, &rtb_current_limit, &rtb_desired_current, &rtb_event, &rtb_type);
+               can_decoder.step(bus_can_rx, bus_messages_rx, bus_events_rx, bus_can_rx_errors);

-    supervisor_rx.step((const BoardState*)board_state_gnd, (const BoardCommand*)board_command_gnd,
-                       &iabc[0], &angle, &omega, &temperature, &motor_sensors_voltage,
-                       &current_threshold, &cu_k_threshold, &voltage_threshold, &vo_k_threshold, &temperature_threshold, &te_c_threshold,
-                       &motor_sensors_current,
-                       &rtb_event, &rtb_control_mode, &rtb_current_limit, &rtb_desired_current,
-                       &rtb_motor, &rtb_mode, &rtb_motor_e, &rtb_nominal, &rtb_peak, &rtb_overload, &rtb_current_o,
-                       &supervisor_control_mode, &pid_reset, &position, &velocity, &current, &voltage);
+    supervisor_rx.step(internal_messages, motor_sensors, bus_events_rx, bus_messages_rx, bus_can_rx_errors, flags, targets);

The application has been tested using CANReal and the behavior remains identical to before. Particularly when using the scan, set control mode idle and set control mode speedvoltage commands.
This PR addresses #747.
cc @sgiraz @valegagge @pattacini",True,"{'ROCKET': ['https://github.com/pattacini', 'https://github.com/Nicogene']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,203,2021-09-21T12:30:18Z,2021-09-21T14:48:43Z,2021-10-07T12:01:28Z,MERGED,True,942,1211,44,https://github.com/GrmanRodriguez,Updated AMC BLDC Application 03 to use generated code with nonvirtual buses,1,[],https://github.com/robotology/icub-firmware/pull/203,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/203#issuecomment-923947043,"This PR updates application 03 from MVP 0.2 to the recent change in using nonvirtual buses (from this PR in study-amc-bldc).
C++ code was re-generated using nonvirtual buses and added as part of the project files. The theMBDagent class has been updated to use the new code.
As expected, adapting the new code was significantly easier and required less variables than before. Here is an example in the previous code:
-               can_decoder.step(&decoder_available, &packet_CLS, &packet_SRC, &packet_DST_TYP, &packet_LEN, &packet_M, &packet_OPC, &packet_ARG[0],
-                                &rtb_motor, &rtb_mode, &rtb_motor_e, &rtb_nominal, &rtb_peak, &rtb_overload, &rtb_current_o, &rtb_control_mode, &rtb_current_limit, &rtb_desired_current, &rtb_event, &rtb_type);
+               can_decoder.step(bus_can_rx, bus_messages_rx, bus_events_rx, bus_can_rx_errors);

-    supervisor_rx.step((const BoardState*)board_state_gnd, (const BoardCommand*)board_command_gnd,
-                       &iabc[0], &angle, &omega, &temperature, &motor_sensors_voltage,
-                       &current_threshold, &cu_k_threshold, &voltage_threshold, &vo_k_threshold, &temperature_threshold, &te_c_threshold,
-                       &motor_sensors_current,
-                       &rtb_event, &rtb_control_mode, &rtb_current_limit, &rtb_desired_current,
-                       &rtb_motor, &rtb_mode, &rtb_motor_e, &rtb_nominal, &rtb_peak, &rtb_overload, &rtb_current_o,
-                       &supervisor_control_mode, &pid_reset, &position, &velocity, &current, &voltage);
+    supervisor_rx.step(internal_messages, motor_sensors, bus_events_rx, bus_messages_rx, bus_can_rx_errors, flags, targets);

The application has been tested using CANReal and the behavior remains identical to before. Particularly when using the scan, set control mode idle and set control mode speedvoltage commands.
This PR addresses #747.
cc @sgiraz @valegagge @pattacini",Happy to read that ,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,204,2021-09-24T09:38:48Z,2021-10-04T15:29:11Z,2021-10-04T15:29:11Z,MERGED,True,15,9,2,https://github.com/GrmanRodriguez,Updated AMC BLDC firmware to use new format ID function,1,[],https://github.com/robotology/icub-firmware/pull/204,https://github.com/GrmanRodriguez,1,https://github.com/robotology/icub-firmware/pull/204,"This PR updates application03 to reflect the latest changes in study-mbd-amc-bldc, regarding the use of a new function for setting the ID of the output CAN messages.
This has been tested on the board and the behavior remains the same, only difference is a more correct ID in the output messages, as you can see in this comment","This PR updates application03 to reflect the latest changes in study-mbd-amc-bldc, regarding the use of a new function for setting the ID of the output CAN messages.
This has been tested on the board and the behavior remains the same, only difference is a more correct ID in the output messages, as you can see in this comment",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,205,2021-10-04T15:26:13Z,2021-10-05T10:11:21Z,2022-01-11T09:41:24Z,MERGED,True,785828,539977,2324,https://github.com/marcoaccame,IPAL for CM7,17,[],https://github.com/robotology/icub-firmware/pull/205,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/205,"This PR adds IP communication to the development board stm32h745disco using the IPAL abstraction layer.
The added code consists of three parts:

the IPAL library w/ its API implemented with lwIP and compiled for the STM32H7 MPU
the adaptation of the stm32hal to the stm32h745disco board
a set of UDP test programs used to verify the UDP stack

Here are fragments of a minimal sample program which successfully respond to a ping.
#include ""stm32hal.h""
#include ""ipal.h""
#include ""ipal_cfg2.h""
Listing. The inclusion files.
int main(void)
{ 
    stm32hal_init(&systickcfg);
    
    itm_puts(""hello world"");
    
    led_init();
    itm_puts(""led initted"");
Listing. The initialization of the HW plus some prints.
    uint32_t *data04aligned = nullptr;
    uint32_t size04aligned = 0;
	ipal_base_memory_getsize2(&ipal_cfg2, &size04aligned);
    if(size04aligned > 0)
    {
        data04aligned = new uint32_t[size04aligned/4];
    }    
	ipal_base_initialise2(&ipal_cfg2, data04aligned);

	ipal_sys_start();
Listing. The initialization of IPAL.
    for(;;)
    {    
        ipal_sys_process_communication();
        volatile uint32_t now = HAL_GetTick();		 
		// Every 10 ms invokes the periodic ipal timer_tick function        
        if((now - prevtick) >= tickperiodms)
        {
            prevtick = now;
            ipal_sys_timetick_increment();
            
            // and i toggle the led every 200 ms
            static uint32_t tt = 0;
            if(0 == (++tt%20))
            {
                led_toggle();
            }
        }
    }    
Listing. The running of IPAL.
And in here is a flavor of the configuration variable called ipal_cfg2.
static const ipal_cfg2_eth_t ethcfg2 =
{
    .eth_mac = IPAL_mac48addr(0x1E,0x30,0x6C,0xA2,0x45,0x5E),
    .eth_ip = IPAL_ipv4addr(10, 0, 1, 99),
    .eth_mask = IPAL_ipv4addr(255, 255, 255, 0),
    .eth_isrpriority = 0,
    .filler = {0, 0, 0, 0, 0, 0, 0},
    .hal_eth_init = ipal_hal_eth_stm32h7_init,
    .hal_eth_enable = ipal_hal_eth_stm32h7_enable,
    .hal_eth_disable = ipal_hal_eth_stm32h7_disable,
    .hal_eth_sendframe = ipal_hal_eth_stm32h7_sendframe,
    .get_frame_size = ipal_hal_eth_stm32h7_get_frame_size,
    .get_frame = ipal_hal_eth_stm32h7_get_frame    
};
...
constexpr uint32_t tout = 10;

static const ipal_cfg2_extfn_t extfncfg2 = 
{
    .usr_on_fatal_error = ipal_app_on_fatal_error,
    .signal_rx_frame = ipal_app_usr_on_rx_frame,
    .signal_tx_frame = ipal_app_usr_on_tx_frame,
    .osal_mutex_new = osal_mutex_new,
    .osal_mutex_take = osal_mutex_take,
    .osal_mutex_release = osal_mutex_release,
    .osal_param_tout_forever = 10,
    .dummy = 0 
};

const ipal_cfg2_t ipal_cfg2 = 
{
    .support = (ipal_cfg2_support_t*) &suppcfg2,
    .system = (ipal_cfg2_system_t*) &syscfg2,
    .eth = (ipal_cfg2_eth_t*) &ethcfg2,
    .arp = (ipal_cfg2_arp_t*) &arpcfg2,
    .udp = (ipal_cfg2_udp_t*) &udpcfg2,
    .igmp = (ipal_cfg2_igmp_t*) &igmpcfg2,
    .dhcp = NULL,
    .extfn2 = (ipal_cfg2_extfn_t*) &extfncfg2    
};
Listing. The configuration  of IPAL.
For mode details refer to the project in path icub-firmware\emBODY\eBcode\arch-arm\board\stm32h745disco\examples\basicping.
Tests
The tests have shown that the new stack works on the stm32h745disco board. Moreover the new code does not interfere w/ code already running on the robot.","This PR adds IP communication to the development board stm32h745disco using the IPAL abstraction layer.
The added code consists of three parts:

the IPAL library w/ its API implemented with lwIP and compiled for the STM32H7 MPU
the adaptation of the stm32hal to the stm32h745disco board
a set of UDP test programs used to verify the UDP stack

Here are fragments of a minimal sample program which successfully respond to a ping.
#include ""stm32hal.h""
#include ""ipal.h""
#include ""ipal_cfg2.h""
Listing. The inclusion files.
int main(void)
{ 
    stm32hal_init(&systickcfg);
    
    itm_puts(""hello world"");
    
    led_init();
    itm_puts(""led initted"");
Listing. The initialization of the HW plus some prints.
    uint32_t *data04aligned = nullptr;
    uint32_t size04aligned = 0;
	ipal_base_memory_getsize2(&ipal_cfg2, &size04aligned);
    if(size04aligned > 0)
    {
        data04aligned = new uint32_t[size04aligned/4];
    }    
	ipal_base_initialise2(&ipal_cfg2, data04aligned);

	ipal_sys_start();
Listing. The initialization of IPAL.
    for(;;)
    {    
        ipal_sys_process_communication();
        volatile uint32_t now = HAL_GetTick();		 
		// Every 10 ms invokes the periodic ipal timer_tick function        
        if((now - prevtick) >= tickperiodms)
        {
            prevtick = now;
            ipal_sys_timetick_increment();
            
            // and i toggle the led every 200 ms
            static uint32_t tt = 0;
            if(0 == (++tt%20))
            {
                led_toggle();
            }
        }
    }    
Listing. The running of IPAL.
And in here is a flavor of the configuration variable called ipal_cfg2.
static const ipal_cfg2_eth_t ethcfg2 =
{
    .eth_mac = IPAL_mac48addr(0x1E,0x30,0x6C,0xA2,0x45,0x5E),
    .eth_ip = IPAL_ipv4addr(10, 0, 1, 99),
    .eth_mask = IPAL_ipv4addr(255, 255, 255, 0),
    .eth_isrpriority = 0,
    .filler = {0, 0, 0, 0, 0, 0, 0},
    .hal_eth_init = ipal_hal_eth_stm32h7_init,
    .hal_eth_enable = ipal_hal_eth_stm32h7_enable,
    .hal_eth_disable = ipal_hal_eth_stm32h7_disable,
    .hal_eth_sendframe = ipal_hal_eth_stm32h7_sendframe,
    .get_frame_size = ipal_hal_eth_stm32h7_get_frame_size,
    .get_frame = ipal_hal_eth_stm32h7_get_frame    
};
...
constexpr uint32_t tout = 10;

static const ipal_cfg2_extfn_t extfncfg2 = 
{
    .usr_on_fatal_error = ipal_app_on_fatal_error,
    .signal_rx_frame = ipal_app_usr_on_rx_frame,
    .signal_tx_frame = ipal_app_usr_on_tx_frame,
    .osal_mutex_new = osal_mutex_new,
    .osal_mutex_take = osal_mutex_take,
    .osal_mutex_release = osal_mutex_release,
    .osal_param_tout_forever = 10,
    .dummy = 0 
};

const ipal_cfg2_t ipal_cfg2 = 
{
    .support = (ipal_cfg2_support_t*) &suppcfg2,
    .system = (ipal_cfg2_system_t*) &syscfg2,
    .eth = (ipal_cfg2_eth_t*) &ethcfg2,
    .arp = (ipal_cfg2_arp_t*) &arpcfg2,
    .udp = (ipal_cfg2_udp_t*) &udpcfg2,
    .igmp = (ipal_cfg2_igmp_t*) &igmpcfg2,
    .dhcp = NULL,
    .extfn2 = (ipal_cfg2_extfn_t*) &extfncfg2    
};
Listing. The configuration  of IPAL.
For mode details refer to the project in path icub-firmware\emBODY\eBcode\arch-arm\board\stm32h745disco\examples\basicping.
Tests
The tests have shown that the new stack works on the stm32h745disco board. Moreover the new code does not interfere w/ code already running on the robot.",True,{'ROCKET': ['https://github.com/valegagge']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,206,2021-10-06T11:24:00Z,2021-10-08T06:58:54Z,2021-10-08T06:58:54Z,MERGED,True,16686,12,73,https://github.com/valegagge,Add AMC-BLDC application04,16,[],https://github.com/robotology/icub-firmware/pull/206,https://github.com/valegagge,1,https://github.com/robotology/icub-firmware/pull/206,"In this PR we want to add the application04 for AMC-BLDC board.
In short, application04 is a test program for the amcbldc board which:

runs a CAN encoder / decoder and a motor controller both obtained w/ a model based design approach,
implements a HW driver for FOC motor control

The novelty of this application04 is that finally integrates all the MBD components.
It was successfully tested using a Matlab application running on a laptop that sends setpoints to the board by CAN.
In here is a video of the result.

  
    
    

    applicatio04-moves-a-motor.mov
    
  

  

  


Figure. The first plot shows the current set point (in orange) and the measurements from the board (in green), both in units of mA. The second plot shows the velocity (in terms of Electrical Angle) in deg/ms. The final plot shows the set point. 1 = Idle, 2 = Current control with fixed set point, 3 = Current control following the orange line of plot 1.
cc @sgiraz @GrmanRodriguez @ale-git","In this PR we want to add the application04 for AMC-BLDC board.
In short, application04 is a test program for the amcbldc board which:

runs a CAN encoder / decoder and a motor controller both obtained w/ a model based design approach,
implements a HW driver for FOC motor control

The novelty of this application04 is that finally integrates all the MBD components.
It was successfully tested using a Matlab application running on a laptop that sends setpoints to the board by CAN.
In here is a video of the result.

  
    
    

    applicatio04-moves-a-motor.mov
    
  

  

  


Figure. The first plot shows the current set point (in orange) and the measurements from the board (in green), both in units of mA. The second plot shows the velocity (in terms of Electrical Angle) in deg/ms. The final plot shows the set point. 1 = Idle, 2 = Current control with fixed set point, 3 = Current control following the orange line of plot 1.
cc @sgiraz @GrmanRodriguez @ale-git",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,207,2021-10-08T09:12:07Z,,2022-02-02T06:51:53Z,OPEN,False,2179,2179,4,https://github.com/andreamerello,PMC piezo driver: update wave tables - shrink in range 2V to 44V,2,[],https://github.com/robotology/icub-firmware/pull/207,https://github.com/andreamerello,1,https://github.com/robotology/icub-firmware/pull/207,"The PMC piezo driver currently uses:

precalculated tables to generate the waves required to drive piezo motor phases
internally-generated ramps in range PIEZO_MINVOLTAGE  to PIEZO_MAXVOLTAGE in order to brake and to go in freewheel state (which I don't know whether really works with those motors), and forced PIEZO_MINVOLTAGE in case of overcurrent.

Currently the tables were in range 128 to 65407 (DAC codes) while the PIEZO_MINVOLTAGE and PIEZO_MAXVOLTAGE lead to DAC codes in range  2760 to 60707.
This is clearly visible in this screenshot

According to G.Z:

The purpose of clamping the operation range is to avoid driving the voltage outside electronic operating range i.e. otherwise the electronic may clamp the voltage.
The correct operating range for the electronic is the one specified by  PIEZO_MINVOLTAGE  and PIEZO_MAXVOLTAGE constants

This lead to the conclusion that the wave tables should be recalculated to fit in the 2760 to 60707 range.
This PR updateds the tables and the generation script according to this.
The outcome is visible in the following screenshot. NOTE: It has been not tested on real HW.","The PMC piezo driver currently uses:

precalculated tables to generate the waves required to drive piezo motor phases
internally-generated ramps in range PIEZO_MINVOLTAGE  to PIEZO_MAXVOLTAGE in order to brake and to go in freewheel state (which I don't know whether really works with those motors), and forced PIEZO_MINVOLTAGE in case of overcurrent.

Currently the tables were in range 128 to 65407 (DAC codes) while the PIEZO_MINVOLTAGE and PIEZO_MAXVOLTAGE lead to DAC codes in range  2760 to 60707.
This is clearly visible in this screenshot

According to G.Z:

The purpose of clamping the operation range is to avoid driving the voltage outside electronic operating range i.e. otherwise the electronic may clamp the voltage.
The correct operating range for the electronic is the one specified by  PIEZO_MINVOLTAGE  and PIEZO_MAXVOLTAGE constants

This lead to the conclusion that the wave tables should be recalculated to fit in the 2760 to 60707 range.
This PR updateds the tables and the generation script according to this.
The outcome is visible in the following screenshot. NOTE: It has been not tested on real HW.",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,208,2021-10-08T16:37:52Z,2021-10-08T16:40:20Z,2022-01-11T09:41:27Z,MERGED,True,21962,245,124,https://github.com/marcoaccame,EOMtheIPnet demo for CM7,8,[],https://github.com/robotology/icub-firmware/pull/208,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/208,"This PR increases the IP support for CM7 introduced w/ #205.
In here there is a further UDP project (udpdemoipnet) which uses EOMtheIPnet and the EOSocketDatagram objects  which offer UDP communication.  These are the objects which sits on top of IPAL to offer the UDP socket communication services on boards ems, mc4plus and mc2plus.
In here is a primer on the internals of EOMtheIPnet and its use with EOSocketDatagram objects.
I have successfully tested it on the stm32h745disco board, the only one for which we have a working UDP stack for CM7.","This PR increases the IP support for CM7 introduced w/ #205.
In here there is a further UDP project (udpdemoipnet) which uses EOMtheIPnet and the EOSocketDatagram objects  which offer UDP communication.  These are the objects which sits on top of IPAL to offer the UDP socket communication services on boards ems, mc4plus and mc2plus.
In here is a primer on the internals of EOMtheIPnet and its use with EOSocketDatagram objects.
I have successfully tested it on the stm32h745disco board, the only one for which we have a working UDP stack for CM7.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,209,2021-10-18T13:48:55Z,2021-10-18T19:06:18Z,2022-01-11T09:41:29Z,MERGED,True,5597,963,23,https://github.com/marcoaccame,RTOS trace for mc4plus,4,[],https://github.com/robotology/icub-firmware/pull/209,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/209,"This PR adds new features useful to trace the fatal error happening on the mc4plus running on iCub.
The fatal error is documented in issue robotology/icub-tech-support#673 and the analysis of a recent log file shows that the fatal error happens inside the SVC handler called by the RTOS when the thread Timer Manager is scheduled.
So, we have added extra code to detect in more details what is happening so that more detailed information is sent to yarprobotinterface's  log.
The extra code is activated if we use a special target of the project mc4plus.diagnostic2ready.uvprojx which defines macros FATALERR_trace_TMRMAN  and FATALERR_trace_RTOS.
In particular, the code does the following:

it specializes what before was falling into hard fault with three more dedicated handlers: UsageFault_Handler(), MemManage_Handler() and BusFault_Handler();
it enables the PRECISERR flag so that in faults of type BusFault and MemManage we can have a precise indication of the offending memory location (see ARM's official documentation for details);
it adds 8 + 8 trace variables for the candidate pieces of code which caused the error: the last scheduled user thread EOtheTimerManager and the offending function inside the RTOS  rt_rmv_dly();
it adds the new 16 trace values to the diagnostics messages sent to yarprobotinterface after a restart due to fatal error.

The code was verified with a test, whose basic details we report in the following in order to show the format of the new log.
Inside the thread tINIT I have forced a divide by zero operation which triggers a fatal error.
    eOerrmanDescriptor_t errdes = {0};
    errdes.code             = eoerror_code_get(eoerror_category_System, eoerror_value_SYS_runninghappily);
    errdes.sourcedevice     = eo_errman_sourcedevice_localboard;
    errdes.sourceaddress    = 0;
    errdes.par16            = 0x0000;
    errdes.par64            = 0;
    eo_errman_Error(eo_errman_GetHandle(), eo_errortype_info, NULL, s_eobj_ownname, &errdes);     
    
#if 1    
    // test the EOtheFatalError
    volatile uint32_t value = 32;
    volatile uint32_t divider = 0;
    volatile uint32_t result = 0;
    value++;
    result = value / divider;    
#endif
In this case, the diagnostics which is sent to yarprobotinterface tells:
...INFO = RESTARTED after FATAL error
...DEBUG: tag00. INFO = @ 12636 ms
...DEBUG: tag00. INFO = handler hw_UsageFault, code 0x64
...DEBUG: tag00. INFO = type see TBL
...DEBUG: tag00. INFO = ipsr 6, tid 2
...DEBUG: tag00. INFO = MORE INFO
...DEBUG: tag00. INFO = ICSR = 0x00000806 SHCSR = 0x00070008
...DEBUG: tag00. INFO = CFSR = 0x02000000 HFSR = 0x00000000
...DEBUG: tag00. INFO = DFSR = 0x00000000 MMFAR = 0xe000ed34
...DEBUG: tag00. INFO = BFAR = 0xe000ed38 AFSR = 0x00000000
...DEBUG: tag00. INFO = r0 = 0x00000021 r1 = 0x00000000
...DEBUG: tag00. INFO = r2 = 0x000000fe r3 = 0x00000000
...DEBUG: tag00. INFO = r12 = 0x08059725 lr = 0x08055be5
...DEBUG: tag00. INFO = pc = 0x08036fe8 psr = 0x01000000
...DEBUG: tag00. INFO = TM0 = 0x00000044 TM1 = 0x20007038
...DEBUG: tag00. INFO = TM2 = 0x20007054 TM3 = 0x00000000
...DEBUG: tag00. INFO = TM4 = 0x00000000 TM5 = 0x00000003
...DEBUG: tag00. INFO = TM6 = 0x00000000 TM7 = 0x00000000
...DEBUG: tag00. INFO = RT0 = 0x00000005 RT1 = 0x00000002
...DEBUG: tag00. INFO = RT2 = 0x20006e80 RT3 = 0x00000000
...DEBUG: tag00. INFO = RT4 = 0x20007980 RT5 = 0x00000056
...DEBUG: tag00. INFO = RT6 = 0x20007830 RT7 = 0x00000000

Listing.  Diagnostics sent with a fatal error caused by a divide by zero operation.
Its interpretation is that there was a usage fault due to what described in register CFSR. In particular the bit CFSR.UFSR.DIVBYZERO is set so we have confirmation that it is a division by zero. The offending instruction is at address code pc = 0x08036fe8 which is inside eo_services_Initialise(). See pictures.


Further tests were done on a dedicated setup where yarprobotinterface successfully run a motor.","This PR adds new features useful to trace the fatal error happening on the mc4plus running on iCub.
The fatal error is documented in issue robotology/icub-tech-support#673 and the analysis of a recent log file shows that the fatal error happens inside the SVC handler called by the RTOS when the thread Timer Manager is scheduled.
So, we have added extra code to detect in more details what is happening so that more detailed information is sent to yarprobotinterface's  log.
The extra code is activated if we use a special target of the project mc4plus.diagnostic2ready.uvprojx which defines macros FATALERR_trace_TMRMAN  and FATALERR_trace_RTOS.
In particular, the code does the following:

it specializes what before was falling into hard fault with three more dedicated handlers: UsageFault_Handler(), MemManage_Handler() and BusFault_Handler();
it enables the PRECISERR flag so that in faults of type BusFault and MemManage we can have a precise indication of the offending memory location (see ARM's official documentation for details);
it adds 8 + 8 trace variables for the candidate pieces of code which caused the error: the last scheduled user thread EOtheTimerManager and the offending function inside the RTOS  rt_rmv_dly();
it adds the new 16 trace values to the diagnostics messages sent to yarprobotinterface after a restart due to fatal error.

The code was verified with a test, whose basic details we report in the following in order to show the format of the new log.
Inside the thread tINIT I have forced a divide by zero operation which triggers a fatal error.
    eOerrmanDescriptor_t errdes = {0};
    errdes.code             = eoerror_code_get(eoerror_category_System, eoerror_value_SYS_runninghappily);
    errdes.sourcedevice     = eo_errman_sourcedevice_localboard;
    errdes.sourceaddress    = 0;
    errdes.par16            = 0x0000;
    errdes.par64            = 0;
    eo_errman_Error(eo_errman_GetHandle(), eo_errortype_info, NULL, s_eobj_ownname, &errdes);     
    
#if 1    
    // test the EOtheFatalError
    volatile uint32_t value = 32;
    volatile uint32_t divider = 0;
    volatile uint32_t result = 0;
    value++;
    result = value / divider;    
#endif
In this case, the diagnostics which is sent to yarprobotinterface tells:
...INFO = RESTARTED after FATAL error
...DEBUG: tag00. INFO = @ 12636 ms
...DEBUG: tag00. INFO = handler hw_UsageFault, code 0x64
...DEBUG: tag00. INFO = type see TBL
...DEBUG: tag00. INFO = ipsr 6, tid 2
...DEBUG: tag00. INFO = MORE INFO
...DEBUG: tag00. INFO = ICSR = 0x00000806 SHCSR = 0x00070008
...DEBUG: tag00. INFO = CFSR = 0x02000000 HFSR = 0x00000000
...DEBUG: tag00. INFO = DFSR = 0x00000000 MMFAR = 0xe000ed34
...DEBUG: tag00. INFO = BFAR = 0xe000ed38 AFSR = 0x00000000
...DEBUG: tag00. INFO = r0 = 0x00000021 r1 = 0x00000000
...DEBUG: tag00. INFO = r2 = 0x000000fe r3 = 0x00000000
...DEBUG: tag00. INFO = r12 = 0x08059725 lr = 0x08055be5
...DEBUG: tag00. INFO = pc = 0x08036fe8 psr = 0x01000000
...DEBUG: tag00. INFO = TM0 = 0x00000044 TM1 = 0x20007038
...DEBUG: tag00. INFO = TM2 = 0x20007054 TM3 = 0x00000000
...DEBUG: tag00. INFO = TM4 = 0x00000000 TM5 = 0x00000003
...DEBUG: tag00. INFO = TM6 = 0x00000000 TM7 = 0x00000000
...DEBUG: tag00. INFO = RT0 = 0x00000005 RT1 = 0x00000002
...DEBUG: tag00. INFO = RT2 = 0x20006e80 RT3 = 0x00000000
...DEBUG: tag00. INFO = RT4 = 0x20007980 RT5 = 0x00000056
...DEBUG: tag00. INFO = RT6 = 0x20007830 RT7 = 0x00000000

Listing.  Diagnostics sent with a fatal error caused by a divide by zero operation.
Its interpretation is that there was a usage fault due to what described in register CFSR. In particular the bit CFSR.UFSR.DIVBYZERO is set so we have confirmation that it is a division by zero. The offending instruction is at address code pc = 0x08036fe8 which is inside eo_services_Initialise(). See pictures.


Further tests were done on a dedicated setup where yarprobotinterface successfully run a motor.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,210,2021-10-25T07:25:20Z,2021-10-25T08:59:04Z,2022-01-11T09:41:30Z,MERGED,True,1310809,1160,760,https://github.com/marcoaccame,Basic support for board amc,5,[],https://github.com/robotology/icub-firmware/pull/210,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/210,"This PR adds support for the amc board. This board is the new generation of the ETH boards the likes of ems, mc4plus and mc2plus.

Figure. The amc board used for the tests.
It has the following main features:

it is a dual core CM7 and CM4,
it has a ETH connection through a three port fully managed ETH switch (one port to MII, the other two for external connection) whose registers are accessible via SPI,
it has two CAN buses
it has a motor driver the likes of the amcbldc which can control medium power motors,
and many other features

This PR adds support to the core set of features of the amc and in particular:

adds a stm32hal library for the CM7 core which is able to run a range of basic applications
provides a set of basic applications which can:

validate the behaviour of the board w/ respect to the embot objects which we use develop our typical application (RTOS environment, LED blinked, print on ITM port, ...),
validate the porting of the UDP stack from the stm32h745disco development board to the amc
validate the ETH diagnostic to be read via SPI from the ETH switch.



In order to validate the porting of the UDP stack, one can use the applications basicping, udpdemobasic and udpdemoipnet which already work for the board stm32h745disco which has the same CM7 core and ETH MAC but different PHY.
When the application udpdemoipnet works, we shall be able to port / testing on the amc the applications which have UDP communication w/  FirmwareUpdater and w/ yarprobotinterface.
In order to validate the ETH diagnostics, one can use the main thread of application embot-os or add a further thread to application udpdemobasic which periodically queries the ETH switch over SPI and prints results w/ embot::core::print() over ITM.
When the ETH diagnostics is ready, we shall be able to add to the amc's application an object the likes of EOtheETHmonitor on the ems which can monitor things such as CRC errors and link up / down.","This PR adds support for the amc board. This board is the new generation of the ETH boards the likes of ems, mc4plus and mc2plus.

Figure. The amc board used for the tests.
It has the following main features:

it is a dual core CM7 and CM4,
it has a ETH connection through a three port fully managed ETH switch (one port to MII, the other two for external connection) whose registers are accessible via SPI,
it has two CAN buses
it has a motor driver the likes of the amcbldc which can control medium power motors,
and many other features

This PR adds support to the core set of features of the amc and in particular:

adds a stm32hal library for the CM7 core which is able to run a range of basic applications
provides a set of basic applications which can:

validate the behaviour of the board w/ respect to the embot objects which we use develop our typical application (RTOS environment, LED blinked, print on ITM port, ...),
validate the porting of the UDP stack from the stm32h745disco development board to the amc
validate the ETH diagnostic to be read via SPI from the ETH switch.



In order to validate the porting of the UDP stack, one can use the applications basicping, udpdemobasic and udpdemoipnet which already work for the board stm32h745disco which has the same CM7 core and ETH MAC but different PHY.
When the application udpdemoipnet works, we shall be able to port / testing on the amc the applications which have UDP communication w/  FirmwareUpdater and w/ yarprobotinterface.
In order to validate the ETH diagnostics, one can use the main thread of application embot-os or add a further thread to application udpdemobasic which periodically queries the ETH switch over SPI and prints results w/ embot::core::print() over ITM.
When the ETH diagnostics is ready, we shall be able to add to the amc's application an object the likes of EOtheETHmonitor on the ems which can monitor things such as CRC errors and link up / down.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,211,2021-10-25T19:03:10Z,2021-10-25T19:03:45Z,2022-01-11T09:41:31Z,MERGED,True,84810,4279,309,https://github.com/marcoaccame,Update of cmsisos2,2,[],https://github.com/robotology/icub-firmware/pull/211,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/211,"This PR updates the cmsisos2 library to contain the latest stable version of the RTOS2 code from https://github.com/ARM-software/CMSIS_5 tagged version 5.8.0
This new version of the cmsisos2 has been tested on the applications of the amc board and works fine.","This PR updates the cmsisos2 library to contain the latest stable version of the RTOS2 code from https://github.com/ARM-software/CMSIS_5 tagged version 5.8.0
This new version of the cmsisos2 has been tested on the applications of the amc board and works fine.",True,{'THUMBS_UP': ['https://github.com/traversaro']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,213,2021-11-03T13:45:41Z,2021-11-04T07:14:35Z,2022-01-11T09:41:32Z,MERGED,True,123,9,9,https://github.com/marcoaccame,More RTOS trace for the mc4plus board,2,[],https://github.com/robotology/icub-firmware/pull/213,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/213,"This PR builds up on the results logged with the mc4plus application generated by a former PR and adds further trace information for the RTOS according to what the analysis of the log has shown (see here).
In particular in here we trace the execution of the function osal_messagequeue_getquick().
We have added for this purpose 16 more variables in which:

OS00 contains a value which show the progress of execution,
OS01 to OS15 contain snapshots of the variables.

A companion PR is being produced in icub-firmware-build for a new binary of the mc4plus.
Tests on a dedicated setup have validate the binary of the mc4plus generated by this PR so we can safely merge this code and associated PR on icub-firmware-build.","This PR builds up on the results logged with the mc4plus application generated by a former PR and adds further trace information for the RTOS according to what the analysis of the log has shown (see here).
In particular in here we trace the execution of the function osal_messagequeue_getquick().
We have added for this purpose 16 more variables in which:

OS00 contains a value which show the progress of execution,
OS01 to OS15 contain snapshots of the variables.

A companion PR is being produced in icub-firmware-build for a new binary of the mc4plus.
Tests on a dedicated setup have validate the binary of the mc4plus generated by this PR so we can safely merge this code and associated PR on icub-firmware-build.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/214,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/214#issuecomment-968882205,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","@sgiraz
This is a super big PR, could you please squash it into a single commit and rebase on the latest robotology@devel?
This way, we could prevent possible merging mistakes.",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/pattacini,3,https://github.com/robotology/icub-firmware/pull/214#issuecomment-968899533,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","We have seen that the fork history is too wild so that we're forced to make use of the Squash and merge button at merge time.
cc @marcoaccame",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/marcoaccame,4,https://github.com/robotology/icub-firmware/pull/214#issuecomment-969030758,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","@sgiraz:
I've just begun to look at this PR. I will come back to you later tomorrow maybe w/ some questions / changes / comments.
You also wrote:

We have to check if the new FW works also on EMS boards.

Let me also verify if we can do this check together, so we can have a solution which is guaranteed to work on all ETH boards.",True,"{'THUMBS_UP': ['https://github.com/sgiraz', 'https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/marcoaccame,5,https://github.com/robotology/icub-firmware/pull/214#issuecomment-969997442,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","Hi @sgiraz, now that the dual PR in icub-firmware-shared  is merged, I am going to work a bit on this one. Stay tuned.",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/sgiraz']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/marcoaccame,6,https://github.com/robotology/icub-firmware/pull/214#issuecomment-970342270,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","together w/ @sgiraz we rebased the sgiraz:devel fork vs robotology:devel and fixed some conflicts.
we still need to:

update application versions of ems, mc4plus, mc2plus which use the recompiled hal library w/ support to aea3,
perform some more checks / tests

and finally we can merge w/ Squash & Merge option",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,214,2021-11-09T17:02:05Z,2021-11-24T11:23:49Z,2021-11-24T11:23:49Z,MERGED,True,447,126,32,https://github.com/sgiraz,Add integration for AEA3 encoder,38,['enhancement'],https://github.com/robotology/icub-firmware/pull/214,https://github.com/marcoaccame,7,https://github.com/robotology/icub-firmware/pull/214#issuecomment-977781189,"This PR contains the new interfaces to interact with the new AEA3 encoder.
Why we should use AEA3 encoders

The new AEA3 encoders have a resolution of 14 bits, two more than the older AEA2.
Comparing the AEA2-datasheet and AEA3-datasheet, the last one results 88% less noisy.
Its physical form factor is very similar to the AEA2, which results in a back-compatible mechanical assembly.

What we need to know before using the new FW ()
During the integration of the new features, we spotted a critical HW issue that caused many warnings related to a spike detection in the yarprobotinterface.
After a long inspection, this problem has been solved with a temporary HW solution applied on a single mc4plus.
Once the solution will be confirmed, all the other boards will be updated as well.
Note: The new FW has been tested successfully on both AEA2 and AEA3 encoders. So it is back-compatible with the older encoders as well.
The following tests have been performed on an ad-hoc designed setup:

test-pwm-noclose: use yarprobotinterface and yarpmotorgui to control the motor in PWM mode at different duty cycle values changing the direction alternately
log-joint-pos: a yarp application that moves the joint in position control mode, providing specific positions and logging the feedback from the encoder.

The result of the last test is reported below:


















Other tests have been performed either as a variant of those above or using the yarpmotorgui manually.
Note for FW developers

Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.

Dependencies
This PR is linked with a PR on icub-firmware-shared and with a PR on icub-firmware-build.
Tests
We (@sgiraz and @marcoaccame) performed exhaustive tests of this code both on dedicated setups, on iCubGenova02 and on iCubErzelli02 (courtesy of @Nicogene). After such tests we are confident that the code of this PR and the associated binaries can be merged.
NOTE
Since there are no bits-state and no zero-padded bits guarantee, using AEA3 in SSI mode we aren't able to check the validity of the reading as we made for AEA2.
[@marcoaccame adds:] As a result of that, the function hal_spiencoder_get_value2() always returns hal_res_OK even if there is no encoder attached. This issue is to be addressed by a further PR.","@sgiraz and I need to update application versions and do some extra checks / tests.

After the above change request, @sgiraz and I:

rebased vs latest devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on ems and mc4plus and on robots iCubGenova02 and iCubErzelli02;

Now the PR can be merged",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,215,2021-11-10T17:01:53Z,2021-11-15T09:39:10Z,2021-11-15T09:39:10Z,MERGED,True,59568,0,73,https://github.com/MrAndrea,bmon firmware added,1,[],https://github.com/robotology/icub-firmware/pull/215,https://github.com/MrAndrea,1,https://github.com/robotology/icub-firmware/pull/215,"This PR to add the BMON electronic board firmware in the icub-firmware repository.
The BMON board is the small board mounted on the iCub 2.5 battery; it has 4 LEDs and it communicates with the BCB board through I2C bus; it embeds a Microchip PIC16F1824 microcontroller. I (@MrAndrea ) wrote the firmware many years ago. It was inside the electronics repo and it is worth to move it in here.","This PR to add the BMON electronic board firmware in the icub-firmware repository.
The BMON board is the small board mounted on the iCub 2.5 battery; it has 4 LEDs and it communicates with the BCB board through I2C bus; it embeds a Microchip PIC16F1824 microcontroller. I (@MrAndrea ) wrote the firmware many years ago. It was inside the electronics repo and it is worth to move it in here.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,215,2021-11-10T17:01:53Z,2021-11-15T09:39:10Z,2021-11-15T09:39:10Z,MERGED,True,59568,0,73,https://github.com/MrAndrea,bmon firmware added,1,[],https://github.com/robotology/icub-firmware/pull/215,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/215#issuecomment-968687628,"This PR to add the BMON electronic board firmware in the icub-firmware repository.
The BMON board is the small board mounted on the iCub 2.5 battery; it has 4 LEDs and it communicates with the BCB board through I2C bus; it embeds a Microchip PIC16F1824 microcontroller. I (@MrAndrea ) wrote the firmware many years ago. It was inside the electronics repo and it is worth to move it in here.","Hi @MrAndrea, it is better to do the PR vs the devel branch. At end of November it will be in master anyway because we are planning a new release.
I will do the change from master to devel myself.",True,{'THUMBS_UP': ['https://github.com/MrAndrea']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,215,2021-11-10T17:01:53Z,2021-11-15T09:39:10Z,2021-11-15T09:39:10Z,MERGED,True,59568,0,73,https://github.com/MrAndrea,bmon firmware added,1,[],https://github.com/robotology/icub-firmware/pull/215,https://github.com/MrAndrea,3,https://github.com/robotology/icub-firmware/pull/215#issuecomment-968699892,"This PR to add the BMON electronic board firmware in the icub-firmware repository.
The BMON board is the small board mounted on the iCub 2.5 battery; it has 4 LEDs and it communicates with the BCB board through I2C bus; it embeds a Microchip PIC16F1824 microcontroller. I (@MrAndrea ) wrote the firmware many years ago. It was inside the electronics repo and it is worth to move it in here.","Hi @MrAndrea, it is better to do the PR vs the devel branch. At end of November it will be in master anyway because we are planning a new release.
I will do the change from master to devel myself.

Ok, thank you @marcoaccame.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,216,2021-11-11T15:47:29Z,2021-11-11T15:56:25Z,2022-01-11T09:41:33Z,MERGED,True,18,17,5,https://github.com/marcoaccame,Increased stack in mc4plus ,1,[],https://github.com/robotology/icub-firmware/pull/216,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/216,"Following my comment in here, the PR adds:

3K more stack to IRQ handlers
print of address of the used stack in diagnostics.","Following my comment in here, the PR adds:

3K more stack to IRQ handlers
print of address of the used stack in diagnostics.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,217,2021-11-12T09:32:32Z,2021-11-15T15:11:43Z,2021-11-15T15:11:43Z,MERGED,True,29,5,3,https://github.com/ale-git,No nonius management of AMO sensors,2,[],https://github.com/robotology/icub-firmware/pull/217,https://github.com/ale-git,1,https://github.com/robotology/icub-firmware/pull/217,"Now, AMO sensors can be read as multi-sector (64 or 32) 14-bit resolution encoders (20 or 19-bit resolution total).
The calibration is hard-stop (type 10) as in R1 wrist pronosupination.","Now, AMO sensors can be read as multi-sector (64 or 32) 14-bit resolution encoders (20 or 19-bit resolution total).
The calibration is hard-stop (type 10) as in R1 wrist pronosupination.",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,217,2021-11-12T09:32:32Z,2021-11-15T15:11:43Z,2021-11-15T15:11:43Z,MERGED,True,29,5,3,https://github.com/ale-git,No nonius management of AMO sensors,2,[],https://github.com/robotology/icub-firmware/pull/217,https://github.com/ale-git,2,https://github.com/robotology/icub-firmware/pull/217#issuecomment-968876901,"Now, AMO sensors can be read as multi-sector (64 or 32) 14-bit resolution encoders (20 or 19-bit resolution total).
The calibration is hard-stop (type 10) as in R1 wrist pronosupination.","Hi @marcoaccame, yes, it is fully back compatible with present management of AMO and AEA boards used as absolute encoders with calibration type 12 and GearboxE2J = 1 parameter. It only affects the EMS unless we have AMO boards connected with MC4+ board (we have no one at present).",True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/marcoaccame']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,217,2021-11-12T09:32:32Z,2021-11-15T15:11:43Z,2021-11-15T15:11:43Z,MERGED,True,29,5,3,https://github.com/ale-git,No nonius management of AMO sensors,2,[],https://github.com/robotology/icub-firmware/pull/217,https://github.com/ale-git,3,https://github.com/robotology/icub-firmware/pull/217#issuecomment-968879580,"Now, AMO sensors can be read as multi-sector (64 or 32) 14-bit resolution encoders (20 or 19-bit resolution total).
The calibration is hard-stop (type 10) as in R1 wrist pronosupination.","But, in case of AMO connected to MC4+ boards it should be compatible as well.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,218,2021-11-17T12:59:52Z,2021-11-17T13:07:28Z,2021-11-17T13:07:29Z,MERGED,True,7,5,2,https://github.com/marcoaccame,Board mc4plus: different application versions for the standard and trace-RTOS versions ,1,[],https://github.com/robotology/icub-firmware/pull/218,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/218,"This PR allows to differentiate the two versions of binaries for the mc4plus: the one dedicated to trace the RTOS execution in case of fatal error uses version 103.xx and the traditional one 3.xx.
Both versions use now 11K of stack size.
The associated PR in  icub-firmware-build is robotology/icub-firmware-build#41 which produces the binaries, versions 103.42 and 3.42.
Both binaries have been validated by running yarprobotinterface on a dedicated setup w/ an AEA2 and a DC motor.","This PR allows to differentiate the two versions of binaries for the mc4plus: the one dedicated to trace the RTOS execution in case of fatal error uses version 103.xx and the traditional one 3.xx.
Both versions use now 11K of stack size.
The associated PR in  icub-firmware-build is robotology/icub-firmware-build#41 which produces the binaries, versions 103.42 and 3.42.
Both binaries have been validated by running yarprobotinterface on a dedicated setup w/ an AEA2 and a DC motor.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,219,2021-11-23T13:25:01Z,2021-11-23T14:40:35Z,2022-01-11T09:41:35Z,MERGED,True,83,42,10,https://github.com/marcoaccame,Fixed HAL priorities,2,[],https://github.com/robotology/icub-firmware/pull/219,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/219,"This PR adjusts the way the HAL sets the priorities in the NVIC so that it is compliant to its use w/ an RTOS.
This PR is linked w/ this issue.
So why this PR?
In an attempt to solve the fatal error happening in the above issue I found out that the priorities of some IRQ handlers used in some devices of the DC motor control of the mc4plus violates the original design of the HAL. In particular, they change the priority grouping of the NVIC and use an invalid priority which conflicts w/ what is use by the RTOS.
In here is a clarification comment I have added to the code of HAL:
// marco.accame on 23 nov 2021: _HAL_TAG_USE_OF_NVIC_PRIORITIES 
// the HAL system uses NVIC_PriorityGroup_4 so that we have 16 pre-emption priorities and 0 subpriorities
// this is done by design: 
// - we set NVIC_PriorityGroup_4 in here (and it is forbidden to change it afterwards!!)
// - we defined hal_interrupt_priority_t to contain values only from 0 to 15.
// the RTOS uses the lowest two priorities which it finds on the system, so in here priorities
// 14 and 15 are reserved to the RTOS which assigns 15 to SysTick_Handler() and PendSV_Handler() 
// and 14 to SVC_Handler().
// it is very important never and ever change priority group expecially after the start of the RTOS because
// that may cause crashes as described in https://developer.arm.com/documentation/ka003146/latest
// why is that? because a change in priority grouping can change the correct rules of preemption of the
// SVC, PendSV and SysTick among themselves and vs other IRQs and there can be a wrong assignment of the 
// thread stack in the context switch done by PendSV and/or SysTick. See for that a note by the guru  Joseph Yiu:
// https://community.arm.com/support-forums/f/architectures-and-processors-forum/9485/cortex-m-rtos-related-exceptions-and-concepts?pifragment-22341=104        
// 
// so in HAL we must use only priorities in range [0, 13].

Now, I believe that this correction is required.
I also hope that it can solve the sporadic fatal error for reason which I wrote in here.
There is an associated PR for the binaries in here.
The tests done on a dedicated setup have shown that the mc4plus can effectively move a motor w/ yarprobotinterface, so we can safely merge both PRs for use in the robots.","This PR adjusts the way the HAL sets the priorities in the NVIC so that it is compliant to its use w/ an RTOS.
This PR is linked w/ this issue.
So why this PR?
In an attempt to solve the fatal error happening in the above issue I found out that the priorities of some IRQ handlers used in some devices of the DC motor control of the mc4plus violates the original design of the HAL. In particular, they change the priority grouping of the NVIC and use an invalid priority which conflicts w/ what is use by the RTOS.
In here is a clarification comment I have added to the code of HAL:
// marco.accame on 23 nov 2021: _HAL_TAG_USE_OF_NVIC_PRIORITIES 
// the HAL system uses NVIC_PriorityGroup_4 so that we have 16 pre-emption priorities and 0 subpriorities
// this is done by design: 
// - we set NVIC_PriorityGroup_4 in here (and it is forbidden to change it afterwards!!)
// - we defined hal_interrupt_priority_t to contain values only from 0 to 15.
// the RTOS uses the lowest two priorities which it finds on the system, so in here priorities
// 14 and 15 are reserved to the RTOS which assigns 15 to SysTick_Handler() and PendSV_Handler() 
// and 14 to SVC_Handler().
// it is very important never and ever change priority group expecially after the start of the RTOS because
// that may cause crashes as described in https://developer.arm.com/documentation/ka003146/latest
// why is that? because a change in priority grouping can change the correct rules of preemption of the
// SVC, PendSV and SysTick among themselves and vs other IRQs and there can be a wrong assignment of the 
// thread stack in the context switch done by PendSV and/or SysTick. See for that a note by the guru  Joseph Yiu:
// https://community.arm.com/support-forums/f/architectures-and-processors-forum/9485/cortex-m-rtos-related-exceptions-and-concepts?pifragment-22341=104        
// 
// so in HAL we must use only priorities in range [0, 13].

Now, I believe that this correction is required.
I also hope that it can solve the sporadic fatal error for reason which I wrote in here.
There is an associated PR for the binaries in here.
The tests done on a dedicated setup have shown that the mc4plus can effectively move a motor w/ yarprobotinterface, so we can safely merge both PRs for use in the robots.",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,220,2021-11-24T13:55:56Z,2021-11-25T09:10:48Z,2022-01-11T09:41:36Z,MERGED,True,16345,774,33,https://github.com/marcoaccame,OSAL over cmsisos2 for ETH boards - step 1,9,[],https://github.com/robotology/icub-firmware/pull/220,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/220,"This PR is a first step vs the use of a more modern RTOS in our ETH boards such as ems, mc4plus, mc2plus.
Introduction
Our ETH boards use RTOS services w/ an abstraction layer called OSAL (OS Abstraction Layer). This SW design solution allows to maintain a consistent set of APIs with the upper layers w/out being tied to those of a specific RTOS. That was important because there were dozens of RTOS and all with different APIs. With OSAL we can use almost any underlying RTOS, as long as we provide a suitable implementation.
At the time of the design of our ETH boards the choice was to use RTX which provided good performances and was available in source code w/out license.



Figure. The ETH applications are built upon the the services of embOBJ (tasks, timer manager, IP network etc) which use OS services through the HAL library which is implemented with RTX v4.
This RTOS has served well over the years but it is now not maintained anymore because a new more modern version is available from ARM in here.
We already use this new RTOS version for some of our boards such as mtb4, strain2 etc as an alternative to OSAL and it is the chosen design for our latest boards such as pmc, amcbldc, amc.
For these latest boards we use RTOS services through a C++ thin layer called embot::os::rtos which uses directly the cmsisos2 library (aka a compiled version of the more modern RTOS version from ARM w/ very few modifications such as easier configuration in runtime and thread-safe memory management).



Figure. The latest boards use a C++ namespaces which gets RTOS services through a layer called embot::os::rtos which allows to cmsisos2 (or OSAL or else) underneath.
Update the ETH boards to use the latest RTOS
The idea for the legacy ETH boards was to continue using the traditional OSAL over RTX-4. However, recent problems probably due to the OSAL (see for instance #209, #213 etc.) has raised the idea to have an RTOS upgrade also for the ETH boards.
Our goal is to use the API of OSAL and to provide a new implementation for it which uses the latest RTOS.
The design of the new OSAL
The ETH boards can still use the OSAL API as long as its internal implementation uses cmsisos2. The use through embot::os::rtos can help a lot. This PR adds a new OSAL library based on these two modules.



Figure. The design of the new OSAL over cmsisos2 allows to reuse all the legacy code of the ETH boards and reuse code which we have been testing for long time now.
The test of the new OSAL
The new OSAL runs on the ems and is able to execute a number of RTOS primitives such as some type of threads (periodic, event-based, message-based) and also the basic services of embOBJ such as the timer manager, callback manager, the LED pulser.
The full execution of the ems application is still under test and will be reserved for a successive step.
The impact of this PR on legacy code
It is very limited. The ETH boards running on the robot are not affected. I had to change some code parts in embot::os::rtos and in embot::os::Thread to make them more versatile for their use. These changes mildly touch the code of some of the latest boards such as strain2 and mtb4  but the changes have been carefully tested, so there is no harm.
What's next
I will test all the application code inside an ETH board, such as IP services offered by EOMtheIPnet (see in here a brief of it behaviour), the control loop, diagnostics, etc.","This PR is a first step vs the use of a more modern RTOS in our ETH boards such as ems, mc4plus, mc2plus.
Introduction
Our ETH boards use RTOS services w/ an abstraction layer called OSAL (OS Abstraction Layer). This SW design solution allows to maintain a consistent set of APIs with the upper layers w/out being tied to those of a specific RTOS. That was important because there were dozens of RTOS and all with different APIs. With OSAL we can use almost any underlying RTOS, as long as we provide a suitable implementation.
At the time of the design of our ETH boards the choice was to use RTX which provided good performances and was available in source code w/out license.



Figure. The ETH applications are built upon the the services of embOBJ (tasks, timer manager, IP network etc) which use OS services through the HAL library which is implemented with RTX v4.
This RTOS has served well over the years but it is now not maintained anymore because a new more modern version is available from ARM in here.
We already use this new RTOS version for some of our boards such as mtb4, strain2 etc as an alternative to OSAL and it is the chosen design for our latest boards such as pmc, amcbldc, amc.
For these latest boards we use RTOS services through a C++ thin layer called embot::os::rtos which uses directly the cmsisos2 library (aka a compiled version of the more modern RTOS version from ARM w/ very few modifications such as easier configuration in runtime and thread-safe memory management).



Figure. The latest boards use a C++ namespaces which gets RTOS services through a layer called embot::os::rtos which allows to cmsisos2 (or OSAL or else) underneath.
Update the ETH boards to use the latest RTOS
The idea for the legacy ETH boards was to continue using the traditional OSAL over RTX-4. However, recent problems probably due to the OSAL (see for instance #209, #213 etc.) has raised the idea to have an RTOS upgrade also for the ETH boards.
Our goal is to use the API of OSAL and to provide a new implementation for it which uses the latest RTOS.
The design of the new OSAL
The ETH boards can still use the OSAL API as long as its internal implementation uses cmsisos2. The use through embot::os::rtos can help a lot. This PR adds a new OSAL library based on these two modules.



Figure. The design of the new OSAL over cmsisos2 allows to reuse all the legacy code of the ETH boards and reuse code which we have been testing for long time now.
The test of the new OSAL
The new OSAL runs on the ems and is able to execute a number of RTOS primitives such as some type of threads (periodic, event-based, message-based) and also the basic services of embOBJ such as the timer manager, callback manager, the LED pulser.
The full execution of the ems application is still under test and will be reserved for a successive step.
The impact of this PR on legacy code
It is very limited. The ETH boards running on the robot are not affected. I had to change some code parts in embot::os::rtos and in embot::os::Thread to make them more versatile for their use. These changes mildly touch the code of some of the latest boards such as strain2 and mtb4  but the changes have been carefully tested, so there is no harm.
What's next
I will test all the application code inside an ETH board, such as IP services offered by EOMtheIPnet (see in here a brief of it behaviour), the control loop, diagnostics, etc.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,221,2021-12-02T11:42:31Z,2021-12-02T13:02:15Z,2022-01-11T09:43:39Z,MERGED,True,3,3,1,https://github.com/marcoaccame,"Fix of bootloader of mtb4 (and strain2, rfe, psc)",1,[],https://github.com/robotology/icub-firmware/pull/221,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/221,"This PR fixed the issue #202 by correcting how the memory address is mapped into pages of the FLASH and vice-versa. The bug was introduced when we added support for page of FLASH different from 2KB, as for the pmc and amcbldc boards which use 4BB.
The bug affected only the bootloaders and not the application. Moreover, the bootloader in icub-firmware-build have always worked because were produced w/ source code which did not have the bug, so new binary is required.
Tests w/ latest build of icub-main in devel have shown that the boards mtb4 and rfe successfully update the application both when the start from the bootloader and the old application.
So, we can safely merge the change.","This PR fixed the issue #202 by correcting how the memory address is mapped into pages of the FLASH and vice-versa. The bug was introduced when we added support for page of FLASH different from 2KB, as for the pmc and amcbldc boards which use 4BB.
The bug affected only the bootloaders and not the application. Moreover, the bootloader in icub-firmware-build have always worked because were produced w/ source code which did not have the bug, so new binary is required.
Tests w/ latest build of icub-main in devel have shown that the boards mtb4 and rfe successfully update the application both when the start from the bootloader and the old application.
So, we can safely merge the change.",True,{'THUMBS_UP': ['https://github.com/maggia80']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,222,2021-12-02T17:47:32Z,2021-12-03T12:46:13Z,2022-01-11T09:42:13Z,MERGED,True,26,13,3,https://github.com/marcoaccame,Fixed bootloader for boards amcbldc and pmc,1,[],https://github.com/robotology/icub-firmware/pull/222,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/222,"This PR allows correct operativity of the board amcbldc and pmc w/ FirmwareUpdater.
This PR is linked w/ two other PRs: one on icub-firmware-shared which gives support for the amcbldc  and one in icub-main which allows the FirmwareUpdater to operate correctly with pmc and amcbldc.
The boards amcbldc and pmc need longer time for the erase of the FLASH which joined w/ the timing used by the canloader library in icub-main and the impossibility to process CAN frames during the erase operation cause a failure in updating the binaries via CAN.
The solution is to be solved jointly:

in icub-firmware: we anticipate the erase FLASH operation at rx of CAN message BOOTLOADER:board;
in icub-main: we wait for a slightly longer time after we send the BOOTLOADER:board CAN message.

Tests have shown that this solution solves the problem for these two boards and is also compatible w/ legacy CAN boards.














Figure. Updating the amcbldc and the strain2 boards.","This PR allows correct operativity of the board amcbldc and pmc w/ FirmwareUpdater.
This PR is linked w/ two other PRs: one on icub-firmware-shared which gives support for the amcbldc  and one in icub-main which allows the FirmwareUpdater to operate correctly with pmc and amcbldc.
The boards amcbldc and pmc need longer time for the erase of the FLASH which joined w/ the timing used by the canloader library in icub-main and the impossibility to process CAN frames during the erase operation cause a failure in updating the binaries via CAN.
The solution is to be solved jointly:

in icub-firmware: we anticipate the erase FLASH operation at rx of CAN message BOOTLOADER:board;
in icub-main: we wait for a slightly longer time after we send the BOOTLOADER:board CAN message.

Tests have shown that this solution solves the problem for these two boards and is also compatible w/ legacy CAN boards.














Figure. Updating the amcbldc and the strain2 boards.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,223,2021-12-06T11:39:33Z,2021-12-06T12:53:20Z,2021-12-06T12:53:21Z,MERGED,True,5621,3414,67,https://github.com/sgiraz,AMC_BLDC: Alignment with the last changes made on master branch of the architectural model,3,[],https://github.com/robotology/icub-firmware/pull/223,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/223,"This PR contains 3 main updates:

The code generated from Simulink is now aligned with the last changes made in the master branch of the Simulink architectural model. It includes a block called ESTIMATION_VELOCITY.
The MBDagent (part of icub-firmware\emBODY\eBcode\arch-arm\board\amcbldc\application04 project) now uses the I/F of the generated code.
The configurations of the low-level control system have been updated in order to manage the Kollmorgen BLDC motor used on the new LEGO-setup. In particular, the critical changes are in: pwm.c and encoder.c.

Finally, the project files have been updated in order including 2 new groups:

mdb::estimator for the new ESTIMATION_VELOCITY block.
mbd::amc-bldc for the definition of CAN_ID_AMC and CAN_ANGLE_DEG2ICUB. The sources included in this group are part of the generated code and were previously missing.
all other groups have been updated accordingly with the changes in the architectural model.

Note:
There are some things to adjust. In particular:

The Supervisor does not change control mode when a set-control-mode command is received from CAN. Hence, now the motor-control-current mode is forced manually inside the MBDaget.
The configurations for the control of the BLDC motor need some fine-tuning.","This PR contains 3 main updates:

The code generated from Simulink is now aligned with the last changes made in the master branch of the Simulink architectural model. It includes a block called ESTIMATION_VELOCITY.
The MBDagent (part of icub-firmware\emBODY\eBcode\arch-arm\board\amcbldc\application04 project) now uses the I/F of the generated code.
The configurations of the low-level control system have been updated in order to manage the Kollmorgen BLDC motor used on the new LEGO-setup. In particular, the critical changes are in: pwm.c and encoder.c.

Finally, the project files have been updated in order including 2 new groups:

mdb::estimator for the new ESTIMATION_VELOCITY block.
mbd::amc-bldc for the definition of CAN_ID_AMC and CAN_ANGLE_DEG2ICUB. The sources included in this group are part of the generated code and were previously missing.
all other groups have been updated accordingly with the changes in the architectural model.

Note:
There are some things to adjust. In particular:

The Supervisor does not change control mode when a set-control-mode command is received from CAN. Hence, now the motor-control-current mode is forced manually inside the MBDaget.
The configurations for the control of the BLDC motor need some fine-tuning.",True,"{'HOORAY': ['https://github.com/pattacini'], 'ROCKET': ['https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,224,2021-12-07T15:28:37Z,2021-12-15T15:20:33Z,2021-12-15T15:20:33Z,MERGED,True,86,16,8,https://github.com/mfussi66,Add latest fault state to motor status data structure ,11,[],https://github.com/robotology/icub-firmware/pull/224,https://github.com/mfussi66,1,https://github.com/robotology/icub-firmware/pull/224,"This PR aims to complement the work done to address: robotology/community#561 , in which the feature request involved communicating the latest fault to the yarpmotorgui.
To address it, the error code is stored in the free space of the struct motor_status_t, right after the diagnostics function sends the error towards the yarplogger.
The data is retrieved by embObjMotionControl upon periodical request of the yarpmotorgui, whenever a fault is detected.
The fault states that can be communicated are the following:
  {eoerror_value_MC_motor_external_fault,  ""MC: exernal fault button pressed.""},
    {eoerror_value_MC_motor_overcurrent,     ""MC: overcurrent. The motor has been turned off to prevent it from being damaged by an impulsive spike of current. par16 = ID of joint.""},
    {eoerror_value_MC_motor_i2t_limit,       ""MC: i2t limit exceeded. The motor has been turned off to prevent it from being damaged by overheating due to a continuous high current. par16 = ID of joint.""},
    {eoerror_value_MC_motor_hallsensors,     ""MC: 2FOC hall sensors fault. Invalid sequence in motor Hall effect sensors, please check motor hall cable connections. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_invalid_prot,""MC: 2FOC CAN invalid protocol. The EMS and 2FOC firmware versions are incompatible, please update. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_generic,     ""MC: 2FOC CAN generic error. Errors happened in the CAN bus between the EMS and the 2FOC board. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_no_answer,   ""MC: 2FOC CAN no answer. The communication between the EMS and the 2FOC board has been lost for more than 50 ms. par16 = ID of joint.""},
    {eoerror_value_MC_axis_torque_sens,      ""MC: torque sensor timeout. The joint is in a compliant interaction mode or torque control mode, and data from torque sensor have been unavailable for more than 100 ms. par16 = ID of joint.""},
    {eoerror_value_MC_aea_abs_enc_invalid,   ""MC: AEA encoder invalid data. Hardware problem in the magnetic position sensor of the joint caused invalid position readings. par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_aea_abs_enc_timeout,   ""MC: AEA encoder timeout. No answer from the magnetic position sensor of the joint (cable broken?). par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_aea_abs_enc_spikes,    ""MC: AEA encoder has spikes. There is impulsive noise in the measures of the magnetic position sensor of the joint. par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_motor_qencoder_dirty,  ""MC: 2FOC quadrature encoder dirty. The number of thicks in a complete revolution of the motor was lower than expected, the optical disks need to be cleaned. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_index,  ""MC: 2FOC quadrature encoder index broken. The reference special thick was not detected during a complete revolution of the motor, please check motor encoder cables. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_phase,  ""MC: 2FOC quadrature encoder phase broken. The motor encoder is not counting even if the motor is moving, please check motor encoder cables. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_generic_error,         ""MC: generic motor error (see 64 bit mask parameter).""},
    {eoerror_value_MC_motor_wrong_state,     ""MC: 2FOC wrong state. The 2FOC motor controller is in a control state different from required by the EMS. In par64 0xF0 is the mask of requested state, 0x0F is the mask of actual state. par16 = ID of joint.""},
    {eoerror_value_MC_joint_hard_limit,      ""MC: hard limit reached. The joint position is outside its hardware boundaries. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_phase_disappeared, ""MC: qenc error has disappeared, warning counter has been reset.""}

which belong to the motion controller category.
Here below is a little demo of the yarpmotorgui displaying a hardware limit fault:

  
    
    

    144848405-89251081-02d5-4b19-8fec-f6ed8a2310ff.mp4
    
  

  

  


Related PR:
icub-firmware-shared: robotology/icub-firmware-shared#52
icub-main: icub-main: robotology/icub-main#779","This PR aims to complement the work done to address: robotology/community#561 , in which the feature request involved communicating the latest fault to the yarpmotorgui.
To address it, the error code is stored in the free space of the struct motor_status_t, right after the diagnostics function sends the error towards the yarplogger.
The data is retrieved by embObjMotionControl upon periodical request of the yarpmotorgui, whenever a fault is detected.
The fault states that can be communicated are the following:
  {eoerror_value_MC_motor_external_fault,  ""MC: exernal fault button pressed.""},
    {eoerror_value_MC_motor_overcurrent,     ""MC: overcurrent. The motor has been turned off to prevent it from being damaged by an impulsive spike of current. par16 = ID of joint.""},
    {eoerror_value_MC_motor_i2t_limit,       ""MC: i2t limit exceeded. The motor has been turned off to prevent it from being damaged by overheating due to a continuous high current. par16 = ID of joint.""},
    {eoerror_value_MC_motor_hallsensors,     ""MC: 2FOC hall sensors fault. Invalid sequence in motor Hall effect sensors, please check motor hall cable connections. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_invalid_prot,""MC: 2FOC CAN invalid protocol. The EMS and 2FOC firmware versions are incompatible, please update. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_generic,     ""MC: 2FOC CAN generic error. Errors happened in the CAN bus between the EMS and the 2FOC board. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_no_answer,   ""MC: 2FOC CAN no answer. The communication between the EMS and the 2FOC board has been lost for more than 50 ms. par16 = ID of joint.""},
    {eoerror_value_MC_axis_torque_sens,      ""MC: torque sensor timeout. The joint is in a compliant interaction mode or torque control mode, and data from torque sensor have been unavailable for more than 100 ms. par16 = ID of joint.""},
    {eoerror_value_MC_aea_abs_enc_invalid,   ""MC: AEA encoder invalid data. Hardware problem in the magnetic position sensor of the joint caused invalid position readings. par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_aea_abs_enc_timeout,   ""MC: AEA encoder timeout. No answer from the magnetic position sensor of the joint (cable broken?). par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_aea_abs_enc_spikes,    ""MC: AEA encoder has spikes. There is impulsive noise in the measures of the magnetic position sensor of the joint. par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_motor_qencoder_dirty,  ""MC: 2FOC quadrature encoder dirty. The number of thicks in a complete revolution of the motor was lower than expected, the optical disks need to be cleaned. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_index,  ""MC: 2FOC quadrature encoder index broken. The reference special thick was not detected during a complete revolution of the motor, please check motor encoder cables. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_phase,  ""MC: 2FOC quadrature encoder phase broken. The motor encoder is not counting even if the motor is moving, please check motor encoder cables. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_generic_error,         ""MC: generic motor error (see 64 bit mask parameter).""},
    {eoerror_value_MC_motor_wrong_state,     ""MC: 2FOC wrong state. The 2FOC motor controller is in a control state different from required by the EMS. In par64 0xF0 is the mask of requested state, 0x0F is the mask of actual state. par16 = ID of joint.""},
    {eoerror_value_MC_joint_hard_limit,      ""MC: hard limit reached. The joint position is outside its hardware boundaries. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_phase_disappeared, ""MC: qenc error has disappeared, warning counter has been reset.""}

which belong to the motion controller category.
Here below is a little demo of the yarpmotorgui displaying a hardware limit fault:

  
    
    

    144848405-89251081-02d5-4b19-8fec-f6ed8a2310ff.mp4
    
  

  

  


Related PR:
icub-firmware-shared: robotology/icub-firmware-shared#52
icub-main: icub-main: robotology/icub-main#779",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,224,2021-12-07T15:28:37Z,2021-12-15T15:20:33Z,2021-12-15T15:20:33Z,MERGED,True,86,16,8,https://github.com/mfussi66,Add latest fault state to motor status data structure ,11,[],https://github.com/robotology/icub-firmware/pull/224,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/224#issuecomment-994852951,"This PR aims to complement the work done to address: robotology/community#561 , in which the feature request involved communicating the latest fault to the yarpmotorgui.
To address it, the error code is stored in the free space of the struct motor_status_t, right after the diagnostics function sends the error towards the yarplogger.
The data is retrieved by embObjMotionControl upon periodical request of the yarpmotorgui, whenever a fault is detected.
The fault states that can be communicated are the following:
  {eoerror_value_MC_motor_external_fault,  ""MC: exernal fault button pressed.""},
    {eoerror_value_MC_motor_overcurrent,     ""MC: overcurrent. The motor has been turned off to prevent it from being damaged by an impulsive spike of current. par16 = ID of joint.""},
    {eoerror_value_MC_motor_i2t_limit,       ""MC: i2t limit exceeded. The motor has been turned off to prevent it from being damaged by overheating due to a continuous high current. par16 = ID of joint.""},
    {eoerror_value_MC_motor_hallsensors,     ""MC: 2FOC hall sensors fault. Invalid sequence in motor Hall effect sensors, please check motor hall cable connections. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_invalid_prot,""MC: 2FOC CAN invalid protocol. The EMS and 2FOC firmware versions are incompatible, please update. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_generic,     ""MC: 2FOC CAN generic error. Errors happened in the CAN bus between the EMS and the 2FOC board. par16 = ID of joint.""},
    {eoerror_value_MC_motor_can_no_answer,   ""MC: 2FOC CAN no answer. The communication between the EMS and the 2FOC board has been lost for more than 50 ms. par16 = ID of joint.""},
    {eoerror_value_MC_axis_torque_sens,      ""MC: torque sensor timeout. The joint is in a compliant interaction mode or torque control mode, and data from torque sensor have been unavailable for more than 100 ms. par16 = ID of joint.""},
    {eoerror_value_MC_aea_abs_enc_invalid,   ""MC: AEA encoder invalid data. Hardware problem in the magnetic position sensor of the joint caused invalid position readings. par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_aea_abs_enc_timeout,   ""MC: AEA encoder timeout. No answer from the magnetic position sensor of the joint (cable broken?). par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_aea_abs_enc_spikes,    ""MC: AEA encoder has spikes. There is impulsive noise in the measures of the magnetic position sensor of the joint. par16 = AEA port (msb) and ID of joint (lsb).""},
    {eoerror_value_MC_motor_qencoder_dirty,  ""MC: 2FOC quadrature encoder dirty. The number of thicks in a complete revolution of the motor was lower than expected, the optical disks need to be cleaned. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_index,  ""MC: 2FOC quadrature encoder index broken. The reference special thick was not detected during a complete revolution of the motor, please check motor encoder cables. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_phase,  ""MC: 2FOC quadrature encoder phase broken. The motor encoder is not counting even if the motor is moving, please check motor encoder cables. In par64 0xFF is the mask of raw encoder value. par16 = ID of joint.""},
    {eoerror_value_MC_generic_error,         ""MC: generic motor error (see 64 bit mask parameter).""},
    {eoerror_value_MC_motor_wrong_state,     ""MC: 2FOC wrong state. The 2FOC motor controller is in a control state different from required by the EMS. In par64 0xF0 is the mask of requested state, 0x0F is the mask of actual state. par16 = ID of joint.""},
    {eoerror_value_MC_joint_hard_limit,      ""MC: hard limit reached. The joint position is outside its hardware boundaries. par16 = ID of joint.""},
    {eoerror_value_MC_motor_qencoder_phase_disappeared, ""MC: qenc error has disappeared, warning counter has been reset.""}

which belong to the motion controller category.
Here below is a little demo of the yarpmotorgui displaying a hardware limit fault:

  
    
    

    144848405-89251081-02d5-4b19-8fec-f6ed8a2310ff.mp4
    
  

  

  


Related PR:
icub-firmware-shared: robotology/icub-firmware-shared#52
icub-main: icub-main: robotology/icub-main#779","Hi @mfussi66, the changes in the code seem OK.
I also know that your further tests on your setup and on iCubGenova02 were successful.
So, let me attach some results for you:

  
    
    

    testfault-2021-12-14_12.59.25.mp4
    
  

  

  


Figure. Tests on a dedicated setup which demonstrates how the yarpmotorgui prints the error code. This one has small edit which always prints the fault message for debugging purposes.

Figure. Tests on iCubGenova02: By keeping the actual robotology/devel but w/ changes in embObjMotionControl.cpp to ask the boards to broadcast the fatter eOmc_motor_status_t and not eOmc_motor_status_basic_t anymore, and w/ the new binary on the ems boards of the forearm, we have the system still working. The launch of yarprobotinterface is OK and  yarpmotorgui correctly shows the joints.",True,{'THUMBS_UP': ['https://github.com/mfussi66']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,225,2021-12-13T14:30:37Z,2021-12-15T11:57:00Z,2022-01-11T09:42:18Z,MERGED,True,227,80,10,https://github.com/marcoaccame,The mc4plus board now uses the second memory bank,4,[],https://github.com/robotology/icub-firmware/pull/225,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/225,"This PR allows the board mc4plus to use the second memory bank. The introduction of this second memory back allows to dedicate almost all the first bank of 128KB to heap so that we have less limitations in the development of new features.
The use of the second memory bank was make available for the ems and mc2plus boards in this PR but it was postponed for the mc4plus because the absanalog encoder did not read correctly.
I have solved this problem by assigning the correct memory address to the DMA operation for the ADC required by the absnalog sensor. We now use memory from the heap for that to guarantee that the DMA uses the first back and the second one is CCM (core couple memory) which does not implement DMA.
Tests on the robot iCubGenova09 with the binaries of this PR on icub-firmware-build have shown that now the correct behaviour is ensured.","This PR allows the board mc4plus to use the second memory bank. The introduction of this second memory back allows to dedicate almost all the first bank of 128KB to heap so that we have less limitations in the development of new features.
The use of the second memory bank was make available for the ems and mc2plus boards in this PR but it was postponed for the mc4plus because the absanalog encoder did not read correctly.
I have solved this problem by assigning the correct memory address to the DMA operation for the ADC required by the absnalog sensor. We now use memory from the heap for that to guarantee that the DMA uses the first back and the second one is CCM (core couple memory) which does not implement DMA.
Tests on the robot iCubGenova09 with the binaries of this PR on icub-firmware-build have shown that now the correct behaviour is ensured.",True,{'HOORAY': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,226,2021-12-15T09:29:07Z,2021-12-15T16:11:55Z,2021-12-15T16:14:41Z,MERGED,True,18653,93,74,https://github.com/sgiraz,AMC_BLDC: Alignment with the last changes on MBD,9,['enhancement'],https://github.com/robotology/icub-firmware/pull/226,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/226,"What's changed in this PR:

In application05:

embot_app_application_theMBDagent.cpp contains a cleaner code
the code generated from the MBD (master) now contains the last changes. The supervisor now changes control mode and manages/prevents HF correctly.
embot_tools has been introduced for performance analysis


In application04:

this folder contains the FW version before the refactoring of the mbd
fixed the change of the control. Now it is performed correctly by the Supervisor.



Note for application05:

In this PR, the problem of motor control is still in progress. Targets of current values greater than ~300mA will trigger the Supervisor HF-Handler. The fault triggered by the Supervisor is correct (it isn't a bug). The problem is in the control.

cc @valegagge @GrmanRodriguez @vvasco @ale-git","What's changed in this PR:

In application05:

embot_app_application_theMBDagent.cpp contains a cleaner code
the code generated from the MBD (master) now contains the last changes. The supervisor now changes control mode and manages/prevents HF correctly.
embot_tools has been introduced for performance analysis


In application04:

this folder contains the FW version before the refactoring of the mbd
fixed the change of the control. Now it is performed correctly by the Supervisor.



Note for application05:

In this PR, the problem of motor control is still in progress. Targets of current values greater than ~300mA will trigger the Supervisor HF-Handler. The fault triggered by the Supervisor is correct (it isn't a bug). The problem is in the control.

cc @valegagge @GrmanRodriguez @vvasco @ale-git",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,227,2021-12-16T11:09:20Z,2021-12-16T11:43:00Z,2022-01-11T09:42:22Z,MERGED,True,118,100,4,https://github.com/marcoaccame,Mutual exclusion in amcbldc,2,[],https://github.com/robotology/icub-firmware/pull/227,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/227,"This PR just adds a mechanism of mutual exclusion in the amcbldc board between a user thread and DMA1_Channel2_IRQHandler() which both run MBD code.
The code was successfully tested on the amcbldc board.
Moreover, this change has a local impact only on the amcbldc and hence it can be safely merged.","This PR just adds a mechanism of mutual exclusion in the amcbldc board between a user thread and DMA1_Channel2_IRQHandler() which both run MBD code.
The code was successfully tested on the amcbldc board.
Moreover, this change has a local impact only on the amcbldc and hence it can be safely merged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,227,2021-12-16T11:09:20Z,2021-12-16T11:43:00Z,2022-01-11T09:42:22Z,MERGED,True,118,100,4,https://github.com/marcoaccame,Mutual exclusion in amcbldc,2,[],https://github.com/robotology/icub-firmware/pull/227,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/227#issuecomment-995715659,"This PR just adds a mechanism of mutual exclusion in the amcbldc board between a user thread and DMA1_Channel2_IRQHandler() which both run MBD code.
The code was successfully tested on the amcbldc board.
Moreover, this change has a local impact only on the amcbldc and hence it can be safely merged.","Hi @marcoaccame
Do you think we could define the implementation of lock and unlock as inline functions to spare the context switch?

I don't think it changes much to avoid a function call @ 160 MHz on a CM4, but it is worth having the implementation. See 94761d4.",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,227,2021-12-16T11:09:20Z,2021-12-16T11:43:00Z,2022-01-11T09:42:22Z,MERGED,True,118,100,4,https://github.com/marcoaccame,Mutual exclusion in amcbldc,2,[],https://github.com/robotology/icub-firmware/pull/227,https://github.com/pattacini,3,https://github.com/robotology/icub-firmware/pull/227#issuecomment-995743221,"This PR just adds a mechanism of mutual exclusion in the amcbldc board between a user thread and DMA1_Channel2_IRQHandler() which both run MBD code.
The code was successfully tested on the amcbldc board.
Moreover, this change has a local impact only on the amcbldc and hence it can be safely merged.","Regarding RTW_MUTEX_USE_INLINE, maybe it's just for the test, but I deem it's a complication that we can spare.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,229,2021-12-20T10:55:34Z,2021-12-20T10:58:56Z,2022-01-11T09:42:23Z,MERGED,True,1406,478,33,https://github.com/marcoaccame,Cleanup of amcbldc projects,4,[],https://github.com/robotology/icub-firmware/pull/229,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/229,"This PR contains a cleanup of the amcbldc projects from application01 to application05.
These are the projects that we have prepared to test the motion control based on MBDE on the amcbldc.
The projects are developed in a evolutive way and we add more and more features as long as the development goes on.
However, in this evolution the older projects did not compile anymore and the latter two, application04 and application05, required some refactoring and also tools able to measure the execution time of the two processing loops: the FOC inner loop @ 37.5 us and the tick loop at 1 ms.
This PR contains such changes.
We have verified that the functionalities have stayed unchanged, so we can safely merge this changes.","This PR contains a cleanup of the amcbldc projects from application01 to application05.
These are the projects that we have prepared to test the motion control based on MBDE on the amcbldc.
The projects are developed in a evolutive way and we add more and more features as long as the development goes on.
However, in this evolution the older projects did not compile anymore and the latter two, application04 and application05, required some refactoring and also tools able to measure the execution time of the two processing loops: the FOC inner loop @ 37.5 us and the tick loop at 1 ms.
This PR contains such changes.
We have verified that the functionalities have stayed unchanged, so we can safely merge this changes.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,230,2021-12-20T11:43:12Z,2021-12-20T11:46:00Z,2022-01-11T09:42:26Z,MERGED,True,2,2,2,https://github.com/marcoaccame,rfe: fixed the i2c bus of the imu bosch bno055 ,1,[],https://github.com/robotology/icub-firmware/pull/230,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/230,"This PR fixes a typo on the bsp configuration of board rfe.
The i2C bus of the chip IMU BOSCH BNO055 is on embot::hw::I2C::one and not on embot::hw::I2C::two. This typo prevented teh correct initialization of the chip and the streaming of IMU data.
The correction has showed that now iCub correctly streams the IMU values. As a result of that I have updated the application version to be 1.2.2 and produced the associated PR on robotology/icub-firmware-build#46","This PR fixes a typo on the bsp configuration of board rfe.
The i2C bus of the chip IMU BOSCH BNO055 is on embot::hw::I2C::one and not on embot::hw::I2C::two. This typo prevented teh correct initialization of the chip and the streaming of IMU data.
The correction has showed that now iCub correctly streams the IMU values. As a result of that I have updated the application version to be 1.2.2 and produced the associated PR on robotology/icub-firmware-build#46",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,231,2021-12-21T15:24:27Z,2021-12-21T15:26:38Z,2021-12-21T15:26:38Z,MERGED,True,361,171,7,https://github.com/marcoaccame,Calibration support for the FAP boards,1,[],https://github.com/robotology/icub-firmware/pull/231,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/231,"This PR adds a embot::app::application::thePOSreader2::calibParams which simplifies the calibration of the FAP readings in the board pmc by using deciDegCalib which allows a rotation, a inversion of direction and a zero in the same ways:
struct deciDegCalib
{
    enum class ROT : uint8_t { none = 0, plus180 = 1, plus090 = 2, minus090 = 3 };
    constexpr static deciDeg rotmap[4] = {0, 1800, 900, -900};
    bool invertdirection {false};
    ROT rotation {ROT::none};   
    deciDeg zero {0};  
    constexpr deciDegCalib() = default;
    constexpr deciDegCalib(bool inv, ROT rot, deciDeg zer) : invertdirection(inv), rotation(rot), zero(zer) {}
    constexpr deciDeg rotateclip(deciDeg v) const { return ( (v+rotmap[static_cast<uint8_t>(rotation)]) % 3600 ); }
    constexpr deciDeg transform(const deciDeg raw) const
    {
        deciDeg z = rotateclip(raw) - rotateclip(zero);
        return (invertdirection) ? (-z) : (+z);
    }
    void reset()
    {
        rotation = ROT::none; invertdirection = false; zero = 0;
    }
    void load(bool inv, ROT rot, deciDeg zer) 
    {
        invertdirection = inv; rotation = rot; zero = zer; 
    }
};

It will be possible w/ later development to change the above parameters in runtime w/ the POS_CONFIG_SET CAN message.
The changes do nor affect the code of any existing board in iCub but only of the pmc board which is in an experimental setup and hence can be safely merged.
cc @simeonedussoni","This PR adds a embot::app::application::thePOSreader2::calibParams which simplifies the calibration of the FAP readings in the board pmc by using deciDegCalib which allows a rotation, a inversion of direction and a zero in the same ways:
struct deciDegCalib
{
    enum class ROT : uint8_t { none = 0, plus180 = 1, plus090 = 2, minus090 = 3 };
    constexpr static deciDeg rotmap[4] = {0, 1800, 900, -900};
    bool invertdirection {false};
    ROT rotation {ROT::none};   
    deciDeg zero {0};  
    constexpr deciDegCalib() = default;
    constexpr deciDegCalib(bool inv, ROT rot, deciDeg zer) : invertdirection(inv), rotation(rot), zero(zer) {}
    constexpr deciDeg rotateclip(deciDeg v) const { return ( (v+rotmap[static_cast<uint8_t>(rotation)]) % 3600 ); }
    constexpr deciDeg transform(const deciDeg raw) const
    {
        deciDeg z = rotateclip(raw) - rotateclip(zero);
        return (invertdirection) ? (-z) : (+z);
    }
    void reset()
    {
        rotation = ROT::none; invertdirection = false; zero = 0;
    }
    void load(bool inv, ROT rot, deciDeg zer) 
    {
        invertdirection = inv; rotation = rot; zero = zer; 
    }
};

It will be possible w/ later development to change the above parameters in runtime w/ the POS_CONFIG_SET CAN message.
The changes do nor affect the code of any existing board in iCub but only of the pmc board which is in an experimental setup and hence can be safely merged.
cc @simeonedussoni",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,232,2021-12-27T10:29:35Z,2021-12-27T10:30:58Z,2021-12-27T10:30:59Z,MERGED,True,212,67,7,https://github.com/marcoaccame,Support of EXT FAULT on board amcbldc,2,[],https://github.com/robotology/icub-firmware/pull/232,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/232,"This PR adds support of the EXT FAULT emergency button on the amcbldc board for application04 and application05.
This is a first basic implementation which gives to object embot::app::application::theMBDagent the button pressed information w/ a bool EXTFAULTisPRESSED variable which is set to true by a IRQ mechanism and must be manually reset to false by the theMBDagent.
The IRQ mechanism is configured by the object embot::hw::button which is configured to trigger a callback at a embot::hw::button::Mode::TriggeredOnPress action on the pin SDA on connector J2. The release of the button must be manually checked when true == EXTFAULTisPRESSED using function bool embot::hw::button::pressed() to see when it returns false again.
The mechanism is now disabled by definition of macro DISABLE_EXTFAULT.
This PR touches only code used by  application04 and application05 of the amcbldc board and does not interfere with their existing behaviour because of the macro DISABLE_EXTFAULT being defined.
On the other hand the changes can be used for further development by others (cc @sgiraz) who need the EXT FAULT.
So it can be safely merged into robotology.","This PR adds support of the EXT FAULT emergency button on the amcbldc board for application04 and application05.
This is a first basic implementation which gives to object embot::app::application::theMBDagent the button pressed information w/ a bool EXTFAULTisPRESSED variable which is set to true by a IRQ mechanism and must be manually reset to false by the theMBDagent.
The IRQ mechanism is configured by the object embot::hw::button which is configured to trigger a callback at a embot::hw::button::Mode::TriggeredOnPress action on the pin SDA on connector J2. The release of the button must be manually checked when true == EXTFAULTisPRESSED using function bool embot::hw::button::pressed() to see when it returns false again.
The mechanism is now disabled by definition of macro DISABLE_EXTFAULT.
This PR touches only code used by  application04 and application05 of the amcbldc board and does not interfere with their existing behaviour because of the macro DISABLE_EXTFAULT being defined.
On the other hand the changes can be used for further development by others (cc @sgiraz) who need the EXT FAULT.
So it can be safely merged into robotology.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,233,2021-12-28T14:23:41Z,2021-12-28T14:40:03Z,2022-01-11T09:42:00Z,MERGED,True,1351472,350714,972,https://github.com/marcoaccame,Support of nucleo64 board + embot::hw::button::Mode::TriggeredOnPressAndRelease,5,[],https://github.com/robotology/icub-firmware/pull/233,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/233,"This PR adds support to the nucleo64 development board.
The support consists in:

its inclusion in the stm32hal library project,
test projects which use the stm32hal library in basic form and also with the embot library of classes.

This PR also adds a new mode for the embot::hw::button, the Mode::TriggeredOnPressAndRelease, which can be used to emulate an external fault in some of our motor control boards. For instance for the amcbldc and associated PR.
The behavior of the external fault was successfully tested on the nucleo64 board w/ a switch connected between 3V3 and PB9.  See photo of the setup.

Figure. Setup used to test the external fault w/  Mode::TriggeredOnPressAndRelease","This PR adds support to the nucleo64 development board.
The support consists in:

its inclusion in the stm32hal library project,
test projects which use the stm32hal library in basic form and also with the embot library of classes.

This PR also adds a new mode for the embot::hw::button, the Mode::TriggeredOnPressAndRelease, which can be used to emulate an external fault in some of our motor control boards. For instance for the amcbldc and associated PR.
The behavior of the external fault was successfully tested on the nucleo64 board w/ a switch connected between 3V3 and PB9.  See photo of the setup.

Figure. Setup used to test the external fault w/  Mode::TriggeredOnPressAndRelease",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,234,2021-12-28T15:33:49Z,2021-12-28T15:34:09Z,2021-12-28T15:34:09Z,MERGED,True,74,58,2,https://github.com/marcoaccame,amcbldc: revised the EXT FAULT management,1,[],https://github.com/robotology/icub-firmware/pull/234,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/234,"This PR adds what in #233 to application04 and application05 of the amcbldc board.
It mildly touches only two files related to the amcbldc so, it can be safely merged.","This PR adds what in #233 to application04 and application05 of the amcbldc board.
It mildly touches only two files related to the amcbldc so, it can be safely merged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,235,2022-01-10T20:44:24Z,2022-01-11T10:29:39Z,2022-01-11T10:29:39Z,MERGED,True,2720,1744,56,https://github.com/sgiraz,AMC_BLDC: Update mbd generated code with the last changes that fix the FOCcontrol issue,4,[],https://github.com/robotology/icub-firmware/pull/235,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/235,"What's changed in this PR:

Finally, the problem of motor control has been solved. So, the generated code has been updated with the last changes of the mbd.
The commands to enable/disable the motor are now part of the mbd.
In rtw_mutex.h the mutex functions are now always enabled.

Note:
When we send the current values for the target, we should pay attention to the current limits we set before.
Even limits of 772mA with a target of 470mA can trigger the Supervisor Fault Handler.
This behavior is not an issue of application05 because it happens in application04 as well.
cc @valegagge @GrmanRodriguez @vvasco @ale-git","What's changed in this PR:

Finally, the problem of motor control has been solved. So, the generated code has been updated with the last changes of the mbd.
The commands to enable/disable the motor are now part of the mbd.
In rtw_mutex.h the mutex functions are now always enabled.

Note:
When we send the current values for the target, we should pay attention to the current limits we set before.
Even limits of 772mA with a target of 470mA can trigger the Supervisor Fault Handler.
This behavior is not an issue of application05 because it happens in application04 as well.
cc @valegagge @GrmanRodriguez @vvasco @ale-git",True,"{'ROCKET': ['https://github.com/pattacini', 'https://github.com/valegagge']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,235,2022-01-10T20:44:24Z,2022-01-11T10:29:39Z,2022-01-11T10:29:39Z,MERGED,True,2720,1744,56,https://github.com/sgiraz,AMC_BLDC: Update mbd generated code with the last changes that fix the FOCcontrol issue,4,[],https://github.com/robotology/icub-firmware/pull/235,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/235#issuecomment-1009354862,"What's changed in this PR:

Finally, the problem of motor control has been solved. So, the generated code has been updated with the last changes of the mbd.
The commands to enable/disable the motor are now part of the mbd.
In rtw_mutex.h the mutex functions are now always enabled.

Note:
When we send the current values for the target, we should pay attention to the current limits we set before.
Even limits of 772mA with a target of 470mA can trigger the Supervisor Fault Handler.
This behavior is not an issue of application05 because it happens in application04 as well.
cc @valegagge @GrmanRodriguez @vvasco @ale-git","Great 

Even limits of 772mA with a target of 4760mA can trigger the Supervisor Fault Handler.

The overloadcurrent limit is meant to be quite high ~ 20 A; hence, it ain't a problem, definitely.
The peakcurrent limit, instead, will be used to implement the SW current limiter, which is now missing.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,236,2022-01-11T10:42:58Z,2022-01-11T10:43:15Z,2022-01-11T10:43:15Z,MERGED,True,26,4,2,https://github.com/marcoaccame,amcbldc: fixed bootloader project,1,[],https://github.com/robotology/icub-firmware/pull/236,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/236,"As per title.
I just added the file embot_hw_button.cpp in the bootloader project.","As per title.
I just added the file embot_hw_button.cpp in the bootloader project.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,237,2022-01-11T12:55:27Z,2022-01-11T13:06:32Z,2022-01-11T13:06:33Z,MERGED,True,2,0,1,https://github.com/valegagge,AMCBLDC: get CAN address from the cached CANBoardInfo,1,[],https://github.com/robotology/icub-firmware/pull/237,https://github.com/valegagge,1,https://github.com/robotology/icub-firmware/pull/237,In this PR the firmware uses the CAN address stored in ROM instead of the constant fixed in the model (its value is 3),In this PR the firmware uses the CAN address stored in ROM instead of the constant fixed in the model (its value is 3),True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,238,2022-01-11T15:40:26Z,2022-01-11T15:40:47Z,2022-01-11T15:40:47Z,MERGED,True,22,3,2,https://github.com/marcoaccame,amcbldc: enabled the EXT fault on application05,1,[],https://github.com/robotology/icub-firmware/pull/238,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/238,"This PR enables the EXT fault on aplication05 of the amcbldc.
The code is tested on our setup and it works fine. When the EXT fault is pressed the red LED gets ON otherwise gets off
CAVEAT: the fault button pressed also disable the motor but unpressing it does not enable it back.","This PR enables the EXT fault on aplication05 of the amcbldc.
The code is tested on our setup and it works fine. When the EXT fault is pressed the red LED gets ON otherwise gets off
CAVEAT: the fault button pressed also disable the motor but unpressing it does not enable it back.",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,239,2022-01-13T09:45:24Z,2022-01-13T09:59:38Z,2022-01-13T09:59:38Z,MERGED,True,20027,0,71,https://github.com/sgiraz,AMC_BLDC: Add Application06 to work with wrist setup.,1,[],https://github.com/robotology/icub-firmware/pull/239,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/239,"What's changed in this PR:

Added Application06 folder that contains the changes to work properly with the wrist setup.

Note

Some changes have been applied to the generated code, so be careful to update the mbd properly before updating these sources with the next generation of the code.
In decoder.cpp it contains some debug prints to inspect the payload for the messages received with ID.Typ 0xF (EMSTO2FOC_DESIRED_CURRENT). These prints can be safely removed with the next generation of the code from mbd.

cc @pattacini @valegagge @GrmanRodriguez @ale-git","What's changed in this PR:

Added Application06 folder that contains the changes to work properly with the wrist setup.

Note

Some changes have been applied to the generated code, so be careful to update the mbd properly before updating these sources with the next generation of the code.
In decoder.cpp it contains some debug prints to inspect the payload for the messages received with ID.Typ 0xF (EMSTO2FOC_DESIRED_CURRENT). These prints can be safely removed with the next generation of the code from mbd.

cc @pattacini @valegagge @GrmanRodriguez @ale-git",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,240,2022-01-14T13:33:54Z,2022-01-14T14:32:40Z,2022-01-14T14:32:40Z,MERGED,True,250,140,13,https://github.com/marcoaccame,Enhancement of `embot::hw::motor`,2,[],https://github.com/robotology/icub-firmware/pull/240,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/240,"This PR improves the APIs of embot::hw::motor so that operations on the motor PWM are effective only when the motor is not faulted and is enabled.
In particular, here is the new behaviour.
The motor embot::hw::MOTOR::one by default is not faulted.
We can implement a safety mechanism by association of the changes of status of a push button to a bool EXTfaultISpressed and to the call of a function embot::hw::motor::fault(embot::hw::MOTOR::one, EXTfaultISpressed).
The call of embot::hw::motor::fault() function is possible even before the initialization of the motor.
But it is only after we initialize the motor embot::hw::MOTOR::one w/ embot::hw::motor::init(embot::hw::MOTOR::one, cfg) that we can attempt to enable it and apply PWM to it w/ embot::hw::motor::enable(embot::hw::MOTOR::one, true) and embot::hw::motor::setpwm(embot::hw::MOTOR::one, u, v, w)
At this stage we have two possibilities:

if the motor embot::hw::MOTOR::one is not faulted, then we can successfully enable and move it;
if the motor embot::hw::MOTOR::one is faulted, the above calls do not have any effect.

When the motor embot::hw::MOTOR::one is enabled and w/ applied PWM and it is faulted by a call to embot::hw::motor::fault(embot::hw::MOTOR::one, true) then:

it is automatically disabled w/ an internal call to embot::hw::motor::setpwm(embot::hw::MOTOR::one, 0, 0, 0) and embot::hw::motor::enable(embot::hw::MOTOR::one, false);
from this point, any further call to embot::hw::motor::enable(embot::hw::MOTOR::one, true) or embot::hw::motor::setpwm(embot::hw::MOTOR::one, u, v, w) do not have any effect.

If the motor is faulted, we need an explicit call to embot::hw::motor::fault(embot::hw::MOTOR::one, false) followed by another explicit call to any call to  embot::hw::motor::enable(embot::hw::MOTOR::one, true) before the application of a non zero PWM can have affect on the motor.
This PR contains also adaptation of the projects of the amcbldc which use the API of embot::hw::motor.","This PR improves the APIs of embot::hw::motor so that operations on the motor PWM are effective only when the motor is not faulted and is enabled.
In particular, here is the new behaviour.
The motor embot::hw::MOTOR::one by default is not faulted.
We can implement a safety mechanism by association of the changes of status of a push button to a bool EXTfaultISpressed and to the call of a function embot::hw::motor::fault(embot::hw::MOTOR::one, EXTfaultISpressed).
The call of embot::hw::motor::fault() function is possible even before the initialization of the motor.
But it is only after we initialize the motor embot::hw::MOTOR::one w/ embot::hw::motor::init(embot::hw::MOTOR::one, cfg) that we can attempt to enable it and apply PWM to it w/ embot::hw::motor::enable(embot::hw::MOTOR::one, true) and embot::hw::motor::setpwm(embot::hw::MOTOR::one, u, v, w)
At this stage we have two possibilities:

if the motor embot::hw::MOTOR::one is not faulted, then we can successfully enable and move it;
if the motor embot::hw::MOTOR::one is faulted, the above calls do not have any effect.

When the motor embot::hw::MOTOR::one is enabled and w/ applied PWM and it is faulted by a call to embot::hw::motor::fault(embot::hw::MOTOR::one, true) then:

it is automatically disabled w/ an internal call to embot::hw::motor::setpwm(embot::hw::MOTOR::one, 0, 0, 0) and embot::hw::motor::enable(embot::hw::MOTOR::one, false);
from this point, any further call to embot::hw::motor::enable(embot::hw::MOTOR::one, true) or embot::hw::motor::setpwm(embot::hw::MOTOR::one, u, v, w) do not have any effect.

If the motor is faulted, we need an explicit call to embot::hw::motor::fault(embot::hw::MOTOR::one, false) followed by another explicit call to any call to  embot::hw::motor::enable(embot::hw::MOTOR::one, true) before the application of a non zero PWM can have affect on the motor.
This PR contains also adaptation of the projects of the amcbldc which use the API of embot::hw::motor.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,241,2022-01-14T15:35:47Z,2022-01-14T15:37:00Z,2022-01-14T15:37:01Z,MERGED,True,82,6,5,https://github.com/marcoaccame,Added support for CAN message embot::prot::can::motor::periodic::STATUS,1,[],https://github.com/robotology/icub-firmware/pull/241,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/241,"This PR add support for CAN message embot::prot::can::motor::periodic::STATUS for use in pmc and amcbldc boards
Some sample code (not active for now) is provided for the application06 of the amcbld board.","This PR add support for CAN message embot::prot::can::motor::periodic::STATUS for use in pmc and amcbldc boards
Some sample code (not active for now) is provided for the application06 of the amcbld board.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,242,2022-01-14T19:34:57Z,2022-01-15T09:25:12Z,2022-01-15T09:25:12Z,MERGED,True,787,541,62,https://github.com/sgiraz,AMC_BLDC: Add support to External Fault ,5,"['bug', 'enhancement', 'CAN']",https://github.com/robotology/icub-firmware/pull/242,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/242,"What's changed in this PR:

Updated the generated code in Application06 with encoder/decoder updates applied on mbd
Bug Fix where targets setpoint were uninitialized in emBODY/eBcode/arch-arm/embobj/plus/mc/Motor.c
Application06 now supports the external fault signal. Glue code has been added to connect the low-level signal with the mbd input managed then by Supervisor.
Disabled ExternalFault macros in Application05

Notes:
Tests performed with Application06:



Command Sequence
set limits
set current mode
set target

set idle mode
set current mode
set target
set idle mode
set current mode
set target





Fault Button State
OFF
OFF
OFF
ON
ON
ON
ON
OFF
OFF
OFF
ON



The above test has been repeated many times with either the Fault Button initially pushed or released.
On each execution, the results are as expected: every time the fault button is pressed the PWM signal stops. Every time the Fault Button is released we can always send a new target after we sent a set control mode idle and then go back to the current control mode.
Furthermore, I can confirm that the External Fault is correctly detected and managed by the Supervisor:

 In order to run Application05 on LEGO-Setup, the External-Faults macros have been disabled otherwise the External-Fault will result always be pressed regardless the physical button is attached or not (  ).
cc @marcoaccame @pattacini @valegagge @GrmanRodriguez @ale-git","What's changed in this PR:

Updated the generated code in Application06 with encoder/decoder updates applied on mbd
Bug Fix where targets setpoint were uninitialized in emBODY/eBcode/arch-arm/embobj/plus/mc/Motor.c
Application06 now supports the external fault signal. Glue code has been added to connect the low-level signal with the mbd input managed then by Supervisor.
Disabled ExternalFault macros in Application05

Notes:
Tests performed with Application06:



Command Sequence
set limits
set current mode
set target

set idle mode
set current mode
set target
set idle mode
set current mode
set target





Fault Button State
OFF
OFF
OFF
ON
ON
ON
ON
OFF
OFF
OFF
ON



The above test has been repeated many times with either the Fault Button initially pushed or released.
On each execution, the results are as expected: every time the fault button is pressed the PWM signal stops. Every time the Fault Button is released we can always send a new target after we sent a set control mode idle and then go back to the current control mode.
Furthermore, I can confirm that the External Fault is correctly detected and managed by the Supervisor:

 In order to run Application05 on LEGO-Setup, the External-Faults macros have been disabled otherwise the External-Fault will result always be pressed regardless the physical button is attached or not (  ).
cc @marcoaccame @pattacini @valegagge @GrmanRodriguez @ale-git",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,243,2022-01-18T12:59:00Z,2022-01-18T13:01:18Z,2022-01-18T13:01:18Z,MERGED,True,38,51,5,https://github.com/marcoaccame,amcbldc: now application06 correctly consumes one can frame every 1 ms,1,[],https://github.com/robotology/icub-firmware/pull/243,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/243,"This PR fixes the case when the amcbldc receives bursts of CAN frames. Now the theMBDagent object is able to consume the burst one CAN frame every 1 ms w/out losing anyone. It is function embot::app::application::theMBDagent::Impl::tick() which has the responsibility to consume CAN frames (and erasing them from the buffer) according to its capability.
cc @sgiraz","This PR fixes the case when the amcbldc receives bursts of CAN frames. Now the theMBDagent object is able to consume the burst one CAN frame every 1 ms w/out losing anyone. It is function embot::app::application::theMBDagent::Impl::tick() which has the responsibility to consume CAN frames (and erasing them from the buffer) according to its capability.
cc @sgiraz",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,244,2022-01-18T16:29:39Z,2022-01-18T16:30:14Z,2022-01-18T16:30:14Z,MERGED,True,575289,0,606,https://github.com/marcoaccame,Board amc: added HW test project,1,[],https://github.com/robotology/icub-firmware/pull/244,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/244,This PR just adds a basic project for testing the HW peripherals of the amc board which will be used for developing full HW support under embot::hw and for the UDP stack. The code is courtesy of @GiorgioZini.,This PR just adds a basic project for testing the HW peripherals of the amc board which will be used for developing full HW support under embot::hw and for the UDP stack. The code is courtesy of @GiorgioZini.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/245,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/sgiraz,2,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1017448649,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","We wait to merge this PR.
First, we have to solve some issues in amc_bldc.
In particular:

we have to restore the SupervisorRX_isBoardCOnfigured original return value.
we have to establish what to do in Motor.c

cc @marcoaccame",True,{'THUMBS_UP': ['https://github.com/valegagge']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/marcoaccame,3,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1019813359,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","We wait to merge this PR.

i have put it in draft status. feel free to move it back ready for review when ok.",True,{'THUMBS_UP': ['https://github.com/sgiraz']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/sgiraz,4,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1021267149,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD


This has been fixed.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/sgiraz,5,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1025777367,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","Hi @marcoaccame, to recap, there are 2 things we should keep in mind while merging:
First

What's change in this PR:
In Motor.c the check on rotor's position is commented in order to work with wrist-setup

The code mentioned above has been commented out, but the rotor's position min/max have been set to 0:
void Motor_config(Motor* o, uint8_t ID, eOmc_motor_config_t* config)
{
    ...
    o->pos_min = 0; //config->limitsofrotor.min;
    o->pos_max = 0; //config->limitsofrotor.max;    
    ...
}
Second

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround (in Motor.c) allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.


#if !defined(EOTHESERVICES_customize_handV3_7joints)
void Motor_actuate(Motor* motor, uint8_t N) //
{
    if (motor->HARDWARE_TYPE == HARDWARE_2FOC)
    {
        // TODO: Fix. Temporary workaround
        // To be sure that amc_bldc/2foc can process all sent messages, we are sending 1 setpoint every 2ms
        static uint8_t cnt = 0;
        if((++cnt % 2) == 1)
        {
            return;
        }
        ....
   }
   ...
}",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/pattacini,6,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1026711614,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","If it works you can remove the customization code where you set them to zero.

Nice! This would be a much better approach indeed.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/pattacini,7,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1026862756,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","@sgiraz, then, remember to update the configuration files in https://github.com/robotology/robots-configuration/tree/devel/experimentalSetups/wristmk2_handmk3_ems_amcbldc to update those 2 values to 0.",True,{'THUMBS_UP': ['https://github.com/sgiraz']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,245,2022-01-19T16:46:03Z,2022-02-01T14:29:48Z,2022-02-02T10:08:29Z,MERGED,True,165,79,22,https://github.com/sgiraz,AMC_BLDC: Update the application06 to work with wrist-setup,13,[],https://github.com/robotology/icub-firmware/pull/245,https://github.com/sgiraz,8,https://github.com/robotology/icub-firmware/pull/245#issuecomment-1026864328,"What changes in this PR:

In Motor.c the check on rotor's position is commented in order to work with wrist-setup
The SET_CURRENT_PID message actually is not processed in order to not override the embedded gains implemented within the MBD

Notes:

 Now the EMS will send 1 target setpoint every 2ms instead of every 1ms. This workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be implemented inside the mbd.
This PR has been tested on wrist setup.","hi @sgiraz,
the changes are ok, but ... pls have a look if what we have just discovered together is true: that we can configure the posmin and posmax of the motor in file xml of mechanical properties, section LIMITS::rotorPosMin and LIMITS::rotorPosMax.
If it works you can remove the customization code where you set them to zero.

Nice catch! This solution definitely works!
    <group name=""LIMITS"">
        <param name=""hardwareJntPosMax"">     52          </param>
        <param name=""hardwareJntPosMin"">    -62          </param>
-        <param name=""rotorPosMin"">          -20           </param>
-        <param name=""rotorPosMax"">           20           </param>
+        <param name=""rotorPosMin"">           0           </param>
+       <param name=""rotorPosMax"">            0           </param>
    </group>

I'm updating robots-configuration in order to match the case for our setup.
The DEBUG_workaround_amcbldc macro still exists due to the setpoint transmission well note issue",True,{'HOORAY': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,246,2022-01-24T08:20:53Z,2022-01-24T08:22:55Z,2022-01-24T08:22:55Z,MERGED,True,2128,520,99,https://github.com/marcoaccame,Update of cubemx for board amc and related stm32hal library,3,[],https://github.com/robotology/icub-firmware/pull/246,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/246,"This PR adds to the stm32hal library for the board amc the low level initialization of the most recent cubemx file which was used for the HW tests of the board. See this recent PR.
The imported cubemx project and the derived stm32hal library were tested on the amc board.
We are now ready to add more HW device drivers to embot::hw, maybe starting from EEPROM support.
The EEPROM will contain the board information and is the first brick for the porting on the amc of the bootstrap structure running on the ems which is formed by: eLoader, eUpdater, eApplication. The other bricks are the IPAL and the CAN driver.","This PR adds to the stm32hal library for the board amc the low level initialization of the most recent cubemx file which was used for the HW tests of the board. See this recent PR.
The imported cubemx project and the derived stm32hal library were tested on the amc board.
We are now ready to add more HW device drivers to embot::hw, maybe starting from EEPROM support.
The EEPROM will contain the board information and is the first brick for the porting on the amc of the bootstrap structure running on the ems which is formed by: eLoader, eUpdater, eApplication. The other bricks are the IPAL and the CAN driver.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,247,2022-01-28T16:43:08Z,2022-01-28T16:59:23Z,2022-01-28T17:23:01Z,CLOSED,False,233,114,31,https://github.com/sgiraz,Update hal2 with fix in case the AEA3 encoder is not attached to the board,10,['bug'],https://github.com/robotology/icub-firmware/pull/247,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/247,"In this PR I have:

rebased vs latest devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on AEA3 setup

The case when the encoder is not connected to the board is now handled correctly","In this PR I have:

rebased vs latest devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on AEA3 setup

The case when the encoder is not connected to the board is now handled correctly",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,247,2022-01-28T16:43:08Z,2022-01-28T16:59:23Z,2022-01-28T17:23:01Z,CLOSED,False,233,114,31,https://github.com/sgiraz,Update hal2 with fix in case the AEA3 encoder is not attached to the board,10,['bug'],https://github.com/robotology/icub-firmware/pull/247,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/247#issuecomment-1024414848,"In this PR I have:

rebased vs latest devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on AEA3 setup

The case when the encoder is not connected to the board is now handled correctly","Hi @sgiraz
I think there might be a problem with the PR.
852 changes are too many.
Did you really aim to merge against master or devel?
Too many commits too.
To be carefully reviewed.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,247,2022-01-28T16:43:08Z,2022-01-28T16:59:23Z,2022-01-28T17:23:01Z,CLOSED,False,233,114,31,https://github.com/sgiraz,Update hal2 with fix in case the AEA3 encoder is not attached to the board,10,['bug'],https://github.com/robotology/icub-firmware/pull/247,https://github.com/pattacini,3,https://github.com/robotology/icub-firmware/pull/247#issuecomment-1024420663,"In this PR I have:

rebased vs latest devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on AEA3 setup

The case when the encoder is not connected to the board is now handled correctly","After a quick alignment w/ @sgiraz, we decided to close this PR unmerged and start over.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,248,2022-01-28T17:47:27Z,2022-01-31T14:22:09Z,2022-01-31T14:25:08Z,MERGED,True,27,19,7,https://github.com/sgiraz,Update hal2 with fix in case the AEA3 encoder is not attached to the board,1,['bug'],https://github.com/robotology/icub-firmware/pull/248,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/248,"In this PR I have:

rebased vs latest robotology/devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on AEA3 setup

The case when the encoder is not connected to the board is now handled correctly","In this PR I have:

rebased vs latest robotology/devel;
adjusted versioning of ems, mc4plus, mc2plus;
performed intensive tests on AEA3 setup

The case when the encoder is not connected to the board is now handled correctly",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,249,2022-01-31T14:33:53Z,2022-01-31T15:32:14Z,2022-01-31T15:32:14Z,MERGED,True,9133,45,24,https://github.com/marcoaccame,Support for SPI and EEPROM in amc board,3,[],https://github.com/robotology/icub-firmware/pull/249,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/249,"This PR adds to embot::hw the support for SPI, EEPROM and the STM chip M95512DF which is a ... spi EEPROM mounted on the amc board.
This PR also requires this one on icub-firmware-shared.
The code was tested on the amc board on a dedicated project and works fine.
IMPORTANT.
The SPI driver with the added configuration features for speed, datasize and shape of the frame is ready to use by a AEA sensor (or other absolute SPI encoder) which can be attached to the J5 connector of the amc board. The driver for the AEA is yet to be developed but can follow the guideline that I have used for embot::hw::chip::M95512DF
For this reason, in the SPI driver and for the M95512DF chip I have also added some documentation and for the M95512DF chip also a test function which describes how to use the chip.
Here are some more details.
Configuration of the embot::hw::spi driver
The driver can be configured through embot::hw::spi::Config which allows, so far, to adapt
speed, datasize and shape of the SPI dataframe.
The pinout of the clock (SCLK), master output/slave input (MOSI), master input/slave output (MISO),
and slave select (SS) are for now not managed in here. They are initted at startup by embot::hw::bsp::init().
The embot::hw::spi::Prescaler
It allows to scale the bus used by SPI to match some discrete speeds.
The embot::hw::spi::DataSize
It allows to form a dataframe of different sizes.
The embot::hw::spi::Mode
It shapes the data frame. That can happens in four different modes whiche end up in binary values of
two parameters: the clock polarity (CPOL) and the clock phase (CPHA).
A CPOL = 0 means that the clock line idles low and similarly CPOL = 1 means clock line idles high.
And if CPHA = 0 the bits are sampled on the leading clock edge, else if CPHA = 1 ar ecampled on the trailing ege.
All four possible combinations are shown in the following figure, alongside with the values of  embot::shw::spi::Mode used in the embot::hw::spi driver.
                    CPHA = 0              CPHA = 1                               
              samples on leading     samples on trailing
                      |                     |  
CPOL = 0              v___               ___v      
CLK idles low       __|   |__         __|   |__
                    Mode::zero        Mode::one
    
              samples on leading     samples on trailing       
                      |                     |
CPOL = 1            __v    __         __    v__
CKL idles high        |___|             |___|
                    Mode::two        Mode::tree

Figure. Description of embot::shw::spi::Mode.
Description of the embot::hw::chip::M95512DF
This class embot::hw::chip::M95512DF implements a device driver for the chip M95512-DF which is an SPI EEPROM of size 64 KB and page size 128 B.
                Vcc
                 |
             ---------
            |         |
       D ---|         |
       C ---|         |
      nS --o| M95xxx  |--- Q
      nW --o|         |
   nHOLD --o|         |
            |         |
             --------- 
                |
               Vss


Figure 1. Logic diagram.



Signal name
Function
Direction
Description




C
Serial Clock
Input



D
Serial data input
Input



Q
Serial data output
Output



nS
Chip select
Input
When this input signal is high, the device is deselected. Driving Chip select low selects the device.


nW
Write protect
Input
The main purpose of this input signal is to freeze the size of the area of memory that is protected against Write instructions.


nHOLD
Hold
Input
Used to pause any serial communications with the device without deselecting the device


Vcc
Supply voltage
-



Vss
Ground
-




Table 1. Signals.
Basic usage
You can use the following code, as long as the settings for SPI are specified by the bsp of the board.
#include ""embot_hw_chip_M95512DF.h""

bool ok = embot::hw::chip::M95512DF::testof_M95512DF();

Code listing. Usage of the class
#if defined(EMBOT_HW_CHIP_M95512DF_enable_test)    

// it tests the chip and offers an example of use
bool embot::hw::chip::testof_M95512DF()
{    
    // this configuration tells about which spi bus to use, which are the control pins
    // and their low level GPIO configuration
    // some extra info:
    // 1. this configuration is typically used by the embot::hw::eeprom and defined
    //    inside embot::hw::eeprom::thebsp located inside mbot_hw_bsp_nameofboard.cpp
    // 2. the spi bus in here specified is initted by M95512DF code w/ a 
    //    call to embot::hw::spi::init() in a way that is specified by
    //    embot::hw::spi::thebsp typically placed inside embot_hw_bsp_nameofboard.cpp
    // 3. the control pins are initialised / deinitialised inside M95512DF only if
    //    embot::hw::chip::M95512DF::Config::PinControl::config.isvalid()
    constexpr embot::hw::chip::M95512DF::Config cfg 
    {
        embot::hw::SPI::six,  // the spi bus
        //{}, // dummy spi config
        {embot::hw::spi::Prescaler::eight, embot::hw::spi::DataSize::eight, embot::hw::spi::Mode::zero},
        {   // the control pins
            {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::eight},    // nS
            {embot::hw::GPIO::PORT::F, embot::hw::GPIO::PIN::twelve},   // nW
            {embot::hw::GPIO::PORT::F, embot::hw::GPIO::PIN::thirteen}, // nHOLD   
            {   // GPIO configuration of the control pins
                embot::hw::gpio::Mode::OUTPUTpushpull,
                embot::hw::gpio::Pull::nopull,
                embot::hw::gpio::Speed::veryhigh
            }        
        }    
    };
    
    // address in EEPROM, data to write, destination for data to read
    constexpr embot::hw::chip::M95512DF::ADR adr {64};
    static constexpr uint8_t bytes2write[8] {1, 2, 3, 4, 5, 6, 7, 8};
    constexpr embot::core::Data data2write {bytes2write, sizeof(bytes2write)};
    uint8_t bytes2read[4] {0};
    embot::core::Data data2read {bytes2read, sizeof(bytes2read)}; 
        
    // step 01: create the object
    embot::hw::chip::M95512DF *chipM95512DF = new embot::hw::chip::M95512DF;
    
    bool ok {false};
    
    // step 02: initialise it (for extra check i also deinit and init it again)   
    chipM95512DF->init(cfg);
    chipM95512DF->deinit();
    if(true == chipM95512DF->init(cfg))
    {  
        // step 03: write some data to EEPROM
        if(true == chipM95512DF->write(adr, data2write))
        {
            // step 04: read data back
            if(true == chipM95512DF->read(adr+1, data2read))
            {
                // step 05: compare them
                ok = (bytes2read[0] == bytes2write[1]) ? true : false;
            }
        }                   
    }

    // step 06: print result
    embot::core::print(ok ? ""test chipM95512DF: OK"" : ""test chipM95512DF: KO"");   
    
    // step 07: delete the object: the destructor also deinits
    delete chipM95512DF;
    
    return ok;
}


#endif

Code listing. Usage of the class, part 2.
Caveat Emptor
The interface of the device driver is kept intentionally simple and some features are left (for now) inside the private implementation.
References
[1] Datasheet of M95512-W M95512-R M95512-DF, DS4192 - Rev 24 - September 2021","This PR adds to embot::hw the support for SPI, EEPROM and the STM chip M95512DF which is a ... spi EEPROM mounted on the amc board.
This PR also requires this one on icub-firmware-shared.
The code was tested on the amc board on a dedicated project and works fine.
IMPORTANT.
The SPI driver with the added configuration features for speed, datasize and shape of the frame is ready to use by a AEA sensor (or other absolute SPI encoder) which can be attached to the J5 connector of the amc board. The driver for the AEA is yet to be developed but can follow the guideline that I have used for embot::hw::chip::M95512DF
For this reason, in the SPI driver and for the M95512DF chip I have also added some documentation and for the M95512DF chip also a test function which describes how to use the chip.
Here are some more details.
Configuration of the embot::hw::spi driver
The driver can be configured through embot::hw::spi::Config which allows, so far, to adapt
speed, datasize and shape of the SPI dataframe.
The pinout of the clock (SCLK), master output/slave input (MOSI), master input/slave output (MISO),
and slave select (SS) are for now not managed in here. They are initted at startup by embot::hw::bsp::init().
The embot::hw::spi::Prescaler
It allows to scale the bus used by SPI to match some discrete speeds.
The embot::hw::spi::DataSize
It allows to form a dataframe of different sizes.
The embot::hw::spi::Mode
It shapes the data frame. That can happens in four different modes whiche end up in binary values of
two parameters: the clock polarity (CPOL) and the clock phase (CPHA).
A CPOL = 0 means that the clock line idles low and similarly CPOL = 1 means clock line idles high.
And if CPHA = 0 the bits are sampled on the leading clock edge, else if CPHA = 1 ar ecampled on the trailing ege.
All four possible combinations are shown in the following figure, alongside with the values of  embot::shw::spi::Mode used in the embot::hw::spi driver.
                    CPHA = 0              CPHA = 1                               
              samples on leading     samples on trailing
                      |                     |  
CPOL = 0              v___               ___v      
CLK idles low       __|   |__         __|   |__
                    Mode::zero        Mode::one
    
              samples on leading     samples on trailing       
                      |                     |
CPOL = 1            __v    __         __    v__
CKL idles high        |___|             |___|
                    Mode::two        Mode::tree

Figure. Description of embot::shw::spi::Mode.
Description of the embot::hw::chip::M95512DF
This class embot::hw::chip::M95512DF implements a device driver for the chip M95512-DF which is an SPI EEPROM of size 64 KB and page size 128 B.
                Vcc
                 |
             ---------
            |         |
       D ---|         |
       C ---|         |
      nS --o| M95xxx  |--- Q
      nW --o|         |
   nHOLD --o|         |
            |         |
             --------- 
                |
               Vss


Figure 1. Logic diagram.



Signal name
Function
Direction
Description




C
Serial Clock
Input



D
Serial data input
Input



Q
Serial data output
Output



nS
Chip select
Input
When this input signal is high, the device is deselected. Driving Chip select low selects the device.


nW
Write protect
Input
The main purpose of this input signal is to freeze the size of the area of memory that is protected against Write instructions.


nHOLD
Hold
Input
Used to pause any serial communications with the device without deselecting the device


Vcc
Supply voltage
-



Vss
Ground
-




Table 1. Signals.
Basic usage
You can use the following code, as long as the settings for SPI are specified by the bsp of the board.
#include ""embot_hw_chip_M95512DF.h""

bool ok = embot::hw::chip::M95512DF::testof_M95512DF();

Code listing. Usage of the class
#if defined(EMBOT_HW_CHIP_M95512DF_enable_test)    

// it tests the chip and offers an example of use
bool embot::hw::chip::testof_M95512DF()
{    
    // this configuration tells about which spi bus to use, which are the control pins
    // and their low level GPIO configuration
    // some extra info:
    // 1. this configuration is typically used by the embot::hw::eeprom and defined
    //    inside embot::hw::eeprom::thebsp located inside mbot_hw_bsp_nameofboard.cpp
    // 2. the spi bus in here specified is initted by M95512DF code w/ a 
    //    call to embot::hw::spi::init() in a way that is specified by
    //    embot::hw::spi::thebsp typically placed inside embot_hw_bsp_nameofboard.cpp
    // 3. the control pins are initialised / deinitialised inside M95512DF only if
    //    embot::hw::chip::M95512DF::Config::PinControl::config.isvalid()
    constexpr embot::hw::chip::M95512DF::Config cfg 
    {
        embot::hw::SPI::six,  // the spi bus
        //{}, // dummy spi config
        {embot::hw::spi::Prescaler::eight, embot::hw::spi::DataSize::eight, embot::hw::spi::Mode::zero},
        {   // the control pins
            {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::eight},    // nS
            {embot::hw::GPIO::PORT::F, embot::hw::GPIO::PIN::twelve},   // nW
            {embot::hw::GPIO::PORT::F, embot::hw::GPIO::PIN::thirteen}, // nHOLD   
            {   // GPIO configuration of the control pins
                embot::hw::gpio::Mode::OUTPUTpushpull,
                embot::hw::gpio::Pull::nopull,
                embot::hw::gpio::Speed::veryhigh
            }        
        }    
    };
    
    // address in EEPROM, data to write, destination for data to read
    constexpr embot::hw::chip::M95512DF::ADR adr {64};
    static constexpr uint8_t bytes2write[8] {1, 2, 3, 4, 5, 6, 7, 8};
    constexpr embot::core::Data data2write {bytes2write, sizeof(bytes2write)};
    uint8_t bytes2read[4] {0};
    embot::core::Data data2read {bytes2read, sizeof(bytes2read)}; 
        
    // step 01: create the object
    embot::hw::chip::M95512DF *chipM95512DF = new embot::hw::chip::M95512DF;
    
    bool ok {false};
    
    // step 02: initialise it (for extra check i also deinit and init it again)   
    chipM95512DF->init(cfg);
    chipM95512DF->deinit();
    if(true == chipM95512DF->init(cfg))
    {  
        // step 03: write some data to EEPROM
        if(true == chipM95512DF->write(adr, data2write))
        {
            // step 04: read data back
            if(true == chipM95512DF->read(adr+1, data2read))
            {
                // step 05: compare them
                ok = (bytes2read[0] == bytes2write[1]) ? true : false;
            }
        }                   
    }

    // step 06: print result
    embot::core::print(ok ? ""test chipM95512DF: OK"" : ""test chipM95512DF: KO"");   
    
    // step 07: delete the object: the destructor also deinits
    delete chipM95512DF;
    
    return ok;
}


#endif

Code listing. Usage of the class, part 2.
Caveat Emptor
The interface of the device driver is kept intentionally simple and some features are left (for now) inside the private implementation.
References
[1] Datasheet of M95512-W M95512-R M95512-DF, DS4192 - Rev 24 - September 2021",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,250,2022-02-02T10:24:54Z,2022-02-03T10:17:01Z,2022-02-03T10:17:02Z,MERGED,True,2248,2133,58,https://github.com/sgiraz,AMC_BLDC: Alignment with the latest changes on MBD,5,['enhancement'],https://github.com/robotology/icub-firmware/pull/250,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/250,"What changes in this PR:

The mbd I/O interfaces have been updated with the latest architectural model changes.
Workarounds for STATUS CAN packet removed because it is now managed internally to the can_encoder
MBDAgent updated with minor improvements and now it is predisposed to manage multi I/O CAN packets although it still elaborates one packet at a time instance in RX

Notes:

 The EMS still sends 1 target setpoint every 2ms instead of every 1ms. Remember that this workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be completed inside the mbd.
 After the fault button is pressed and then released, if we send the SET_CONTROL_MODE IDLE through the yarpmotorgui, there are 2 consecutive SET_CONTROL_MODE message packets are sent
 This PR has been successfully tested on wrist-setup.","What changes in this PR:

The mbd I/O interfaces have been updated with the latest architectural model changes.
Workarounds for STATUS CAN packet removed because it is now managed internally to the can_encoder
MBDAgent updated with minor improvements and now it is predisposed to manage multi I/O CAN packets although it still elaborates one packet at a time instance in RX

Notes:

 The EMS still sends 1 target setpoint every 2ms instead of every 1ms. Remember that this workaround allows the AMC_BLDC to consume all its incoming packages. This is a temporary workaround until the multipackage manager will be completed inside the mbd.
 After the fault button is pressed and then released, if we send the SET_CONTROL_MODE IDLE through the yarpmotorgui, there are 2 consecutive SET_CONTROL_MODE message packets are sent
 This PR has been successfully tested on wrist-setup.",True,"{'HOORAY': ['https://github.com/pattacini'], 'ROCKET': ['https://github.com/pattacini']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,251,2022-02-03T16:36:25Z,2022-02-03T16:37:52Z,2022-02-04T10:02:34Z,MERGED,True,1609,438,18,https://github.com/marcoaccame,Full support of SPI in amc board + driver for AS5045 chip,2,[],https://github.com/robotology/icub-firmware/pull/251,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/251,"This PR much improves the embot::hw::spi driver by giving runtime configurability which matches our needs for the SPI-based absolute encoders we use. I have also developed a draft driver for the SPI-based chip AS5045 which is the one used in our AEA2  absolute encoder.
The embot::hw::spi driver
The idea of the driver is that:

pinout and configuration which do not change after bootstrap are mapped in a constant data structure defined inside embot::hw::spi::bsp
all those configuration which we may change in runtime are passed through a embot:;hw:spi::Config dat structure passed to the embot:;hw:spi::init(...) function.

struct PROP
{
    SPI_Handle* handle {nullptr}; 
    uint32_t clockrate {0};
    std::array<embot::hw::GPIO, SignalsNumberOf> pinout { {} };
    constexpr PROP() = default;
    constexpr PROP(SPI_Handle *h, uint32_t c, std::array<embot::hw::GPIO, SignalsNumberOf> p) 
     : handle(h), clockrate(c), pinout(p) {}
    constexpr PROP(SPI_Handle *h) : handle(h) {} 
    constexpr Speed prescalertospeed(Prescaler p) const { return clockrate >> (1+embot::core::tointegral(p)); } 
    constexpr Prescaler speedtoprescaler(Speed s) const
    { 
        if(s > clockrate/2) return Prescaler::none; 
        for(uint8_t i=0; i<8; i++) { if((clockrate >> (i+1))<=s) return static_cast<Prescaler>(i); }
        return Prescaler::none;
    }; 
};

Code Listing. In here the core constant configuration.
namespace embot { namespace hw { namespace spi { namespace bsp {
SPI_HandleTypeDef hspi1;
constexpr std::array<embot::hw::GPIO, SignalsNumberOf> pinoutspi1 = { {
    {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::nine},     // miso
    {embot::hw::GPIO::PORT::D, embot::hw::GPIO::PIN::seven},    // mosi
    {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::eleven},   // sckl
    {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::ten}       // ssel
} };
constexpr PROP spi1p = { &hspi1, 50*1000*1000, pinoutspi1 }; 
}}}} // namespace embot { namespace hw { namespace spi { namespace bsp {
Code Listing. In here there is how the constant configuration is used inside the BSP of the amc board in for what regards embot::hw::SPI::one.
struct Config
{      
    Prescaler prescaler {Prescaler::none};  
    DataSize datasize {DataSize::none};
    Mode mode {Mode::zero};  
    GPIOspecials gpiospecials {};      
    constexpr Config() = default;
    constexpr Config(Prescaler p, DataSize d, Mode m, const GPIOspecials &g) 
     : prescaler(p), datasize(d), mode(m), gpiospecials(g) {};
    constexpr Config(Prescaler p, DataSize d, Mode m) : prescaler(p), datasize(d), mode(m) {};
    constexpr bool isvalid() const { return (Prescaler::none != prescaler) && (DataSize::none != datasize); }
    void clear() { prescaler = Prescaler::none; datasize = DataSize::none; mode = Mode::zero; gpiospecials.clear(); } 
};

Code Listing. In here the runtime configuration.
constexpr embot::hw::spi::Config cfgM95512DF
{
    embot::hw::spi::Prescaler::eight,   // reduces SPI speed (100M) to have the 12.5 MHz needed by this chip
    embot::hw::spi::DataSize::eight,    // we transfer data in chunks of 8 bits 
    embot::hw::spi::Mode::zero,         // (polarity, phase) = (0, 0)      
    { { // pull modes for MISO, MOSI, SCKL, SSEL
        embot::hw::gpio::Pull::nopull, embot::hw::gpio::Pull::nopull, 
        embot::hw::gpio::Pull::nopull, embot::hw::gpio::Pull::none
    } }        
};
Code Listing. And in here the runtime configuration used for the EEPROM driver.
The SPI driver was tested w/ read and write operations on the onboard EEPROM and w/ dummy read operations on SPI1 / SPI2 / SPI3 which are exposed by connector J5.

Figure. The amc board and the J5 connector
The driver for SPI-based chip AS5045
The driver will be fully tested with a true AEA2  attached to all the three ports of the J5 connector.
This driver, as well as the driver for the EEPROM  chip M95512DF   (see #249), is meant to be used as a template for the future development of drivers of the other SPI-based encoders.
namespace embot { namespace hw { namespace chip {
    
class AS5045
{
  
public:
    
    using POS = uint16_t;
    
    struct Status
    {
        uint32_t todedone {0};
        bool ok {false};
        Status() = default;           
    };
    
    struct Data
    {
        POS position {0};
        Status status {};
        Data() = default;
        bool isvalid() const { return status.ok; }
    }; 

                            
    struct Config
    {   // contains: spi bus and ... tbd            
        embot::hw::SPI spi {embot::hw::SPI::none};
        embot::hw::spi::Config spicfg {};
        constexpr Config() = default;
        constexpr Config(embot::hw::SPI s, const embot::hw::spi::Config &sc) 
            : spi(s), spicfg(sc) {}   
        constexpr bool isvalid() const { 
            return embot::hw::spi::supported(spi); 
        }
    }; 
    
    AS5045();
    ~AS5045();

    bool isinitted() const;
    bool init(const Config &config);  
    bool deinit();
           
    bool read(Data &data, embot::core::relTime timeout);  
    bool read(Data &data, const embot::core::Callback &oncompletion);        

private:        
    struct Impl;
    Impl *pImpl;    
};

}}} // namespace embot { namespace hw { namespace chip {

#define EMBOT_HW_CHIP_AS5045_enable_test   
#if defined(EMBOT_HW_CHIP_AS5045_enable_test)    
namespace embot { namespace hw { namespace chip {
    // it tests the chip and offers an example of use
    bool testof_AS5045();
}}}
#endif

Code listing. The public interface of the AS5045 class is left as minimal as possible. We also add a test function which shows its usage.","This PR much improves the embot::hw::spi driver by giving runtime configurability which matches our needs for the SPI-based absolute encoders we use. I have also developed a draft driver for the SPI-based chip AS5045 which is the one used in our AEA2  absolute encoder.
The embot::hw::spi driver
The idea of the driver is that:

pinout and configuration which do not change after bootstrap are mapped in a constant data structure defined inside embot::hw::spi::bsp
all those configuration which we may change in runtime are passed through a embot:;hw:spi::Config dat structure passed to the embot:;hw:spi::init(...) function.

struct PROP
{
    SPI_Handle* handle {nullptr}; 
    uint32_t clockrate {0};
    std::array<embot::hw::GPIO, SignalsNumberOf> pinout { {} };
    constexpr PROP() = default;
    constexpr PROP(SPI_Handle *h, uint32_t c, std::array<embot::hw::GPIO, SignalsNumberOf> p) 
     : handle(h), clockrate(c), pinout(p) {}
    constexpr PROP(SPI_Handle *h) : handle(h) {} 
    constexpr Speed prescalertospeed(Prescaler p) const { return clockrate >> (1+embot::core::tointegral(p)); } 
    constexpr Prescaler speedtoprescaler(Speed s) const
    { 
        if(s > clockrate/2) return Prescaler::none; 
        for(uint8_t i=0; i<8; i++) { if((clockrate >> (i+1))<=s) return static_cast<Prescaler>(i); }
        return Prescaler::none;
    }; 
};

Code Listing. In here the core constant configuration.
namespace embot { namespace hw { namespace spi { namespace bsp {
SPI_HandleTypeDef hspi1;
constexpr std::array<embot::hw::GPIO, SignalsNumberOf> pinoutspi1 = { {
    {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::nine},     // miso
    {embot::hw::GPIO::PORT::D, embot::hw::GPIO::PIN::seven},    // mosi
    {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::eleven},   // sckl
    {embot::hw::GPIO::PORT::G, embot::hw::GPIO::PIN::ten}       // ssel
} };
constexpr PROP spi1p = { &hspi1, 50*1000*1000, pinoutspi1 }; 
}}}} // namespace embot { namespace hw { namespace spi { namespace bsp {
Code Listing. In here there is how the constant configuration is used inside the BSP of the amc board in for what regards embot::hw::SPI::one.
struct Config
{      
    Prescaler prescaler {Prescaler::none};  
    DataSize datasize {DataSize::none};
    Mode mode {Mode::zero};  
    GPIOspecials gpiospecials {};      
    constexpr Config() = default;
    constexpr Config(Prescaler p, DataSize d, Mode m, const GPIOspecials &g) 
     : prescaler(p), datasize(d), mode(m), gpiospecials(g) {};
    constexpr Config(Prescaler p, DataSize d, Mode m) : prescaler(p), datasize(d), mode(m) {};
    constexpr bool isvalid() const { return (Prescaler::none != prescaler) && (DataSize::none != datasize); }
    void clear() { prescaler = Prescaler::none; datasize = DataSize::none; mode = Mode::zero; gpiospecials.clear(); } 
};

Code Listing. In here the runtime configuration.
constexpr embot::hw::spi::Config cfgM95512DF
{
    embot::hw::spi::Prescaler::eight,   // reduces SPI speed (100M) to have the 12.5 MHz needed by this chip
    embot::hw::spi::DataSize::eight,    // we transfer data in chunks of 8 bits 
    embot::hw::spi::Mode::zero,         // (polarity, phase) = (0, 0)      
    { { // pull modes for MISO, MOSI, SCKL, SSEL
        embot::hw::gpio::Pull::nopull, embot::hw::gpio::Pull::nopull, 
        embot::hw::gpio::Pull::nopull, embot::hw::gpio::Pull::none
    } }        
};
Code Listing. And in here the runtime configuration used for the EEPROM driver.
The SPI driver was tested w/ read and write operations on the onboard EEPROM and w/ dummy read operations on SPI1 / SPI2 / SPI3 which are exposed by connector J5.

Figure. The amc board and the J5 connector
The driver for SPI-based chip AS5045
The driver will be fully tested with a true AEA2  attached to all the three ports of the J5 connector.
This driver, as well as the driver for the EEPROM  chip M95512DF   (see #249), is meant to be used as a template for the future development of drivers of the other SPI-based encoders.
namespace embot { namespace hw { namespace chip {
    
class AS5045
{
  
public:
    
    using POS = uint16_t;
    
    struct Status
    {
        uint32_t todedone {0};
        bool ok {false};
        Status() = default;           
    };
    
    struct Data
    {
        POS position {0};
        Status status {};
        Data() = default;
        bool isvalid() const { return status.ok; }
    }; 

                            
    struct Config
    {   // contains: spi bus and ... tbd            
        embot::hw::SPI spi {embot::hw::SPI::none};
        embot::hw::spi::Config spicfg {};
        constexpr Config() = default;
        constexpr Config(embot::hw::SPI s, const embot::hw::spi::Config &sc) 
            : spi(s), spicfg(sc) {}   
        constexpr bool isvalid() const { 
            return embot::hw::spi::supported(spi); 
        }
    }; 
    
    AS5045();
    ~AS5045();

    bool isinitted() const;
    bool init(const Config &config);  
    bool deinit();
           
    bool read(Data &data, embot::core::relTime timeout);  
    bool read(Data &data, const embot::core::Callback &oncompletion);        

private:        
    struct Impl;
    Impl *pImpl;    
};

}}} // namespace embot { namespace hw { namespace chip {

#define EMBOT_HW_CHIP_AS5045_enable_test   
#if defined(EMBOT_HW_CHIP_AS5045_enable_test)    
namespace embot { namespace hw { namespace chip {
    // it tests the chip and offers an example of use
    bool testof_AS5045();
}}}
#endif

Code listing. The public interface of the AS5045 class is left as minimal as possible. We also add a test function which shows its usage.",True,{'HEART': ['https://github.com/sgiraz']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,252,2022-02-18T11:26:20Z,2022-02-18T15:44:02Z,2022-02-18T15:44:02Z,MERGED,True,619,304,11,https://github.com/marcoaccame,Support of the embot::hw::can driver on board amc,5,[],https://github.com/robotology/icub-firmware/pull/252,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/252,"This PR adds CAN communication for the board amc using the embot::hw::can driver. Both embot::hw::CAN::one and  embot::hw::CAN::two are supported.
The changes can be safely merged as they touch only code parts used by the amc board. and the driver was tested w/ a test program as described below.
CAN demo
Here is a nice CAN demo running on the amc board.
The two ports J11 and J12 are connected together w/ a CAN cable.

Figure. The amc board w/ a cable which connects CAN1 and CAN2 through J11 and J12.
We ask the amc board to transmit a burst of n = 2 CAN frames every 3 seconds out of port J11. The n frames are received by the board in port J12, decoded and n replies are sent back w/ the size of each received frame.

Figure. Sequence diagram for the CAN transmission flow.
In here the prints of the test program.
this is a demo which shows that this code can run on a dev board. clock = 400 MHz
starting the INIT thread
INIT: creating the system services: timer manager + callback manager
INIT: creating the LED pulser: it will blink a LED at 1 Hz and run a 0.2 Hz waveform on another
INIT: creating the main thread. it will reveives one periodic tick event and one upon pressure of the blue button
initting two threads, each one managing a different embot::hw::CAN
quitting the INIT thread. Normal scheduling starts
mainthread-startup: started timer which sends evtTick to evthread every = S1:m0:u0
tCAN2: started CAN2 driver
tCAN1: started timer triggers CAN communication every = S3:m0:u0
tCAN1: started CAN1 driver
 
-------------------------------------------------------------------------
tCAN1 -> START OF transmissions from CAN1 to CAN2 and back to CAN1
-------------------------------------------------------------------------
tCAN1: evtCAN1tx received @ time = D0:H0:M0:S3:m21:u6
tCAN1: will now transmit on CAN1 a burst of 2 frames w/ data[0] = 2 and decreasing sizes
tCAN1: tx frame w/ size = 8
tCAN1: tx frame w/ size = 7
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S3:m21:u847
tCAN2: decoded frame w/ [id size {payload} ] = 2, 8, [2, 3, 5, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S3:m22:u219
tCAN2: decoded frame w/ [id size {payload} ] = 2, 7, [2, 3, 5, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S3:m22:u597
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [8, 0, 0, ...} ]
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S3:m22:u830
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [7, 0, 0, ...} ]
 
 
-------------------------------------------------------------------------
tCAN1 -> START OF transmissions from CAN1 to CAN2 and back to CAN1
-------------------------------------------------------------------------
tCAN1: evtCAN1tx received @ time = D0:H0:M0:S6:m21:u6
tCAN1: will now transmit on CAN1 a burst of 2 frames w/ data[0] = 3 and decreasing sizes
tCAN1: tx frame w/ size = 8
tCAN1: tx frame w/ size = 7
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S6:m21:u845
tCAN2: decoded frame w/ [id size {payload} ] = 2, 8, [3, 4, 6, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S6:m22:u216
tCAN2: decoded frame w/ [id size {payload} ] = 2, 7, [3, 4, 6, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S6:m22:u594
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [8, 0, 0, ...} ]
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S6:m22:u827
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [7, 0, 0, ...} ]","This PR adds CAN communication for the board amc using the embot::hw::can driver. Both embot::hw::CAN::one and  embot::hw::CAN::two are supported.
The changes can be safely merged as they touch only code parts used by the amc board. and the driver was tested w/ a test program as described below.
CAN demo
Here is a nice CAN demo running on the amc board.
The two ports J11 and J12 are connected together w/ a CAN cable.

Figure. The amc board w/ a cable which connects CAN1 and CAN2 through J11 and J12.
We ask the amc board to transmit a burst of n = 2 CAN frames every 3 seconds out of port J11. The n frames are received by the board in port J12, decoded and n replies are sent back w/ the size of each received frame.

Figure. Sequence diagram for the CAN transmission flow.
In here the prints of the test program.
this is a demo which shows that this code can run on a dev board. clock = 400 MHz
starting the INIT thread
INIT: creating the system services: timer manager + callback manager
INIT: creating the LED pulser: it will blink a LED at 1 Hz and run a 0.2 Hz waveform on another
INIT: creating the main thread. it will reveives one periodic tick event and one upon pressure of the blue button
initting two threads, each one managing a different embot::hw::CAN
quitting the INIT thread. Normal scheduling starts
mainthread-startup: started timer which sends evtTick to evthread every = S1:m0:u0
tCAN2: started CAN2 driver
tCAN1: started timer triggers CAN communication every = S3:m0:u0
tCAN1: started CAN1 driver
 
-------------------------------------------------------------------------
tCAN1 -> START OF transmissions from CAN1 to CAN2 and back to CAN1
-------------------------------------------------------------------------
tCAN1: evtCAN1tx received @ time = D0:H0:M0:S3:m21:u6
tCAN1: will now transmit on CAN1 a burst of 2 frames w/ data[0] = 2 and decreasing sizes
tCAN1: tx frame w/ size = 8
tCAN1: tx frame w/ size = 7
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S3:m21:u847
tCAN2: decoded frame w/ [id size {payload} ] = 2, 8, [2, 3, 5, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S3:m22:u219
tCAN2: decoded frame w/ [id size {payload} ] = 2, 7, [2, 3, 5, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S3:m22:u597
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [8, 0, 0, ...} ]
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S3:m22:u830
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [7, 0, 0, ...} ]
 
 
-------------------------------------------------------------------------
tCAN1 -> START OF transmissions from CAN1 to CAN2 and back to CAN1
-------------------------------------------------------------------------
tCAN1: evtCAN1tx received @ time = D0:H0:M0:S6:m21:u6
tCAN1: will now transmit on CAN1 a burst of 2 frames w/ data[0] = 3 and decreasing sizes
tCAN1: tx frame w/ size = 8
tCAN1: tx frame w/ size = 7
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S6:m21:u845
tCAN2: decoded frame w/ [id size {payload} ] = 2, 8, [3, 4, 6, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN2: evtCAN2rx received @ time = D0:H0:M0:S6:m22:u216
tCAN2: decoded frame w/ [id size {payload} ] = 2, 7, [3, 4, 6, ...} ]
tCAN2: and now sending back a short reply on CAN2 w/ payload[0] = size of rx frame
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S6:m22:u594
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [8, 0, 0, ...} ]
 
tCAN1: evtCAN1rx received @ time = D0:H0:M0:S6:m22:u827
tCAN1: decoded frame w/ [id size {payload} ] = 1, 1, [7, 0, 0, ...} ]",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,253,2022-02-22T10:52:18Z,2022-03-01T10:50:37Z,2022-03-02T19:53:28Z,MERGED,True,769,690,25,https://github.com/sgiraz,AMC_BLDC: Update codegen + Fix initialization of htim2.Init.Period,4,['enhancement'],https://github.com/robotology/icub-firmware/pull/253,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/253,"What changes in this PR:

The generated code now contains the addition of the SW Current Limiter that aims to limit the current when it exceeds the Peak Limit Ipeak.
The encoder configuration is now initialized using the MainConf.pwm.poles instead of the hardcoded value

Notes:
The code has been tested successfully on the ems-amc_bldc-wrist-setup.
cc @pattacini","What changes in this PR:

The generated code now contains the addition of the SW Current Limiter that aims to limit the current when it exceeds the Peak Limit Ipeak.
The encoder configuration is now initialized using the MainConf.pwm.poles instead of the hardcoded value

Notes:
The code has been tested successfully on the ems-amc_bldc-wrist-setup.
cc @pattacini",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,253,2022-02-22T10:52:18Z,2022-03-01T10:50:37Z,2022-03-02T19:53:28Z,MERGED,True,769,690,25,https://github.com/sgiraz,AMC_BLDC: Update codegen + Fix initialization of htim2.Init.Period,4,['enhancement'],https://github.com/robotology/icub-firmware/pull/253,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/253#issuecomment-1050065068,"What changes in this PR:

The generated code now contains the addition of the SW Current Limiter that aims to limit the current when it exceeds the Peak Limit Ipeak.
The encoder configuration is now initialized using the MainConf.pwm.poles instead of the hardcoded value

Notes:
The code has been tested successfully on the ems-amc_bldc-wrist-setup.
cc @pattacini","Hi @sgiraz
We need to regenerate the code from the model as we fixed the bug on the SW Current Limiter.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,253,2022-02-22T10:52:18Z,2022-03-01T10:50:37Z,2022-03-02T19:53:28Z,MERGED,True,769,690,25,https://github.com/sgiraz,AMC_BLDC: Update codegen + Fix initialization of htim2.Init.Period,4,['enhancement'],https://github.com/robotology/icub-firmware/pull/253,https://github.com/sgiraz,3,https://github.com/robotology/icub-firmware/pull/253#issuecomment-1050864389,"What changes in this PR:

The generated code now contains the addition of the SW Current Limiter that aims to limit the current when it exceeds the Peak Limit Ipeak.
The encoder configuration is now initialized using the MainConf.pwm.poles instead of the hardcoded value

Notes:
The code has been tested successfully on the ems-amc_bldc-wrist-setup.
cc @pattacini","Hi @pattacini, the codegen has been updated to the last changes on study-amc-bldc@master.
I'll perform a quick test next Monday, then I think this PR can be safely merged.",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,253,2022-02-22T10:52:18Z,2022-03-01T10:50:37Z,2022-03-02T19:53:28Z,MERGED,True,769,690,25,https://github.com/sgiraz,AMC_BLDC: Update codegen + Fix initialization of htim2.Init.Period,4,['enhancement'],https://github.com/robotology/icub-firmware/pull/253,https://github.com/sgiraz,4,https://github.com/robotology/icub-firmware/pull/253#issuecomment-1054067779,"What changes in this PR:

The generated code now contains the addition of the SW Current Limiter that aims to limit the current when it exceeds the Peak Limit Ipeak.
The encoder configuration is now initialized using the MainConf.pwm.poles instead of the hardcoded value

Notes:
The code has been tested successfully on the ems-amc_bldc-wrist-setup.
cc @pattacini","application06 well tested with the new changes!
@marcoaccame feel free to merge!
cc @pattacini",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,253,2022-02-22T10:52:18Z,2022-03-01T10:50:37Z,2022-03-02T19:53:28Z,MERGED,True,769,690,25,https://github.com/sgiraz,AMC_BLDC: Update codegen + Fix initialization of htim2.Init.Period,4,['enhancement'],https://github.com/robotology/icub-firmware/pull/253,https://github.com/pattacini,5,https://github.com/robotology/icub-firmware/pull/253#issuecomment-1055295379,"What changes in this PR:

The generated code now contains the addition of the SW Current Limiter that aims to limit the current when it exceeds the Peak Limit Ipeak.
The encoder configuration is now initialized using the MainConf.pwm.poles instead of the hardcoded value

Notes:
The code has been tested successfully on the ems-amc_bldc-wrist-setup.
cc @pattacini",I think we can safely merge the PR as it mostly pertains to changes done to the codegen.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,254,2022-02-23T11:22:26Z,2022-03-07T16:27:35Z,2022-03-07T16:27:35Z,MERGED,True,49,33,9,https://github.com/sgiraz,Add support for viscousPos/Neg and coulombPos/Neg friction parameters,6,['Status: In Progress'],https://github.com/robotology/icub-firmware/pull/254,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/254,"What's new in this PR:

When the MController_config_joint is triggered, now it is able to manage the new friction parameters (viscous and coulomb) properly.

Note:

 We still need to clarify how we should handle the size of ROP in EOMtheEMSapplCfg_cfg.h
Code tested successfully on a custom single joint setup (mc4plus + DC motor + aea2)
Code tested successfully on iCubGenova02 ","What's new in this PR:

When the MController_config_joint is triggered, now it is able to manage the new friction parameters (viscous and coulomb) properly.

Note:

 We still need to clarify how we should handle the size of ROP in EOMtheEMSapplCfg_cfg.h
Code tested successfully on a custom single joint setup (mc4plus + DC motor + aea2)
Code tested successfully on iCubGenova02 ",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,254,2022-02-23T11:22:26Z,2022-03-07T16:27:35Z,2022-03-07T16:27:35Z,MERGED,True,49,33,9,https://github.com/sgiraz,Add support for viscousPos/Neg and coulombPos/Neg friction parameters,6,['Status: In Progress'],https://github.com/robotology/icub-firmware/pull/254,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/254#issuecomment-1060878292,"What's new in this PR:

When the MController_config_joint is triggered, now it is able to manage the new friction parameters (viscous and coulomb) properly.

Note:

 We still need to clarify how we should handle the size of ROP in EOMtheEMSapplCfg_cfg.h
Code tested successfully on a custom single joint setup (mc4plus + DC motor + aea2)
Code tested successfully on iCubGenova02 ","This PR is to be merged as whole with all these PRs:

robotology/icub-firmware-shared#57
#254
robotology/icub-firmware-build#49",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,255,2022-03-03T18:14:49Z,2022-03-07T08:55:29Z,2022-03-08T08:40:06Z,MERGED,True,20360,0,72,https://github.com/sgiraz,AMC_BLDC: Add application07,1,[],https://github.com/robotology/icub-firmware/pull/255,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/255,"What's new in this PR:

A new application07 project folder is now available to be used with both Lego-setup and Wrist-setup.

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini @ale-git","What's new in this PR:

A new application07 project folder is now available to be used with both Lego-setup and Wrist-setup.

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini @ale-git",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,255,2022-03-03T18:14:49Z,2022-03-07T08:55:29Z,2022-03-08T08:40:06Z,MERGED,True,20360,0,72,https://github.com/sgiraz,AMC_BLDC: Add application07,1,[],https://github.com/robotology/icub-firmware/pull/255,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/255#issuecomment-1059302520,"What's new in this PR:

A new application07 project folder is now available to be used with both Lego-setup and Wrist-setup.

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini @ale-git","The work @ale-git is doing on the HAL is almost landing, but I deem we can merge this PR straight away in the meantime.
Can we?
@sgiraz @marcoaccame",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,256,2022-03-09T10:51:04Z,2022-03-09T10:52:50Z,2022-03-09T10:52:50Z,MERGED,True,0,0,1,https://github.com/pattacini,CAN protocol for MC boards,1,[],https://github.com/robotology/icub-firmware/pull/256,https://github.com/pattacini,1,https://github.com/robotology/icub-firmware/pull/256,This PR adds up the CAN protocol for the MC boards.,This PR adds up the CAN protocol for the MC boards.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,257,2022-03-14T15:40:09Z,2022-03-18T10:23:40Z,2022-03-18T10:23:40Z,MERGED,True,6565,386,41,https://github.com/marcoaccame,FT service with multiple sensors,13,[],https://github.com/robotology/icub-firmware/pull/257,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/257,"Description
This PR with its companion PRs in icub-firmware-shared and icub-firmware-build allow an ETH board such as the ems, mc4plus, mc2plus to stream FT data and associated temperature coming from one, two or more CAN FT sensor boards such as the strain2 or the strain.
The changes generated by the above triad of PRs (icub-firmware, icub-firmware-shared, icub-firmware-build) can coexist safely with current release of icub-main/devel, even if the multiple FT service cannot be activated yet.
In order to see the multiple streams at YARP level, we need to add in icub-main the device embObjMultipleFTsensors with a PR which will be soon made available.
So far, I have done extensive tests on a dedicated setup to verify the following.

backwards compatibility. yarprobotinterface if compiled w/ icub-firmware-shared of the companion PR can safely run:

a standard FT service on an ems board,
a MC service on an mc4plus board driving a single motor.


capability of streaming from multiple sensor boards.  An ems board with two strain2 attached has run a simulation where the object embot::app::eth::theFTserviceTester was faking the presence of embObjMultipleFTsensors. The result was that the new object embot::app::eth::theFTservice was correctly activated and deactivated as if yarprobotinterface were present.
verification of transmission from the sensor boards.  The embot::app::eth::theFTservice object runs also a new embot::app::eth::CANmonitor service which is able to check if the required CAN boards transmits regularly. The CANmonitor can be configured to check at a given rate and to send diagnostics messages in various modes, from minimal to fully pedantic.

More details
Here are the more details on how the embot::app::eth::theFTservice can be configured at xml level and what FT sensors data sends up to yarprobotinterface.
    <group name=""SERVICE"">
        
        <param name=""type""> eomn_serv_AS_ft </param>
    
        <group name=""PROPERTIES"">

            <!-- we can have as many boards as we want, 
                 but now the only good ones are strain and strain2. 
                 use eoas_ft_isboardvalid() to verify -->
            <group name=""CANBOARDS"">
                <param name=""type"">                 strain2     strain      </param>

                <group name=""PROTOCOL"">
                    <param name=""major"">            2           1           </param>    
                    <param name=""minor"">            0           0           </param>     
                </group>                    
                <group name=""FIRMWARE"">
                    <param name=""major"">            2           1           </param>    
                    <param name=""minor"">            0           1           </param> 
                    <param name=""build"">            9           3           </param>
                </group>
            </group>
            
            <!-- we can have as many sensors as we want. however ... -->
            <group name=""SENSORS"">
                <param name=""id"">                   l_foot_ft1      l_foot_ft2      l_foot_ft3  </param>
                <param name=""board"">                strain2         strain2         strain      </param>
                <param name=""location"">             CAN2:13         CAN1:12         CAN2:11     </param>
            </group>                
        
        </group>

        <!-- we can pick up at max 4 sensors from the above list. 
             we can specify parameters which are different for each sensor 
             - ftPeriod is expressed in ms in range [1, 250]
             - temperaturePeriod is expressed in ms (but it will be used in seconds).
             - useCalibration is boolean
             -->
        <group name=""SETTINGS"">        
            <param name=""enabledSensors"">       l_foot_ft1  l_foot_ft2  l_foot_ft3      </param>
            <param name=""ftPeriod"">             10          10          10              </param>
            <param name=""temperaturePeriod"">    1000        1000        0               </param>
            <param name=""useCalibration"">       true        false       true            </param>           
        </group>       
     
        <group name=""CANMONITOR"">        
            <param name=""checkPeriod"">      100     </param>
            <param name=""reportMode"">       ALL     </param>
            <param name=""ratePeriod"">       20*1000 </param>
        </group>    
     
    </group>
Code Listing. Configuration of the multiple FT service. In this case, we ask FT data from three sensors each with a period of 10 ms (but we could also specify a different period for each). Two sensors stream calibrated data, one uncalibrated. Two sensors also stream temperature at 1 second period.
<!-- CANMONITOR tells the ETH board how to verify the continuous presence of the
     CAN boards which are required for the service and how to report to
     yarprobotinterface w/ suitable diagnostics messages.
     Here are the parameters.

     - checkPeriod: in milliseconds in range [0, 255]. It is the period at which the 
       ETH board monitors if all CAN boards are present in the bus. 
       If 0 there is no monitoring
     - reportMode: it tells how the ETH board sends up diagnostics messages on
       the result of its monitoring. The following string values are allowed:
       - NEVER: the ETH board never sends a diagnostic message about the monitoring status)
       - justLOSTjustFOUND: sends diagnostics only when boards disappears and when
         they reappers.
       - justLOSTjustFOUNDstillLOST: as justLOSTjustFOUND but the ETH board also sends 
         periodic diagnostics if boards are still found but with a rate of 
         reportPeriod millisec.
       - ALL: as justLOSTjustFOUNDstillLOST but the ETH board also sends periodic diagnostics
         even if all boards are present.
     - reportPeriod: the period in milliseconds at which the ETH board sends diagnostics messages
       in case the CAN boards are still missing or even if they are present. This
       value has meaning only if reportmode is justLOSTjustFOUNDstillLOST or
       justLOSTjustFOUNDstillLOST. Values to use are in range [1000, 64*1024-1] 
  -->
<group name=""CANMONITOR"">        
    <param name=""checkPeriod"">      100     </param>
    <param name=""reportMode"">       ALL     </param>
    <param name=""ratePeriod"">       20*1000 </param>
</group>  
Code Listing. Configuration of the CAN monitor. In this case, we check vs presence of the CAN boards every 100 ms, we report with diagnostics messages every 20 sec if boards are all OK, with one immediate message if any goes away or if it returns and every 20 sec if they should not be back.
typedef struct
{
    // timeoflife in usec. better using this because yarp may ask the board to have its time
    eOabstime_t             age;      
    // ffu ... used-calib-set, saturated info, calib/notcalib, candata-not-heard-of-since-ms-ago, 
    uint32_t                info;         
    uint16_t                ffu;
    // in steps of 0.1 celsius degree (pos and neg).
    eOmeas_temperature_t    temperature; 
    // they may be [f, t] or also the 6 adc values or also ... see info.     
    float32_t               values[6];       
} eOas_ft_timedvalue_t;     EO_VERIFYsizeof(eOas_ft_timedvalue_t, 40)
Code Listing. The FT service streams up to yarprobotinterface the 40 bytes of eOas_ft_timedvalue_t for each FT sensor. The six FT values are in floating point format so that we are ready for future better precision in the CAN sensor. They can contain either calibrated or raw values.  We also have the temperature and the acquisition time of the FT values. There are also several bits which may be useful later on for extra signalling / diagnostics (i.e., for indicating presence of saturation, type of calibration used etc.).
What's next
As a result of the backwards compatibility tests reported above, I believe that these three PRs can be safely merged. When the new PR on icub-main is ready we can perform more tests on dedicated setup and on the robot.","Description
This PR with its companion PRs in icub-firmware-shared and icub-firmware-build allow an ETH board such as the ems, mc4plus, mc2plus to stream FT data and associated temperature coming from one, two or more CAN FT sensor boards such as the strain2 or the strain.
The changes generated by the above triad of PRs (icub-firmware, icub-firmware-shared, icub-firmware-build) can coexist safely with current release of icub-main/devel, even if the multiple FT service cannot be activated yet.
In order to see the multiple streams at YARP level, we need to add in icub-main the device embObjMultipleFTsensors with a PR which will be soon made available.
So far, I have done extensive tests on a dedicated setup to verify the following.

backwards compatibility. yarprobotinterface if compiled w/ icub-firmware-shared of the companion PR can safely run:

a standard FT service on an ems board,
a MC service on an mc4plus board driving a single motor.


capability of streaming from multiple sensor boards.  An ems board with two strain2 attached has run a simulation where the object embot::app::eth::theFTserviceTester was faking the presence of embObjMultipleFTsensors. The result was that the new object embot::app::eth::theFTservice was correctly activated and deactivated as if yarprobotinterface were present.
verification of transmission from the sensor boards.  The embot::app::eth::theFTservice object runs also a new embot::app::eth::CANmonitor service which is able to check if the required CAN boards transmits regularly. The CANmonitor can be configured to check at a given rate and to send diagnostics messages in various modes, from minimal to fully pedantic.

More details
Here are the more details on how the embot::app::eth::theFTservice can be configured at xml level and what FT sensors data sends up to yarprobotinterface.
    <group name=""SERVICE"">
        
        <param name=""type""> eomn_serv_AS_ft </param>
    
        <group name=""PROPERTIES"">

            <!-- we can have as many boards as we want, 
                 but now the only good ones are strain and strain2. 
                 use eoas_ft_isboardvalid() to verify -->
            <group name=""CANBOARDS"">
                <param name=""type"">                 strain2     strain      </param>

                <group name=""PROTOCOL"">
                    <param name=""major"">            2           1           </param>    
                    <param name=""minor"">            0           0           </param>     
                </group>                    
                <group name=""FIRMWARE"">
                    <param name=""major"">            2           1           </param>    
                    <param name=""minor"">            0           1           </param> 
                    <param name=""build"">            9           3           </param>
                </group>
            </group>
            
            <!-- we can have as many sensors as we want. however ... -->
            <group name=""SENSORS"">
                <param name=""id"">                   l_foot_ft1      l_foot_ft2      l_foot_ft3  </param>
                <param name=""board"">                strain2         strain2         strain      </param>
                <param name=""location"">             CAN2:13         CAN1:12         CAN2:11     </param>
            </group>                
        
        </group>

        <!-- we can pick up at max 4 sensors from the above list. 
             we can specify parameters which are different for each sensor 
             - ftPeriod is expressed in ms in range [1, 250]
             - temperaturePeriod is expressed in ms (but it will be used in seconds).
             - useCalibration is boolean
             -->
        <group name=""SETTINGS"">        
            <param name=""enabledSensors"">       l_foot_ft1  l_foot_ft2  l_foot_ft3      </param>
            <param name=""ftPeriod"">             10          10          10              </param>
            <param name=""temperaturePeriod"">    1000        1000        0               </param>
            <param name=""useCalibration"">       true        false       true            </param>           
        </group>       
     
        <group name=""CANMONITOR"">        
            <param name=""checkPeriod"">      100     </param>
            <param name=""reportMode"">       ALL     </param>
            <param name=""ratePeriod"">       20*1000 </param>
        </group>    
     
    </group>
Code Listing. Configuration of the multiple FT service. In this case, we ask FT data from three sensors each with a period of 10 ms (but we could also specify a different period for each). Two sensors stream calibrated data, one uncalibrated. Two sensors also stream temperature at 1 second period.
<!-- CANMONITOR tells the ETH board how to verify the continuous presence of the
     CAN boards which are required for the service and how to report to
     yarprobotinterface w/ suitable diagnostics messages.
     Here are the parameters.

     - checkPeriod: in milliseconds in range [0, 255]. It is the period at which the 
       ETH board monitors if all CAN boards are present in the bus. 
       If 0 there is no monitoring
     - reportMode: it tells how the ETH board sends up diagnostics messages on
       the result of its monitoring. The following string values are allowed:
       - NEVER: the ETH board never sends a diagnostic message about the monitoring status)
       - justLOSTjustFOUND: sends diagnostics only when boards disappears and when
         they reappers.
       - justLOSTjustFOUNDstillLOST: as justLOSTjustFOUND but the ETH board also sends 
         periodic diagnostics if boards are still found but with a rate of 
         reportPeriod millisec.
       - ALL: as justLOSTjustFOUNDstillLOST but the ETH board also sends periodic diagnostics
         even if all boards are present.
     - reportPeriod: the period in milliseconds at which the ETH board sends diagnostics messages
       in case the CAN boards are still missing or even if they are present. This
       value has meaning only if reportmode is justLOSTjustFOUNDstillLOST or
       justLOSTjustFOUNDstillLOST. Values to use are in range [1000, 64*1024-1] 
  -->
<group name=""CANMONITOR"">        
    <param name=""checkPeriod"">      100     </param>
    <param name=""reportMode"">       ALL     </param>
    <param name=""ratePeriod"">       20*1000 </param>
</group>  
Code Listing. Configuration of the CAN monitor. In this case, we check vs presence of the CAN boards every 100 ms, we report with diagnostics messages every 20 sec if boards are all OK, with one immediate message if any goes away or if it returns and every 20 sec if they should not be back.
typedef struct
{
    // timeoflife in usec. better using this because yarp may ask the board to have its time
    eOabstime_t             age;      
    // ffu ... used-calib-set, saturated info, calib/notcalib, candata-not-heard-of-since-ms-ago, 
    uint32_t                info;         
    uint16_t                ffu;
    // in steps of 0.1 celsius degree (pos and neg).
    eOmeas_temperature_t    temperature; 
    // they may be [f, t] or also the 6 adc values or also ... see info.     
    float32_t               values[6];       
} eOas_ft_timedvalue_t;     EO_VERIFYsizeof(eOas_ft_timedvalue_t, 40)
Code Listing. The FT service streams up to yarprobotinterface the 40 bytes of eOas_ft_timedvalue_t for each FT sensor. The six FT values are in floating point format so that we are ready for future better precision in the CAN sensor. They can contain either calibrated or raw values.  We also have the temperature and the acquisition time of the FT values. There are also several bits which may be useful later on for extra signalling / diagnostics (i.e., for indicating presence of saturation, type of calibration used etc.).
What's next
As a result of the backwards compatibility tests reported above, I believe that these three PRs can be safely merged. When the new PR on icub-main is ready we can perform more tests on dedicated setup and on the robot.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,258,2022-03-16T16:10:44Z,2022-03-16T18:07:19Z,2022-03-18T16:45:33Z,MERGED,True,80,71,27,https://github.com/sgiraz,AMC_BLDC: Update codegen with the last changes on architectural model,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/258,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/258,"What's new in this PR:

Update the prints in application07/src/embot_app_application_theMBDagent.cpp.
Update codegen containing the fix of the encoded velocity in icubdeg/ms.
[In Progress]: Update codegen with the strategy to use to optimize the FOC output.

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini","What's new in this PR:

Update the prints in application07/src/embot_app_application_theMBDagent.cpp.
Update codegen containing the fix of the encoded velocity in icubdeg/ms.
[In Progress]: Update codegen with the strategy to use to optimize the FOC output.

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,258,2022-03-16T16:10:44Z,2022-03-16T18:07:19Z,2022-03-18T16:45:33Z,MERGED,True,80,71,27,https://github.com/sgiraz,AMC_BLDC: Update codegen with the last changes on architectural model,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/258,https://github.com/pattacini,2,https://github.com/robotology/icub-firmware/pull/258#issuecomment-1069403919,"What's new in this PR:

Update the prints in application07/src/embot_app_application_theMBDagent.cpp.
Update codegen containing the fix of the encoded velocity in icubdeg/ms.
[In Progress]: Update codegen with the strategy to use to optimize the FOC output.

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini","[In Progress]: Update codegen with the strategy to use to optimize the FOC output.

We can keep the current strategy and possibly open up a second PR for updating it.
Thus, I've made the PR ready for review.",True,{'THUMBS_UP': ['https://github.com/sgiraz']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,259,2022-03-24T16:35:33Z,2022-03-24T16:36:56Z,2022-03-24T16:36:56Z,MERGED,True,301,162,4,https://github.com/marcoaccame,ems / mc4plus: adapted projects for the new wrist / hand to compile C++ files,1,[],https://github.com/robotology/icub-firmware/pull/259,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/259,ems / mc4plus: adapted projects for the new wrist / hand to compile the C++ files added in previous PR #257,ems / mc4plus: adapted projects for the new wrist / hand to compile the C++ files added in previous PR #257,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,260,2022-03-31T10:28:16Z,2022-04-04T07:19:46Z,2022-04-04T07:19:46Z,MERGED,True,4113,1474,58,https://github.com/marcoaccame,ETH driver for the amc board,7,[],https://github.com/robotology/icub-firmware/pull/260,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/260,"This PR adds an ETH driver for the amc board which enables:

UDP communication using IPAL but also higher layers such as EOsocketDatagram via EOMtheIPnet,
reading of ETH diagnostics from the chip KSZ8563.

Tests
The functionalities of the driver were tested through several test applications. From the most basic to the most complex:


board/amc/examples/basicping: it runs a bare metal application which just .. allows a host configured as icub-head (fixed IP address 10.0.1.104 and netmask 255.255.255.0) to ping the board
shell-1 $ ping 10.0.1.99


board/amc/examples/udpdemobasic: it runs an RTOS application based onto embot with some threads. One just runs the IPAL stack, another manages a IPAL UDP socket listening at port 3333, and the third manages diagnostics from chip KSZ8563. You can ping the board or send a UDP frame to it with a dedicated application (e.g, w/ netcat).


board/amc/examples/udpdemoipnet: it runs an RTOS application based onto embot which runs the EOMtheIPnet and allows to use the objects EOsocketDatagram to offer the same socket services available on the ems. In here we have one server thread listing on port 3333 which replies to receptions, a thread which reads diagnostics, LEDs switched on and off if link is UP or DOWN etc.  Just read board/amc/examples/udpdemoipnet/docs/the udpdemo IPnet project.md to know more or .. you can launch this command on a PC configured as a icub-head and ... digit messages.
shell-1a $ netcat -u 10.0.1.99 -p 11111 3333


Impact of this PR
This PR touches only files used by the amc, hence it can be safely merged w/out further tests on the robot.
Further details on the ETH driver
The IP communication is possible by properly filling the ipal_cfg2_eth_t struct of IPAL with functions defined in namespace embot::hw::eth, for instance as in the following code listing.
constexpr ipal_cfg2_eth_t ethcfg2 =
{
    .eth_mac = IPAL_mac48addr(0x1E,0x30,0x6C,0xA2,0x45,0x5E),
    .eth_ip = IPAL_ipv4addr(10, 0, 1, 99),
    .eth_mask = IPAL_ipv4addr(255, 255, 255, 0),
    .eth_isrpriority = 0,
    .filler = {0, 0, 0, 0, 0, 0, 0},
    .hal_eth_init = embot::hw::eth::init,
    .hal_eth_enable = embot::hw::eth::enable,
    .hal_eth_disable = embot::hw::eth::disable,
    .hal_eth_sendframe = embot::hw::eth::sendframe,
    .get_frame_size = embot::hw::eth::get_frame_size,
    .get_frame = embot::hw::eth::get_frame       
};
Code Listing. The initialization of IPAL used in amc board.
Inside the above functions in embot::hw::eth the driver works simply with a proper initialization of RMII interface of the MPU,  of the pins of the KSZ8563 switch,  the use of a specific memory mapping for the ETH buffers and the aid of a ARM_DRIVER_ETH_MAC driver properly modified.
These low level operations are done in several places, as the following table reports.



Module
Place
Comments




Initialization of pins and RMII
inside MX_GPIO_Init() and MX_ETH_Init()
called inside initialization of stm32hal and inside embot::hw::eth::init()


Use of memory mapping
with the scatter file used in the test projects



adapted driverARM_DRIVER_ETH_MAC 
inside amc/bsp/ethdriver









The retrieval of diagnostic information requires SPI communication w/ the KSZ8563 switch. All that is done entirely in the embot environment by means of embot::hw::eth functions which use embot::hw::chip::KSZ8563 which uses the standard embot::hw::spi functions that we use for EEPROM and AEA encoder reading.","This PR adds an ETH driver for the amc board which enables:

UDP communication using IPAL but also higher layers such as EOsocketDatagram via EOMtheIPnet,
reading of ETH diagnostics from the chip KSZ8563.

Tests
The functionalities of the driver were tested through several test applications. From the most basic to the most complex:


board/amc/examples/basicping: it runs a bare metal application which just .. allows a host configured as icub-head (fixed IP address 10.0.1.104 and netmask 255.255.255.0) to ping the board
shell-1 $ ping 10.0.1.99


board/amc/examples/udpdemobasic: it runs an RTOS application based onto embot with some threads. One just runs the IPAL stack, another manages a IPAL UDP socket listening at port 3333, and the third manages diagnostics from chip KSZ8563. You can ping the board or send a UDP frame to it with a dedicated application (e.g, w/ netcat).


board/amc/examples/udpdemoipnet: it runs an RTOS application based onto embot which runs the EOMtheIPnet and allows to use the objects EOsocketDatagram to offer the same socket services available on the ems. In here we have one server thread listing on port 3333 which replies to receptions, a thread which reads diagnostics, LEDs switched on and off if link is UP or DOWN etc.  Just read board/amc/examples/udpdemoipnet/docs/the udpdemo IPnet project.md to know more or .. you can launch this command on a PC configured as a icub-head and ... digit messages.
shell-1a $ netcat -u 10.0.1.99 -p 11111 3333


Impact of this PR
This PR touches only files used by the amc, hence it can be safely merged w/out further tests on the robot.
Further details on the ETH driver
The IP communication is possible by properly filling the ipal_cfg2_eth_t struct of IPAL with functions defined in namespace embot::hw::eth, for instance as in the following code listing.
constexpr ipal_cfg2_eth_t ethcfg2 =
{
    .eth_mac = IPAL_mac48addr(0x1E,0x30,0x6C,0xA2,0x45,0x5E),
    .eth_ip = IPAL_ipv4addr(10, 0, 1, 99),
    .eth_mask = IPAL_ipv4addr(255, 255, 255, 0),
    .eth_isrpriority = 0,
    .filler = {0, 0, 0, 0, 0, 0, 0},
    .hal_eth_init = embot::hw::eth::init,
    .hal_eth_enable = embot::hw::eth::enable,
    .hal_eth_disable = embot::hw::eth::disable,
    .hal_eth_sendframe = embot::hw::eth::sendframe,
    .get_frame_size = embot::hw::eth::get_frame_size,
    .get_frame = embot::hw::eth::get_frame       
};
Code Listing. The initialization of IPAL used in amc board.
Inside the above functions in embot::hw::eth the driver works simply with a proper initialization of RMII interface of the MPU,  of the pins of the KSZ8563 switch,  the use of a specific memory mapping for the ETH buffers and the aid of a ARM_DRIVER_ETH_MAC driver properly modified.
These low level operations are done in several places, as the following table reports.



Module
Place
Comments




Initialization of pins and RMII
inside MX_GPIO_Init() and MX_ETH_Init()
called inside initialization of stm32hal and inside embot::hw::eth::init()


Use of memory mapping
with the scatter file used in the test projects



adapted driverARM_DRIVER_ETH_MAC 
inside amc/bsp/ethdriver









The retrieval of diagnostic information requires SPI communication w/ the KSZ8563 switch. All that is done entirely in the embot environment by means of embot::hw::eth functions which use embot::hw::chip::KSZ8563 which uses the standard embot::hw::spi functions that we use for EEPROM and AEA encoder reading.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,261,2022-04-01T09:05:48Z,2022-04-05T14:22:53Z,2022-04-06T08:27:56Z,MERGED,True,97,5,3,https://github.com/sgiraz,Update EMS to deal with `wrist-setup` in current control mode,1,[],https://github.com/robotology/icub-firmware/pull/261,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/261,"What's new in this PR:
AMC_BLDC

When a new CAN frame comes in, if the sender CAN ADDRESS is different than 0 (EMS), the frame will not be saved (see emBODY\eBcode\arch-arm\board\amcbldc\application07\src\amcbldc-main.cpp).

EMS

In Joint.c the signature of Joint_send_debug_message change the first argument type from char * to const char *, for better performance and compatibility when we build the module using C++)
In JointSet.c, the JointSet_do_current_control now contains the same instructions used in JointSet_do_pwm_control that are under WRIST_MK2 macro.

Note:

The filtering on the CAN address sender implemented in amcbldc-main.cpp, should be done at lower level (this activity will be adressed with the Refactor the IRQ handler responsible for calling FOC)
In order to work with the wrist-setup, in hardware\motorControl\wrist-eb2-j0_2-mc.xml, we have to change the outputType from pwm to current
Pitch and yaw are inverted when using the yarpmotorgui
 When we run the yarprobotinterface, if we look at the log, we see the following burst of messages:

...
[12:19 PM] Simone Girardi
[WARNING] from BOARD 10.0.1.1 (R), src LOCAL, adr 0, time 158s 697m 592u: (code 0x0000000b, par16 0x019f par64 0x021d011903a0028d) -> SYS: the RX phase of the control loop has last more than wanted. In par16: RX execution time [usec]. In par64: latest previous execution times of TX, RX, DO, TX [usec] + .
[WARNING] from BOARD 10.0.1.1 (R), src LOCAL, adr 0, time 158s 749m 156u: (code 0x0000000d, par16 0x0163 par64 0x0000021c012e0210) -> SYS: the TX phase of the control loop has last more than wanted. In par16: TX execution time [usec]. In par64: num of tx can2 and can1 frames and latest previous execution times of TX, RX, DO [usec] + .
...
Talking with @simeonedussoni we can see the same burst of messages on their wrist-setup.
cc @pattacini","What's new in this PR:
AMC_BLDC

When a new CAN frame comes in, if the sender CAN ADDRESS is different than 0 (EMS), the frame will not be saved (see emBODY\eBcode\arch-arm\board\amcbldc\application07\src\amcbldc-main.cpp).

EMS

In Joint.c the signature of Joint_send_debug_message change the first argument type from char * to const char *, for better performance and compatibility when we build the module using C++)
In JointSet.c, the JointSet_do_current_control now contains the same instructions used in JointSet_do_pwm_control that are under WRIST_MK2 macro.

Note:

The filtering on the CAN address sender implemented in amcbldc-main.cpp, should be done at lower level (this activity will be adressed with the Refactor the IRQ handler responsible for calling FOC)
In order to work with the wrist-setup, in hardware\motorControl\wrist-eb2-j0_2-mc.xml, we have to change the outputType from pwm to current
Pitch and yaw are inverted when using the yarpmotorgui
 When we run the yarprobotinterface, if we look at the log, we see the following burst of messages:

...
[12:19 PM] Simone Girardi
[WARNING] from BOARD 10.0.1.1 (R), src LOCAL, adr 0, time 158s 697m 592u: (code 0x0000000b, par16 0x019f par64 0x021d011903a0028d) -> SYS: the RX phase of the control loop has last more than wanted. In par16: RX execution time [usec]. In par64: latest previous execution times of TX, RX, DO, TX [usec] + .
[WARNING] from BOARD 10.0.1.1 (R), src LOCAL, adr 0, time 158s 749m 156u: (code 0x0000000d, par16 0x0163 par64 0x0000021c012e0210) -> SYS: the TX phase of the control loop has last more than wanted. In par16: TX execution time [usec]. In par64: num of tx can2 and can1 frames and latest previous execution times of TX, RX, DO [usec] + .
...
Talking with @simeonedussoni we can see the same burst of messages on their wrist-setup.
cc @pattacini",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,261,2022-04-01T09:05:48Z,2022-04-05T14:22:53Z,2022-04-06T08:27:56Z,MERGED,True,97,5,3,https://github.com/sgiraz,Update EMS to deal with `wrist-setup` in current control mode,1,[],https://github.com/robotology/icub-firmware/pull/261,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/261#issuecomment-1088768013,"What's new in this PR:
AMC_BLDC

When a new CAN frame comes in, if the sender CAN ADDRESS is different than 0 (EMS), the frame will not be saved (see emBODY\eBcode\arch-arm\board\amcbldc\application07\src\amcbldc-main.cpp).

EMS

In Joint.c the signature of Joint_send_debug_message change the first argument type from char * to const char *, for better performance and compatibility when we build the module using C++)
In JointSet.c, the JointSet_do_current_control now contains the same instructions used in JointSet_do_pwm_control that are under WRIST_MK2 macro.

Note:

The filtering on the CAN address sender implemented in amcbldc-main.cpp, should be done at lower level (this activity will be adressed with the Refactor the IRQ handler responsible for calling FOC)
In order to work with the wrist-setup, in hardware\motorControl\wrist-eb2-j0_2-mc.xml, we have to change the outputType from pwm to current
Pitch and yaw are inverted when using the yarpmotorgui
 When we run the yarprobotinterface, if we look at the log, we see the following burst of messages:

...
[12:19 PM] Simone Girardi
[WARNING] from BOARD 10.0.1.1 (R), src LOCAL, adr 0, time 158s 697m 592u: (code 0x0000000b, par16 0x019f par64 0x021d011903a0028d) -> SYS: the RX phase of the control loop has last more than wanted. In par16: RX execution time [usec]. In par64: latest previous execution times of TX, RX, DO, TX [usec] + .
[WARNING] from BOARD 10.0.1.1 (R), src LOCAL, adr 0, time 158s 749m 156u: (code 0x0000000d, par16 0x0163 par64 0x0000021c012e0210) -> SYS: the TX phase of the control loop has last more than wanted. In par16: TX execution time [usec]. In par64: num of tx can2 and can1 frames and latest previous execution times of TX, RX, DO [usec] + .
...
Talking with @simeonedussoni we can see the same burst of messages on their wrist-setup.
cc @pattacini"," When we run the yarprobotinterface, if we look at the log, we see the following burst of messages:


Hi @sgiraz, don't worry about that. The control runs fine despite these messages. In any case, we surely shall be able to mitigate this by setting new timings for the RX, DO, and TX phases of just by optimizing things a bit. But as it is a experimental code, we very likely will run it on the amc board which is much faster.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,262,2022-04-01T15:15:29Z,2022-04-05T07:29:58Z,2022-04-05T07:29:59Z,MERGED,True,4275,4445,38,https://github.com/sgiraz,AMC_BLDC  Update application07 codegen with c-like code,1,[],https://github.com/robotology/icub-firmware/pull/262,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/262,"What's new in this PR:

The glue code and the codegen have been updated accordingly to the last changes applied to the architectural model.
The FOC Control contains the strategy min + 5

Note:

Application07 has been tested successfully on lego-setup

cc @pattacini","What's new in this PR:

The glue code and the codegen have been updated accordingly to the last changes applied to the architectural model.
The FOC Control contains the strategy min + 5

Note:

Application07 has been tested successfully on lego-setup

cc @pattacini",True,{'ROCKET': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,263,2022-04-14T18:21:00Z,2022-05-03T13:30:07Z,2022-05-24T07:52:54Z,MERGED,True,1801,306,21,https://github.com/sgiraz,Add Kalman Filter to ems mc2plus and mc4plus,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/263,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/263,"What's new in this PR:

Joint velocity and acceleration are now estimated using the Kalman Filter algorithm (one for each joint).
A new group called mdb::kalman-filter has been added to the projects of ems, mc2plus and mc4plus. The sources have been placed under icub-firmware\emBODY\eBcode\arch-arm\mbd
A Joint_hid.h header has been created in order to include the KalmanFilter class instance as a member of the CJoint structure following the pattern of forward declaration.


Notes:

Currently, the FW has been validated and tested successfully on AEA3-setup , iCubGenova02 and iCub3.
kalman_filter.step takes 27 us to compute
Kalman Filter is disabled by default with the following hard-coded instruction in JointSet.c: o->kalman_filter_enabled = FALSE;
Next developments have to allow us to initialize the Kalman Filter from XML. Actually, they are hard-coded in JointSet.c.

cc @pattacini","What's new in this PR:

Joint velocity and acceleration are now estimated using the Kalman Filter algorithm (one for each joint).
A new group called mdb::kalman-filter has been added to the projects of ems, mc2plus and mc4plus. The sources have been placed under icub-firmware\emBODY\eBcode\arch-arm\mbd
A Joint_hid.h header has been created in order to include the KalmanFilter class instance as a member of the CJoint structure following the pattern of forward declaration.


Notes:

Currently, the FW has been validated and tested successfully on AEA3-setup , iCubGenova02 and iCub3.
kalman_filter.step takes 27 us to compute
Kalman Filter is disabled by default with the following hard-coded instruction in JointSet.c: o->kalman_filter_enabled = FALSE;
Next developments have to allow us to initialize the Kalman Filter from XML. Actually, they are hard-coded in JointSet.c.

cc @pattacini",True,"{'ROCKET': ['https://github.com/pattacini', 'https://github.com/gsisinna']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,263,2022-04-14T18:21:00Z,2022-05-03T13:30:07Z,2022-05-24T07:52:54Z,MERGED,True,1801,306,21,https://github.com/sgiraz,Add Kalman Filter to ems mc2plus and mc4plus,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/263,https://github.com/sgiraz,2,https://github.com/robotology/icub-firmware/pull/263#issuecomment-1099506049,"What's new in this PR:

Joint velocity and acceleration are now estimated using the Kalman Filter algorithm (one for each joint).
A new group called mdb::kalman-filter has been added to the projects of ems, mc2plus and mc4plus. The sources have been placed under icub-firmware\emBODY\eBcode\arch-arm\mbd
A Joint_hid.h header has been created in order to include the KalmanFilter class instance as a member of the CJoint structure following the pattern of forward declaration.


Notes:

Currently, the FW has been validated and tested successfully on AEA3-setup , iCubGenova02 and iCub3.
kalman_filter.step takes 27 us to compute
Kalman Filter is disabled by default with the following hard-coded instruction in JointSet.c: o->kalman_filter_enabled = FALSE;
Next developments have to allow us to initialize the Kalman Filter from XML. Actually, they are hard-coded in JointSet.c.

cc @pattacini","Probably we should not merge this PR until the robot tests have been completed
@pattacini @marcoaccame",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,263,2022-04-14T18:21:00Z,2022-05-03T13:30:07Z,2022-05-24T07:52:54Z,MERGED,True,1801,306,21,https://github.com/sgiraz,Add Kalman Filter to ems mc2plus and mc4plus,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/263,https://github.com/traversaro,3,https://github.com/robotology/icub-firmware/pull/263#issuecomment-1100044261,"What's new in this PR:

Joint velocity and acceleration are now estimated using the Kalman Filter algorithm (one for each joint).
A new group called mdb::kalman-filter has been added to the projects of ems, mc2plus and mc4plus. The sources have been placed under icub-firmware\emBODY\eBcode\arch-arm\mbd
A Joint_hid.h header has been created in order to include the KalmanFilter class instance as a member of the CJoint structure following the pattern of forward declaration.


Notes:

Currently, the FW has been validated and tested successfully on AEA3-setup , iCubGenova02 and iCub3.
kalman_filter.step takes 27 us to compute
Kalman Filter is disabled by default with the following hard-coded instruction in JointSet.c: o->kalman_filter_enabled = FALSE;
Next developments have to allow us to initialize the Kalman Filter from XML. Actually, they are hard-coded in JointSet.c.

cc @pattacini",Cross-link to related icub-firmware-models PR : robotology/icub-firmware-models#3 .,True,"{'THUMBS_UP': ['https://github.com/pattacini', 'https://github.com/sgiraz']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,263,2022-04-14T18:21:00Z,2022-05-03T13:30:07Z,2022-05-24T07:52:54Z,MERGED,True,1801,306,21,https://github.com/sgiraz,Add Kalman Filter to ems mc2plus and mc4plus,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/263,https://github.com/pattacini,4,https://github.com/robotology/icub-firmware/pull/263#issuecomment-1116066623,"What's new in this PR:

Joint velocity and acceleration are now estimated using the Kalman Filter algorithm (one for each joint).
A new group called mdb::kalman-filter has been added to the projects of ems, mc2plus and mc4plus. The sources have been placed under icub-firmware\emBODY\eBcode\arch-arm\mbd
A Joint_hid.h header has been created in order to include the KalmanFilter class instance as a member of the CJoint structure following the pattern of forward declaration.


Notes:

Currently, the FW has been validated and tested successfully on AEA3-setup , iCubGenova02 and iCub3.
kalman_filter.step takes 27 us to compute
Kalman Filter is disabled by default with the following hard-coded instruction in JointSet.c: o->kalman_filter_enabled = FALSE;
Next developments have to allow us to initialize the Kalman Filter from XML. Actually, they are hard-coded in JointSet.c.

cc @pattacini",The test of robotology/icub-firmware-build#53 was successful.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,264,2022-04-29T12:53:29Z,2022-05-02T07:21:39Z,2022-05-02T07:21:39Z,MERGED,True,31957,41,78,https://github.com/marcoaccame,ETH environment for the amc board,16,[],https://github.com/robotology/icub-firmware/pull/264,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/264,"Brief of the PR
This PR adds an eLoader, an eUpdater and a template eApplication which can run on the CM7 core of the amc board.
The above processes massively use the environment we now use in icub-firmware which is based upon the C++ embot + stm32hal libraries.
Moreover,  we were also able to reuse very useful legacy C objects (such as: EOMtheIPnet, EOsocketDatagram and later also the ones implementing the services) which we use in boards such as the ems, mc4plus, mc2plus. We have achieved that by means of the adaptation layer embot::os::EOM.
 -----------------------
| embot                 |
|                       |
|    ----------------   |
|   | embot::os::EOM |  | 
|    ----------------   |
|   | EOM            |  |
|    ----------------   |
|                       |
 -----------------------
| stm32hal              |
 ----------------------- 
| HW                    |
 ----------------------- 

Figure. The embot::os::EOM layer enables legacy EOM services inside a embot + stm32hal environment.
For now, the result of all the above, is that the amc board can boostraps, runs the eUpdater or the eApplication and can talk to FirmwareUpdater and use some of its services.
Later on, we shall be able to run in a modern C++ environment other code for specific services. The code can be either legacy EO objects (e.g, EOtheServices,  EOtheSKIN, ...) or new embot objects (e.g, embot::app::eth::theFTservice, embot::app::eth::CANmonitor, ...) and also C++ code generated from MBD.
Mergeability
The code in this PR does was designed to not interfere w/ code running on other boards. Moreover, it was thoroughly tested.  So, it can be safely merged.
What's new in more details
In here is what we have in more details:

the eLoader, the eUpdater and a template eApplication which all run on the amc in different FLASH sections (see here for a description of how these three processes interact amongst them);
the FirmwareUpdater can talk to the amc board and perform some operations as shown in the following video;
the above mentioned template eApplication reuses most objects of the legacy ETH boards by wrapping them into a fully modern C++ embot application and finally greatly simplifies its use and configurability. See example of configuration in the following code listings.

Interaction w/ FirmwareUpdater
It is demonstrated by this video.

  
    
    

    Screencast.from.28-04-2022.16.52.43.webm.mp4
    
  

  

  


Video. FirmwareUpdater operates on the amc board.
Structure of the eApplication
In the following code listings, are shown how the main() is structured, plus what are the main objects used to offer the basic services and their complete configurability.
#include ""embot_app_eth_theApplication.h""
int main(void)
{
    embot::app::eth::theApplication::getInstance().start({});
}
Code Listing. The elegance of the main() which just calls a method which starts the application.
[[noreturn]] void embot::app::eth::theApplication::Impl::start(const Config &config)
{   
    embot::core::print(std::string(objectname) + ""::Impl::start()"");
    
    embot::os::init(osconfig); 
    embot::os::start();
}


void embot::app::eth::theApplication::Impl::initSystem(embot::os::Thread *t, void* initparam)
{        
    embot::os::theTimerManager::getInstance().start(embot::app::eth::theApplication_Config.TMRMANconfig);     
    embot::os::theCallbackManager::getInstance().start(embot::app::eth::theApplication_Config.CBKMANconfig);  
        
    embot::app::eth::theErrorManager::getInstance().initialise(embot::app::eth::theApplication_Config.ERRMANconfig);
        
    embot::app::theLEDmanager::getInstance().init(embot::app::eth::theApplication_Config.allLEDs);
    embot::app::theLEDmanager::getInstance().get(embot::app::eth::theApplication_Config.pulseLED).pulse(embot::app::eth::theApplication_Config.pulseFREQ, 0);

    // this starts initialization of legacy and usefuls EOM services to use embot objects:
    // EOVtheCallbackManager, EOVtheTimerManager, EOVtheSystem, ...
    embot::os::EOM::initialise(eomcfg);  
    
    // ok, now you can run whatever you want ... w/ EOM objects or their wrappers
    
    embot::app::eth::theEnvironment::getInstance().initialise();
    embot::app::eth::theIPnet::getInstance().initialise(embot::app::eth::theApplication_Config.IPNETconfig);
    embot::app::eth::theListener::getInstance().initialise(embot::app::eth::theApplication_Config.LISTENERconfig);       

    // and now we can launch whatever else we want
        
    embot::app::eth::theApplication_Config.OSuserdefinit.execute();
    
    theErrorManager::getInstance().emit(theErrorManager::Severity::info, {objectname, t}, {}, ""quitting the INIT thread. Normal scheduling starts"");    
}
Code Listing. The object theApplication is responsible to start the OS which in its INIT thread starts: theTimerManager, theCallbackManager, theErrorManager, theLEDmanager, enables legacy EOM C objects w/ embot::os::EOM::initialise(eomcfg). Then it starts wrappers to legacy services w/ theEnvironment,  theIPnet, theListener and finally calls a user defined function which can start any other further service.
constexpr theApplication::Config theApplication_Config
{
    .property =
    {
        Process::eApplication,
        {3, 0},                  
        {2022, Month::Apr, Day::fourteen, 15, 16}
    },
    .OStick = 1000*embot::core::time1microsec,
    .OSstacksizeinit = 6*1024,
    .OSuserdefinit = {theApplication_Config_inituserdefined, nullptr},
    .OSstacksizeidle = 2*1024,
    .OSonidle = theApplication_Config_onIdle,
    .TMRMANconfig = {1024, 8, embot::os::Priority::system50},
    .CBKMANconfig = {2*1024, 8, embot::os::Priority::system49},
    .ERRMANconfig = { theApplication_Config_errorman_onemit },
    .allLEDs =
    {
        embot::hw::LED::one, embot::hw::LED::two, embot::hw::LED::three, 
        embot::hw::LED::four, embot::hw::LED::five, embot::hw::LED::six
    },
    .pulseLED = embot::hw::LED::three,
    .pulseFREQ = embot::core::time1second,
    .IPNETconfig =
    {
        {&ipal_cfg2, true},                     // ipal
        {embot::os::Priority::high44, 4*1024},  // proc
        {embot::os::Priority::high43, 4*1024},  // tick
        25*embot::core::time1millisec,          // maxidletime
        {4, 4}                                  // sockets ... {numberofsockets, maxdatagramenqueuedintx} 
    },
    .LISTENERconfig = 
    {
        { embot::os::Priority::belownorm22, 4*1024 },   // thread
        {{2, 32, 1, 128}, 3333},                        // socket.size, socket.localport
        {embot::app::eth::IPlocalhost, 3333}            // hostaddress
    }    
};

Code Listing. Configuration of the embot::app::eth::theApplication object which implements the eApplication running on the amc board. The constants are placed inside file theApplication_config.h;
// user defined onidle
void theApplication_Config_onIdle(embot::os::Thread *t, void* idleparam) 
{ 
    static volatile uint32_t cnt {0}; 
    cnt++; 
}

// user defined worker called by INIT thread just before start of scheduling
void theApplication_Config_inituserdefined(void *p)
{
    // add what yout want
    volatile uint32_t ciao {0};
    ciao++;
    embot::core::print(""hello world... you can ping me now"");
}

// user defined error function
void theApplication_Config_errorman_onemit(theErrorManager::Severity sev, const theErrorManager::Caller &caller, const theErrorManager::Descriptor &des, const std::string &str)
{
    std::string timenow = embot::core::TimeFormatter(embot::core::now()).to_string();
    std::string eobjstr = (true == caller.isvalid()) ? caller.objectname : ""OBJ"";
    std::string threadname = (true == caller.isvalid()) ? caller.owner->getName() : ""THR"";
    std::string severity = theErrorManager::to_cstring(sev);
    
    embot::core::print(std::string(""["") + severity + ""] @"" + timenow + "" ("" + eobjstr + "", "" + threadname + ""): "" + str);
    
    if(theErrorManager::Severity::trace == sev) 
    {
        return;
    } 
...

Code Listing. Configuration of the embot::app::eth::theApplication object. The code can be placed anywhere;
What's next
The general structure of the amc works fine,] but there are some known issues to be solved:

The IP stack based on lwIP does not receive the broadcast UDP packets as sent by FirmwareUpdater. The above video worked w/ the DISCOVERY command sent in unicast, but that must be solved.
The writing of the FLASH on the STM32H7 is not reliable yet, so the programming of the application using FirmwareUpdater works but is not fully reliable yet.
Tests the FW update of CAN boards attached to the amc is yet to be done.","Brief of the PR
This PR adds an eLoader, an eUpdater and a template eApplication which can run on the CM7 core of the amc board.
The above processes massively use the environment we now use in icub-firmware which is based upon the C++ embot + stm32hal libraries.
Moreover,  we were also able to reuse very useful legacy C objects (such as: EOMtheIPnet, EOsocketDatagram and later also the ones implementing the services) which we use in boards such as the ems, mc4plus, mc2plus. We have achieved that by means of the adaptation layer embot::os::EOM.
 -----------------------
| embot                 |
|                       |
|    ----------------   |
|   | embot::os::EOM |  | 
|    ----------------   |
|   | EOM            |  |
|    ----------------   |
|                       |
 -----------------------
| stm32hal              |
 ----------------------- 
| HW                    |
 ----------------------- 

Figure. The embot::os::EOM layer enables legacy EOM services inside a embot + stm32hal environment.
For now, the result of all the above, is that the amc board can boostraps, runs the eUpdater or the eApplication and can talk to FirmwareUpdater and use some of its services.
Later on, we shall be able to run in a modern C++ environment other code for specific services. The code can be either legacy EO objects (e.g, EOtheServices,  EOtheSKIN, ...) or new embot objects (e.g, embot::app::eth::theFTservice, embot::app::eth::CANmonitor, ...) and also C++ code generated from MBD.
Mergeability
The code in this PR does was designed to not interfere w/ code running on other boards. Moreover, it was thoroughly tested.  So, it can be safely merged.
What's new in more details
In here is what we have in more details:

the eLoader, the eUpdater and a template eApplication which all run on the amc in different FLASH sections (see here for a description of how these three processes interact amongst them);
the FirmwareUpdater can talk to the amc board and perform some operations as shown in the following video;
the above mentioned template eApplication reuses most objects of the legacy ETH boards by wrapping them into a fully modern C++ embot application and finally greatly simplifies its use and configurability. See example of configuration in the following code listings.

Interaction w/ FirmwareUpdater
It is demonstrated by this video.

  
    
    

    Screencast.from.28-04-2022.16.52.43.webm.mp4
    
  

  

  


Video. FirmwareUpdater operates on the amc board.
Structure of the eApplication
In the following code listings, are shown how the main() is structured, plus what are the main objects used to offer the basic services and their complete configurability.
#include ""embot_app_eth_theApplication.h""
int main(void)
{
    embot::app::eth::theApplication::getInstance().start({});
}
Code Listing. The elegance of the main() which just calls a method which starts the application.
[[noreturn]] void embot::app::eth::theApplication::Impl::start(const Config &config)
{   
    embot::core::print(std::string(objectname) + ""::Impl::start()"");
    
    embot::os::init(osconfig); 
    embot::os::start();
}


void embot::app::eth::theApplication::Impl::initSystem(embot::os::Thread *t, void* initparam)
{        
    embot::os::theTimerManager::getInstance().start(embot::app::eth::theApplication_Config.TMRMANconfig);     
    embot::os::theCallbackManager::getInstance().start(embot::app::eth::theApplication_Config.CBKMANconfig);  
        
    embot::app::eth::theErrorManager::getInstance().initialise(embot::app::eth::theApplication_Config.ERRMANconfig);
        
    embot::app::theLEDmanager::getInstance().init(embot::app::eth::theApplication_Config.allLEDs);
    embot::app::theLEDmanager::getInstance().get(embot::app::eth::theApplication_Config.pulseLED).pulse(embot::app::eth::theApplication_Config.pulseFREQ, 0);

    // this starts initialization of legacy and usefuls EOM services to use embot objects:
    // EOVtheCallbackManager, EOVtheTimerManager, EOVtheSystem, ...
    embot::os::EOM::initialise(eomcfg);  
    
    // ok, now you can run whatever you want ... w/ EOM objects or their wrappers
    
    embot::app::eth::theEnvironment::getInstance().initialise();
    embot::app::eth::theIPnet::getInstance().initialise(embot::app::eth::theApplication_Config.IPNETconfig);
    embot::app::eth::theListener::getInstance().initialise(embot::app::eth::theApplication_Config.LISTENERconfig);       

    // and now we can launch whatever else we want
        
    embot::app::eth::theApplication_Config.OSuserdefinit.execute();
    
    theErrorManager::getInstance().emit(theErrorManager::Severity::info, {objectname, t}, {}, ""quitting the INIT thread. Normal scheduling starts"");    
}
Code Listing. The object theApplication is responsible to start the OS which in its INIT thread starts: theTimerManager, theCallbackManager, theErrorManager, theLEDmanager, enables legacy EOM C objects w/ embot::os::EOM::initialise(eomcfg). Then it starts wrappers to legacy services w/ theEnvironment,  theIPnet, theListener and finally calls a user defined function which can start any other further service.
constexpr theApplication::Config theApplication_Config
{
    .property =
    {
        Process::eApplication,
        {3, 0},                  
        {2022, Month::Apr, Day::fourteen, 15, 16}
    },
    .OStick = 1000*embot::core::time1microsec,
    .OSstacksizeinit = 6*1024,
    .OSuserdefinit = {theApplication_Config_inituserdefined, nullptr},
    .OSstacksizeidle = 2*1024,
    .OSonidle = theApplication_Config_onIdle,
    .TMRMANconfig = {1024, 8, embot::os::Priority::system50},
    .CBKMANconfig = {2*1024, 8, embot::os::Priority::system49},
    .ERRMANconfig = { theApplication_Config_errorman_onemit },
    .allLEDs =
    {
        embot::hw::LED::one, embot::hw::LED::two, embot::hw::LED::three, 
        embot::hw::LED::four, embot::hw::LED::five, embot::hw::LED::six
    },
    .pulseLED = embot::hw::LED::three,
    .pulseFREQ = embot::core::time1second,
    .IPNETconfig =
    {
        {&ipal_cfg2, true},                     // ipal
        {embot::os::Priority::high44, 4*1024},  // proc
        {embot::os::Priority::high43, 4*1024},  // tick
        25*embot::core::time1millisec,          // maxidletime
        {4, 4}                                  // sockets ... {numberofsockets, maxdatagramenqueuedintx} 
    },
    .LISTENERconfig = 
    {
        { embot::os::Priority::belownorm22, 4*1024 },   // thread
        {{2, 32, 1, 128}, 3333},                        // socket.size, socket.localport
        {embot::app::eth::IPlocalhost, 3333}            // hostaddress
    }    
};

Code Listing. Configuration of the embot::app::eth::theApplication object which implements the eApplication running on the amc board. The constants are placed inside file theApplication_config.h;
// user defined onidle
void theApplication_Config_onIdle(embot::os::Thread *t, void* idleparam) 
{ 
    static volatile uint32_t cnt {0}; 
    cnt++; 
}

// user defined worker called by INIT thread just before start of scheduling
void theApplication_Config_inituserdefined(void *p)
{
    // add what yout want
    volatile uint32_t ciao {0};
    ciao++;
    embot::core::print(""hello world... you can ping me now"");
}

// user defined error function
void theApplication_Config_errorman_onemit(theErrorManager::Severity sev, const theErrorManager::Caller &caller, const theErrorManager::Descriptor &des, const std::string &str)
{
    std::string timenow = embot::core::TimeFormatter(embot::core::now()).to_string();
    std::string eobjstr = (true == caller.isvalid()) ? caller.objectname : ""OBJ"";
    std::string threadname = (true == caller.isvalid()) ? caller.owner->getName() : ""THR"";
    std::string severity = theErrorManager::to_cstring(sev);
    
    embot::core::print(std::string(""["") + severity + ""] @"" + timenow + "" ("" + eobjstr + "", "" + threadname + ""): "" + str);
    
    if(theErrorManager::Severity::trace == sev) 
    {
        return;
    } 
...

Code Listing. Configuration of the embot::app::eth::theApplication object. The code can be placed anywhere;
What's next
The general structure of the amc works fine,] but there are some known issues to be solved:

The IP stack based on lwIP does not receive the broadcast UDP packets as sent by FirmwareUpdater. The above video worked w/ the DISCOVERY command sent in unicast, but that must be solved.
The writing of the FLASH on the STM32H7 is not reliable yet, so the programming of the application using FirmwareUpdater works but is not fully reliable yet.
Tests the FW update of CAN boards attached to the amc is yet to be done.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,265,2022-04-30T11:09:19Z,2022-05-02T07:27:24Z,2022-05-02T07:27:24Z,MERGED,True,52,62,3,https://github.com/sgiraz,AMC_BLDC  Clean Up mbdAgent of application07,3,[],https://github.com/robotology/icub-firmware/pull/265,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/265,"What's new in this PR:
In the last PR I forgot to:

remove the USE_LEGO_SETUP macro from the project configuration of application07.
add the control_foc_data.cpp source file generated from Simulink.
removed unused code
removed old commented code
update some debug instructions with the new C-like struct in order to build correctly when enabled

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini @valegagge @GrmanRodriguez","What's new in this PR:
In the last PR I forgot to:

remove the USE_LEGO_SETUP macro from the project configuration of application07.
add the control_foc_data.cpp source file generated from Simulink.
removed unused code
removed old commented code
update some debug instructions with the new C-like struct in order to build correctly when enabled

Note:

To use the Lego-setup just enable the macro USE_LEGO_SETUP (disabled by default)
This macro will be removed when the hal will become configurable (currently WIP).

cc @pattacini @valegagge @GrmanRodriguez",True,"{'THUMBS_UP': ['https://github.com/pattacini'], 'HEART': ['https://github.com/valegagge']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,266,2022-05-13T08:09:27Z,2022-05-16T13:00:54Z,2022-05-16T13:00:54Z,MERGED,True,622,108,9,https://github.com/marcoaccame,Added support in the `amc` board for redirection of `theErrorManager`'s prints over UDP,1,[],https://github.com/robotology/icub-firmware/pull/266,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/266,"Content of the PR
This PR adds a customization in the template application for the amc added to this repository in here.
In particular, it customize the theErrorManager::emit(...) functions so that not only prints its information over the TRACE port but also sends it over UDP to a host which will be able to print it.
That is particularly helpful to debug the newborn amc board. It can be used in long runs of simulations with no programmer attached to it, but also it overcomes the limitation of the programmer + toolchains which now show on the screen a maximum of 4K lines.
The main changes have been:

the addition of a method theErrorManager::set(fpOnEmit onemit) which allows to change the behavior of the object also in runtime (as the ems already can do).
the use of the object embot::app::eth::theBackdoor which opens a bidirectional socket and is able to send out UDP datagrams as well as receive them (with their decoding that can be customized).

Tests
The code was verified on an setup formed by a laptop running netcat and an amc board to produce the following print.
 ---------------------------------------   
| amc cm7                               |
|                                       |
| Thread                                |
|   |                                   |              
|    -> theErrorManager::emit()         |
|                 |                     |
|       theBackdoor::transmit()         |
|                 |                     |
|             theIPnet                  |
|                                       |
 ---------------------------------------
                  |
                  |
                   ------------
                               |
                         ---------------           
                        |               |  
                        | > netcat      |
                        |               |
                        |               |
                        ----------------
                       / qwertyuiop    /
                      / asdfghjkl     /
                     / zxcvbnm       /
                     ----------------

Figure. The setup.
acemor@:~ [] $ netcat -u 10.0.1.1 -p 6666 6666
[info] @S165:m2:u80 (testThread, tTESTccc): onevent: timeout @ time = S165:m2:u3
[info] @S170:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S170:m2:u6
[info] @S175:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S175:m2:u5
[info] @S180:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S180:m2:u6
[info] @S185:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S185:m2:u6


Listing. The object theErrorManager is used by a 5 seconds periodic thread to emit messages of severity info. The messages are managed by theBackdoor, formatted and redirected to socket address 10.0.1.104:666, where the netcat program listens and prints.
Mergeability
The changes affects only the code used by the amc, so they can be safely merged.","Content of the PR
This PR adds a customization in the template application for the amc added to this repository in here.
In particular, it customize the theErrorManager::emit(...) functions so that not only prints its information over the TRACE port but also sends it over UDP to a host which will be able to print it.
That is particularly helpful to debug the newborn amc board. It can be used in long runs of simulations with no programmer attached to it, but also it overcomes the limitation of the programmer + toolchains which now show on the screen a maximum of 4K lines.
The main changes have been:

the addition of a method theErrorManager::set(fpOnEmit onemit) which allows to change the behavior of the object also in runtime (as the ems already can do).
the use of the object embot::app::eth::theBackdoor which opens a bidirectional socket and is able to send out UDP datagrams as well as receive them (with their decoding that can be customized).

Tests
The code was verified on an setup formed by a laptop running netcat and an amc board to produce the following print.
 ---------------------------------------   
| amc cm7                               |
|                                       |
| Thread                                |
|   |                                   |              
|    -> theErrorManager::emit()         |
|                 |                     |
|       theBackdoor::transmit()         |
|                 |                     |
|             theIPnet                  |
|                                       |
 ---------------------------------------
                  |
                  |
                   ------------
                               |
                         ---------------           
                        |               |  
                        | > netcat      |
                        |               |
                        |               |
                        ----------------
                       / qwertyuiop    /
                      / asdfghjkl     /
                     / zxcvbnm       /
                     ----------------

Figure. The setup.
acemor@:~ [] $ netcat -u 10.0.1.1 -p 6666 6666
[info] @S165:m2:u80 (testThread, tTESTccc): onevent: timeout @ time = S165:m2:u3
[info] @S170:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S170:m2:u6
[info] @S175:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S175:m2:u5
[info] @S180:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S180:m2:u6
[info] @S185:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S185:m2:u6


Listing. The object theErrorManager is used by a 5 seconds periodic thread to emit messages of severity info. The messages are managed by theBackdoor, formatted and redirected to socket address 10.0.1.104:666, where the netcat program listens and prints.
Mergeability
The changes affects only the code used by the amc, so they can be safely merged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,266,2022-05-13T08:09:27Z,2022-05-16T13:00:54Z,2022-05-16T13:00:54Z,MERGED,True,622,108,9,https://github.com/marcoaccame,Added support in the `amc` board for redirection of `theErrorManager`'s prints over UDP,1,[],https://github.com/robotology/icub-firmware/pull/266,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/266#issuecomment-1125814797,"Content of the PR
This PR adds a customization in the template application for the amc added to this repository in here.
In particular, it customize the theErrorManager::emit(...) functions so that not only prints its information over the TRACE port but also sends it over UDP to a host which will be able to print it.
That is particularly helpful to debug the newborn amc board. It can be used in long runs of simulations with no programmer attached to it, but also it overcomes the limitation of the programmer + toolchains which now show on the screen a maximum of 4K lines.
The main changes have been:

the addition of a method theErrorManager::set(fpOnEmit onemit) which allows to change the behavior of the object also in runtime (as the ems already can do).
the use of the object embot::app::eth::theBackdoor which opens a bidirectional socket and is able to send out UDP datagrams as well as receive them (with their decoding that can be customized).

Tests
The code was verified on an setup formed by a laptop running netcat and an amc board to produce the following print.
 ---------------------------------------   
| amc cm7                               |
|                                       |
| Thread                                |
|   |                                   |              
|    -> theErrorManager::emit()         |
|                 |                     |
|       theBackdoor::transmit()         |
|                 |                     |
|             theIPnet                  |
|                                       |
 ---------------------------------------
                  |
                  |
                   ------------
                               |
                         ---------------           
                        |               |  
                        | > netcat      |
                        |               |
                        |               |
                        ----------------
                       / qwertyuiop    /
                      / asdfghjkl     /
                     / zxcvbnm       /
                     ----------------

Figure. The setup.
acemor@:~ [] $ netcat -u 10.0.1.1 -p 6666 6666
[info] @S165:m2:u80 (testThread, tTESTccc): onevent: timeout @ time = S165:m2:u3
[info] @S170:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S170:m2:u6
[info] @S175:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S175:m2:u5
[info] @S180:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S180:m2:u6
[info] @S185:m2:u81 (testThread, tTESTccc): onevent: timeout @ time = S185:m2:u6


Listing. The object theErrorManager is used by a 5 seconds periodic thread to emit messages of severity info. The messages are managed by theBackdoor, formatted and redirected to socket address 10.0.1.104:666, where the netcat program listens and prints.
Mergeability
The changes affects only the code used by the amc, so they can be safely merged.","cc @sgiraz , @davidetome, @triccyx",True,"{'THUMBS_UP': ['https://github.com/davidetome', 'https://github.com/sgiraz']}"
robotology/icub-firmware,https://github.com/robotology/icub-firmware,267,2022-05-20T13:47:11Z,2022-05-26T09:21:10Z,2022-05-26T09:21:10Z,MERGED,True,1,1,1,https://github.com/sgiraz,Fix typo when calling eom_task_New in EOMtheEMSdiscoverylistener.cpp,1,[],https://github.com/robotology/icub-firmware/pull/267,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/267,"Note:

This PR fixes a typo in EOMtheEMSdiscoverylistener.cpp that prevents ems and mc4plus projects from compiling without error.","Note:

This PR fixes a typo in EOMtheEMSdiscoverylistener.cpp that prevents ems and mc4plus projects from compiling without error.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,268,2022-05-24T08:44:10Z,,2022-05-26T13:16:34Z,OPEN,False,54,64,8,https://github.com/sgiraz,Update Kalman Filter configuration params to be initialized from XML files,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/268,https://github.com/sgiraz,1,https://github.com/robotology/icub-firmware/pull/268,"What's new in this PR:

This PR involves changes on ems, mc2plus and mc4plus.
The Kalman Filter configuration params are now initialized when Joint_config is called.
EOMTHEEMSAPPLCFG_SOCKET_OUTDGRAMSIZEOF and EOMTHEEMSAPPLCFG_TRANSCEIVER_ROPFRAMEREPLIESCAPACITY have been increased by 2 Bytes.

Notes:

This PR is a follow up to #263
Currently, the FW has been validated and tested successfully on AEA3-setup.
Kalman Filter is disabled by default when no configurations are provided

cc @pattacini","What's new in this PR:

This PR involves changes on ems, mc2plus and mc4plus.
The Kalman Filter configuration params are now initialized when Joint_config is called.
EOMTHEEMSAPPLCFG_SOCKET_OUTDGRAMSIZEOF and EOMTHEEMSAPPLCFG_TRANSCEIVER_ROPFRAMEREPLIESCAPACITY have been increased by 2 Bytes.

Notes:

This PR is a follow up to #263
Currently, the FW has been validated and tested successfully on AEA3-setup.
Kalman Filter is disabled by default when no configurations are provided

cc @pattacini",True,{'THUMBS_UP': ['https://github.com/pattacini']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,268,2022-05-24T08:44:10Z,,2022-05-26T13:16:34Z,OPEN,False,54,64,8,https://github.com/sgiraz,Update Kalman Filter configuration params to be initialized from XML files,2,['enhancement'],https://github.com/robotology/icub-firmware/pull/268,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/268#issuecomment-1138566125,"What's new in this PR:

This PR involves changes on ems, mc2plus and mc4plus.
The Kalman Filter configuration params are now initialized when Joint_config is called.
EOMTHEEMSAPPLCFG_SOCKET_OUTDGRAMSIZEOF and EOMTHEEMSAPPLCFG_TRANSCEIVER_ROPFRAMEREPLIESCAPACITY have been increased by 2 Bytes.

Notes:

This PR is a follow up to #263
Currently, the FW has been validated and tested successfully on AEA3-setup.
Kalman Filter is disabled by default when no configurations are provided

cc @pattacini","Hi @sgiraz, I can see that this PR is still draft and also the twin one in here.
Note that:

the repos have just been tagged for the 2022.05 release, so we can re-start w/ merging the PRs. Feel free to mark your PRs ready when it is OK for you.
there have been some PRs since you created this one, so pls have a look if they interfere w/ yours. I don't think so, anyway.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,269,2022-05-24T10:51:36Z,2022-05-26T13:09:17Z,2022-05-26T13:09:18Z,MERGED,True,11294,10506,55,https://github.com/valegagge,Amc bldc: the new supervisor multi-packets,5,[],https://github.com/robotology/icub-firmware/pull/269,https://github.com/valegagge,1,https://github.com/robotology/icub-firmware/pull/269,"Here there is the generated code with this model.
The amc-bldc firmware version is 1.0.7.
The firmware has been compiled with the icub-firmware shared at head of devel branch. (the SHA is 79cf7d52fa7e3605e510cb520b1c3b127f2c1be9).
We tested the firmware on the wrist setup and it works properly.
We added the histogram print function for debugging: we developed it to check the size of input or output CAN queue.
cc @GrmanRodriguez","Here there is the generated code with this model.
The amc-bldc firmware version is 1.0.7.
The firmware has been compiled with the icub-firmware shared at head of devel branch. (the SHA is 79cf7d52fa7e3605e510cb520b1c3b127f2c1be9).
We tested the firmware on the wrist setup and it works properly.
We added the histogram print function for debugging: we developed it to check the size of input or output CAN queue.
cc @GrmanRodriguez",True,{'THUMBS_UP': ['https://github.com/vvasco']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,269,2022-05-24T10:51:36Z,2022-05-26T13:09:17Z,2022-05-26T13:09:18Z,MERGED,True,11294,10506,55,https://github.com/valegagge,Amc bldc: the new supervisor multi-packets,5,[],https://github.com/robotology/icub-firmware/pull/269,https://github.com/mfussi66,2,https://github.com/robotology/icub-firmware/pull/269#issuecomment-1138555387,"Here there is the generated code with this model.
The amc-bldc firmware version is 1.0.7.
The firmware has been compiled with the icub-firmware shared at head of devel branch. (the SHA is 79cf7d52fa7e3605e510cb520b1c3b127f2c1be9).
We tested the firmware on the wrist setup and it works properly.
We added the histogram print function for debugging: we developed it to check the size of input or output CAN queue.
cc @GrmanRodriguez","In my last commit, lots of autogen files have their date and model version at earlier values compared to the ones in the previous commit.
I think this is just caused by matlab being ""smart"" and generating only the files which have differences at the model level.
Nonetheless, You could clearly see the latest contributions to the architectural model. I think it can be safely merged on my end.",True,{'THUMBS_UP': ['https://github.com/marcoaccame']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,269,2022-05-24T10:51:36Z,2022-05-26T13:09:17Z,2022-05-26T13:09:18Z,MERGED,True,11294,10506,55,https://github.com/valegagge,Amc bldc: the new supervisor multi-packets,5,[],https://github.com/robotology/icub-firmware/pull/269,https://github.com/marcoaccame,3,https://github.com/robotology/icub-firmware/pull/269#issuecomment-1138557967,"Here there is the generated code with this model.
The amc-bldc firmware version is 1.0.7.
The firmware has been compiled with the icub-firmware shared at head of devel branch. (the SHA is 79cf7d52fa7e3605e510cb520b1c3b127f2c1be9).
We tested the firmware on the wrist setup and it works properly.
We added the histogram print function for debugging: we developed it to check the size of input or output CAN queue.
cc @GrmanRodriguez","Nonetheless, You could clearly see the latest contributions to the architectural model. I think it can be safely merged on my end.

Ok, so we shall merge then.",True,{'THUMBS_UP': ['https://github.com/mfussi66']}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,271,2022-05-26T13:01:30Z,2022-05-26T13:03:52Z,2022-05-26T13:03:52Z,MERGED,True,317,27,5,https://github.com/marcoaccame,Enhancement of the `embot::hw::timer` driver,2,[],https://github.com/robotology/icub-firmware/pull/271,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/271,"This PR enhances the embot::hw::timer driver in two ways:

it adds some extra functions required for the porting of the objects EOMtheRunner to the amc application,
it adds the support of emulated HW timers.

The emulation is implemented w/ the embot::os::Timer objects and is enabled w/ macros EMBOT_ENABLE_hw_timer and EMBOT_ENABLE_hw_timer_emulated.
This feature is useful because I can begin testing the control loop inside the EOMtheRunner using some sort of timers which can still do the job, even if not surely at 1KHz.
In the meantime the development of the embot::hw::timer using the HW of the new H7 CPU can proceed, hopefully in parallel.
This change does not affect other boards which use the same embot::hw::timer driver because I have added functions, and not changed or removed existing ones.
So, this PR can be safely merged.","This PR enhances the embot::hw::timer driver in two ways:

it adds some extra functions required for the porting of the objects EOMtheRunner to the amc application,
it adds the support of emulated HW timers.

The emulation is implemented w/ the embot::os::Timer objects and is enabled w/ macros EMBOT_ENABLE_hw_timer and EMBOT_ENABLE_hw_timer_emulated.
This feature is useful because I can begin testing the control loop inside the EOMtheRunner using some sort of timers which can still do the job, even if not surely at 1KHz.
In the meantime the development of the embot::hw::timer using the HW of the new H7 CPU can proceed, hopefully in parallel.
This change does not affect other boards which use the same embot::hw::timer driver because I have added functions, and not changed or removed existing ones.
So, this PR can be safely merged.",True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,271,2022-05-26T13:01:30Z,2022-05-26T13:03:52Z,2022-05-26T13:03:52Z,MERGED,True,317,27,5,https://github.com/marcoaccame,Enhancement of the `embot::hw::timer` driver,2,[],https://github.com/robotology/icub-firmware/pull/271,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/271#issuecomment-1138553163,"This PR enhances the embot::hw::timer driver in two ways:

it adds some extra functions required for the porting of the objects EOMtheRunner to the amc application,
it adds the support of emulated HW timers.

The emulation is implemented w/ the embot::os::Timer objects and is enabled w/ macros EMBOT_ENABLE_hw_timer and EMBOT_ENABLE_hw_timer_emulated.
This feature is useful because I can begin testing the control loop inside the EOMtheRunner using some sort of timers which can still do the job, even if not surely at 1KHz.
In the meantime the development of the embot::hw::timer using the HW of the new H7 CPU can proceed, hopefully in parallel.
This change does not affect other boards which use the same embot::hw::timer driver because I have added functions, and not changed or removed existing ones.
So, this PR can be safely merged.",cc @sgiraz,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,272,2022-05-30T12:58:42Z,2022-05-30T13:00:36Z,2022-05-30T13:00:36Z,MERGED,True,0,0,1,https://github.com/marcoaccame,Stream of battery data over CAN: documented the protocol,1,[],https://github.com/robotology/icub-firmware/pull/272,https://github.com/marcoaccame,1,https://github.com/robotology/icub-firmware/pull/272,TSD-ICUBUNIT-canprotocol-sensorboards.docx: added a class and a message able to stream battery data.,TSD-ICUBUNIT-canprotocol-sensorboards.docx: added a class and a message able to stream battery data.,True,{}
robotology/icub-firmware,https://github.com/robotology/icub-firmware,272,2022-05-30T12:58:42Z,2022-05-30T13:00:36Z,2022-05-30T13:00:36Z,MERGED,True,0,0,1,https://github.com/marcoaccame,Stream of battery data over CAN: documented the protocol,1,[],https://github.com/robotology/icub-firmware/pull/272,https://github.com/marcoaccame,2,https://github.com/robotology/icub-firmware/pull/272#issuecomment-1141129745,TSD-ICUBUNIT-canprotocol-sensorboards.docx: added a class and a message able to stream battery data.,cc @triccyx,True,{}
