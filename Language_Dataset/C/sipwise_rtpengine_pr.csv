sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/229,The timeout that will limit the duration of a call.,The timeout that will limit the duration of a call.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/229#issuecomment-196445842,The timeout that will limit the duration of a call.,"Just a quick question here. When checking the timeout, you take c->last_signal into account, which means that reinvites would keep the call alive past the timeout. Is this intended?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/229#issuecomment-196880182,The timeout that will limit the duration of a call.,"It is intended to check the call since creation time. Thanks for noticing this.
I've updated pull request also adding rtpengine-ctl setters/getters for this params. Do you think locks are necessary when setting new timeout values? (only ctl thread writes so it's no write concurrency there)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/229#issuecomment-198404473,The timeout that will limit the duration of a call.,"Well, there still is concurrency between reading threads and writing threads, so this must be taken into account. Normally reads and writes to integers are atomic and these values aren't sensitive enough to warrant a lock, but this isn't guaranteed and in some cases (different architectures) accesses might not be atomic, which would open the door to a race condition. So better be on the safe side. Either keep the lock or use dedicated atomic ops (g_atomic_* for example) to access the values.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/smititelu,5,https://github.com/sipwise/rtpengine/pull/229#issuecomment-199169635,The timeout that will limit the duration of a call.,"I've added a rwlock_t in callmaster_config structure, in commit 2830e42. I think it should solve the concurency between reading and writing threads. I'm not 100% percent if you've seen it :D. Is your above comment still applicable after that commit?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/229#issuecomment-199297013,The timeout that will limit the duration of a call.,"Yes I've seen it, thank you. My comment was meant as an explanation of the situation and to offer an alternative solution. But the code is fine as it is now.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/229#issuecomment-199303022,The timeout that will limit the duration of a call.,"Actually, I take that back. :) There's one thing missing. The config_lock is never initialized (rwlock_init)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/smititelu,8,https://github.com/sipwise/rtpengine/pull/229#issuecomment-199315114,The timeout that will limit the duration of a call.,I've added the the rwlock_init. Thank you for noticing.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/rfuchs,9,https://github.com/sipwise/rtpengine/pull/229#issuecomment-199320903,The timeout that will limit the duration of a call.,"Slight complication there. :) The conf structure is overwritten in main.c:610, so the init would have to be done elsewhere, e.g. main.c:531.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,229,2016-03-08T11:19:21Z,2016-03-21T15:08:49Z,2016-06-23T13:34:51Z,MERGED,True,159,29,10,https://github.com/smititelu,Add FINAL_TIMEOUT parameter,5,[],https://github.com/sipwise/rtpengine/pull/229,https://github.com/smititelu,10,https://github.com/sipwise/rtpengine/pull/229#issuecomment-199329698,The timeout that will limit the duration of a call.,I've put it in main.c:537 right after mc gets ZERO'ed.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,231,2016-03-14T14:33:59Z,2016-03-21T13:59:00Z,2016-06-23T13:32:37Z,MERGED,True,164,2,5,https://github.com/smititelu,Add offer/answer/delete processing statistics,2,[],https://github.com/sipwise/rtpengine/pull/231,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/231,"Add graphite offer/answer/delete min/max/avg statistics.
Print new graphite statistics in rtpengine-cli list totals.","Add graphite offer/answer/delete min/max/avg statistics.
Print new graphite statistics in rtpengine-cli list totals.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,231,2016-03-14T14:33:59Z,2016-03-21T13:59:00Z,2016-06-23T13:32:37Z,MERGED,True,164,2,5,https://github.com/smititelu,Add offer/answer/delete processing statistics,2,[],https://github.com/sipwise/rtpengine/pull/231,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/231#issuecomment-196459555,"Add graphite offer/answer/delete min/max/avg statistics.
Print new graphite statistics in rtpengine-cli list totals.","I think you might be able to greatly reduce the amount of code (and especially redundant code) by unifying the variables into a struct, e.g.
struct foobar {
  mutex_t lock;
  u_int64_t count;
  struct timeval time_min, time_max, time_avg;
};
...
  struct foobar offer, answer, delete;

and then move the selection of the appropriate struct to the calling function, e.g.
static void timeval_update(struct foobar *foo, const struct timeval *diff) {
  mutex_lock(&foo->lock);
...
}
...
  timeval_update(&c->callmaster->totalstats_interval.offer, &stop_tv);

What do you think?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,231,2016-03-14T14:33:59Z,2016-03-21T13:59:00Z,2016-06-23T13:32:37Z,MERGED,True,164,2,5,https://github.com/smititelu,Add offer/answer/delete processing statistics,2,[],https://github.com/sipwise/rtpengine/pull/231,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/231#issuecomment-196742221,"Add graphite offer/answer/delete min/max/avg statistics.
Print new graphite statistics in rtpengine-cli list totals.","You are right. The code can be simplified a lot by doing this.
I've updated the pull request accordingly.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,231,2016-03-14T14:33:59Z,2016-03-21T13:59:00Z,2016-06-23T13:32:37Z,MERGED,True,164,2,5,https://github.com/smititelu,Add offer/answer/delete processing statistics,2,[],https://github.com/sipwise/rtpengine/pull/231,https://github.com/smititelu,4,https://github.com/sipwise/rtpengine/pull/231#issuecomment-199163515,"Add graphite offer/answer/delete min/max/avg statistics.
Print new graphite statistics in rtpengine-cli list totals.","Updated pull-request to return (0 sec, 0 usec) timeval in case divisor is 0.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/234,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/234#issuecomment-208372566,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","Hi,
To clarify some of the obj_ functions used here.
The _o versions of the functions are designed to work directly on struct obj type variables, while the regular (non-_o) versions work on the embedded struct obj obj members found in other structs. The __obj versions aren't supposed to be used directly and I see that this is an error in log.h. I'll fix this separately, which will cause a conflict with this pull request - you can just remove those sections then.
I'm OK with the other changes here, minus enabling the OBJ_DEBUG flag - I'd prefer to leave this disabled in the git repo and then enable it only locally.
I'm also OK with an additional -ctl reload function if it helps you. Perhaps use #ifdefs to include it only in debug builds, so people don't accidentally use it on production systems?
The issue you're having is almost certainly related to a refcount booboo somewhere. In case you're not aware, you need to set G_SLICE=always-malloc when debugging with valgrind to defuse the glib slice allocator. Let me know if you need help hunting down the ref leak. The obj debugging stuff enabled should definitely be helpful.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/234#issuecomment-208383781,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","Your intuition is right. I am sure now that the memory leak is a call refcount issue. See http://pastebin.com/FJca6vUq.
Thanks for your advices. I'll let you know if I have some troubles in tracking it down.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/234#issuecomment-208397265,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","0206f09 contains the fixed obj debugging stuff.
Just a quick question, do you see the ref/mem leak only for calls managed through the new notification interface, or for all calls restored from redis?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/234#issuecomment-208400907,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","What you see in the snippet that you pasted is probably because call_get() also uses the call for log_info (through log_info_call()) which holds an additional reference to the call. It gets released when log_info is set to something else or explicitly released through log_info_clear()
Thus, a call_get*() needs to be paired not only with a obj_put() but also with a log_info_clear().",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/234#issuecomment-208402517,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","In practise, every entry point into the code should have a log_info_clear() at its end. Entry points are event handlers, such as control_ng_incoming() or stream_fd_readable(). They should use log_info_clear() just before returning to the handler loop.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,234,2016-04-11T13:44:39Z,2016-04-12T09:12:16Z,2016-06-23T13:33:39Z,CLOSED,False,32,32,1,https://github.com/smititelu,Update obj_* debugging,1,[],https://github.com/sipwise/rtpengine/pull/234,https://github.com/smititelu,7,https://github.com/sipwise/rtpengine/pull/234#issuecomment-208807339,"We are investigating memory leaks that happen only on machines which establish calls via redis notifications (see #225). Leaks are not happening on machines that establish calls via offer/answer.
We believe leaks happen in rtpengine redis_restore_call(). Possible causes:

structures are not freed due to refcounting (this commit will help in debugging this)
free callback function of structures does not free all the content of calls established via redis_restore_call(); however, they free all the content of calls established via offer/answer since the leak can't be noticed there.
redis_restore_call() leak memory inside (e.g. forget to free the content of a glib queue etc..); this can't be noticed on current behaviour since redis_restore() is called only when rtpengine starts. But when notifications are turned on, it will receive SADD->DEL->SADD for each new foreign call which translates to (redis_restore_call()->call_destroy()->redis_restore_call()).

An idea, to be 100% sure that the leaks come from redis_restore_call(), is to have a rtpengine-ctl command that reloads redis calls on-demand. Thus, by repeatedly doing 'reload + terminate all' one can watch the system memory behaviour. Also I will investigate more using Valgrind.
What do you think about the possible causes?
What do you think about having a redis reload ctl command?
Other ideas are welcomed.","For current upstream master, for calls established via offer/answer or via redis_restore this is applicable:

call terminate via BYE => refcounting ok
call terminate via terminate all => refcounting ok
call terminate via terminate call_id => refcounting not ok; struct call is not freed. After calling `log_info_clear()' right before obj_put(),  struct call refcounting is ok.

Thank you for your notes here; it helped alot. I will close this PR and continue working on the notifications PR, considering everything from here.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,235,2016-04-21T00:18:14Z,2016-04-21T12:50:37Z,2016-04-22T00:28:44Z,MERGED,True,2,2,1,https://github.com/slavrov,fix typo and error in rtpengine.init,1,[],https://github.com/sipwise/rtpengine/pull/235,https://github.com/slavrov,1,https://github.com/sipwise/rtpengine/pull/235,"fix typo and error:
./rtpengine.init: line 111: syntax error in conditional expression
./rtpengine.init: line 111: syntax error near -a' ./rtpengine.init: line 111:   if [[ -n ""$REDIS"" -a -n ""$REDIS_DB"" ]]'","fix typo and error:
./rtpengine.init: line 111: syntax error in conditional expression
./rtpengine.init: line 111: syntax error near -a' ./rtpengine.init: line 111:   if [[ -n ""$REDIS"" -a -n ""$REDIS_DB"" ]]'",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,235,2016-04-21T00:18:14Z,2016-04-21T12:50:37Z,2016-04-22T00:28:44Z,MERGED,True,2,2,1,https://github.com/slavrov,fix typo and error in rtpengine.init,1,[],https://github.com/sipwise/rtpengine/pull/235,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/235#issuecomment-212903589,"fix typo and error:
./rtpengine.init: line 111: syntax error in conditional expression
./rtpengine.init: line 111: syntax error near -a' ./rtpengine.init: line 111:   if [[ -n ""$REDIS"" -a -n ""$REDIS_DB"" ]]'",Should the same be done for other instances of [[ .. ]] in this init file?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,235,2016-04-21T00:18:14Z,2016-04-21T12:50:37Z,2016-04-22T00:28:44Z,MERGED,True,2,2,1,https://github.com/slavrov,fix typo and error in rtpengine.init,1,[],https://github.com/sipwise/rtpengine/pull/235,https://github.com/slavrov,3,https://github.com/sipwise/rtpengine/pull/235#issuecomment-213173883,"fix typo and error:
./rtpengine.init: line 111: syntax error in conditional expression
./rtpengine.init: line 111: syntax error near -a' ./rtpengine.init: line 111:   if [[ -n ""$REDIS"" -a -n ""$REDIS_DB"" ]]'","No, that should be enough",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/239,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/239#issuecomment-218471181,,"We are experiencing a segfault only on backup machines (i.e. FOREIGN calls, restored via redis) when printing the CDR upon call_destroy():
(gdb) bt
#0  call_destroy (c=c@entry=0x7fad110fb960) at call.c:2045
#1  0x0000000000417c8f in onRedisNotification (actx=<optimized out>, reply=0x7fad006fec80, privdata=0x2566980) at redis.c:339
#2  0x00007fad2ba0d100 in redisProcessCallbacks () from /usr/lib/x86_64-linux-gnu/libhiredis.so.0.10
#3  0x00007fad2c8d5254 in event_base_loop () from /usr/lib/x86_64-linux-gnu/libevent-2.0.so.5
#4  0x0000000000418599 in redis_notify (cm=cm@entry=0x2566980) at redis.c:543
#5  0x00000000004189f8 in redis_notify_loop (d=0x2566980) at redis.c:587
#6  0x000000000040bc0f in thread_detach_func (d=0x2556d40) at aux.c:143
#7  0x00007fad2b7f0b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#8  0x00007fad2b53b30d in clone () from /lib/x86_64-linux-gnu/libc.so.6
#9  0x0000000000000000 in ?? ()

(gdb) print md
$5 = (struct call_media *) 0x7fad027a9540
(gdb) print md->index
$6 = 1
(gdb) print protocol
$7 = 0x43ea5f ""rtp""
(gdb) print cdrlinecnt
$10 = <optimized out>
(gdb) print addr
$11 = 0x7fad2706f5e4 ""91.60.65.152""

(gdb) print ps
$8 = (struct packet_stream *) 0x7fad050555f0
(gdb) print ps->stats
$9 = {packets = {p = 0x1}, bytes = {p = 0xac}, errors = {p = 0x0}, delay_min = 0, delay_avg = 0, delay_max = 0, in_tos_tclass = 0 '\000', foreign_sessions = {p = 0x0}}
(gdb) print ps->selected_sfd
$4 = (struct stream_fd * volatile) 0x50
(gdb) print ps->selected_sfd->socket
Cannot access memory at address 0x70
(gdb) print ps->selected_sfd->unique_id
Cannot access memory at address 0x68
(gdb) print ps->selected_sfd->call
Cannot access memory at address 0xc8

So far, the only reason/solution we have is this pull-request (not 100% confirmed; just trying to traceback the code). Are there any other ideas why ps->selected_sfd would point to that 0x50 address?!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/239#issuecomment-218474482,,So you happen to still have the raw data from Redis for this particular call?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/smititelu,4,https://github.com/sipwise/rtpengine/pull/239#issuecomment-218519938,,Nope.. I can't find redis content for it. Probably it get deleted on all machines by the delete()/DEL notifications that triggered also this call_destroy().,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/smititelu,5,https://github.com/sipwise/rtpengine/pull/239#issuecomment-218763315,,"A curious stuff found:
(gdb) print (((struct call*)c)->stream_fds)
$46 = {head = 0x3ac46a0, tail = 0x7fad11fa0c00, *length = 8*}
(gdb) print ((struct call*)c)->streams
$24 = {head = 0x5c106e0, tail = 0x3e53940, *length = 8*}

(gdb) print ((struct stream_fd *)(((struct call*)c)->stream_fds.head)->next->next->data)
$68 = (struct stream_fd *) 0x7fad0046a000
(gdb) print ((struct stream_fd *)(((struct call*)c)->stream_fds.head)->next->next->next->data)
$67 = (struct stream_fd *) 0x7fad0156fbd0

but:
(gdb) print ((struct stream_fd *)(((struct call*)c)->stream_fds.head)->next->next->data)->stream->selected_sfd
$65 = (struct stream_fd * volatile) 0x50
(gdb) print ((struct stream_fd *)(((struct call*)c)->stream_fds.head)->next->next->next->data)->stream->selected_sfd
$66 = (struct stream_fd * volatile) 0x0

For all other 6 sfds the values matched.
The scenario is one of a audio failure branching in which 4 monologues are created in total. The kamailio commands to active rtpengine are like this:

offer1 - triggers SADD notification (because there is nothing to DEL)
answer1 - triggers DEL+SADD notification
offer2 - triggers DEL+SADD notification
answer2 - triggers DEL+SADD notification
delete - triggers DEL notification
offer3 - triggers SADD notification (because there is nothing to DEL)
answer3 - triggers DEL(here we had a crash) + SADD
delete - triggers DEL notification (and clears the redis database)

A redis dump would have been very useful and have given a clue how the structures look in redis and how are linked upon restoring call; but I think we won't be able to catch it because we can not reproducing it consistently. If we could reproduce it consistently we could try to delay that answer3 and get it.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/239#issuecomment-218785652,,"Well, the way I see it... selected_sfd gets assigned in redis_link_streams, restored from stream-X-Y hash's sfd value, which is an integer. If selected_sfd was NULL, then that integer was -1 and redis_list_get_ptr would subsequently return NULL.
Point to note that redis_list_get_ptr uses redis_hash_get_unsigned, which internally uses strtol, meaning that -1 is parsed correctly but is returned as a large positive integer, so that should work correctly.
redis_list_get_ptr in turn uses redis_list_get_idx_ptr which checks the index against the array length and only returns the pointer if the index is valid.
The list of sfds is created in redis_get_list_hash using the value from num_sfds. The ptrs array is alocated there but not initialized or populated. It's populated in redis_sfds using the array length in sfds. Any error results in -1 being returned, which aborts the entire restore process. I don't see any possibilities of sfds->ptrs being left uninitialized or initialized incorrectly when used later on.
As for stream->selected_sfd itself, when the stream is allocated, it's initialized to zero, so the only way it could end up as 0x50 is when it gets assigned that value explicitly, which (in the restore) can only happen in redis_link_streams. But it seems to be impossible for sfds to contain invalid pointers.
So it has to be something else. Memory corruption or concurrency would be candidates. One thing I've noticed is that redis_restore_call uses call_get_or_create to create the call struct. Originally this was guaranteed to return a blank and newly allocated call, but now this isn't necessarily true any more. Not sure if that can really make a difference though.
What were the other threads doing at the time the core was generated? (thread apply all bt)
What's the reference count of the call struct? (call->obj.ref) I believe at that point in the code it ought to be 2",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/lbalaceanu,7,https://github.com/sipwise/rtpengine/pull/239#issuecomment-219009822,,"Hi Richard,
We also suspect some race condition.
The reference count of the call struct is 10.
As for the threads, most are waiting as they should be ( the majority in the epoll_wait(), then 1 each for: waiting sighandler, main loop checking the g_shutdown, pthread_cond_timedwait related to ice,  sleeping waiting for graphite)
2 more are:
1 in the onRedisNotification -> call_destroy() (which causes the fault)
1 is in the call.c: callmaster_timer (line 544: atomic64add call):
for (j = 0; j < ke->target.num_payload_types; j++) {
.....
    if (ke->rtp_stats[j].packets > atomic64_get(&rs->packets))
        atomic64_add(&rs->packets,
                  ke->rtp_stats[j].packets - atomic64_get(&rs->packets));

We have another coredump in which the more interesting threads are:
1 in the onRedisNotification -> call_destroy() (which causes the fault)
1 related to callmaster_timer again:
0  0x00007fc32ebe91fd in read () from /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x000000000040ad28 in read (__nbytes=1096, __buf=0x256c450, __fd=32629) at /usr/include/x86_64-linux-gnu/bits/unistd.h:45
#2  kernel_list (id=<optimized out>) at kernel.c:120
#3  0x0000000000412ce2 in callmaster_timer (ptr=0x6e2980) at call.c:501

1 in redis code:
#3  0x000000000041586b in redis_consume (r=<error reading variable: Unhandled dwarf expression opcode 0xfa>, r=<error reading variable: Unhandled dwarf expression opcode 0xfa>) at redis.c:131
#4  0x0000000000419cb9 in redis_update (c=0x7fc30a52a7e0, r=0x6e6030) at redis.c:1918
#5  0x00000000004278ba in call_offer_answer_ng (input=input@entry=0x7fc325904078, m=0x6e2980, output=output@entry=0x7fc325904018, opmode=opmode@entry=OP_OFFER, addr=addr@entry=0x7fc31b4415a0 ""XXX:35200"", 
---Type <return> to continue, or q <return> to quit---
    sin=sin@entry=0x7fc31b441580) at call_interfaces.c:718
#6  0x0000000000429af5 in call_offer_ng (input=input@entry=0x7fc325904078, m=<optimized out>, output=output@entry=0x7fc325904018, addr=addr@entry=0x7fc31b4415a0 ""XXX:35200"", sin=sin@entry=0x7fc31b441580)
    at call_interfaces.c:767
#7  0x000000000041c48d in control_ng_incoming (obj=0x6e4000, buf=<optimized out>, sin=0x7fc31b441580, addr=0x7fc31b4415a0 ""XXX:35200"", ul=0x6e40a0) at control_ng.c:179

I don't necessarily see any pattern in the threads.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/239#issuecomment-219048686,,"Regarding that second core dump you mentioned. Does selected_sfd also point to 0x50 there, or some other value? And, does the offer_answer in the other thread pertain to the same call-id as the call that caused the segfault?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,239,2016-05-11T13:56:36Z,2016-05-11T14:08:21Z,2016-05-13T15:26:51Z,MERGED,True,1,1,1,https://github.com/smititelu,Add >= idx check for redis_list_get_idx_ptr(),1,[],https://github.com/sipwise/rtpengine/pull/239,https://github.com/lbalaceanu,9,https://github.com/sipwise/rtpengine/pull/239#issuecomment-219076470,,"Hi again,
This time value is 0x60:
(gdb) print ((struct stream_fd *)(((struct call*)c)->stream_fds.head)->next->next->data)->stream->selected_sfd
$1 = (struct stream_fd * volatile) 0x60
(gdb) print ((struct stream_fd *)(((struct call*)c)->stream_fds.head)->next->next->next->data)->stream->selected_sfd
$2 = (struct stream_fd * volatile) 0x0

And the call-ids (offer_answer vs segfault) don't match ( what is  more, I presume offer_answer is OWN call, while other is FOREIGN call).
Thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,245,2016-06-16T14:37:08Z,2016-06-28T13:25:52Z,2016-06-29T15:13:11Z,MERGED,True,749,24,12,https://github.com/egreenmachine,Add Feature: Record call to pcap file,42,[],https://github.com/sipwise/rtpengine/pull/245,https://github.com/egreenmachine,1,https://github.com/sipwise/rtpengine/pull/245,See README for options and how to use.,See README for options and how to use.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,245,2016-06-16T14:37:08Z,2016-06-28T13:25:52Z,2016-06-29T15:13:11Z,MERGED,True,749,24,12,https://github.com/egreenmachine,Add Feature: Record call to pcap file,42,[],https://github.com/sipwise/rtpengine/pull/245,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/245#issuecomment-226805881,See README for options and how to use.,Thanks - this is gonna take me a while to go through.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,245,2016-06-16T14:37:08Z,2016-06-28T13:25:52Z,2016-06-29T15:13:11Z,MERGED,True,749,24,12,https://github.com/egreenmachine,Add Feature: Record call to pcap file,42,[],https://github.com/sipwise/rtpengine/pull/245,https://github.com/egreenmachine,3,https://github.com/sipwise/rtpengine/pull/245#issuecomment-228063938,See README for options and how to use.,I made some changes that you requested. Let me know if anything else needs to be done. Thanks!,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,245,2016-06-16T14:37:08Z,2016-06-28T13:25:52Z,2016-06-29T15:13:11Z,MERGED,True,749,24,12,https://github.com/egreenmachine,Add Feature: Record call to pcap file,42,[],https://github.com/sipwise/rtpengine/pull/245,https://github.com/egreenmachine,4,https://github.com/sipwise/rtpengine/pull/245#issuecomment-229380115,See README for options and how to use.,Thanks for pulling this in. Any idea when your next tagged release will be?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,245,2016-06-16T14:37:08Z,2016-06-28T13:25:52Z,2016-06-29T15:13:11Z,MERGED,True,749,24,12,https://github.com/egreenmachine,Add Feature: Record call to pcap file,42,[],https://github.com/sipwise/rtpengine/pull/245,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/245#issuecomment-229388041,See README for options and how to use.,Currently scheduled for 26th of August,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,247,2016-06-23T13:46:54Z,2016-06-28T14:46:51Z,2016-06-28T14:46:51Z,MERGED,True,195,190,3,https://github.com/pkuzak,Do not print statistics of foreign calls,5,[],https://github.com/sipwise/rtpengine/pull/247,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/247,"Statistics of foreign calls are flooding the logs, but are useless most of the time.","Statistics of foreign calls are flooding the logs, but are useless most of the time.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,249,2016-06-29T08:46:30Z,2016-06-29T13:56:56Z,2016-06-29T13:56:56Z,MERGED,True,4,3,1,https://github.com/pkuzak,Make utils package part of meta package,1,[],https://github.com/sipwise/rtpengine/pull/249,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/249,"I propose that the ngcp-rtpengine-utils package gets installed together with the ngcp-rtpengine meta package. If this is explicitly intended not to be the case, this pull request can be simply closed.","I propose that the ngcp-rtpengine-utils package gets installed together with the ngcp-rtpengine meta package. If this is explicitly intended not to be the case, this pull request can be simply closed.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,253,2016-07-14T10:55:22Z,2016-07-15T13:47:29Z,2016-07-25T11:43:13Z,MERGED,True,45,4,2,https://github.com/lbalaceanu,redundant media setup: failover due to tout on offer response,2,[],https://github.com/sipwise/rtpengine/pull/253,https://github.com/lbalaceanu,1,https://github.com/sipwise/rtpengine/pull/253,"Failover scenario because of timeout on offer response: kamailio sends offer information to rtpengine1, but responses don't make it back to kamailio.
Consider a 3 rtpengines redundant media setup. Kamailio tries to establish session with rtpengine2 even though rtpengine1 might have persisted part of the session.
rtpengine2 - deletes previous call in memory and recreates an OWN call in redis (triggers sadd notifies on rtpengine1 and rtpengine3).
rtpengine1 - receives sadd: moves call from own->foreign, deletes call (changes don't propagate in redis); create new foreign call
rtpengine3 - receives sadd:  delete call, create new foreign call","Failover scenario because of timeout on offer response: kamailio sends offer information to rtpengine1, but responses don't make it back to kamailio.
Consider a 3 rtpengines redundant media setup. Kamailio tries to establish session with rtpengine2 even though rtpengine1 might have persisted part of the session.
rtpengine2 - deletes previous call in memory and recreates an OWN call in redis (triggers sadd notifies on rtpengine1 and rtpengine3).
rtpengine1 - receives sadd: moves call from own->foreign, deletes call (changes don't propagate in redis); create new foreign call
rtpengine3 - receives sadd:  delete call, create new foreign call",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,253,2016-07-14T10:55:22Z,2016-07-15T13:47:29Z,2016-07-25T11:43:13Z,MERGED,True,45,4,2,https://github.com/lbalaceanu,redundant media setup: failover due to tout on offer response,2,[],https://github.com/sipwise/rtpengine/pull/253,https://github.com/lbalaceanu,2,https://github.com/sipwise/rtpengine/pull/253#issuecomment-232716420,"Failover scenario because of timeout on offer response: kamailio sends offer information to rtpengine1, but responses don't make it back to kamailio.
Consider a 3 rtpengines redundant media setup. Kamailio tries to establish session with rtpengine2 even though rtpengine1 might have persisted part of the session.
rtpengine2 - deletes previous call in memory and recreates an OWN call in redis (triggers sadd notifies on rtpengine1 and rtpengine3).
rtpengine1 - receives sadd: moves call from own->foreign, deletes call (changes don't propagate in redis); create new foreign call
rtpengine3 - receives sadd:  delete call, create new foreign call","So I think I can enhance the code in call_interfaces.c -> call_offer_answer_ng() somehow around this form (maybe more attention to the refrences and locks is required) :
if (opmode == OP_OFFER) {  
    call = call_get(&callid, m);
    if (call) {
        if (IS_FOREIGN_CALL(call)) {
            rwlock_unlock_w(&call->master_lock);
            call_destroy(call);
        }
    }
    else call = call_get_or_create();
}
else call = call_get(&callid, m);
Is this what you had in mind? We still have the hash lookup done twice in case of (OP_OFFER and new call).
Thank you,
Lucian",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,253,2016-07-14T10:55:22Z,2016-07-15T13:47:29Z,2016-07-25T11:43:13Z,MERGED,True,45,4,2,https://github.com/lbalaceanu,redundant media setup: failover due to tout on offer response,2,[],https://github.com/sipwise/rtpengine/pull/253,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/253#issuecomment-232724326,"Failover scenario because of timeout on offer response: kamailio sends offer information to rtpengine1, but responses don't make it back to kamailio.
Consider a 3 rtpengines redundant media setup. Kamailio tries to establish session with rtpengine2 even though rtpengine1 might have persisted part of the session.
rtpengine2 - deletes previous call in memory and recreates an OWN call in redis (triggers sadd notifies on rtpengine1 and rtpengine3).
rtpengine1 - receives sadd: moves call from own->foreign, deletes call (changes don't propagate in redis); create new foreign call
rtpengine3 - receives sadd:  delete call, create new foreign call",Yeah something like that should work. Thanks,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/dbmikus,1,https://github.com/sipwise/rtpengine/pull/255,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.","Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/255#issuecomment-232728310,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.","Hi, thanks for the report. Looks like you're right: call->recording->metadata isn't sufficiently protected by a lock. But I don't think it's necessary to add another mutex for this.
call->recording is supposed to be protected by call->master_lock. call->recording->metadata can then be protected either by ->master_lock also, or by ->recording->recording_lock. I think using the master_lock makes more sense. From a quick glance, it looks like all that is necessary is to move the respective code in call_offer_answer_ng up by a few lines.
Let me know what you think.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/dbmikus,3,https://github.com/sipwise/rtpengine/pull/255#issuecomment-232745569,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.","@egreenmachine and I talked about using the ->recording->recording_lock, but he brought up the point that, since recording_lock locks against writing RTP data to the PCAP file, updating the metadata might interfere and prevent writing output.
However, if the RTP flowing in is buffered, then I don't think we would run into issues with waiting on the lock when writing out PCAP data.
Is that correct?
If the potential problem @egreenmachine and I discussed is a non-issue, then it seems like using the call->master_lock and just moving the code up into that section is the solution.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/255#issuecomment-232752355,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.","Either way shouldn't be a problem. During signalling (offer/answer/delete), the master_lock is always acquired in write mode, which keeps the RTP processing from acquiring a read lock, so these two will always interfere with each other in some way.
On second thought, call->recording is created and assigned with a write lock held on master_lock. The code below accesses call->recording to get to the metadata, so this must hold master_lock at least in read mode by definition. It would make most sense to simply include the metadata in what's protected by master_lock (as write lock).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/dbmikus,5,https://github.com/sipwise/rtpengine/pull/255#issuecomment-232779320,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.","I pushed an updated commit. I can squash it in a new pull request when this looks good to go in, but I just wanted to keep any discussion streamlined until then.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/255#issuecomment-232789196,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.",Looks good to me,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,255,2016-07-14T16:56:16Z,2016-07-15T20:10:15Z,2016-07-15T20:10:15Z,CLOSED,False,23,20,2,https://github.com/dbmikus,Made interactions with recording metadata threadsafe,2,[],https://github.com/sipwise/rtpengine/pull/255,https://github.com/dbmikus,7,https://github.com/sipwise/rtpengine/pull/255#issuecomment-233057715,"Updating, freeing, and writing the recording metadata is now threadsafe. This is in regards to the metadata that we receive from the rtpengine_offer or rtpengine_answer commands, not the meta_fp file.
We got an rtpengine crash that happened when calling free(call->recording->metadata); at https://github.com/sipwise/rtpengine/blob/master/daemon/call_interfaces.c#L753.
We are pretty sure this happened due to a double-free, but weren't able to exactly reproduce this in the code. Either way, if call_offer_answer_ng can be called simultaneously in multiple threads, it was technically possible to attempt to double-free the recording->metadata string. A mutex lock prevents that.",See squashed request: #256,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,256,2016-07-15T20:09:56Z,2016-07-18T13:29:37Z,2016-07-19T20:26:52Z,MERGED,True,23,20,2,https://github.com/dbmikus,Made interactions to recording metadata threadsafe,1,[],https://github.com/sipwise/rtpengine/pull/256,https://github.com/dbmikus,1,https://github.com/sipwise/rtpengine/pull/256,"Updating, freeing, and writing the recording metadata is now
threadsafe. This is in regards to the metadata that we receive from
the rtpengine_offer or rtpengine_answer commands, not the
meta_fp file.
We can simply use the call->master_lock variable for protecting
updates to the recording metadata. We had to move the metadata
handling code in call_interfaces.c up into the master_lock guarded
section. The code in ""recording.c:meta_finish_file"" is called with
master_lock protection already.","Updating, freeing, and writing the recording metadata is now
threadsafe. This is in regards to the metadata that we receive from
the rtpengine_offer or rtpengine_answer commands, not the
meta_fp file.
We can simply use the call->master_lock variable for protecting
updates to the recording metadata. We had to move the metadata
handling code in call_interfaces.c up into the master_lock guarded
section. The code in ""recording.c:meta_finish_file"" is called with
master_lock protection already.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,259,2016-07-20T11:57:33Z,2016-07-22T13:45:12Z,2016-07-22T13:45:12Z,MERGED,True,2,0,2,https://github.com/pkuzak,Configuration file support for recording-dir,1,[],https://github.com/sipwise/rtpengine/pull/259,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/259,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/lbalaceanu,1,https://github.com/sipwise/rtpengine/pull/262,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured","Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/262#issuecomment-235004145,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured",278561b seems to duplicate the log severity when logging to stderr (log_to_stderr() already includes this).,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/lbalaceanu,3,https://github.com/sipwise/rtpengine/pull/262#issuecomment-235197897,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured","Hi Richard - you are right. To solve this, I would delete the printing of the log severity in the log_to_stderr() which solves the problem. Agree?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/262#issuecomment-235270536,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured",Works for me,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/lbalaceanu,5,https://github.com/sipwise/rtpengine/pull/262#issuecomment-235288725,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured","Ok, and how about making --log-stderr available from ngcp-rtpengine-daemon.init + adding in ngcp-rtpengine-daemon.default # LOG_STDERR=""no""?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/262#issuecomment-235290143,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured","Not sure how useful that is from an init.d script, but hey, why not :)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,262,2016-07-25T13:48:14Z,2016-07-26T14:52:27Z,2016-07-26T14:52:27Z,MERGED,True,98,54,10,https://github.com/lbalaceanu,Various minor improvements,7,[],https://github.com/sipwise/rtpengine/pull/262,https://github.com/lbalaceanu,7,https://github.com/sipwise/rtpengine/pull/262#issuecomment-235292093,"Report own/foreign/total sessions to Graphite
Printing severity level within every log message


rtpengine[4613]: ERR: Socket connect failed. fd: 25, Reason: Connection refused
                                                         vs
rtpengine[4613]: Socket connect failed. fd: 25, Reason: Connection refused



Print relay IP information: add relay IP info in MDR, rtpengine-ctl list sessions <Call-ID>, call_destroy()
Adding redis_expires parameter: default is 86400, but this can be configured",Updated the pull request.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,263,2016-07-26T20:41:43Z,2016-07-28T13:25:30Z,2016-07-28T13:25:30Z,MERGED,True,15,1,3,https://github.com/egreenmachine,Make rtpengine packaging more compatible with el7,4,[],https://github.com/sipwise/rtpengine/pull/263,https://github.com/egreenmachine,1,https://github.com/sipwise/rtpengine/pull/263,This pull request makes the rtpengine default spec file more compatible with el7. It also allows the installation of the kernel module on el7 using DKMS.,This pull request makes the rtpengine default spec file more compatible with el7. It also allows the installation of the kernel module on el7 using DKMS.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,268,2016-08-23T11:26:08Z,2016-09-29T16:50:45Z,2016-09-29T16:50:45Z,MERGED,True,2,1,2,https://github.com/pkuzak,Add REDIS_EXPIRES to default configuration file,2,[],https://github.com/sipwise/rtpengine/pull/268,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/268,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,269,2016-08-24T19:50:18Z,2016-11-02T16:54:14Z,2016-11-02T16:54:14Z,MERGED,True,2,0,2,https://github.com/SIGUSR2,Make --dtls-passive available from ngcp-rtpengine-daemon.init,1,[],https://github.com/sipwise/rtpengine/pull/269,https://github.com/SIGUSR2,1,https://github.com/sipwise/rtpengine/pull/269,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,1,https://github.com/sipwise/rtpengine/pull/286,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,2,https://github.com/sipwise/rtpengine/pull/286#issuecomment-257924600,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","Further information:
(gdb) bt full
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
        l = 0x3519940
        n = 0x7f24b042db80
        k = <optimized out>
        m = 0x7f24acbd9080
        ml = <optimized out>
        ml2 = <optimized out>
        media = <optimized out>
        ps = <optimized out>
        sfd = 0x0
        il = <optimized out>
        ep = 0x7f24987fa760
        pt = <optimized out>
        redis_expires_s = 86400
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
        sdp = {
          s = 0x7f24c45f0602 ""v=0\r\no=- 2476064514 1190582884 IN IP4 xxx.xxx.xxx.xxx\r\ns=-\r\nc=IN IP4 xxx.xxx.xxx.xxx\r\nt=0 0\r\nm=audio 37868 RTP/AVP 8 101\r\na=rtpmap:8 PCMA/8000\r\na=rtpmap:101 telephone-event/8000\r\na=ptime:20\r\n3:ICE6:remo""..., len = 189}
        fromtag = {
          s = 0x7f24c45f06d7 ""nggk9q3o-CC-1003-OFC-85:flagsl14:unidirectional10:asymmetric13:trust-address13:strict-sourcee7:replacel6:origine7:call-id31:ED582781E5282D16@xxx.xxx.xxx.xxx10:via-branch4:main13:received-froml3:IP414:2""..., len = 22}
        totag = {s = 0x7f24c45f07ba ""C5455B48078B1D497:command6:answere"", len = 16}
        callid = {s = 0x7f24c45f0753 ""ED582781E5282D16@xxx.xxx.xxx.xxx10:via-branch4:main13:received-froml3:IP414:xxx.xxx.xxx.xxxe8:from-tag16:C5455B48078B1D497:command6:answere"", len = 31}
        viabranch = {s = 0x7f24c45f0781 ""main13:received-froml3:IP414:xxx.xxx.xxx.xxxe8:from-tag16:C5455B48078B1D497:command6:answere"", len = 4}
        recordcall = <optimized out>
        metadata = <optimized out>
        errstr = 0x443d4e ""Invalid dialogue association""
        parsed = {head = 0x32ed240, tail = 0x32ed240, length = 1}
        streams = {head = 0x7f2498ca7e40, tail = 0x7f2498ca7e40, length = 1}
        call = 0x7f24b05c85a0
        monologue = 0x7f24a4b4a150
        ret = 0
        flags = {opmode = OP_ANSWER, received_from_family = {s = 0x7f24c45f0798 ""IP414:xxx.xxx.xxx.xxxe8:from-tag16:C5455B48078B1D497:command6:answere"", len = 3}, received_from_address = {
            s = 0x7f24c45f079e ""xxx.xxx.xxx.xxxe8:from-tag16:C5455B48078B1D497:command6:answere"", len = 14}, media_address = {s = 0x0, len = 0}, transport_protocol_str = {s = 0x0, len = 0}, address_family_str = {s = 0x0, len = 0}, 
          transport_protocol = 0x0, parsed_received_from = {family = 0x0, u = {ipv4 = {s_addr = 0}, ipv6 = {__in6_u = {__u6_addr8 = '\000' <repeats 15 times>, __u6_addr16 = {0, 0, 0, 0, 0, 0, 0, 0}, __u6_addr32 = {0, 0, 0, 
                    0}}}}}, parsed_media_address = {family = 0x0, u = {ipv4 = {s_addr = 0}, ipv6 = {__in6_u = {__u6_addr8 = '\000' <repeats 15 times>, __u6_addr16 = {0, 0, 0, 0, 0, 0, 0, 0}, __u6_addr32 = {0, 0, 0, 0}}}}}, 
          direction = {{s = 0x0, len = 0}, {s = 0x0, len = 0}}, address_family = 0x0, tos = 256, asymmetric = -1, unidirectional = -1, trust_address = -1, port_latching = 0, replace_origin = -1, replace_sess_conn = 0, 
          ice_remove = -1, ice_force = 0, ice_force_relay = 0, rtcp_mux_offer = 0, rtcp_mux_demux = 0, rtcp_mux_accept = 0, rtcp_mux_reject = 0, strict_source = -1, media_handover = 0, dtls_passive = 0, reset = 0, dtls_off = 0, 
          sdes_off = 0, sdes_unencrypted_srtp = 0, sdes_unencrypted_srtcp = 0, sdes_unauthenticated_srtp = 0, sdes_encrypted_srtp = 0, sdes_encrypted_srtcp = 0, sdes_authenticated_srtp = 0}
        chopper = 0x7f24acfeee60
        recording = <optimized out>
        recordings = 0x7f24a1c08108",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/286#issuecomment-257926159,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","I'd say you're right. Even if ports are unavailable or couldn't be opened, the contents of (struct intf_list)->list should never be null. This list is normally built in __get_endpoint_map using return values of stream_fd_new and this function never returns null.
The only other place where this list gets built is in the redis restore code, namely in redis_link_maps so it's probably some inconsistency in the data in redis that causes this. You wouldn't happen to have a dump of the redis data pertaining to the offending call?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,4,https://github.com/sipwise/rtpengine/pull/286#issuecomment-257934710,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","Hello,
Unfortunately we don't have such a dump of the redis database, but I will also look in redis_link_maps code and maybe also fix from there until we stabilize the redis reading/ writing itself.
We do have logs:
=============== rtp1
18:00:21  rtpengine[42502]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Received command 'offer' from xxx.xxx.xxx.xxx:37666
18:00:21  rtpengine[42502]: ERR: [zzzzzz@xxx.xxx.xxx.xxx]: Redis-Notifier: SADD already find call with callid: zzzzzz@xxx.xxx.xxx.xxx; deleting the existing one.
18:00:21  rtpengine[42502]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: offer time = 0.065399 sec
18:00:21  rtpengine[42502]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Replying to 'offer' from xxx.xxx.xxx.xxx:37666
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Final packet stats:
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --- Tag 'wwwwwwww', created 46960827:55 ago for branch '', in dialogue with ''
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: ------ Media #1 (audio over RTP/AVP) using unknown codec
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port         0.0.0.0:0     <>  xxx.xxx.xxx.xxx:7082 , 0 p, 0 b, 0 e, 1477319762 last_packet
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port         0.0.0.0:0     <>  xxx.xxx.xxx.xxx:7083  (RTCP), 0 p, 0 b, 0 e, 1477319762 last_packet
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --- Tag '', created 46960827:55 ago for branch 'main', in dialogue with 'wwwwwwww'
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: ------ Media #1 (audio over RTP/AVP) using unknown codec
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port         0.0.0.0:0     <>         0.0.0.0:0    , 0 p, 0 b, 0 e, 1477319762 last_packet
19:03:02  rtpengine[116969]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port         0.0.0.0:0     <>         0.0.0.0:0     (RTCP), 0 p, 0 b, 0 e, 1477319762 

=============== rtp2
18:00:21  rtpengine[122716]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Received command 'offer' from xxx.xxx.xxx.xxx:55302
18:00:21  rtpengine[122716]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: offer time = 0.013266 sec
18:00:21  rtpengine[122716]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Replying to 'offer' from xxx.xxx.xxx.xxx:55302
18:00:21  rtpengine[122716]: ERR: [zzzzzz@xxx.xxx.xxx.xxx]: Redis-Notifier: SADD already find call with callid: zzzzzz@xxx.xxx.xxx.xxx; deleting the existing one.
18:00:21  rtpengine[122716]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Received command 'answer' from xxx.xxx.xxx.xxx:42770
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Closing call due to timeout
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: Final packet stats:
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --- Tag 'wwwwwwww', created 62:41 ago for branch '', in dialogue with ''
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: ------ Media #1 (audio over RTP/AVP) using unknown codec
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port   xxx.xxx.xxx.xxx:32736 <>  xxx.xxx.xxx.xxx:7082 , 0 p, 0 b, 0 e, 1477317782 last_packet
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port   xxx.xxx.xxx.xxx:32737 <>  xxx.xxx.xxx.xxx:7083  (RTCP), 0 p, 0 b, 0 e, 1477317782 last_packet
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --- Tag '', created 62:41 ago for branch 'main', in dialogue with 'wwwwwwww'
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: ------ Media #1 (audio over RTP/AVP) using unknown codec
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port   xxx.xxx.xxx.xxx:32722 <>         0.0.0.0:0    , 0 p, 0 b, 0 e, 1477317782 last_packet
19:03:02  rtpengine[40977]: INFO: [zzzzzz@xxx.xxx.xxx.xxx]: --------- Port   xxx.xxx.xxx.xxx:32723 <>         0.0.0.0:0     (RTCP), 0 p, 0 b, 0 e, 1477317782 last_packet
19:03:02  rtpengine[40977]: NOTICE: Redis-Notifier: DEL did not find call with callid: zzzzzz@xxx.xxx.xxx.xxx",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,5,https://github.com/sipwise/rtpengine/pull/286#issuecomment-257934870,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","Additionally, we also encountered increased kamailio - rtpengine timeout cases lately at offer and maybe port allocation inside  __get_consecutive_ports function could be improved when dealing with large number of allocations (getting close to the maximum number of ports available). I am thinking at something like a stack of available ports fromout which to allocate/ free. This would have to also take into account that RTCP should be on odd ports and RTP on even ones, if we are to be consistent with the current implementation. This is just a thought.
Thank you for your prompt answer",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/linuxmaniac,6,https://github.com/sipwise/rtpengine/pull/286#issuecomment-257939709,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?",@lbalaceanu please use the Markdown format specially when pasting gdb output or github gets confused,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/pkuzak,7,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258088865,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","@rfuchs , you mentioned inconsistent data may have caused this issue. I would kind of agree, as we also think other issues we have are related to reading inconsistent Redis data. I suppose the problem is that data related to one call is stored in multiple key-value pairs in Redis, and those data is updated in a non-transactional way. Therefore, in our setup, a slave might end up reading a call from Redis where part of the keys are already updated and the other part not.
In order to improve this, we plan to extend redis.c  and cover all the Redis read/write commands referring to one call with MULTI and EXEC Redis transaction commands.
Parallel to this, we are also evaluating changing the call data structure how a call is represented in Redis. Our goal is to just have one key-value pair for one call.
Any thoughts on this?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258160571,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","That's probably a good idea for your use case. To be fair, the current redis code was never intended to be used in an active-active setup and so it's possible there are some race conditions in there that could lead to inconsistent data.
AFAIK indidvidual redis commands are guaranteed to be atomic, so I'd say either using transactions or using a single key would be sufficient, assuming the key is always updated using a single command. I don't think there's a need for both mechanisms.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/pkuzak,9,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258164929,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","I have the same understanding of individual Redis commands you have regarding atomicity and I also don't see the need for both implementations to co-exist. It's just that extending redis.c with MULTI and EXEC commands is easier and faster to implement than restructuring the Redis call data structure. So we rather think of using Redis transactions as a short term solution, but for the long term we are targeting the one key-value pair solution (which then will not require MULTI and EXEC commands). It depends a bit on how much effort/time it will take.
Thank you for you input.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/rfuchs,10,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258226199,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?",Are you still working on this pull req or should I merge it?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,11,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258381574,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","Hi,
Please leave it open for now as I am working on the redis_link_maps part following your hint.
Thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,12,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258836270,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?",I updated the code in the pull request with a check for null sfds in redis_link_maps instead of the check in the redis_update().,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,286,2016-11-02T16:18:48Z,2016-11-07T16:31:07Z,2016-11-07T16:31:07Z,MERGED,True,11,1,1,https://github.com/lbalaceanu,avoid coredump for strange cases when redis_update finds structures in ep->intf_sfds to be null,2,[],https://github.com/sipwise/rtpengine/pull/286,https://github.com/lbalaceanu,13,https://github.com/sipwise/rtpengine/pull/286#issuecomment-258841722,"There seems to be a strange race condition in the rtpengine so that we get the following coredump and see that in fact SFDs inside ep->intf_sfds seem to be null.
#0  0x000000000041a4a2 in redis_update (c=0x7f24b05c85a0, r=0x143b030) at redis.c:1921
#1  0x00000000004284d6 in call_offer_answer_ng (input=input@entry=0x7f24a17a5da8, m=0x1437d80, output=output@entry=0x7f24a17a5d48, opmode=opmode@entry=OP_ANSWER, addr=addr@entry=0x0, sin=sin@entry=0x0) at call_interfaces.c:766
#2  0x000000000042a890 in call_answer_ng (input=input@entry=0x7f24a17a5da8, m=<optimized out>, output=output@entry=0x7f24a17a5d48) at call_interfaces.c:819
#3  0x000000000041cf89 in control_ng_incoming (obj=0x1439000, buf=<optimized out>, sin=0x7f24c45f0580, addr=0x7f24c45f05a0 ""xxx.xxx.xxx.xxx:42770"", ul=0x14390a0) at control_ng.c:193
#4  0x000000000041bfc3 in udp_listener_incoming (fd=<optimized out>, p=0x14296a0, x=<optimized out>) at udp_listener.c:56
#5  0x000000000040b9b6 in poller_poll (p=p@entry=0x1426a90, timeout=timeout@entry=100) at poller.c:348
#6  0x000000000040c25d in poller_loop (d=0x1426a90) at poller.c:502
#7  0x000000000040c2df in thread_detach_func (d=0x1427720) at aux.c:143
#8  0x00007f24cbd88b50 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#9  0x00007f24cbad2fbd in clone () from /lib/x86_64-linux-gnu/libc.so.6

The scenario is a little more complex: rtp1 receives an OFFER and until it answers Kamailio timeouts and sends OFFER to rtp2. At ANSWER, rtp2 tries to write information in redis and there it crashes producing the coredump.
rtp2 gets restarted and some time later both it and rtp1 expire the call producing some statistics, which suggest that both rtps think they are responsible for the call (IS_FOREIGN(call) == 0).
We are not sure how the sfds can get null since we would expect the call setup to end when no more ports are available. Are we wrong here?","I also added a somehow similar commit for fixing a segfault when creating a call from an incorrect redis database.
From our point of view you can now merge the pull request.
Thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,293,2016-11-16T09:52:20Z,2016-11-18T21:37:34Z,2016-11-18T21:37:34Z,CLOSED,False,43,7,4,https://github.com/khoegh,Recording crash and feature (#292 and #290),8,[],https://github.com/sipwise/rtpengine/pull/293,https://github.com/khoegh,1,https://github.com/sipwise/rtpengine/pull/293,"Added --recording-format, to support raw (default) or to fake ethernet frames in pcap files.","Added --recording-format, to support raw (default) or to fake ethernet frames in pcap files.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,295,2016-11-18T13:00:23Z,2016-11-18T21:38:56Z,2017-02-14T10:21:28Z,MERGED,True,7,1,2,https://github.com/pkuzak,Added flag 'no-redis-update',1,[],https://github.com/sipwise/rtpengine/pull/295,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/295,"This flag can be used by the signaling proxy in order to tell rtpengine not to persist the call into Redis upon receiving offer/answer() control commands.
Upon merging this we'll upgrade the Kamailio rtpengine module documentation accordingly.","This flag can be used by the signaling proxy in order to tell rtpengine not to persist the call into Redis upon receiving offer/answer() control commands.
Upon merging this we'll upgrade the Kamailio rtpengine module documentation accordingly.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,297,2016-11-24T16:31:15Z,2016-11-24T16:34:41Z,2016-11-24T16:34:41Z,MERGED,True,17,10,1,https://github.com/winem,small fixes; updated the specs file to be compatible to rtpengine 4.5 and CentOS 7.2,1,[],https://github.com/sipwise/rtpengine/pull/297,https://github.com/winem,1,https://github.com/sipwise/rtpengine/pull/297,Successfully tested all packages with CentOS 7.2,Successfully tested all packages with CentOS 7.2,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,300,2016-12-06T09:54:56Z,2016-12-06T12:46:44Z,2016-12-06T13:51:08Z,MERGED,True,37,64,1,https://github.com/pkuzak,Reduced complexity in onRedisNotification(),1,[],https://github.com/sipwise/rtpengine/pull/300,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/300,"If a call already exists and a Redis notification for that call is received, don't change the call (ignore notification).","If a call already exists and a Redis notification for that call is received, don't change the call (ignore notification).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,300,2016-12-06T09:54:56Z,2016-12-06T12:46:44Z,2016-12-06T13:51:08Z,MERGED,True,37,64,1,https://github.com/pkuzak,Reduced complexity in onRedisNotification(),1,[],https://github.com/sipwise/rtpengine/pull/300,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/300#issuecomment-265132803,"If a call already exists and a Redis notification for that call is received, don't change the call (ignore notification).","Seems OK, except for a small booboo which seems to be present in the original code already. The obj_put in line 1501/1474 should not be called before unlocking the master_lock (1504/1489). I'll fix it in a separate commit.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/302,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,2,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266391203,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","Thanks for commenting. I didn't know there is such a tool. I've updated this pull request, should be fine now. If not, please report back.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,3,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266695345,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","Basically you are right and I agree with you. I think the problem is that in Wheezy, just having the depends on dev packages does not work because by default it tries to install the package from the wheezy repository, but it does not work with that one. We need the one from the wheezy-backports repository, having version >=6:10 . Just adding the version to the dev packages does not work, because those then depend on the corresponding wheezy-backport packages, but don't get installed by default. At least we end up in build errors like:
The following packages have unmet dependencies:
 libavresample-dev : Depends: libavutil-dev (= 6:10.1-1~bpo70+1) but 6:0.8.17-2 is to be installed
E: Unable to correct problems, you have held broken packages.

Nonetheless I've updated the pull request.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,4,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266727663,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","Squashed commits into one.
Regarding tuning apt: This is not an option for us. I am aware of this solution, but we are using a company wide build server which is not maintained by our team and most probably they will not change the configuration there.
I haven't tried whether the build works when leaving out the versions in the build dependencies, because I wasn't able to satisfy apt without them.
I am indeed not a Debian packaging expert, but I thought this is a valid solution.
Due to the fact that we have to use the company build server and don't have access to it to change the configuration, I am not aware of an other solution for us than proposed in this pull request. If you know a better solution, please share it with me.
You can reject this pull request if it doesn't satisfy you requirements. If we don't find an alternative, we'll have to keep this ""patch"" locally then (at least as long we will need to build for Wheezy).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,5,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266744148,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.",So what? Shall I close this pull request or do you have an idea how to solve this without being able to change the apt configuration?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266745321,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.",Restricting the -dev packages to certain minimum version numbers is not sufficient?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,7,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266746156,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","No, because, for example, libswscale-dev=6:10.1-1~bpo70+1 depends on libswscale2=6:10.1-1~bpo70+1, but apt will refuse to install it without explicitly mentioning it in the control file. Similar does apply for the other dev packages. We end up with errors like:
The following packages have unmet dependencies:
 libavresample-dev : Depends: libavutil-dev (= 6:10.1-1~bpo70+1) but 6:0.8.17-2 is to be installed
E: Unable to correct problems, you have held broken packages.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/guillemj,8,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266756143,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","@pkuzak I don't think this needs to be closed. There are some changes that seem mergable. The actual code changes, and perhaps the version restrictions. But the rest are just incorrect. The problem here is that the wheezy-backports repository sets the NotAutomatic and ButAutomaticUpgrades fields to ""yes"" which means package manager will not pull new packages not explicitly requested, it will only upgrade already installed ones (https://wiki.debian.org/RepositoryFormat#NotAutomatic_and_ButAutomaticUpgrades).
I still think this is a local setup problem that you should fix ideally in your organization. Is requesting such change to that other group managing the infra out of the question? It seems like the correct thing to do here, really.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,302,2016-12-07T12:15:38Z,2016-12-13T15:30:33Z,2016-12-13T15:31:10Z,MERGED,True,14,7,4,https://github.com/pkuzak,Stricter build dependencies,1,[],https://github.com/sipwise/rtpengine/pull/302,https://github.com/pkuzak,9,https://github.com/sipwise/rtpengine/pull/302#issuecomment-266762568,"The recording feature seems to require a minimal version of libav related packages.
Tested on Wheezy and Jessie.","Works 👍 . I've updated the pull request. Now there are just dependencies on dev packages. Sorry for this long discussion, but I wasn't aware of those flags.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,305,2016-12-08T11:28:20Z,2016-12-12T18:48:41Z,2017-04-27T15:53:29Z,MERGED,True,844,0,2,https://github.com/lbalaceanu,Pictures for Internal data structures and Redis correlations wiki,1,[],https://github.com/sipwise/rtpengine/pull/305,https://github.com/lbalaceanu,1,https://github.com/sipwise/rtpengine/pull/305,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/316,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,2,https://github.com/sipwise/rtpengine/pull/316#issuecomment-271838721,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Hi Richard,
I write you back since this stuff is mostly my implementation :-)
Thank you very much for the comments on this. I'll take care and fix the your mentioned points.
Cheers, Frédéric",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/pkuzak,3,https://github.com/sipwise/rtpengine/pull/316#issuecomment-271841747,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","@rfuchs , regarding the root_reader, could we go with a trade-off and keep it like it is in this pull request (being part of the call object)? We are going to refactor the code anyway to fit better with the new implementation, so we would fix this in a future pull request.
We've put the root_reader to the call object because we didn't find a solution how to achieve this in a different way without introducing bigger changes.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/316#issuecomment-272882082,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Hi, I see you pushed the fixes to a different branch. Can you please update the pull request (squash/amend commit preferred if possible) so I can look over them again, thanks.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,5,https://github.com/sipwise/rtpengine/pull/316#issuecomment-273143215,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",Ok sorry I rebased into redis-onekey-concept-master,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/316#issuecomment-276427029,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","So when trying this (start rtpengine, launch some calls, kill it and restart it), I run into a bunch of errors. Only one out of 20 calls could be restored, the others failed with
[1485882301.668752] DEBUG: Processing call ID 'json-YYyJZ5npL9VIfisrp5bPrP9u1fw5tLRRQg3U0uVCMizzcgaUTb' from Redis
[1485882301.668756] DEBUG: Processing call ID 'json-h7GZ8SbT5uhsZ6WPE6GQotiBWfbbqMweAtmY4lWzONs4TKjuT4' from Redis
[1485882301.668990] DEBUG: Could not parse json data !
[1485882301.668990] DEBUG: Could not parse json data !
...
[1485882301.669702] WARNING: Failed to restore call ID 'ysokNURgnpQ1sZQS36NFzpjr8bxnr4nOVrn7m7xucFt919AdwU' from Redis: failed to create sfds
[1485882301.669702] WARNING: Failed to restore call ID '5vIGFXe5T4HfBBCdxNGxqheMPtFAXo4pGkypUZlhIs0SZMGclC' from Redis: failed to create sfds

There seems to be a problem with storing binary data (encryption keys) into JSON format, perhaps related to unicode/utf8 encoding issues.
Sample JSON body of a failed call, straight out of redis:
{""json-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm"":{""created"":""1485882283"",""last_signal"":""1485882283"",""tos"":""0"",""deleted"":""0"",""num_sfds"":""8"",""num_streams"":""4"",""num_medias"":""2"",""num_tags"":""2"",""num_maps"":""2"",""ml_deleted"":""0"",""created_from"":""[::1]:56850"",""created_from_addr"":""::1"",""redis_hosted_db"":""0""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":{""pref_family"":""IP6"",""localport"":""30426"",""logical_intf"":""default"",""local_intf_uid"":""0"",""stream"":""0"",""-crypto_suite"":""AES_CM_128_HMAC_SHA1_80"",""-master_key"":""2KAxLBIURybEs6XAhAxSSSQ17Xs008"",""-master_salt"":""hAxSSSQ17Xs008"",""-unenc-srtp"":""0"",""-unenc-srtcp"":""0"",""-unauth-srtp"":""0"",""last_index"":""37369"",""ssrc"":""4043817941""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":{""pref_family"":""IP6"",""localport"":""30427"",""logical_intf"":""default"",""local_intf_uid"":""0"",""stream"":""1"",""-crypto_suite"":""AES_CM_128_HMAC_SHA1_80"",""-master_key"":""2KAxLBIURybEs6XAhAxSSSQ17Xs008"",""-master_salt"":""hAxSSSQ17Xs008"",""-unenc-srtp"":""0"",""-unenc-srtcp"":""0"",""-unauth-srtp"":""0"",""last_index"":""0"",""ssrc"":""0""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-2"":{""pref_family"":""IP6"",""localport"":""30434"",""logical_intf"":""default"",""local_intf_uid"":""1"",""stream"":""0""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-3"":{""pref_family"":""IP6"",""localport"":""30435"",""logical_intf"":""default"",""local_intf_uid"":""1"",""stream"":""1""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-4"":{""pref_family"":""IP6"",""localport"":""30438"",""logical_intf"":""default"",""local_intf_uid"":""0"",""stream"":""2""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-5"":{""pref_family"":""IP6"",""localport"":""30439"",""logical_intf"":""default"",""local_intf_uid"":""0"",""stream"":""3""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-6"":{""pref_family"":""IP6"",""localport"":""30450"",""logical_intf"":""default"",""local_intf_uid"":""1"",""stream"":""2""},""sfd-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-7"":{""pref_family"":""IP6"",""localport"":""30451"",""logical_intf"":""default"",""local_intf_uid"":""1"",""stream"":""3""},""stream-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":{""media"":""0"",""sfd"":""0"",""rtp_sink"":""2"",""rtcp_sink"":""4294967295"",""rtcp_sibling"":""1"",""last_packet"":""1485882298"",""ps_flags"":""15794176"",""component"":""1"",""endpoint"":""[2607:fea8:a9df:fa04::90]:6390"",""advertised_endpoint"":""[2607:fea8:a9df:fa04::90]:6390"",""stats-packets"":""752"",""stats-bytes"":""129344"",""stats-errors"":""0"",""-crypto_suite"":""AES_CM_128_HMAC_SHA1_80"",""-master_key"":""ÞKm\u0005%\\ûIÉNëÌ\u0014¬Ýo\u0002ú\""\u0019CS\b\u0005/\bfãH"",""-master_salt"":""o\u0002ú\""\u0019CS\b\u0005/\bfãH"",""-unenc-srtp"":""0"",""-unenc-srtcp"":""0"",""-unauth-srtp"":""0"",""last_index"":""56060"",""ssrc"":""3221943417""},""stream-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":{""media"":""0"",""sfd"":""1"",""rtp_sink"":""4294967295"",""rtcp_sink"":""3"",""rtcp_sibling"":""4294967295"",""last_packet"":""1485882293"",""ps_flags"":""15859712"",""component"":""2"",""endpoint"":""[2607:fea8:a9df:fa04::90]:6391"",""advertised_endpoint"":""[2607:fea8:a9df:fa04::90]:6391"",""stats-packets"":""3"",""stats-bytes"":""360"",""stats-errors"":""0"",""-crypto_suite"":""AES_CM_128_HMAC_SHA1_80"",""-master_key"":""ÞKm\u0005%\\ûIÉNëÌ\u0014¬Ýo\u0002ú\""\u0019CS\b\u0005/\bfãH"",""-master_salt"":""o\u0002ú\""\u0019CS\b\u0005/\bfãH"",""-unenc-srtp"":""0"",""-unenc-srtcp"":""0"",""-unauth-srtp"":""0"",""last_index"":""4"",""ssrc"":""0""},""stream-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-2"":{""media"":""1"",""sfd"":""4"",""rtp_sink"":""0"",""rtcp_sink"":""4294967295"",""rtcp_sibling"":""3"",""last_packet"":""1485882298"",""ps_flags"":""15794176"",""component"":""1"",""endpoint"":""[2607:fea8:a9df:fa04::90]:26528"",""advertised_endpoint"":""[2607:fea8:a9df:fa04::90]:26528"",""stats-packets"":""753"",""stats-bytes"":""137046"",""stats-errors"":""0""},""stream-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-3"":{""media"":""1"",""sfd"":""5"",""rtp_sink"":""4294967295"",""rtcp_sink"":""1"",""rtcp_sibling"":""4294967295"",""last_packet"":""1485882298"",""ps_flags"":""15859713"",""component"":""2"",""endpoint"":""[2607:fea8:a9df:fa04::90]:26529"",""advertised_endpoint"":""[2607:fea8:a9df:fa04::90]:26529"",""stats-packets"":""4"",""stats-bytes"":""536"",""stats-errors"":""0""},""stream_sfds-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""0"",""2""],""stream_sfds-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""1"",""3""],""stream_sfds-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-2"":[""4"",""6""],""stream_sfds-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-3"":[""5"",""7""],""tag-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":{""created"":""1485882283"",""active"":""1"",""deleted"":""0"",""tag"":""ZDfbPmo5Dmkt29T""},""tag-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":{""created"":""1485882283"",""active"":""0"",""deleted"":""0"",""tag"":""h4BJDlBQ6ycEhWK""},""other_tags-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""1""],""medias-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""1""],""other_tags-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""0""],""medias-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""0""],""media-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":{""tag"":""1"",""index"":""1"",""type"":""audio"",""protocol"":""UDP/TLS/RTP/SAVP"",""desired_family"":""IP6"",""sdes_in_tag"":""1"",""sdes_out_tag"":""1"",""logical_intf"":""default"",""media_flags"":""2686988"",""sdes_in-crypto_suite"":""AES_CM_128_HMAC_SHA1_80"",""sdes_in-master_key"":""2KAxLBIURybEs6XAhAxSSSQ17Xs008"",""sdes_in-master_salt"":""hAxSSSQ17Xs008"",""sdes_in-unenc-srtp"":""0"",""sdes_in-unenc-srtcp"":""0"",""sdes_in-unauth-srtp"":""0"",""sdes_out-crypto_suite"":""AES_CM_128_HMAC_SHA1_80"",""sdes_out-master_key"":""ÞKm\u0005%\\ûIÉNëÌ\u0014¬Ýo\u0002ú\""\u0019CS\b\u0005/\bfãH"",""sdes_out-master_salt"":""o\u0002ú\""\u0019CS\b\u0005/\bfãH"",""sdes_out-unenc-srtp"":""0"",""sdes_out-unenc-srtcp"":""0"",""sdes_out-unauth-srtp"":""0""},""media-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":{""tag"":""0"",""index"":""1"",""type"":""audio"",""protocol"":""RTP/AVP"",""desired_family"":""IP6"",""sdes_in_tag"":""0"",""sdes_out_tag"":""0"",""logical_intf"":""default"",""media_flags"":""196620""},""streams-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""0"",""1""],""maps-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""0""],""payload_types-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""111/opus/48000/2"",""0/PCMU/8000/(null)"",""8/PCMA/8000/(null)""],""streams-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""2"",""3""],""maps-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""1""],""payload_types-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""111/opus/48000/2"",""0/PCMU/8000/(null)"",""8/PCMA/8000/(null)""],""map-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":{""wildcard"":""0"",""num_ports"":""2"",""intf_preferred_family"":""IP6"",""logical_intf"":""default"",""endpoint"":""[2607:fea8:a9df:fa04::90]:26528""},""map-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":{""wildcard"":""0"",""num_ports"":""2"",""intf_preferred_family"":""IP6"",""logical_intf"":""default"",""endpoint"":""[2607:fea8:a9df:fa04::90]:6390""},""map_sfds-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-0"":[""loc-0"",""0"",""1"",""loc-1"",""2"",""3""],""map_sfds-ZBKcDPm6v1Ti06HmONMdiYYYf9I9IO7KqGDw1VWfNXlHBPfjlm-1"":[""loc-0"",""4"",""5"",""loc-1"",""6"",""7""]}",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/pkuzak,7,https://github.com/sipwise/rtpengine/pull/316#issuecomment-276619535,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Ow, that's not nice to hear. Indeed we didn't test any encrypted stuff. Regular (not encrypted) calls should work fine. We also kind of thought encryption is not yet fully supported to work with Redis, e.g. because of issue #303 . Nonetheless, a fix we can think of is to store the binary data base64 encoded. Would this be O.K. for you?
It's not straightforward for us to construct a DTLS test case, do you maybe have a command line tool/scenario we can use for testing?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/316#issuecomment-276668852,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","DTLS is what's not supported, but SDES ought to work, and it looks like this is what this patch breaks.
Base64 for binary data should work, but I think there's a more fundamental issue here. As far as I know, JSON in general and JSON-Glib in particular expects all strings to be UTF8 encoded unicode strings, while none of rtpengine's internal strings are.
In practice, this probably isn't an issue for most(?) strings, but there's no inherent guarantee that none of the strings contain any special characters. If a string is guaranteed to be plain ASCII only, it can be left as it is, but everything else ought to be escaped or guarded in some way and treated as bare binary data. The safest option would be to treat all strings as binary data, which would be fairly easy to achieve using a handful of wrapper functions.
Base64 for strings that are mostly or almost always (but can't be guaranteed to be) plain ASCII is obviously not a good choice. Perhaps using URI encoding or something similar would work better. My preference would be to use a single encoding mechanism for all strings and not get into trying to distinguish between what could and couldn't contain special characters.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,9,https://github.com/sipwise/rtpengine/pull/316#issuecomment-276670057,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Oh, and for testing you can use the included (but poorly documented) simulator-ng.pl script. A sample command line from the repo's main directory is
perl -Iperl tests/simulator-ng.pl --local-ip=192.168.... --local-ipv6=2607:...  --num-calls=20 --runtime=60 --keep-going

There's a bunch of other options (in particular --destination might be of interest) listed in the head of the script file. Then while it's running, kill the daemon and restart it.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,10,https://github.com/sipwise/rtpengine/pull/316#issuecomment-276942471,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Hi Richard,
thanks for the perl test line, that'll make things much easier for us. So I'll take also care about the UTF-8 stuff (along with my colleague Pawel).
Cheers
Frédéric",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,11,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278581489,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Hi Richard,
I can see that i.e. the master key is generated with 30 bytes. With 'redis-multikey', you write only the first 16 to redis. I don't understand this. Could you please shorty explain. Thanks.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,12,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278659800,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","The master key is 16 bytes and the master salt is 14 bytes. Makes 30 bytes together. In some cases (e.g. SDES SDP) they're communicated as a single 30 bytes long string.
There are some additional issues here, including a memory leak AFAICT. The URI encoding as it is now doesn't work fully correctly as it doesn't handle null bytes. I'm working on a comprehensive fix. Stay tuned.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,13,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278695467,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",Thanks Richard. So I will wait for you fix if I understood you correctly.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,14,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278760560,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",Check out the last commit in branch https://github.com/sipwise/rtpengine/tree/1and1-redis-onekey-concept-master,True,{'THUMBS_UP': ['https://github.com/inf265']}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,15,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278760621,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",f77726c,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,16,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278762691,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",Ha great I thought before to make to make the de/en-code functions myself but I discarded. I will have a detailed look t'morrow thx a lot. And a nice evening.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/rfuchs,17,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278945808,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.","Well, that wasn't entirely by choice, but rather because there doesn't seem to be an existing library function that does the job 😛
What I haven't tried is whether the Redis subscription still works. I haven't changed much, only made the pattern matching more precise, so it should be OK.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/pkuzak,18,https://github.com/sipwise/rtpengine/pull/316#issuecomment-278947002,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",I've tested the subscription/notification stuff and I can confirm that it is working (using f77726c).,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,316,2017-01-09T13:40:20Z,2017-02-13T15:35:20Z,2017-02-14T10:12:53Z,MERGED,True,1383,119,20,https://github.com/pkuzak,Implements redis onekey concept,13,[],https://github.com/sipwise/rtpengine/pull/316,https://github.com/inf265,19,https://github.com/sipwise/rtpengine/pull/316#issuecomment-279649583,"The redis onekey concepts is introduced to reduce traffic to redis
and redis notification traffic.
It modifies the current structure for one call in redis, which are
multiple keys with pre- and postfixes and the callid in between to
one key with the structure ""json-"". The value is a json
formatted string with the previous multi-key identifiers in it.",Thanks Richard.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,317,2017-01-19T13:00:18Z,2017-01-19T14:48:21Z,2017-01-19T14:48:21Z,MERGED,True,1,1,1,https://github.com/khorsmann,Update rtpengine.init,1,[],https://github.com/sipwise/rtpengine/pull/317,https://github.com/khorsmann,1,https://github.com/sipwise/rtpengine/pull/317,There is no INPUT_prefilter table on CentOS 6 systems.  So put it on INPUT should be good enough.,There is no INPUT_prefilter table on CentOS 6 systems.  So put it on INPUT should be good enough.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,323,2017-02-23T06:45:17Z,2017-03-06T17:06:00Z,2017-03-07T10:40:58Z,MERGED,True,68,980,7,https://github.com/inf265,Redis onekey concept improvements,8,[],https://github.com/sipwise/rtpengine/pull/323,https://github.com/inf265,1,https://github.com/sipwise/rtpengine/pull/323,"This pull request:

removes the multikey storing of data in the redis db
removes the artifact of the redisReply used before when restoring a call (restore and notification)

Calls are now stored in redis under the key  without prefix.","This pull request:

removes the multikey storing of data in the redis db
removes the artifact of the redisReply used before when restoring a call (restore and notification)

Calls are now stored in redis under the key  without prefix.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,323,2017-02-23T06:45:17Z,2017-03-06T17:06:00Z,2017-03-07T10:40:58Z,MERGED,True,68,980,7,https://github.com/inf265,Redis onekey concept improvements,8,[],https://github.com/sipwise/rtpengine/pull/323,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/323#issuecomment-284462430,"This pull request:

removes the multikey storing of data in the redis db
removes the artifact of the redisReply used before when restoring a call (restore and notification)

Calls are now stored in redis under the key  without prefix.",Thanks guys. See master for slightly updated version.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,328,2017-03-01T05:38:45Z,2017-03-02T14:14:49Z,2017-03-02T14:14:49Z,MERGED,True,11,0,1,https://github.com/aalba6675,"base64: flush base64 decoding, and skip base64 padding in crypto line",2,[],https://github.com/sipwise/rtpengine/pull/328,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/328,"Tweak base64:

in case key length + salt length is not a multiple of 3, e.g., AES-192, AES-256
skip base64 padding (""=="" or ""="")","Tweak base64:

in case key length + salt length is not a multiple of 3, e.g., AES-192, AES-256
skip base64 padding (""=="" or ""="")",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,328,2017-03-01T05:38:45Z,2017-03-02T14:14:49Z,2017-03-02T14:14:49Z,MERGED,True,11,0,1,https://github.com/aalba6675,"base64: flush base64 decoding, and skip base64 padding in crypto line",2,[],https://github.com/sipwise/rtpengine/pull/328,https://github.com/aalba6675,2,https://github.com/sipwise/rtpengine/pull/328#issuecomment-283471617,"Tweak base64:

in case key length + salt length is not a multiple of 3, e.g., AES-192, AES-256
skip base64 padding (""=="" or ""="")","Good catch — I will fix this; most UAs send padding so I expect that they will handle padding on receive
From pjproject v2.6 pjsua
a=crypto:1 AES_CM_256_HMAC_SHA1_80 inline:c2fQwFT9GEtwYlyUA9q4dRW/nAu7q0lSqh4sqzfjiezQQA9DtVmR4d+iJvVWYQ==
From FreeSWITCH 1.6.15
a=crypto:1 AES_CM_256_HMAC_SHA1_80 inline:NazjxRMjncLYVcuMYzIK80qsiDFswLT70gDEYn1qW+QtqETm67c07hXD72WI1O==
so it may not be necessary to change the encoding?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,328,2017-03-01T05:38:45Z,2017-03-02T14:14:49Z,2017-03-02T14:14:49Z,MERGED,True,11,0,1,https://github.com/aalba6675,"base64: flush base64 decoding, and skip base64 padding in crypto line",2,[],https://github.com/sipwise/rtpengine/pull/328,https://github.com/aalba6675,3,https://github.com/sipwise/rtpengine/pull/328#issuecomment-283477384,"Tweak base64:

in case key length + salt length is not a multiple of 3, e.g., AES-192, AES-256
skip base64 padding (""=="" or ""="")",Fixed commit per @rfuchs comment. Did not touch encoding part.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,328,2017-03-01T05:38:45Z,2017-03-02T14:14:49Z,2017-03-02T14:14:49Z,MERGED,True,11,0,1,https://github.com/aalba6675,"base64: flush base64 decoding, and skip base64 padding in crypto line",2,[],https://github.com/sipwise/rtpengine/pull/328,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/328#issuecomment-283663545,"Tweak base64:

in case key length + salt length is not a multiple of 3, e.g., AES-192, AES-256
skip base64 padding (""=="" or ""="")","Hm you may be right. I misread the RFC. Referring to RFC 4568 section 6.1 https://tools.ietf.org/html/rfc4568#section-6.1 it states:
When base64 decoding the key and
salt, padding characters (i.e., one or two ""="" at the end of the
base64-encoded data) are discarded
This talks about decoding, not encoding as I originally thought. Also the attribute grammar from section 9.2 includes = as a valid base64 character, so I think leaving the padding in place is the correct thing to do.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/332,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/332#issuecomment-287545067,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Nice, thank you. Couple of comments (of course 😄)
I would prefer to use separate function pointers for the different key lengths instead of using the same one and doing a case distinction based on key length. Something like changing aes_cm_session_key_init to aes_cm_session_key_init(struct crypto_context *c, EVP_CIPHER *ecb_cipher) and then have something like
static int aes_cm_session_key_init_128(struct crypto_context *c) {
  return aes_cm_session_key_init(c, EVP_aes_128_ecb())
}

and so on, and use these in crypto_suite definitions. Does that make sense? A similar approach should be possible with aes_ctr_128_no_ctx. Another solution could be to include the EVP_CIPHER * pointer in the crypto_suite definitions directly.
Does the aes_ctr_128() function also need to be adapted?
As for kernel support, it can either follow the same mantra and extend re_ciphers to include separate entries for different key lengths (rename REC_AES_CM to REC_AES_CM_128 and add REC_AES_CM_192 etc) and have separate encoding functions, or extend struct rtpengine_srtp to include the key length. I haven't checked what would make more sense. If there's no case distinction necessary, then extending the struct with the key length should be sufficient.
I can make these changes if you'd prefer.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/aalba6675,3,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288296250,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Refactor:

Add explicit aes_cm_session_key_init_NNN functions
Rename aes_ctr_128() to aes_ctr(), aes_ctr_128_no_ctx to aes_ctr_no_ctx()
aes_ctr (was aes_ctr_128) seems to be ok (i.e., key length unaware), as it just uses the passed-in cipher context
crypto_gen_session_key() is in the public interface: I did not change that, and am extracting key length to pass to prf_n(). Any qualms about this one?
I'll next look at the kernel interfaces...",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/aalba6675,4,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288390598,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Initial kernel support:

Pass master key len and session key len to kernel structures; let crypto_cipher_setkey() handle AES-128, AES-192, AES-256 key lengths",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288414727,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Hi, I've made some additional changes to this, see code in branch https://github.com/sipwise/rtpengine/tree/rfuchs/aes
I don't have a test case for AES-192/256, so if possible, please confirm that this is still working correctly, thanks.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/aalba6675,6,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288463310,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","I couldn't reach the branch https://github.com/sipwise/rtpengine/tree/rfuchs/aes
Am getting 404 errors",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288472921,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Durr, it was deleted by our gerrit by accident. It's there now.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/aalba6675,8,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288479665,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Sure — let me test this; meanwhile, I have pushed a commit that fixes a stupid indexing error in DBG: 21->31",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,332,2017-03-18T07:12:41Z,2017-03-24T15:53:37Z,2017-03-25T01:51:59Z,MERGED,True,563,48,9,https://github.com/aalba6675,"Initial support for AES-192, AES-256 in userspace",9,[],https://github.com/sipwise/rtpengine/pull/332,https://github.com/aalba6675,9,https://github.com/sipwise/rtpengine/pull/332#issuecomment-288998620,"This is an initial attempt at AES-192 AES-256 support for comments. It works in userspace / SDES only.
Remaining issues:

no DTLS (the equivalent DTLS suites seem to have died in IETF drafts)
kernel support; will need to pass key length some how to kernel interface; open to suggestions here","Added AES static test vectors from libsrtp in tests/.  libsrtp does not contain AES-192 or AES-256 (SRTCP) test vectors so I have added them here too.
HOWTO:

build daemon/
cd tests/
make -f Makefile.aes
./t_crypt

Expected behaviour
$ ./t_crypt
SRTP AES-CM-128 RTP encrypt: PASS
SRTP AES-CM-128 RTP decrypt: PASS
...
extra AES-CM-256 RTP encrypt: PASS
extra AES-CM-256 RTP decrypt: PASS",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,333,2017-03-19T14:51:37Z,2017-03-19T21:18:02Z,2017-03-20T00:25:48Z,MERGED,True,1,1,1,https://github.com/xiaosuo,STUN: The most significant 2 bits is 0xc0 in hex,1,[],https://github.com/sipwise/rtpengine/pull/333,https://github.com/xiaosuo,1,https://github.com/sipwise/rtpengine/pull/333,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,334,2017-03-21T06:02:47Z,2017-03-21T13:58:13Z,2017-04-27T15:52:57Z,CLOSED,False,558,441,8,https://github.com/inf265,Seperate statistics and cdr,2,[],https://github.com/sipwise/rtpengine/pull/334,https://github.com/inf265,1,https://github.com/sipwise/rtpengine/pull/334,"Just a code move from some functions where running code, statistics and cdr were mixed up.","Just a code move from some functions where running code, statistics and cdr were mixed up.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/335,Resolving technical debt introduced in #316 (root_reader being part of call object).,Resolving technical debt introduced in #316 (root_reader being part of call object).,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/335#issuecomment-288068261,Resolving technical debt introduced in #316 (root_reader being part of call object).,This seems to include the commits from #334 as well. Do you want to close the other pull request?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/inf265,3,https://github.com/sipwise/rtpengine/pull/335#issuecomment-288086031,Resolving technical debt introduced in #316 (root_reader being part of call object).,Yes but anyway I don't have the permission I guess ?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/inf265,4,https://github.com/sipwise/rtpengine/pull/335#issuecomment-288086366,Resolving technical debt introduced in #316 (root_reader being part of call object).,Ahh I found,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/inf265,5,https://github.com/sipwise/rtpengine/pull/335#issuecomment-288186469,Resolving technical debt introduced in #316 (root_reader being part of call object).,Yes but to be honest I do not very like the parameter handover deep down to every function but I think it's better than before. We'll see if there's a more better way in the future.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/335#issuecomment-288190422,Resolving technical debt introduced in #316 (root_reader being part of call object).,"Yes I agree, that's why I thought using a global TLS variable would avoid the extra parameter everywhere. At global level, you would declare static __thread JsonReader *root_reader, then set this variable at the beginning of the restore process and clear it at the end. Because it's TLS, it's safe to use in all participating functions.
Another option would be to use a helper struct that contains the call struct pointer and the JsonReader pointer and pass that struct to every function instead of the call pointer. You'd just replace struct call *c with struct foobar_helper *x everywhere and use x->c instead of c to access the call.
Either way, it's up to you. Just some ideas. I'm OK with merging it as it is.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,335,2017-03-21T11:54:30Z,2017-03-24T14:05:52Z,2017-03-27T09:56:26Z,CLOSED,False,3,0,2,https://github.com/pkuzak,Remove jsonreader from call,7,[],https://github.com/sipwise/rtpengine/pull/335,https://github.com/inf265,7,https://github.com/sipwise/rtpengine/pull/335#issuecomment-288317625,Resolving technical debt introduced in #316 (root_reader being part of call object).,Ok if it's ok we leave it as it is. And thanks for explaining the other options.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,337,2017-03-25T02:04:09Z,2017-03-27T14:17:10Z,2017-03-27T14:17:10Z,MERGED,True,6,0,1,https://github.com/aalba6675,Document RFC 3711 errata id 3712 that SRTCP_R_LENGTH == 6 is canonical,1,[],https://github.com/sipwise/rtpengine/pull/337,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/337,"Add RFC 3711 errata comment, and libsrtp issue, that the libsrtp behaviour is canonical.","Add RFC 3711 errata comment, and libsrtp issue, that the libsrtp behaviour is canonical.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,346,2017-04-05T13:14:59Z,2017-04-05T14:24:23Z,2017-04-27T15:52:27Z,MERGED,True,2,1,1,https://github.com/claudiupb,make cli_incoming accept multiple connections,1,[],https://github.com/sipwise/rtpengine/pull/346,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/346,"fixes #280
The original problem in this issue is generated because multiple incoming connections on the listening socket can generate a single epoll event. Since the events have EPOLLET flag this means that if only one connection is treated (as with the code before) the other ones will never be processed, because no other event will be generated for them. If this happens some incoming connections will never be treated and the client will never get a response (this is why the rtpengine-ctl client never prints and remains hanged).
Modifications to the cli_incoming function will allow to treat all connections, since now accept is called until it returns EAGAIN || EWOULDBLOCK.","fixes #280
The original problem in this issue is generated because multiple incoming connections on the listening socket can generate a single epoll event. Since the events have EPOLLET flag this means that if only one connection is treated (as with the code before) the other ones will never be processed, because no other event will be generated for them. If this happens some incoming connections will never be treated and the client will never get a response (this is why the rtpengine-ctl client never prints and remains hanged).
Modifications to the cli_incoming function will allow to treat all connections, since now accept is called until it returns EAGAIN || EWOULDBLOCK.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,346,2017-04-05T13:14:59Z,2017-04-05T14:24:23Z,2017-04-27T15:52:27Z,MERGED,True,2,1,1,https://github.com/claudiupb,make cli_incoming accept multiple connections,1,[],https://github.com/sipwise/rtpengine/pull/346,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/346#issuecomment-291867759,"fixes #280
The original problem in this issue is generated because multiple incoming connections on the listening socket can generate a single epoll event. Since the events have EPOLLET flag this means that if only one connection is treated (as with the code before) the other ones will never be processed, because no other event will be generated for them. If this happens some incoming connections will never be treated and the client will never get a response (this is why the rtpengine-ctl client never prints and remains hanged).
Modifications to the cli_incoming function will allow to treat all connections, since now accept is called until it returns EAGAIN || EWOULDBLOCK.","Good catch, thanks. The log messages from line 843 should also be removed since this is now an expected condition.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,346,2017-04-05T13:14:59Z,2017-04-05T14:24:23Z,2017-04-27T15:52:27Z,MERGED,True,2,1,1,https://github.com/claudiupb,make cli_incoming accept multiple connections,1,[],https://github.com/sipwise/rtpengine/pull/346,https://github.com/claudiupb,3,https://github.com/sipwise/rtpengine/pull/346#issuecomment-291876902,"fixes #280
The original problem in this issue is generated because multiple incoming connections on the listening socket can generate a single epoll event. Since the events have EPOLLET flag this means that if only one connection is treated (as with the code before) the other ones will never be processed, because no other event will be generated for them. If this happens some incoming connections will never be treated and the client will never get a response (this is why the rtpengine-ctl client never prints and remains hanged).
Modifications to the cli_incoming function will allow to treat all connections, since now accept is called until it returns EAGAIN || EWOULDBLOCK.","Yes, I removed the message.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,348,2017-04-07T01:51:55Z,2017-04-07T12:18:10Z,2017-04-10T09:24:27Z,MERGED,True,12,0,1,https://github.com/aalba6675,Interop: document libsrtp AES-256 SRTCP bug,1,[],https://github.com/sipwise/rtpengine/pull/348,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/348,"Document a mild interop issue due to a bug that is in libsrtp+OpenSSL SRTCP AES-256 CM that exists in all libsrtp versions in the wild. This bug is to be fixed in libsrtp 1.6 and 2.1. Versions of libsrtp compiled without OpenSSL support are unaffected.
This interop issue is mild and only affects SRTCP AES-256. Both SRTP and SRTCP AES-128 are unaffected.
E.g., encountered with rtpengine<-->FreeSWITCH 1.6.15 as conference bridge with AES-256 CM.
cisco/libsrtp#264","Document a mild interop issue due to a bug that is in libsrtp+OpenSSL SRTCP AES-256 CM that exists in all libsrtp versions in the wild. This bug is to be fixed in libsrtp 1.6 and 2.1. Versions of libsrtp compiled without OpenSSL support are unaffected.
This interop issue is mild and only affects SRTCP AES-256. Both SRTP and SRTCP AES-128 are unaffected.
E.g., encountered with rtpengine<-->FreeSWITCH 1.6.15 as conference bridge with AES-256 CM.
cisco/libsrtp#264",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,353,2017-04-24T12:46:15Z,2017-04-27T15:50:08Z,2017-04-27T15:51:58Z,CLOSED,False,38,42,2,https://github.com/pkuzak,More control over iptables,1,[],https://github.com/sipwise/rtpengine/pull/353,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/353,Relates to #205.,Relates to #205.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,353,2017-04-24T12:46:15Z,2017-04-27T15:50:08Z,2017-04-27T15:51:58Z,CLOSED,False,38,42,2,https://github.com/pkuzak,More control over iptables,1,[],https://github.com/sipwise/rtpengine/pull/353,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/353#issuecomment-296674491,Relates to #205.,"Hm, I'm not sure about this one. It seems to lose the meaning of the CREATE_IPTABLES_CHAIN switch. Some people might be using that option. Can you elaborate on your rationale behind this change?
Also, this looks like a good opportunity to get rid of all the old references to mediaproxy.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,353,2017-04-24T12:46:15Z,2017-04-27T15:50:08Z,2017-04-27T15:51:58Z,CLOSED,False,38,42,2,https://github.com/pkuzak,More control over iptables,1,[],https://github.com/sipwise/rtpengine/pull/353,https://github.com/pkuzak,3,https://github.com/sipwise/rtpengine/pull/353#issuecomment-296686811,Relates to #205.,"Sure. this change was motivated by our operational/administration team (as was #205, but #205 didn't solve all their requirements). They are managing all iptables rules separately. Also, they take care of loading and unloading Kernel modules. So they asked me whether I can extend the init script accordingly. That's why I came up with this pull request.
I renamed (or deleted) the old CREATE_IPTABLES_CHAIN switch because that one only controlled the creation of iptables rules. The deletion was always done. I thought the name MANAGE_IPTABLES is more suitable.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,353,2017-04-24T12:46:15Z,2017-04-27T15:50:08Z,2017-04-27T15:51:58Z,CLOSED,False,38,42,2,https://github.com/pkuzak,More control over iptables,1,[],https://github.com/sipwise/rtpengine/pull/353,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/353#issuecomment-297743543,Relates to #205.,One problem that I can see is that the rmmod must come after the del $TABLE. I'll fix it up and commit it.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,353,2017-04-24T12:46:15Z,2017-04-27T15:50:08Z,2017-04-27T15:51:58Z,CLOSED,False,38,42,2,https://github.com/pkuzak,More control over iptables,1,[],https://github.com/sipwise/rtpengine/pull/353,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/353#issuecomment-297745859,Relates to #205.,Although it seems that you've moved the rmmod above the del $TABLE intentionally. Any particular reason for that?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,353,2017-04-24T12:46:15Z,2017-04-27T15:50:08Z,2017-04-27T15:51:58Z,CLOSED,False,38,42,2,https://github.com/pkuzak,More control over iptables,1,[],https://github.com/sipwise/rtpengine/pull/353,https://github.com/pkuzak,6,https://github.com/sipwise/rtpengine/pull/353#issuecomment-297747439,Relates to #205.,"Oh...O.K.. Honestly, looking at the code I don't know why I moved this part down in the code. Thank you for taking care of this.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,357,2017-04-27T08:52:26Z,2017-04-27T13:31:56Z,2017-04-27T13:31:56Z,MERGED,True,4,4,3,https://github.com/tiglat,Issue354: Fix for rtpengint to ngcp-rtpengine renaming issues,1,[],https://github.com/sipwise/rtpengine/pull/357,https://github.com/tiglat,1,https://github.com/sipwise/rtpengine/pull/357,"Some time ago rtpengine service was renamed to ngcp-rtpengine during rpm package installation. However some names were not renamed and were forgotten. That lead to installation issues and prevent from successfull packages install and running. This fix also includes fix of issue 356.
Note also that from my point of view it would be better to update dkms.conf file in the target rpmbuild/BUILDROOT directory instead doing that inside source rpmbuild/BUILD directory. Sometimes rpm packages are built from sources taken from some repository but not from tar file in rpmbuild/SOURCES dir. So keeping source file untouched is useful. That is why I propose to execute sed on file in the buildroot dir.","Some time ago rtpengine service was renamed to ngcp-rtpengine during rpm package installation. However some names were not renamed and were forgotten. That lead to installation issues and prevent from successfull packages install and running. This fix also includes fix of issue 356.
Note also that from my point of view it would be better to update dkms.conf file in the target rpmbuild/BUILDROOT directory instead doing that inside source rpmbuild/BUILD directory. Sometimes rpm packages are built from sources taken from some repository but not from tar file in rpmbuild/SOURCES dir. So keeping source file untouched is useful. That is why I propose to execute sed on file in the buildroot dir.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,369,2017-06-12T14:05:36Z,2017-06-12T14:10:14Z,2017-06-12T14:42:34Z,MERGED,True,7,5,1,https://github.com/xiaosuo,DTLS: Fix potential double BIO_free,1,[],https://github.com/sipwise/rtpengine/pull/369,https://github.com/xiaosuo,1,https://github.com/sipwise/rtpengine/pull/369,"We should set init to 1 after calling SSL_set_bio(), otherwise if
we fail to call EC_KEY_new_by_curve_name(), we will free r_bio and
w_bio twice: one with BIO_free(), and the other with SSL_free().","We should set init to 1 after calling SSL_set_bio(), otherwise if
we fail to call EC_KEY_new_by_curve_name(), we will free r_bio and
w_bio twice: one with BIO_free(), and the other with SSL_free().",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,375,2017-07-11T14:19:52Z,2017-07-11T14:27:22Z,2017-08-29T09:19:26Z,MERGED,True,8,10,1,https://github.com/claudiupb,fix bug that makes rtpengine crash when graphite server is down,1,[],https://github.com/sipwise/rtpengine/pull/375,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/375,"replaced select with poll because when a large number of file
descriptors are open segfaults might happen
If case a large number of calls are made, and graphite server is down,  graphite_sock.fd can become greater than FD_SETSIZE. In this case the select will fail, and FD_SET can sometimes cause a segmentation fault.","replaced select with poll because when a large number of file
descriptors are open segfaults might happen
If case a large number of calls are made, and graphite server is down,  graphite_sock.fd can become greater than FD_SETSIZE. In this case the select will fail, and FD_SET can sometimes cause a segmentation fault.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,377,2017-07-21T15:09:29Z,2017-07-31T13:18:12Z,2017-08-29T09:19:11Z,MERGED,True,83,14,3,https://github.com/lbalaceanu,"on startup, also accept hostname:port params for endpoints",1,[],https://github.com/sipwise/rtpengine/pull/377,https://github.com/lbalaceanu,1,https://github.com/sipwise/rtpengine/pull/377,"Hi,
In order to also accept hostname:port besides IP46:port for startup options specifying an endpoint, I added 2 new functions: endpoint_parse_any_getaddrinfo_full, endpoint_parse_any_getaddrinfo.
Thank you","Hi,
In order to also accept hostname:port besides IP46:port for startup options specifying an endpoint, I added 2 new functions: endpoint_parse_any_getaddrinfo_full, endpoint_parse_any_getaddrinfo.
Thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,377,2017-07-21T15:09:29Z,2017-07-31T13:18:12Z,2017-08-29T09:19:11Z,MERGED,True,83,14,3,https://github.com/lbalaceanu,"on startup, also accept hostname:port params for endpoints",1,[],https://github.com/sipwise/rtpengine/pull/377,https://github.com/lbalaceanu,2,https://github.com/sipwise/rtpengine/pull/377#issuecomment-318337263,"Hi,
In order to also accept hostname:port besides IP46:port for startup options specifying an endpoint, I added 2 new functions: endpoint_parse_any_getaddrinfo_full, endpoint_parse_any_getaddrinfo.
Thank you","Hi @rfuchs ,
Should I change something regarding this pull request?
Thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,388,2017-09-04T14:35:28Z,2017-09-05T14:01:33Z,2017-09-05T14:01:33Z,MERGED,True,27,4,1,https://github.com/claudiupb,check that redisContext is not NULL before using it,1,[],https://github.com/sipwise/rtpengine/pull/388,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/388,"If redis server is down, it can happen that the ctx member of the redis structure is NULL. I added checks before  before accessing members of the redisContext structure.","If redis server is down, it can happen that the ctx member of the redis structure is NULL. I added checks before  before accessing members of the redisContext structure.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,390,2017-09-07T13:42:42Z,2017-09-07T14:22:33Z,2017-09-07T14:22:34Z,MERGED,True,7,3,1,https://github.com/claudiupb,Count multipexed packets in statistics. Don't count errounously when …,1,[],https://github.com/sipwise/rtpengine/pull/390,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/390,"…no stream is found
fixes #387","…no stream is found
fixes #387",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,394,2017-09-14T07:34:45Z,2017-09-14T12:59:12Z,2017-09-14T15:55:49Z,MERGED,True,2,5,1,https://github.com/claudiupb,don't log corrupted cdr for foreign calls,1,[],https://github.com/sipwise/rtpengine/pull/394,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/394,"cdrbuffer is not initialized unless IS_OWN_CALL is true, so only log it in that case","cdrbuffer is not initialized unless IS_OWN_CALL is true, so only log it in that case",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,398,2017-09-26T10:44:49Z,2017-09-26T12:36:11Z,2017-10-06T09:20:04Z,MERGED,True,34,1,5,https://github.com/claudiupb,Stop recording,2,[],https://github.com/sipwise/rtpengine/pull/398,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/398,Add stop recording message to ng control interface. This can be sent to rtpengine to stop recording while call is ongoing.,Add stop recording message to ng control interface. This can be sent to rtpengine to stop recording while call is ongoing.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,400,2017-09-29T23:55:44Z,2017-10-02T14:30:16Z,2017-10-02T14:30:16Z,CLOSED,False,6,0,1,https://github.com/efiop,daemon: cli: set O_NONBLOCK for accepted fd,1,[],https://github.com/sipwise/rtpengine/pull/400,https://github.com/efiop,1,https://github.com/sipwise/rtpengine/pull/400,"Fixes #399
Signed-off-by: Ruslan Kuprieiev kupruser@gmail.com","Fixes #399
Signed-off-by: Ruslan Kuprieiev kupruser@gmail.com",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,402,2017-10-10T12:40:48Z,2017-10-10T13:09:28Z,2017-10-10T13:09:28Z,CLOSED,False,1,0,1,https://github.com/claudiupb,set TOS for redis streams,1,[],https://github.com/sipwise/rtpengine/pull/402,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/402,"In case kernel forwarding is disabled, TOS should be set for streams that are created from redis db.","In case kernel forwarding is disabled, TOS should be set for streams that are created from redis db.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,403,2017-10-10T13:12:04Z,2017-10-10T13:12:57Z,2017-10-10T13:12:57Z,MERGED,True,1,1,1,https://github.com/claudiupb,set TOS for redis streams,1,[],https://github.com/sipwise/rtpengine/pull/403,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/403,"In case kernel forwarding is disabled, TOS should be set for streams that are created from redis db.","In case kernel forwarding is disabled, TOS should be set for streams that are created from redis db.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,403,2017-10-10T13:12:04Z,2017-10-10T13:12:57Z,2017-10-10T13:12:57Z,MERGED,True,1,1,1,https://github.com/claudiupb,set TOS for redis streams,1,[],https://github.com/sipwise/rtpengine/pull/403,https://github.com/claudiupb,2,https://github.com/sipwise/rtpengine/pull/403#issuecomment-335467801,"In case kernel forwarding is disabled, TOS should be set for streams that are created from redis db.",I made a new Pull Request since a forced push was not visible in the old one.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,409,2017-10-19T11:00:38Z,2017-10-19T12:33:41Z,2017-10-19T12:33:41Z,MERGED,True,1,1,1,https://github.com/claudiupb,check call.recording structure before using it,1,[],https://github.com/sipwise/rtpengine/pull/409,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/409,"if call recording is not configured but the Redis db contains calls with recording flag, then call.recording can be NULL. This can happen if  two rtpengines are configured with redundancy using Redis, but only one has call recording configured.","if call recording is not configured but the Redis db contains calls with recording flag, then call.recording can be NULL. This can happen if  two rtpengines are configured with redundancy using Redis, but only one has call recording configured.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,411,2017-10-25T09:29:40Z,2017-11-02T14:56:25Z,2017-11-02T15:42:35Z,MERGED,True,185,51,12,https://github.com/claudiupb,Add recording forwarding,2,[],https://github.com/sipwise/rtpengine/pull/411,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/411,"These commits add the option for recording daemon to forward the captured traffic to a UNIX domain socket instead of encoding to wav/mp3 and saving an audio file.  We chose a UNIX domain socket because we can use the SOCK_SEQPACKET type which allows to make have a connection based communication, but uses datagrams instead of streams, so it will be easier to detect each individual RTP package.
This way for each call a new connection is made and a simple program that listens on than UNIX domain socket can process each RTP packet from each stream, as needed.
The first received message contains the metadata info in clear text format, so control information can easily be passed from rtpengine (or from kamailio by using start_recording() or rtpengine_manage()).","These commits add the option for recording daemon to forward the captured traffic to a UNIX domain socket instead of encoding to wav/mp3 and saving an audio file.  We chose a UNIX domain socket because we can use the SOCK_SEQPACKET type which allows to make have a connection based communication, but uses datagrams instead of streams, so it will be easier to detect each individual RTP package.
This way for each call a new connection is made and a simple program that listens on than UNIX domain socket can process each RTP packet from each stream, as needed.
The first received message contains the metadata info in clear text format, so control information can easily be passed from rtpengine (or from kamailio by using start_recording() or rtpengine_manage()).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,411,2017-10-25T09:29:40Z,2017-11-02T14:56:25Z,2017-11-02T15:42:35Z,MERGED,True,185,51,12,https://github.com/claudiupb,Add recording forwarding,2,[],https://github.com/sipwise/rtpengine/pull/411,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/411#issuecomment-339328041,"These commits add the option for recording daemon to forward the captured traffic to a UNIX domain socket instead of encoding to wav/mp3 and saving an audio file.  We chose a UNIX domain socket because we can use the SOCK_SEQPACKET type which allows to make have a connection based communication, but uses datagrams instead of streams, so it will be easier to detect each individual RTP package.
This way for each call a new connection is made and a simple program that listens on than UNIX domain socket can process each RTP packet from each stream, as needed.
The first received message contains the metadata info in clear text format, so control information can easily be passed from rtpengine (or from kamailio by using start_recording() or rtpengine_manage()).","May I ask about the motivation behind this feature? I'm wondering because the RTP packets are already available for reading locally through the /proc interface, so having the recording-daemon read them locally just to re-deliver them elsewhere locally seems like an unnecessary step.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,411,2017-10-25T09:29:40Z,2017-11-02T14:56:25Z,2017-11-02T15:42:35Z,MERGED,True,185,51,12,https://github.com/claudiupb,Add recording forwarding,2,[],https://github.com/sipwise/rtpengine/pull/411,https://github.com/claudiupb,3,https://github.com/sipwise/rtpengine/pull/411#issuecomment-339353426,"These commits add the option for recording daemon to forward the captured traffic to a UNIX domain socket instead of encoding to wav/mp3 and saving an audio file.  We chose a UNIX domain socket because we can use the SOCK_SEQPACKET type which allows to make have a connection based communication, but uses datagrams instead of streams, so it will be easier to detect each individual RTP package.
This way for each call a new connection is made and a simple program that listens on than UNIX domain socket can process each RTP packet from each stream, as needed.
The first received message contains the metadata info in clear text format, so control information can easily be passed from rtpengine (or from kamailio by using start_recording() or rtpengine_manage()).","The recording-daemon also parses the .meta files from the spool directory, and has the stream structures for each call in place. If another application will want tho read the /proc interface, it will also need to monitor the file-system to read and parse these files so it knows the number of streams for each call and where to read them. All this is already implemented in the recording daemon, so by using this feature any application that would simply want to read the RTP packets organized by calls will have a reduced complexity.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,412,2017-10-26T11:44:27Z,2017-10-26T19:01:00Z,2017-10-26T19:01:00Z,MERGED,True,0,1738,4,https://github.com/pkuzak,Deleted outdated graphics,1,[],https://github.com/sipwise/rtpengine/pull/412,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/412,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,416,2017-11-06T12:35:01Z,2017-11-06T14:20:27Z,2017-11-06T15:18:19Z,MERGED,True,22,5,2,https://github.com/claudiupb,don't use g_hash_table_foreach for call_timer_iterator,1,[],https://github.com/sipwise/rtpengine/pull/416,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/416,this keeps the callmaster->hashlock for a long time so copy the list of calls instead and update call refs,this keeps the callmaster->hashlock for a long time so copy the list of calls instead and update call refs,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,416,2017-11-06T12:35:01Z,2017-11-06T14:20:27Z,2017-11-06T15:18:19Z,MERGED,True,22,5,2,https://github.com/claudiupb,don't use g_hash_table_foreach for call_timer_iterator,1,[],https://github.com/sipwise/rtpengine/pull/416,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/416#issuecomment-342162100,this keeps the callmaster->hashlock for a long time so copy the list of calls instead and update call refs,"Nice catch, thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,418,2017-11-08T12:56:24Z,2017-12-12T12:02:12Z,2017-12-12T12:02:44Z,CLOSED,False,2,2,1,https://github.com/pkuzak,Fix control statistics headlines,1,[],https://github.com/sipwise/rtpengine/pull/418,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/418,StopRec was missing,StopRec was missing,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,418,2017-11-08T12:56:24Z,2017-12-12T12:02:12Z,2017-12-12T12:02:44Z,CLOSED,False,2,2,1,https://github.com/pkuzak,Fix control statistics headlines,1,[],https://github.com/sipwise/rtpengine/pull/418,https://github.com/pkuzak,2,https://github.com/sipwise/rtpengine/pull/418#issuecomment-351031917,StopRec was missing,Is part of #430,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/420,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/420#issuecomment-348295608,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Wow, this is a very large commit for what it's trying to achieve.
Only a small number of config parameters are currently mutable during runtime. Can you explain the reason for having this mechanism for parameters that cannot be changed?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/hdikme,3,https://github.com/sipwise/rtpengine/pull/420#issuecomment-348495425,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Hello Richard,
While coding the ""cli_incoming_params_diff"" function, i have also thought that there is a limited number of parameters that can be changed at the run time but then i also thought those parameters could be increased by the upstream in the course of the time. In order not to be affected by any future modifications, the function has been implemented this way. If you think there is gonna be no more addition in terms of the parameters that could be changed at the run time, then i will reorganize the  ""cli_incoming_params_diff"" function. Thanks for your time.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/420#issuecomment-348897616,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Fair enough. I have no problem with taking possible future expansions into account. However, the amount of code duplication between callmaster_config, callmaster_cfg_addition, and rtpengine_config_params, and related boilerplate code is far from ideal. A more unified and consolidated approach would be far better.
Why not combine everything into a single struct, and keep two global instances thereof (running config and startup config)? Then callmaster_config can be moved out of the callmaster struct, and the mc special handling can then be eliminated. (In fact, the entire callmaster struct should be thrown out the window and converted to global variables instead. But that's way beyond the scope of this change.)
All the strlen/strcpy stuff can be avoided by using g_strlcpy, or strdup (especially strdupfree from aux.h).
There's no reason the GOptionEntry list cannot reference struct members directly.
Is this something you'd be willing to work on? If not, I can do the preparation work and cleanup/removal of old code that serves no purpose myself, and then you can add your new functions on top of that.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/hdikme,5,https://github.com/sipwise/rtpengine/pull/420#issuecomment-349954625,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","As far as I understand, I will remove the callmaster_config struct from the callmaster struct and then add some variables (all additional variables from the callmaster_cfg_addition struct) into callmaster_config. Following that, I will create
2 instances of callmaster_config one for current the other for the initial config parameters. And that means “struct callmaster_config mc” at the beginning of function“static void create_everything(struct main_context *ctx)” will be moved outside the function and defined as a global struct. At this point I m wondering:
1)callmaster config contains fields like config_lock, *redis, *redis_write that are not populated at startup. What happens with such fields? Should these be defaulted to NULL in the initial config?
2)What do you mean exactly by saying “Then callmaster_config can be moved out of the callmaster struct, and the mc special handling can then be eliminated.“? Because I thought that I should define mc outside the function as a global struct and the rest would be left the same but the word “eliminating” has confused me a bit.
3)Any yes I’m willing to implement this my own but what do you mean by doing the preparation work (removal of old code)?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/420#issuecomment-349984232,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","config_lock is used to synchronize access to certain fields of the (running) config. If a startup-config is read-only, it does not need a config_lock.
*redis and *redis_write are more handles than config options. There's a few config options in there (endpoint, db) and those should go into a config struct and be populated accordingly, but the redis handles themselves should be kept separately.
The purpose of the 'callmaster_config mc' is/was to populate the config struct before the callmaster itself is created, and then copy the fields from there into the callmaster's config. If the config is moved out of the callmaster and made global, this extra step becomes redundant and the global config struct can be populated directly.
And what I meant is that I can do all of the changes I just described myself if you'd prefer. I would aim for a clean(er) config handling, which would lend itself to keeping track changes between a startup config and the runtime config. It's up to you.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/420#issuecomment-353375745,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","FYI, I've created an internal ticket to do the config cleanup I was talking about. Stay tuned.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/420#issuecomment-355106976,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Check out the code in https://github.com/sipwise/rtpengine/tree/rfuchs/config-rework
This gets rid of the callmaster struct, moves everything holding state information global, and moves all config options into a globally held rtpe_config struct.
Unparsed config options (such as the raw listen-... strings) are held only in local variables right now, but those could be moved into the global config struct as well if necessary.
The only ones left are the options from auxlib.c (such as the log-level) - I will gather them up and put them into the config struct as well.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/hdikme,9,https://github.com/sipwise/rtpengine/pull/420#issuecomment-356266210,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Thank you for the updating, i m already working on the code, fyi.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,420,2017-11-17T10:36:33Z,2018-02-01T14:57:54Z,2018-02-05T16:28:24Z,CLOSED,False,411,15,4,https://github.com/hdikme,"cli params command has beend created for initial, current parameters.",1,[],https://github.com/sipwise/rtpengine/pull/420,https://github.com/hdikme,10,https://github.com/sipwise/rtpengine/pull/420#issuecomment-363138234,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Hi richard,
I have created a new pull-request based-on the new structure.
#452",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,426,2017-12-03T17:17:45Z,2017-12-04T07:44:40Z,2017-12-04T07:44:40Z,MERGED,True,5,3,1,https://github.com/poroh,Crash stream_packet in case of out_srtp is NULL is fixed,1,[],https://github.com/sipwise/rtpengine/pull/426,https://github.com/poroh,1,https://github.com/sipwise/rtpengine/pull/426,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,426,2017-12-03T17:17:45Z,2017-12-04T07:44:40Z,2017-12-04T07:44:40Z,MERGED,True,5,3,1,https://github.com/poroh,Crash stream_packet in case of out_srtp is NULL is fixed,1,[],https://github.com/sipwise/rtpengine/pull/426,https://github.com/poroh,2,https://github.com/sipwise/rtpengine/pull/426#issuecomment-348798839,,"Backtrace of crash:
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ff734611234 in pthread_mutex_lock () from /lib/x86_64-linux-gnu/libpthread.so.0
[Current thread is 1 (Thread 0x7ff727fff700 (LWP 28450))]
(gdb) bt
#0  0x00007ff734611234 in pthread_mutex_lock () from /lib/x86_64-linux-gnu/libpthread.so.0
#1  0x000000000043124b in __stream_ssrc (in_srtp=<optimized out>, out_srtp=0x0, ssrc_bs=<optimized out>, ssrc_in_p=0x7ff727ffc250, ssrc_out_p=0x7ff727ffc258, ssrc_hash=0x7ff714a13300) at media_socket.c:1129
#2  0x0000000000433416 in stream_packet (tv=0x7ff727ffc270, fsin=0x7ff727ffc280, s=0x7ff727ffc260, sfd=<optimized out>) at media_socket.c:1279
#3  stream_fd_readable (fd=<optimized out>, p=<optimized out>, u=<optimized out>) at media_socket.c:1562
#4  0x000000000040a00e in poller_poll (p=p@entry=0x714db0, timeout=timeout@entry=100) at poller.c:350
#5  0x000000000040a3ad in poller_loop (d=0x714db0) at poller.c:505
#6  0x000000000040a420 in thread_detach_func (d=0x6f3e20) at aux.c:143
#7  0x00007ff73460f064 in start_thread () from /lib/x86_64-linux-gnu/libpthread.so.0
#8  0x00007ff73434462d in clone () from /lib/x86_64-linux-gnu/libc.so.6",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,430,2017-12-12T11:57:56Z,2017-12-12T14:20:19Z,2018-01-19T11:01:24Z,MERGED,True,31,12,9,https://github.com/claudiupb,Add to ToS to control ng & Fix control statistics headlines ,3,[],https://github.com/sipwise/rtpengine/pull/430,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/430,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/arkadiam,1,https://github.com/sipwise/rtpengine/pull/432,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393","Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/432#issuecomment-352515036,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393","Can you post a concrete example of a call going wrong? Debug log containing the SDP bodies would be great.
I don't believe this is a the correct patch to fix this. Rtpengine is supposed to remember the protocols used by clients that it talked to before, and is supposed to insert the correct transport protocol without being instructed to (or even when not instructed to do anything).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/arkadiam,3,https://github.com/sipwise/rtpengine/pull/432#issuecomment-352540809,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393","Thanks for looking at it.
Please find the logs of a test call attached.
It follows calls scenario I've originally described: Polycom phone places a call, call is answered, then Polycom phone puts call on Hold, then it Resumes the call.
The issue corresponds to the log line 53 where Rtpengine translates one of ""m=audio"" to RTP/AVP.
rtpengine-20171218.log.txt",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/432#issuecomment-353369494,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393","I believe the problem stems from the way Asterisk responds to the multi-stream SDP.
Polycom offers 4 media streams: audio SRTP, audio RTP, video SRTP, video RTP.
Asterisk then answers with only 2 media streams: audio RTP, video RTP (disabled)
My understanding of RFC 3264 (section 6) is that media descriptions in the SDP (m= lines) in the answer must match up with media descriptions given in the offer. So if the offer contains 4 media streams, the answer must also contain 4 media streams. Asterisk doesn't do this.
The result is that rtpengine matches up the first media stream from Polycom with the first media stream from Asterisk, thus it thinks that Polycom wants to speak SRTP there while Asterisk wants to speak RTP. It remembers this and in the subsequent re-offer substitutes the appropriate transport protocol.
A correct response from Asterisk (IMO and from my understanding of the RFC) would be to generate an SDP answer with 4 media streams, with the same types and protocols as the original offer, and all of them except the second one (audio RTP) disabled (zero port).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/arkadiam,5,https://github.com/sipwise/rtpengine/pull/432#issuecomment-353512246,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393","Asterisk version we have to work with, doesn't support SRTP. Unsupported media are being ignored without producing zero-port m-line records. I agree with your RFC3264 interpretation.
I can try to modify Asterisk code to return 4 media streams like:
m=audio 0 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
BUT I'm not sure if in this case the media path will be:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
I think it might be turned into:
Polycom -- RTP -- rtpengine -- RTP -- Asterisk.
which is not our intention. We would like to keep the first call leg secure.
I don't see how rtpengine_manage() can be called with any other flags to achieve SRTP-RTP conversion. Specifying transport protocol: ""RTP/AVP""  will turn initial  SDP into:
m=audio 2278 RTP/AVP
m=audio 2278 RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
which will be rejected by Asterisk due to duplicate values.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/432#issuecomment-353605348,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393","Ah no, actually you're right. It would be RTP both ways. I suppose in the offer, you have to specify RTP/AVP. (This sort of alternative protocol selection isn't supported by rtpengine. I'm not sure if there's an RFC for it, but I guess it could be implemented anyway.)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/432#issuecomment-353614685,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393",A possible workaround for the Asterisk side of this is to make rtpengine recognize this situation (m= lines missing) and attempt to match up the lines as Asterisk thinks they should match up (possibly by internally filling up the missing media streams with dummy entries). See __get_media and its invocation in monologue_offer_answer,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,432,2017-12-15T18:56:33Z,,2018-01-02T15:22:39Z,OPEN,False,8,6,1,https://github.com/arkadiam,Replace transport protocol only if protocol was specified in flags,1,[],https://github.com/sipwise/rtpengine/pull/432,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/432#issuecomment-354790031,"Setup: Polycom phone with SDES (optional) -- Kamailio + Rtpengine -- Asterisk PBX
On initial INVITE Polycom sends SDP with:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 2280 RTP/SAVP
m=video 2280 RTP/AVP
Kmailio calls rtpengine_manage() with flags:
""direction=pub direction=priv replace-origin replace-session-connection ICE=remove SDES-off""
INVITE passed to Asterisk with the same media options (different port numbers). Asterisk is configured only to accept audio RTP. Call is answered and media goes like:
Polycom -- SRTP -- rtpengine -- RTP -- Asterisk.
Now Polycom puts call on HOLD. That produce INVITE with SDP like:
m=audio 2278 RTP/SAVP
m=audio 2278 RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
At this point, by some reason, Rtpengine replaces transport protocol with RTP/AVP and Asterisk presented with such media options:
m=audio xxx RTP/AVP
m=audio xxx RTP/AVP
m=video 0 RTP/AVP
m=video 0 RTP/AVP
Multiple RTP/AVP for audio confuses the Asterisk and it rejects the INVITE with 488.
Patch in this pull request prevents protocol replacement if it wasn't set in ""flags"".
It allows RE-INVITE to pass and present Asterisk valid media options:
m=audio xxx RTP/SAVP
m=audio xxx RTP/AVP
m=video 0 RTP/SAVP
m=video 0 RTP/AVP
This may potentially fix issues #275 and #393",#435 is related,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,445,2018-01-18T08:42:56Z,2018-01-18T13:57:56Z,2018-01-19T11:01:36Z,MERGED,True,116,11,6,https://github.com/claudiupb,"Add timeouts to redis commands, and possiblity to temporarily disable redis",6,[],https://github.com/sipwise/rtpengine/pull/445,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/445,"When having issues with the redis server the offer/answer/delete times will be affected.
With the new parameters a user can configure a timeout for redis commands and connection, and also to temporarily disable redis communication after a number of consecutive errors","When having issues with the redis server the offer/answer/delete times will be affected.
With the new parameters a user can configure a timeout for redis commands and connection, and also to temporarily disable redis communication after a number of consecutive errors",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,445,2018-01-18T08:42:56Z,2018-01-18T13:57:56Z,2018-01-19T11:01:36Z,MERGED,True,116,11,6,https://github.com/claudiupb,"Add timeouts to redis commands, and possiblity to temporarily disable redis",6,[],https://github.com/sipwise/rtpengine/pull/445,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/445#issuecomment-358641755,"When having issues with the redis server the offer/answer/delete times will be affected.
With the new parameters a user can configure a timeout for redis commands and connection, and also to temporarily disable redis communication after a number of consecutive errors",Can you explain a bit about the symptoms you're seeing? Would it be beneficial to run the redis commands asynchronously in a separate thread?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,445,2018-01-18T08:42:56Z,2018-01-18T13:57:56Z,2018-01-19T11:01:36Z,MERGED,True,116,11,6,https://github.com/claudiupb,"Add timeouts to redis commands, and possiblity to temporarily disable redis",6,[],https://github.com/sipwise/rtpengine/pull/445,https://github.com/claudiupb,3,https://github.com/sipwise/rtpengine/pull/445#issuecomment-358647585,"When having issues with the redis server the offer/answer/delete times will be affected.
With the new parameters a user can configure a timeout for redis commands and connection, and also to temporarily disable redis communication after a number of consecutive errors","The problem can appear if there is a slow connection to redis, and is some situations the offer/answer/delete processing time become too big and kamailio will disable the rtpengine node since it will not respond in time. I think it will be beneficial to use a separate thread for redis commands, but using asynchronous commands will require a rewrite of the redis functions to use the hiredis asynchronous API.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,445,2018-01-18T08:42:56Z,2018-01-18T13:57:56Z,2018-01-19T11:01:36Z,MERGED,True,116,11,6,https://github.com/claudiupb,"Add timeouts to redis commands, and possiblity to temporarily disable redis",6,[],https://github.com/sipwise/rtpengine/pull/445,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/445#issuecomment-358652050,"When having issues with the redis server the offer/answer/delete times will be affected.
With the new parameters a user can configure a timeout for redis commands and connection, and also to temporarily disable redis communication after a number of consecutive errors","Use of the asynchronous API might not be strictly necessary. Simply appending the Redis commands to a queue and then having a dedicated thread read from the queue and issue to commands to Redis synchronously would probably also work. Not sure which would be more effort to implement. Either way, just an idea.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,446,2018-01-19T11:44:20Z,2018-01-30T10:51:44Z,2018-01-30T12:28:28Z,MERGED,True,111,6,6,https://github.com/claudiupb,Add statistics for requests per second,7,[],https://github.com/sipwise/rtpengine/pull/446,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/446,This commit adds statistics for the number of offer/answer/delete requests per second. For each second the number of requests is counted and then a min/max is kept and an average is computed. The statistics are also sent to the graphite server.,This commit adds statistics for the number of offer/answer/delete requests per second. For each second the number of requests is counted and then a min/max is kept and an average is computed. The statistics are also sent to the graphite server.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,446,2018-01-19T11:44:20Z,2018-01-30T10:51:44Z,2018-01-30T12:28:28Z,MERGED,True,111,6,6,https://github.com/claudiupb,Add statistics for requests per second,7,[],https://github.com/sipwise/rtpengine/pull/446,https://github.com/claudiupb,2,https://github.com/sipwise/rtpengine/pull/446#issuecomment-360445392,This commit adds statistics for the number of offer/answer/delete requests per second. For each second the number of requests is counted and then a min/max is kept and an average is computed. The statistics are also sent to the graphite server.,"Hello @rfuchs, sorry for the late reply I was in vacation until today. I saw your comments and I will make new commits to this branch to solve the existing issues.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,446,2018-01-19T11:44:20Z,2018-01-30T10:51:44Z,2018-01-30T12:28:28Z,MERGED,True,111,6,6,https://github.com/claudiupb,Add statistics for requests per second,7,[],https://github.com/sipwise/rtpengine/pull/446,https://github.com/claudiupb,3,https://github.com/sipwise/rtpengine/pull/446#issuecomment-360478739,This commit adds statistics for the number of offer/answer/delete requests per second. For each second the number of requests is counted and then a min/max is kept and an average is computed. The statistics are also sent to the graphite server.,"I have added 3 new commits to this branch
3850e99 addreses the get_set issue
74cecc0 fixes the lock usage for statistics.
As I explained in the #446 (comment), rtpe_totalstats_lastinterval is just a copy of rtpe_totalstats_interval, so the counters are not actually increased here. This is why rtpe_totalstats_lastinterval_lock is sufficient when working with data inside it. However I noticed that when the copy is made, another lock is used so I changed this. I also noticed that the mutexes for the request_time are never initialized but they are used, so this was also added.
0ffb9e6 fixes the display of average request time when issuing rtpengine-ctl list totals, since the average is divided twice by the count",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,452,2018-02-05T16:26:34Z,2018-02-09T15:36:30Z,2018-02-09T16:01:27Z,MERGED,True,285,21,4,https://github.com/hdikme,"cli params command has been created for initial, current parameters and their difference",1,[],https://github.com/sipwise/rtpengine/pull/452,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/452,"Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""","Using the below commands, it has been enabled to screen initial & present values of rtpengine.conf parameters. Additionally, it is possible to now check if any parameter has been modified.
""rtpengine-ctl params start""
""rtpengine-ctl params current""
""rtpengine-ctl params diff""",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/455,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.","This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/455#issuecomment-364468035,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.","Hi,
Just a quick question here, as I'm not sure whether you're aware that there's already a round-robin interface selection algorithm in place, and it looks like there's some duplicated logic here.
From your README:
For this option only the name of the interfaces must be given. They must correspond with the names defined
in the `--interface` option otherwise they will be ignored:

	interface = pub1/IPV4; pub1/IPV6; pub2/IPV4; pub2/IPV6; pub3/IPV4; pub3/IPV6;
	primary-interface-group = pub1; pub3

The interfaces from this group will be selected in round-robin fashion in according to the desired address
family for the call.

I think the same thing can be achieved by doing something like this:
	interface = pub:1/IPV4; pub:1/IPV6; pub2/IPV4; pub2/IPV6; pub:3/IPV4; pub:3/IPV6;
	primary-interface = pub

Note the additional colon in the interface name, i.e. pub:1 instead of pub1. This creates a logical round-robin interface named pub, which if selected using direction=pub would do a round-robin selection between pub:1 and pub:3. (Individual logical interfaces can still be selected with direction=pub:1 etc).
There's some more info about this in the current README. Would this be sufficient for your use case, or do you require the additional logic from this patch?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/pkuzak,3,https://github.com/sipwise/rtpengine/pull/455#issuecomment-364475048,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.","We weren't aware of the feature you've written. You mentioned a primary-interface configuration option? What exactly does this do?
In our use case the SIP Proxy does not need to have any knowledge about what logical interface names there are and which one to use depending on which media relay is going to be used. We currently have 10 media relays, each one having a different interface configuration (the order of interfaces is different). The logical naming of interfaces is important for our redundancy concept.
Also, changing logical interfaces names should be transparent to our SIP Proxies.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/455#issuecomment-364477052,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.","Sorry, I guess I need to clarify. The primary-interface option doesn't exist yet, but the round-robin selection algorithm does. From what I understand, doing the following should achieve the same as your patch would achieve:

Rename your logical interfaces to the name:suffix schema, at least those you wish to use as a default/primary interface group.
Implement a single primary-interface option, which takes the place of the direction= argument if no direction was specified.

Perhaps the primary-interface option can even be skipped or made optional by falling back to an interface called default (or something) if no direction is specified. If no default interface exists, then it falls back to the current behaviour (pick the first). Then your interfaces could simply be called default:1, default:2, etc and you would get your round-robin selection.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/pkuzak,5,https://github.com/sipwise/rtpengine/pull/455#issuecomment-364560209,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.","Thanks for your explanation. I think your proposal should also fit our needs. In our active-active redundancy setup each of or media relays has a differt default or primary interface logical name. The reason for this is how sessions get stored in Redis. The logical interface name is used to determine on which interface to restore (or create upon Redis notification) the session. So we kind of need a unique mapping between logical name to an IP on all media relays.
In order to get rid of the primary-interface option, would following be OK for you:
If no direction parameter is specified and the 1st configured logical interface name follows your proposal (name:id), rtpengine will round-robin using all interfaces with the same name.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/455#issuecomment-364562545,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.",Sounds like a plan 👍,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,455,2018-02-07T12:46:57Z,2018-02-12T14:41:12Z,2018-02-12T14:41:12Z,CLOSED,False,85,3,6,https://github.com/claudiupb,Add primary-interface-group parameter,1,[],https://github.com/sipwise/rtpengine/pull/455,https://github.com/claudiupb,7,https://github.com/sipwise/rtpengine/pull/455#issuecomment-364941933,"This commit adds a new parameter to the config --primary-interface-group. With this a user can define a group of interfaces that will be used for calls where no direction is given, instead of using just the first interface.
This is useful to extend the maximum number of calls (with no direction)  an rtpengine instance can handle since there will be more available ports.",I am closing this Pull Request and will open a new one with the proposed solution.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,456,2018-02-13T14:53:54Z,2018-02-13T18:17:22Z,2018-02-14T06:06:12Z,MERGED,True,325,71,9,https://github.com/claudiupb,Extend rtpengine ctl,6,[],https://github.com/sipwise/rtpengine/pull/456,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/456,"This branch adds the following to rtpengine-ctl:

add get command as alias for list, in order to be more intuitive since the parameters are changed with set command.
make sure that every parameter that can be set can also be get, so split the list timeout command
make control-tos, redis-allowed-errors, redis-disable-time, redis-cmd-timeout and redis-connect-timeout configurable via rtpengine-ctl","This branch adds the following to rtpengine-ctl:

add get command as alias for list, in order to be more intuitive since the parameters are changed with set command.
make sure that every parameter that can be set can also be get, so split the list timeout command
make control-tos, redis-allowed-errors, redis-disable-time, redis-cmd-timeout and redis-connect-timeout configurable via rtpengine-ctl",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,456,2018-02-13T14:53:54Z,2018-02-13T18:17:22Z,2018-02-14T06:06:12Z,MERGED,True,325,71,9,https://github.com/claudiupb,Extend rtpengine ctl,6,[],https://github.com/sipwise/rtpengine/pull/456,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/456#issuecomment-365356887,"This branch adds the following to rtpengine-ctl:

add get command as alias for list, in order to be more intuitive since the parameters are changed with set command.
make sure that every parameter that can be set can also be get, so split the list timeout command
make control-tos, redis-allowed-errors, redis-disable-time, redis-cmd-timeout and redis-connect-timeout configurable via rtpengine-ctl",Quick note for future reference: There's a str_to_i function that can be used in place of strtol etc on str objects.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,456,2018-02-13T14:53:54Z,2018-02-13T18:17:22Z,2018-02-14T06:06:12Z,MERGED,True,325,71,9,https://github.com/claudiupb,Extend rtpengine ctl,6,[],https://github.com/sipwise/rtpengine/pull/456,https://github.com/claudiupb,3,https://github.com/sipwise/rtpengine/pull/456#issuecomment-365505853,"This branch adds the following to rtpengine-ctl:

add get command as alias for list, in order to be more intuitive since the parameters are changed with set command.
make sure that every parameter that can be set can also be get, so split the list timeout command
make control-tos, redis-allowed-errors, redis-disable-time, redis-cmd-timeout and redis-connect-timeout configurable via rtpengine-ctl","Thank you, I didn't know this function exists. I will use it in the future.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,461,2018-02-15T09:50:44Z,2018-02-15T11:01:32Z,2018-02-15T11:01:32Z,MERGED,True,23,3,3,https://github.com/pkuzak,Enable round robin for default interface,1,[],https://github.com/sipwise/rtpengine/pull/461,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/461,Follow up to #455.,Follow up to #455.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,467,2018-02-17T00:03:45Z,2018-03-05T12:39:51Z,2018-03-05T12:39:51Z,CLOSED,False,24,16,6,https://github.com/jerzyptak,adding no-rtcp-filtering flag,2,[],https://github.com/sipwise/rtpengine/pull/467,https://github.com/jerzyptak,1,https://github.com/sipwise/rtpengine/pull/467,"Some SIP endpints rely on rtcp feedback messages despite usage of RTP/(S)AVP profile.
This change adds no-rtcp-filtering flag that disables rtcp feedback filtering on RTP/(S)AVP streams.","Some SIP endpints rely on rtcp feedback messages despite usage of RTP/(S)AVP profile.
This change adds no-rtcp-filtering flag that disables rtcp feedback filtering on RTP/(S)AVP streams.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,467,2018-02-17T00:03:45Z,2018-03-05T12:39:51Z,2018-03-05T12:39:51Z,CLOSED,False,24,16,6,https://github.com/jerzyptak,adding no-rtcp-filtering flag,2,[],https://github.com/sipwise/rtpengine/pull/467,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/467#issuecomment-368112083,"Some SIP endpints rely on rtcp feedback messages despite usage of RTP/(S)AVP profile.
This change adds no-rtcp-filtering flag that disables rtcp feedback filtering on RTP/(S)AVP streams.",See commit above (4991c3c) for a possible implementation of this.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,467,2018-02-17T00:03:45Z,2018-03-05T12:39:51Z,2018-03-05T12:39:51Z,CLOSED,False,24,16,6,https://github.com/jerzyptak,adding no-rtcp-filtering flag,2,[],https://github.com/sipwise/rtpengine/pull/467,https://github.com/jerzyptak,3,https://github.com/sipwise/rtpengine/pull/467#issuecomment-368161484,"Some SIP endpints rely on rtcp feedback messages despite usage of RTP/(S)AVP profile.
This change adds no-rtcp-filtering flag that disables rtcp feedback filtering on RTP/(S)AVP streams.",Great I will try it out as soon as I can.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,472,2018-02-23T22:08:58Z,2018-02-27T13:00:50Z,2018-02-27T13:00:50Z,CLOSED,False,14,1,1,https://github.com/jerzyptak,Sdp parsing fix for fmtp attribute,3,[],https://github.com/sipwise/rtpengine/pull/472,https://github.com/jerzyptak,1,https://github.com/sipwise/rtpengine/pull/472,"I have noticed that parsing of parameters in fmtp lines was incorrectly handling spaces, it would stop processing them at the first space. This does not look like a valid behaviour as fmtp formatting is dependent on the codec. For example this H.263 fmtp parameters set is valid
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640 YMAX=480 MPI=2;MaxBR=7680
but rtpengine will copy it as:
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640
I have implemented fix for this issue.","I have noticed that parsing of parameters in fmtp lines was incorrectly handling spaces, it would stop processing them at the first space. This does not look like a valid behaviour as fmtp formatting is dependent on the codec. For example this H.263 fmtp parameters set is valid
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640 YMAX=480 MPI=2;MaxBR=7680
but rtpengine will copy it as:
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640
I have implemented fix for this issue.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,472,2018-02-23T22:08:58Z,2018-02-27T13:00:50Z,2018-02-27T13:00:50Z,CLOSED,False,14,1,1,https://github.com/jerzyptak,Sdp parsing fix for fmtp attribute,3,[],https://github.com/sipwise/rtpengine/pull/472,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/472#issuecomment-368156960,"I have noticed that parsing of parameters in fmtp lines was incorrectly handling spaces, it would stop processing them at the first space. This does not look like a valid behaviour as fmtp formatting is dependent on the codec. For example this H.263 fmtp parameters set is valid
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640 YMAX=480 MPI=2;MaxBR=7680
but rtpengine will copy it as:
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640
I have implemented fix for this issue.","Ya, good catch. The whole token extraction thing should actually be done with str_token() and str_token_sep(), eliminating the extract_token() function altogether. I'll fix it.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,472,2018-02-23T22:08:58Z,2018-02-27T13:00:50Z,2018-02-27T13:00:50Z,CLOSED,False,14,1,1,https://github.com/jerzyptak,Sdp parsing fix for fmtp attribute,3,[],https://github.com/sipwise/rtpengine/pull/472,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/472#issuecomment-368564530,"I have noticed that parsing of parameters in fmtp lines was incorrectly handling spaces, it would stop processing them at the first space. This does not look like a valid behaviour as fmtp formatting is dependent on the codec. For example this H.263 fmtp parameters set is valid
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640 YMAX=480 MPI=2;MaxBR=7680
but rtpengine will copy it as:
a=fmtp:34 VGA=2;CIF=1;QVGA=1;QCIF=1;XMAX=640
I have implemented fix for this issue.",19345d9 should be a clean fix for this,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,490,2018-03-13T00:18:23Z,2018-03-13T14:17:30Z,2018-03-13T22:54:25Z,MERGED,True,3,0,1,https://github.com/aalba6675,recording.c: save the label in pcap metadata file,1,[],https://github.com/sipwise/rtpengine/pull/490,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/490,"label in ng-protocol can be used by SIP proxy to send additional metadata. It is useful to persist this data for CDR, audit etc.
I have a customer use case where it is useful to explicitly save the callid, from URI, to URI. For example: at proxy side
# kamailio
rtpengine_manage(""label=$ci,$fu,$tu"")

Although the callid is implicit in the metadata filename, this example is more explicit. The customer wishes to store metadata and pcap files to separate audit storage and would like to be able to correlate with CDRs easily.","label in ng-protocol can be used by SIP proxy to send additional metadata. It is useful to persist this data for CDR, audit etc.
I have a customer use case where it is useful to explicitly save the callid, from URI, to URI. For example: at proxy side
# kamailio
rtpengine_manage(""label=$ci,$fu,$tu"")

Although the callid is implicit in the metadata filename, this example is more explicit. The customer wishes to store metadata and pcap files to separate audit storage and would like to be able to correlate with CDRs easily.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,491,2018-03-13T15:00:15Z,2018-03-13T15:01:46Z,2018-03-13T15:01:46Z,MERGED,True,1,1,1,https://github.com/claudiupb,Fix uptime statistics,1,[],https://github.com/sipwise/rtpengine/pull/491,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/491,I used time() function since rtpe_now in not initialized at that point,I used time() function since rtpe_now in not initialized at that point,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,492,2018-03-13T22:36:05Z,2018-03-15T21:26:56Z,2018-03-15T21:26:56Z,MERGED,True,1,1,1,https://github.com/que273,Fix AMR-WB codec initialisation,1,[],https://github.com/sipwise/rtpengine/pull/492,https://github.com/que273,1,https://github.com/sipwise/rtpengine/pull/492,"I was getting these errors when transcoding PCMA <=> AMR-WB:
Mar 13 15:33:34 EU1C11TESTSIPRTP03 rtpengine[4389]: ERR: [abc123@10.1.1.1 port 30190]: av_log: Only 8000Hz sample rate supported
Mar 13 15:33:34 EU1C11TESTSIPRTP03 rtpengine[4389]: ERR: [abc123@10.1.1.1 port 30190]: Error configuring media output for codec AMR-WB: failed to open output
and found a typo in the AMR-WB initialisation.
My session is now established, but I get other decoder errors and mangled audio. Separate investigation needed there.","I was getting these errors when transcoding PCMA <=> AMR-WB:
Mar 13 15:33:34 EU1C11TESTSIPRTP03 rtpengine[4389]: ERR: [abc123@10.1.1.1 port 30190]: av_log: Only 8000Hz sample rate supported
Mar 13 15:33:34 EU1C11TESTSIPRTP03 rtpengine[4389]: ERR: [abc123@10.1.1.1 port 30190]: Error configuring media output for codec AMR-WB: failed to open output
and found a typo in the AMR-WB initialisation.
My session is now established, but I get other decoder errors and mangled audio. Separate investigation needed there.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,492,2018-03-13T22:36:05Z,2018-03-15T21:26:56Z,2018-03-15T21:26:56Z,MERGED,True,1,1,1,https://github.com/que273,Fix AMR-WB codec initialisation,1,[],https://github.com/sipwise/rtpengine/pull/492,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/492#issuecomment-373528204,"I was getting these errors when transcoding PCMA <=> AMR-WB:
Mar 13 15:33:34 EU1C11TESTSIPRTP03 rtpengine[4389]: ERR: [abc123@10.1.1.1 port 30190]: av_log: Only 8000Hz sample rate supported
Mar 13 15:33:34 EU1C11TESTSIPRTP03 rtpengine[4389]: ERR: [abc123@10.1.1.1 port 30190]: Error configuring media output for codec AMR-WB: failed to open output
and found a typo in the AMR-WB initialisation.
My session is now established, but I get other decoder errors and mangled audio. Separate investigation needed there.",Derp. Thanks.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,506,2018-03-29T12:49:25Z,2018-03-29T13:19:16Z,2018-04-03T08:12:48Z,MERGED,True,5,6,1,https://github.com/claudiupb,Fix race condition where redis context is used outside mutex protection,1,[],https://github.com/sipwise/rtpengine/pull/506,https://github.com/claudiupb,1,https://github.com/sipwise/rtpengine/pull/506,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,508,2018-04-04T07:10:51Z,2018-04-04T12:38:34Z,2018-04-04T12:38:34Z,MERGED,True,2,2,1,https://github.com/juha-h,added note to README.md about recording-daemon,1,[],https://github.com/sipwise/rtpengine/pull/508,https://github.com/juha-h,1,https://github.com/sipwise/rtpengine/pull/508,"It took me a while before I noticed that an example of ""a dedicated 3rd party component"" is included in the repository.","It took me a while before I noticed that an example of ""a dedicated 3rd party component"" is included in the repository.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,512,2018-04-05T09:06:43Z,2018-04-05T15:17:58Z,2018-04-05T15:17:58Z,MERGED,True,16,2,3,https://github.com/jerzyptak,fixing memory leaks,1,[],https://github.com/sipwise/rtpengine/pull/512,https://github.com/jerzyptak,1,https://github.com/sipwise/rtpengine/pull/512,Fixes for memory leaks reported in issue #511.,Fixes for memory leaks reported in issue #511.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,514,2018-04-05T17:26:22Z,2018-04-05T17:29:21Z,2018-04-05T17:29:21Z,MERGED,True,3,1,1,https://github.com/juha-h,improved description of metadata key value,2,[],https://github.com/sipwise/rtpengine/pull/514,https://github.com/juha-h,1,https://github.com/sipwise/rtpengine/pull/514,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,517,2018-04-07T06:26:31Z,2018-04-09T14:33:38Z,2018-04-09T14:45:06Z,MERGED,True,57,3,3,https://github.com/juha-h, recording-daemon: added possibility to store audio streams to database,1,[],https://github.com/sipwise/rtpengine/pull/517,https://github.com/juha-h,1,https://github.com/sipwise/rtpengine/pull/517,"added new column 'stream mediumblob' to 'recording_streams' table for audio streams
added new option 'output-storage' with values 'file' (= default), 'db' or 'both'","added new column 'stream mediumblob' to 'recording_streams' table for audio streams
added new option 'output-storage' with values 'file' (= default), 'db' or 'both'",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,517,2018-04-07T06:26:31Z,2018-04-09T14:33:38Z,2018-04-09T14:45:06Z,MERGED,True,57,3,3,https://github.com/juha-h, recording-daemon: added possibility to store audio streams to database,1,[],https://github.com/sipwise/rtpengine/pull/517,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/517#issuecomment-379773492,"added new column 'stream mediumblob' to 'recording_streams' table for audio streams
added new option 'output-storage' with values 'file' (= default), 'db' or 'both'",I've amended it slightly so that people who are already using the existing DB schema don't have to update it if they're not using the db output option. See commit af963a2,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,517,2018-04-07T06:26:31Z,2018-04-09T14:33:38Z,2018-04-09T14:45:06Z,MERGED,True,57,3,3,https://github.com/juha-h, recording-daemon: added possibility to store audio streams to database,1,[],https://github.com/sipwise/rtpengine/pull/517,https://github.com/juha-h,3,https://github.com/sipwise/rtpengine/pull/517#issuecomment-379777294,"added new column 'stream mediumblob' to 'recording_streams' table for audio streams
added new option 'output-storage' with values 'file' (= default), 'db' or 'both'","Richard Fuchs writes:
 I've amended it slightly so that people who are already using the
 existing DB schema don't have to update it if they're not using the
 `db` output option. See commit af963a2

I too had that in mind, i.e., use stream field only if storage mode is
'db' or 'both'.
…
-- Juha",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,519,2018-04-09T13:06:49Z,2018-04-09T14:40:46Z,2018-04-10T00:02:06Z,MERGED,True,5,0,1,https://github.com/aalba6675,recording.c: add a few ms timestamps to pcap metadata,1,[],https://github.com/sipwise/rtpengine/pull/519,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/519,"For pcap recording, store a few timestamps in milliseconds in metadata
created timestamp for each monologue
terminated timestamp for first monologue in the linked list;
also ""call end time"" metadata includes the delete delay, so the
monologue terminated timestamp gives better information for
CDR purposes","For pcap recording, store a few timestamps in milliseconds in metadata
created timestamp for each monologue
terminated timestamp for first monologue in the linked list;
also ""call end time"" metadata includes the delete delay, so the
monologue terminated timestamp gives better information for
CDR purposes",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,521,2018-04-10T05:57:54Z,2018-04-16T14:53:31Z,2018-04-16T14:53:31Z,MERGED,True,44,0,2,https://github.com/juha-h,introduced rtpengine-recording.sample.conf,2,[],https://github.com/sipwise/rtpengine/pull/521,https://github.com/juha-h,1,https://github.com/sipwise/rtpengine/pull/521,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,529,2018-04-17T13:48:44Z,2018-04-17T14:27:29Z,2018-04-17T14:27:29Z,MERGED,True,19,0,2,https://github.com/netaskd,add homer options to el configuration,1,[],https://github.com/sipwise/rtpengine/pull/529,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/529,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,530,2018-04-17T16:21:11Z,2018-04-17T16:36:47Z,2018-04-17T16:36:47Z,MERGED,True,6,2,1,https://github.com/netaskd,add possibility to use different kernel version,1,[],https://github.com/sipwise/rtpengine/pull/530,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/530,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,534,2018-04-25T08:07:12Z,2018-04-26T12:50:59Z,2018-04-26T12:51:27Z,CLOSED,False,6,0,2,https://github.com/aalba6675,ffmpeg: handle some API changes for release/4.0 master,1,[],https://github.com/sipwise/rtpengine/pull/534,https://github.com/aalba6675,1,https://github.com/sipwise/rtpengine/pull/534,"Handle some API changes for newer versions of ffmpeg.
Encountered with Fedora 28 + latest ffmpeg","Handle some API changes for newer versions of ffmpeg.
Encountered with Fedora 28 + latest ffmpeg",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,534,2018-04-25T08:07:12Z,2018-04-26T12:50:59Z,2018-04-26T12:51:27Z,CLOSED,False,6,0,2,https://github.com/aalba6675,ffmpeg: handle some API changes for release/4.0 master,1,[],https://github.com/sipwise/rtpengine/pull/534,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/534#issuecomment-384283229,"Handle some API changes for newer versions of ffmpeg.
Encountered with Fedora 28 + latest ffmpeg","See ae3dae7 for an alternative, hopefully handling all cases. Let me know how that works for you.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,534,2018-04-25T08:07:12Z,2018-04-26T12:50:59Z,2018-04-26T12:51:27Z,CLOSED,False,6,0,2,https://github.com/aalba6675,ffmpeg: handle some API changes for release/4.0 master,1,[],https://github.com/sipwise/rtpengine/pull/534,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/534#issuecomment-384629736,"Handle some API changes for newer versions of ffmpeg.
Encountered with Fedora 28 + latest ffmpeg",Let's see how long it takes before somebody complains that this broke something :),True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,545,2018-05-08T09:04:25Z,2018-05-08T13:01:10Z,2018-05-08T13:11:59Z,MERGED,True,3,0,1,https://github.com/lbalaceanu,Fix for recovering from losing synchronous redis context while the as…,1,[],https://github.com/sipwise/rtpengine/pull/545,https://github.com/lbalaceanu,1,https://github.com/sipwise/rtpengine/pull/545,"…ync one is up
Force re-checking of the synchronous redis context state in case of processing
a redis notification. It is possible that redis async context is up while the
blocking one is down.","…ync one is up
Force re-checking of the synchronous redis context state in case of processing
a redis notification. It is possible that redis async context is up while the
blocking one is down.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,547,2018-05-09T10:02:30Z,2018-05-11T11:10:15Z,2018-05-11T11:10:34Z,CLOSED,False,1,1,1,https://github.com/pkuzak,Do not start service with -E (logging to stderr),1,[],https://github.com/sipwise/rtpengine/pull/547,https://github.com/pkuzak,1,https://github.com/sipwise/rtpengine/pull/547,Relates to #546,Relates to #546,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,548,2018-05-10T03:20:51Z,2018-05-11T03:21:45Z,2018-05-11T03:21:45Z,CLOSED,False,51,6,4,None,allow empty local address in interface config if advertised address is specified,1,[],https://github.com/sipwise/rtpengine/pull/548,None,1,https://github.com/sipwise/rtpengine/pull/548,"In our case, we want to receive rtp packets from all interfaces which all local interfaces have the same advertised address. Instead of listing all interfaces in config, an implicit 'all local addresses' way is preferred.
The real receiving interface is learned from the first received packet to make kernel forwarding works properly.
allowed format:
interface = !192.168.1.1","In our case, we want to receive rtp packets from all interfaces which all local interfaces have the same advertised address. Instead of listing all interfaces in config, an implicit 'all local addresses' way is preferred.
The real receiving interface is learned from the first received packet to make kernel forwarding works properly.
allowed format:
interface = !192.168.1.1",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,552,2018-05-15T08:58:54Z,2018-05-15T12:35:48Z,2018-05-15T12:35:48Z,MERGED,True,36,99,3,https://github.com/hdikme,rtpengine-ctl params updates and additions,1,[],https://github.com/sipwise/rtpengine/pull/552,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/552,"-cli params diff command has been updated to serve only for the possible modifiable configuration file parameters (max_sessions, timeout, silent_timeout, final_timeout, log_level, redis_allowed_errors, redis_disable_time, redis_connect_timeout, control_tos).
-Additionally, cli params revert command has been implemented.","-cli params diff command has been updated to serve only for the possible modifiable configuration file parameters (max_sessions, timeout, silent_timeout, final_timeout, log_level, redis_allowed_errors, redis_disable_time, redis_connect_timeout, control_tos).
-Additionally, cli params revert command has been implemented.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,554,2018-05-16T15:04:38Z,2018-05-16T19:07:23Z,2018-05-16T19:07:23Z,MERGED,True,2,2,1,https://github.com/etamme,do not require epel-release in spec file,1,[],https://github.com/sipwise/rtpengine/pull/554,https://github.com/etamme,1,https://github.com/sipwise/rtpengine/pull/554,Update the spec file so that it does not pull in epel-release.  This allows those who maintain their own repositories to keep things untainted.,Update the spec file so that it does not pull in epel-release.  This allows those who maintain their own repositories to keep things untainted.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,557,2018-05-23T13:20:08Z,2018-05-28T12:21:25Z,2018-05-28T12:21:25Z,MERGED,True,18,41,1,https://github.com/hdikme,control command logs have been updated,1,[],https://github.com/sipwise/rtpengine/pull/557,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/557,The logs have been a bit changed and the log lines reduces through the merging of some logs.,The logs have been a bit changed and the log lines reduces through the merging of some logs.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,574,2018-07-11T10:19:00Z,2018-07-11T13:18:11Z,2018-07-11T13:18:11Z,MERGED,True,258,202,5,https://github.com/netaskd,added package recording; updated ngcp-rtpengine version to 6.4.0.0,2,[],https://github.com/sipwise/rtpengine/pull/574,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/574,"add package recording
update ngcp-rtpengine version to 6.4.0.0","add package recording
update ngcp-rtpengine version to 6.4.0.0",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,575,2018-07-12T12:13:24Z,2018-07-12T13:36:58Z,2018-07-12T13:36:58Z,MERGED,True,37,16,2,https://github.com/netaskd,refactoring,2,[],https://github.com/sipwise/rtpengine/pull/575,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/575,"refactoring handling kernel table for config and sysconfig
commented out all pre-start arguments","refactoring handling kernel table for config and sysconfig
commented out all pre-start arguments",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,578,2018-07-17T11:07:13Z,2019-01-05T13:42:34Z,2019-01-05T13:42:34Z,CLOSED,False,2,1,1,https://github.com/kosza,Update README.md,1,[],https://github.com/sipwise/rtpengine/pull/578,https://github.com/kosza,1,https://github.com/sipwise/rtpengine/pull/578,"In Ubuntu Bionic the xtables are moved to different path.
The new kernel modul available after system reboot.","In Ubuntu Bionic the xtables are moved to different path.
The new kernel modul available after system reboot.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,578,2018-07-17T11:07:13Z,2019-01-05T13:42:34Z,2019-01-05T13:42:34Z,CLOSED,False,2,1,1,https://github.com/kosza,Update README.md,1,[],https://github.com/sipwise/rtpengine/pull/578,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/578#issuecomment-405554817,"In Ubuntu Bionic the xtables are moved to different path.
The new kernel modul available after system reboot.","The changed path actually applies to newer Debian releases as well, and I assume also some other distros.
I'm not sure about that reboot statement. Why would a reboot be needed?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,578,2018-07-17T11:07:13Z,2019-01-05T13:42:34Z,2019-01-05T13:42:34Z,CLOSED,False,2,1,1,https://github.com/kosza,Update README.md,1,[],https://github.com/sipwise/rtpengine/pull/578,https://github.com/kosza,3,https://github.com/sipwise/rtpengine/pull/578#issuecomment-405576581,"In Ubuntu Bionic the xtables are moved to different path.
The new kernel modul available after system reboot.","It is a good question. Honestly I don't know.
modprobe didn't see xt_RTPENGINE.ko. For test we rebooted the system and voila.
It seems that the Bionic needs reboot. Later we will do a clear install and we can test it again.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,586,2018-08-02T17:19:34Z,2018-08-07T13:56:21Z,2018-08-07T13:56:21Z,MERGED,True,18,14,3,https://github.com/egreenmachine,Make recording more accurately report source address,1,[],https://github.com/sipwise/rtpengine/pull/586,https://github.com/egreenmachine,1,https://github.com/sipwise/rtpengine/pull/586,"Just as a note. I have tested the pcap recording method, but not the proc recording method. I tried to make the commit as unintrusive as possible and I expect that proc recording works as it should.","Just as a note. I have tested the pcap recording method, but not the proc recording method. I tried to make the commit as unintrusive as possible and I expect that proc recording works as it should.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,586,2018-08-02T17:19:34Z,2018-08-07T13:56:21Z,2018-08-07T13:56:21Z,MERGED,True,18,14,3,https://github.com/egreenmachine,Make recording more accurately report source address,1,[],https://github.com/sipwise/rtpengine/pull/586,https://github.com/egreenmachine,2,https://github.com/sipwise/rtpengine/pull/586#issuecomment-410809302,"Just as a note. I have tested the pcap recording method, but not the proc recording method. I tried to make the commit as unintrusive as possible and I expect that proc recording works as it should.",Fixed,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,611,2018-09-03T14:40:58Z,2018-09-04T08:09:40Z,2018-09-04T08:09:40Z,MERGED,True,1,1,1,https://github.com/netaskd,update rtpengine-recording pid filename,1,[],https://github.com/sipwise/rtpengine/pull/611,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/611,"sysinit script is not expected to see /var/run/ngcp-rtpengine-recording-daemon.pid
PID file name renamed to rtpengine-recording.pid","sysinit script is not expected to see /var/run/ngcp-rtpengine-recording-daemon.pid
PID file name renamed to rtpengine-recording.pid",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,612,2018-09-04T08:03:46Z,2018-09-04T08:11:08Z,2018-09-04T08:45:08Z,MERGED,True,33,5,1,https://github.com/vasilevalex,Separate build for Centos with/without transcoding,1,[],https://github.com/sipwise/rtpengine/pull/612,https://github.com/vasilevalex,1,https://github.com/sipwise/rtpengine/pull/612,"If you don't need to use transcoding and recording, so you don't need
to install ffmpeg libraries. Just change with_transcoding to 0.
Also some changes according directory name inside tar.gz archive","If you don't need to use transcoding and recording, so you don't need
to install ffmpeg libraries. Just change with_transcoding to 0.
Also some changes according directory name inside tar.gz archive",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,619,2018-09-18T12:47:16Z,2018-09-18T14:32:36Z,2018-09-18T14:32:36Z,MERGED,True,5,2,1,https://github.com/oyvindkolbu,Fix homer and add Graphite to el sysconfig,2,[],https://github.com/sipwise/rtpengine/pull/619,https://github.com/oyvindkolbu,1,https://github.com/sipwise/rtpengine/pull/619,"The el init script and sysconfig is out of sync, so fix the sysconfig script to use the current variables.
While here add options for Graphite.","The el init script and sysconfig is out of sync, so fix the sysconfig script to use the current variables.
While here add options for Graphite.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,621,2018-09-23T08:37:40Z,2018-09-26T14:29:30Z,2018-09-26T14:29:31Z,MERGED,True,1,1,1,https://github.com/oyvindkolbu,Match default in daemon/main.c.,1,[],https://github.com/sipwise/rtpengine/pull/621,https://github.com/oyvindkolbu,1,https://github.com/sipwise/rtpengine/pull/621,Got surprised by defaults in code and config did not match.,Got surprised by defaults in code and config did not match.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,653,2018-11-07T10:53:37Z,2018-11-09T15:13:04Z,2018-11-09T15:13:05Z,MERGED,True,16,7,4,https://github.com/TorPetterson,Option to write SRTP keys to error log,5,[],https://github.com/sipwise/rtpengine/pull/653,https://github.com/TorPetterson,1,https://github.com/sipwise/rtpengine/pull/653,"We recently had a problem where some calls from users would have choppy sound some times.
To make sure the problem was not related to any systems on our end I had to listen to the audio as it was coming in. If I set the log level high enough to log the keys I loose most of the logs to throttling so it's very useful to log the keys to the error log","We recently had a problem where some calls from users would have choppy sound some times.
To make sure the problem was not related to any systems on our end I had to listen to the audio as it was coming in. If I set the log level high enough to log the keys I loose most of the logs to throttling so it's very useful to log the keys to the error log",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,653,2018-11-07T10:53:37Z,2018-11-09T15:13:04Z,2018-11-09T15:13:05Z,MERGED,True,16,7,4,https://github.com/TorPetterson,Option to write SRTP keys to error log,5,[],https://github.com/sipwise/rtpengine/pull/653,https://github.com/TorPetterson,2,https://github.com/sipwise/rtpengine/pull/653#issuecomment-437310011,"We recently had a problem where some calls from users would have choppy sound some times.
To make sure the problem was not related to any systems on our end I had to listen to the audio as it was coming in. If I set the log level high enough to log the keys I loose most of the logs to throttling so it's very useful to log the keys to the error log",I accepted you suggestions and expanded the documentation to make it more clear,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,1,https://github.com/sipwise/rtpengine/pull/658,crypto containing padding should be sent within sdp for pass through,crypto containing padding should be sent within sdp for pass through,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,2,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439361688,crypto containing padding should be sent within sdp for pass through,"Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding when using the base64 string you are using there is not padded; its length is not a multiple of 3. From RFC 4648:
Implementations MUST include appropriate pad characters at the end of encoded data unless the specification referring to this document explicitly states otherwise.
The call make from Bria soft phone fails with following bria error.
""SDES crypto key found in SDP, but is not of correct length after base 64 decode: 45, should be: 46""
AES_CM_256_HMAC_SHA1_80
Bria : inline:IPX7TGb7HLAYBGuuGdP//+VVSLFV4cz8WrkWVvbA39BJGHk580/UrV+ioCRFiA==
RTPEngine: inline:CYkq/gl8W1Bik8xvqlmJxnznqfDD5fGg13aLsjTOku/ILo8K3RgOQaxlq1KYFe
RTPEngine version: 6.5.2.0+0",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439503215,crypto containing padding should be sent within sdp for pass through,"Yes, and the document that does refer to RFC 4648 in this particular case is RFC 4568, which states in section 6.1:
When base64 decoding the key and
   salt, padding characters (i.e., one or two ""="" at the end of the
   base64-encoded data) are discarded (see [RFC3548] for details).

I'm afraid the Bria phone is to blame here.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,4,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439516243,crypto containing padding should be sent within sdp for pass through,"@rfuchs The modified code worked fine.
rtpengine sent reply that didn’t have the padding where Bria phone terminated the call. Please can you review the code and add to mr6.5 branch.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439536253,crypto containing padding should be sent within sdp for pass through,"No because while it might work for you, it might break things in other cases. My understanding of the RFC is that there should be no padding characters.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,6,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439548012,crypto containing padding should be sent within sdp for pass through,"@rfuchs parse_attribute_crypto function is handling the padding received by rtpengine which is ok. Since rfc4568 dealing with decoding.
The fix while inserting crypto it should not remove padding returned from function call g_base64_encode_close. This looks harmless as the receiver will remove the padding should disregard while decoding as does rtpengine.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439549245,crypto containing padding should be sent within sdp for pass through,"That's your assumption. It's just as well possible that a receiver will complain about extra padding characters being present when they shouldn't be, just as Bria complains about them not being present when it's expecting them to be there.
Unless you have any information to the contrary, I maintain that the RFC states that the padding characters should be discarded, and that Bria is wrong in rejecting the attribute.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,8,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439555176,crypto containing padding should be sent within sdp for pass through,"@rfuchs digging Rfc4648 states section 3.2 : -
`Implementations MUST include appropriate pad characters at the end of encoded data unless the specification referring to this document explicitly states otherwise.
The base64 and base32 alphabets use padding, as described below in sections 4 and 6, but the base16 alphabet does not need it; see section 8.`
Base64 section 4 relating with padding : -
`Padding at the end of the data is performed using the '=' character.  Since all base 64 input is an integral number of octets, only the following cases can arise:
(1) The final quantum of encoding input is an integral multiple of 24 bits; here, the final unit of encoded output will be an integral  multiple of 4 characters with no ""="" padding.
(2) The final quantum of encoding input is exactly 8 bits; here, the final unit of encoded output will be two characters followed by two ""="" padding characters.
(3) The final quantum of encoding input is exactly 16 bits; here, the final unit of encoded output will be three characters followed by one ""="" padding character.`",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/rfuchs,9,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439555610,crypto containing padding should be sent within sdp for pass through,"""unless the specification referring to this document explicitly states otherwise""
RFC 4568 does explicitly state otherwise.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/rfuchs,10,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439556590,crypto containing padding should be sent within sdp for pass through,"That being said, from looking at sample SDPs that can be found online, it seems that both variants (with and without padding) are commonly found. So I wouldn't mind having a compile-time option or something like that. But the default should be the behaviour as it is now.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,11,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439559165,crypto containing padding should be sent within sdp for pass through,"@rfuchs May be config option can be added to enable padding?
This padding removal is recent thing as it wasn’t there in version 6.3.2.0 since I didn’t had this issue.
On another subject is there config option to disable specific ciphers ?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/adil-mafzool,12,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439980717,crypto containing padding should be sent within sdp for pass through,@rfuchs can you review the new flag pad-crypto,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,658,2018-11-16T11:10:13Z,2018-11-19T18:40:19Z,2018-11-19T18:41:30Z,CLOSED,False,17,10,4,https://github.com/adil-mafzool,Bria softphone using SRTP call with AES_CM_256_HMAC_SHA1_80 requires padding to append,3,[],https://github.com/sipwise/rtpengine/pull/658,https://github.com/rfuchs,13,https://github.com/sipwise/rtpengine/pull/658#issuecomment-439998278,crypto containing padding should be sent within sdp for pass through,"Merged to mr6.5
Looks like Bria has the same problem with FreeSwitch: https://freeswitch.org/jira/si/jira.issueviews:issue-html/FS-10864/FS-10864.html",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,676,2018-12-15T14:56:55Z,2018-12-15T15:36:30Z,2018-12-15T15:36:30Z,MERGED,True,7,0,1,https://github.com/ycaner06,daemon makefile : added if statement for g729,1,[],https://github.com/sipwise/rtpengine/pull/676,https://github.com/ycaner06,1,https://github.com/sipwise/rtpengine/pull/676,"added if condition  for g729 codec .  After installation bcg729 library from git repo , it helps to find right path.","added if condition  for g729 codec .  After installation bcg729 library from git repo , it helps to find right path.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,677,2018-12-19T12:42:47Z,2018-12-19T14:16:38Z,2018-12-19T14:16:38Z,MERGED,True,69,29,2,https://github.com/ycaner06,rtpengine.service : systemd service file added,2,[],https://github.com/sipwise/rtpengine/pull/677,https://github.com/ycaner06,1,https://github.com/sipwise/rtpengine/pull/677,"-systemd service file added for Centos 7

changed comment way in sysconfig file for systemd . systemd cannot read variables when comment after variable setting.","-systemd service file added for Centos 7

changed comment way in sysconfig file for systemd . systemd cannot read variables when comment after variable setting.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,688,2019-01-23T18:15:51Z,2019-01-23T18:19:02Z,2019-01-23T18:19:02Z,MERGED,True,1,0,1,https://github.com/dragonfly-net,add BuildRequires: gperf in spec file,1,[],https://github.com/sipwise/rtpengine/pull/688,https://github.com/dragonfly-net,1,https://github.com/sipwise/rtpengine/pull/688,for #687,for #687,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,690,2019-01-25T15:38:55Z,2019-02-25T18:37:46Z,2019-02-25T18:37:46Z,CLOSED,False,152,90,7,https://github.com/adil-mafzool,Work around ssrc context for handling srtp replay protection for the transcoded srtp stream,2,[],https://github.com/sipwise/rtpengine/pull/690,https://github.com/adil-mafzool,1,https://github.com/sipwise/rtpengine/pull/690,Work around ssrc context for handling srtp replay protection for the transcoded srtp stream,Work around ssrc context for handling srtp replay protection for the transcoded srtp stream,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,690,2019-01-25T15:38:55Z,2019-02-25T18:37:46Z,2019-02-25T18:37:46Z,CLOSED,False,152,90,7,https://github.com/adil-mafzool,Work around ssrc context for handling srtp replay protection for the transcoded srtp stream,2,[],https://github.com/sipwise/rtpengine/pull/690,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/690#issuecomment-457663631,Work around ssrc context for handling srtp replay protection for the transcoded srtp stream,"I'm working on a similar fix, but more elaborate and extensive to provide consistent seq and TS output in all cases.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,698,2019-01-31T13:30:16Z,2019-01-31T14:30:33Z,2019-01-31T14:30:34Z,MERGED,True,11,8,2,https://github.com/mika,el init script improvements,2,[],https://github.com/sipwise/rtpengine/pull/698,https://github.com/mika,1,https://github.com/sipwise/rtpengine/pull/698,Fixing #696 and while at it taking care of stderr + exit code handling.,Fixing #696 and while at it taking care of stderr + exit code handling.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,704,2019-02-19T08:49:15Z,2019-02-19T14:52:17Z,2019-06-19T12:56:12Z,MERGED,True,10,10,3,https://github.com/vasilevalex,Rename crypto suits according to RFC6188,1,[],https://github.com/sipwise/rtpengine/pull/704,https://github.com/vasilevalex,1,https://github.com/sipwise/rtpengine/pull/704,"Fixes #703
Please review. I didn't change test suits.
And I'm not sure, if old names should be as alternative?","Fixes #703
Please review. I didn't change test suits.
And I'm not sure, if old names should be as alternative?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,704,2019-02-19T08:49:15Z,2019-02-19T14:52:17Z,2019-06-19T12:56:12Z,MERGED,True,10,10,3,https://github.com/vasilevalex,Rename crypto suits according to RFC6188,1,[],https://github.com/sipwise/rtpengine/pull/704,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/704#issuecomment-465150958,"Fixes #703
Please review. I didn't change test suits.
And I'm not sure, if old names should be as alternative?","Hm yes, this was changed in the draft very early on.
https://www.ietf.org/rfcdiff?url1=draft-ietf-avt-srtp-big-aes-00&url2=draft-ietf-avt-srtp-big-aes-01
I have no idea how widely used the old incorrect crypto suite names are. I'd say submit this now and then see who complains about it :)",True,{'THUMBS_UP': ['https://github.com/vasilevalex']}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,705,2019-02-20T18:00:34Z,2019-02-20T18:02:36Z,2019-02-20T18:02:36Z,MERGED,True,1,1,1,https://github.com/seanbright,README.md: Update main bcg279 link,1,[],https://github.com/sipwise/rtpengine/pull/705,https://github.com/seanbright,1,https://github.com/sipwise/rtpengine/pull/705,The current link 404s.,The current link 404s.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,726,2019-03-06T00:29:49Z,2019-03-06T00:31:50Z,2019-03-06T00:31:50Z,MERGED,True,0,3,1,https://github.com/bacek,Remove duplicated configuration parameter sample,1,[],https://github.com/sipwise/rtpengine/pull/726,https://github.com/bacek,1,https://github.com/sipwise/rtpengine/pull/726,Just remove duplicate,Just remove duplicate,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,731,2019-03-11T16:43:42Z,2019-03-14T16:19:12Z,2019-03-14T16:19:21Z,CLOSED,False,2,6,1,https://github.com/khorsmann,Fix lower or higher target CentOS Kernel Versions,1,[],https://github.com/sipwise/rtpengine/pull/731,https://github.com/khorsmann,1,https://github.com/sipwise/rtpengine/pull/731,"The changes in 62ec9cc breaks the installation of ngcp-rtpengine-dkms. It will not produce any kind of xt_RTPENGINE.* module if your kernel-version dont match with the build-host. Only chance is if you have the same kernel-version as the build-host.
More is less here. Remove this changes.","The changes in 62ec9cc breaks the installation of ngcp-rtpengine-dkms. It will not produce any kind of xt_RTPENGINE.* module if your kernel-version dont match with the build-host. Only chance is if you have the same kernel-version as the build-host.
More is less here. Remove this changes.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,731,2019-03-11T16:43:42Z,2019-03-14T16:19:12Z,2019-03-14T16:19:21Z,CLOSED,False,2,6,1,https://github.com/khorsmann,Fix lower or higher target CentOS Kernel Versions,1,[],https://github.com/sipwise/rtpengine/pull/731,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/731#issuecomment-471623450,"The changes in 62ec9cc breaks the installation of ngcp-rtpengine-dkms. It will not produce any kind of xt_RTPENGINE.* module if your kernel-version dont match with the build-host. Only chance is if you have the same kernel-version as the build-host.
More is less here. Remove this changes.","You'll have to discuss with @netaskd
Without any more details, I would strongly favour strict version-specific kernel module builds. Unless the RPM platform does something different here, the kernel itself makes zero guarantees about ABI compatibility even among patch releases.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,731,2019-03-11T16:43:42Z,2019-03-14T16:19:12Z,2019-03-14T16:19:21Z,CLOSED,False,2,6,1,https://github.com/khorsmann,Fix lower or higher target CentOS Kernel Versions,1,[],https://github.com/sipwise/rtpengine/pull/731,https://github.com/netaskd,3,https://github.com/sipwise/rtpengine/pull/731#issuecomment-472786945,"The changes in 62ec9cc breaks the installation of ngcp-rtpengine-dkms. It will not produce any kind of xt_RTPENGINE.* module if your kernel-version dont match with the build-host. Only chance is if you have the same kernel-version as the build-host.
More is less here. Remove this changes.",@khorsmann please test #734,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,731,2019-03-11T16:43:42Z,2019-03-14T16:19:12Z,2019-03-14T16:19:21Z,CLOSED,False,2,6,1,https://github.com/khorsmann,Fix lower or higher target CentOS Kernel Versions,1,[],https://github.com/sipwise/rtpengine/pull/731,https://github.com/khorsmann,4,https://github.com/sipwise/rtpengine/pull/731#issuecomment-472842037,"The changes in 62ec9cc breaks the installation of ngcp-rtpengine-dkms. It will not produce any kind of xt_RTPENGINE.* module if your kernel-version dont match with the build-host. Only chance is if you have the same kernel-version as the build-host.
More is less here. Remove this changes.","@netaskd
#734 didnt work.
Better we use %if 0%{?kversion:1} like @rfuchs described with Professor Google.
I tested %if 0%{?kversion:1} and omited the previous declaration %if statement. Then it works fine. with and without define.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,731,2019-03-11T16:43:42Z,2019-03-14T16:19:12Z,2019-03-14T16:19:21Z,CLOSED,False,2,6,1,https://github.com/khorsmann,Fix lower or higher target CentOS Kernel Versions,1,[],https://github.com/sipwise/rtpengine/pull/731,https://github.com/khorsmann,5,https://github.com/sipwise/rtpengine/pull/731#issuecomment-472944275,"The changes in 62ec9cc breaks the installation of ngcp-rtpengine-dkms. It will not produce any kind of xt_RTPENGINE.* module if your kernel-version dont match with the build-host. Only chance is if you have the same kernel-version as the build-host.
More is less here. Remove this changes.","@netaskd  last commit on #734 fix that 4cdf106.
Plus optional --define for (uname -r) on buildhost or (best kernelversion ever). I close my pull-request then.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,734,2019-03-14T10:02:12Z,2019-03-14T16:36:04Z,2019-05-14T01:38:57Z,MERGED,True,13,6,1,https://github.com/netaskd,rtpengine.spec: fix building dkms module on a different host kernel ver,1,[],https://github.com/sipwise/rtpengine/pull/734,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/734,"fixes commit 62ec9cc
In case when DKMS package built without defined kversion, it must build module for target host current kernel version.","fixes commit 62ec9cc
In case when DKMS package built without defined kversion, it must build module for target host current kernel version.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,734,2019-03-14T10:02:12Z,2019-03-14T16:36:04Z,2019-05-14T01:38:57Z,MERGED,True,13,6,1,https://github.com/netaskd,rtpengine.spec: fix building dkms module on a different host kernel ver,1,[],https://github.com/sipwise/rtpengine/pull/734,https://github.com/netaskd,2,https://github.com/sipwise/rtpengine/pull/734#issuecomment-472929311,"fixes commit 62ec9cc
In case when DKMS package built without defined kversion, it must build module for target host current kernel version.",@khorsmann please test the latest force push 4cdf106 It works perfect for the both cases.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,734,2019-03-14T10:02:12Z,2019-03-14T16:36:04Z,2019-05-14T01:38:57Z,MERGED,True,13,6,1,https://github.com/netaskd,rtpengine.spec: fix building dkms module on a different host kernel ver,1,[],https://github.com/sipwise/rtpengine/pull/734,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/734#issuecomment-472952093,"fixes commit 62ec9cc
In case when DKMS package built without defined kversion, it must build module for target host current kernel version.",Thanks for taking care of this @netaskd,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,734,2019-03-14T10:02:12Z,2019-03-14T16:36:04Z,2019-05-14T01:38:57Z,MERGED,True,13,6,1,https://github.com/netaskd,rtpengine.spec: fix building dkms module on a different host kernel ver,1,[],https://github.com/sipwise/rtpengine/pull/734,https://github.com/kdoren,4,https://github.com/sipwise/rtpengine/pull/734#issuecomment-492045883,"fixes commit 62ec9cc
In case when DKMS package built without defined kversion, it must build module for target host current kernel version.","@netaskd I tried referencing kversion and install failed on target with different kernel.  I wound up creating my own rpm specfile based on fedora specfile from @amessina  (see [(https://github.com//issues/758)] ), eliminated the kversion references, and it works fine installing on target with different kernel.   Differing/changing kernel  versions is the problem that DKMS was designed to solve, it works automatically.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/linuxmaniac,1,https://github.com/sipwise/rtpengine/pull/738,"define stretch as first supported deb version
Fixes #737","define stretch as first supported deb version
Fixes #737",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/taurus-forever,2,https://github.com/sipwise/rtpengine/pull/738#issuecomment-473981764,"define stretch as first supported deb version
Fixes #737","It is looks line necessary changes if we want to build rtpengine for several .deb-based distributions.
I am not sure how to keep in sync files into pkg/deb and debian/* after changes in branches.
Sure for the latest one you will have symlinks... but still some changes can happens in NGCP branch mr5.5 which should be represented in pkg/deb/jessie/control, etc.
LGTM as it doesn't affect NGCP releasing.
Up 2 @mika and @guillemj  here.
P.S. @linuxmaniac TNX!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/mika,3,https://github.com/sipwise/rtpengine/pull/738#issuecomment-474462710,"define stretch as first supported deb version
Fixes #737","Hej @linuxmaniac - thanks for taking care! :) So we briefly discussed this internally, we're not yet sure whether that's the best approach for us, as it seems to go in the wrong direction, instead of removing all packaging it adds even more. :)
@linuxmaniac, do we have an overview of the current state of affairs of all the Debian + Ubuntu releases we (as in: building and providing packages at kamailio.sipwise.com) are targeting? (We could always special case rtpengine and guarantee it is buildable with oldstable and stable, possibly also testing.)
Another option might be to use master with what we have, and use debian/$release and ubuntu/$release or so (following https://dep-team.pages.debian.net/deps/dep14/) for their specific packaging. (We could try to automatically pull and rebase the branches against master during packaging builds?) Does anyone have experience with a setup like that?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/linuxmaniac,4,https://github.com/sipwise/rtpengine/pull/738#issuecomment-474938937,"define stretch as first supported deb version
Fixes #737","@mika I didn't even started to try to build on all the releases that kamailio 5.3 supports, so no for now I don't know the current stat of affairs
From my POV you don't even need to maintain pkg/deb/debian/backports/* or any pkg/whatever. It should be a community effort.
We (kamailio project) would like to switch the default config to use the rtpengine module and provide rtpengine packages for the same releases We currently do for kamailio in order to make life easier to our users.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/738#issuecomment-477605794,"define stretch as first supported deb version
Fixes #737","As of right now, I can't merge this because our jenkins-debian-glue refuses to build it due to lack of /debian/",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/taurus-forever,6,https://github.com/sipwise/rtpengine/pull/738#issuecomment-499556303,"define stretch as first supported deb version
Fixes #737","Hi @linuxmaniac,
As discussed on the ""Courage meeting"" we need to improve this a bit.

it is fine to have ""pkg"" folder with all the supported suites.
you need to move folder ""el"" into ""pkg/rhel/el5"" to be solid. Right? Maybe fire a separate pull request and ask RedHat files contributors to check it.
Move current ""debian/"" to ""pkg/debian/stretch/"" and create ""debian/"" symlink to ""pkg/debian/stretch/"" , so those changes will be fully compatible with Sipwise. Later on during migration to buster, we will create ""pkg/debian/buster"" and update symlink.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,738,2019-03-17T00:22:47Z,,2021-12-06T10:34:18Z,OPEN,False,2971,0,63,https://github.com/linuxmaniac,package files reorganization,2,[],https://github.com/sipwise/rtpengine/pull/738,https://github.com/taurus-forever,7,https://github.com/sipwise/rtpengine/pull/738#issuecomment-986647515,"define stretch as first supported deb version
Fixes #737",@linuxmaniac  resolved/abandoned with bbfe168 ?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,740,2019-03-21T13:18:35Z,2019-03-25T11:57:13Z,2019-03-25T11:57:13Z,MERGED,True,4,0,1,https://github.com/netaskd,add kernel-devel package as requires for DKMS module build on a target host,2,[],https://github.com/sipwise/rtpengine/pull/740,https://github.com/netaskd,1,https://github.com/sipwise/rtpengine/pull/740,DKMS module will not builded without kernel sources on the target host,DKMS module will not builded without kernel sources on the target host,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,740,2019-03-21T13:18:35Z,2019-03-25T11:57:13Z,2019-03-25T11:57:13Z,MERGED,True,4,0,1,https://github.com/netaskd,add kernel-devel package as requires for DKMS module build on a target host,2,[],https://github.com/sipwise/rtpengine/pull/740,https://github.com/mika,2,https://github.com/sipwise/rtpengine/pull/740#issuecomment-475227365,DKMS module will not builded without kernel sources on the target host,"AFAIK the kernel-devel package is rhel + fedora specific, but fails e.g. on SuSE, maybe we should use an approach like ZOL folks in https://github.com/zfsonlinux/zfs/blob/ecd3728b264b94de239932555b7046f1ddb936b2/rpm/generic/zfs-kmod.spec.in#L75?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,740,2019-03-21T13:18:35Z,2019-03-25T11:57:13Z,2019-03-25T11:57:13Z,MERGED,True,4,0,1,https://github.com/netaskd,add kernel-devel package as requires for DKMS module build on a target host,2,[],https://github.com/sipwise/rtpengine/pull/740,https://github.com/netaskd,3,https://github.com/sipwise/rtpengine/pull/740#issuecomment-475553369,DKMS module will not builded without kernel sources on the target host,"Hi @mika,
Thats a good idea! Changed in c2ad397",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,740,2019-03-21T13:18:35Z,2019-03-25T11:57:13Z,2019-03-25T11:57:13Z,MERGED,True,4,0,1,https://github.com/netaskd,add kernel-devel package as requires for DKMS module build on a target host,2,[],https://github.com/sipwise/rtpengine/pull/740,https://github.com/mika,4,https://github.com/sipwise/rtpengine/pull/740#issuecomment-476106907,DKMS module will not builded without kernel sources on the target host,"Thanks for taking care, @netaskd - LGTM!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/vitalikvoip,1,https://github.com/sipwise/rtpengine/pull/755,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.","If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/755#issuecomment-485436686,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.","I think this might add another race condition via the refcount of s. It would need an extra obj_hold on it before being added to the streams hash table, followed by an obj_put at the end of the function.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/vitalikvoip,3,https://github.com/sipwise/rtpengine/pull/755#issuecomment-485442509,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.",Checked the code and didn't understand what can go wrong between adding obj to streams and insertions of a new poller_item to a poller. Could you pls describe the case.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/755#issuecomment-485445067,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.","A concurrent streambuf_stream_closed event releases a reference of s if it was present in the streams hash table. If this happens right before poller_add_item is called, then s would be freed while i still points to it, before poller_add_item can grab a reference to it.
I'm not sure if this can actually happen with the current code base, but for robustness's sake the possibility should be accounted for.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/vitalikvoip,5,https://github.com/sipwise/rtpengine/pull/755#issuecomment-485464415,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.","Well streambuf_stream_closed is called from event callbacks which are invoked by a poller, so nobody can call them before streambuf_stream is added to poller.
But I see your point and additional guarding obj_hold/obj_put won't harm.
I will add them and update the pull request.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/vitalikvoip,6,https://github.com/sipwise/rtpengine/pull/755#issuecomment-487912281,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.",Added additional obj_hold/obj_put around streambuf_stream object.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/vitalikvoip,7,https://github.com/sipwise/rtpengine/pull/755#issuecomment-487936866,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.","Squashed commits.
If I understood the code correctly this additional obj_put in the end is needed. Objects added to streams are cleaned from streambuf_stream_closed which in its turn is called from different callbacks like streambuf_stream_readable or streambuf_stream_writeable. If we failed to add an item to poller those callbacks will never be called and thus streams will stay in streams forever.
After writing all this have a feeling that this patch is not very good. If we fail to add to poller my patch will remove streambuf_stream object but it will stay as a dangling pointer in listener->streams.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/755#issuecomment-487939575,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.",Hm yes you're right. I guess the code needs to clean up streams in the failure path.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,755,2019-04-16T13:31:29Z,2019-04-30T15:07:37Z,2019-05-03T11:07:54Z,MERGED,True,14,3,1,https://github.com/vitalikvoip,Insert streambuf object to listener->streams before adding it to poller,1,[],https://github.com/sipwise/rtpengine/pull/755,https://github.com/vitalikvoip,9,https://github.com/sipwise/rtpengine/pull/755#issuecomment-487981283,"If a CLI client disconnects immediately after connection establishment rtpengine sometimes doesn't remove resources (struct streambuf_stream) due to the race between poller threads (the one that accepted connection and another one that closed it).
To reproduce:
run: ./cli_test 1000
cli_test.zip
Some sockets will stay in CLOSE_WAIT forever.",Updated pull request.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,796,2019-06-21T09:49:30Z,2019-06-21T11:30:13Z,2019-06-21T11:30:13Z,MERGED,True,1,0,1,https://github.com/hdikme,add missing errno include,1,[],https://github.com/sipwise/rtpengine/pull/796,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/796,"Compilation error when trying to compile with ""with_transcoding = no"" switch.

In file included from ./log.h:6:0,
from ../include/obj.h:90,
from ../include/media_socket.h:9,
from dtmf.c:2:
dtmf.c: In function 'dtmf_init':
dtmf.c:15:77: error: 'errno' undeclared (first use in this function)
ilog(LOG_ERR, ""Failed to open/connect DTMF logging socket: %s"", strerror(errno));","Compilation error when trying to compile with ""with_transcoding = no"" switch.

In file included from ./log.h:6:0,
from ../include/obj.h:90,
from ../include/media_socket.h:9,
from dtmf.c:2:
dtmf.c: In function 'dtmf_init':
dtmf.c:15:77: error: 'errno' undeclared (first use in this function)
ilog(LOG_ERR, ""Failed to open/connect DTMF logging socket: %s"", strerror(errno));",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,797,2019-06-21T12:58:37Z,2019-06-21T13:11:41Z,2019-06-21T13:11:41Z,MERGED,True,1,1,2,https://github.com/razvancrainea,dtmf: prevent freeing json buf too early,1,[],https://github.com/sipwise/rtpengine/pull/797,https://github.com/razvancrainea,1,https://github.com/sipwise/rtpengine/pull/797,"When both logging and sending the DTMF event further, the json buffer
was released/freed before being sent on the network, resulting in a
0-length UDP packet. On the other hand, if only UDP sending was used
(without logging), a leak was happening. This commit fixes both issues.","When both logging and sending the DTMF event further, the json buffer
was released/freed before being sent on the network, resulting in a
0-length UDP packet. On the other hand, if only UDP sending was used
(without logging), a leak was happening. This commit fixes both issues.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,810,2019-07-17T22:00:32Z,2019-07-17T22:07:49Z,2019-07-17T22:07:49Z,MERGED,True,11,0,1,https://github.com/abalashov,Updated README with call recording info,2,[],https://github.com/sipwise/rtpengine/pull/810,https://github.com/abalashov,1,https://github.com/sipwise/rtpengine/pull/810,"Added call recording section with a bit of general explanation, since none was present there, and also an admonition not to use the same directory for spool dir and output / recordings dir.","Added call recording section with a bit of general explanation, since none was present there, and also an admonition not to use the same directory for spool dir and output / recordings dir.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,813,2019-07-19T19:15:27Z,2019-07-19T19:16:01Z,2019-07-19T19:16:01Z,CLOSED,False,707,46,13,https://github.com/benlai2018,Fix missing first character of connection_uid,14,[],https://github.com/sipwise/rtpengine/pull/813,https://github.com/benlai2018,1,https://github.com/sipwise/rtpengine/pull/813,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,818,2019-07-23T22:16:24Z,2019-07-23T22:17:16Z,2019-07-23T22:17:16Z,CLOSED,False,2963,55,19,https://github.com/benlai2018,Not finished: Add tcp server and timer,21,[],https://github.com/sipwise/rtpengine/pull/818,https://github.com/benlai2018,1,https://github.com/sipwise/rtpengine/pull/818,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,830,2019-08-26T05:16:42Z,2019-08-28T12:02:06Z,2019-08-28T12:02:06Z,MERGED,True,46,1,2,https://github.com/space88man,RPM packaging on EL: detect systemd directories and package unit files,1,[],https://github.com/sipwise/rtpengine/pull/830,https://github.com/space88man,1,https://github.com/sipwise/rtpengine/pull/830,"For EL-like systems, using el/rtpengine.spec, package el/rtpengine.service and idiomatic usage of systemctl.","For EL-like systems, using el/rtpengine.spec, package el/rtpengine.service and idiomatic usage of systemctl.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,831,2019-08-26T05:26:21Z,2019-08-28T12:02:06Z,2019-08-28T12:02:06Z,MERGED,True,6,1,1,https://github.com/space88man,EL8: mariadb-devel conflicts with mysql-devel,1,[],https://github.com/sipwise/rtpengine/pull/831,https://github.com/space88man,1,https://github.com/sipwise/rtpengine/pull/831,Detect EL8 and use mariadb-devel instead.,Detect EL8 and use mariadb-devel instead.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,831,2019-08-26T05:26:21Z,2019-08-28T12:02:06Z,2019-08-28T12:02:06Z,MERGED,True,6,1,1,https://github.com/space88man,EL8: mariadb-devel conflicts with mysql-devel,1,[],https://github.com/sipwise/rtpengine/pull/831,https://github.com/space88man,2,https://github.com/sipwise/rtpengine/pull/831#issuecomment-524721497,Detect EL8 and use mariadb-devel instead.,"In EL8 , mariadb-devel does not provide mysql-devel, but instead conflicts with it. 😢",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,832,2019-08-26T09:03:18Z,2019-08-28T12:02:06Z,2019-08-28T12:02:06Z,MERGED,True,4,2,1,https://github.com/space88man,"EL7,8: no such package iptables-ipv6",1,[],https://github.com/sipwise/rtpengine/pull/832,https://github.com/space88man,1,https://github.com/sipwise/rtpengine/pull/832,"EL7, EL8 don't have iptables-ipv6","EL7, EL8 don't have iptables-ipv6",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/834,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee","Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/834#issuecomment-525801896,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",Will take a while for me to go through this...,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/balajeesv,3,https://github.com/sipwise/rtpengine/pull/834#issuecomment-531243021,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",With new commit sender clock drift handling and few other minor fixes are done.Please check.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/balajeesv,4,https://github.com/sipwise/rtpengine/pull/834#issuecomment-559994185,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",@rfuchs Did you get a chance to review this PR?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/834#issuecomment-560343752,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee","No not yet, sorry for the delay, I'll try to get to it one of these days",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/balajeesv,6,https://github.com/sipwise/rtpengine/pull/834#issuecomment-564103880,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee","Ok, so from a quick first glace, I see that this is implemented as an incoming packet buffer, unlike the send_timer mechanism that already exists, which is an outgoing packet buffer. Originally I was under the impression that this would be another outgoing packet buffer, which is why I suggested using the send_timer.
This makes me think that a more generic version of send_timer would be more appropriate in order to eliminate some unnecessary case distinctions. Either completely unlinked from the send_timer as another instance of a timerthread (which would require separate dedicated threads), or within the send_timer but using a handler function in codec_packet (which then should probably be renamed).
I can probably handle this kind of refactoring if you prefer.

@rfuchs Incoming packet buffer used because of transcoding and re-packetization would get benefitted from the incoming buffer.
I would be happy to get this refactored to a more generic version of send_timer :)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/balajee-plivo,7,https://github.com/sipwise/rtpengine/pull/834#issuecomment-572401107,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",@rfuchs Did you get chance to look into responses?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/834#issuecomment-572696264,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee","Yes, thank you, I plan on getting on this shortly.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/rfuchs,9,https://github.com/sipwise/rtpengine/pull/834#issuecomment-578248559,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",Just a quick update here to let you know that I'm almost through with refactoring and integrating your code.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/rfuchs,10,https://github.com/sipwise/rtpengine/pull/834#issuecomment-579814998,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee","I've pushed my refactored version of this into the branch rfuchs/jb. If you can, please try it and see if/how it works for you.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,834,2019-08-27T14:45:41Z,2020-02-12T17:32:06Z,2020-02-12T17:32:06Z,CLOSED,False,527,36,17,https://github.com/balajeesv,Jitter Buffer implementation for rtpengine,9,[],https://github.com/sipwise/rtpengine/pull/834,https://github.com/balajeesv,11,https://github.com/sipwise/rtpengine/pull/834#issuecomment-580354894,"Hi,
Please review Jitter buffer implementation in rtpengine. Discussions regarding jitter buffer implementation can be found here.
The algorithm is mentioned in the gist and the timer is implemented with existing timer thread pool instead of ptime proposed.
The existing timer is enhanced to support jitter buffer by introducing a few changes like insert into the queue with sorting in descending order (sorted in descending order for faster insertion) and read from the tail.
Tested this code with basic buffering, packets drops, duplicates, repacketization, and transcoding.
Thanks,
Balajee",Sure. I will test and update you.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,836,2019-08-29T12:49:52Z,2019-09-19T13:52:50Z,2019-09-19T13:52:50Z,CLOSED,False,1,0,1,https://github.com/denyspozniak,spandsp-devel is missing,2,[],https://github.com/sipwise/rtpengine/pull/836,https://github.com/denyspozniak,1,https://github.com/sipwise/rtpengine/pull/836,added spandsp-devel to the build requirements.,added spandsp-devel to the build requirements.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,836,2019-08-29T12:49:52Z,2019-09-19T13:52:50Z,2019-09-19T13:52:50Z,CLOSED,False,1,0,1,https://github.com/denyspozniak,spandsp-devel is missing,2,[],https://github.com/sipwise/rtpengine/pull/836,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/836#issuecomment-526172151,added spandsp-devel to the build requirements.,Can you squash those please 😆,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,841,2019-09-06T08:42:54Z,2019-09-18T13:29:58Z,2019-09-18T13:29:58Z,CLOSED,False,7,5,1,https://github.com/sea5727,codec_ssrc_handler memory leak clear,1,[],https://github.com/sipwise/rtpengine/pull/841,https://github.com/sea5727,1,https://github.com/sipwise/rtpengine/pull/841,"valgrind memory leak clear
before valgrind log :
==22420== 22,265 (544 direct, 21,721 indirect) bytes in 2 blocks are definitely lost in loss record 901 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x4253AA: control_ng_incoming (control_ng.strhash.c:356)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== 64,124 (272 direct, 63,852 indirect) bytes in 1 blocks are definitely lost in loss record 903 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x425375: control_ng_incoming (control_ng.strhash.c:360)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== LEAK SUMMARY:
==22420==    definitely lost: 4,915 bytes in 42 blocks
==22420==    indirectly lost: 92,299 bytes in 233 blocks
==22420==      possibly lost: 15,338 bytes in 26 blocks
==22420==    still reachable: 642,824 bytes in 5,426 blocks
==22420==                       of which reachable via heuristic:
==22420==                         newarray           : 1,536 bytes in 16 blocks
==22420==         suppressed: 0 bytes in 0 blocks
==22420== Reachable blocks (those to which a pointer was found) are not shown.
==22420== To see them, rerun with: --leak-check=full --show-leak-kinds=all
after valgrind log : ( definitely Lost clear )
==7730== LEAK SUMMARY:
==7730==    definitely lost: 4,091 bytes in 38 blocks
==7730==    indirectly lost: 6,726 bytes in 112 blocks
==7730==      possibly lost: 10,692 bytes in 24 blocks
==7730==    still reachable: 640,704 bytes in 5,418 blocks
==7730==                       of which reachable via heuristic:
==7730==                         newarray           : 1,536 bytes in 16 blocks
==7730==         suppressed: 0 bytes in 0 blocks
==7730== Reachable blocks (those to which a pointer was found) are not shown.
==7730== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==7730==
==7730== Use --track-origins=yes to see where uninitialised values come from
==7730== ERROR SUMMARY: 34 errors from 33 contexts (suppressed: 0 from 0)","valgrind memory leak clear
before valgrind log :
==22420== 22,265 (544 direct, 21,721 indirect) bytes in 2 blocks are definitely lost in loss record 901 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x4253AA: control_ng_incoming (control_ng.strhash.c:356)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== 64,124 (272 direct, 63,852 indirect) bytes in 1 blocks are definitely lost in loss record 903 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x425375: control_ng_incoming (control_ng.strhash.c:360)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== LEAK SUMMARY:
==22420==    definitely lost: 4,915 bytes in 42 blocks
==22420==    indirectly lost: 92,299 bytes in 233 blocks
==22420==      possibly lost: 15,338 bytes in 26 blocks
==22420==    still reachable: 642,824 bytes in 5,426 blocks
==22420==                       of which reachable via heuristic:
==22420==                         newarray           : 1,536 bytes in 16 blocks
==22420==         suppressed: 0 bytes in 0 blocks
==22420== Reachable blocks (those to which a pointer was found) are not shown.
==22420== To see them, rerun with: --leak-check=full --show-leak-kinds=all
after valgrind log : ( definitely Lost clear )
==7730== LEAK SUMMARY:
==7730==    definitely lost: 4,091 bytes in 38 blocks
==7730==    indirectly lost: 6,726 bytes in 112 blocks
==7730==      possibly lost: 10,692 bytes in 24 blocks
==7730==    still reachable: 640,704 bytes in 5,418 blocks
==7730==                       of which reachable via heuristic:
==7730==                         newarray           : 1,536 bytes in 16 blocks
==7730==         suppressed: 0 bytes in 0 blocks
==7730== Reachable blocks (those to which a pointer was found) are not shown.
==7730== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==7730==
==7730== Use --track-origins=yes to see where uninitialised values come from
==7730== ERROR SUMMARY: 34 errors from 33 contexts (suppressed: 0 from 0)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,841,2019-09-06T08:42:54Z,2019-09-18T13:29:58Z,2019-09-18T13:29:58Z,CLOSED,False,7,5,1,https://github.com/sea5727,codec_ssrc_handler memory leak clear,1,[],https://github.com/sipwise/rtpengine/pull/841,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/841#issuecomment-528833873,"valgrind memory leak clear
before valgrind log :
==22420== 22,265 (544 direct, 21,721 indirect) bytes in 2 blocks are definitely lost in loss record 901 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x4253AA: control_ng_incoming (control_ng.strhash.c:356)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== 64,124 (272 direct, 63,852 indirect) bytes in 1 blocks are definitely lost in loss record 903 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x425375: control_ng_incoming (control_ng.strhash.c:360)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== LEAK SUMMARY:
==22420==    definitely lost: 4,915 bytes in 42 blocks
==22420==    indirectly lost: 92,299 bytes in 233 blocks
==22420==      possibly lost: 15,338 bytes in 26 blocks
==22420==    still reachable: 642,824 bytes in 5,426 blocks
==22420==                       of which reachable via heuristic:
==22420==                         newarray           : 1,536 bytes in 16 blocks
==22420==         suppressed: 0 bytes in 0 blocks
==22420== Reachable blocks (those to which a pointer was found) are not shown.
==22420== To see them, rerun with: --leak-check=full --show-leak-kinds=all
after valgrind log : ( definitely Lost clear )
==7730== LEAK SUMMARY:
==7730==    definitely lost: 4,091 bytes in 38 blocks
==7730==    indirectly lost: 6,726 bytes in 112 blocks
==7730==      possibly lost: 10,692 bytes in 24 blocks
==7730==    still reachable: 640,704 bytes in 5,418 blocks
==7730==                       of which reachable via heuristic:
==7730==                         newarray           : 1,536 bytes in 16 blocks
==7730==         suppressed: 0 bytes in 0 blocks
==7730== Reachable blocks (those to which a pointer was found) are not shown.
==7730== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==7730==
==7730== Use --track-origins=yes to see where uninitialised values come from
==7730== ERROR SUMMARY: 34 errors from 33 contexts (suppressed: 0 from 0)","Good catch, thanks. I don't think this is correct fix though. I will upload my proposed patch later, can you then check if this fixes your leaks as well?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,841,2019-09-06T08:42:54Z,2019-09-18T13:29:58Z,2019-09-18T13:29:58Z,CLOSED,False,7,5,1,https://github.com/sea5727,codec_ssrc_handler memory leak clear,1,[],https://github.com/sipwise/rtpengine/pull/841,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/841#issuecomment-528844953,"valgrind memory leak clear
before valgrind log :
==22420== 22,265 (544 direct, 21,721 indirect) bytes in 2 blocks are definitely lost in loss record 901 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x4253AA: control_ng_incoming (control_ng.strhash.c:356)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== 64,124 (272 direct, 63,852 indirect) bytes in 1 blocks are definitely lost in loss record 903 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x425375: control_ng_incoming (control_ng.strhash.c:360)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== LEAK SUMMARY:
==22420==    definitely lost: 4,915 bytes in 42 blocks
==22420==    indirectly lost: 92,299 bytes in 233 blocks
==22420==      possibly lost: 15,338 bytes in 26 blocks
==22420==    still reachable: 642,824 bytes in 5,426 blocks
==22420==                       of which reachable via heuristic:
==22420==                         newarray           : 1,536 bytes in 16 blocks
==22420==         suppressed: 0 bytes in 0 blocks
==22420== Reachable blocks (those to which a pointer was found) are not shown.
==22420== To see them, rerun with: --leak-check=full --show-leak-kinds=all
after valgrind log : ( definitely Lost clear )
==7730== LEAK SUMMARY:
==7730==    definitely lost: 4,091 bytes in 38 blocks
==7730==    indirectly lost: 6,726 bytes in 112 blocks
==7730==      possibly lost: 10,692 bytes in 24 blocks
==7730==    still reachable: 640,704 bytes in 5,418 blocks
==7730==                       of which reachable via heuristic:
==7730==                         newarray           : 1,536 bytes in 16 blocks
==7730==         suppressed: 0 bytes in 0 blocks
==7730== Reachable blocks (those to which a pointer was found) are not shown.
==7730== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==7730==
==7730== Use --track-origins=yes to see where uninitialised values come from
==7730== ERROR SUMMARY: 34 errors from 33 contexts (suppressed: 0 from 0)",Please see 938605a,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,841,2019-09-06T08:42:54Z,2019-09-18T13:29:58Z,2019-09-18T13:29:58Z,CLOSED,False,7,5,1,https://github.com/sea5727,codec_ssrc_handler memory leak clear,1,[],https://github.com/sipwise/rtpengine/pull/841,https://github.com/sea5727,4,https://github.com/sipwise/rtpengine/pull/841#issuecomment-529091559,"valgrind memory leak clear
before valgrind log :
==22420== 22,265 (544 direct, 21,721 indirect) bytes in 2 blocks are definitely lost in loss record 901 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x4253AA: control_ng_incoming (control_ng.strhash.c:356)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== 64,124 (272 direct, 63,852 indirect) bytes in 1 blocks are definitely lost in loss record 903 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x425375: control_ng_incoming (control_ng.strhash.c:360)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== LEAK SUMMARY:
==22420==    definitely lost: 4,915 bytes in 42 blocks
==22420==    indirectly lost: 92,299 bytes in 233 blocks
==22420==      possibly lost: 15,338 bytes in 26 blocks
==22420==    still reachable: 642,824 bytes in 5,426 blocks
==22420==                       of which reachable via heuristic:
==22420==                         newarray           : 1,536 bytes in 16 blocks
==22420==         suppressed: 0 bytes in 0 blocks
==22420== Reachable blocks (those to which a pointer was found) are not shown.
==22420== To see them, rerun with: --leak-check=full --show-leak-kinds=all
after valgrind log : ( definitely Lost clear )
==7730== LEAK SUMMARY:
==7730==    definitely lost: 4,091 bytes in 38 blocks
==7730==    indirectly lost: 6,726 bytes in 112 blocks
==7730==      possibly lost: 10,692 bytes in 24 blocks
==7730==    still reachable: 640,704 bytes in 5,418 blocks
==7730==                       of which reachable via heuristic:
==7730==                         newarray           : 1,536 bytes in 16 blocks
==7730==         suppressed: 0 bytes in 0 blocks
==7730== Reachable blocks (those to which a pointer was found) are not shown.
==7730== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==7730==
==7730== Use --track-origins=yes to see where uninitialised values come from
==7730== ERROR SUMMARY: 34 errors from 33 contexts (suppressed: 0 from 0)","Good catch, thanks. I don't think this is correct fix though. I will upload my proposed patch later, can you then check if this fixes your leaks as well?

ok. i will testing. after my holiday is during about 1weeks.
I don't thinks this is correct fix too. just temporarily.
I don't know rtpengine well.
if you correct this bug. and I will test. thanks",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,841,2019-09-06T08:42:54Z,2019-09-18T13:29:58Z,2019-09-18T13:29:58Z,CLOSED,False,7,5,1,https://github.com/sea5727,codec_ssrc_handler memory leak clear,1,[],https://github.com/sipwise/rtpengine/pull/841,https://github.com/sea5727,5,https://github.com/sipwise/rtpengine/pull/841#issuecomment-529092049,"valgrind memory leak clear
before valgrind log :
==22420== 22,265 (544 direct, 21,721 indirect) bytes in 2 blocks are definitely lost in loss record 901 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x4253AA: control_ng_incoming (control_ng.strhash.c:356)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== 64,124 (272 direct, 63,852 indirect) bytes in 1 blocks are definitely lost in loss record 903 of 906
==22420==    at 0x4C28EC3: malloc (vg_replace_malloc.c:309)
==22420==    by 0x518968D: g_malloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A0C8D: g_slice_alloc (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x51A11ED: g_slice_alloc0 (in /usr/lib64/libglib-2.0.so.0.5600.1)
==22420==    by 0x457F53: __obj_alloc0 (obj.h:132)
==22420==    by 0x457F53: __ssrc_handler_transcode_new (codec.c:1213)
==22420==    by 0x454C27: create_ssrc_hash_full (ssrc.c:190)
==22420==    by 0x459895: __make_transcoder (codec.c:224)
==22420==    by 0x45B2E8: codec_handlers_update (codec.c:619)
==22420==    by 0x415BCA: monologue_offer_answer (call.c:1896)
==22420==    by 0x43608D: call_offer_answer_ng (call_interfaces.strhash.c:1232)
==22420==    by 0x425375: control_ng_incoming (control_ng.strhash.c:360)
==22420==    by 0x42439B: udp_listener_incoming (udp_listener.c:54)
==22420==
==22420== LEAK SUMMARY:
==22420==    definitely lost: 4,915 bytes in 42 blocks
==22420==    indirectly lost: 92,299 bytes in 233 blocks
==22420==      possibly lost: 15,338 bytes in 26 blocks
==22420==    still reachable: 642,824 bytes in 5,426 blocks
==22420==                       of which reachable via heuristic:
==22420==                         newarray           : 1,536 bytes in 16 blocks
==22420==         suppressed: 0 bytes in 0 blocks
==22420== Reachable blocks (those to which a pointer was found) are not shown.
==22420== To see them, rerun with: --leak-check=full --show-leak-kinds=all
after valgrind log : ( definitely Lost clear )
==7730== LEAK SUMMARY:
==7730==    definitely lost: 4,091 bytes in 38 blocks
==7730==    indirectly lost: 6,726 bytes in 112 blocks
==7730==      possibly lost: 10,692 bytes in 24 blocks
==7730==    still reachable: 640,704 bytes in 5,418 blocks
==7730==                       of which reachable via heuristic:
==7730==                         newarray           : 1,536 bytes in 16 blocks
==7730==         suppressed: 0 bytes in 0 blocks
==7730== Reachable blocks (those to which a pointer was found) are not shown.
==7730== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==7730==
==7730== Use --track-origins=yes to see where uninitialised values come from
==7730== ERROR SUMMARY: 34 errors from 33 contexts (suppressed: 0 from 0)","Please see 938605a

ok!  I will test after 1weeks. thanks",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,856,2019-10-01T09:50:34Z,2019-10-01T13:00:05Z,2019-10-01T13:00:05Z,CLOSED,False,1,0,1,https://github.com/xadhoom,Add missing errno.h,1,[],https://github.com/sipwise/rtpengine/pull/856,https://github.com/xadhoom,1,https://github.com/sipwise/rtpengine/pull/856,"Fixes the following compilation error:
dtmf.c: In function 'dtmf_init':
dtmf.c:15:77: error: 'errno' undeclared (first use in this function)
ilog(LOG_ERR, ""Failed to open/connect DTMF logging socket: %s"", strerror(errno));","Fixes the following compilation error:
dtmf.c: In function 'dtmf_init':
dtmf.c:15:77: error: 'errno' undeclared (first use in this function)
ilog(LOG_ERR, ""Failed to open/connect DTMF logging socket: %s"", strerror(errno));",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,1,https://github.com/sipwise/rtpengine/pull/892,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,2,https://github.com/sipwise/rtpengine/pull/892#issuecomment-564549721,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","I forgot to note the expected configuration required for this setup to work:
The configuration should have:

One local interface (with advertised address or not, label is optional)
Redis server configured with a single known database number
The same database used as the subscribed keyspace

Example:
[rtpengine]
interface=172.30.1.1!12.34.56.78
listen-ng=2223
redis=redis-server:6379/1
sip-source=true
num-threads=2
subscribe-keyspace=1",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/892#issuecomment-565083246,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Ok, so to summarise: Normally rtpengine stores the name (label) and the ID of the local interface used for each local port into Redis, and then uses that information to restore the same status when a call is restored. This patch adds a plain interface address to the call structure, and when present, rtpengine uses that address instead of the actual interface address when communicating to the outside world, while the actual UDP socket is still bound to whatever local interface is configured. Did I get it right so far?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,4,https://github.com/sipwise/rtpengine/pull/892#issuecomment-565161652,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Yes, that's basically it. This works well for me where my nodes are running behind a 1-to-1 NAT where what we store and advertise is an IP address not listed on the local interface. I don't think it matters for this behavior change (I assume that without the NAT public IP address, advertised_address will be the actual local IP address).
The main issue is that the stored interface address belongs to another node (it is only used for ""foreign calls""), so the RTP socket is actually bound on another machine.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/892#issuecomment-565460266,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Ok. I don't have a problem adding such a feature, but obviously it would have to be optional and configurable. Also I'd like to have it in a more generic way, meaning without the requirement for a special case config. This can probably be achieved by having the ""connection address"" stored not per call, but rather per socket (or per media), and perhaps add a flag to configured interfaces to signal that this is an interface that can receive non-local network traffic.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,6,https://github.com/sipwise/rtpengine/pull/892#issuecomment-567001359,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Sorry for taking the time to respond. I want to advance this feature request, but am running into difficulties:

When you say ""per socket (or per media)"", what do you mean in regards to the Redis call data structure? Do you mean the thing that redis.c calls ""sfd-%u"" or ""stream-%u"" ? And why would I want to store it there - don't all streams go through the same server?
We seem to be having some trouble with SRTP, which needs more investigation and likely more work - I'll update when we have a solution, which will likely require storing more information in Redis.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/892#issuecomment-567042299,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Re 1. Yes all streams go through the same server, but a single call can have ports/sockets allocated from multiple different interfaces. This feature currently requires that only a single interface is configured. I'd like to lift this restriction and make it work also in scenarios with multiple interfaces present.
SRTP should not really be affected by this. If it works without this feature, it should work with it. At least I see no reason why it shouldn't 😄",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,8,https://github.com/sipwise/rtpengine/pull/892#issuecomment-570055622,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","@rfuchs - I'd appreciate your input on a problem I'm with this feature: when rtpengine loads a foreign call from Redis, as part of loading the data structure into memory, it also tries to open all the ports described in the sfds. I've been getting error sometimes with that process as when multiple servers are handling calls, they can open the same ports numbers for different calls (on different servers), so when a foreign call is loaded, it might describe ports that are already in use by local calls.
I tried to figure out how the static configuration - with multiple interfaces configured on the local machine (describing interfaces on remote machines), but I can't figure out how you avoid that problem in the static configuration either. I'd appreciate any pointers.
The last commit - that tries to just not allocate the ports - was causing later code to SIGSEGV or SIGABRT, so I removed it.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,9,https://github.com/sipwise/rtpengine/pull/892#issuecomment-570921136,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Possibly related to my last question, you said:

perhaps add a flag to configured interfaces to signal that this is an interface that can receive non-local network traffic

Would that mean that __get_consecutive_ports would know that it doesn't need to allocate a port for a foreign call? if so - how can it propagate that knowledge? all the other things after the call to __get_consecutive_ports in redis_sfds assume that there is stream_fd that holds a real OS socket.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,10,https://github.com/sipwise/rtpengine/pull/892#issuecomment-571276128,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Ok, I've been spending a lot of time with this issue the last week, as I still can't get this feature to work, so here's a summary of the status - what I'm looking for and what I understood rtpengine does. Hopefully it will inform our communications.
Current clustering method
I believe I failed to understand what the current cluster/redis support in rtpengine does. The way I understand it now is that the cluster setup is supposed to be as follows:

A fixed number of servers are set up and configured. The IP addresses and interfaces for all of these are known.
The servers network stack is configured with all of the IP addresses of all of the servers! (I'm pretty sure I'm correct about this, though the Wiki page doesn't mention that at all).
Some kind of network router, such as ipvsadm knows which server ""owns"" which IP address, and when a server fail - to route traffic destined to the IP of the failed server, to another server - where that IP is already configured on the TCP stack, so would just work.
A Redis ""database"" number is pre-allocated for each server.
rtpengine is configured with all of that information.

When a new offer is received, the primary rtpengine that received it sets up the call data and stores it in their Redis database. All other servers (I'm going to call them ""alternates"" from now on) read the data and set up ""foreign call"" data, while also opening all the listening ports required, on their ""copy"" of the primary's network interface (i.e. on the IP alias that was pre-configured). The alternates can do that because the primary broadcasted the logical name of the network interface it runs the call on, they have a configuration that identifies which IP that name is globally attached to (i.e. its the same name to the same IP in all rtpengine instances), and that IP is already configured in some network interface in the OS (step 2 above).
While concurrent calls with different primaries may re-use port numbers, because each logical interface has its own port pool, it works fine because ""conflicting"" ports are bound on different IP addresses and the OS network stack handles that nicely.

Pros: in-call failover: as an rtpengine instance crashes, assuming the network router knows to detect that and ""migrate"" the IP address, calls can continue with possibly no interruption.
Cons:

As long as the primary is running, all commands must be directed at the primary and alternates are only used for fallbacks in case of an rtpengine failure, so the load balancer needs some kind of session tracking, probably call-id based, so it is a layer 5 LB.
There is a hard limit on the number of servers by the number of supported Redis databases (IIRC its 16)
There is a soft limit by the complexity of the network configuration and needing to manage it.



Suggested ""zero-knowledge"" clustering method.
What I'm trying to achieve is a dynamic cluster that supports:

Auto-scaling: we shouldn't need to pre-allocate all the resources - running on modern cloud infrastructure should allow us to change resource allocation in runtime to track demand. This means we can't pre-configure a set of IP addresses
Work with minimal configuration dumb load balancers, such as those offered by cloud infrastructure, that have no session tracking and no failover logic.

Problems:

we can't pre-configure network interfaces (theoretically we can use a pool of known IP addresses, and re-use them when scaling out, but that limits scaling and makes it much more costly both in configuration complexity and actual money: pre-allocated IPs have a cost, so I rather not do that if I can).
we can't pre-allocate Redis databases per-server.
we can't assume intelligent routing: servers will have to answer for commands where they are not the primary! (this is the main problem I'm stuck on atm).

The setup I'm looking for will be like this:

Servers can come and go with completely arbitrary configuration.
Each server gets configured in runtime to know just their local IP addresses.
A layer 3 or 4 simple load balancer routes control commands atrbitrarily (i.e. with no stickiness)
All servers share a single Redis ""database""
rtpengine is configured just with the local interfaces and the single Redis database for both writing and reading. RTP is routed directly from UAs to servers without load balancing.

When a new offer is received, the primary rtpengine that received is setes up the call data, records the IP addresses it uses for each of the two media objects and stores it in the Redis database (actually in the SDP's ""<family> SPACE <address>"" format, because there's an easily refactored piece of code that does it like that and we always need both data items at once). All alternates read the data and set up ""foreign call"" data, including the primary's network interface addresses, but do not open listening ports - because we worry about port pool conflicts and we can't listen on ""other servers IPs"" anyway.
When an alternate receives a command (because the load balancer is dumb), it generates the correct SDP for continuing to route the media through the primary, because it has all the information: it knows all the port numbers and the controlling (foreign) network interface's familty and address.

Pros:

configuration is much simpler and less limited.
should work well with and take advantage of modern cloud infrastructure.


Cons:

If a server goes down, all calls it is running are lost. For my requirements this is a minor problem in and of itself (assuming a server crash), but it is a major problem with scale-in: a scale-in action has to take the server out of the command load balancer and then wait until all calls terminate before killing the server. This is not a trivial setup but seems quite doable with relatively simple control logic that we will create later (and I won't mind sharing).



The problems

Storing the controlling network interface address data in Redis so alternates can ""fake"" SDP responses - this is done and I've settled on storing it in the media structure (it is currently in another branch and not in this PR, but I'll push it here shortly).
Supporting ""foreign ports"" for socket_t (that we shouldn't bind to): when the Redis code loads the foreign call, it needs to create the data structures to faithfully reproduce the original port numbers in the SDP for ""alternate answers"", but we can't actually bind to the ports because (a) its useless and (b) it might conflicts with ports for local calls. I've added a field and some support code for using socket_t as a ""not an actual bound port"", and it seems to be working fine, but the logic for deciding when to use it probably breaks the static cluster use case - I probably want to add a new configuration field to trigger this behavior?
Reusing a ""cached"" network address when rewriting the SDP - done.
Updating the primary data when an alternate handles an answer: the ""leg B"" endpoint is known only in the answer, and without letting the primary know about it, the primary won't send RTP to B's UA. This is the main issue I'm trying to tackle now. The alternate doesn't write things back into Redis, but if it did - the primary will just ignore it as it ignores notification on its ow calls, and even if it didn't - we'd run into all kinds of update races and data conflicts. I think the best way would be to add another pub/sub for ""back updates"" where the alternate can send just the UA endpoint data from the answer - when a primary sees a ""back update"" for its own call, it can update the endpoint, keep calm and carry on.

Any pointers, screams or oy-veys are welcome :-)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,11,https://github.com/sipwise/rtpengine/pull/892#issuecomment-571660247,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","I was mistaken about the alternates not updating Redis - they do. So I'm trying to implement ""don't ignore foreign updates, try to integrate them"" for primaries. The issues I'm having are:
a. seems that a lot of the changes in the alternate write-back are due to json_restore_call not generating a 100% faithful call structure. For example, my alternate logs show notifications such as Opus doesn't support a ptime of 32000 ms; using 60 ms instead during foreign call loads, when ptime is actually set to ""0"" in the original JSON write, then in the writeback is is set to ""20"" (?). So I need to be very careful with what I choose to update.
b. It is not easy to update things: the call data management is done throughout performing SDP rewrite logic, so without duplicating various data access codes from throughout call.c, I doubt I can do all the needed updates, and even then - I'm missing a lot of know how about call.c internals to make it safe. I'll concentrate on getting my use-case working, and we'll see from there.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,12,https://github.com/sipwise/rtpengine/pull/892#issuecomment-571704146,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","For the underlying RTP sockets, I see two distinct cases:

No advertised address is used and change of endpoint address from one instance to another is handled by the load balancer through a changed network route (e.g. a host route). A naive approach would be to store the address into Redis and have other instances simply open the port on that address while ignoring their own interface configuration. This would require the net.ipv4.ip_nonlocal_bind sysctl to be enabled (there's an IPv6 equivalent too) as well as an external mechanism to bring the address up locally when needed.
Advertised address is used and change of endpoint address from one instance to another is handled by the load balancer through a changed NAT destination. In this case, the port is bound to whatever interface address rtpengine is configured and it's the advertised address that's stored into Redis instead. Care must be taken that there is no overlap in address/port ranges, so this probably doesn't scale indefinitely.

In both cases, the logical interface name should still be honoured, so that multiple interfaces can be supported, even though in the first case it will likely be of little consequence.
For the Redis part of the puzzle, I can't provide much insight since this sort of active/active failover is contributed code and we're not using rtpengine in this mode ourselves. I would assume that the distinction between ""foreign"" and owned call must remain so that standby instances don't act on these calls (e.g. doing timeouts or writing to Redis) by default. I would try to avoid sending signalling to instances that don't own the call if at all possible as that would complicate things considerably. Instead, receiving signalling (or RTP for that matter) should switch a call from ""foreign"" to ""owned,"" giving that instance ownership of that call, presuming that whichever instance owned the call previously is not there any more. This switching of ownership could also happen explicitly instead, e.g. through some sort of command to rtpengine ""take over all calls owned by instance X."" This would require giving each instance a unique identifier and storing the owner ID for each call into Redis.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,13,https://github.com/sipwise/rtpengine/pull/892#issuecomment-571756567,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","No advertised address ... This would require the net.ipv4.ip_nonlocal_bind sysctl to be enabled


Very interesting - I wasn't aware of that capability.

I would try to avoid sending signalling to instances that don't own the call if at all possible as that would complicate things considerably.

Yea, I'm looking at that complication now :-/ . One option we were looking at is ""just"" writing the session aware signaling load-balancer, to make sure all signaling work well, but we concluded that writing a reliable load-balancer for auto scaling is harder then utilizing the existing Redis active/active support. This assessment may have been incorrect.

This would require giving each instance a unique identifier and storing the owner ID for each call into Redis.

AFAIK, each instance already have a unique ID: it adds it to the SDPs it replies with. I think storing it in Redis would be a good idea, but I didn't find where it is stored in memory.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,14,https://github.com/sipwise/rtpengine/pull/892#issuecomment-571800717,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","AFAIK, each instance already have a unique ID: it adds it to the SDPs it replies with. I think storing it in Redis would be a good idea, but I didn't find where it is stored in memory.

That's static const str instance_id in sdp.c. It's generated randomly during startup. You can use this, but then it should be made somewhat more constant across restarts.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,15,https://github.com/sipwise/rtpengine/pull/892#issuecomment-572459903,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","That's static const str instance_id in sdp.c. It's generated randomly during startup. You can use this, but then it should be made somewhat more constant across restarts.

Constant across restart does not help with my ""immutable replaceable instances"" scenario, but I guess I can make this as a hash on configured interfaces hardware IDs?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,16,https://github.com/sipwise/rtpengine/pull/892#issuecomment-578523209,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Update on progress: with all the latest commits, I can now have an answer handled by an alternative server, and when the alternative updates the shared Redis database - the primary picks up the update and we get enough things updated in the local call structure so that the call can complete successfully.
I'll now continue working on the additional stuff, which IIRC are:

storing instance id in Redis. I think that using the current instance id is good enough: it isn't predictable and isn't retained across service restarts, but I think that is fine: a restart will need to re-setup everything anyway, and we don't know how long the service had been down - it likely have lost all of its calls anyway. Also - on my setup I reconfigure and restart the server if the server changes IP (which it does from time to time because we have a weird EC2 elastic IP setup), so it is technically a new service instance (it has different IP addresses).
fix various failures of the Redis read/write code - it looks like the codec payload handling both doesn't serialize all the required data, and then fails to deserialize whatever it read faithfully (ptime field being read incorrectly being the main issue I observed).
figure out how to configure the zero-knoweldge behavior properly. @rfuchs - how would you suggest I flag interfaces as being ""valid for non-local traffic""? The current interface definition format is pretty complex as it is. Other than that, I think handling special ""subscriber-keyspace"" value of ""shared"" would means that we expect all instances to send updates to the same Redis database and we should subscribe to that same database for notifications - this I think would convey all the required logic, and we don't need to if (config.keyspace==shared) in the notification handling code because there's no other reason for the call owner to see updates to its own calls (normally updates are only received from other databases, or not at all). Maybe have it be an error to set subscriber-keyspace to the same database as the redis configuration (instead of explicitly saying ""shared"")?

IIRC these are the open issues we discussed regarding this feature, please correct me if I'm wrong.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,17,https://github.com/sipwise/rtpengine/pull/892#issuecomment-578773166,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Is it even necessary to flag interfaces as being non-local? If a Redis update comes in with an overridden interface address, then that address should be used regardless of what's in the config, no?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,18,https://github.com/sipwise/rtpengine/pull/892#issuecomment-586687720,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","So the last push (and I'll fix the merge conflicts in a bit) works for me: in a cluster of rtpengine instances that share a Redis database, all servers keep an up to date copy of the the call data structure for all calls, and when a non-owner of a call gets a command, they can answer it truthfully and if any new data needs to be generated - it is propagated correctly back to the owner so the owner can handle RTP streams with full knowledge of what answers where provided by alternates.
There are still things that can be improved: even after 14abc07 there are some problems with payload descriptor encoding/decoding; I want to rebuild the JSON structure so it is hierarchical like the actual call structure and use numeric encoding for numbers instead of a set of string arrays; a couple of places where I had to copy code from call.c can be refactored into reusable functions.
But that being said, I believe this feature is ready to merge (after I fix the conflicts)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,19,https://github.com/sipwise/rtpengine/pull/892#issuecomment-590394947,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.",Well this has grown into a rather large PR. Are you able to refactor/squash/rebase this into commits that are easier to review?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,20,https://github.com/sipwise/rtpengine/pull/892#issuecomment-600641093,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Sorry for the late reply - I was sick at home for a couple of weeks and then covid19 happened :-/
I'll rebase the commits for something more manageable in the next few days.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,21,https://github.com/sipwise/rtpengine/pull/892#issuecomment-600753470,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Also, @rfuchs , we encountered another edge case that breaks this work, that I would appreciate your feedback on:
Looking at call_interfaces.c:975 - this gets triggered if we get a new offer command for an existing call. From the comments it looks like this behavior is related to the Redis-based clustering code (the original multi-database hard-coded configuration mode) and is about some kind of recovery from a networking failure between the SIP entity and RTPEngine. In our use case this gets triggered when the SIP entity is handling a media re-INVITE - it starts a new media negotiation on the same call ID.
This is obviously not what the original code was intended to handle, but I've added some code in the last commit to have other servers honor an RTPEngine that ""takes ownership"" of a call like that.
My question is - shouldn't we do this always (why only in cluster mode)? If a new offer is received for an existing call, why not always destroy the old call and start a new call?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/rfuchs,22,https://github.com/sipwise/rtpengine/pull/892#issuecomment-600780407,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","Well, no, because rtpengine keeps call state intact across re-invites, and handles changes in the media descriptions gracefully (or at least attempts to). This is things like local ports allocated, packet counters, protocols used, codecs, crypto info, etc etc.
I can't really comment on this particular code (nor anything else from the active/active mechanism) as it's been contributed by @smititelu and @inf265 and so I don't know why in this case the call is destroyed and re-created.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,23,https://github.com/sipwise/rtpengine/pull/892#issuecomment-601195736,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","In that case, I believe the correct approach would be to remove the code that has special handling of ""offer for a known foreign call"" added by @lbalaceanu - with the code in this PR, the reasoning in the comment is no longer needed: the ""fallback server"" will just return the same reply the original server sent and there is no loss of data and no need to restart anything.
I'm going to do that and run some tests before pushing the change here.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/lbalaceanu,24,https://github.com/sipwise/rtpengine/pull/892#issuecomment-642005195,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","This is obviously not what the original code was intended to handle, but I've added some code in the last commit to have other servers honor an RTPEngine that ""takes ownership"" of a call like that.

Hi @guss77 , @rfuchs ,
I haven't been able to browse through the actual commits proposed by this pull request, but as far as I remember the original code you mention is related to this scenario: the primary rtpengine (owner) receives an offer from a SIP proxy, but its response doesn't reach this proxy in time. The proxy then sends the same offer to another rtpengine (alternate). Obviously there must be a way to re-conciliate the 2 rtpengines.
The code in the original Redis fixed keyspace setup might seem at times cumbersome, but this is because over time it got tested and repaired and obviously different corner cases have been addressed. I consider that this progress should be kept and new features come as extensions  or additions to working code.
Thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,892,2019-12-11T13:35:10Z,,2020-07-01T15:24:25Z,OPEN,False,1865,115,20,https://github.com/guss77,Support zero-knowledge scaling of RTPEngine,51,[],https://github.com/sipwise/rtpengine/pull/892,https://github.com/guss77,25,https://github.com/sipwise/rtpengine/pull/892#issuecomment-652484976,"The current model for creating RTPEngine clusters, as documented in the Redis keyspace notification wiki page, require a static configuration where the exact topology of the cluster is fully known ahead of time, and a Redis keyspace is allocated for each cluster member.
Here we introduce a new way to handle RTPEngine clusters that allows a cluster to scale out and in automatically without pre-configuring each cluster member with all the known addresses of all other members. This configuration supports a completely stateless message distribution (for example as that offered by a layer 3 network load balancer) by remembering the network identity of a call owner in the Redis-distributed data structure and allowing a node that receives a command for a session created by another node to answer with the owner's network identity without knowing it ahead of time.
This patch, though minimal, is probably a bit too hackish - and is not configurable at all - so it is presented here as a basis for discussion. Please let me know what you think.","The code in the original Redis fixed keyspace setup might seem at times cumbersome, but this is because over time it got tested and repaired and obviously different corner cases have been addressed. I consider that this progress should be kept and new features come as extensions or additions to working code.

Hi @lbalaceanu - sorry it took me so long to respond. I've been dealing with other things that took attention away from this project.
Regarding your comments, to the best of my knowledge an ability, all the new behavior I introduced up till now isn't supposed to change the original behavior - though this is based only on my reading of the code and guesses as to the intent of the original author, as the system architecture for which the ""Redis fixed keyspace setup"" was built is not documented anywhere and I have no way to actually test that the original behavior is intact.
I would love to be able to re-produce such a set up to allow me to test such assumptions. Are you the original author and/or have a relevant setup that we can discuss?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,893,2019-12-11T21:36:19Z,2019-12-13T14:16:11Z,2019-12-13T14:16:11Z,MERGED,True,1,1,1,https://github.com/sduthil,make clean: test files are not cleaned,1,[],https://github.com/sipwise/rtpengine/pull/893,https://github.com/sduthil,1,https://github.com/sipwise/rtpengine/pull/893,"Why:

When running make clean, the following files are not cleaned:

daemon/dtmf_rx_fillin-test.c
daemon/dtmf_rx_fillin-test
daemon/fix_frame_channel_layout-test.c
daemon/fix_frame_channel_layout-test
...","Why:

When running make clean, the following files are not cleaned:

daemon/dtmf_rx_fillin-test.c
daemon/dtmf_rx_fillin-test
daemon/fix_frame_channel_layout-test.c
daemon/fix_frame_channel_layout-test
...",True,{'THUMBS_UP': ['https://github.com/fblackburn1']}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,893,2019-12-11T21:36:19Z,2019-12-13T14:16:11Z,2019-12-13T14:16:11Z,MERGED,True,1,1,1,https://github.com/sduthil,make clean: test files are not cleaned,1,[],https://github.com/sipwise/rtpengine/pull/893,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/893#issuecomment-565041509,"Why:

When running make clean, the following files are not cleaned:

daemon/dtmf_rx_fillin-test.c
daemon/dtmf_rx_fillin-test
daemon/fix_frame_channel_layout-test.c
daemon/fix_frame_channel_layout-test
...",I'm not seeing any leftover files in the current master branch. Is this on some other branch?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,893,2019-12-11T21:36:19Z,2019-12-13T14:16:11Z,2019-12-13T14:16:11Z,MERGED,True,1,1,1,https://github.com/sduthil,make clean: test files are not cleaned,1,[],https://github.com/sipwise/rtpengine/pull/893,https://github.com/sduthil,3,https://github.com/sipwise/rtpengine/pull/893#issuecomment-565137625,"Why:

When running make clean, the following files are not cleaned:

daemon/dtmf_rx_fillin-test.c
daemon/dtmf_rx_fillin-test
daemon/fix_frame_channel_layout-test.c
daemon/fix_frame_channel_layout-test
...","Yes, it happens on master, with Debian 10 Buster:
docker run -it debian:buster bash -c ""\
apt update ; \
apt install -y git devscripts ; \
git clone https://github.com/sipwise/rtpengine ; \
cd rtpengine ; \
sed -i '/libbcg729-dev/d' debian/control ; \
mk-build-deps --install --remove --tool='env DEBIAN_FRONTEND=noninteractive apt-get --no-install-recommends --yes' debian/control ; \
make clean ; \
ls -l daemon/dtmf_rx_fillin-test* \
""

gives at the end:
root@e8f76666c136:/rtpengine# ls -l daemon/dtmf_rx_fillin-test*
-rwxr-xr-x 1 root root 19464 Dec 12 18:51 daemon/dtmf_rx_fillin-test
lrwxrwxrwx 1 root root    28 Dec 12 18:51 daemon/dtmf_rx_fillin-test.c -> ../lib/dtmf_rx_fillin-test.c",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,895,2019-12-14T01:50:04Z,2019-12-14T13:52:27Z,2019-12-14T13:52:28Z,CLOSED,False,4344,84,29,https://github.com/benlai2018,RT-985 Fix issue if period of silence is longer than 5 seconds,58,[],https://github.com/sipwise/rtpengine/pull/895,https://github.com/benlai2018,1,https://github.com/sipwise/rtpengine/pull/895,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,895,2019-12-14T01:50:04Z,2019-12-14T13:52:27Z,2019-12-14T13:52:28Z,CLOSED,False,4344,84,29,https://github.com/benlai2018,RT-985 Fix issue if period of silence is longer than 5 seconds,58,[],https://github.com/sipwise/rtpengine/pull/895,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/895#issuecomment-565719152,,Way too large of a PR with all kinds of unrelated changes and no description provided.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,896,2019-12-14T01:52:01Z,2019-12-14T13:52:20Z,2019-12-14T13:52:21Z,CLOSED,False,4192,55,27,https://github.com/benlai2018,RT-985 fix silence insertion issue longer than 5 seconds,54,[],https://github.com/sipwise/rtpengine/pull/896,https://github.com/benlai2018,1,https://github.com/sipwise/rtpengine/pull/896,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,896,2019-12-14T01:52:01Z,2019-12-14T13:52:20Z,2019-12-14T13:52:21Z,CLOSED,False,4192,55,27,https://github.com/benlai2018,RT-985 fix silence insertion issue longer than 5 seconds,54,[],https://github.com/sipwise/rtpengine/pull/896,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/896#issuecomment-565719146,,Way too large of a PR with all kinds of unrelated changes and no description provided.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,904,2020-01-08T15:08:14Z,2020-01-08T15:13:16Z,2020-01-08T15:13:16Z,MERGED,True,1,0,1,https://github.com/SipSeb,debian/control: add libconfig-tiny-perl dependency,1,[],https://github.com/sipwise/rtpengine/pull/904,https://github.com/SipSeb,1,https://github.com/sipwise/rtpengine/pull/904,"rtpengine-ctl uses Config::Tiny for reading the config file.
This commit adds the dependency to the utils package.
Change-Id: Iae0892fe9c8d30435eecc513cf538122b2fbe2c7","rtpengine-ctl uses Config::Tiny for reading the config file.
This commit adds the dependency to the utils package.
Change-Id: Iae0892fe9c8d30435eecc513cf538122b2fbe2c7",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,909,2020-01-15T09:05:39Z,2020-01-15T15:55:38Z,2020-01-15T15:55:38Z,MERGED,True,11,1,1,https://github.com/miconda,use pkg-config to detect xtables library for iptables-extension,1,[],https://github.com/sipwise/rtpengine/pull/909,https://github.com/miconda,1,https://github.com/sipwise/rtpengine/pull/909,"In some OSes (e.g, Suse), the xtables library installs the headers in custom path and the current Makefile fails to find it. The patch doesn't try to detect if pkg-config is installed, because it is listed as a build dependency, but can be added if wanted.","In some OSes (e.g, Suse), the xtables library installs the headers in custom path and the current Makefile fails to find it. The patch doesn't try to detect if pkg-config is installed, because it is listed as a build dependency, but can be added if wanted.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,918,2020-01-30T03:37:59Z,2020-04-22T19:28:19Z,2020-04-23T00:55:02Z,CLOSED,False,12,3,3,https://github.com/timgws,Improve used SSL ciphers,2,[],https://github.com/sipwise/rtpengine/pull/918,https://github.com/timgws,1,https://github.com/sipwise/rtpengine/pull/918,"Remove a number of SSLv3 ciphers, increase the key size generated by RSA_generate_key_ex (fixes some issues with Chrome WebRTC)
The following items (highlighted in red) shows the ciphers that are disabled with this change.
--- included-current.txt	2020-01-30 14:34:39.000000000 +1100
+++ included-new.txt	2020-01-30 14:34:45.000000000 +1100
@@ -14,7 +14,6 @@
 DHE-RSA-CAMELLIA256-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA256
 DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
 GOST2001-GOST89-GOST89  SSLv3 Kx=GOST     Au=GOST01 Enc=GOST-28178-89-CNT Mac=GOST89IMIT
-AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
 AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
 AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
 AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
@@ -31,14 +30,8 @@
 DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
 DHE-RSA-CAMELLIA128-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA256
 DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
-AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
 AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
 AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
 AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
 CAMELLIA128-SHA256      TLSv1.2 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA256
 CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1
-ECDHE-RSA-DES-CBC3-SHA  SSLv3 Kx=ECDH     Au=RSA  Enc=3DES(168) Mac=SHA1
-ECDHE-ECDSA-DES-CBC3-SHA SSLv3 Kx=ECDH     Au=ECDSA Enc=3DES(168) Mac=SHA1
-EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
-AECDH-DES-CBC3-SHA      SSLv3 Kx=ECDH     Au=None Enc=3DES(168) Mac=SHA1
-DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1","Remove a number of SSLv3 ciphers, increase the key size generated by RSA_generate_key_ex (fixes some issues with Chrome WebRTC)
The following items (highlighted in red) shows the ciphers that are disabled with this change.
--- included-current.txt	2020-01-30 14:34:39.000000000 +1100
+++ included-new.txt	2020-01-30 14:34:45.000000000 +1100
@@ -14,7 +14,6 @@
 DHE-RSA-CAMELLIA256-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA256
 DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
 GOST2001-GOST89-GOST89  SSLv3 Kx=GOST     Au=GOST01 Enc=GOST-28178-89-CNT Mac=GOST89IMIT
-AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
 AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
 AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
 AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
@@ -31,14 +30,8 @@
 DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
 DHE-RSA-CAMELLIA128-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA256
 DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
-AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
 AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
 AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
 AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
 CAMELLIA128-SHA256      TLSv1.2 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA256
 CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1
-ECDHE-RSA-DES-CBC3-SHA  SSLv3 Kx=ECDH     Au=RSA  Enc=3DES(168) Mac=SHA1
-ECDHE-ECDSA-DES-CBC3-SHA SSLv3 Kx=ECDH     Au=ECDSA Enc=3DES(168) Mac=SHA1
-EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
-AECDH-DES-CBC3-SHA      SSLv3 Kx=ECDH     Au=None Enc=3DES(168) Mac=SHA1
-DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,918,2020-01-30T03:37:59Z,2020-04-22T19:28:19Z,2020-04-23T00:55:02Z,CLOSED,False,12,3,3,https://github.com/timgws,Improve used SSL ciphers,2,[],https://github.com/sipwise/rtpengine/pull/918,https://github.com/timgws,2,https://github.com/sipwise/rtpengine/pull/918#issuecomment-580071135,"Remove a number of SSLv3 ciphers, increase the key size generated by RSA_generate_key_ex (fixes some issues with Chrome WebRTC)
The following items (highlighted in red) shows the ciphers that are disabled with this change.
--- included-current.txt	2020-01-30 14:34:39.000000000 +1100
+++ included-new.txt	2020-01-30 14:34:45.000000000 +1100
@@ -14,7 +14,6 @@
 DHE-RSA-CAMELLIA256-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA256
 DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
 GOST2001-GOST89-GOST89  SSLv3 Kx=GOST     Au=GOST01 Enc=GOST-28178-89-CNT Mac=GOST89IMIT
-AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
 AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
 AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
 AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
@@ -31,14 +30,8 @@
 DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
 DHE-RSA-CAMELLIA128-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA256
 DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
-AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
 AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
 AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
 AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
 CAMELLIA128-SHA256      TLSv1.2 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA256
 CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1
-ECDHE-RSA-DES-CBC3-SHA  SSLv3 Kx=ECDH     Au=RSA  Enc=3DES(168) Mac=SHA1
-ECDHE-ECDSA-DES-CBC3-SHA SSLv3 Kx=ECDH     Au=ECDSA Enc=3DES(168) Mac=SHA1
-EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
-AECDH-DES-CBC3-SHA      SSLv3 Kx=ECDH     Au=None Enc=3DES(168) Mac=SHA1
-DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1","Reasons for removing these ciphers can be found at https://ciphersuite.info/
For example, with AECDH-AES128-SHA (TLS_ECDH_anon_WITH_AES_128_CBC_SHA) it is easily able to be used with to cause a Man in the Middle attack in some environments*",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,918,2020-01-30T03:37:59Z,2020-04-22T19:28:19Z,2020-04-23T00:55:02Z,CLOSED,False,12,3,3,https://github.com/timgws,Improve used SSL ciphers,2,[],https://github.com/sipwise/rtpengine/pull/918,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/918#issuecomment-580335942,"Remove a number of SSLv3 ciphers, increase the key size generated by RSA_generate_key_ex (fixes some issues with Chrome WebRTC)
The following items (highlighted in red) shows the ciphers that are disabled with this change.
--- included-current.txt	2020-01-30 14:34:39.000000000 +1100
+++ included-new.txt	2020-01-30 14:34:45.000000000 +1100
@@ -14,7 +14,6 @@
 DHE-RSA-CAMELLIA256-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA256
 DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
 GOST2001-GOST89-GOST89  SSLv3 Kx=GOST     Au=GOST01 Enc=GOST-28178-89-CNT Mac=GOST89IMIT
-AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
 AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
 AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
 AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
@@ -31,14 +30,8 @@
 DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
 DHE-RSA-CAMELLIA128-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA256
 DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
-AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
 AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
 AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
 AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
 CAMELLIA128-SHA256      TLSv1.2 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA256
 CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1
-ECDHE-RSA-DES-CBC3-SHA  SSLv3 Kx=ECDH     Au=RSA  Enc=3DES(168) Mac=SHA1
-ECDHE-ECDSA-DES-CBC3-SHA SSLv3 Kx=ECDH     Au=ECDSA Enc=3DES(168) Mac=SHA1
-EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
-AECDH-DES-CBC3-SHA      SSLv3 Kx=ECDH     Au=None Enc=3DES(168) Mac=SHA1
-DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1",Do you know if this is in line with other DTLS-SRTP/WebRTC implementations? I don't want to break interoperability. Perhaps this should be made configurable.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,918,2020-01-30T03:37:59Z,2020-04-22T19:28:19Z,2020-04-23T00:55:02Z,CLOSED,False,12,3,3,https://github.com/timgws,Improve used SSL ciphers,2,[],https://github.com/sipwise/rtpengine/pull/918,https://github.com/timgws,4,https://github.com/sipwise/rtpengine/pull/918#issuecomment-580507332,"Remove a number of SSLv3 ciphers, increase the key size generated by RSA_generate_key_ex (fixes some issues with Chrome WebRTC)
The following items (highlighted in red) shows the ciphers that are disabled with this change.
--- included-current.txt	2020-01-30 14:34:39.000000000 +1100
+++ included-new.txt	2020-01-30 14:34:45.000000000 +1100
@@ -14,7 +14,6 @@
 DHE-RSA-CAMELLIA256-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA256
 DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
 GOST2001-GOST89-GOST89  SSLv3 Kx=GOST     Au=GOST01 Enc=GOST-28178-89-CNT Mac=GOST89IMIT
-AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
 AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
 AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
 AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
@@ -31,14 +30,8 @@
 DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
 DHE-RSA-CAMELLIA128-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA256
 DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
-AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
 AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
 AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
 AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
 CAMELLIA128-SHA256      TLSv1.2 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA256
 CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1
-ECDHE-RSA-DES-CBC3-SHA  SSLv3 Kx=ECDH     Au=RSA  Enc=3DES(168) Mac=SHA1
-ECDHE-ECDSA-DES-CBC3-SHA SSLv3 Kx=ECDH     Au=ECDSA Enc=3DES(168) Mac=SHA1
-EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
-AECDH-DES-CBC3-SHA      SSLv3 Kx=ECDH     Au=None Enc=3DES(168) Mac=SHA1
-DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1","Do you know if this is in line with other DTLS-SRTP/WebRTC implementations?

I honestly have no idea, it would be amazing to have both of these parameters be configurable.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,918,2020-01-30T03:37:59Z,2020-04-22T19:28:19Z,2020-04-23T00:55:02Z,CLOSED,False,12,3,3,https://github.com/timgws,Improve used SSL ciphers,2,[],https://github.com/sipwise/rtpengine/pull/918,https://github.com/timgws,5,https://github.com/sipwise/rtpengine/pull/918#issuecomment-618114653,"Remove a number of SSLv3 ciphers, increase the key size generated by RSA_generate_key_ex (fixes some issues with Chrome WebRTC)
The following items (highlighted in red) shows the ciphers that are disabled with this change.
--- included-current.txt	2020-01-30 14:34:39.000000000 +1100
+++ included-new.txt	2020-01-30 14:34:45.000000000 +1100
@@ -14,7 +14,6 @@
 DHE-RSA-CAMELLIA256-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA256
 DHE-RSA-CAMELLIA256-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(256) Mac=SHA1
 GOST2001-GOST89-GOST89  SSLv3 Kx=GOST     Au=GOST01 Enc=GOST-28178-89-CNT Mac=GOST89IMIT
-AECDH-AES256-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(256)  Mac=SHA1
 AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD
 AES256-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA256
 AES256-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(256)  Mac=SHA1
@@ -31,14 +30,8 @@
 DHE-RSA-AES128-SHA      SSLv3 Kx=DH       Au=RSA  Enc=AES(128)  Mac=SHA1
 DHE-RSA-CAMELLIA128-SHA256 TLSv1.2 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA256
 DHE-RSA-CAMELLIA128-SHA SSLv3 Kx=DH       Au=RSA  Enc=Camellia(128) Mac=SHA1
-AECDH-AES128-SHA        SSLv3 Kx=ECDH     Au=None Enc=AES(128)  Mac=SHA1
 AES128-GCM-SHA256       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(128) Mac=AEAD
 AES128-SHA256           TLSv1.2 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA256
 AES128-SHA              SSLv3 Kx=RSA      Au=RSA  Enc=AES(128)  Mac=SHA1
 CAMELLIA128-SHA256      TLSv1.2 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA256
 CAMELLIA128-SHA         SSLv3 Kx=RSA      Au=RSA  Enc=Camellia(128) Mac=SHA1
-ECDHE-RSA-DES-CBC3-SHA  SSLv3 Kx=ECDH     Au=RSA  Enc=3DES(168) Mac=SHA1
-ECDHE-ECDSA-DES-CBC3-SHA SSLv3 Kx=ECDH     Au=ECDSA Enc=3DES(168) Mac=SHA1
-EDH-RSA-DES-CBC3-SHA    SSLv3 Kx=DH       Au=RSA  Enc=3DES(168) Mac=SHA1
-AECDH-DES-CBC3-SHA      SSLv3 Kx=ECDH     Au=None Enc=3DES(168) Mac=SHA1
-DES-CBC3-SHA            SSLv3 Kx=RSA      Au=RSA  Enc=3DES(168) Mac=SHA1","Thanks so much for this, @rfuchs!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,921,2020-02-03T15:48:59Z,2020-02-03T16:43:58Z,2020-02-03T16:43:58Z,MERGED,True,1,1,1,https://github.com/smititelu,Fix crash when redis disconnects/reconnects,1,[],https://github.com/sipwise/rtpengine/pull/921,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/921,"Steps to reproduce:

start rtpengine with redis support
stop the redis server
start the redis server => wait for rtpengine to reconnect => crash

From [1] I've found out that:

""The asynchronous context can hold a disconnect callback function that is called when the connection is disconnected (either because of an error or per user request)""
""The context object is always freed after the disconnect callback fired.""

So I think there is no point in calling redisAsyncDisconnect() on redis reconnect; this will lead to the crash.
[1] https://github.com/redis/hiredis","Steps to reproduce:

start rtpengine with redis support
stop the redis server
start the redis server => wait for rtpengine to reconnect => crash

From [1] I've found out that:

""The asynchronous context can hold a disconnect callback function that is called when the connection is disconnected (either because of an error or per user request)""
""The context object is always freed after the disconnect callback fired.""

So I think there is no point in calling redisAsyncDisconnect() on redis reconnect; this will lead to the crash.
[1] https://github.com/redis/hiredis",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,921,2020-02-03T15:48:59Z,2020-02-03T16:43:58Z,2020-02-03T16:43:58Z,MERGED,True,1,1,1,https://github.com/smititelu,Fix crash when redis disconnects/reconnects,1,[],https://github.com/sipwise/rtpengine/pull/921,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/921#issuecomment-581482596,"Steps to reproduce:

start rtpengine with redis support
stop the redis server
start the redis server => wait for rtpengine to reconnect => crash

From [1] I've found out that:

""The asynchronous context can hold a disconnect callback function that is called when the connection is disconnected (either because of an error or per user request)""
""The context object is always freed after the disconnect callback fired.""

So I think there is no point in calling redisAsyncDisconnect() on redis reconnect; this will lead to the crash.
[1] https://github.com/redis/hiredis",I assume this would fix #919 ?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,921,2020-02-03T15:48:59Z,2020-02-03T16:43:58Z,2020-02-03T16:43:58Z,MERGED,True,1,1,1,https://github.com/smititelu,Fix crash when redis disconnects/reconnects,1,[],https://github.com/sipwise/rtpengine/pull/921,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/921#issuecomment-581487069,"Steps to reproduce:

start rtpengine with redis support
stop the redis server
start the redis server => wait for rtpengine to reconnect => crash

From [1] I've found out that:

""The asynchronous context can hold a disconnect callback function that is called when the connection is disconnected (either because of an error or per user request)""
""The context object is always freed after the disconnect callback fired.""

So I think there is no point in calling redisAsyncDisconnect() on redis reconnect; this will lead to the crash.
[1] https://github.com/redis/hiredis","I'm not using a haproxy configuration scenario, and my gdb trace looks a bit different:
(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007fd2bde4b535 in __GI_abort () at abort.c:79
#2  0x00007fd2bdea2508 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7fd2bdfad28d ""%s\n"") at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007fd2bdea8c1a in malloc_printerr (str=str@entry=0x7fd2bdfab43b ""free(): invalid pointer"") at malloc.c:5341
#4  0x00007fd2bdeaa42c in _int_free (av=, p=, have_lock=) at malloc.c:4165
#5  0x00007fd2be30a9f8 in __redisGetSubscribeCallback (dstcb=0x7fd2bb536820, reply=0x7fd29c005470, ac=0x7fd2bb537700) at async.c:479
#6  redisProcessCallbacks (ac=0x7fd2bb537700) at async.c:479
#7  0x000055a1af82160c in redis_disconnect () at redis.c:622
#8  redis_notify_loop (d=) at redis.c:622
#9  0x000055a1af813592 in thread_detach_func (d=0x55a1afddc3a0) at aux.c:207
#10 0x00007fd2bdff3fa3 in start_thread (arg=) at pthread_create.c:486
#11 0x00007fd2bdf224cf in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
However, he can give it a try since I see it's about a lost connection and re-connection.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,923,2020-02-04T14:51:38Z,2020-02-04T15:00:16Z,2020-02-04T15:43:46Z,MERGED,True,2,0,1,https://github.com/boettner,Update rtpengine-ctl,1,[],https://github.com/sipwise/rtpengine/pull/923,https://github.com/boettner,1,https://github.com/sipwise/rtpengine/pull/923,"The offer-timeout option is not listed in rtpengine-ctl -h, but is already implemented. Maybe one forgot to mention this in the help output? 🤔","The offer-timeout option is not listed in rtpengine-ctl -h, but is already implemented. Maybe one forgot to mention this in the help output? 🤔",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,926,2020-02-09T17:58:55Z,2020-02-12T17:32:35Z,2020-02-12T17:32:35Z,CLOSED,False,34,48,4,https://github.com/balajeesv,Jitter buffer Changes,9,[],https://github.com/sipwise/rtpengine/pull/926,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/926,"The following changes are made in this PR.

Jitter_buffer free through timerthread_obj
jitter_buffer.c:91 - Corrected wrong str object passed to rtp_payload
Clock drift handling made simpler, Now for every 20, 40, 80, 160, 320 ... packets clock drift corrected if enabled in config
Removed buffering first packet. The first packet Immediately sent without buffering.","The following changes are made in this PR.

Jitter_buffer free through timerthread_obj
jitter_buffer.c:91 - Corrected wrong str object passed to rtp_payload
Clock drift handling made simpler, Now for every 20, 40, 80, 160, 320 ... packets clock drift corrected if enabled in config
Removed buffering first packet. The first packet Immediately sent without buffering.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,926,2020-02-09T17:58:55Z,2020-02-12T17:32:35Z,2020-02-12T17:32:35Z,CLOSED,False,34,48,4,https://github.com/balajeesv,Jitter buffer Changes,9,[],https://github.com/sipwise/rtpengine/pull/926,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/926#issuecomment-584288016,"The following changes are made in this PR.

Jitter_buffer free through timerthread_obj
jitter_buffer.c:91 - Corrected wrong str object passed to rtp_payload
Clock drift handling made simpler, Now for every 20, 40, 80, 160, 320 ... packets clock drift corrected if enabled in config
Removed buffering first packet. The first packet Immediately sent without buffering.",This is ready to be merged?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,926,2020-02-09T17:58:55Z,2020-02-12T17:32:35Z,2020-02-12T17:32:35Z,CLOSED,False,34,48,4,https://github.com/balajeesv,Jitter buffer Changes,9,[],https://github.com/sipwise/rtpengine/pull/926,https://github.com/balajeesv,3,https://github.com/sipwise/rtpengine/pull/926#issuecomment-585319066,"The following changes are made in this PR.

Jitter_buffer free through timerthread_obj
jitter_buffer.c:91 - Corrected wrong str object passed to rtp_payload
Clock drift handling made simpler, Now for every 20, 40, 80, 160, 320 ... packets clock drift corrected if enabled in config
Removed buffering first packet. The first packet Immediately sent without buffering.","@rfuchs Yes, this can be merged. I ran a few basic tests and looks good.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,940,2020-02-21T17:45:28Z,2020-02-26T19:58:15Z,2020-02-26T19:58:15Z,MERGED,True,39,19,2,https://github.com/balajeesv,jb ssrc and timestamp change handling,1,[],https://github.com/sipwise/rtpengine/pull/940,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/940,"The following are fixed in this PR.

SSRC change
Timestamp Change
RTCP no buffering
DTMF handling","The following are fixed in this PR.

SSRC change
Timestamp Change
RTCP no buffering
DTMF handling",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,965,2020-04-12T12:22:59Z,2020-04-13T13:12:28Z,2020-04-13T13:12:28Z,MERGED,True,9,3,2,https://github.com/balajeesv,jitter buffer correction,1,[],https://github.com/sipwise/rtpengine/pull/965,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/965,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,988,2020-05-10T14:03:09Z,2020-05-19T13:12:07Z,2020-05-19T13:12:53Z,MERGED,True,130,50,4,https://github.com/balajeesv,Jb improvements,7,[],https://github.com/sipwise/rtpengine/pull/988,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/988,"JB correction on RTP Marker bit
Sequence wrap handling
Flush jitter buffer on reset
Ensure correct ordering of sequence
Comfort noise handling
Clock drift handling improvements","JB correction on RTP Marker bit
Sequence wrap handling
Flush jitter buffer on reset
Ensure correct ordering of sequence
Comfort noise handling
Clock drift handling improvements",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,988,2020-05-10T14:03:09Z,2020-05-19T13:12:07Z,2020-05-19T13:12:53Z,MERGED,True,130,50,4,https://github.com/balajeesv,Jb improvements,7,[],https://github.com/sipwise/rtpengine/pull/988,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/988#issuecomment-630808102,"JB correction on RTP Marker bit
Sequence wrap handling
Flush jitter buffer on reset
Ensure correct ordering of sequence
Comfort noise handling
Clock drift handling improvements","For future pull requests, it would be appreciated if each commit had a more descriptive messages attached, detailing what it achieved, and also not ""root"" as author. Thank you.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,989,2020-05-11T22:11:22Z,2020-05-19T13:16:00Z,2020-05-19T13:16:00Z,MERGED,True,139,0,1,https://github.com/attermann,Added new CLI command for parseable stats,2,[],https://github.com/sipwise/rtpengine/pull/989,https://github.com/attermann,1,https://github.com/sipwise/rtpengine/pull/989,"Added support for ""list jsonstats"" CLI command that returns stats in easily parseable json format.","Added support for ""list jsonstats"" CLI command that returns stats in easily parseable json format.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,994,2020-05-22T09:33:04Z,2020-05-22T11:23:17Z,2020-05-22T11:26:22Z,MERGED,True,1,0,1,https://github.com/micmac1,kernel-module: fix implicit function declaration,1,[],https://github.com/sipwise/rtpengine/pull/994,https://github.com/micmac1,1,https://github.com/sipwise/rtpengine/pull/994,"Hi all,
We added rtpengine to OpenWrt here, after users requested it on the forum.
We don't really have many patches for rtpengine. The ones we do have are mostly not relevant for rtpengine upstream. But maybe this missing header patch is?
Kind regards,
Seb
This commit adds a header to the mix to prevent the following compile
error:
make[3]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module'
make -C /home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122 M=/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module O=/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122 modules
make[4]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122'
make[5]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122'
CC [M]  /home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.o
/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.c: In function 'send_proxy_packet6':
/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.c:3387:14: error: implicit declaration of function 'csum_ipv6_magic'; did you mean 'csum_tcpudp_magic'? [-Werror=implicit-function-declaration]
uh->check = csum_ipv6_magic(&ih->saddr, &ih->daddr, datalen, IPPROTO_UDP, csum_partial(uh, datalen, 0));
^~~~~~~~~~~~~~~
csum_tcpudp_magic
cc1: some warnings being treated as errors
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net","Hi all,
We added rtpengine to OpenWrt here, after users requested it on the forum.
We don't really have many patches for rtpengine. The ones we do have are mostly not relevant for rtpengine upstream. But maybe this missing header patch is?
Kind regards,
Seb
This commit adds a header to the mix to prevent the following compile
error:
make[3]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module'
make -C /home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122 M=/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module O=/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122 modules
make[4]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122'
make[5]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122'
CC [M]  /home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.o
/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.c: In function 'send_proxy_packet6':
/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.c:3387:14: error: implicit declaration of function 'csum_ipv6_magic'; did you mean 'csum_tcpudp_magic'? [-Werror=implicit-function-declaration]
uh->check = csum_ipv6_magic(&ih->saddr, &ih->daddr, datalen, IPPROTO_UDP, csum_partial(uh, datalen, 0));
^~~~~~~~~~~~~~~
csum_tcpudp_magic
cc1: some warnings being treated as errors
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,994,2020-05-22T09:33:04Z,2020-05-22T11:23:17Z,2020-05-22T11:26:22Z,MERGED,True,1,0,1,https://github.com/micmac1,kernel-module: fix implicit function declaration,1,[],https://github.com/sipwise/rtpengine/pull/994,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/994#issuecomment-632642978,"Hi all,
We added rtpengine to OpenWrt here, after users requested it on the forum.
We don't really have many patches for rtpengine. The ones we do have are mostly not relevant for rtpengine upstream. But maybe this missing header patch is?
Kind regards,
Seb
This commit adds a header to the mix to prevent the following compile
error:
make[3]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module'
make -C /home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122 M=/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module O=/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122 modules
make[4]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122'
make[5]: Entering directory '/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/linux-4.19.122'
CC [M]  /home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.o
/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.c: In function 'send_proxy_packet6':
/home/sk/tmp/openwrt/build_dir/target-mips_24kc_musl/linux-ath79_generic/rtpengine-no-transcode/rtpengine-mr8.3.1.4/kernel-module/xt_RTPENGINE.c:3387:14: error: implicit declaration of function 'csum_ipv6_magic'; did you mean 'csum_tcpudp_magic'? [-Werror=implicit-function-declaration]
uh->check = csum_ipv6_magic(&ih->saddr, &ih->daddr, datalen, IPPROTO_UDP, csum_partial(uh, datalen, 0));
^~~~~~~~~~~~~~~
csum_tcpudp_magic
cc1: some warnings being treated as errors
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net",If you have more patches that are or can be made conditional on the OpenWRT environment then I'd be happy to merge them in.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,997,2020-05-26T15:15:12Z,2020-05-28T14:49:02Z,2020-05-28T14:49:03Z,MERGED,True,41,1,5,https://github.com/smititelu,Add drop-traffic start and stop flags,1,[],https://github.com/sipwise/rtpengine/pull/997,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/997,"Useful when someone needs to:

completely drop early media, but stop dropping after call is answered.
completely drop initial invite media, but stop dropping after re-invite

Tested by toggling re-INVITES and checking that audio was or was not heard.","Useful when someone needs to:

completely drop early media, but stop dropping after call is answered.
completely drop initial invite media, but stop dropping after re-invite

Tested by toggling re-INVITES and checking that audio was or was not heard.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,997,2020-05-26T15:15:12Z,2020-05-28T14:49:02Z,2020-05-28T14:49:03Z,MERGED,True,41,1,5,https://github.com/smititelu,Add drop-traffic start and stop flags,1,[],https://github.com/sipwise/rtpengine/pull/997,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/997#issuecomment-634116496,"Useful when someone needs to:

completely drop early media, but stop dropping after call is answered.
completely drop initial invite media, but stop dropping after re-invite

Tested by toggling re-INVITES and checking that audio was or was not heard.","I think it would make more sense to have this as a dictionary key instead of an entry in the flags, e.g. as drop-traffic=start etc similar to ICE= or DTLS=. What do you think?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,997,2020-05-26T15:15:12Z,2020-05-28T14:49:02Z,2020-05-28T14:49:03Z,MERGED,True,41,1,5,https://github.com/smititelu,Add drop-traffic start and stop flags,1,[],https://github.com/sipwise/rtpengine/pull/997,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/997#issuecomment-634145889,"Useful when someone needs to:

completely drop early media, but stop dropping after call is answered.
completely drop initial invite media, but stop dropping after re-invite

Tested by toggling re-INVITES and checking that audio was or was not heard.","Yes, indeed. I'll update the pull request accordingly.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,997,2020-05-26T15:15:12Z,2020-05-28T14:49:02Z,2020-05-28T14:49:03Z,MERGED,True,41,1,5,https://github.com/smititelu,Add drop-traffic start and stop flags,1,[],https://github.com/sipwise/rtpengine/pull/997,https://github.com/smititelu,4,https://github.com/sipwise/rtpengine/pull/997#issuecomment-635201765,"Useful when someone needs to:

completely drop early media, but stop dropping after call is answered.
completely drop initial invite media, but stop dropping after re-invite

Tested by toggling re-INVITES and checking that audio was or was not heard.",Done. Retested successfully.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,998,2020-05-27T06:56:33Z,2020-05-27T06:57:31Z,2020-05-27T06:57:42Z,CLOSED,False,185,30,14,https://github.com/mika,GH testing,2,[],https://github.com/sipwise/rtpengine/pull/998,https://github.com/mika,1,https://github.com/sipwise/rtpengine/pull/998,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,998,2020-05-27T06:56:33Z,2020-05-27T06:57:31Z,2020-05-27T06:57:42Z,CLOSED,False,185,30,14,https://github.com/mika,GH testing,2,[],https://github.com/sipwise/rtpengine/pull/998,https://github.com/mika,2,https://github.com/sipwise/rtpengine/pull/998#issuecomment-634467799,,"Alright, so GitHub actions doesn't work yet here, sorry4noise.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1010,2020-06-05T22:02:20Z,2020-06-06T05:22:03Z,2020-06-06T05:22:04Z,CLOSED,False,18,4,2,https://github.com/attermann,"Added ""currentstatistics"" to json stats.",2,[],https://github.com/sipwise/rtpengine/pull/1010,https://github.com/attermann,1,https://github.com/sipwise/rtpengine/pull/1010,Added section for current server stats to easily parseable json stats.,Added section for current server stats to easily parseable json stats.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1010,2020-06-05T22:02:20Z,2020-06-06T05:22:03Z,2020-06-06T05:22:04Z,CLOSED,False,18,4,2,https://github.com/attermann,"Added ""currentstatistics"" to json stats.",2,[],https://github.com/sipwise/rtpengine/pull/1010,https://github.com/attermann,2,https://github.com/sipwise/rtpengine/pull/1010#issuecomment-639986675,Added section for current server stats to easily parseable json stats.,Re-submitted each commit as a separate pull.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1011,2020-06-05T22:19:21Z,2020-06-09T16:03:41Z,2020-06-09T16:03:41Z,MERGED,True,2,2,1,https://github.com/attermann,Made hash tables for flags case-insensitive.,1,[],https://github.com/sipwise/rtpengine/pull/1011,https://github.com/attermann,1,https://github.com/sipwise/rtpengine/pull/1011,Made hash tables for flags case-insensitive so that CODEC names in SDP that are not the expected case will still match flags like code-mask-CODEC and codec-strip-CODEC.,Made hash tables for flags case-insensitive so that CODEC names in SDP that are not the expected case will still match flags like code-mask-CODEC and codec-strip-CODEC.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1011,2020-06-05T22:19:21Z,2020-06-09T16:03:41Z,2020-06-09T16:03:41Z,MERGED,True,2,2,1,https://github.com/attermann,Made hash tables for flags case-insensitive.,1,[],https://github.com/sipwise/rtpengine/pull/1011,https://github.com/attermann,2,https://github.com/sipwise/rtpengine/pull/1011#issuecomment-639863448,Made hash tables for flags case-insensitive so that CODEC names in SDP that are not the expected case will still match flags like code-mask-CODEC and codec-strip-CODEC.,Addresses issue #1009.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1012,2020-06-06T05:20:49Z,2020-06-08T13:55:52Z,2020-06-08T13:55:52Z,MERGED,True,16,2,1,https://github.com/attermann,"Added ""currentstatistics"" to json stats.",1,[],https://github.com/sipwise/rtpengine/pull/1012,https://github.com/attermann,1,https://github.com/sipwise/rtpengine/pull/1012,Added section for current server stats to easily parseable json stats.,Added section for current server stats to easily parseable json stats.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1013,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-641311640,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Thanks for this, I've had it on my own to-do list for ages...",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-641389516,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Just a note that I'm currently looking also into the other ""possibly lost"" warnings, trying to fix as many as possible / if possible.
The best would be to solve all and have clean valgrind output. Thus, would make debugging of (new) memory leaks easier.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-641399452,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","The argument/config file handling is incomplete I think. The reason you're getting a warning about trying to free addresses in r-x mapped files is that there are defaults for these strings that are given as string literals and thus aren't allocated. But if a value for these strings were taken from a config file or argv, then they would be allocated.
Also, the 3-times iteration over arguments, then config file, then arguments again, doesn't take duplicates into account. If some values are given in both locations, the pointer would simply be overwritten without the previous value being freed (I think). Something like strdupfree() should probably be used here in some way.
The duplication of the shared arguments is also not nice. There was a reason why it was in a single place in auxlib.c, so I'd prefer to preserve that.
Moving all the option variables out of options() and into global namespace seems like the wrong solution. Those are meant to be temporary and should be freed when options() returns. Those are probably good candidates for auto-cleanup, see AUTO_CLEANUP*() macros, in particular AUTO_CLEANUP_BUF.
Let me know if you want to fiddle with this more, because I can probably address these points myself too.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/smititelu,5,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-641912847,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Thanks for feedback. Yes, I'll fiddle a little more with this.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/smititelu,6,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-642059895,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Force pushed a new commit considering your feedback, in order:


got rid of ""r-w"" warning by allocating the default values with g_strdup(), only if they are NULL after config_load() runs => thus can be always freed using glib g_free() at the end


indeed, i tried running in CLI with a STRING argument present in config also and valgrind reported ""definitely lost"" for it => maybe we remember this issue and address it in another commit ?!


restored the common options in auxlib.c; freed the malloc'ed entries


restored options() with local variables and freed them at the end but using the glib g_free()


At this point there are also 0 ""definitely lost"" reported, while running rtpengine as in first comment.
Let me know what you think of it.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-642151646,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Ok, this looks mostly good to me, and I'm ok with leaving additional cleanups to later commits. The only minor point I have left is that log_mark_prefix and _suffix are part of the ""common"" config and so should receive their default values also in the common/shared code, which is in config_load(). As such, there should probably also be a shared config_free() or similar in auxlib.c that takes care of freeing these strings, that is then called from the local options_free(). (Or perhaps even registered via atexit())
Additional notes that can be addressed later:
The if_a array could be freed immediately without keeping a global reference if if_addr_parse would duplicate the parts of the string that it uses, which I believe is just the interface name. Then the actual cleanup would happen when cleaning up the all_local_interfaces list which incidentally also needs to be taken care of. I'm actually surprised that valgrind isn't complaining about it - are you doing your tests with G_SLICE=always-malloc set?
Some of the many g_free calls could be avoided by declaring the variables with AUTO_CLEANUP_BUF(). Unfortunately this doesn't work for global variables :)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/smititelu,8,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-642574916,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Updated the commit solving the following:

add config_load_free() to free all the common options; call it in options_free() and in config_load() if any errors happen
moved default of log prefix/suffix common options in config_load()
add AUTO_CLEANUP_G/GVBUF and use them in options()

Related to the if_a stuff, yes i also tested with G_SLICE=always-malloc, however no ""definitely lost"" reported. However, there are some ""still reachable"" warnings that may be related to that.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/smititelu,9,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-642634616,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","Just for the record, two TODOs that can be addresed later:


If STRING or STRING LIST param is present in both config file and cli argument valgrind reports ""definitely lost"" for it => in config_load() free the memory for common config file vs cli arguments, after config file was parsed but before argv is parsed second time


Free if_a inside options() and don't use global reference anymore. Solve everything else where if_a is currently used.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/rfuchs,10,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-642635303,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","I'll be working on these points now, thanks",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1013,2020-06-09T08:11:48Z,2020-06-11T12:09:46Z,2020-06-12T13:17:14Z,MERGED,True,167,41,7,https://github.com/smititelu,"Solve Vlagrind ""definitely lost"" memory leaks",1,[],https://github.com/sipwise/rtpengine/pull/1013,https://github.com/rfuchs,11,https://github.com/sipwise/rtpengine/pull/1013#issuecomment-643265454,"run rtpengine under valgrind: sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes --verbose --log-file=valgrind-out1.txt daemon/rtpengine -f -E --no-log-timestamps --pidfile /run/ngcp-rtpengine-daemon.pid --config-file /etc/rtpengine/rtpengine1.conf
wait it to start
Ctrl+c

Vlagrind reports lots of memory warnings. Some of them are ""definitely lost"" (attached file) which are definitely memory leaks.
After this commit, there are 0 ""definitely lost"" warnings that valgrind reports(for the above steps).
valgrind_definitely.txt","JFYI I've pushed some more cleanups to https://github.com/sipwise/rtpengine/tree/rfuchs/cleanup
They're addressing a bunch of the ""still reachable"" allocations",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1015,2020-06-14T08:52:15Z,2020-06-14T12:59:07Z,2020-06-14T12:59:07Z,MERGED,True,1,1,1,https://github.com/balajeesv,trap divide error crash fix,1,[],https://github.com/sipwise/rtpengine/pull/1015,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/1015,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1016,2020-06-15T13:21:35Z,2020-06-17T12:11:50Z,2020-06-17T12:11:50Z,MERGED,True,26,1,5,https://github.com/smititelu,"Solve Valgrind ""possibly lost"" for redis and dtls",1,[],https://github.com/sipwise/rtpengine/pull/1016,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1016,"There is 1 more warning related to this, that I am confused how to solve:
==30466== 64 bytes in 1 blocks are still reachable in loss record 211 of 387
==30466==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30466==    by 0x522BAB8: g_malloc (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x51F95A2: g_async_queue_new_full (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x524EA0C: g_thread_pool_new (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x12DD6F: redis_restore (redis.c:1758)
==30466==    by 0x119D82: create_everything (main.c:868)
==30466==    by 0x119D82: main (main.c:892)

I think it might be related to the glibc since g_thread_pool_free should already do all the job.
I tried creating a small test program only with g_thread_pool_new g_thread_pool_free with empty thread  callback and valgrind still reported the above warning.","There is 1 more warning related to this, that I am confused how to solve:
==30466== 64 bytes in 1 blocks are still reachable in loss record 211 of 387
==30466==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30466==    by 0x522BAB8: g_malloc (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x51F95A2: g_async_queue_new_full (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x524EA0C: g_thread_pool_new (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x12DD6F: redis_restore (redis.c:1758)
==30466==    by 0x119D82: create_everything (main.c:868)
==30466==    by 0x119D82: main (main.c:892)

I think it might be related to the glibc since g_thread_pool_free should already do all the job.
I tried creating a small test program only with g_thread_pool_new g_thread_pool_free with empty thread  callback and valgrind still reported the above warning.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1016,2020-06-15T13:21:35Z,2020-06-17T12:11:50Z,2020-06-17T12:11:50Z,MERGED,True,26,1,5,https://github.com/smititelu,"Solve Valgrind ""possibly lost"" for redis and dtls",1,[],https://github.com/sipwise/rtpengine/pull/1016,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/1016#issuecomment-644132292,"There is 1 more warning related to this, that I am confused how to solve:
==30466== 64 bytes in 1 blocks are still reachable in loss record 211 of 387
==30466==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30466==    by 0x522BAB8: g_malloc (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x51F95A2: g_async_queue_new_full (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x524EA0C: g_thread_pool_new (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x12DD6F: redis_restore (redis.c:1758)
==30466==    by 0x119D82: create_everything (main.c:868)
==30466==    by 0x119D82: main (main.c:892)

I think it might be related to the glibc since g_thread_pool_free should already do all the job.
I tried creating a small test program only with g_thread_pool_new g_thread_pool_free with empty thread  callback and valgrind still reported the above warning.",The test scenario is the same as in #1013,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1016,2020-06-15T13:21:35Z,2020-06-17T12:11:50Z,2020-06-17T12:11:50Z,MERGED,True,26,1,5,https://github.com/smititelu,"Solve Valgrind ""possibly lost"" for redis and dtls",1,[],https://github.com/sipwise/rtpengine/pull/1016,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1016#issuecomment-644148753,"There is 1 more warning related to this, that I am confused how to solve:
==30466== 64 bytes in 1 blocks are still reachable in loss record 211 of 387
==30466==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30466==    by 0x522BAB8: g_malloc (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x51F95A2: g_async_queue_new_full (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x524EA0C: g_thread_pool_new (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x12DD6F: redis_restore (redis.c:1758)
==30466==    by 0x119D82: create_everything (main.c:868)
==30466==    by 0x119D82: main (main.c:892)

I think it might be related to the glibc since g_thread_pool_free should already do all the job.
I tried creating a small test program only with g_thread_pool_new g_thread_pool_free with empty thread  callback and valgrind still reported the above warning.","What you're seeing is probably the unused_thread_queue from https://github.com/GNOME/glib/blob/mainline/glib/gthreadpool.c#L111
It's created when the first thread pool is created: https://github.com/GNOME/glib/blob/mainline/glib/gthreadpool.c#L581
I don't see any code trying to free it ever (should be g_async_queue_unref) so I think this is to be expected.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1016,2020-06-15T13:21:35Z,2020-06-17T12:11:50Z,2020-06-17T12:11:50Z,MERGED,True,26,1,5,https://github.com/smititelu,"Solve Valgrind ""possibly lost"" for redis and dtls",1,[],https://github.com/sipwise/rtpengine/pull/1016,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1016#issuecomment-644161816,"There is 1 more warning related to this, that I am confused how to solve:
==30466== 64 bytes in 1 blocks are still reachable in loss record 211 of 387
==30466==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30466==    by 0x522BAB8: g_malloc (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x51F95A2: g_async_queue_new_full (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x524EA0C: g_thread_pool_new (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x12DD6F: redis_restore (redis.c:1758)
==30466==    by 0x119D82: create_everything (main.c:868)
==30466==    by 0x119D82: main (main.c:892)

I think it might be related to the glibc since g_thread_pool_free should already do all the job.
I tried creating a small test program only with g_thread_pool_new g_thread_pool_free with empty thread  callback and valgrind still reported the above warning.","Looks like I'm getting a shutdown crash with this patch applied:
[pid 3177782] madvise(0x7f965f0c2000, 8368128, MADV_DONTNEED) = 0
[pid 3177782] exit(0)                   = ?
[pid 3177782] +++ exited with 0 +++
<... futex resumed>)                    = 0
munmap(0x7f9616ffe000, 8392704)         = 0
futex(0x564974b81e80, FUTEX_WAKE_PRIVATE, 1) = 0
write(2, ""[1592230466.693114] INFO: Version 8.5.0.0+0~mr8.5.0.0 git-master-a0895fa7 shutting down\n"", 88) = 88
--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x68} ---
+++ killed by SIGSEGV (core dumped) +++

Reading symbols from ../daemon/rtpengine...
[New LWP 3177779]
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/lib/x86_64-linux-gnu/libthread_db.so.1"".
Core was generated by `../daemon/rtpengine --config-file=none -t -1 -i 203.0.113.1 -i 2001:db8:4321::1'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000564974b10ac4 in redis_close (r=0x0) at redis.c:684

warning: Source file is more recent than executable.
684	void redis_close(struct redis *r) {
(gdb) bt
#0  0x0000564974b10ac4 in redis_close (r=0x0) at redis.c:684
#1  0x0000564974afc71a in main (argc=<optimized out>, argv=<optimized out>) at main.c:952
(gdb)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1016,2020-06-15T13:21:35Z,2020-06-17T12:11:50Z,2020-06-17T12:11:50Z,MERGED,True,26,1,5,https://github.com/smititelu,"Solve Valgrind ""possibly lost"" for redis and dtls",1,[],https://github.com/sipwise/rtpengine/pull/1016,https://github.com/smititelu,5,https://github.com/sipwise/rtpengine/pull/1016#issuecomment-645274318,"There is 1 more warning related to this, that I am confused how to solve:
==30466== 64 bytes in 1 blocks are still reachable in loss record 211 of 387
==30466==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==30466==    by 0x522BAB8: g_malloc (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x51F95A2: g_async_queue_new_full (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x524EA0C: g_thread_pool_new (in /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.5600.4)
==30466==    by 0x12DD6F: redis_restore (redis.c:1758)
==30466==    by 0x119D82: create_everything (main.c:868)
==30466==    by 0x119D82: main (main.c:892)

I think it might be related to the glibc since g_thread_pool_free should already do all the job.
I tried creating a small test program only with g_thread_pool_new g_thread_pool_free with empty thread  callback and valgrind still reported the above warning.","Added null-checks before free-ing dtls and redis.
Created a new GNOME/glib issue for the above g_thread_pool_new/g_thread_pool_free.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1020,2020-06-17T17:36:48Z,2020-06-18T12:58:44Z,2020-06-18T12:58:44Z,MERGED,True,41,7,4,https://github.com/smititelu,Few more valgrind fixes,2,[],https://github.com/sipwise/rtpengine/pull/1020,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1020,"free the allocate str_init_dup() for if name
clear the queues for keyspaces and interfaces config","free the allocate str_init_dup() for if name
clear the queues for keyspaces and interfaces config",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1020,2020-06-17T17:36:48Z,2020-06-18T12:58:44Z,2020-06-18T12:58:44Z,MERGED,True,41,7,4,https://github.com/smititelu,Few more valgrind fixes,2,[],https://github.com/sipwise/rtpengine/pull/1020,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1020#issuecomment-645527821,"free the allocate str_init_dup() for if name
clear the queues for keyspaces and interfaces config","Getting a shutdown crash with this.
(gdb) bt
#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007f0ba1ffa55b in __GI_abort () at abort.c:79
#2  0x00007f0ba2053038 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f0ba215ff3e ""%s\n"")
    at ../sysdeps/posix/libc_fatal.c:181
#3  0x00007f0ba205a3da in malloc_printerr (str=str@entry=0x7f0ba215e0e0 ""free(): invalid pointer"") at malloc.c:5339
#4  0x00007f0ba205bdcc in _int_free (av=<optimized out>, p=<optimized out>, have_lock=0) at malloc.c:4173
#5  0x00007f0ba4b0ff2f in g_queue_foreach () at /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0
#6  0x00007f0ba4b0ffb5 in g_queue_clear_full () at /usr/lib/x86_64-linux-gnu/libglib-2.0.so.0
#7  0x00005648f448c7fd in options_free () at main.c:975
#8  main (argc=<optimized out>, argv=<optimized out>) at main.c:975

I believe it's because if_addr_parse uses g_slice_alloc to populate the list of interfaces in rtpe_config.interfaces, while your added code uses malloc/free to duplicate and free the ini_rtpe_cfg->interfaces list.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1020,2020-06-17T17:36:48Z,2020-06-18T12:58:44Z,2020-06-18T12:58:44Z,MERGED,True,41,7,4,https://github.com/smititelu,Few more valgrind fixes,2,[],https://github.com/sipwise/rtpengine/pull/1020,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1020#issuecomment-645871413,"free the allocate str_init_dup() for if name
clear the queues for keyspaces and interfaces config","Thanks for pointing this out. I missed it since I was testing only with G_SLICE=always-malloc.
Updated the commit so both will use g_slice_alloc/free. Added also str_free_dup() function.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1022,2020-06-19T10:58:24Z,2020-06-19T12:24:46Z,2020-06-19T12:24:47Z,MERGED,True,6,4,1,https://github.com/smititelu,Fix config use_section,1,[],https://github.com/sipwise/rtpengine/pull/1022,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1022,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1022,2020-06-19T10:58:24Z,2020-06-19T12:24:46Z,2020-06-19T12:24:47Z,MERGED,True,6,4,1,https://github.com/smititelu,Fix config use_section,1,[],https://github.com/sipwise/rtpengine/pull/1022,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/1022#issuecomment-646573607,,Fixes #1021,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1022,2020-06-19T10:58:24Z,2020-06-19T12:24:46Z,2020-06-19T12:24:47Z,MERGED,True,6,4,1,https://github.com/smititelu,Fix config use_section,1,[],https://github.com/sipwise/rtpengine/pull/1022,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1022#issuecomment-646606930,,My mistake I think. Thanks.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1023,2020-06-22T07:40:27Z,2020-06-22T16:03:14Z,2020-06-22T16:03:14Z,MERGED,True,97,5,17,https://github.com/smititelu,"Fix Valgrind ""still reachable"" for a few others",1,[],https://github.com/sipwise/rtpengine/pull/1023,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1023,"log, ice, media_player, jitter_buffer, statistics, codeclib, call_interfaces
After this commit, and using the glib suppression file [1] just two other valgrind warnings show up upon start-stop rtpengine:

av lib related (even if i call the avformat_network_deinit()):

==14340== 40 bytes in 1 blocks are still reachable in loss record 137 of 264
==14340==    at 0x4C32443: memalign (vg_replace_malloc.c:906)
==14340==    by 0x4C32546: posix_memalign (vg_replace_malloc.c:1070)
==14340==    by 0x93F0662: av_malloc (in /usr/lib/x86_64-linux-gnu/libavutil.so.55.78.100)
==14340==    by 0x7ED0099: ??? (in /usr/lib/x86_64-linux-gnu/libavcodec.so.57.107.100)
==14340==    by 0x7ED40FD: avpriv_lock_avformat (in /usr/lib/x86_64-linux-gnu/libavcodec.so.57.107.100)
==14340==    by 0x9100008: ??? (in /usr/lib/x86_64-linux-gnu/libavformat.so.57.83.100)
==14340==    by 0x9097248: ??? (in /usr/lib/x86_64-linux-gnu/libavformat.so.57.83.100)
==14340==    by 0x911398E: avformat_network_init (in /usr/lib/x86_64-linux-gnu/libavformat.so.57.83.100)
==14340==    by 0x17903A: codeclib_init (codeclib.c:775)
==14340==    by 0x119CCB: init_everything (main.c:761)
==14340==    by 0x119CCB: main (main.c:902)


glib related:

==14340== 96 bytes in 1 blocks are still reachable in loss record 184 of 264
==14340==    at 0x4C2FECB: malloc (vg_replace_malloc.c:307)
==14340==    by 0x5230D08: g_malloc (gmem.c:106)
==14340==    by 0x52498D5: g_slice_alloc (gslice.c:1025)
==14340==    by 0x5218A9D: g_hash_table_new_full (ghash.c:1071)
==14340==    by 0x523B96A: g_quark_init (gquark.c:61)
==14340==    by 0x4010732: call_init (dl-init.c:72)
==14340==    by 0x4010732: _dl_init (dl-init.c:119)
==14340==    by 0x40010C9: ??? (in /lib/x86_64-linux-gnu/ld-2.27.so)
==14340==    by 0x7: ???
==14340==    by 0x1FFF000572: ???
==14340==    by 0x1FFF000583: ???
==14340==    by 0x1FFF000586: ???
==14340==    by 0x1FFF000589: ???


==14340== 16,384 bytes in 1 blocks are still reachable in loss record 264 of 264
==14340==    at 0x4C2FECB: malloc (vg_replace_malloc.c:307)
==14340==    by 0x5230D08: g_malloc (gmem.c:106)
==14340==    by 0x523B97B: g_quark_init (gquark.c:62)
==14340==    by 0x4010732: call_init (dl-init.c:72)
==14340==    by 0x4010732: _dl_init (dl-init.c:119)
==14340==    by 0x40010C9: ??? (in /lib/x86_64-linux-gnu/ld-2.27.so)
==14340==    by 0x7: ???
==14340==    by 0x1FFF000572: ???
==14340==    by 0x1FFF000583: ???
==14340==    by 0x1FFF000586: ???
==14340==    by 0x1FFF000589: ???
==14340==    by 0x1FFF00059D: ???
==14340==    by 0x1FFF0005A7: ???

However, there are no warnings strictly related to rtpengine code, for the basic start-stop scenario 😃
[1] https://github.com/GNOME/glib/blob/mainline/glib.supp","log, ice, media_player, jitter_buffer, statistics, codeclib, call_interfaces
After this commit, and using the glib suppression file [1] just two other valgrind warnings show up upon start-stop rtpengine:

av lib related (even if i call the avformat_network_deinit()):

==14340== 40 bytes in 1 blocks are still reachable in loss record 137 of 264
==14340==    at 0x4C32443: memalign (vg_replace_malloc.c:906)
==14340==    by 0x4C32546: posix_memalign (vg_replace_malloc.c:1070)
==14340==    by 0x93F0662: av_malloc (in /usr/lib/x86_64-linux-gnu/libavutil.so.55.78.100)
==14340==    by 0x7ED0099: ??? (in /usr/lib/x86_64-linux-gnu/libavcodec.so.57.107.100)
==14340==    by 0x7ED40FD: avpriv_lock_avformat (in /usr/lib/x86_64-linux-gnu/libavcodec.so.57.107.100)
==14340==    by 0x9100008: ??? (in /usr/lib/x86_64-linux-gnu/libavformat.so.57.83.100)
==14340==    by 0x9097248: ??? (in /usr/lib/x86_64-linux-gnu/libavformat.so.57.83.100)
==14340==    by 0x911398E: avformat_network_init (in /usr/lib/x86_64-linux-gnu/libavformat.so.57.83.100)
==14340==    by 0x17903A: codeclib_init (codeclib.c:775)
==14340==    by 0x119CCB: init_everything (main.c:761)
==14340==    by 0x119CCB: main (main.c:902)


glib related:

==14340== 96 bytes in 1 blocks are still reachable in loss record 184 of 264
==14340==    at 0x4C2FECB: malloc (vg_replace_malloc.c:307)
==14340==    by 0x5230D08: g_malloc (gmem.c:106)
==14340==    by 0x52498D5: g_slice_alloc (gslice.c:1025)
==14340==    by 0x5218A9D: g_hash_table_new_full (ghash.c:1071)
==14340==    by 0x523B96A: g_quark_init (gquark.c:61)
==14340==    by 0x4010732: call_init (dl-init.c:72)
==14340==    by 0x4010732: _dl_init (dl-init.c:119)
==14340==    by 0x40010C9: ??? (in /lib/x86_64-linux-gnu/ld-2.27.so)
==14340==    by 0x7: ???
==14340==    by 0x1FFF000572: ???
==14340==    by 0x1FFF000583: ???
==14340==    by 0x1FFF000586: ???
==14340==    by 0x1FFF000589: ???


==14340== 16,384 bytes in 1 blocks are still reachable in loss record 264 of 264
==14340==    at 0x4C2FECB: malloc (vg_replace_malloc.c:307)
==14340==    by 0x5230D08: g_malloc (gmem.c:106)
==14340==    by 0x523B97B: g_quark_init (gquark.c:62)
==14340==    by 0x4010732: call_init (dl-init.c:72)
==14340==    by 0x4010732: _dl_init (dl-init.c:119)
==14340==    by 0x40010C9: ??? (in /lib/x86_64-linux-gnu/ld-2.27.so)
==14340==    by 0x7: ???
==14340==    by 0x1FFF000572: ???
==14340==    by 0x1FFF000583: ???
==14340==    by 0x1FFF000586: ???
==14340==    by 0x1FFF000589: ???
==14340==    by 0x1FFF00059D: ???
==14340==    by 0x1FFF0005A7: ???

However, there are no warnings strictly related to rtpengine code, for the basic start-stop scenario 😃
[1] https://github.com/GNOME/glib/blob/mainline/glib.supp",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1026,2020-06-24T13:38:59Z,2020-06-25T13:15:27Z,2020-06-25T13:15:27Z,MERGED,True,32,1,7,https://github.com/smititelu,"Fix a few more ""still reachable"". End all redis unused threads.",1,[],https://github.com/sipwise/rtpengine/pull/1026,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1026,"I'm starting to test valgrind rtpengine in production environment with production config.
Found a few more ""still reachable"" upon start-stop.","I'm starting to test valgrind rtpengine in production environment with production config.
Found a few more ""still reachable"" upon start-stop.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1026,2020-06-24T13:38:59Z,2020-06-25T13:15:27Z,2020-06-25T13:15:27Z,MERGED,True,32,1,7,https://github.com/smititelu,"Fix a few more ""still reachable"". End all redis unused threads.",1,[],https://github.com/sipwise/rtpengine/pull/1026,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/1026#issuecomment-649333449,"I'm starting to test valgrind rtpengine in production environment with production config.
Found a few more ""still reachable"" upon start-stop.",Added some free in recording-daemon/main.c,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1033,2020-07-01T08:13:01Z,2020-07-02T14:59:38Z,2020-07-02T14:59:38Z,CLOSED,False,19,0,1,https://github.com/jovermann,do not forward RTP packets with unsuitable payload,1,[],https://github.com/sipwise/rtpengine/pull/1033,https://github.com/jovermann,1,https://github.com/sipwise/rtpengine/pull/1033,"Fixing #1032
This is a last-resort check to stop RTP packets being sent to sink
ports for payloads which are not supported by the sink ports.","Fixing #1032
This is a last-resort check to stop RTP packets being sent to sink
ports for payloads which are not supported by the sink ports.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1033,2020-07-01T08:13:01Z,2020-07-02T14:59:38Z,2020-07-02T14:59:38Z,CLOSED,False,19,0,1,https://github.com/jovermann,do not forward RTP packets with unsuitable payload,1,[],https://github.com/sipwise/rtpengine/pull/1033,https://github.com/jovermann,2,https://github.com/sipwise/rtpengine/pull/1033#issuecomment-652269003,"Fixing #1032
This is a last-resort check to stop RTP packets being sent to sink
ports for payloads which are not supported by the sink ports.","I consider this a workaround for a problem created deeper inside rtpengine (routing packets to wrong sinks), but I struggle to find where to properly fix this. Any comments and better solutions welcome.
Even with a better fix in place, this patch may be useful as a last-resort check to prevent packets going the wrong way.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1033,2020-07-01T08:13:01Z,2020-07-02T14:59:38Z,2020-07-02T14:59:38Z,CLOSED,False,19,0,1,https://github.com/jovermann,do not forward RTP packets with unsuitable payload,1,[],https://github.com/sipwise/rtpengine/pull/1033,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1033#issuecomment-652386971,"Fixing #1032
This is a last-resort check to stop RTP packets being sent to sink
ports for payloads which are not supported by the sink ports.","While I appreciate the effort, I don't think this is an appropriate change to make. Rtpengine is supposed to forward packets even if it doesn't understand them at all, e.g. packets that aren't even RTP, or an unknown protocol, or an unknown codec. Only packets that it can understand should be consumed or blocked, not the other way around.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1049,2020-07-23T15:29:54Z,2020-07-23T15:34:30Z,2020-07-23T15:34:31Z,CLOSED,False,122,12,5,https://github.com/pchero,Added message compression/uncompression,1,[],https://github.com/sipwise/rtpengine/pull/1049,https://github.com/pchero,1,https://github.com/sipwise/rtpengine/pull/1049,"Currently, the RTPEngine sends the UDP message without any. compression.
This is fine for most of the cases, but with the complex SDP, the RTPEngine generated over 3000 characters of RTP stats at the end of the call.
Added option for compression the message if the message size is over a certain size.","Currently, the RTPEngine sends the UDP message without any. compression.
This is fine for most of the cases, but with the complex SDP, the RTPEngine generated over 3000 characters of RTP stats at the end of the call.
Added option for compression the message if the message size is over a certain size.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1049,2020-07-23T15:29:54Z,2020-07-23T15:34:30Z,2020-07-23T15:34:31Z,CLOSED,False,122,12,5,https://github.com/pchero,Added message compression/uncompression,1,[],https://github.com/sipwise/rtpengine/pull/1049,https://github.com/pchero,2,https://github.com/sipwise/rtpengine/pull/1049#issuecomment-663076058,"Currently, the RTPEngine sends the UDP message without any. compression.
This is fine for most of the cases, but with the complex SDP, the RTPEngine generated over 3000 characters of RTP stats at the end of the call.
Added option for compression the message if the message size is over a certain size.","Sorry, this is the wrong Pull request. I will be back with a proper request later.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1052,2020-07-27T12:29:08Z,2020-08-19T19:23:44Z,2020-08-25T13:34:32Z,CLOSED,False,139,14,9,https://github.com/pchero,Added compress option,1,[],https://github.com/sipwise/rtpengine/pull/1052,https://github.com/pchero,1,https://github.com/sipwise/rtpengine/pull/1052,Added the compress/uncompress option when the RTPEngine is sending/receiving the Bencode message.,Added the compress/uncompress option when the RTPEngine is sending/receiving the Bencode message.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1052,2020-07-27T12:29:08Z,2020-08-19T19:23:44Z,2020-08-25T13:34:32Z,CLOSED,False,139,14,9,https://github.com/pchero,Added compress option,1,[],https://github.com/sipwise/rtpengine/pull/1052,https://github.com/guillemj,2,https://github.com/sipwise/rtpengine/pull/1052#issuecomment-664681430,Added the compress/uncompress option when the RTPEngine is sending/receiving the Bencode message.,"Hi!
I'm going to perform a cursory review. But Richard is the one who will eventually approve this.
First off, please squash the various commit fixups into logic commits, in this case I think one commit would do, and then force push. Also it looks like the prevalent coding style is to use hard-tabs instead of spaces, please fix those too.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1052,2020-07-27T12:29:08Z,2020-08-19T19:23:44Z,2020-08-25T13:34:32Z,CLOSED,False,139,14,9,https://github.com/pchero,Added compress option,1,[],https://github.com/sipwise/rtpengine/pull/1052,https://github.com/pchero,3,https://github.com/sipwise/rtpengine/pull/1052#issuecomment-676614726,Added the compress/uncompress option when the RTPEngine is sending/receiving the Bencode message.,"Hi @guillemj , @rfuchs ,
Thank you for your kind review. But I don't think this change is valid and useful anymore, at this moment.
So, I'm closing this MR now.
Thank you for all messages.
Kind regards,
Sungtae",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1052,2020-07-27T12:29:08Z,2020-08-19T19:23:44Z,2020-08-25T13:34:32Z,CLOSED,False,139,14,9,https://github.com/pchero,Added compress option,1,[],https://github.com/sipwise/rtpengine/pull/1052,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1052#issuecomment-680022410,Added the compress/uncompress option when the RTPEngine is sending/receiving the Bencode message.,"@pchero If this was supposed to address UDP sending issues related to large packet sizes, MTU, and broken packet fragmentation, we have a feature in the works that adds HTTP and Websocket transports, so it should be possible to use those for rtpengine signalling in the future.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1052,2020-07-27T12:29:08Z,2020-08-19T19:23:44Z,2020-08-25T13:34:32Z,CLOSED,False,139,14,9,https://github.com/pchero,Added compress option,1,[],https://github.com/sipwise/rtpengine/pull/1052,https://github.com/pchero,5,https://github.com/sipwise/rtpengine/pull/1052#issuecomment-680028550,Added the compress/uncompress option when the RTPEngine is sending/receiving the Bencode message.,Thank you @rfuchs !! 👍 👍 👍,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1057,2020-08-07T19:34:53Z,2020-08-07T19:54:45Z,2020-08-07T19:56:30Z,MERGED,True,10,7,2,https://github.com/neheb,fix compilation without deprecated OpenSSL APIs,1,[],https://github.com/sipwise/rtpengine/pull/1057,https://github.com/neheb,1,https://github.com/sipwise/rtpengine/pull/1057,Signed-off-by: Rosen Penev rosenp@gmail.com,Signed-off-by: Rosen Penev rosenp@gmail.com,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1072,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-689044564,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.",Is this because you find the DEL command takes too long to process?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-689331806,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","Yes, actually we have a setup where the redis write server is in another database and a ICMP ping to it takes long.
Overall, for our setup, a DEL command takes long, to send and consume.
Updated the commit such as the new delete async thread to just pool the redis write state, upon redis disconnection, and don't do anything to the redis write context.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/smititelu,4,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-689512130,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","Update: I'm having a hard time synchronizing rtpe_redis_delete_async_context between the delete async thread and other rtpengine threads, under production-like traffic. This is because: The(async)context object is always free'd after the disconnect callback fired. This leads to a segfault in redis_delete_async_call_json()->redisAsyncCommand().
I will try a different approach:

all other threads push redis delete commands strings into a glib queue, under a lock
only delete_async thread will handle redis async ctx; will pop redis delete commands strings from the glib queue, under a lock, and send them, using libevent
Need to periodically send loopbreak to delete_async thread in order for step 2 to happen

What do you think of this different approach?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-689542255,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","redis_delete_async_call_json() uses rtpe_redis_delete_async_context under a lock and only if non-null. redis_delete_async_context_disconnect() sets rtpe_redis_delete_async_context to null, also under a lock, and the implicit free only happens after the callback is done. I'm not sure how a segfault can happen here? If you see a segfault then there might be a different underlying issue.
One thing I notice is that the struct redis (rtpe_redis_write) seems to be shared between the async connection and the regular non-async one, which means they (erroneously?) share the connection state, even without being under a lock (in redis_delete_async_loop()). You probably need to keep track of the connection state separately, or even better, refactor struct redis to be able to handle both async and non-async Redis connections.
In general I see a lot of code duplication between the notification code and the new async delete code. Can that be refactored so they share most of the code? Do we really need two event bases? (I guess you need two if you want to strictly separate the threads and what they do.)
If you want to proceed with separating handling the connection into a separate thread, glib provides some convenience structures for that, namely GAsyncQueue or even (somewhat different) GThreadPool. But I feel that it shouldn't be necessary and might just be working around some other issue.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/smititelu,6,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-690592122,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","I updated the code:

remove code duplication
add some async params to struct redis
the delete_async thread will be the only one that handles redis write async_ctx
use async_queue to decouple ""delete"" commands from delete_async thread vs other rtpengine call threads
use async_mutex to guard async_queue
use timer poller loop to trigger delete_async loopbreak, depending on newly added config param redis-delete-async-interval

Preliminary pre-production testing looks ok. Will test this a little more and update the status.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/smititelu,7,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-697403284,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","Added a small fix related to the locking of the async queue, in redis_delete_async() and parameters rename.
Testing the feature since last comment, no more issues spotted.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-700689010,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.","This segfaults on startup for me.
Core was generated by `./rtpengine --config-file=none -t -1 -i 203.0.113.1 -i 2001:db8:4321::1 -n 2223'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00005574b45b89c9 in poller_timer_loop (d=0x5574b5eff120) at poller.c:529
529			if (rtpe_redis_write->async_last + rtpe_config.redis_delete_async_interval <= rtpe_now.tv_sec) {
[Current thread is 1 (Thread 0x7f1280237700 (LWP 117351))]
(gdb) bt
#0  0x00005574b45b89c9 in poller_timer_loop (d=0x5574b5eff120) at poller.c:529
#1  0x00005574b45b8bf2 in thread_detach_func (d=0x5574b5ee12e0) at aux.c:209
#2  0x00007f12899ecea7 in start_thread (arg=<optimized out>) at pthread_create.c:477
#3  0x00007f128991ceaf in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
(gdb) bt full
#0  0x00005574b45b89c9 in poller_timer_loop (d=0x5574b5eff120) at poller.c:529
        tv = {
          tv_sec = 1601384704,
          tv_usec = 518507
        }
        wt = <optimized out>
#1  0x00005574b45b8bf2 in thread_detach_func (d=0x5574b5ee12e0) at aux.c:209
        dt = 0x5574b5ee12e0
        t = 0x7f1278001bb0
        scheduler = <optimized out>
#2  0x00007f12899ecea7 in start_thread (arg=<optimized out>) at pthread_create.c:477
        ret = <optimized out>
        pd = <optimized out>
        unwind_buf = {
          cancel_jmp_buf = {{
              jmp_buf = {139717435946752, 6713012582790149102, 140730246019134, 140730246019135, 139717435941184, 8396800, -6697862932787678226, -6697844005462002706},
              mask_was_saved = 0
            }},
          priv = {
            pad = {0x0, 0x0, 0x0, 0x0},
            data = {
              prev = 0x0,
              cleanup = 0x0,
              canceltype = 0
            }
          }
        }
        not_first_call = 0
#3  0x00007f128991ceaf in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
(gdb) p rtpe_redis_write
$1 = (struct redis *) 0x0",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/rfuchs,9,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-700689472,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.",Also can you squash those commits into one while you're at it please :),True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1072,2020-09-07T12:42:45Z,2020-10-06T18:34:49Z,2020-10-06T18:34:50Z,MERGED,True,278,83,6,https://github.com/smititelu,Add redis async delete,1,[],https://github.com/sipwise/rtpengine/pull/1072,https://github.com/smititelu,10,https://github.com/sipwise/rtpengine/pull/1072#issuecomment-703630153,"Add a new thread to handle async deletes, using libevent, when enabled by config; default is disabled.
Note that when redis disconnects, deletes are currently lost.
@rfuchs let me know what you think of this PR.",Fixed the above segfault at startup and squashed commits.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1073,2020-09-07T22:02:06Z,2020-09-09T12:09:07Z,2020-09-09T12:09:07Z,MERGED,True,1,1,1,https://github.com/space88man,EL packaging: Build with various FreeSWITCH package names for spandsp,1,[],https://github.com/sipwise/rtpengine/pull/1073,https://github.com/space88man,1,https://github.com/sipwise/rtpengine/pull/1073,"FreeSWITCH >= 1.10.5 has two packages names: spandsp or spandsp3.
As of 2020-09-08,  FreeSWITCH provides for EL systems:

spandsp-devel-1.99.0-15.a6266f2259.x86_64.rpm
spandsp3-devel-3.0.0-25.6ec23e5a7e.x86_64.rpm

They both provide pkgconfig(spandsp), but unfortunately, spandsp3-devel does not provide spandsp-devel to act as a substitute.
The package from EPEL also provides pkgconfig(spandsp), so this PR shouldn't break existing builds.","FreeSWITCH >= 1.10.5 has two packages names: spandsp or spandsp3.
As of 2020-09-08,  FreeSWITCH provides for EL systems:

spandsp-devel-1.99.0-15.a6266f2259.x86_64.rpm
spandsp3-devel-3.0.0-25.6ec23e5a7e.x86_64.rpm

They both provide pkgconfig(spandsp), but unfortunately, spandsp3-devel does not provide spandsp-devel to act as a substitute.
The package from EPEL also provides pkgconfig(spandsp), so this PR shouldn't break existing builds.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1073,2020-09-07T22:02:06Z,2020-09-09T12:09:07Z,2020-09-09T12:09:07Z,MERGED,True,1,1,1,https://github.com/space88man,EL packaging: Build with various FreeSWITCH package names for spandsp,1,[],https://github.com/sipwise/rtpengine/pull/1073,https://github.com/space88man,2,https://github.com/sipwise/rtpengine/pull/1073#issuecomment-688525617,"FreeSWITCH >= 1.10.5 has two packages names: spandsp or spandsp3.
As of 2020-09-08,  FreeSWITCH provides for EL systems:

spandsp-devel-1.99.0-15.a6266f2259.x86_64.rpm
spandsp3-devel-3.0.0-25.6ec23e5a7e.x86_64.rpm

They both provide pkgconfig(spandsp), but unfortunately, spandsp3-devel does not provide spandsp-devel to act as a substitute.
The package from EPEL also provides pkgconfig(spandsp), so this PR shouldn't break existing builds.","If accepted, any chance this could be back-ported to  mr9.0 as well since that is at early stage of branching?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1073,2020-09-07T22:02:06Z,2020-09-09T12:09:07Z,2020-09-09T12:09:07Z,MERGED,True,1,1,1,https://github.com/space88man,EL packaging: Build with various FreeSWITCH package names for spandsp,1,[],https://github.com/sipwise/rtpengine/pull/1073,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1073#issuecomment-689047796,"FreeSWITCH >= 1.10.5 has two packages names: spandsp or spandsp3.
As of 2020-09-08,  FreeSWITCH provides for EL systems:

spandsp-devel-1.99.0-15.a6266f2259.x86_64.rpm
spandsp3-devel-3.0.0-25.6ec23e5a7e.x86_64.rpm

They both provide pkgconfig(spandsp), but unfortunately, spandsp3-devel does not provide spandsp-devel to act as a substitute.
The package from EPEL also provides pkgconfig(spandsp), so this PR shouldn't break existing builds.",Do you happen to know how backwards compatible this is? Could it cause problems when building for older EL releases?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1073,2020-09-07T22:02:06Z,2020-09-09T12:09:07Z,2020-09-09T12:09:07Z,MERGED,True,1,1,1,https://github.com/space88man,EL packaging: Build with various FreeSWITCH package names for spandsp,1,[],https://github.com/sipwise/rtpengine/pull/1073,https://github.com/space88man,4,https://github.com/sipwise/rtpengine/pull/1073#issuecomment-689403600,"FreeSWITCH >= 1.10.5 has two packages names: spandsp or spandsp3.
As of 2020-09-08,  FreeSWITCH provides for EL systems:

spandsp-devel-1.99.0-15.a6266f2259.x86_64.rpm
spandsp3-devel-3.0.0-25.6ec23e5a7e.x86_64.rpm

They both provide pkgconfig(spandsp), but unfortunately, spandsp3-devel does not provide spandsp-devel to act as a substitute.
The package from EPEL also provides pkgconfig(spandsp), so this PR shouldn't break existing builds.","This should work back to EL6. I tested on EL7 and checking the EL6 RPM from EPEL:
$ rpm -qp --provides spandsp-devel-0.0.6-0.8.pre21.el6.x86_64.rpm 
warning: spandsp-devel-0.0.6-0.8.pre21.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID 0608b895: NOKEY
pkgconfig(spandsp) = 0.0.6
spandsp-devel = 0.0.6-0.8.pre21.el6
spandsp-devel(x86-64) = 0.0.6-0.8.pre21.el6

Also EL6 is EOL on 11/2020 so maybe that should be enough?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1077,2020-09-10T22:43:41Z,2020-09-11T13:13:41Z,2020-09-11T13:13:42Z,MERGED,True,10,5,3,https://github.com/drylaarsdam,Add support for metadata in stop_recording.,1,[],https://github.com/sipwise/rtpengine/pull/1077,https://github.com/drylaarsdam,1,https://github.com/sipwise/rtpengine/pull/1077,(Issue #1075 on sipwise/rtpengine),(Issue #1075 on sipwise/rtpengine),True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1082,2020-09-25T11:29:42Z,2020-09-28T09:00:19Z,2020-09-28T09:00:19Z,CLOSED,False,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,2,[],https://github.com/sipwise/rtpengine/pull/1082,https://github.com/sem32,1,https://github.com/sipwise/rtpengine/pull/1082,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1082,2020-09-25T11:29:42Z,2020-09-28T09:00:19Z,2020-09-28T09:00:19Z,CLOSED,False,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,2,[],https://github.com/sipwise/rtpengine/pull/1082,https://github.com/guillemj,2,https://github.com/sipwise/rtpengine/pull/1082#issuecomment-699550274,,"Ah perfect then thanks. Could you, though, squash both commits into a single one, so that the history does not get confusing?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1083,2020-09-28T09:06:07Z,2020-09-29T14:34:31Z,2020-09-29T14:34:31Z,MERGED,True,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,1,[],https://github.com/sipwise/rtpengine/pull/1083,https://github.com/sem32,1,https://github.com/sipwise/rtpengine/pull/1083,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1083,2020-09-28T09:06:07Z,2020-09-29T14:34:31Z,2020-09-29T14:34:31Z,MERGED,True,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,1,[],https://github.com/sipwise/rtpengine/pull/1083,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1083#issuecomment-700715030,,"I think there's a different underlying problem here. The function starts with
	if (!media->sdes_in.length)
		return;

So media->sdes_in.head == NULL later on should never happen. The only way this can happen is due to a missing lock somewhere, and a race condition. Can you explain the circumstances in which you see this segfault?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1083,2020-09-28T09:06:07Z,2020-09-29T14:34:31Z,2020-09-29T14:34:31Z,MERGED,True,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,1,[],https://github.com/sipwise/rtpengine/pull/1083,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1083#issuecomment-700715667,,Ah I guess you're using a number of SDES-no-... options?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1083,2020-09-28T09:06:07Z,2020-09-29T14:34:31Z,2020-09-29T14:34:31Z,MERGED,True,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,1,[],https://github.com/sipwise/rtpengine/pull/1083,https://github.com/sem32,4,https://github.com/sipwise/rtpengine/pull/1083#issuecomment-700731869,,"Yes, you are right, we are using
trust-address replace-origin replace-session-connection strict-source ICE=remove RTP/SAVP SDES-encrypted_srtp DTLS=off SDES-no-AES_CM_256_HMAC_SHA1_32 SDES-no-AES_CM_192_HMAC_SHA1_32 SDES-no-AES_CM_192_HMAC_SHA1_80 SDES-no-AES_CM_128_HMAC_SHA1_32 SDES-no-F8_128_HMAC_SHA1_80 SDES-no-F8_128_HMAC_SHA1_32 SDES-no-NULL_HMAC_SHA1_80 SDES-no-NULL_HMAC_SHA1_32 SDES-no-AES_256_CM_HMAC_SHA1_32 SDES-no-AES_256_CM_HMAC_SHA1_80 SDES-no-AES_192_CM_HMAC_SHA1_32 SDES-no-AES_192_CM_HMAC_SHA1_80 rtcp-mux-demux direction=eth0 direction=eth0 via-branch=extra",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1083,2020-09-28T09:06:07Z,2020-09-29T14:34:31Z,2020-09-29T14:34:31Z,MERGED,True,3,0,1,https://github.com/sem32,fix segfault upon got reINVITE and BYE at the same time,1,[],https://github.com/sipwise/rtpengine/pull/1083,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/1083#issuecomment-700747239,,"Ok that explains then, so there just weren't any cipher suites left :)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1093,2020-10-21T13:55:43Z,2020-10-22T17:40:25Z,2020-10-22T17:40:25Z,MERGED,True,18,3,4,https://github.com/smititelu,Fix compilation when transcoding disabled,1,[],https://github.com/sipwise/rtpengine/pull/1093,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1093,"Fix it by escaping newly added code with #ifdef WITH_TRANSCODING.
Also in the Makefile, I've moved LDFLAGS and CFLAGS outside transcoding check; alternativeley could have also guarded websocket #include with  #ifdef WITH_TRANSCODING.
Please let me know if this is ok.","Fix it by escaping newly added code with #ifdef WITH_TRANSCODING.
Also in the Makefile, I've moved LDFLAGS and CFLAGS outside transcoding check; alternativeley could have also guarded websocket #include with  #ifdef WITH_TRANSCODING.
Please let me know if this is ok.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1099,2020-10-28T12:22:18Z,2020-10-28T13:47:52Z,2020-10-28T13:47:52Z,MERGED,True,3,0,1,https://github.com/smititelu,Add format_cmp_f stub when transcoding is not enabled,1,[],https://github.com/sipwise/rtpengine/pull/1099,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1099,needed in order to compile when transcoding is not enabled,needed in order to compile when transcoding is not enabled,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1099,2020-10-28T12:22:18Z,2020-10-28T13:47:52Z,2020-10-28T13:47:52Z,MERGED,True,3,0,1,https://github.com/smititelu,Add format_cmp_f stub when transcoding is not enabled,1,[],https://github.com/sipwise/rtpengine/pull/1099,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1099#issuecomment-717898480,needed in order to compile when transcoding is not enabled,I should really add that compilation option to our tests...,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1116,2020-11-24T19:00:08Z,2020-12-04T13:24:15Z,2020-12-04T13:24:15Z,MERGED,True,4,0,3,https://github.com/jchavanton,RTT per call leg,1,[],https://github.com/sipwise/rtpengine/pull/1116,https://github.com/jchavanton,1,https://github.com/sipwise/rtpengine/pull/1116,"This will let us retrieve the RTT per call legs.
I also tested the integration into kamailio rtpengine module.
(I will make an MR if we do merge this new feature)
Test notes from Kamailio :
Test 1 :
With leg A (Caller) very far 250ms RTT from rtp-engine and leg B (Callee) 100ms RTT
<script>: [QOS][Caller]rtt[370414us]rtt_leg[265979]
<script>: [QOS][Callee]rtt[303485us]rtt_leg[104435]
<script>: [QOS][Average]rtt[336949us]rtt_leg[185207]

Test 2:
Both legs  94ms RTT
<script>: [QOS][Caller]rtt[166813us]rtt_leg[92066]
<script>: [QOS][Callee]rtt[186408us]rtt_leg[94342]
<script>: [QOS][Average]rtt[176610us]rtt_leg[93204]

Kamailio config :
modparam(""rtpengine"", ""mos_B_label_pv"", ""$avp(mos_B_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_B_pv"", ""$avp(mos_max_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_B_pv"", ""$avp(mos_average_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_B_pv"", ""$avp(mos_average_roundtrip_leg_B)"");

modparam(""rtpengine"", ""mos_A_label_pv"", ""$avp(mos_A_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_A_pv"", ""$avp(mos_max_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_A_pv"", ""$avp(mos_average_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_A_pv"", ""$avp(mos_average_roundtrip_leg_A)"");

modparam(""rtpengine"", ""mos_min_pv"", ""$avp(mos_min)"")
modparam(""rtpengine"", ""mos_max_roundtrip_pv"", ""$avp(mos_max_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_pv"", ""$avp(mos_average_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_pv"", ""$avp(mos_average_roundtrip_leg)"");

route[QOS] {
	$avp(mos_A_label) = ""legA"";	
	$avp(mos_B_label) = ""legB"";	
	rtpengine_query();
	xinfo(""[QOS][Caller]rtt[$avp(mos_average_roundtrip_A)us]rtt_leg[$avp(mos_average_roundtrip_leg_A)]\n"");
	xinfo(""[QOS][Callee]rtt[$avp(mos_average_roundtrip_B)us]rtt_leg[$avp(mos_average_roundtrip_leg_B)]\n"");
	xinfo(""[QOS][Average]rtt[$avp(mos_average_roundtrip)us]rtt_leg[$avp(mos_average_roundtrip_leg)]\n"");
}

Additional note: I will also complete the WIP on QoS Rx per call leg without RTCP.
As requested I tested with the kernel module, there was no problem, I am getting closer.
jchavanton#1","This will let us retrieve the RTT per call legs.
I also tested the integration into kamailio rtpengine module.
(I will make an MR if we do merge this new feature)
Test notes from Kamailio :
Test 1 :
With leg A (Caller) very far 250ms RTT from rtp-engine and leg B (Callee) 100ms RTT
<script>: [QOS][Caller]rtt[370414us]rtt_leg[265979]
<script>: [QOS][Callee]rtt[303485us]rtt_leg[104435]
<script>: [QOS][Average]rtt[336949us]rtt_leg[185207]

Test 2:
Both legs  94ms RTT
<script>: [QOS][Caller]rtt[166813us]rtt_leg[92066]
<script>: [QOS][Callee]rtt[186408us]rtt_leg[94342]
<script>: [QOS][Average]rtt[176610us]rtt_leg[93204]

Kamailio config :
modparam(""rtpengine"", ""mos_B_label_pv"", ""$avp(mos_B_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_B_pv"", ""$avp(mos_max_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_B_pv"", ""$avp(mos_average_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_B_pv"", ""$avp(mos_average_roundtrip_leg_B)"");

modparam(""rtpengine"", ""mos_A_label_pv"", ""$avp(mos_A_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_A_pv"", ""$avp(mos_max_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_A_pv"", ""$avp(mos_average_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_A_pv"", ""$avp(mos_average_roundtrip_leg_A)"");

modparam(""rtpengine"", ""mos_min_pv"", ""$avp(mos_min)"")
modparam(""rtpengine"", ""mos_max_roundtrip_pv"", ""$avp(mos_max_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_pv"", ""$avp(mos_average_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_pv"", ""$avp(mos_average_roundtrip_leg)"");

route[QOS] {
	$avp(mos_A_label) = ""legA"";	
	$avp(mos_B_label) = ""legB"";	
	rtpengine_query();
	xinfo(""[QOS][Caller]rtt[$avp(mos_average_roundtrip_A)us]rtt_leg[$avp(mos_average_roundtrip_leg_A)]\n"");
	xinfo(""[QOS][Callee]rtt[$avp(mos_average_roundtrip_B)us]rtt_leg[$avp(mos_average_roundtrip_leg_B)]\n"");
	xinfo(""[QOS][Average]rtt[$avp(mos_average_roundtrip)us]rtt_leg[$avp(mos_average_roundtrip_leg)]\n"");
}

Additional note: I will also complete the WIP on QoS Rx per call leg without RTCP.
As requested I tested with the kernel module, there was no problem, I am getting closer.
jchavanton#1",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1116,2020-11-24T19:00:08Z,2020-12-04T13:24:15Z,2020-12-04T13:24:15Z,MERGED,True,4,0,3,https://github.com/jchavanton,RTT per call leg,1,[],https://github.com/sipwise/rtpengine/pull/1116,https://github.com/jchavanton,2,https://github.com/sipwise/rtpengine/pull/1116#issuecomment-738462816,"This will let us retrieve the RTT per call legs.
I also tested the integration into kamailio rtpengine module.
(I will make an MR if we do merge this new feature)
Test notes from Kamailio :
Test 1 :
With leg A (Caller) very far 250ms RTT from rtp-engine and leg B (Callee) 100ms RTT
<script>: [QOS][Caller]rtt[370414us]rtt_leg[265979]
<script>: [QOS][Callee]rtt[303485us]rtt_leg[104435]
<script>: [QOS][Average]rtt[336949us]rtt_leg[185207]

Test 2:
Both legs  94ms RTT
<script>: [QOS][Caller]rtt[166813us]rtt_leg[92066]
<script>: [QOS][Callee]rtt[186408us]rtt_leg[94342]
<script>: [QOS][Average]rtt[176610us]rtt_leg[93204]

Kamailio config :
modparam(""rtpengine"", ""mos_B_label_pv"", ""$avp(mos_B_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_B_pv"", ""$avp(mos_max_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_B_pv"", ""$avp(mos_average_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_B_pv"", ""$avp(mos_average_roundtrip_leg_B)"");

modparam(""rtpengine"", ""mos_A_label_pv"", ""$avp(mos_A_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_A_pv"", ""$avp(mos_max_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_A_pv"", ""$avp(mos_average_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_A_pv"", ""$avp(mos_average_roundtrip_leg_A)"");

modparam(""rtpengine"", ""mos_min_pv"", ""$avp(mos_min)"")
modparam(""rtpengine"", ""mos_max_roundtrip_pv"", ""$avp(mos_max_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_pv"", ""$avp(mos_average_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_pv"", ""$avp(mos_average_roundtrip_leg)"");

route[QOS] {
	$avp(mos_A_label) = ""legA"";	
	$avp(mos_B_label) = ""legB"";	
	rtpengine_query();
	xinfo(""[QOS][Caller]rtt[$avp(mos_average_roundtrip_A)us]rtt_leg[$avp(mos_average_roundtrip_leg_A)]\n"");
	xinfo(""[QOS][Callee]rtt[$avp(mos_average_roundtrip_B)us]rtt_leg[$avp(mos_average_roundtrip_leg_B)]\n"");
	xinfo(""[QOS][Average]rtt[$avp(mos_average_roundtrip)us]rtt_leg[$avp(mos_average_roundtrip_leg)]\n"");
}

Additional note: I will also complete the WIP on QoS Rx per call leg without RTCP.
As requested I tested with the kernel module, there was no problem, I am getting closer.
jchavanton#1",@rfuchs any thought or opinion on this little improvement ?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1116,2020-11-24T19:00:08Z,2020-12-04T13:24:15Z,2020-12-04T13:24:15Z,MERGED,True,4,0,3,https://github.com/jchavanton,RTT per call leg,1,[],https://github.com/sipwise/rtpengine/pull/1116,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1116#issuecomment-738781407,"This will let us retrieve the RTT per call legs.
I also tested the integration into kamailio rtpengine module.
(I will make an MR if we do merge this new feature)
Test notes from Kamailio :
Test 1 :
With leg A (Caller) very far 250ms RTT from rtp-engine and leg B (Callee) 100ms RTT
<script>: [QOS][Caller]rtt[370414us]rtt_leg[265979]
<script>: [QOS][Callee]rtt[303485us]rtt_leg[104435]
<script>: [QOS][Average]rtt[336949us]rtt_leg[185207]

Test 2:
Both legs  94ms RTT
<script>: [QOS][Caller]rtt[166813us]rtt_leg[92066]
<script>: [QOS][Callee]rtt[186408us]rtt_leg[94342]
<script>: [QOS][Average]rtt[176610us]rtt_leg[93204]

Kamailio config :
modparam(""rtpengine"", ""mos_B_label_pv"", ""$avp(mos_B_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_B_pv"", ""$avp(mos_max_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_B_pv"", ""$avp(mos_average_roundtrip_B)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_B_pv"", ""$avp(mos_average_roundtrip_leg_B)"");

modparam(""rtpengine"", ""mos_A_label_pv"", ""$avp(mos_A_label)"")
modparam(""rtpengine"", ""mos_max_roundtrip_A_pv"", ""$avp(mos_max_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_A_pv"", ""$avp(mos_average_roundtrip_A)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_A_pv"", ""$avp(mos_average_roundtrip_leg_A)"");

modparam(""rtpengine"", ""mos_min_pv"", ""$avp(mos_min)"")
modparam(""rtpengine"", ""mos_max_roundtrip_pv"", ""$avp(mos_max_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_pv"", ""$avp(mos_average_roundtrip)"");
modparam(""rtpengine"", ""mos_average_roundtrip_leg_pv"", ""$avp(mos_average_roundtrip_leg)"");

route[QOS] {
	$avp(mos_A_label) = ""legA"";	
	$avp(mos_B_label) = ""legB"";	
	rtpengine_query();
	xinfo(""[QOS][Caller]rtt[$avp(mos_average_roundtrip_A)us]rtt_leg[$avp(mos_average_roundtrip_leg_A)]\n"");
	xinfo(""[QOS][Callee]rtt[$avp(mos_average_roundtrip_B)us]rtt_leg[$avp(mos_average_roundtrip_leg_B)]\n"");
	xinfo(""[QOS][Average]rtt[$avp(mos_average_roundtrip)us]rtt_leg[$avp(mos_average_roundtrip_leg)]\n"");
}

Additional note: I will also complete the WIP on QoS Rx per call leg without RTCP.
As requested I tested with the kernel module, there was no problem, I am getting closer.
jchavanton#1","Sorry, I missed this PR the first time around. Thanks for the ping. LGTM.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/jakubkarolczyk,1,https://github.com/sipwise/rtpengine/pull/1126,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738782702,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.",Can you describe a concrete case that this would fix? I would like to add it to the automated tests.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/jakubkarolczyk,3,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738799122,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","Client sends the offer with rtcp-mux; RTPEngine does rtcp-demux and sends the new offer to peer
1st answer back from the peer (183) with c=A.B.C.D; RTPEngine replies to client with rtcp-mux
2nd answer back from the peer (200) with c=E.F.G.H; RTPEngine replies to client without rtcp-mux (before fix)
Client can only do rtcp-mux and rejects the call
2nd answer back from the peer (200) with c=E.F.G.H; RTPEngine replies to client with rtcp-mux (after fix)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738803300,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","Hm ok, can't really reproduce that... does the 200 answer also have a different to-tag than the 183?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/jakubkarolczyk,5,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738811751,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","That's correct, 200 has got different to-tag than 183",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738888184,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","Ok I see. I don't think this is the correct solution. In fact it breaks an existing test case.
Is there any branching/forking going on in your routing logic, or do you simply get two answers with different to-tags unsolicited?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/jakubkarolczyk,7,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738896712,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","I simply get two answers with different to-tags.
btw. what is the scenario of test case ""gh #793 b2""?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1126,2020-12-04T12:48:06Z,,2020-12-04T17:14:08Z,OPEN,False,5,0,1,https://github.com/jakubkarolczyk,Update call.c,1,[],https://github.com/sipwise/rtpengine/pull/1126,https://github.com/rfuchs,8,https://github.com/sipwise/rtpengine/pull/1126#issuecomment-738902603,"If the consecutive answer is from different media endpoint (e.g. early media scenario with different media endpoint used for 183), then we are loosing RTCP_MUX_OVERRIDE, as it was set for the previous answer. We need to explicitly check if rtcp-mux was initially offered by the client.","I simply get two answers with different to-tags.
btw. what is the scenario of test case ""gh #793 b2""​【5 cm】?

Similar to your case, but for a deliberately branched call (using via-branch and multiple offers).
I'll have to think about how this can be fixed nicely.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1127,2020-12-04T16:18:56Z,2020-12-23T19:18:16Z,2020-12-23T19:18:16Z,CLOSED,False,9,3,1,https://github.com/jakubkarolczyk,Update jitter_buffer.c,2,[],https://github.com/sipwise/rtpengine/pull/1127,https://github.com/jakubkarolczyk,1,https://github.com/sipwise/rtpengine/pull/1127,"Changed the way of excluding RTCP from being processed by JB.
For rtcp-mux, stream is both RTP and RTCP. That causes the situation when the first RTCP packet received is disabling Jitter Buffer. The proposition is to rely on check every packet and exclude the RTCP one from being processed in JB.","Changed the way of excluding RTCP from being processed by JB.
For rtcp-mux, stream is both RTP and RTCP. That causes the situation when the first RTCP packet received is disabling Jitter Buffer. The proposition is to rely on check every packet and exclude the RTCP one from being processed in JB.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1130,2020-12-09T02:09:14Z,2020-12-09T12:51:47Z,2020-12-09T12:51:47Z,CLOSED,False,1,1,1,https://github.com/timando,Fix error in xt_RTPENGINE.c introduced by commit 9a2dc5,1,[],https://github.com/sipwise/rtpengine/pull/1130,https://github.com/timando,1,https://github.com/sipwise/rtpengine/pull/1130,"Fixes an error I got when trying to install the module via DKMS
make: Entering directory '/usr/src/kernels/4.18.0-240.1.1.el8_3.x86_64'
  CC [M]  /var/lib/dkms/ngcp-rtpengine/9.2.0.0+0~mr9.2.0.0-1.el8/build/xt_RTPENGINE.o
/var/lib/dkms/ngcp-rtpengine/9.2.0.0+0~mr9.2.0.0-1.el8/build/xt_RTPENGINE.c: In function ‘send_proxy_packet6’:
/var/lib/dkms/ngcp-rtpengine/9.2.0.0+0~mr9.2.0.0-1.el8/build/xt_RTPENGINE.c:3456:3: error: missing binary operator before token ""(""
   (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,158) && LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0))","Fixes an error I got when trying to install the module via DKMS
make: Entering directory '/usr/src/kernels/4.18.0-240.1.1.el8_3.x86_64'
  CC [M]  /var/lib/dkms/ngcp-rtpengine/9.2.0.0+0~mr9.2.0.0-1.el8/build/xt_RTPENGINE.o
/var/lib/dkms/ngcp-rtpengine/9.2.0.0+0~mr9.2.0.0-1.el8/build/xt_RTPENGINE.c: In function ‘send_proxy_packet6’:
/var/lib/dkms/ngcp-rtpengine/9.2.0.0+0~mr9.2.0.0-1.el8/build/xt_RTPENGINE.c:3456:3: error: missing binary operator before token ""(""
   (LINUX_VERSION_CODE >= KERNEL_VERSION(4,19,158) && LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0))",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1133,2020-12-11T01:16:40Z,2021-01-20T18:30:37Z,2021-01-20T18:30:37Z,CLOSED,False,432,3,3,https://github.com/space88man,Implement RFC7714 ciphers: AEAD AES,3,[],https://github.com/sipwise/rtpengine/pull/1133,https://github.com/space88man,1,https://github.com/sipwise/rtpengine/pull/1133,Initial userspace only implementation. kernel implementation to follow.,Initial userspace only implementation. kernel implementation to follow.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1133,2020-12-11T01:16:40Z,2021-01-20T18:30:37Z,2021-01-20T18:30:37Z,CLOSED,False,432,3,3,https://github.com/space88man,Implement RFC7714 ciphers: AEAD AES,3,[],https://github.com/sipwise/rtpengine/pull/1133,https://github.com/space88man,2,https://github.com/sipwise/rtpengine/pull/1133#issuecomment-742902646,Initial userspace only implementation. kernel implementation to follow.,"Question for @rfuchs : the AEAD-AES GCM encrypt operation sizeof(ciphertext) > sizeof(plaintext).
The API crypto_encrypt_rtp/crypto_encrypt_rtcp look like inplace operations, can the source == target str accept the increased length?
Edit: looks like this might have broken a CI test due to regex not expecting AEAD_AES strings.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1133,2020-12-11T01:16:40Z,2021-01-20T18:30:37Z,2021-01-20T18:30:37Z,CLOSED,False,432,3,3,https://github.com/space88man,Implement RFC7714 ciphers: AEAD AES,3,[],https://github.com/sipwise/rtpengine/pull/1133,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1133#issuecomment-743223828,Initial userspace only implementation. kernel implementation to follow.,"To answer your question, there's a #define RTP_BUFFER_TAIL_ROOM	512 to accommodate for increased payload length during rewrite operations. You can increase it if necessary. On the kernel side we have #define MAX_SKB_TAIL_ROOM (sizeof(((struct rtpengine_srtp *) 0)->mki) + 20)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1133,2020-12-11T01:16:40Z,2021-01-20T18:30:37Z,2021-01-20T18:30:37Z,CLOSED,False,432,3,3,https://github.com/space88man,Implement RFC7714 ciphers: AEAD AES,3,[],https://github.com/sipwise/rtpengine/pull/1133,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1133#issuecomment-743252491,Initial userspace only implementation. kernel implementation to follow.,"And also yes, the tests will have to be adapted to expect the additional crypto suites.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1133,2020-12-11T01:16:40Z,2021-01-20T18:30:37Z,2021-01-20T18:30:37Z,CLOSED,False,432,3,3,https://github.com/space88man,Implement RFC7714 ciphers: AEAD AES,3,[],https://github.com/sipwise/rtpengine/pull/1133,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/1133#issuecomment-762938923,Initial userspace only implementation. kernel implementation to follow.,Currently working on cleaning this up and seeing if kernel support is feasible,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1134,2020-12-11T17:40:36Z,2021-02-01T16:27:41Z,2021-02-01T16:27:41Z,CLOSED,False,11,2,5,https://github.com/balajeesv,rtpengine: Disable jitter-buffer per call in offer,4,[],https://github.com/sipwise/rtpengine/pull/1134,https://github.com/balajeesv,1,https://github.com/sipwise/rtpengine/pull/1134,"Pull request to disable jitter-buffer per call based on the scenario. In the case where more than one rtpengine is used in call-flow (both jitter-buffer enabled in rtpengine), jitter-buffer can be disabled for the second rtpengine.","Pull request to disable jitter-buffer per call based on the scenario. In the case where more than one rtpengine is used in call-flow (both jitter-buffer enabled in rtpengine), jitter-buffer can be disabled for the second rtpengine.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1159,2021-01-08T20:56:11Z,2021-01-12T13:24:36Z,2021-01-12T13:24:36Z,CLOSED,False,45,19,4,https://github.com/dvillaume,Play and repeat,7,[],https://github.com/sipwise/rtpengine/pull/1159,https://github.com/dvillaume,1,https://github.com/sipwise/rtpengine/pull/1159,Add a repetitor to the play functions.,Add a repetitor to the play functions.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1159,2021-01-08T20:56:11Z,2021-01-12T13:24:36Z,2021-01-12T13:24:36Z,CLOSED,False,45,19,4,https://github.com/dvillaume,Play and repeat,7,[],https://github.com/sipwise/rtpengine/pull/1159,https://github.com/dvillaume,2,https://github.com/sipwise/rtpengine/pull/1159#issuecomment-758013530,Add a repetitor to the play functions.,"@rfuchs i will accept your poposal to handle this, if that doesn't bother you too much.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1159,2021-01-08T20:56:11Z,2021-01-12T13:24:36Z,2021-01-12T13:24:36Z,CLOSED,False,45,19,4,https://github.com/dvillaume,Play and repeat,7,[],https://github.com/sipwise/rtpengine/pull/1159,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1159#issuecomment-758061307,Add a repetitor to the play functions.,So ac2a6f0 would be my cleaned up version of this. See if it works for you. (Flag has been renamed to repeat-times from repeat_times for consistency),True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1159,2021-01-08T20:56:11Z,2021-01-12T13:24:36Z,2021-01-12T13:24:36Z,CLOSED,False,45,19,4,https://github.com/dvillaume,Play and repeat,7,[],https://github.com/sipwise/rtpengine/pull/1159,https://github.com/amessina,4,https://github.com/sipwise/rtpengine/pull/1159#issuecomment-758077572,Add a repetitor to the play functions.,"While not related directly to repeat, it would be useful to play a list of files in succession, i.e. play-media file=file1&file2&...1 db-id=id1&id2&....",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1159,2021-01-08T20:56:11Z,2021-01-12T13:24:36Z,2021-01-12T13:24:36Z,CLOSED,False,45,19,4,https://github.com/dvillaume,Play and repeat,7,[],https://github.com/sipwise/rtpengine/pull/1159,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/1159#issuecomment-758122845,Add a repetitor to the play functions.,@amessina pull requests welcome 😄,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1159,2021-01-08T20:56:11Z,2021-01-12T13:24:36Z,2021-01-12T13:24:36Z,CLOSED,False,45,19,4,https://github.com/dvillaume,Play and repeat,7,[],https://github.com/sipwise/rtpengine/pull/1159,https://github.com/amessina,6,https://github.com/sipwise/rtpengine/pull/1159#issuecomment-758137379,Add a repetitor to the play functions.,"@amessina pull requests welcome

Most certainly -- I just don't know C :(",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1163,2021-01-13T11:29:08Z,2021-01-14T08:42:59Z,2021-01-14T08:42:59Z,CLOSED,False,1,1,1,https://github.com/smititelu,Fix strange issue #1161,1,[],https://github.com/sipwise/rtpengine/pull/1163,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1163,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1163,2021-01-13T11:29:08Z,2021-01-14T08:42:59Z,2021-01-14T08:42:59Z,CLOSED,False,1,1,1,https://github.com/smititelu,Fix strange issue #1161,1,[],https://github.com/sipwise/rtpengine/pull/1163,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/1163#issuecomment-760024756,,#1161 NOT an issue,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1164,2021-01-15T10:02:23Z,2021-01-27T15:32:55Z,2021-01-27T15:32:55Z,MERGED,True,83,22,8,https://github.com/smititelu,Update ports binding logic,1,[],https://github.com/sipwise/rtpengine/pull/1164,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1164,"Right now, when binding ports, same number of ports are bound on all local interfaces of a logical interface. Example of audio only call:
interface = external/195.1.1.1;external/2001:8d8::1 will bind 4 ports on IP4 and 4 ports on IP6 even though there is only an IP4 call; thus IP6 ports are wasted.
Try to save ports and bind only the first available local interface of desired family, of a logical interface.
Let me know what you think of this approach.
Thanks,
Stefan","Right now, when binding ports, same number of ports are bound on all local interfaces of a logical interface. Example of audio only call:
interface = external/195.1.1.1;external/2001:8d8::1 will bind 4 ports on IP4 and 4 ports on IP6 even though there is only an IP4 call; thus IP6 ports are wasted.
Try to save ports and bind only the first available local interface of desired family, of a logical interface.
Let me know what you think of this approach.
Thanks,
Stefan",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1164,2021-01-15T10:02:23Z,2021-01-27T15:32:55Z,2021-01-27T15:32:55Z,MERGED,True,83,22,8,https://github.com/smititelu,Update ports binding logic,1,[],https://github.com/sipwise/rtpengine/pull/1164,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/1164#issuecomment-768181910,"Right now, when binding ports, same number of ports are bound on all local interfaces of a logical interface. Example of audio only call:
interface = external/195.1.1.1;external/2001:8d8::1 will bind 4 ports on IP4 and 4 ports on IP6 even though there is only an IP4 call; thus IP6 ports are wasted.
Try to save ports and bind only the first available local interface of desired family, of a logical interface.
Let me know what you think of this approach.
Thanks,
Stefan","Updated PR to the latest master, with my commit on top, to check if sid debian packaging still fails.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1164,2021-01-15T10:02:23Z,2021-01-27T15:32:55Z,2021-01-27T15:32:55Z,MERGED,True,83,22,8,https://github.com/smititelu,Update ports binding logic,1,[],https://github.com/sipwise/rtpengine/pull/1164,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1164#issuecomment-768199535,"Right now, when binding ports, same number of ports are bound on all local interfaces of a logical interface. Example of audio only call:
interface = external/195.1.1.1;external/2001:8d8::1 will bind 4 ports on IP4 and 4 ports on IP6 even though there is only an IP4 call; thus IP6 ports are wasted.
Try to save ports and bind only the first available local interface of desired family, of a logical interface.
Let me know what you think of this approach.
Thanks,
Stefan","Check was still failing for sid, for latest master, even though compilation and tests passed.
After trying a ""blind"" commit over the latest master (which just added a comment in code) and force pushed the same ""port binding"" commit over the latest master, now all checks succeed.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1164,2021-01-15T10:02:23Z,2021-01-27T15:32:55Z,2021-01-27T15:32:55Z,MERGED,True,83,22,8,https://github.com/smititelu,Update ports binding logic,1,[],https://github.com/sipwise/rtpengine/pull/1164,https://github.com/smititelu,4,https://github.com/sipwise/rtpengine/pull/1164#issuecomment-768348502,"Right now, when binding ports, same number of ports are bound on all local interfaces of a logical interface. Example of audio only call:
interface = external/195.1.1.1;external/2001:8d8::1 will bind 4 ports on IP4 and 4 ports on IP6 even though there is only an IP4 call; thus IP6 ports are wasted.
Try to save ports and bind only the first available local interface of desired family, of a logical interface.
Let me know what you think of this approach.
Thanks,
Stefan",Updated .pod file.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1179,2021-02-01T11:13:39Z,2021-02-01T13:55:39Z,2021-02-01T13:55:39Z,MERGED,True,1,1,1,https://github.com/smititelu,Fix build when transcoding disabled,1,[],https://github.com/sipwise/rtpengine/pull/1179,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1179,small param typo fix,small param typo fix,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1180,2021-02-01T13:42:46Z,2021-02-01T16:27:41Z,2021-03-04T17:25:57Z,CLOSED,False,287,15,9,https://github.com/enreached,Control ng tcp,24,[],https://github.com/sipwise/rtpengine/pull/1180,https://github.com/enreached,1,https://github.com/sipwise/rtpengine/pull/1180,"This patch adds support for control-ng over TCP; we feel this to be an important feature, it was tested in our production environment for some time and the results are encouraging.","This patch adds support for control-ng over TCP; we feel this to be an important feature, it was tested in our production environment for some time and the results are encouraging.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1180,2021-02-01T13:42:46Z,2021-02-01T16:27:41Z,2021-03-04T17:25:57Z,CLOSED,False,287,15,9,https://github.com/enreached,Control ng tcp,24,[],https://github.com/sipwise/rtpengine/pull/1180,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1180#issuecomment-770915527,"This patch adds support for control-ng over TCP; we feel this to be an important feature, it was tested in our production environment for some time and the results are encouraging.","Oh and if you could document the new option, in the readme and the .pod file, that would be great 😆",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1180,2021-02-01T13:42:46Z,2021-02-01T16:27:41Z,2021-03-04T17:25:57Z,CLOSED,False,287,15,9,https://github.com/enreached,Control ng tcp,24,[],https://github.com/sipwise/rtpengine/pull/1180,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1180#issuecomment-790784344,"This patch adds support for control-ng over TCP; we feel this to be an important feature, it was tested in our production environment for some time and the results are encouraging.","As the question came up on the Kamailio mailing list (https://lists.kamailio.org/pipermail/sr-users/2021-March/112029.html), out of curiosity, what are you using to speak TCP to rtpengine?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1180,2021-02-01T13:42:46Z,2021-02-01T16:27:41Z,2021-03-04T17:25:57Z,CLOSED,False,287,15,9,https://github.com/enreached,Control ng tcp,24,[],https://github.com/sipwise/rtpengine/pull/1180,https://github.com/enreached,4,https://github.com/sipwise/rtpengine/pull/1180#issuecomment-790789463,"This patch adds support for control-ng over TCP; we feel this to be an important feature, it was tested in our production environment for some time and the results are encouraging.",We have a custom piece of software which speaks TCP to rtpengine.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1183,2021-02-02T10:08:20Z,2021-02-02T15:10:37Z,2021-02-02T15:10:37Z,CLOSED,False,58,3,4,https://github.com/enreached,Dtmf events over ng tcp,33,[],https://github.com/sipwise/rtpengine/pull/1183,https://github.com/enreached,1,https://github.com/sipwise/rtpengine/pull/1183,"This one adds support for sending DTMF events via control NG TCP. It's also been used in the production environment for some time with out any issues. We found that UDP DTMF logging is quite unreliable in our network, so that's why this one was developed.","This one adds support for sending DTMF events via control NG TCP. It's also been used in the production environment for some time with out any issues. We found that UDP DTMF logging is quite unreliable in our network, so that's why this one was developed.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1194,2021-02-18T09:45:09Z,2021-02-18T12:30:14Z,2021-02-18T12:30:14Z,MERGED,True,6,0,1,https://github.com/smititelu,Get time before deciding to re-establish redis connection,1,[],https://github.com/sipwise/rtpengine/pull/1194,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1194,Also set redis connected state when PING works again,Also set redis connected state when PING works again,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1200,2021-03-02T14:55:53Z,2021-03-04T16:42:25Z,2021-03-04T16:42:25Z,CLOSED,False,115,10,7,https://github.com/enreached,Implement poller per thread in order to fix packet order.,9,[],https://github.com/sipwise/rtpengine/pull/1200,https://github.com/enreached,1,https://github.com/sipwise/rtpengine/pull/1200,"With this patch we implemented a poller per thread which will guarantee the correct order of packets being read and sent. In our production environment we noticed that sometimes DTMF packets (RFC 2833) are being sent from RTPEngine in an incorrect order, even though they were delivered in the correct one. Our conclusion was that this was caused by the fact that different threads are reading (and thus sending) DTMF packets from the same socket. Having a poller per thread, we are certain that only a single thread will ever read from a single socket, thus maintaining the correct packet order.","With this patch we implemented a poller per thread which will guarantee the correct order of packets being read and sent. In our production environment we noticed that sometimes DTMF packets (RFC 2833) are being sent from RTPEngine in an incorrect order, even though they were delivered in the correct one. Our conclusion was that this was caused by the fact that different threads are reading (and thus sending) DTMF packets from the same socket. Having a poller per thread, we are certain that only a single thread will ever read from a single socket, thus maintaining the correct packet order.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1200,2021-03-02T14:55:53Z,2021-03-04T16:42:25Z,2021-03-04T16:42:25Z,CLOSED,False,115,10,7,https://github.com/enreached,Implement poller per thread in order to fix packet order.,9,[],https://github.com/sipwise/rtpengine/pull/1200,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1200#issuecomment-789741709,"With this patch we implemented a poller per thread which will guarantee the correct order of packets being read and sent. In our production environment we noticed that sometimes DTMF packets (RFC 2833) are being sent from RTPEngine in an incorrect order, even though they were delivered in the correct one. Our conclusion was that this was caused by the fact that different threads are reading (and thus sending) DTMF packets from the same socket. Having a poller per thread, we are certain that only a single thread will ever read from a single socket, thus maintaining the correct packet order.","Ok I see. Yeah I'm willing to accept it if it's made optional. Some other things I noticed here that I don't see as blockers, but JFYI
You could use pthread_self for a cleaner and more portable alternative for gettid
For random numbers, we tend to use ssl_random() in the code, which is a bit shorter
For small sleeps, we tend to use usleep() which would eliminate the need for a hand rolled function
You could call poller_loop2 from poller_loop to eliminate some code duplication",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1200,2021-03-02T14:55:53Z,2021-03-04T16:42:25Z,2021-03-04T16:42:25Z,CLOSED,False,115,10,7,https://github.com/enreached,Implement poller per thread in order to fix packet order.,9,[],https://github.com/sipwise/rtpengine/pull/1200,https://github.com/enreached,3,https://github.com/sipwise/rtpengine/pull/1200#issuecomment-790593132,"With this patch we implemented a poller per thread which will guarantee the correct order of packets being read and sent. In our production environment we noticed that sometimes DTMF packets (RFC 2833) are being sent from RTPEngine in an incorrect order, even though they were delivered in the correct one. Our conclusion was that this was caused by the fact that different threads are reading (and thus sending) DTMF packets from the same socket. Having a poller per thread, we are certain that only a single thread will ever read from a single socket, thus maintaining the correct packet order.",Last commits should address all the issues you've risen. What should we do about tests? Do you think we should test the behavior with and without the 'poller per thread' functionality?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1200,2021-03-02T14:55:53Z,2021-03-04T16:42:25Z,2021-03-04T16:42:25Z,CLOSED,False,115,10,7,https://github.com/enreached,Implement poller per thread in order to fix packet order.,9,[],https://github.com/sipwise/rtpengine/pull/1200,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1200#issuecomment-790698350,"With this patch we implemented a poller per thread which will guarantee the correct order of packets being read and sent. In our production environment we noticed that sometimes DTMF packets (RFC 2833) are being sent from RTPEngine in an incorrect order, even though they were delivered in the correct one. Our conclusion was that this was caused by the fact that different threads are reading (and thus sending) DTMF packets from the same socket. Having a poller per thread, we are certain that only a single thread will ever read from a single socket, thus maintaining the correct packet order.","Last commits should address all the issues you've risen. What should we do about tests? Do you think we should test the behavior with and without the 'poller per thread' functionality?

TBH I'm not sure how that can be tested reliably since you may randomly get the same behaviour even without the feature active...",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1200,2021-03-02T14:55:53Z,2021-03-04T16:42:25Z,2021-03-04T16:42:25Z,CLOSED,False,115,10,7,https://github.com/enreached,Implement poller per thread in order to fix packet order.,9,[],https://github.com/sipwise/rtpengine/pull/1200,https://github.com/rfuchs,5,https://github.com/sipwise/rtpengine/pull/1200#issuecomment-790755513,"With this patch we implemented a poller per thread which will guarantee the correct order of packets being read and sent. In our production environment we noticed that sometimes DTMF packets (RFC 2833) are being sent from RTPEngine in an incorrect order, even though they were delivered in the correct one. Our conclusion was that this was caused by the fact that different threads are reading (and thus sending) DTMF packets from the same socket. Having a poller per thread, we are certain that only a single thread will ever read from a single socket, thus maintaining the correct packet order.",Merged as f650f95,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1213,2021-03-19T09:54:55Z,2021-03-19T13:14:02Z,2021-03-19T13:15:16Z,MERGED,True,30,0,2,https://github.com/hdikme,added rtpengine-ctl set and list options for the delete-delay config parameter,2,[],https://github.com/sipwise/rtpengine/pull/1213,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/1213,"The patch enables the following commands:

rtpengine-ctl list deletedelay
rtpengine-ctl set deletedelay X (where X is a number).","The patch enables the following commands:

rtpengine-ctl list deletedelay
rtpengine-ctl set deletedelay X (where X is a number).",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1213,2021-03-19T09:54:55Z,2021-03-19T13:14:02Z,2021-03-19T13:15:16Z,MERGED,True,30,0,2,https://github.com/hdikme,added rtpengine-ctl set and list options for the delete-delay config parameter,2,[],https://github.com/sipwise/rtpengine/pull/1213,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1213#issuecomment-802797019,"The patch enables the following commands:

rtpengine-ctl list deletedelay
rtpengine-ctl set deletedelay X (where X is a number).",Can you also add it to the online help in rtpengine-ctl itself please,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1213,2021-03-19T09:54:55Z,2021-03-19T13:14:02Z,2021-03-19T13:15:16Z,MERGED,True,30,0,2,https://github.com/hdikme,added rtpengine-ctl set and list options for the delete-delay config parameter,2,[],https://github.com/sipwise/rtpengine/pull/1213,https://github.com/hdikme,3,https://github.com/sipwise/rtpengine/pull/1213#issuecomment-802824622,"The patch enables the following commands:

rtpengine-ctl list deletedelay
rtpengine-ctl set deletedelay X (where X is a number).","@rfuchs thanks for the quick reply, it's done!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1216,2021-03-24T09:49:34Z,2021-03-24T11:53:23Z,2021-03-24T11:53:23Z,MERGED,True,1,1,1,https://github.com/Dup4,Fix mos_calc,1,[],https://github.com/sipwise/rtpengine/pull/1216,https://github.com/Dup4,1,https://github.com/sipwise/rtpengine/pull/1216,as per https://www.pingman.com/kb/article/how-is-mos-calculated-in-pingplotter-pro-50.html,as per https://www.pingman.com/kb/article/how-is-mos-calculated-in-pingplotter-pro-50.html,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1218,2021-03-24T21:01:50Z,2021-03-25T13:26:23Z,2021-03-25T13:26:23Z,MERGED,True,4,1,1,https://github.com/jchavanton,max-mos: is often invalid when RTCP was not received on both legs ,1,[],https://github.com/sipwise/rtpengine/pull/1218,https://github.com/jchavanton,1,https://github.com/sipwise/rtpengine/pull/1218,"Since we are using RTT mos-cq (conversational quality), we should not compute it when we have only the RTT from one
leg.
What is happening is that almost everytime you have significant latency, the min-mos is the first one and is not accurate ...
We should consider this mos-cq invalid.
Further actions :

add MOS-LQ (the mos that does not consider RTT)
modify Kamailio rtpengine module to not select mos = 0 as the lower mos.

if (decode_mos_vals_dict(&vals_decoded, ssrc_dict, ""lowest MOS"")) {
        if (vals_decoded.mos > 0 && vals_decoded.mos < min_vals.mos)
                min_vals = vals_decoded;
}

Speaking about this, this seems like a good article for more context.
https://archive.eetasia.com/www.eetasia.com/ARTICLES/2005OCT/B/2005OCT03_RFD_NETD_TA.pdf?SOURCES=DOWNLOAD","Since we are using RTT mos-cq (conversational quality), we should not compute it when we have only the RTT from one
leg.
What is happening is that almost everytime you have significant latency, the min-mos is the first one and is not accurate ...
We should consider this mos-cq invalid.
Further actions :

add MOS-LQ (the mos that does not consider RTT)
modify Kamailio rtpengine module to not select mos = 0 as the lower mos.

if (decode_mos_vals_dict(&vals_decoded, ssrc_dict, ""lowest MOS"")) {
        if (vals_decoded.mos > 0 && vals_decoded.mos < min_vals.mos)
                min_vals = vals_decoded;
}

Speaking about this, this seems like a good article for more context.
https://archive.eetasia.com/www.eetasia.com/ARTICLES/2005OCT/B/2005OCT03_RFD_NETD_TA.pdf?SOURCES=DOWNLOAD",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1218,2021-03-24T21:01:50Z,2021-03-25T13:26:23Z,2021-03-25T13:26:23Z,MERGED,True,4,1,1,https://github.com/jchavanton,max-mos: is often invalid when RTCP was not received on both legs ,1,[],https://github.com/sipwise/rtpengine/pull/1218,https://github.com/jchavanton,2,https://github.com/sipwise/rtpengine/pull/1218#issuecomment-806235288,"Since we are using RTT mos-cq (conversational quality), we should not compute it when we have only the RTT from one
leg.
What is happening is that almost everytime you have significant latency, the min-mos is the first one and is not accurate ...
We should consider this mos-cq invalid.
Further actions :

add MOS-LQ (the mos that does not consider RTT)
modify Kamailio rtpengine module to not select mos = 0 as the lower mos.

if (decode_mos_vals_dict(&vals_decoded, ssrc_dict, ""lowest MOS"")) {
        if (vals_decoded.mos > 0 && vals_decoded.mos < min_vals.mos)
                min_vals = vals_decoded;
}

Speaking about this, this seems like a good article for more context.
https://archive.eetasia.com/www.eetasia.com/ARTICLES/2005OCT/B/2005OCT03_RFD_NETD_TA.pdf?SOURCES=DOWNLOAD","looking at the logs, I can not see why the unit tests failed ...
Seems like it is failing at the very end, not sure I understand the framework
1..1332
Died at ../perl/NGCP/Rtpengine/AutoTest.pm line 265.
END failed--call queue aborted.
# Looks like your test exited with 22 just after 1332.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1218,2021-03-24T21:01:50Z,2021-03-25T13:26:23Z,2021-03-25T13:26:23Z,MERGED,True,4,1,1,https://github.com/jchavanton,max-mos: is often invalid when RTCP was not received on both legs ,1,[],https://github.com/sipwise/rtpengine/pull/1218,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1218#issuecomment-806728344,"Since we are using RTT mos-cq (conversational quality), we should not compute it when we have only the RTT from one
leg.
What is happening is that almost everytime you have significant latency, the min-mos is the first one and is not accurate ...
We should consider this mos-cq invalid.
Further actions :

add MOS-LQ (the mos that does not consider RTT)
modify Kamailio rtpengine module to not select mos = 0 as the lower mos.

if (decode_mos_vals_dict(&vals_decoded, ssrc_dict, ""lowest MOS"")) {
        if (vals_decoded.mos > 0 && vals_decoded.mos < min_vals.mos)
                min_vals = vals_decoded;
}

Speaking about this, this seems like a good article for more context.
https://archive.eetasia.com/www.eetasia.com/ARTICLES/2005OCT/B/2005OCT03_RFD_NETD_TA.pdf?SOURCES=DOWNLOAD","looking at the logs, I can not see why the unit tests failed ...
Seems like it is failing at the very end, not sure I understand the framework
1..1332
Died at ../perl/NGCP/Rtpengine/AutoTest.pm line 265.
END failed--call queue aborted.
# Looks like your test exited with 22 just after 1332.


That test is currently broken, don't worry about it",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1219,2021-03-25T09:53:24Z,2021-04-07T12:45:45Z,2021-04-07T12:45:45Z,MERGED,True,133,0,6,https://github.com/smititelu,Add stats for ipv4/ipv6/mixed media calls,1,[],https://github.com/sipwise/rtpengine/pull/1219,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1219,Also Send stats for ipv4/ipv6/mixed media calls to graphite,Also Send stats for ipv4/ipv6/mixed media calls to graphite,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1219,2021-03-25T09:53:24Z,2021-04-07T12:45:45Z,2021-04-07T12:45:45Z,MERGED,True,133,0,6,https://github.com/smititelu,Add stats for ipv4/ipv6/mixed media calls,1,[],https://github.com/sipwise/rtpengine/pull/1219,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1219#issuecomment-806755758,Also Send stats for ipv4/ipv6/mixed media calls to graphite,"I believe there's a problem if a call has one side switching from v4 to v6 (or vice versa) during a re-invite - the stats would go out of sync then, would they not? In fact it looks like that any time a call sees two or more answers it would be counted multiple times?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1219,2021-03-25T09:53:24Z,2021-04-07T12:45:45Z,2021-04-07T12:45:45Z,MERGED,True,133,0,6,https://github.com/smititelu,Add stats for ipv4/ipv6/mixed media calls,1,[],https://github.com/sipwise/rtpengine/pull/1219,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1219#issuecomment-808189540,Also Send stats for ipv4/ipv6/mixed media calls to graphite,"Indeed I have overlooked the re-invites. Will update the PR accordingly.
Question: Do you think there is any valid scenario where calling rtpengine_answer() when call is already answered is helpful? Or this should just be guarded out, for these statistics?
Thanks,
Stefan",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1219,2021-03-25T09:53:24Z,2021-04-07T12:45:45Z,2021-04-07T12:45:45Z,MERGED,True,133,0,6,https://github.com/smititelu,Add stats for ipv4/ipv6/mixed media calls,1,[],https://github.com/sipwise/rtpengine/pull/1219,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1219#issuecomment-808194858,Also Send stats for ipv4/ipv6/mixed media calls to graphite,"Indeed I have overlooked the re-invites. Will update the PR accordingly.
Question: Do you think there is any valid scenario where calling rtpengine_answer() when call is already answered is helpful? Or this should just be guarded out, for these statistics?

Yes, this is very commonly done for a number of reasons, and can include changing the endpoint and address family.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1219,2021-03-25T09:53:24Z,2021-04-07T12:45:45Z,2021-04-07T12:45:45Z,MERGED,True,133,0,6,https://github.com/smititelu,Add stats for ipv4/ipv6/mixed media calls,1,[],https://github.com/sipwise/rtpengine/pull/1219,https://github.com/smititelu,5,https://github.com/sipwise/rtpengine/pull/1219#issuecomment-810046149,Also Send stats for ipv4/ipv6/mixed media calls to graphite,"I've updated PR to consider separate offer/answer ip 4/6 stats and to update the stats for each new offer/answer.
I've basically tested it and it looks fine. Still, I want to do more complex tests and will post later.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1219,2021-03-25T09:53:24Z,2021-04-07T12:45:45Z,2021-04-07T12:45:45Z,MERGED,True,133,0,6,https://github.com/smititelu,Add stats for ipv4/ipv6/mixed media calls,1,[],https://github.com/sipwise/rtpengine/pull/1219,https://github.com/smititelu,6,https://github.com/sipwise/rtpengine/pull/1219#issuecomment-814757954,Also Send stats for ipv4/ipv6/mixed media calls to graphite,"I've found no issues in my tests, so far, with these new statistics. From my point of view PR can be merged.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1221,2021-03-25T17:03:58Z,2021-03-25T20:07:19Z,2021-03-26T04:53:32Z,MERGED,True,9,5,1,https://github.com/jchavanton,mos calculation adjustment,1,[],https://github.com/sipwise/rtpengine/pull/1221,https://github.com/jchavanton,1,https://github.com/sipwise/rtpengine/pull/1221,"small mos calculation adjustment to handle negative r-factor
This will make sure we are considering very low MOS score as invalid, as defined in the standard.
https://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-G.107-201506-I!!PDF-E&type=items
https://medium.com/obkio/measuring-voip-quality-with-mos-score-mean-opinion-score-4de9c7541304
even if this article was missing this part of the calculation
https://www.pingman.com/kb/article/how-is-mos-calculated-in-pingplotter-pro-50.html","small mos calculation adjustment to handle negative r-factor
This will make sure we are considering very low MOS score as invalid, as defined in the standard.
https://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-G.107-201506-I!!PDF-E&type=items
https://medium.com/obkio/measuring-voip-quality-with-mos-score-mean-opinion-score-4de9c7541304
even if this article was missing this part of the calculation
https://www.pingman.com/kb/article/how-is-mos-calculated-in-pingplotter-pro-50.html",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1222,2021-03-26T04:47:45Z,2021-03-26T18:15:25Z,2021-03-26T18:15:25Z,MERGED,True,19,9,4,https://github.com/jchavanton,Mos average fix,1,[],https://github.com/sipwise/rtpengine/pull/1222,https://github.com/jchavanton,1,https://github.com/sipwise/rtpengine/pull/1222,"I noticed that mos average also needs to be fixed when missing one leg RTT, here is one example with the problem.
[core] --- SSRC 40658ef2
[core] ------ Average MOS 3.2, lowest MOS 0.0 (at 0:04), highest MOS 4.3 (at 0:08)
[core] --- SSRC 57f548f4
[core] ------ Average MOS 4.3, lowest MOS 4.3 (at 0:05), highest MOS 4.3 (at 0:05)

with this fix
[core] Calculated MOS from RR for 40671f96 is 0.0

and then end of call is accurate
--- SSRC 40671f96
------ Average MOS 4.3, lowest MOS 4.3 (at 0:08), highest MOS 4.3 (at 0:08)
--- SSRC 622e6eb
------ Average MOS 4.3, lowest MOS 4.3 (at 0:05), highest MOS 4.3 (at 0:05)","I noticed that mos average also needs to be fixed when missing one leg RTT, here is one example with the problem.
[core] --- SSRC 40658ef2
[core] ------ Average MOS 3.2, lowest MOS 0.0 (at 0:04), highest MOS 4.3 (at 0:08)
[core] --- SSRC 57f548f4
[core] ------ Average MOS 4.3, lowest MOS 4.3 (at 0:05), highest MOS 4.3 (at 0:05)

with this fix
[core] Calculated MOS from RR for 40671f96 is 0.0

and then end of call is accurate
--- SSRC 40671f96
------ Average MOS 4.3, lowest MOS 4.3 (at 0:08), highest MOS 4.3 (at 0:08)
--- SSRC 622e6eb
------ Average MOS 4.3, lowest MOS 4.3 (at 0:05), highest MOS 4.3 (at 0:05)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1224,2021-04-01T15:12:31Z,2021-04-05T12:27:03Z,2021-04-05T12:27:03Z,MERGED,True,7,4,4,https://github.com/jchavanton,adding cumulative number of packets lost,1,[],https://github.com/sipwise/rtpengine/pull/1224,https://github.com/jchavanton,1,https://github.com/sipwise/rtpengine/pull/1224,adding cumulative number of packets lost the reporting.,adding cumulative number of packets lost the reporting.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1225,2021-04-02T17:42:20Z,2021-04-05T17:34:23Z,2021-04-05T17:34:23Z,MERGED,True,7,2,2,https://github.com/jchavanton,fix rtt from rtcp_rx,1,[],https://github.com/sipwise/rtpengine/pull/1225,https://github.com/jchavanton,1,https://github.com/sipwise/rtpengine/pull/1225,"I found out we where using the RTT from RTCP_XR (both legs in ms)
to represent 1 leg RTT us.","I found out we where using the RTT from RTCP_XR (both legs in ms)
to represent 1 leg RTT us.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1232,2021-04-11T09:07:24Z,2021-04-11T13:22:03Z,2021-04-11T13:22:04Z,MERGED,True,3,1,1,https://github.com/sergey-safarov,fixed rpm packaging,1,[],https://github.com/sipwise/rtpengine/pull/1232,https://github.com/sergey-safarov,1,https://github.com/sipwise/rtpengine/pull/1232,GH #1231,GH #1231,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1234,2021-04-11T15:41:42Z,2021-04-12T12:16:19Z,2021-04-12T12:16:19Z,MERGED,True,3,0,1,https://github.com/sergey-safarov,rtpengine.sample: added listen-http example,1,[],https://github.com/sipwise/rtpengine/pull/1234,https://github.com/sergey-safarov,1,https://github.com/sipwise/rtpengine/pull/1234,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1252,2021-05-06T03:33:16Z,2021-05-06T12:33:16Z,2021-05-07T09:21:06Z,MERGED,True,1,1,1,https://github.com/azzbcc,"Fix redis connect failed when there are ""@"" in redis password.",1,[],https://github.com/sipwise/rtpengine/pull/1252,https://github.com/azzbcc,1,https://github.com/sipwise/rtpengine/pull/1252,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1262,2021-05-10T15:22:38Z,2021-05-11T12:41:08Z,2021-05-11T12:41:08Z,CLOSED,False,18,2,4,https://github.com/tinoIII,Support Configurable MTU,2,[],https://github.com/sipwise/rtpengine/pull/1262,https://github.com/tinoIII,1,https://github.com/sipwise/rtpengine/pull/1262,"default to 1200
minmimum value 576
RESOLVE #1261","default to 1200
minmimum value 576
RESOLVE #1261",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1262,2021-05-10T15:22:38Z,2021-05-11T12:41:08Z,2021-05-11T12:41:08Z,CLOSED,False,18,2,4,https://github.com/tinoIII,Support Configurable MTU,2,[],https://github.com/sipwise/rtpengine/pull/1262,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1262#issuecomment-838405324,"default to 1200
minmimum value 576
RESOLVE #1261",Merged as 575435d,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1268,2021-05-20T07:51:53Z,2021-05-20T18:20:02Z,2021-05-20T18:36:46Z,CLOSED,False,5,0,1,https://github.com/smititelu,Avoid deadlock of notification thread,1,[],https://github.com/sipwise/rtpengine/pull/1268,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1268,"Fixes issue #1258.
Testing the other two commits on this branch (rfuchs/1257) also look good for us, so they can be put on master, with this commit included.","Fixes issue #1258.
Testing the other two commits on this branch (rfuchs/1257) also look good for us, so they can be put on master, with this commit included.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1268,2021-05-20T07:51:53Z,2021-05-20T18:20:02Z,2021-05-20T18:36:46Z,CLOSED,False,5,0,1,https://github.com/smititelu,Avoid deadlock of notification thread,1,[],https://github.com/sipwise/rtpengine/pull/1268,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1268#issuecomment-845357703,"Fixes issue #1258.
Testing the other two commits on this branch (rfuchs/1257) also look good for us, so they can be put on master, with this commit included.",Thanks for the help. Merged as 156271e,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1278,2021-06-09T12:14:38Z,2021-07-06T12:29:46Z,2021-07-06T12:29:47Z,CLOSED,False,73,24,10,https://github.com/enreached,Feature/recording output dir,7,[],https://github.com/sipwise/rtpengine/pull/1278,https://github.com/enreached,1,https://github.com/sipwise/rtpengine/pull/1278,This ads functionality to set output dir / filename per recording. We use this internally to save recording files directly to S3 fs without exposing the file extension.,This ads functionality to set output dir / filename per recording. We use this internally to save recording files directly to S3 fs without exposing the file extension.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1278,2021-06-09T12:14:38Z,2021-07-06T12:29:46Z,2021-07-06T12:29:47Z,CLOSED,False,73,24,10,https://github.com/enreached,Feature/recording output dir,7,[],https://github.com/sipwise/rtpengine/pull/1278,https://github.com/enreached,2,https://github.com/sipwise/rtpengine/pull/1278#issuecomment-872885464,This ads functionality to set output dir / filename per recording. We use this internally to save recording files directly to S3 fs without exposing the file extension.,"@rfuchs I think I addressed your objections, but I'm puzzled why unit tests are failing. It seems that master's tests are also failing (Run unit tests with sanitizers enabled) with:
Makefile:105: warning: overriding recipe for target 'all-tests'
../lib/common.Makefile:7: warning: ignoring old recipe for target 'all-tests'
rm -rf fake-daemon-tests-main-sockets
mkdir fake-daemon-tests-main-sockets
LD_PRELOAD=../t/tests-preload.so RTPE_BIN=../daemon/rtpengine TEST_SOCKET_PATH=./fake-daemon-tests-main-sockets 
perl -I../perl auto-daemon-tests.pl
==18328==AddressSanitizer CHECK failed: ../../../../src/libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc:6278 ""((__interception::real_memcpy)) != (0)"" (0x0, 0x0)

make[3]: *** [Makefile:119: daemon-tests-main] Error 1
make[3]: Leaving directory '/home/damirn/gh-rtpengine/t'
make[2]: *** [Makefile:112: daemon-tests] Error 2
Can you advise please?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1278,2021-06-09T12:14:38Z,2021-07-06T12:29:46Z,2021-07-06T12:29:47Z,CLOSED,False,73,24,10,https://github.com/enreached,Feature/recording output dir,7,[],https://github.com/sipwise/rtpengine/pull/1278,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1278#issuecomment-874717438,This ads functionality to set output dir / filename per recording. We use this internally to save recording files directly to S3 fs without exposing the file extension.,Merged as cc09099,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1285,2021-06-17T22:30:27Z,2021-06-18T12:55:07Z,2021-06-18T12:55:07Z,CLOSED,False,1,0,1,https://github.com/semhoun,Fix G729 packet duration,1,[],https://github.com/sipwise/rtpengine/pull/1285,https://github.com/semhoun,1,https://github.com/sipwise/rtpengine/pull/1285,"Without this correction, timestamp is not incremented in case of transcoding","Without this correction, timestamp is not incremented in case of transcoding",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1285,2021-06-17T22:30:27Z,2021-06-18T12:55:07Z,2021-06-18T12:55:07Z,CLOSED,False,1,0,1,https://github.com/semhoun,Fix G729 packet duration,1,[],https://github.com/sipwise/rtpengine/pull/1285,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1285#issuecomment-864017401,"Without this correction, timestamp is not incremented in case of transcoding",Merged as 5b90489,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1286,2021-06-17T22:35:03Z,2021-06-18T12:43:38Z,2021-06-18T12:43:38Z,MERGED,True,1,0,1,https://github.com/semhoun,Fix G729 packet duration,1,[],https://github.com/sipwise/rtpengine/pull/1286,https://github.com/semhoun,1,https://github.com/sipwise/rtpengine/pull/1286,"Without this correction, timestamp is not incremented in case of transcoding.
As mentioned in encoder_input_data rtpengine don't rely on encoder pts, but calculating pts from packet duration.
As G729 is not encoded by avcodec we must set the packet duration manually.","Without this correction, timestamp is not incremented in case of transcoding.
As mentioned in encoder_input_data rtpengine don't rely on encoder pts, but calculating pts from packet duration.
As G729 is not encoded by avcodec we must set the packet duration manually.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1287,2021-06-21T15:53:17Z,2021-06-21T16:01:16Z,2021-06-22T08:37:07Z,MERGED,True,2,2,1,https://github.com/khorsmann,Correct EL systemd permissions,1,[],https://github.com/sipwise/rtpengine/pull/1287,https://github.com/khorsmann,1,https://github.com/sipwise/rtpengine/pull/1287,"Systemd complains about 755 rights of EL service files.
""systemd[1]: Configuration file /usr/lib/systemd/system/rtpengine.service is marked executable. Please remove executable permission bits. Proceeding anyway.""","Systemd complains about 755 rights of EL service files.
""systemd[1]: Configuration file /usr/lib/systemd/system/rtpengine.service is marked executable. Please remove executable permission bits. Proceeding anyway.""",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1288,2021-06-22T11:33:20Z,2021-06-22T15:43:42Z,2021-06-22T15:43:42Z,MERGED,True,1,1,1,https://github.com/khorsmann,"not report errors if ""which"" is failing.",1,[],https://github.com/sipwise/rtpengine/pull/1288,https://github.com/khorsmann,1,https://github.com/sipwise/rtpengine/pull/1288,"Since ngcp-virt-identify is not part of rtpengine #916 the helper Pre/Post script should not report errors if ""which"" is failing.","Since ngcp-virt-identify is not part of rtpengine #916 the helper Pre/Post script should not report errors if ""which"" is failing.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1292,2021-06-23T17:44:51Z,2021-06-23T18:49:44Z,2021-06-23T18:49:44Z,CLOSED,False,110,7,3,https://github.com/khorsmann,Add ngcp-rtpengine-iptables-setup to EL based systems,6,[],https://github.com/sipwise/rtpengine/pull/1292,https://github.com/khorsmann,1,https://github.com/sipwise/rtpengine/pull/1292,"The el-sysv init scripts includes also an iptables wrapper.
I use the debian ngcp-rtpengine-iptables-setup and add it to the spec file and the service file.","The el-sysv init scripts includes also an iptables wrapper.
I use the debian ngcp-rtpengine-iptables-setup and add it to the spec file and the service file.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1295,2021-06-28T15:15:26Z,2021-06-28T15:31:13Z,2021-06-28T15:31:13Z,MERGED,True,6,2,1,https://github.com/smititelu,Fix segfault when ps not found,1,[],https://github.com/sipwise/rtpengine/pull/1295,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1295,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1307,2021-07-13T09:42:16Z,2021-07-13T12:44:00Z,2021-07-13T12:44:01Z,CLOSED,False,1,10,1,https://github.com/HauptmannBoosted,Removing unused function '__unsubscribe_one',1,[],https://github.com/sipwise/rtpengine/pull/1307,https://github.com/HauptmannBoosted,1,https://github.com/sipwise/rtpengine/pull/1307,"In daemon/call.c the function '__unsubscribe_one'
has been removed because it was never used which
produces gcc warning on compilation:

call.c:2611:13: warning: ‘__unsubscribe_one’ defined but not used [-Wunused-function]
2611 | static bool __unsubscribe_one(struct call_monologue *which, struct call_monologue *from) {
|             ^~~~~~~~~~~~~~~~~","In daemon/call.c the function '__unsubscribe_one'
has been removed because it was never used which
produces gcc warning on compilation:

call.c:2611:13: warning: ‘__unsubscribe_one’ defined but not used [-Wunused-function]
2611 | static bool __unsubscribe_one(struct call_monologue *which, struct call_monologue *from) {
|             ^~~~~~~~~~~~~~~~~",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1307,2021-07-13T09:42:16Z,2021-07-13T12:44:00Z,2021-07-13T12:44:01Z,CLOSED,False,1,10,1,https://github.com/HauptmannBoosted,Removing unused function '__unsubscribe_one',1,[],https://github.com/sipwise/rtpengine/pull/1307,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1307#issuecomment-879054772,"In daemon/call.c the function '__unsubscribe_one'
has been removed because it was never used which
produces gcc warning on compilation:

call.c:2611:13: warning: ‘__unsubscribe_one’ defined but not used [-Wunused-function]
2611 | static bool __unsubscribe_one(struct call_monologue *which, struct call_monologue *from) {
|             ^~~~~~~~~~~~~~~~~",I have commits pending which will use this function in the near future. Sorry for the warnings in the meantime and sorry for the trouble.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1311,2021-07-16T08:46:13Z,,2021-09-07T20:20:38Z,OPEN,False,12,7,1,https://github.com/jamesaylett,Handle dtls retransmissions,1,[],https://github.com/sipwise/rtpengine/pull/1311,https://github.com/jamesaylett,1,https://github.com/sipwise/rtpengine/pull/1311,"See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.","See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1311,2021-07-16T08:46:13Z,,2021-09-07T20:20:38Z,OPEN,False,12,7,1,https://github.com/jamesaylett,Handle dtls retransmissions,1,[],https://github.com/sipwise/rtpengine/pull/1311,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1311#issuecomment-881436684,"See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.",Sounds reasonable. Have you tested/verified that this solution actually fixes the problem?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1311,2021-07-16T08:46:13Z,,2021-09-07T20:20:38Z,OPEN,False,12,7,1,https://github.com/jamesaylett,Handle dtls retransmissions,1,[],https://github.com/sipwise/rtpengine/pull/1311,https://github.com/jamesaylett,3,https://github.com/sipwise/rtpengine/pull/1311#issuecomment-884714132,"See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.","Apologies for not answering sooner.
Our QA team have been looking at the code and have found some in some circumstances that these changes don't have the desired effect, likely when packets are coming in out of order. We believe try_connect may be exiting with SSL_WANT_READ/SSL_WANT_WRITE and subsequently causing an SSL invalid operation when SSL_read is called. I am going to follow up, so in the meantime please don't merge - but may be helpful to keep this open for reference to others.
My own testing did not have any issues, but was not done under load and with the latest OpenSSL version 1.1.1k.
In terms of the severity of this issue, its not clear to us. We normally get a few customer reports of no-way speech from time to time. Over internet, packets are more likely to be dropped. Could be 1 in 10,000 or less.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1311,2021-07-16T08:46:13Z,,2021-09-07T20:20:38Z,OPEN,False,12,7,1,https://github.com/jamesaylett,Handle dtls retransmissions,1,[],https://github.com/sipwise/rtpengine/pull/1311,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1311#issuecomment-884868491,"See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.","Thanks for trying to track down the issues.
I was wondering if simply calling SSL_connect or SSL_accept again would take care of it? Using SSL_read seems a bit odd to me as we're not reading/writing any actual SSL data. But then I'm not too familiar with the OpenSSL internals.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1311,2021-07-16T08:46:13Z,,2021-09-07T20:20:38Z,OPEN,False,12,7,1,https://github.com/jamesaylett,Handle dtls retransmissions,1,[],https://github.com/sipwise/rtpengine/pull/1311,https://github.com/jamesaylett,5,https://github.com/sipwise/rtpengine/pull/1311#issuecomment-884886124,"See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.","I did try repeating the call to SSL_accept, but in my tests it wasn't successful. I think this does make sense - the DTLS negotiation is incomplete and the documentation on SSL_accept implies its use is to initiate a handshake.
One option might be to change the underlying BIO to block, the OpenSSL documentation suggesting that SSL_connect/SSL_accept returns once the handshake is complete. Not being familiar with OpenSSL, I wasn't sure whether it is an option for DTLS and whether blocking IO would have negative impact on RTPEngine's ability to handle call volumes.
For more context, we use RTPEngine exclusively for WebRTC to legacy VoIP handling multiple thousands concurrent calls daily. Every so often we get these reports of no way speech, but tracking down the exact cause is often too time consuming to be worthwhile given the low rate of occurrence. We now have a customer who is more sensitive to failed calls, so this is an area we are looking to improve to help with the robustness of our service.
I'll likely take a few days to investigate, but I will be sharing the results. Thank you.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1311,2021-07-16T08:46:13Z,,2021-09-07T20:20:38Z,OPEN,False,12,7,1,https://github.com/jamesaylett,Handle dtls retransmissions,1,[],https://github.com/sipwise/rtpengine/pull/1311,https://github.com/jamesaylett,6,https://github.com/sipwise/rtpengine/pull/1311#issuecomment-914601694,"See issue #1310 for summary.
I'm not too familiar with OpenSSL, but taking examples from other sources such as Mediasoup lead me to believe calling SSL_read()  anytime after SSL_connect/SSL_accept would resolve and handle retransmissions.","Apologies for leaving this for so long, been pulled onto other priorities but now will be looking at picking this up again.
We repeated our QA and found for OpenSSL 1.0.2k this pull request resolved the issue, however with 1.1.1k the issue seemed to be resolved with some builds but on others we were able to reproduce the issue about 50% of the time. With our 1.1.1k build we are seeing some compiler warnings (using CentOS 7 so the OS OpenSSL is 1.0.2), I will investigate further and get back to you!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1346,2021-09-07T16:27:30Z,2021-09-09T11:55:06Z,2021-09-09T11:55:06Z,CLOSED,False,3,2,1,https://github.com/smititelu,"Fix graphite deadlock, when continue",1,[],https://github.com/sipwise/rtpengine/pull/1346,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1346,possible fix for issue #1345,possible fix for issue #1345,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1347,2021-09-08T16:16:29Z,2021-09-21T12:54:11Z,2021-09-21T12:54:11Z,CLOSED,False,5,0,1,https://github.com/kolmisoft-company,show codec name in media stats,2,[],https://github.com/sipwise/rtpengine/pull/1347,https://github.com/kolmisoft-company,1,https://github.com/sipwise/rtpengine/pull/1347,"Adds codec name in media stats output
          ...
          ""0f0d2e18"": {
              ""in dialogue with"": ""cs6kn1rloc"",
              ""tag"": ""0f0d2e18"",
              ""codec"": ""PCMA/8000"",
              ""medias"": [
                {
                  ""protocol"": ""RTP/SAVPF"",
                  ""index"": 1,
                  ""type"": ""audio"",
                  ""streams"": [
                     {
                       ""endpoint"": {
           ...","Adds codec name in media stats output
          ...
          ""0f0d2e18"": {
              ""in dialogue with"": ""cs6kn1rloc"",
              ""tag"": ""0f0d2e18"",
              ""codec"": ""PCMA/8000"",
              ""medias"": [
                {
                  ""protocol"": ""RTP/SAVPF"",
                  ""index"": 1,
                  ""type"": ""audio"",
                  ""streams"": [
                     {
                       ""endpoint"": {
           ...",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1373,2021-10-08T00:20:51Z,2021-10-08T12:46:23Z,2021-10-08T12:49:26Z,CLOSED,False,2,2,1,https://github.com/vaizki,Do not manage TLS sockets unless we are forwarding to them,1,[],https://github.com/sipwise/rtpengine/pull/1373,https://github.com/vaizki,1,https://github.com/sipwise/rtpengine/pull/1373,"If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.","If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1373,2021-10-08T00:20:51Z,2021-10-08T12:46:23Z,2021-10-08T12:49:26Z,CLOSED,False,2,2,1,https://github.com/vaizki,Do not manage TLS sockets unless we are forwarding to them,1,[],https://github.com/sipwise/rtpengine/pull/1373,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1373#issuecomment-938593915,"If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.",I'm confused about how (stream->forwarding_on || mf->forwarding_on) can become true if TLS forwarding isn't configured?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1373,2021-10-08T00:20:51Z,2021-10-08T12:46:23Z,2021-10-08T12:49:26Z,CLOSED,False,2,2,1,https://github.com/vaizki,Do not manage TLS sockets unless we are forwarding to them,1,[],https://github.com/sipwise/rtpengine/pull/1373,https://github.com/vaizki,3,https://github.com/sipwise/rtpengine/pull/1373#issuecomment-938603450,"If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.","I'm confused about how (stream->forwarding_on || mf->forwarding_on) can become true if TLS forwarding isn't configured?

stream->forwarding_on becomes true for half the streams in a call after a start forwarding message is sent to rtpengine, metafile gets STREAM %lu FORWARDING %u section at that point.
https://github.com/sipwise/rtpengine/blob/master/recording-daemon/metafile.c#L193",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1373,2021-10-08T00:20:51Z,2021-10-08T12:46:23Z,2021-10-08T12:49:26Z,CLOSED,False,2,2,1,https://github.com/vaizki,Do not manage TLS sockets unless we are forwarding to them,1,[],https://github.com/sipwise/rtpengine/pull/1373,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1373#issuecomment-938604506,"If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.","Ok that's what I thought. AFAIK start forwarding is about TLS forwarding, not the Unix socket forwarding.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1373,2021-10-08T00:20:51Z,2021-10-08T12:46:23Z,2021-10-08T12:49:26Z,CLOSED,False,2,2,1,https://github.com/vaizki,Do not manage TLS sockets unless we are forwarding to them,1,[],https://github.com/sipwise/rtpengine/pull/1373,https://github.com/vaizki,5,https://github.com/sipwise/rtpengine/pull/1373#issuecomment-938612753,"If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.","Ok that's what I thought. AFAIK start forwarding is about TLS forwarding, not the Unix socket forwarding.

Oh. Maybe I shouldn't do this at 3 am... So unix socket forwarding is always on for all recorded calls and applies to all streams.  Looks like I need find another way to forward only part of the streams. If I close the socket from the other side, there is a constant stream of error-level messages to the log for the rest of the call (one message per RTP packet). So I need to consume every packet even when I know from metadata that I don't need this call.
This PR is dead then, instead there should be an error message if forwarding is started without a valid TLS config.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1373,2021-10-08T00:20:51Z,2021-10-08T12:46:23Z,2021-10-08T12:49:26Z,CLOSED,False,2,2,1,https://github.com/vaizki,Do not manage TLS sockets unless we are forwarding to them,1,[],https://github.com/sipwise/rtpengine/pull/1373,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/1373#issuecomment-938616657,"If file output is enabled simultaneously with --forward-to, then TLS forwarding socket code is entered even though the TLS endpoint is not configured, resulting in a null pointer dereference and segfault. PR adds checks that a non-zero TLS endpoint port has been provided on the command line before managing sockets.",You can open a PR to add support for start/stop forwarding for Unix socket forwarding,True,{'THUMBS_UP': ['https://github.com/vaizki']}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1388,2021-10-22T19:15:59Z,2021-10-23T00:24:39Z,2021-10-23T00:24:39Z,MERGED,True,14,6,5,https://github.com/micmac1,Add support for time64 libcs,1,[],https://github.com/sipwise/rtpengine/pull/1388,https://github.com/micmac1,1,https://github.com/sipwise/rtpengine/pull/1388,"libcs are implementing changes to fix the year 2038 issue on 32 bit
platforms (see [1]). musl libc already went ahead and implemented it,
starting with musl-1.2.0 (see [2]).
This commit adds two new definitions to lib/loglib.h:
TIME_T_INT_FMT
TIME_T_UINT_FMT
If __USE_TIME_BITS64 is defined (by a time64 libc, see [1]), they're set
to the proper conversions for type int64_t, PRId64 and PRIu64
respectively. If __USE_TIME_BITS64 is not defined, the status quo
remains unchanged (""%ld"" and ""%lu"" are used).
The new definitions are used in the different parts of rtpengine, where
appropriate.
These changes get rid of the new warnings that appeared with musl-1.2.0.
Below an example warning:
In file included from ./log.h:6,
from ../include/obj.h:94,
from ../include/media_socket.h:9,
from ../include/call.h:26,
from ../include/redis.h:15,
from redis.c:1:
redis.c: In function 'redis_check_conn':
../lib/loglib.h:56:30: warning: format '%ld' expects argument of type 'long int', but argument 5 has type 'time_t' {aka 'long long int'} [-Wformat=]
56 |                 _ilog(prio, ""[%s] "" fmt, log_level_names[system], ##VA_ARGS);                                              
|                              ^~~~~~~
../lib/loglib.h:64:39: note: in expansion of macro 'ilogsn'
64 | #define ilogs(system, prio, fmt, ...) ilogsn(log_level_index ## system, prio, fmt, ##VA_ARGS)
|                                       ^~~~~~
../lib/loglib.h:63:30: note: in expansion of macro 'ilogs'
63 | #define ilog(prio, fmt, ...) ilogs(core, prio, fmt, ##VA_ARGS)
|                              ^~~~~
redis.c:887:17: note: in expansion of macro 'ilog'
887 |                 ilog(LOG_WARNING, ""Redis server %s is disabled. Don't try RE-Establishing for %ld more seconds"",
|                 ^~~~
[1] https://sourceware.org/glibc/wiki/Y2038ProofnessDesign
[2] https://musl.libc.org/time64.html
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net","libcs are implementing changes to fix the year 2038 issue on 32 bit
platforms (see [1]). musl libc already went ahead and implemented it,
starting with musl-1.2.0 (see [2]).
This commit adds two new definitions to lib/loglib.h:
TIME_T_INT_FMT
TIME_T_UINT_FMT
If __USE_TIME_BITS64 is defined (by a time64 libc, see [1]), they're set
to the proper conversions for type int64_t, PRId64 and PRIu64
respectively. If __USE_TIME_BITS64 is not defined, the status quo
remains unchanged (""%ld"" and ""%lu"" are used).
The new definitions are used in the different parts of rtpengine, where
appropriate.
These changes get rid of the new warnings that appeared with musl-1.2.0.
Below an example warning:
In file included from ./log.h:6,
from ../include/obj.h:94,
from ../include/media_socket.h:9,
from ../include/call.h:26,
from ../include/redis.h:15,
from redis.c:1:
redis.c: In function 'redis_check_conn':
../lib/loglib.h:56:30: warning: format '%ld' expects argument of type 'long int', but argument 5 has type 'time_t' {aka 'long long int'} [-Wformat=]
56 |                 _ilog(prio, ""[%s] "" fmt, log_level_names[system], ##VA_ARGS);                                              
|                              ^~~~~~~
../lib/loglib.h:64:39: note: in expansion of macro 'ilogsn'
64 | #define ilogs(system, prio, fmt, ...) ilogsn(log_level_index ## system, prio, fmt, ##VA_ARGS)
|                                       ^~~~~~
../lib/loglib.h:63:30: note: in expansion of macro 'ilogs'
63 | #define ilog(prio, fmt, ...) ilogs(core, prio, fmt, ##VA_ARGS)
|                              ^~~~~
redis.c:887:17: note: in expansion of macro 'ilog'
887 |                 ilog(LOG_WARNING, ""Redis server %s is disabled. Don't try RE-Establishing for %ld more seconds"",
|                 ^~~~
[1] https://sourceware.org/glibc/wiki/Y2038ProofnessDesign
[2] https://musl.libc.org/time64.html
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1388,2021-10-22T19:15:59Z,2021-10-23T00:24:39Z,2021-10-23T00:24:39Z,MERGED,True,14,6,5,https://github.com/micmac1,Add support for time64 libcs,1,[],https://github.com/sipwise/rtpengine/pull/1388,https://github.com/micmac1,2,https://github.com/sipwise/rtpengine/pull/1388#issuecomment-949901937,"libcs are implementing changes to fix the year 2038 issue on 32 bit
platforms (see [1]). musl libc already went ahead and implemented it,
starting with musl-1.2.0 (see [2]).
This commit adds two new definitions to lib/loglib.h:
TIME_T_INT_FMT
TIME_T_UINT_FMT
If __USE_TIME_BITS64 is defined (by a time64 libc, see [1]), they're set
to the proper conversions for type int64_t, PRId64 and PRIu64
respectively. If __USE_TIME_BITS64 is not defined, the status quo
remains unchanged (""%ld"" and ""%lu"" are used).
The new definitions are used in the different parts of rtpengine, where
appropriate.
These changes get rid of the new warnings that appeared with musl-1.2.0.
Below an example warning:
In file included from ./log.h:6,
from ../include/obj.h:94,
from ../include/media_socket.h:9,
from ../include/call.h:26,
from ../include/redis.h:15,
from redis.c:1:
redis.c: In function 'redis_check_conn':
../lib/loglib.h:56:30: warning: format '%ld' expects argument of type 'long int', but argument 5 has type 'time_t' {aka 'long long int'} [-Wformat=]
56 |                 _ilog(prio, ""[%s] "" fmt, log_level_names[system], ##VA_ARGS);                                              
|                              ^~~~~~~
../lib/loglib.h:64:39: note: in expansion of macro 'ilogsn'
64 | #define ilogs(system, prio, fmt, ...) ilogsn(log_level_index ## system, prio, fmt, ##VA_ARGS)
|                                       ^~~~~~
../lib/loglib.h:63:30: note: in expansion of macro 'ilogs'
63 | #define ilog(prio, fmt, ...) ilogs(core, prio, fmt, ##VA_ARGS)
|                              ^~~~~
redis.c:887:17: note: in expansion of macro 'ilog'
887 |                 ilog(LOG_WARNING, ""Redis server %s is disabled. Don't try RE-Establishing for %ld more seconds"",
|                 ^~~~
[1] https://sourceware.org/glibc/wiki/Y2038ProofnessDesign
[2] https://musl.libc.org/time64.html
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net","Hello Richard,
I'm not a programmer, but I think the ""%06lu"" in daemon/cdr.c may be a typo? If so (and if it should read ""%06ld"") then I can change the commit a bit and remove the TIME_T_UINT_FMT definition.
Kind regards,
Seb",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1388,2021-10-22T19:15:59Z,2021-10-23T00:24:39Z,2021-10-23T00:24:39Z,MERGED,True,14,6,5,https://github.com/micmac1,Add support for time64 libcs,1,[],https://github.com/sipwise/rtpengine/pull/1388,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1388#issuecomment-949978191,"libcs are implementing changes to fix the year 2038 issue on 32 bit
platforms (see [1]). musl libc already went ahead and implemented it,
starting with musl-1.2.0 (see [2]).
This commit adds two new definitions to lib/loglib.h:
TIME_T_INT_FMT
TIME_T_UINT_FMT
If __USE_TIME_BITS64 is defined (by a time64 libc, see [1]), they're set
to the proper conversions for type int64_t, PRId64 and PRIu64
respectively. If __USE_TIME_BITS64 is not defined, the status quo
remains unchanged (""%ld"" and ""%lu"" are used).
The new definitions are used in the different parts of rtpengine, where
appropriate.
These changes get rid of the new warnings that appeared with musl-1.2.0.
Below an example warning:
In file included from ./log.h:6,
from ../include/obj.h:94,
from ../include/media_socket.h:9,
from ../include/call.h:26,
from ../include/redis.h:15,
from redis.c:1:
redis.c: In function 'redis_check_conn':
../lib/loglib.h:56:30: warning: format '%ld' expects argument of type 'long int', but argument 5 has type 'time_t' {aka 'long long int'} [-Wformat=]
56 |                 _ilog(prio, ""[%s] "" fmt, log_level_names[system], ##VA_ARGS);                                              
|                              ^~~~~~~
../lib/loglib.h:64:39: note: in expansion of macro 'ilogsn'
64 | #define ilogs(system, prio, fmt, ...) ilogsn(log_level_index ## system, prio, fmt, ##VA_ARGS)
|                                       ^~~~~~
../lib/loglib.h:63:30: note: in expansion of macro 'ilogs'
63 | #define ilog(prio, fmt, ...) ilogs(core, prio, fmt, ##VA_ARGS)
|                              ^~~~~
redis.c:887:17: note: in expansion of macro 'ilog'
887 |                 ilog(LOG_WARNING, ""Redis server %s is disabled. Don't try RE-Establishing for %ld more seconds"",
|                 ^~~~
[1] https://sourceware.org/glibc/wiki/Y2038ProofnessDesign
[2] https://musl.libc.org/time64.html
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net","I'm not a programmer, but I think the ""%06lu"" in daemon/cdr.c may be a typo? If so (and if it should read ""%06ld"") then I can change the commit a bit and remove the TIME_T_UINT_FMT definition.

Yes, considering that time_t is signed, the %u format version is not needed.
There also seems to be __TIMESIZE == 64 as a test for this? Not sure how different libcs stand on this...",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1388,2021-10-22T19:15:59Z,2021-10-23T00:24:39Z,2021-10-23T00:24:39Z,MERGED,True,14,6,5,https://github.com/micmac1,Add support for time64 libcs,1,[],https://github.com/sipwise/rtpengine/pull/1388,https://github.com/micmac1,4,https://github.com/sipwise/rtpengine/pull/1388#issuecomment-950006034,"libcs are implementing changes to fix the year 2038 issue on 32 bit
platforms (see [1]). musl libc already went ahead and implemented it,
starting with musl-1.2.0 (see [2]).
This commit adds two new definitions to lib/loglib.h:
TIME_T_INT_FMT
TIME_T_UINT_FMT
If __USE_TIME_BITS64 is defined (by a time64 libc, see [1]), they're set
to the proper conversions for type int64_t, PRId64 and PRIu64
respectively. If __USE_TIME_BITS64 is not defined, the status quo
remains unchanged (""%ld"" and ""%lu"" are used).
The new definitions are used in the different parts of rtpengine, where
appropriate.
These changes get rid of the new warnings that appeared with musl-1.2.0.
Below an example warning:
In file included from ./log.h:6,
from ../include/obj.h:94,
from ../include/media_socket.h:9,
from ../include/call.h:26,
from ../include/redis.h:15,
from redis.c:1:
redis.c: In function 'redis_check_conn':
../lib/loglib.h:56:30: warning: format '%ld' expects argument of type 'long int', but argument 5 has type 'time_t' {aka 'long long int'} [-Wformat=]
56 |                 _ilog(prio, ""[%s] "" fmt, log_level_names[system], ##VA_ARGS);                                              
|                              ^~~~~~~
../lib/loglib.h:64:39: note: in expansion of macro 'ilogsn'
64 | #define ilogs(system, prio, fmt, ...) ilogsn(log_level_index ## system, prio, fmt, ##VA_ARGS)
|                                       ^~~~~~
../lib/loglib.h:63:30: note: in expansion of macro 'ilogs'
63 | #define ilog(prio, fmt, ...) ilogs(core, prio, fmt, ##VA_ARGS)
|                              ^~~~~
redis.c:887:17: note: in expansion of macro 'ilog'
887 |                 ilog(LOG_WARNING, ""Redis server %s is disabled. Don't try RE-Establishing for %ld more seconds"",
|                 ^~~~
[1] https://sourceware.org/glibc/wiki/Y2038ProofnessDesign
[2] https://musl.libc.org/time64.html
Signed-off-by: Sebastian Kemper sebastian_ml@gmx.net","Yes, considering that time_t is signed, the %u format version is not needed.

Thanks, commit amended.

There also seems to be __TIMESIZE == 64 as a test for this? Not sure how different libcs stand on this...

In the glibc article [1] they suggest to check if __USE_TIME_BITS64 is defined. __TIMESIZE is not mentioned. I grepped musl for __TIMESIZE, but it didn't find it at all.
I think for now checking for __USE_TIME_BITS64 is sufficient.
[1] https://sourceware.org/glibc/wiki/Y2038ProofnessDesign",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1396,2021-11-11T11:52:37Z,2021-11-23T13:49:47Z,2021-11-23T13:49:47Z,MERGED,True,91,152,9,https://github.com/avoylenko,Tune package building for Enterprise Linux,1,[],https://github.com/sipwise/rtpengine/pull/1396,https://github.com/avoylenko,1,https://github.com/sipwise/rtpengine/pull/1396,"The SPEC file is fixed to follow the official building guide, RPM metadata updated. Both services configured for restarting in case of a service failure.","The SPEC file is fixed to follow the official building guide, RPM metadata updated. Both services configured for restarting in case of a service failure.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1400,2021-11-17T02:17:37Z,2021-11-24T15:03:01Z,2021-11-24T15:03:01Z,MERGED,True,36,3,6,https://github.com/john08burke,Add support for endpoint-learning on a per call basis,1,[],https://github.com/sipwise/rtpengine/pull/1400,https://github.com/john08burke,1,https://github.com/sipwise/rtpengine/pull/1400,"Currently, the endpoint-learning algorithm is a global config and set at startup.  This PR adds the ability to override the startup config on a per-call basis.  The reason behind wanting per-call control of the EL algo was driven by this discussion on the mailing list.  In short, I found that on some of the newer kernels, userspace can be quite CPU expensive when compared to older versions.  By having some per-call control, this gives the developer the ability to optimize CPU allocation by minimizing / eliminating any userspace processing (ex: traffic that is known to advertise public SDP doesn't need 3 sec user learning phase).
This is my first PR on this project, so let me know if I was way off base with anything... or if you want anything refactored!","Currently, the endpoint-learning algorithm is a global config and set at startup.  This PR adds the ability to override the startup config on a per-call basis.  The reason behind wanting per-call control of the EL algo was driven by this discussion on the mailing list.  In short, I found that on some of the newer kernels, userspace can be quite CPU expensive when compared to older versions.  By having some per-call control, this gives the developer the ability to optimize CPU allocation by minimizing / eliminating any userspace processing (ex: traffic that is known to advertise public SDP doesn't need 3 sec user learning phase).
This is my first PR on this project, so let me know if I was way off base with anything... or if you want anything refactored!",True,{'THUMBS_UP': ['https://github.com/Nibreos']}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1400,2021-11-17T02:17:37Z,2021-11-24T15:03:01Z,2021-11-24T15:03:01Z,MERGED,True,36,3,6,https://github.com/john08burke,Add support for endpoint-learning on a per call basis,1,[],https://github.com/sipwise/rtpengine/pull/1400,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1400#issuecomment-976593626,"Currently, the endpoint-learning algorithm is a global config and set at startup.  This PR adds the ability to override the startup config on a per-call basis.  The reason behind wanting per-call control of the EL algo was driven by this discussion on the mailing list.  In short, I found that on some of the newer kernels, userspace can be quite CPU expensive when compared to older versions.  By having some per-call control, this gives the developer the ability to optimize CPU allocation by minimizing / eliminating any userspace processing (ex: traffic that is known to advertise public SDP doesn't need 3 sec user learning phase).
This is my first PR on this project, so let me know if I was way off base with anything... or if you want anything refactored!","Hi,
First off, thanks for adding this feature.
Looking through the code, I think this commit is a lot more complicated than it needs to be :)
My suggestions would be:

Leave enum endpoint_learning as it is (in main.h), including the option struct rtpengine_config (except maybe for renaming it). This would then be the default value, and take the role of el_option_def. The same enum type can then also be used in struct sdp_ng_flags without having to redefine it.
Use that same enum type for el_flags in struct packet_stream. There's no need for this to be a bit field as only one option can be set at any given time. This eliminates the PS_EL defines and the bit field test stuff.
Initialising el_option in call_ng_flags_init() from the default setting (would then be rtpe_config.endpoint_learning) is fine.
If you want to be extra fancy (optional exercise for the reader 😆), you can unify the string parsing done in options() with the parsing done in ng_el_option() into a single function to eliminate code duplication.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1400,2021-11-17T02:17:37Z,2021-11-24T15:03:01Z,2021-11-24T15:03:01Z,MERGED,True,36,3,6,https://github.com/john08burke,Add support for endpoint-learning on a per call basis,1,[],https://github.com/sipwise/rtpengine/pull/1400,https://github.com/john08burke,3,https://github.com/sipwise/rtpengine/pull/1400#issuecomment-977103702,"Currently, the endpoint-learning algorithm is a global config and set at startup.  This PR adds the ability to override the startup config on a per-call basis.  The reason behind wanting per-call control of the EL algo was driven by this discussion on the mailing list.  In short, I found that on some of the newer kernels, userspace can be quite CPU expensive when compared to older versions.  By having some per-call control, this gives the developer the ability to optimize CPU allocation by minimizing / eliminating any userspace processing (ex: traffic that is known to advertise public SDP doesn't need 3 sec user learning phase).
This is my first PR on this project, so let me know if I was way off base with anything... or if you want anything refactored!","Hey @rfuchs, just pushed updates w/ your recommendations.  Indeed a much simpler solution!  My tests checked out, so let me know if any additions mods are required!",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1403,2021-11-22T08:29:39Z,,2021-11-23T15:46:25Z,OPEN,False,100,5,6,https://github.com/arnd-s,Various changes of RTP timeout handling to handle timeouts on single streams,1,[],https://github.com/sipwise/rtpengine/pull/1403,https://github.com/arnd-s,1,https://github.com/sipwise/rtpengine/pull/1403,"introduced timeout-mode parameter to control mode of operation off/any/all during session
off - don't monitor timeouts / turn monitoring off
any - react if a timeout occur on any RTP stream
all - react if timeout occur on all streams (old behavior)
Don't monitor RTCP streams for timeout (to prevent false alarms if RTP timeout is very low)

This patch introduces primary the possibility to react on RTP timeouts of a single stream.
During call establishment / early-media, there is often only one stream direction active. To prevent false alarms
for this case, the timeout-mode parameter for the call-interface was added. The logic is, that a call starts with
a disabled timeout monitoring and when the session is established in both directions (for example 200OK Reply for
an answer) the timeout will be activated.
When activated, timeout_activated element of struct call will be set to earliest possible timeout occurence
(activation time + timeout time). This should prevent false alarms immediatliy after session establishment
There is still an unresolved problem at the moment. Even timeout_activated is used, it sometimes happens
that on first check a timeout is detected. This occurs even, when timeout value (and timeout_activated
in succession) is increased.
To circumvent this, missed_packet_counter of struct packet_stream is used, so that the checks fails on the third
missed package in a row.
Signed-off-by: Arnd Schmitter arnd@lgcm.de","introduced timeout-mode parameter to control mode of operation off/any/all during session
off - don't monitor timeouts / turn monitoring off
any - react if a timeout occur on any RTP stream
all - react if timeout occur on all streams (old behavior)
Don't monitor RTCP streams for timeout (to prevent false alarms if RTP timeout is very low)

This patch introduces primary the possibility to react on RTP timeouts of a single stream.
During call establishment / early-media, there is often only one stream direction active. To prevent false alarms
for this case, the timeout-mode parameter for the call-interface was added. The logic is, that a call starts with
a disabled timeout monitoring and when the session is established in both directions (for example 200OK Reply for
an answer) the timeout will be activated.
When activated, timeout_activated element of struct call will be set to earliest possible timeout occurence
(activation time + timeout time). This should prevent false alarms immediatliy after session establishment
There is still an unresolved problem at the moment. Even timeout_activated is used, it sometimes happens
that on first check a timeout is detected. This occurs even, when timeout value (and timeout_activated
in succession) is increased.
To circumvent this, missed_packet_counter of struct packet_stream is used, so that the checks fails on the third
missed package in a row.
Signed-off-by: Arnd Schmitter arnd@lgcm.de",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1403,2021-11-22T08:29:39Z,,2021-11-23T15:46:25Z,OPEN,False,100,5,6,https://github.com/arnd-s,Various changes of RTP timeout handling to handle timeouts on single streams,1,[],https://github.com/sipwise/rtpengine/pull/1403,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1403#issuecomment-976663545,"introduced timeout-mode parameter to control mode of operation off/any/all during session
off - don't monitor timeouts / turn monitoring off
any - react if a timeout occur on any RTP stream
all - react if timeout occur on all streams (old behavior)
Don't monitor RTCP streams for timeout (to prevent false alarms if RTP timeout is very low)

This patch introduces primary the possibility to react on RTP timeouts of a single stream.
During call establishment / early-media, there is often only one stream direction active. To prevent false alarms
for this case, the timeout-mode parameter for the call-interface was added. The logic is, that a call starts with
a disabled timeout monitoring and when the session is established in both directions (for example 200OK Reply for
an answer) the timeout will be activated.
When activated, timeout_activated element of struct call will be set to earliest possible timeout occurence
(activation time + timeout time). This should prevent false alarms immediatliy after session establishment
There is still an unresolved problem at the moment. Even timeout_activated is used, it sometimes happens
that on first check a timeout is detected. This occurs even, when timeout value (and timeout_activated
in succession) is increased.
To circumvent this, missed_packet_counter of struct packet_stream is used, so that the checks fails on the third
missed package in a row.
Signed-off-by: Arnd Schmitter arnd@lgcm.de","I'm not sure about your exact use case, but I'm wondering if this can be solved in a more automatic way? (Not opposed to having this as a settable value, but we could do both...)
Since rtpengine has a vague concept of which sides/parties to expect RTP from, and so I'm wondering if the timeout check can simply be made conditional on that? (There's some exceptions here, e.g. there's no distinction between an answer from a 18x and an answer from a 200, so that could be something else that could be added new)

There is still an unresolved problem at the moment. Even timeout_activated is used, it sometimes happens that on first check a timeout is detected. This occurs even, when timeout value (and timeout_activated in succession) is increased. To circumvent this, missed_packet_counter of struct packet_stream is used, so that the checks fails on the third missed package in a row.

I did come across this issue in the past and thought that resetting the last_packet timestamp to the current time during a signalling event could solve this. Or perhaps taking the last_signal timestamp into account somehow. What do you think?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1403,2021-11-22T08:29:39Z,,2021-11-23T15:46:25Z,OPEN,False,100,5,6,https://github.com/arnd-s,Various changes of RTP timeout handling to handle timeouts on single streams,1,[],https://github.com/sipwise/rtpengine/pull/1403,https://github.com/arnd-s,3,https://github.com/sipwise/rtpengine/pull/1403#issuecomment-976689402,"introduced timeout-mode parameter to control mode of operation off/any/all during session
off - don't monitor timeouts / turn monitoring off
any - react if a timeout occur on any RTP stream
all - react if timeout occur on all streams (old behavior)
Don't monitor RTCP streams for timeout (to prevent false alarms if RTP timeout is very low)

This patch introduces primary the possibility to react on RTP timeouts of a single stream.
During call establishment / early-media, there is often only one stream direction active. To prevent false alarms
for this case, the timeout-mode parameter for the call-interface was added. The logic is, that a call starts with
a disabled timeout monitoring and when the session is established in both directions (for example 200OK Reply for
an answer) the timeout will be activated.
When activated, timeout_activated element of struct call will be set to earliest possible timeout occurence
(activation time + timeout time). This should prevent false alarms immediatliy after session establishment
There is still an unresolved problem at the moment. Even timeout_activated is used, it sometimes happens
that on first check a timeout is detected. This occurs even, when timeout value (and timeout_activated
in succession) is increased.
To circumvent this, missed_packet_counter of struct packet_stream is used, so that the checks fails on the third
missed package in a row.
Signed-off-by: Arnd Schmitter arnd@lgcm.de","Since rtpengine has a vague concept of which sides/parties to expect RTP from, and so I'm wondering if the timeout check can simply be made conditional on that? (There's some exceptions here, e.g. there's no distinction between an answer from a 18x and an answer from a 200, so that could be something else that could be added new)

In our use case, UAC often don't send any RTP traffic until the receive of a 200 answer. So in case of a sdp-reply via 18x a timeout will occur.
It's also in my experience feasible to have more control in case of call forking scenarios with multiple early media streams or to disable timeouts during call hold.


There is still an unresolved problem at the moment. Even timeout_activated is used, it sometimes happens that on first check a timeout is detected. This occurs even, when timeout value (and timeout_activated in succession) is increased. To circumvent this, missed_packet_counter of struct packet_stream is used, so that the checks fails on the third missed package in a row.



I did come across this issue in the past and thought that resetting the last_packet timestamp to the current time during a signalling event could solve this. Or perhaps taking the last_signal timestamp into account somehow. What do you think?

I'll look into it and try if i find a better solution.
Please be aware, that this PR should in my opinion get extensive testing from users with other use cases before merging. Especially with forking scenarios or more than one stream in each direction. I also don't tested it in webrtc scenarios.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1407,2021-12-02T14:41:12Z,2021-12-02T16:11:05Z,2021-12-02T16:11:06Z,CLOSED,False,102334,10120,476,https://github.com/daknadnane,RTPengine remote syslog server ,2192,[],https://github.com/sipwise/rtpengine/pull/1407,https://github.com/daknadnane,1,https://github.com/sipwise/rtpengine/pull/1407,"Hi ,
is  possible to configure rtpengine to send log to remote syslog server","Hi ,
is  possible to configure rtpengine to send log to remote syslog server",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1407,2021-12-02T14:41:12Z,2021-12-02T16:11:05Z,2021-12-02T16:11:06Z,CLOSED,False,102334,10120,476,https://github.com/daknadnane,RTPengine remote syslog server ,2192,[],https://github.com/sipwise/rtpengine/pull/1407,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1407#issuecomment-984773287,"Hi ,
is  possible to configure rtpengine to send log to remote syslog server","No, not directly. You can do this through your system's syslog config.
Questions should be directed to our mailing list: https://rtpengine.com/mailing-list",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1413,2021-12-16T09:11:34Z,2021-12-20T15:11:17Z,2021-12-20T15:11:18Z,MERGED,True,16,16,2,https://github.com/smititelu,Add 'seconds' to some stats duration,1,[],https://github.com/sipwise/rtpengine/pull/1413,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1413,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1413,2021-12-16T09:11:34Z,2021-12-20T15:11:17Z,2021-12-20T15:11:18Z,MERGED,True,16,16,2,https://github.com/smititelu,Add 'seconds' to some stats duration,1,[],https://github.com/sipwise/rtpengine/pull/1413,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1413#issuecomment-995975128,,"You need to adjust one of the tests to expect the new format, e.g. at https://github.com/sipwise/rtpengine/blob/master/t/test-stats.c#L431 and https://github.com/sipwise/rtpengine/blob/master/t/test-stats.c#L441 and all other instances in that file.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1421,2021-12-30T15:44:52Z,2021-12-30T15:46:05Z,2022-01-19T23:48:53Z,MERGED,True,1,1,1,https://github.com/ryfow,Fix README typo,1,[],https://github.com/sipwise/rtpengine/pull/1421,https://github.com/ryfow,1,https://github.com/sipwise/rtpengine/pull/1421,my -> may,my -> may,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1428,2022-01-11T09:15:55Z,2022-01-12T15:13:30Z,2022-01-12T15:13:30Z,MERGED,True,18,0,5,https://github.com/smititelu,Add new graphite-timeout parameter,1,[],https://github.com/sipwise/rtpengine/pull/1428,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1428,"Needed to be able to set graphite socket timeout.
Useful when one wants rtpengine to force the graphite connection
to fail faster, in case graphite server gets filtered while
connection is ongoing.","Needed to be able to set graphite socket timeout.
Useful when one wants rtpengine to force the graphite connection
to fail faster, in case graphite server gets filtered while
connection is ongoing.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1428,2022-01-11T09:15:55Z,2022-01-12T15:13:30Z,2022-01-12T15:13:30Z,MERGED,True,18,0,5,https://github.com/smititelu,Add new graphite-timeout parameter,1,[],https://github.com/sipwise/rtpengine/pull/1428,https://github.com/smititelu,2,https://github.com/sipwise/rtpengine/pull/1428#issuecomment-1010880558,"Needed to be able to set graphite socket timeout.
Useful when one wants rtpengine to force the graphite connection
to fail faster, in case graphite server gets filtered while
connection is ongoing.","Thanks for the feedback! PR updated.
I've tested setting socket option right after connect_socket_nb() and it works, even when graphite server is initially filtered.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1429,2022-01-11T12:12:16Z,2022-01-12T15:53:49Z,2022-01-12T15:53:49Z,CLOSED,False,4,0,1,https://github.com/hdikme,Enabled sending total statistics to graphite,1,[],https://github.com/sipwise/rtpengine/pull/1429,https://github.com/hdikme,1,https://github.com/sipwise/rtpengine/pull/1429,Enabled sending also the total statistics to graphite by a config variable called graphite_send_totalstats.,Enabled sending also the total statistics to graphite by a config variable called graphite_send_totalstats.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1429,2022-01-11T12:12:16Z,2022-01-12T15:53:49Z,2022-01-12T15:53:49Z,CLOSED,False,4,0,1,https://github.com/hdikme,Enabled sending total statistics to graphite,1,[],https://github.com/sipwise/rtpengine/pull/1429,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1429#issuecomment-1010202021,Enabled sending also the total statistics to graphite by a config variable called graphite_send_totalstats.,"This is only about the NG command stats, isn't it? And they're not split up by proxy, so this metric should already be available without having to go through the list. For a total count of all commands you should look at rtpe_stats_cumulative.ng_commands[command_idx]. So something like this (untested)
	if (rtpe_config.graphite_send_totalstats) {
		for (int i = 0; i < NGC_COUNT; i++) {
			GPF(""total%scount %"" PRIu64, ng_command_strings_short[i], atomic64_get(&rtpe_stats_cumulative.ng_commands[i]));
		}
	}

Also I think it should be safe to always add these to the output without needing a new config option 🤷",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/razvancrainea,1,https://github.com/sipwise/rtpengine/pull/1430,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.","When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1430#issuecomment-1011376276,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.","Hm that's breaking some of the tests :)
In particular a ""publish"" for a sendonly stream now produces an inactive SDP on the ""subscribe"" leg. I think the send/recv logic is reversed here.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/rfuchs,3,https://github.com/sipwise/rtpengine/pull/1430#issuecomment-1011412428,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.","No worries, thanks. Do you want to add some tests for this as well? If not then I'll add them myself.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/razvancrainea,4,https://github.com/sipwise/rtpengine/pull/1430#issuecomment-1011890997,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.","Sure, I'll give it a try.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/razvancrainea,5,https://github.com/sipwise/rtpengine/pull/1430#issuecomment-1012289012,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.",Just committed a test for pausing and resume a single stream. Let me know if that's OK.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/1430#issuecomment-1012399110,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.","Perfect, thank you",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1430,2022-01-12T17:32:21Z,2022-01-13T18:38:43Z,2022-01-14T10:35:26Z,CLOSED,False,235,1,2,https://github.com/razvancrainea,Fix `subscribe request` SDP media direction,3,[],https://github.com/sipwise/rtpengine/pull/1430,https://github.com/rfuchs,7,https://github.com/sipwise/rtpengine/pull/1430#issuecomment-1012405768,"When building the SDP for a subscribe request command, take into
consideration the media direction of the source stream - if stream is
recvonly, then we do not have anything to send, thus the direction
should be advertised as inactive, rather than sendonly.",Merged as 5fc658e,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1439,2022-02-07T07:51:27Z,2022-02-07T13:06:02Z,2022-02-07T13:06:02Z,MERGED,True,3,3,1,https://github.com/avoylenko,Fix RPM build process,2,[],https://github.com/sipwise/rtpengine/pull/1439,https://github.com/avoylenko,1,https://github.com/sipwise/rtpengine/pull/1439,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1440,2022-02-08T07:58:03Z,2022-02-08T12:14:03Z,2022-02-08T12:14:43Z,MERGED,True,27,22,5,https://github.com/avoylenko,Run services as non root user,1,[],https://github.com/sipwise/rtpengine/pull/1440,https://github.com/avoylenko,1,https://github.com/sipwise/rtpengine/pull/1440,"*) Run services as a user created during RPM installation
*) Add perl-Config-Tiny dependency
*) Disable automatic kernel module loading for RHEL 7","*) Run services as a user created during RPM installation
*) Add perl-Config-Tiny dependency
*) Disable automatic kernel module loading for RHEL 7",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1440,2022-02-08T07:58:03Z,2022-02-08T12:14:03Z,2022-02-08T12:14:43Z,MERGED,True,27,22,5,https://github.com/avoylenko,Run services as non root user,1,[],https://github.com/sipwise/rtpengine/pull/1440,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1440#issuecomment-1032543799,"*) Run services as a user created during RPM installation
*) Add perl-Config-Tiny dependency
*) Disable automatic kernel module loading for RHEL 7","Thanks for taking care of the RPM packaging.
FYI we also include non-NGCP packaging for Debian now, so you could omit the ngcp prefixes from the RPM packages if you prefer.",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1445,,,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1445#issuecomment-1036180415,,You sure about this logic? This seems to make the result conditional on the exit code from the echo and not the test itself.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1445#issuecomment-1036445034,,"Thanks for the notice! Indeed there is a flaw in my logic. I am testing now by forcing a test to fail inside the code (and not just inside t/Makefile).
I want to ask you if there is really a need to do ""exit 1"" when a test fails and stop building final deb?
Thank you,
Stefan",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/rfuchs,4,https://github.com/sipwise/rtpengine/pull/1445#issuecomment-1036465532,,"I want to ask you if there is really a need to do ""exit 1"" when a test fails and stop building final deb?

Well, yes and no, depends on your workflow I guess. During development I use these tests to detect regressions and so I want to see some kind of build failure. During normal packaging I suppose you could continue building even if the tests are failing, but either way it indicates some kind of trouble that should be investigated. (I believe the Debian build tools have a flag to disable the tests for package building purposes.)
Do you find that some tests are unstable or why are you asking?",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/smititelu,5,https://github.com/sipwise/rtpengine/pull/1445#issuecomment-1036539059,,"No, all tests run ok.
What I am also trying to achieve, besides adding fail/succeed info for each test, is to run all tests, no matter how many fail (i.e. don't ""exit 1"" at first failed test). Thus, output can be parsed and a summary can be done.
Let me know what you think of the PR right now. All tests should run. Build should fail if at least one test fails. Tested it by forcing 1 tests to fail in code (aes-crypt.c).
Thanks,
Stefan",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/rfuchs,6,https://github.com/sipwise/rtpengine/pull/1445#issuecomment-1036590379,,"Ok that looks good. If you want to be even more verbose, you could collect the names of the failed tests in a variable and then report them all at the end in one go. Something like
failed=""""; \
...
else echo `date +""%Y-%m-%d %H:%M:%S""` test $$x: failed ; failed=""$$failed $$x""; \
...
if [ -n ""$$failed"" ]; then \
echo ""Tests failed: $$failed""; \
exit 1; \
fi
...

should work I think",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1445,2022-02-11T11:31:06Z,2022-02-17T00:52:47Z,2022-02-17T00:52:48Z,MERGED,True,13,1,1,https://github.com/smititelu,Add more info about ok/failed t tests,1,[],https://github.com/sipwise/rtpengine/pull/1445,https://github.com/smititelu,7,https://github.com/sipwise/rtpengine/pull/1445#issuecomment-1038822676,,Updated PR. Tested it with 2 failing tests and it works.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1446,2022-02-11T13:29:14Z,2022-02-11T17:10:42Z,2022-02-11T17:10:42Z,MERGED,True,1,1,1,https://github.com/avoylenko,Fix segfault when 'tls-send-to' option is not set,1,[],https://github.com/sipwise/rtpengine/pull/1446,https://github.com/avoylenko,1,https://github.com/sipwise/rtpengine/pull/1446,Check if 'tls-send-to' option is set before starting a TLS connection.,Check if 'tls-send-to' option is set before starting a TLS connection.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1449,2022-02-14T14:07:25Z,2022-02-15T08:29:40Z,2022-02-15T08:29:49Z,CLOSED,False,2,0,1,https://github.com/smititelu,More info about kernelized stream,1,[],https://github.com/sipwise/rtpengine/pull/1449,https://github.com/smititelu,1,https://github.com/sipwise/rtpengine/pull/1449,"Adds call-id and port log prefix, for each kernelized stream. Please let me know what you think.
Thanks,
Stefan","Adds call-id and port log prefix, for each kernelized stream. Please let me know what you think.
Thanks,
Stefan",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1449,2022-02-14T14:07:25Z,2022-02-15T08:29:40Z,2022-02-15T08:29:49Z,CLOSED,False,2,0,1,https://github.com/smititelu,More info about kernelized stream,1,[],https://github.com/sipwise/rtpengine/pull/1449,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1449#issuecomment-1039522074,"Adds call-id and port log prefix, for each kernelized stream. Please let me know what you think.
Thanks,
Stefan","Is this because the log prefixes were missing in these log lines? Because that should have been fixed by 6d1dfab
Or do you want to add extra info? In that case the log_info_stream_fd() should be paired with a log_info_pop() (also see the commit referenced above, 6d1dfab#diff-5e71163bdc19a5894ee6f788613376d521032f953485d04d3f35f3d8177be259R36 in particular)",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1449,2022-02-14T14:07:25Z,2022-02-15T08:29:40Z,2022-02-15T08:29:49Z,CLOSED,False,2,0,1,https://github.com/smititelu,More info about kernelized stream,1,[],https://github.com/sipwise/rtpengine/pull/1449,https://github.com/smititelu,3,https://github.com/sipwise/rtpengine/pull/1449#issuecomment-1039994253,"Adds call-id and port log prefix, for each kernelized stream. Please let me know what you think.
Thanks,
Stefan","Only because the log prefixes were missing in these log lines. Indeed 6d1dfab fixed it. Closing this PR.
Thank you,
Stefan",True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1457,2022-02-24T17:26:00Z,2022-02-24T17:43:49Z,2022-02-25T08:27:25Z,MERGED,True,492,6,4,https://github.com/razvancrainea,provide sendrecv mode in siprec tag-medias and media-labels,1,[],https://github.com/sipwise/rtpengine/pull/1457,https://github.com/razvancrainea,1,https://github.com/sipwise/rtpengine/pull/1457,SIPREC protocol requires to know whether a media stream is actively sending media or not.,SIPREC protocol requires to know whether a media stream is actively sending media or not.,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1457,2022-02-24T17:26:00Z,2022-02-24T17:43:49Z,2022-02-25T08:27:25Z,MERGED,True,492,6,4,https://github.com/razvancrainea,provide sendrecv mode in siprec tag-medias and media-labels,1,[],https://github.com/sipwise/rtpengine/pull/1457,https://github.com/rfuchs,2,https://github.com/sipwise/rtpengine/pull/1457#issuecomment-1050103425,SIPREC protocol requires to know whether a media stream is actively sending media or not.,Do you need this merged to any existing branches?,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1457,2022-02-24T17:26:00Z,2022-02-24T17:43:49Z,2022-02-25T08:27:25Z,MERGED,True,492,6,4,https://github.com/razvancrainea,provide sendrecv mode in siprec tag-medias and media-labels,1,[],https://github.com/sipwise/rtpengine/pull/1457,https://github.com/razvancrainea,3,https://github.com/sipwise/rtpengine/pull/1457#issuecomment-1050639088,SIPREC protocol requires to know whether a media stream is actively sending media or not.,I believe it is OK just in sipwise/rtpengine:master for now. Thank you!,True,{}
sipwise/rtpengine,https://github.com/sipwise/rtpengine,1487,2022-05-04T17:32:20Z,2022-05-05T20:09:56Z,2022-05-05T20:09:56Z,CLOSED,False,6,2,1,https://github.com/szcom,[dtx] discard null packets in dtx buffer ref #1485,2,[],https://github.com/sipwise/rtpengine/pull/1487,https://github.com/szcom,1,https://github.com/sipwise/rtpengine/pull/1487,,,True,{}
