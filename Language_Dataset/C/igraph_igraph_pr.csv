igraph/igraph,https://github.com/igraph/igraph,933,2016-03-05T11:06:09Z,2016-03-06T14:34:03Z,2020-01-29T09:18:03Z,MERGED,True,27,1,4,https://github.com/szhorvat,Add igraph_malloc(),1,[],https://github.com/igraph/igraph/pull/933,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/933,"Summary
This pull request adds igraph_malloc(), a function that works exactly like the standard malloc(), but it calls the same malloc that igraph was compiled with.  This is useful (and necessary) if igraph is compiled as a DLL with compiler A but then the DLL is used from a program compiled with compiler B, and the two do not have compatible malloc/free implementations.
igraph_free() is also necessary in this case, but this function already exists so I didn't need to add it.
Motivation
We had a short discussion about this on the mailing list, but at that time the problem did not come up in a practical situation for me.
https://lists.gnu.org/archive/html/igraph-help/2015-12/msg00027.html


Finally, I notice that some examples use free() and not igraph_free()
to free memory. Do I need to worry about this and the potential
differences between the two if igraph itself and my program use
different compilers?  Shouldn't igraph provide an igraph_malloc in
addition to igraph_free to make sure that memory I might allocate will
be correctly freed by igraph_vector_ptr_free_all()? This last one is
so far a theoretical question as I don't yet need this.

Don't worry about free and igraph_free. AFAIR igraph_free is newer,
and the idea was that we could use different allocators, but in the
end we never did this.
I guess we could still convert all free() to igraph_free()
GAbor

It turns out that my worry was not unfounded.  If I compile igraph with MinGW-w64 as a DLL, but then use that DLL with the Visual Studio compiler, I run into problems.  The MinGW and MSVC free/malloc are incompatible.  Memory allocated by one cannot be freed with the other (it crashes).
This problem is also mentioned here: http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands

A new/delete or malloc/free in a MSVC DLL will not co-operate with a Cygwin newlib new/delete or malloc/free. One cannot free space which was allocated in a function using a different new/malloc at all.

The same page also agrees that despite these problems, it is not necessarily an absolutely atrocious idea to mix compilers like this for as long as its done across DLL boundaries (not static linking) and for as long as the DLL is called through a simple C (not C++) interface.

Dll's are slightly different. Sometimes you can link a DLL built with one compiler to an application compiled with another. This works well if the DLL is written in C, even if the application is written in C++.

The problems can be avoided if the user is very careful to only use malloc/free in matching pairs.  Always use MSVC-free on MSVC-malloc'd memory and always use MinGW-free on MinGW-malloc'd memory.  To be able to do this, the user needs access to both sets of functions, i.e. he needs access to the malloc/free pair that igraph (the igraph DLL) uses internally.  Hence this pull request.
Now let me show practical scenarios which force the user to allocate memory which will be freed by igraph internally, or the reverse, deallocate memory which was allocated by igraph internally.
Some Bliss functions allocate memory which must be explicitly deallocated by the user using free().  To avoid trouble it should in fact be done using igraph_free().
http://igraph.org/c/doc/igraph-Isomorphism.html#igraph_bliss_info_t
What about the reverse?  igraph_vector_ptr_free_all and igraph_vector_ptr_destroy_all will free memory which may have been allocated by the user.  When is this memory likely allocated by the user directly and not an igraph function?  One example is when preparing the domain argument of igraph_subisomorphic_lad.
Can the user just not use igraph_vector_ptr_free_all but use their own (matching) free() to manually deallocate each element instead?  Yes, in principle this is possible.  But in my case it is very inconvenient.  The reason is that I have a C++ class wrapping igraph_vector_ptr_t and the class destructor does not know which malloc was used to allocate elements.  They may have been allocated by an igraph function internally (typical) or they may have been allocated by me manually (rare, prime example being domain in LAD functions).
Now I will understand if this pull request gets rejected on the basis that mixing compilers is just a bad idea anyway.  But given my practical constraints, I am going to use this patch either way.  So I might as well submit it as a pull request.
I compile igraph using MinGW because I am unable to get it to work using MSVC (I spent a lot of time on this without success).  But I compile my Mathematica package using MSVC because using MinGW with Mathematica is risky and troublesome, partly for the same compatibility worries mentioned above.  I cannot control the library-Mathematica interface and how they might malloc/free things.  But I can control the igraph-library interface and I can take care to avoid trouble there.  So at least until the dev version (0.8) of igraph becomes easy to compile with MSVC, I am going to stick to this solution.","Summary
This pull request adds igraph_malloc(), a function that works exactly like the standard malloc(), but it calls the same malloc that igraph was compiled with.  This is useful (and necessary) if igraph is compiled as a DLL with compiler A but then the DLL is used from a program compiled with compiler B, and the two do not have compatible malloc/free implementations.
igraph_free() is also necessary in this case, but this function already exists so I didn't need to add it.
Motivation
We had a short discussion about this on the mailing list, but at that time the problem did not come up in a practical situation for me.
https://lists.gnu.org/archive/html/igraph-help/2015-12/msg00027.html


Finally, I notice that some examples use free() and not igraph_free()
to free memory. Do I need to worry about this and the potential
differences between the two if igraph itself and my program use
different compilers?  Shouldn't igraph provide an igraph_malloc in
addition to igraph_free to make sure that memory I might allocate will
be correctly freed by igraph_vector_ptr_free_all()? This last one is
so far a theoretical question as I don't yet need this.

Don't worry about free and igraph_free. AFAIR igraph_free is newer,
and the idea was that we could use different allocators, but in the
end we never did this.
I guess we could still convert all free() to igraph_free()
GAbor

It turns out that my worry was not unfounded.  If I compile igraph with MinGW-w64 as a DLL, but then use that DLL with the Visual Studio compiler, I run into problems.  The MinGW and MSVC free/malloc are incompatible.  Memory allocated by one cannot be freed with the other (it crashes).
This problem is also mentioned here: http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands

A new/delete or malloc/free in a MSVC DLL will not co-operate with a Cygwin newlib new/delete or malloc/free. One cannot free space which was allocated in a function using a different new/malloc at all.

The same page also agrees that despite these problems, it is not necessarily an absolutely atrocious idea to mix compilers like this for as long as its done across DLL boundaries (not static linking) and for as long as the DLL is called through a simple C (not C++) interface.

Dll's are slightly different. Sometimes you can link a DLL built with one compiler to an application compiled with another. This works well if the DLL is written in C, even if the application is written in C++.

The problems can be avoided if the user is very careful to only use malloc/free in matching pairs.  Always use MSVC-free on MSVC-malloc'd memory and always use MinGW-free on MinGW-malloc'd memory.  To be able to do this, the user needs access to both sets of functions, i.e. he needs access to the malloc/free pair that igraph (the igraph DLL) uses internally.  Hence this pull request.
Now let me show practical scenarios which force the user to allocate memory which will be freed by igraph internally, or the reverse, deallocate memory which was allocated by igraph internally.
Some Bliss functions allocate memory which must be explicitly deallocated by the user using free().  To avoid trouble it should in fact be done using igraph_free().
http://igraph.org/c/doc/igraph-Isomorphism.html#igraph_bliss_info_t
What about the reverse?  igraph_vector_ptr_free_all and igraph_vector_ptr_destroy_all will free memory which may have been allocated by the user.  When is this memory likely allocated by the user directly and not an igraph function?  One example is when preparing the domain argument of igraph_subisomorphic_lad.
Can the user just not use igraph_vector_ptr_free_all but use their own (matching) free() to manually deallocate each element instead?  Yes, in principle this is possible.  But in my case it is very inconvenient.  The reason is that I have a C++ class wrapping igraph_vector_ptr_t and the class destructor does not know which malloc was used to allocate elements.  They may have been allocated by an igraph function internally (typical) or they may have been allocated by me manually (rare, prime example being domain in LAD functions).
Now I will understand if this pull request gets rejected on the basis that mixing compilers is just a bad idea anyway.  But given my practical constraints, I am going to use this patch either way.  So I might as well submit it as a pull request.
I compile igraph using MinGW because I am unable to get it to work using MSVC (I spent a lot of time on this without success).  But I compile my Mathematica package using MSVC because using MinGW with Mathematica is risky and troublesome, partly for the same compatibility worries mentioned above.  I cannot control the library-Mathematica interface and how they might malloc/free things.  But I can control the igraph-library interface and I can take care to avoid trouble there.  So at least until the dev version (0.8) of igraph becomes easy to compile with MSVC, I am going to stick to this solution.",True,{}
igraph/igraph,https://github.com/igraph/igraph,933,2016-03-05T11:06:09Z,2016-03-06T14:34:03Z,2020-01-29T09:18:03Z,MERGED,True,27,1,4,https://github.com/szhorvat,Add igraph_malloc(),1,[],https://github.com/igraph/igraph/pull/933,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/933#issuecomment-192623857,"Summary
This pull request adds igraph_malloc(), a function that works exactly like the standard malloc(), but it calls the same malloc that igraph was compiled with.  This is useful (and necessary) if igraph is compiled as a DLL with compiler A but then the DLL is used from a program compiled with compiler B, and the two do not have compatible malloc/free implementations.
igraph_free() is also necessary in this case, but this function already exists so I didn't need to add it.
Motivation
We had a short discussion about this on the mailing list, but at that time the problem did not come up in a practical situation for me.
https://lists.gnu.org/archive/html/igraph-help/2015-12/msg00027.html


Finally, I notice that some examples use free() and not igraph_free()
to free memory. Do I need to worry about this and the potential
differences between the two if igraph itself and my program use
different compilers?  Shouldn't igraph provide an igraph_malloc in
addition to igraph_free to make sure that memory I might allocate will
be correctly freed by igraph_vector_ptr_free_all()? This last one is
so far a theoretical question as I don't yet need this.

Don't worry about free and igraph_free. AFAIR igraph_free is newer,
and the idea was that we could use different allocators, but in the
end we never did this.
I guess we could still convert all free() to igraph_free()
GAbor

It turns out that my worry was not unfounded.  If I compile igraph with MinGW-w64 as a DLL, but then use that DLL with the Visual Studio compiler, I run into problems.  The MinGW and MSVC free/malloc are incompatible.  Memory allocated by one cannot be freed with the other (it crashes).
This problem is also mentioned here: http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands

A new/delete or malloc/free in a MSVC DLL will not co-operate with a Cygwin newlib new/delete or malloc/free. One cannot free space which was allocated in a function using a different new/malloc at all.

The same page also agrees that despite these problems, it is not necessarily an absolutely atrocious idea to mix compilers like this for as long as its done across DLL boundaries (not static linking) and for as long as the DLL is called through a simple C (not C++) interface.

Dll's are slightly different. Sometimes you can link a DLL built with one compiler to an application compiled with another. This works well if the DLL is written in C, even if the application is written in C++.

The problems can be avoided if the user is very careful to only use malloc/free in matching pairs.  Always use MSVC-free on MSVC-malloc'd memory and always use MinGW-free on MinGW-malloc'd memory.  To be able to do this, the user needs access to both sets of functions, i.e. he needs access to the malloc/free pair that igraph (the igraph DLL) uses internally.  Hence this pull request.
Now let me show practical scenarios which force the user to allocate memory which will be freed by igraph internally, or the reverse, deallocate memory which was allocated by igraph internally.
Some Bliss functions allocate memory which must be explicitly deallocated by the user using free().  To avoid trouble it should in fact be done using igraph_free().
http://igraph.org/c/doc/igraph-Isomorphism.html#igraph_bliss_info_t
What about the reverse?  igraph_vector_ptr_free_all and igraph_vector_ptr_destroy_all will free memory which may have been allocated by the user.  When is this memory likely allocated by the user directly and not an igraph function?  One example is when preparing the domain argument of igraph_subisomorphic_lad.
Can the user just not use igraph_vector_ptr_free_all but use their own (matching) free() to manually deallocate each element instead?  Yes, in principle this is possible.  But in my case it is very inconvenient.  The reason is that I have a C++ class wrapping igraph_vector_ptr_t and the class destructor does not know which malloc was used to allocate elements.  They may have been allocated by an igraph function internally (typical) or they may have been allocated by me manually (rare, prime example being domain in LAD functions).
Now I will understand if this pull request gets rejected on the basis that mixing compilers is just a bad idea anyway.  But given my practical constraints, I am going to use this patch either way.  So I might as well submit it as a pull request.
I compile igraph using MinGW because I am unable to get it to work using MSVC (I spent a lot of time on this without success).  But I compile my Mathematica package using MSVC because using MinGW with Mathematica is risky and troublesome, partly for the same compatibility worries mentioned above.  I cannot control the library-Mathematica interface and how they might malloc/free things.  But I can control the igraph-library interface and I can take care to avoid trouble there.  So at least until the dev version (0.8) of igraph becomes easy to compile with MSVC, I am going to stick to this solution.","A final note: I am aware of igraph_Calloc in igraph_memory.h, but it is a macro so it doesn't give access to the memory allocator that an already compiled igraph is using.",True,{}
igraph/igraph,https://github.com/igraph/igraph,933,2016-03-05T11:06:09Z,2016-03-06T14:34:03Z,2020-01-29T09:18:03Z,MERGED,True,27,1,4,https://github.com/szhorvat,Add igraph_malloc(),1,[],https://github.com/igraph/igraph/pull/933,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/933#issuecomment-192729956,"Summary
This pull request adds igraph_malloc(), a function that works exactly like the standard malloc(), but it calls the same malloc that igraph was compiled with.  This is useful (and necessary) if igraph is compiled as a DLL with compiler A but then the DLL is used from a program compiled with compiler B, and the two do not have compatible malloc/free implementations.
igraph_free() is also necessary in this case, but this function already exists so I didn't need to add it.
Motivation
We had a short discussion about this on the mailing list, but at that time the problem did not come up in a practical situation for me.
https://lists.gnu.org/archive/html/igraph-help/2015-12/msg00027.html


Finally, I notice that some examples use free() and not igraph_free()
to free memory. Do I need to worry about this and the potential
differences between the two if igraph itself and my program use
different compilers?  Shouldn't igraph provide an igraph_malloc in
addition to igraph_free to make sure that memory I might allocate will
be correctly freed by igraph_vector_ptr_free_all()? This last one is
so far a theoretical question as I don't yet need this.

Don't worry about free and igraph_free. AFAIR igraph_free is newer,
and the idea was that we could use different allocators, but in the
end we never did this.
I guess we could still convert all free() to igraph_free()
GAbor

It turns out that my worry was not unfounded.  If I compile igraph with MinGW-w64 as a DLL, but then use that DLL with the Visual Studio compiler, I run into problems.  The MinGW and MSVC free/malloc are incompatible.  Memory allocated by one cannot be freed with the other (it crashes).
This problem is also mentioned here: http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands

A new/delete or malloc/free in a MSVC DLL will not co-operate with a Cygwin newlib new/delete or malloc/free. One cannot free space which was allocated in a function using a different new/malloc at all.

The same page also agrees that despite these problems, it is not necessarily an absolutely atrocious idea to mix compilers like this for as long as its done across DLL boundaries (not static linking) and for as long as the DLL is called through a simple C (not C++) interface.

Dll's are slightly different. Sometimes you can link a DLL built with one compiler to an application compiled with another. This works well if the DLL is written in C, even if the application is written in C++.

The problems can be avoided if the user is very careful to only use malloc/free in matching pairs.  Always use MSVC-free on MSVC-malloc'd memory and always use MinGW-free on MinGW-malloc'd memory.  To be able to do this, the user needs access to both sets of functions, i.e. he needs access to the malloc/free pair that igraph (the igraph DLL) uses internally.  Hence this pull request.
Now let me show practical scenarios which force the user to allocate memory which will be freed by igraph internally, or the reverse, deallocate memory which was allocated by igraph internally.
Some Bliss functions allocate memory which must be explicitly deallocated by the user using free().  To avoid trouble it should in fact be done using igraph_free().
http://igraph.org/c/doc/igraph-Isomorphism.html#igraph_bliss_info_t
What about the reverse?  igraph_vector_ptr_free_all and igraph_vector_ptr_destroy_all will free memory which may have been allocated by the user.  When is this memory likely allocated by the user directly and not an igraph function?  One example is when preparing the domain argument of igraph_subisomorphic_lad.
Can the user just not use igraph_vector_ptr_free_all but use their own (matching) free() to manually deallocate each element instead?  Yes, in principle this is possible.  But in my case it is very inconvenient.  The reason is that I have a C++ class wrapping igraph_vector_ptr_t and the class destructor does not know which malloc was used to allocate elements.  They may have been allocated by an igraph function internally (typical) or they may have been allocated by me manually (rare, prime example being domain in LAD functions).
Now I will understand if this pull request gets rejected on the basis that mixing compilers is just a bad idea anyway.  But given my practical constraints, I am going to use this patch either way.  So I might as well submit it as a pull request.
I compile igraph using MinGW because I am unable to get it to work using MSVC (I spent a lot of time on this without success).  But I compile my Mathematica package using MSVC because using MinGW with Mathematica is risky and troublesome, partly for the same compatibility worries mentioned above.  I cannot control the library-Mathematica interface and how they might malloc/free things.  But I can control the igraph-library interface and I can take care to avoid trouble there.  So at least until the dev version (0.8) of igraph becomes easy to compile with MSVC, I am going to stick to this solution.","Thanks for the detailed analysis of the issue. I have no objections against adding igraph_malloc. Let's wait a few days to see if @gaborcsardi chimes in or not, and if there are no objections from his side, I will merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,933,2016-03-05T11:06:09Z,2016-03-06T14:34:03Z,2020-01-29T09:18:03Z,MERGED,True,27,1,4,https://github.com/szhorvat,Add igraph_malloc(),1,[],https://github.com/igraph/igraph/pull/933,https://github.com/gaborcsardi,4,https://github.com/igraph/igraph/pull/933#issuecomment-192898003,"Summary
This pull request adds igraph_malloc(), a function that works exactly like the standard malloc(), but it calls the same malloc that igraph was compiled with.  This is useful (and necessary) if igraph is compiled as a DLL with compiler A but then the DLL is used from a program compiled with compiler B, and the two do not have compatible malloc/free implementations.
igraph_free() is also necessary in this case, but this function already exists so I didn't need to add it.
Motivation
We had a short discussion about this on the mailing list, but at that time the problem did not come up in a practical situation for me.
https://lists.gnu.org/archive/html/igraph-help/2015-12/msg00027.html


Finally, I notice that some examples use free() and not igraph_free()
to free memory. Do I need to worry about this and the potential
differences between the two if igraph itself and my program use
different compilers?  Shouldn't igraph provide an igraph_malloc in
addition to igraph_free to make sure that memory I might allocate will
be correctly freed by igraph_vector_ptr_free_all()? This last one is
so far a theoretical question as I don't yet need this.

Don't worry about free and igraph_free. AFAIR igraph_free is newer,
and the idea was that we could use different allocators, but in the
end we never did this.
I guess we could still convert all free() to igraph_free()
GAbor

It turns out that my worry was not unfounded.  If I compile igraph with MinGW-w64 as a DLL, but then use that DLL with the Visual Studio compiler, I run into problems.  The MinGW and MSVC free/malloc are incompatible.  Memory allocated by one cannot be freed with the other (it crashes).
This problem is also mentioned here: http://www.mingw.org/wiki/Interoperability_of_Libraries_Created_by_Different_Compiler_Brands

A new/delete or malloc/free in a MSVC DLL will not co-operate with a Cygwin newlib new/delete or malloc/free. One cannot free space which was allocated in a function using a different new/malloc at all.

The same page also agrees that despite these problems, it is not necessarily an absolutely atrocious idea to mix compilers like this for as long as its done across DLL boundaries (not static linking) and for as long as the DLL is called through a simple C (not C++) interface.

Dll's are slightly different. Sometimes you can link a DLL built with one compiler to an application compiled with another. This works well if the DLL is written in C, even if the application is written in C++.

The problems can be avoided if the user is very careful to only use malloc/free in matching pairs.  Always use MSVC-free on MSVC-malloc'd memory and always use MinGW-free on MinGW-malloc'd memory.  To be able to do this, the user needs access to both sets of functions, i.e. he needs access to the malloc/free pair that igraph (the igraph DLL) uses internally.  Hence this pull request.
Now let me show practical scenarios which force the user to allocate memory which will be freed by igraph internally, or the reverse, deallocate memory which was allocated by igraph internally.
Some Bliss functions allocate memory which must be explicitly deallocated by the user using free().  To avoid trouble it should in fact be done using igraph_free().
http://igraph.org/c/doc/igraph-Isomorphism.html#igraph_bliss_info_t
What about the reverse?  igraph_vector_ptr_free_all and igraph_vector_ptr_destroy_all will free memory which may have been allocated by the user.  When is this memory likely allocated by the user directly and not an igraph function?  One example is when preparing the domain argument of igraph_subisomorphic_lad.
Can the user just not use igraph_vector_ptr_free_all but use their own (matching) free() to manually deallocate each element instead?  Yes, in principle this is possible.  But in my case it is very inconvenient.  The reason is that I have a C++ class wrapping igraph_vector_ptr_t and the class destructor does not know which malloc was used to allocate elements.  They may have been allocated by an igraph function internally (typical) or they may have been allocated by me manually (rare, prime example being domain in LAD functions).
Now I will understand if this pull request gets rejected on the basis that mixing compilers is just a bad idea anyway.  But given my practical constraints, I am going to use this patch either way.  So I might as well submit it as a pull request.
I compile igraph using MinGW because I am unable to get it to work using MSVC (I spent a lot of time on this without success).  But I compile my Mathematica package using MSVC because using MinGW with Mathematica is risky and troublesome, partly for the same compatibility worries mentioned above.  I cannot control the library-Mathematica interface and how they might malloc/free things.  But I can control the igraph-library interface and I can take care to avoid trouble there.  So at least until the dev version (0.8) of igraph becomes easy to compile with MSVC, I am going to stick to this solution.","This looks great, thanks! It is good to know that you can mix compilers this way.",True,{}
igraph/igraph,https://github.com/igraph/igraph,935,2016-03-17T15:33:24Z,2016-03-17T15:35:40Z,2016-03-17T15:35:40Z,CLOSED,False,15565,3260,476,https://github.com/arivero,"updating fork  - sorry, please ignore",236,[],https://github.com/igraph/igraph/pull/935,https://github.com/arivero,1,https://github.com/igraph/igraph/pull/935,"This is -I hope- to sync my fork against the original base  --- please ignore it, the UI of github confused me","This is -I hope- to sync my fork against the original base  --- please ignore it, the UI of github confused me",True,{}
igraph/igraph,https://github.com/igraph/igraph,935,2016-03-17T15:33:24Z,2016-03-17T15:35:40Z,2016-03-17T15:35:40Z,CLOSED,False,15565,3260,476,https://github.com/arivero,"updating fork  - sorry, please ignore",236,[],https://github.com/igraph/igraph/pull/935,https://github.com/gaborcsardi,2,https://github.com/igraph/igraph/pull/935#issuecomment-197935298,"This is -I hope- to sync my fork against the original base  --- please ignore it, the UI of github confused me","I am not sure what this is, but I will close it. :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,941,2016-04-18T15:56:28Z,2016-04-18T19:32:19Z,2016-04-19T09:15:30Z,MERGED,True,45,2,1,https://github.com/szhorvat,More checks for igraph_static_fitness_game,1,[],https://github.com/igraph/igraph/pull/941,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/941,"This patch has three changes:

It verifies that fitness_in and fitness_out are of the same size.
It attempts to verify that the user didn't request more edges than what are possible to add.  Please verify this, as there are different cases depending directed/loop-free/multi-edge graph choices.
Better interruptibility.  Before this function allowed interruption after each 10000 edges added.  Not every edge insertion trial is successful.  It is possible to get stuck trying to add more edges but never succeeding (or only succeeding with very small probabilities).  Instead of counting the edges that were added, now we count the number of trials (whether successful or not).

I did not check interactions with other functions that might call igraph_static_fitness_game
Fixes #939","This patch has three changes:

It verifies that fitness_in and fitness_out are of the same size.
It attempts to verify that the user didn't request more edges than what are possible to add.  Please verify this, as there are different cases depending directed/loop-free/multi-edge graph choices.
Better interruptibility.  Before this function allowed interruption after each 10000 edges added.  Not every edge insertion trial is successful.  It is possible to get stuck trying to add more edges but never succeeding (or only succeeding with very small probabilities).  Instead of counting the edges that were added, now we count the number of trials (whether successful or not).

I did not check interactions with other functions that might call igraph_static_fitness_game
Fixes #939",True,{}
igraph/igraph,https://github.com/igraph/igraph,941,2016-04-18T15:56:28Z,2016-04-18T19:32:19Z,2016-04-19T09:15:30Z,MERGED,True,45,2,1,https://github.com/szhorvat,More checks for igraph_static_fitness_game,1,[],https://github.com/igraph/igraph/pull/941,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/941#issuecomment-211542492,"This patch has three changes:

It verifies that fitness_in and fitness_out are of the same size.
It attempts to verify that the user didn't request more edges than what are possible to add.  Please verify this, as there are different cases depending directed/loop-free/multi-edge graph choices.
Better interruptibility.  Before this function allowed interruption after each 10000 edges added.  Not every edge insertion trial is successful.  It is possible to get stuck trying to add more edges but never succeeding (or only succeeding with very small probabilities).  Instead of counting the edges that were added, now we count the number of trials (whether successful or not).

I did not check interactions with other functions that might call igraph_static_fitness_game
Fixes #939","Seems okay to me - I'll make a few stylistic adjustments after merging, though. MSVC does not like variable declarations in the middle of a function body so I'll move them to the top of the function. Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,941,2016-04-18T15:56:28Z,2016-04-18T19:32:19Z,2016-04-19T09:15:30Z,MERGED,True,45,2,1,https://github.com/szhorvat,More checks for igraph_static_fitness_game,1,[],https://github.com/igraph/igraph/pull/941,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/941#issuecomment-211756106,"This patch has three changes:

It verifies that fitness_in and fitness_out are of the same size.
It attempts to verify that the user didn't request more edges than what are possible to add.  Please verify this, as there are different cases depending directed/loop-free/multi-edge graph choices.
Better interruptibility.  Before this function allowed interruption after each 10000 edges added.  Not every edge insertion trial is successful.  It is possible to get stuck trying to add more edges but never succeeding (or only succeeding with very small probabilities).  Instead of counting the edges that were added, now we count the number of trials (whether successful or not).

I did not check interactions with other functions that might call igraph_static_fitness_game
Fixes #939","Thanks!  I thought that variables at the beginning of blocks should always be fine in C.
void f() {
  printf(""foo\n"");
  int i=0; /* error */
  printf(""%d\n"", i);
}

void f() {
  printf(""foo\n"");
  {
    int i=0; /* valid */
    printf(""%d\n"", i);
  }
}

But I only tried with the latest MSVC (2015)",True,{}
igraph/igraph,https://github.com/igraph/igraph,941,2016-04-18T15:56:28Z,2016-04-18T19:32:19Z,2016-04-19T09:15:30Z,MERGED,True,45,2,1,https://github.com/szhorvat,More checks for igraph_static_fitness_game,1,[],https://github.com/igraph/igraph/pull/941,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/941#issuecomment-211819866,"This patch has three changes:

It verifies that fitness_in and fitness_out are of the same size.
It attempts to verify that the user didn't request more edges than what are possible to add.  Please verify this, as there are different cases depending directed/loop-free/multi-edge graph choices.
Better interruptibility.  Before this function allowed interruption after each 10000 edges added.  Not every edge insertion trial is successful.  It is possible to get stuck trying to add more edges but never succeeding (or only succeeding with very small probabilities).  Instead of counting the edges that were added, now we count the number of trials (whether successful or not).

I did not check interactions with other functions that might call igraph_static_fitness_game
Fixes #939","Not sure, I remember that we've had problems with that in the past and we don't do regular testing on MSVC (due to lack of access to Windows machines) so I prefer to be on the safe side.",True,{}
igraph/igraph,https://github.com/igraph/igraph,944,2016-05-20T15:33:07Z,2016-05-24T11:02:38Z,2016-05-24T11:02:41Z,MERGED,True,6,7,1,https://github.com/szhorvat,Clarify documentation on mean geodesic lengths,2,[],https://github.com/igraph/igraph/pull/944,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/944,"This is based on user feedback (for IGraph/M).
For a directed graph, it is not true that the mean shortest paths within connected components will be taken.  Consider the two-vertex directed graph 1 -> 2.  The two components are {1} and {2} and the 1 -> 2 edge is not part of either component.  Yet it is taken into account during the calculation of the average.
It also doesn't exactly compute the average geodesic length, i.e. average of the lengths of all geodesics. There may be more than one geodesic between the same two vertices.
Yes, this is splitting hairs, but useful when one is in doubt about what exactly gets calculated.","This is based on user feedback (for IGraph/M).
For a directed graph, it is not true that the mean shortest paths within connected components will be taken.  Consider the two-vertex directed graph 1 -> 2.  The two components are {1} and {2} and the 1 -> 2 edge is not part of either component.  Yet it is taken into account during the calculation of the average.
It also doesn't exactly compute the average geodesic length, i.e. average of the lengths of all geodesics. There may be more than one geodesic between the same two vertices.
Yes, this is splitting hairs, but useful when one is in doubt about what exactly gets calculated.",True,{}
igraph/igraph,https://github.com/igraph/igraph,944,2016-05-20T15:33:07Z,2016-05-24T11:02:38Z,2016-05-24T11:02:41Z,MERGED,True,6,7,1,https://github.com/szhorvat,Clarify documentation on mean geodesic lengths,2,[],https://github.com/igraph/igraph/pull/944,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/944#issuecomment-221236145,"This is based on user feedback (for IGraph/M).
For a directed graph, it is not true that the mean shortest paths within connected components will be taken.  Consider the two-vertex directed graph 1 -> 2.  The two components are {1} and {2} and the 1 -> 2 edge is not part of either component.  Yet it is taken into account during the calculation of the average.
It also doesn't exactly compute the average geodesic length, i.e. average of the lengths of all geodesics. There may be more than one geodesic between the same two vertices.
Yes, this is splitting hairs, but useful when one is in doubt about what exactly gets calculated.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,1,https://github.com/igraph/igraph/pull/951,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/951#issuecomment-231339505,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Added igraph to my AppVeyor account - what else do I need to do? Shall I just merge this pull request and see how the build goes?,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,3,https://github.com/igraph/igraph/pull/951#issuecomment-231340072,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","I think you are done: it will just build every PR and if appveyor doesn't find an appveyor.yml file will skip that build. So new commits in this PR should be build, but all other PRs/commits not (until this PR is merged). We will see when I push a commit to this PR, I'm currently waiting for https://ci.appveyor.com/project/JanSchulz/igraph/build/job/6nhpxyacxv273x4r :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,4,https://github.com/igraph/igraph/pull/951#issuecomment-231345373,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",And there it is :-) https://ci.appveyor.com/project/ntamas/igraph/build/1.0.1,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,5,https://github.com/igraph/igraph/pull/951#issuecomment-231346450,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Autsch: 31 minutes just for one msys2 build, so the complete tests will take over 3h... I should probably implement that as one msys2 build+test and 3 msvc builds...",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,6,https://github.com/igraph/igraph/pull/951#issuecomment-231376349,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",@ntamas could you kill all appveyor builds other than the latest? I screwed up with the conda update conda call and now all these builds will wait on updating the root python (at worst case 1h until the timeout) :-(,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/951#issuecomment-231378032,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Done.,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,8,https://github.com/igraph/igraph/pull/951#issuecomment-231403490,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Ok, py27 starts building but fails https://ci.appveyor.com/project/ntamas/igraph/build/job/mt81sistwbvl1gq2
For the rest, I have to see how to properly start it :-(",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/951#issuecomment-231415125,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","I have started looking for : error in the compiler output and started fixing things, but I have to go now. It looks like there are many compilation errors stemming from the fact that MSVC doesn't ""like"" variable declarations being mixed with code and these errors can be fixed easily by moving the variable declarations up to the start of the closest code block (see my two most recent commits).",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,10,https://github.com/igraph/igraph/pull/951#issuecomment-233176491,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Rebased on top of master, lets see what is still failing...",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,11,https://github.com/igraph/igraph/pull/951#issuecomment-233184589,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","@ntamas layout_gem contains a line referencing M_PI_2, but I found no line declaring or setting it. This seems like a bug :-/ 
  
    
      igraph/src/layout_gem.c
    
    
         Line 211
      in
      19946d0
    
  
  
    

        
          
           if (sin(beta) >= sin(M_PI_2 + alpha_r / 2.0)) { 
        
    
  


[Update: looked up the reference and added this constant as pi/2 in 522ac37]",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,12,https://github.com/igraph/igraph/pull/951#issuecomment-233193296,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","If the last two builds (""Appveyor: use devenv instead of VCUpgrade"" and ""Add artifacts to appveyor"" hand :-( It would be great if someone could kill the builds... I currently use my own account to test further builds...",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/gaborcsardi,13,https://github.com/igraph/igraph/pull/951#issuecomment-233197264,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Only Tamas can admin it, afaik.",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,14,https://github.com/igraph/igraph/pull/951#issuecomment-233197950,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Also seems not to matter: the devenv call also freezes without the ""overwrite""... Seems this problem needs a new igraph.vcxproj so that this can happen without the upgrade step :-(",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/951#issuecomment-233333414,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Just came online and it seems like there are no more builds in progress... is there anything else I should do? (Thanks for the M_PI_2 fix by the way).,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,16,https://github.com/igraph/igraph/pull/951#issuecomment-233333793,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","so, the py35 error is now

The following error has occurred during XML parsing: File: C:\data\external\igraph\igraph-0.8.0-pre+81ed709-msvc\igraph.vcproj Line: 3477 Column: 0 Error Message: Systemfehler: -2146233079. The file 'C:\data\external\igraph\igraph-0.8.0-pre+81ed709-msvc\igraph.vcproj' has failed to load.

If anyone has a clue... :-/",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,17,https://github.com/igraph/igraph/pull/951#issuecomment-233335093,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",@ntamas right now I'm stuck with converting the project file on py34 and py35 and the py27 build fails to set the right include dirs so that the  vendored source files find their *.h files.,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,18,https://github.com/igraph/igraph/pull/951#issuecomment-233337482,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Ok, found a hint:
 <File
                               RelativePath="".\include\make[1]:""
                               FileType=""2"">
                       </File>
                       <File
                               RelativePath="".\include\Leaving""
                               FileType=""2"">
                       </File>
                       <File
                               RelativePath="".\include\directory""
                               FileType=""2"">
                       </File>

This looks wrong...",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,19,https://github.com/igraph/igraph/pull/951#issuecomment-233338518,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Looks like a bug in our tools/create-msvc-projectfile.py script that creates the MSVC project file for the MSVC release.,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,20,https://github.com/igraph/igraph/pull/951#issuecomment-233343940,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","The ""don't find the header"" seems to be a problem that certain files don't show up in echosources makefile target, e.g. the ones under AMD, CHOLMOD and COLAMD: e.g. ""colamd.h"" is only included once as a source file, but not as a header :-(",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,21,https://github.com/igraph/igraph/pull/951#issuecomment-233387102,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","yay, finally I got all to build...
@ntamas @gaborcsardi Ok, now I'm out of ideas:
https://ci.appveyor.com/project/JanSchulz/igraph/build/1.0.43/job/pswkw57pt1u0tvsp (but py34 and py35 fail with similar errors)
.\src\CHOLMOD\Partition\cholmod_metis.c(55) : fatal error C1083: Cannot open include file: 'metis.h': No such file or directory

c:\data\external\igraph (appveyor)
[igraph35] λ grep -R metis.h
igraph-0.8.0-pre+81ed709-msvc/src/CHOLMOD/Partition/cholmod_metis.c:#include ""metis.h""
src/CHOLMOD/Partition/cholmod_metis.c:#include ""metis.h""

[igraph35] λ es metis.h
C:\portabel\R\R\win-library\3.3\BH\include\boost\graph\metis.hpp
C:\portabel\R\R\win-library\3.4\BH\include\boost\graph\metis.hpp

-> Ok, this seems to require boost, I can probably get that from msys2 somewhere, but no idea how to include it in the msvc builds :-(
.\src\CHOLMOD\Partition\cholmod_ccolamd.c(32) : fatal error C1083: Cannot open include file: 'ccolamd.h': No such file or directory
cholmod_camd.c
.\src\CHOLMOD\Partition\cholmod_camd.c(42) : fatal error C1083: Cannot open include file: 'camd.h': No such file or directory
cholmod_band.c

c:\data\external\igraph (appveyor)
[igraph35] λ grep -R ccolamd.h
igraph-0.8.0-pre+81ed709-msvc/src/CHOLMOD/Partition/cholmod_ccolamd.c:#include ""ccolamd.h""
igraph-0.8.0-pre+81ed709-msvc/src/CHOLMOD/Partition/cholmod_csymamd.c:#include ""ccolamd.h""
src/CHOLMOD/Partition/cholmod_ccolamd.c:#include ""ccolamd.h""
src/CHOLMOD/Partition/cholmod_csymamd.c:#include ""ccolamd.h""

c:\data\external\igraph (appveyor)
[igraph35] λ es ccolamd.h

[igraph35] λ grep -R camd.h |grep -v _camd.h
igraph-0.8.0-pre+81ed709-msvc/src/CHOLMOD/Partition/cholmod_camd.c:#include ""camd.h""
src/CHOLMOD/Partition/cholmod_camd.c:#include ""camd.h""

c:\data\external\igraph (appveyor)
[igraph35] λ es camd.h
C:\data\external\igraph\igraph-0.8.0-pre+81ed709-msvc\src\CHOLMOD\Include\cholmod_camd.h
C:\data\external\igraph\src\CHOLMOD\Include\cholmod_camd.h

-> The camd.h looks almost like a missed rename, but then both cholmod_camd.h and camd.h are included in that file right one after another. No idea about ccolamd.h... :-(",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,22,https://github.com/igraph/igraph/pull/951#issuecomment-233390396,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Ah:
#ifndef NCAMD

Seems I have to define that as well...",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,23,https://github.com/igraph/igraph/pull/951#issuecomment-233428618,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","WTF? Why does this NOT compile, but all the other files which include that file?
https://ci.appveyor.com/project/ntamas/igraph/build/1.0.42/job/2h63gh5t4p3xokmr#L3484 (py27)
c:\projects\igraph\igraph-0.8.0-pre+2a13533-msvc\src\prpack\prpack_csc.h(4) : fatal error C1083: Cannot open include file: 'stdint.h': No such file or directory",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,24,https://github.com/igraph/igraph/pull/951#issuecomment-233436559,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","And more fun:
https://ci.appveyor.com/project/ntamas/igraph/build/1.0.43/job/29qa3e24fpi77bh8#L3724
src\prpack.cpp(66): error C2065: 'prpack_igraph_graph' : undeclared identifier [C:\projects\igraph\igraph-0.8.0-pre+2a13533-msvc\igraph.vcxproj]
src\prpack.cpp(66): error C2146: syntax error : missing ';' before identifier 'prpack_graph' [C:\projects\igraph\igraph-0.8.0-pre+2a13533-msvc\igraph.vcxproj]
src\prpack.cpp(66): error C3861: 'prpack_graph': identifier not found [C:\projects\igraph\igraph-0.8.0-pre+2a13533-msvc\igraph.vcxproj]
src\prpack.cpp(67): error C2065: 'prpack_graph' : undeclared identifier [C:\projects\igraph\igraph-0.8.0-pre+2a13533-msvc\igraph.vcxproj]

https://ci.appveyor.com/project/ntamas/igraph/build/1.0.43/job/e0nih5t2qugwblp7#L4342
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(217): warning C4005: 'register': macro redefinition [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  c:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\src\gengraph_definitions.h(26): note: see previous definition of 'register'
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(250): fatal error C1189: #error:  The C++ Standard Library forbids macroizing keywords. Enable warning C4005 to find the forbidden macro. [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  gengraph_mr-connected.cpp
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(217): warning C4005: 'register': macro redefinition [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  c:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\src\gengraph_definitions.h(26): note: see previous definition of 'register'
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(250): fatal error C1189: #error:  The C++ Standard Library forbids macroizing keywords. Enable warning C4005 to find the forbidden macro. [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  gengraph_graph_molloy_optimized.cpp
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(217): warning C4005: 'register': macro redefinition [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  c:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\src\gengraph_definitions.h(26): note: see previous definition of 'register'
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(250): fatal error C1189: #error:  The C++ Standard Library forbids macroizing keywords. Enable warning C4005 to find the forbidden macro. [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  gengraph_graph_molloy_hash.cpp
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(217): warning C4005: 'register': macro redefinition [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]
  c:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\src\gengraph_definitions.h(26): note: see previous definition of 'register'
c:\program files (x86)\microsoft visual studio 14.0\vc\include\xkeycheck.h(250): fatal error C1189: #error:  The C++ Standard Library forbids macroizing keywords. Enable warning C4005 to find the forbidden macro. [C:\projects\igraph\igraph-0.8.0-pre+5efbd97-msvc\igraph.vcxproj]

So, currently all three msvc builds fail at a different place :-(",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,25,https://github.com/igraph/igraph/pull/951#issuecomment-233466451,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Update: I managed to remove the problem with redefining register.  Now only two problems remain...,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,26,https://github.com/igraph/igraph/pull/951#issuecomment-233640710,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","WTF? Why does this NOT compile, but all the other files which include that file?

MSVC does not have stdint.h so other files include this conditionally; see, e.g., src/plfit/lbfgs.c:
#ifndef _MSC_VER
#include <stdint.h>
#endif

We need stdint.h only to get int64_t (i.e. a 64-bit signed integer type). For MSVC, you can probably get around this by not including stdint.h and using this instead:
typedef __int64 int64_t;",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,27,https://github.com/igraph/igraph/pull/951#issuecomment-233641010,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","src\prpack.cpp(66): error C2146: syntax error : missing ';' before identifier 'prpack_graph' [C:\projects\igraph\igraph-0.8.0-pre+2a13533-msvc\igraph.vcxproj]

Can this be a problem with not defining PRPACK_IGRAPH_SUPPORT in the MSVC version of config.h?",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,28,https://github.com/igraph/igraph/pull/951#issuecomment-234190294,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Can this be a problem with not defining PRPACK_IGRAPH_SUPPORT in the MSVC version of config.h?

I do define it: https://github.com/igraph/igraph/pull/951/files#diff-3209138253bf6b677d8c22e3a2e1f66cR180 (commit: 82a29ee)",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,29,https://github.com/igraph/igraph/pull/951#issuecomment-234191087,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",... but prpack.cpp and the others does not include config.h...,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,30,https://github.com/igraph/igraph/pull/951#issuecomment-234203993,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","And the first MSVC builds are green... yay! Will be interesting what the last builds spits out, thats the make check on msys2 (NOT msvc!).",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,31,https://github.com/igraph/igraph/pull/951#issuecomment-234208356,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","... and the tests all fail, so I suspect that something basic in the tests is failing... :-/
IMO the msvc building is something which could be merged right now. I can remove the make check into a different PR, if you want that...",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/szhorvat,32,https://github.com/igraph/igraph/pull/951#issuecomment-234209530,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Sorry if this is a too naive comment ... you are probably well aware of this.  But just in case: If you build igraph as a DLL, before you run the tests you must make sure that the DLL is in the path.",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,33,https://github.com/igraph/igraph/pull/951#issuecomment-234209912,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","It seems that the testssuite is not going to work on windows, at least if I interprete 
  
    
      igraph/tests/testsuite.at
    
    
         Line 30
      in
      19946d0
    
  
  
    

        
          
           AT_CHECK([DYLD_LIBRARY_PATH=${abs_top_builddir}/src/.libs${DYLD_LIBRARY_PATH+:$DYLD_LIBRARY_PATH} LD_LIBRARY_PATH=${abs_top_builddir}/src/.libs${LD_LIBRARY_PATH+:$LD_LIBRARY_PATH} ./itest], [], [expout])]) 
        
    
  


-> If that's shell command to set a path, then that isn't going to work :-( LD_LIBRARY_PATH is also probably not be used on windows.
-> I've no clue of m4 and how to make that spit out what the problem is here.  :-(",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,34,https://github.com/igraph/igraph/pull/951#issuecomment-234218085,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","@szhorvat good idea! I've actually no clue how the tests work, so I'm mostly doing trial&error here :-/",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/szhorvat,35,https://github.com/igraph/igraph/pull/951#issuecomment-234218660,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","I'm not fully following what you're doing here (sorry, too many comments to read :-) ), but I do build igraph (master branch) successfully with mingw-w64 + msys2.  I can also run the tests. There are some that fail due to different printing of floating point infinities, but there aren't any true problems.  #886
As I said earlier, I never managed with MSVC, so it's great that you're sorting that out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,36,https://github.com/igraph/igraph/pull/951#issuecomment-234221926,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","If that's shell command to set a path, then that isn't going to work :-(

Yes; basically, the linker on Linux looks for .so files (the equivalents of DLLs) in some predefined places plus whatever directories you put in LD_LIBRARY_PATH. Mac OS X is the same but with DYLD_LIBRARY_PATH. The line that you pointed to sets up these environment variables to ensure that the tests are run with the version of igraph that was compiled.
As far as I know, the closest thing to these on Windows is the PATH variable. When looking for a DLL, Windows looks at the folder of the executable and the folders in the PATH variable (and probably some standard places). So, maybe you could get around this by setting the PATH to include the folder that contains the freshly built igraph.dll temporarily.",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,37,https://github.com/igraph/igraph/pull/951#issuecomment-234222270,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Ok, I've set the PATH to the folder which has the dll, lets see if that's already enough to fix it :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,38,https://github.com/igraph/igraph/pull/951#issuecomment-234228723,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","Ok, setting the PATH seems not be enough (or I messed up something there): https://ci.appveyor.com/project/ntamas/igraph/build/1.0.51/job/8j5f777fx1sn3ham
@szhorvat Could you paste here the commands you used to run the testsuite?",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,39,https://github.com/igraph/igraph/pull/951#issuecomment-234230459,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",seems that I messed something up? at least the new path didn't show up in the testsuite.log...,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/szhorvat,40,https://github.com/igraph/igraph/pull/951#issuecomment-234236865,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",I'll tell you how I do it in in the evening (European time).,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,41,https://github.com/igraph/igraph/pull/951#issuecomment-234269430,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",@szhorvat thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/szhorvat,42,https://github.com/igraph/igraph/pull/951#issuecomment-234304207,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","It doesn't look like I'll get to a Windows machine with msys2 today.  So here it is, partly from my notes, partly from memory.  This is probably not the ""right way"", and I don't claim to understand what I'm doing.  But it works, at least so far.  If you know how/when it might cause trouble, and how to fix that, please let me know.
First build gmp:
./configure --prefix=$HOME/local
make
make check

This builds the static library.  It produces an .a file and an .la file.  I'm installing everything into $HOME/local.
Now we build igraph.  I never build the graphml stuff because I don't need it, but I do need GMP.
For some reason that I don't understand, linking gmp statically fails since a few months ago (after an msys update).  If I delete the .la file, then linking succeeds and everything seems to work fine.  I don't know why and I welcome explanations.  So before building igraph, delete gmp's .la file.
Now in the igraph directory,
export CPPFLAGS=""-I$HOME/local/include -DMSDOS"" LDFLAGS=-L$HOME/local/lib

Defining MSDOS solves many problems and prevents trying to include UNIX-specific stuff that's no available in MinGW.  I don't remember the details, but I remember that when I looked into it, it seemed that this had to be defined on Windows (not on DOS!).  I also remember that originally @ntamas said that this seems DOS specific and shouldn't be used, but in the end I concluded that it wasn't so.  This is for some libraries that igraph (0.8 branch) relies on and ships with.
Then proceed with:
./bootstrap.sh
./configure --prefix=$HOME/local --disable-graphml
make
make install

Now add $HOME/local/bin to the PATH environment variable so programs can find the igraph DLL.
Now you can do make check and everything should succeed except for what I mentioned in #886
I used msys2 from https://msys2.github.io/ and installed dependencies using instructions here: https://wiki.qt.io/MSYS2
This is how I build igraph to be used in the Mathematica interface (IGraph/M).  Then I build the Mathematica interface using MSVC (2015).  To avoid ABI-incompatibility problems between MSVC and MinGW, it is important to use free/malloc in compatible pairs.  That's the reason for this pull request: #933 (already merged).
I know this looks like a mess, but it's the only way I could get things working in the amount of time I had to spend on this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/szhorvat,43,https://github.com/igraph/igraph/pull/951#issuecomment-234304978,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Someone should really write up a detailed guide for building with various toolchains ...,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,44,https://github.com/igraph/igraph/pull/951#issuecomment-234377971,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","And it worked. In then end it was my stupidity with setting PATH :-)
Thanks @szhorvat for the PATH hint! :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/szhorvat,45,https://github.com/igraph/igraph/pull/951#issuecomment-234387652,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)",Can you give me any hints about how to make GMP link statically without messing with the .la file?  Do you enable GMP?,True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/jankatins,46,https://github.com/igraph/igraph/pull/951#issuecomment-236212289,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","@szhorvat I've actually no clue right now. I only managed to compile it because I wanted it compiled for the python port :-)
@ntamas @gaborcsardi it built, IMO this is ready to be merged :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,951,2016-07-08T11:39:13Z,2016-08-02T15:08:28Z,2016-08-02T15:08:37Z,MERGED,True,223,85,20,https://github.com/jankatins,Implement CI tests on windows (appveyor),40,[],https://github.com/igraph/igraph/pull/951,https://github.com/ntamas,47,https://github.com/igraph/igraph/pull/951#issuecomment-236934562,"Currently WIP... I'm currently trying it in my own fork with my account: https://ci.appveyor.com/project/JanSchulz/igraph/
In the end, it needs appveyor enabling in this project: an owner in this project needs to get a appveyor account and enable the project in the appveyor UI.
I also suspect that the msvc tests will not build due to #909 (comment)","This is great job, thanks for all your hard work on this!",True,{}
igraph/igraph,https://github.com/igraph/igraph,958,2016-08-12T20:37:35Z,2016-08-14T19:44:27Z,2016-08-14T19:44:27Z,MERGED,True,2188,2707,74,https://github.com/abeham,DLL Imports/Exports and fixes for Visual Studio Builds,5,[],https://github.com/igraph/igraph/pull/958,https://github.com/abeham,1,https://github.com/igraph/igraph/pull/958,"Two changes are critical, I don't know if you want to make them:

src/cliquer/graph.c was renamed to src/cliquer/graph2.c
src/heap.c was renamed to src/heap2.c

Otherwise in Visual Studio (2013) both heap.c and heap.cc build to the same .o file and overwrite each other.
Other than that:

I included PRPACK in makefile's echosources target so that these are part of the visual studio project
I added MSDOS to the compiler's preprocessor definitions (otherwise there is a compile error)
I removed the __BEGIN_DECL and __END_DECL directives from each header file and put them in igraph_decl.h which is included in all .h files that had these directives
I added DECLDIR directive to all ""public"" functions which is either empty, or when Visual Studio is used as compiler is __declspec(dllexport) when building with IGRAPH_EXPORTS flag or __declspec(dllimport) when building without the flag","Two changes are critical, I don't know if you want to make them:

src/cliquer/graph.c was renamed to src/cliquer/graph2.c
src/heap.c was renamed to src/heap2.c

Otherwise in Visual Studio (2013) both heap.c and heap.cc build to the same .o file and overwrite each other.
Other than that:

I included PRPACK in makefile's echosources target so that these are part of the visual studio project
I added MSDOS to the compiler's preprocessor definitions (otherwise there is a compile error)
I removed the __BEGIN_DECL and __END_DECL directives from each header file and put them in igraph_decl.h which is included in all .h files that had these directives
I added DECLDIR directive to all ""public"" functions which is either empty, or when Visual Studio is used as compiler is __declspec(dllexport) when building with IGRAPH_EXPORTS flag or __declspec(dllimport) when building without the flag",True,{}
igraph/igraph,https://github.com/igraph/igraph,958,2016-08-12T20:37:35Z,2016-08-14T19:44:27Z,2016-08-14T19:44:27Z,MERGED,True,2188,2707,74,https://github.com/abeham,DLL Imports/Exports and fixes for Visual Studio Builds,5,[],https://github.com/igraph/igraph/pull/958,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/958#issuecomment-239569709,"Two changes are critical, I don't know if you want to make them:

src/cliquer/graph.c was renamed to src/cliquer/graph2.c
src/heap.c was renamed to src/heap2.c

Otherwise in Visual Studio (2013) both heap.c and heap.cc build to the same .o file and overwrite each other.
Other than that:

I included PRPACK in makefile's echosources target so that these are part of the visual studio project
I added MSDOS to the compiler's preprocessor definitions (otherwise there is a compile error)
I removed the __BEGIN_DECL and __END_DECL directives from each header file and put them in igraph_decl.h which is included in all .h files that had these directives
I added DECLDIR directive to all ""public"" functions which is either empty, or when Visual Studio is used as compiler is __declspec(dllexport) when building with IGRAPH_EXPORTS flag or __declspec(dllimport) when building without the flag","Thanks for your work on this, it looks great!
I would prefer renaming src/cliquer/graph.c to src/cliquer/cliquer_graph.c and src/bliss/heap.cc to src/bliss/bliss_heap.cc instead - feels more readable than graph2.c and heap2.c.
Also, the AppVeyor build has failed for one of the build configurations because MSVC does not seem to include stdint.h:
https://ci.appveyor.com/project/ntamas/igraph/build/1.0.55/job/6x86orpkpp7d0xyf#L3494
To be honest, I don't quite understand why it fails - more precisely, I don't understand how the other three build configurations on AppVeyor could succeed if stdint.h is missing. It can even happen that prpack_solver.cpp does not need stdint.h at all. Can you try recompiling this without stdint.h on your machine?",True,{}
igraph/igraph,https://github.com/igraph/igraph,958,2016-08-12T20:37:35Z,2016-08-14T19:44:27Z,2016-08-14T19:44:27Z,MERGED,True,2188,2707,74,https://github.com/abeham,DLL Imports/Exports and fixes for Visual Studio Builds,5,[],https://github.com/igraph/igraph/pull/958,https://github.com/abeham,3,https://github.com/igraph/igraph/pull/958#issuecomment-239638379,"Two changes are critical, I don't know if you want to make them:

src/cliquer/graph.c was renamed to src/cliquer/graph2.c
src/heap.c was renamed to src/heap2.c

Otherwise in Visual Studio (2013) both heap.c and heap.cc build to the same .o file and overwrite each other.
Other than that:

I included PRPACK in makefile's echosources target so that these are part of the visual studio project
I added MSDOS to the compiler's preprocessor definitions (otherwise there is a compile error)
I removed the __BEGIN_DECL and __END_DECL directives from each header file and put them in igraph_decl.h which is included in all .h files that had these directives
I added DECLDIR directive to all ""public"" functions which is either empty, or when Visual Studio is used as compiler is __declspec(dllexport) when building with IGRAPH_EXPORTS flag or __declspec(dllimport) when building without the flag","Yes, very strange that only one failed. prpack_solver.cpp builds fine in VS2013 without stdint.h so I removed it. I also made the requested filename changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,958,2016-08-12T20:37:35Z,2016-08-14T19:44:27Z,2016-08-14T19:44:27Z,MERGED,True,2188,2707,74,https://github.com/abeham,DLL Imports/Exports and fixes for Visual Studio Builds,5,[],https://github.com/igraph/igraph/pull/958,https://github.com/abeham,4,https://github.com/igraph/igraph/pull/958#issuecomment-239641512,"Two changes are critical, I don't know if you want to make them:

src/cliquer/graph.c was renamed to src/cliquer/graph2.c
src/heap.c was renamed to src/heap2.c

Otherwise in Visual Studio (2013) both heap.c and heap.cc build to the same .o file and overwrite each other.
Other than that:

I included PRPACK in makefile's echosources target so that these are part of the visual studio project
I added MSDOS to the compiler's preprocessor definitions (otherwise there is a compile error)
I removed the __BEGIN_DECL and __END_DECL directives from each header file and put them in igraph_decl.h which is included in all .h files that had these directives
I added DECLDIR directive to all ""public"" functions which is either empty, or when Visual Studio is used as compiler is __declspec(dllexport) when building with IGRAPH_EXPORTS flag or __declspec(dllimport) when building without the flag","Okay, I think that did it. I had to avoid including stdint.h also for MINGW builds. But reusing pstdint.h was not the way to go...",True,{}
igraph/igraph,https://github.com/igraph/igraph,958,2016-08-12T20:37:35Z,2016-08-14T19:44:27Z,2016-08-14T19:44:27Z,MERGED,True,2188,2707,74,https://github.com/abeham,DLL Imports/Exports and fixes for Visual Studio Builds,5,[],https://github.com/igraph/igraph/pull/958,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/958#issuecomment-239692669,"Two changes are critical, I don't know if you want to make them:

src/cliquer/graph.c was renamed to src/cliquer/graph2.c
src/heap.c was renamed to src/heap2.c

Otherwise in Visual Studio (2013) both heap.c and heap.cc build to the same .o file and overwrite each other.
Other than that:

I included PRPACK in makefile's echosources target so that these are part of the visual studio project
I added MSDOS to the compiler's preprocessor definitions (otherwise there is a compile error)
I removed the __BEGIN_DECL and __END_DECL directives from each header file and put them in igraph_decl.h which is included in all .h files that had these directives
I added DECLDIR directive to all ""public"" functions which is either empty, or when Visual Studio is used as compiler is __declspec(dllexport) when building with IGRAPH_EXPORTS flag or __declspec(dllimport) when building without the flag","Thanks, now I think this one is ready for merging.",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/EmSyndio,1,https://github.com/igraph/igraph/pull/982,"see:
#580","see:
#580",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/EmSyndio,2,https://github.com/igraph/igraph/pull/982#issuecomment-292731911,"see:
#580","Could you possibly cut a new release though?
Thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/982#issuecomment-292905103,"see:
#580",I cannot make a release on my own. @gaborcsardi?,True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/982#issuecomment-292908366,"see:
#580","Making a new release is a big undertaking. There were a large number of new functions added, API changes, etc.
Personally, I would prefer if you could wait until I can submit a complete pull request for transitioning everything to the new (fast) maximal clique finder. That would also make pull request #824 obsolete.  However, I can't promise to be able to finish that before ~2 months from now.
I wish I could also finish the LAD update (which will certainly make more API changes necessary), but I don't think I will have enough time for that ...
P.S. I am saying this because I would also prefer to be able to base the Mathematica interface off a released igraph instead of having to maintain my own fork.  But some of these max clique changes are already in the version I released this weekend.",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/982#issuecomment-292909241,"see:
#580",Or maybe I misunderstood and this was a request for a 0.7.2 bugfix release instead of a new 0.8 one?,True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/982#issuecomment-292909372,"see:
#580","Yes, it's a request for 0.7.2. In theory, 0.7.2 could be released easily because the changes in this pull request were merged into the release-0.7 branch and not the master branch, so the only thing that changed between 0.7.1 and 0.7.2 is this fix (as far as I know).",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/982#issuecomment-292909559,"see:
#580",Then disregard my comment please. It does not apply to this situation.,True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/EmSyndio,8,https://github.com/igraph/igraph/pull/982#issuecomment-293340862,"see:
#580","Just confirming here:
This PR is to incorporate the Burt's constraint bug fix in the 0.7.x release.
This bug fix was supposed to be in 0.7.1 as per the release notes, but it was not.
The PR just remerged the bug fix into release-0.7 branch.
A new release should simply be about tagging and creating a release from that branch.
Personally, I just want to be able to use Burt on the latest stable official release (i.e. pull the tar file and build) and not have to patch it myself before building, diverging from official release.
Thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/EmSyndio,9,https://github.com/igraph/igraph/pull/982#issuecomment-332006785,"see:
#580","still no new release for this... :-(
@gaborcsardi?",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/982#issuecomment-494664785,"see:
#580","Shall we close this @ntamas @szhorvat @iosonofabio, since it is already merged in master, and we will not update release-0.7 any further?",True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/982#issuecomment-494689689,"see:
#580",Not much to do there; this is a merged PR and #580 is already closed.,True,{}
igraph/igraph,https://github.com/igraph/igraph,982,2017-04-08T00:59:52Z,2017-04-08T16:11:13Z,2019-05-22T07:48:11Z,MERGED,True,1,1,1,https://github.com/EmSyndio,fix original issue #580 not propagated to 0.7.1 release,1,[],https://github.com/igraph/igraph/pull/982,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/982#issuecomment-494692822,"see:
#580","Ah yes, sorry.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,1,https://github.com/igraph/igraph/pull/990,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,2,https://github.com/igraph/igraph/pull/990#issuecomment-297957401,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","AppVeyor build generates a couple of syntax errors on file src\attributes.c, which I have not commit at all. Really don't know if should I resolve this here, since seems not related with Fluid Communities implementation.
If someone could guide me, it would be nice.
.\src\attributes.c(419) : error C2143: syntax error : missing ')' before '*'
.\src\attributes.c(419) : error C2059: syntax error : ')'

417    type=(igraph_attribute_combination_type_t)va_arg(ap, int);
418    if (type == IGRAPH_ATTRIBUTE_COMBINE_FUNCTION) {
419      func=va_arg(ap, void (*)(void));
420    }",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/990#issuecomment-346369056,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","Is no_of_communities meant to be an input parameter?  If yes, why is it a pointer?  It seems to me that it should be an igraph_integer_t instead of an int *.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/990#issuecomment-346381154,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","I tried this function and I was wondering why it returns precisely one more community than requested when the graph is disconnected.  E.g. when asking for 4, it gives me 5.
If there are requirements on the connectedness or other properties of the graph, they should be checked by at the beginning of the function. If some of them are not met, the function should report an error and abort (using IGRAPH_ERROR).",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/990#issuecomment-346442127,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",Thanks Szabolcs for starting to review this PR. I was putting this aside for quite a while now due to lack of time and familiarity with the algorithm. Do you happen to know how the algorithm works from a theoretical point of view?,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,6,https://github.com/igraph/igraph/pull/990#issuecomment-346954668,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","I've made corresponding code changes to set no_of_communities variable as igraph_integer_t type. Tried to check everything you commented me, @szhorvat .
Regarding the IGRAPH_ERROR checking the connectedness of the graph, I've to explore how to do that but I'll do it. The reason of your malfunction is that, at function initialization i set membership of all nodes to community 0, which I treat as no community (it is necessary to do it the way algorithm works). Algorithm mathematically should not leave any node without community assigned at convergence if the graph is connected. When inputting a disconnected graph previous property is not ensured, so some nodes membership still assigned to 0, meaning no community assigned.
Fluid Communities algorithm is only thought to run on connected graphs right now. So I implement this requirement as soon as possible.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/990#issuecomment-347006333,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@FerranPares Thanks for the update.
As a start, could you state what requirements your algorithm imposes on the graph?  Does it work on disconnected graphs?  Directed graphs?  Graphs with loop edges (1-1) or multiple edges (1-2, 1-2)?  Any other restrictions?
It should also be verified that the function handles edge cases (such as an empty graph or a single vertex).
These requirements should be stated in the documentation, and the function should verify them when appropriate (e.g. when checking that the input is correct doesn't take longer than running the algorithm).  There are multiple ways you can handle the requirements: e.g. if only undirected graphs are supported, then instead of checking that the graph is undirected, you can state in the documentation that edge directions will be ignored.
As for checking connectedness, you can use igraph_is_connected().  If the algorithm requires a simple graph, you can use igraph_is_simple() for the check.
Regarding the no_of_communities argument, I still do not understand why it is a pointer. It seems to me that this is an input parameter, i.e. you use the value but never change it.  Why can't it be a simple value instead of a pointer to a value then?",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,8,https://github.com/igraph/igraph/pull/990#issuecomment-347188368,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","Implemented and documented requirements:

Connected: It is a must. If unconnected throw an error. IGRAPH_EINVAL
Unweighted: I directly don't ask for weights as an input argument but I say in the docstring that function is for unweighted graphs. IGRAPH_EINVAL
Undirected: I've set up a warning message. If graph is directed, throw the warning message and treat graph as undirected.
Loop and multiple edges: FluidC was not originally thought to work with loop edges or multiple edges. If graph is not simple then I throw an error. IGRAPH_EINVAL
Empty or single vertex graph: Those cases do not make sense. So, I throw an error on them (in fact, if no_of_nodes < no_of_communities I throw an additional error). IGRAPH_EINVAL
Additionally, I introduced an internal IGRAPH_ERROR check under IGRAPH_EINTERNAL code at the end of the function. It should never be activated, if it does means something went internally wrong.  IGRAPH_EINTERNAL

no_of_communities can be a simple value instead of a pointer. I'm not used to program with pointers, so I don't really know which are the main reasons for using a pointer or not. Think I start getting the point on when to use them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/990#issuecomment-347326061,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","Thank you for making these fixes @FerranPares. One more thing I wanted to mention is that I noticed that you do not declare all variables at the beginning of blocks.  While most C compilers accept this, technically it is not valid ANSI C (C89). I am not an igraph maintainer, and I do not know how the maintainers feel about this. (Personally, I always put the declarations at the beginning in my pull requests, for compliance reasons, even though this hurts readability.)
@ntamas : I am not yet very familiar with how the algorithm works, I simply played with this implementation a bit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,10,https://github.com/igraph/igraph/pull/990#issuecomment-347819272,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","I just have 3 blocks of variables initialization, 2 of them at function initialization (before main loop) and 1 block inside the main loop at the very beginning of it. What do you exactly refer to? Do you want me to do option 1 or 2?

Option 1: Put first 2 blocks together at the very beginning of the function and leave the third as it is at the beginning of the main loop.
Option 2: Join all three blocks at the very beginning, the first two blocks and the third one corresponding to the main loop variables.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/990#issuecomment-347821319,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","Just to be clear: I am not an igraph maintainer, and I do not know how strict @ntamas and @gaborcsardi want to be about standards compliance.
Here's an excerpt from your code:
  if (igraph_is_directed(graph)) {
     IGRAPH_WARNING(""Edge directions are ignored."");
   }
 
   /* Internal variables initialization */
   long int i, j, k, kv1;
   igraph_adjlist_t al;

This is not valid ANSI C because you are mixing declarations with code.  Declarations must be at the beginning of the block.
This is invalid:
{
    printf(""xxx"");
    int x=1;
}

This is valid:
{
    int x;
    
    printf(""xxx"");
    x = 1;
}",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,12,https://github.com/igraph/igraph/pull/990#issuecomment-347831927,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@szhorvat Thanks for the clarification!
So, I wait for @ntamas or @gaborcsardi to say something about it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/990#issuecomment-348142546,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","One more thing I wanted to mention is that I noticed that you do not declare all variables at the beginning of blocks. While most C compilers accept this, technically it is not valid ANSI C (C89). I am not an igraph maintainer, and I do not know how the maintainers feel about this.

I've had problems before with declarations that were not at the beginning of blocks (I think that MSVC on Windows is particularly picky about this), so I tend to move them to the top nowadays. It would be good if we could stick to this.
Also, sorry for the late reply, it's a busy week for me (barely have any time to spend online). I'll return to the PR next week when things are more quiet.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,14,https://github.com/igraph/igraph/pull/990#issuecomment-348960625,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","Ok, I have placed all declaration blocks at the beginning of blocks to have valid ANSI C (C89) code.
I have seen that AppVeyor fails on installing an specific dependency in Python 3.4 before building up Igraph. Hope everything is alright on my PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,15,https://github.com/igraph/igraph/pull/990#issuecomment-361241118,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@ntamas The PR is ready waiting for you to check and merge it. No pressure on that, just a reminder.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/990#issuecomment-536589860,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",Please do ping me before a final merge would take place. I do already have this integrated into IGraph/M and it would be easy for me to run a few tests.,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,17,https://github.com/igraph/igraph/pull/990#issuecomment-536597740,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","All proposed changes are done! Hope everything looks nice now for final merge.
PD: Sorry for the rebase of all my commits. Did not expect to mess the references up :/.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/vtraag,18,https://github.com/igraph/igraph/pull/990#issuecomment-536915795,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@szhorvat feel free to check it further, as far as I am concerned it is good to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/990#issuecomment-536958429,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",Something seems to have gotten broken with the recent changes. It's simply not working correctly anymore. I am requesting 3 communities and it's giving me one.,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/990#issuecomment-536961892,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",Sorry for not giving a more specific example—I can see this behaviour with the Mathematica interface. I need to look into what exactly is happening.,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/vtraag,21,https://github.com/igraph/igraph/pull/990#issuecomment-536963369,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@szhorvat , it seemed to be working correctly for me. Perhaps something in the interface got changed? The whole PR was force-pushed because it was rebased, perhaps the Mathematica interface was still designed for the previous PR?",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/990#issuecomment-536964675,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","I think we need an #include ""igraph_structural.h"" at the beginning of the file, otherwise my IDE complains about not knowing igraph_is_simple().",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/990#issuecomment-536975840,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@vtraag @FerranPares Here's an example that goes wrong:
#include <igraph.h>

int main() {
    igraph_t g;
    igraph_vector_t membership;
    igraph_real_t modularity;

    igraph_small(&g, 8, 0,
                 0,1, 0,2, 0,3, 1,2, 1,3, 2,3,
                 3,4,
                 4,5, 4,6, 4,7, 5,6, 5,7, 6,7,
                 -1);

    igraph_vector_init(&membership, 0);

    igraph_community_fluid_communities(&g, 2, &membership, &modularity);

    igraph_vector_print(&membership);

    igraph_vector_destroy(&membership);
    igraph_destroy(&g);

    return 0;
}
The typical membership vector it outputs is now 1 1 1 1 1 1 1 1 or 0 0 0 0 0 0 0 0 (i.e. a single community).
Previously, it was 0 0 0 0 1 1 1 1.
The graph looks like this:",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/990#issuecomment-536976738,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","A final comment/question:
Is community_fluid_communities the best name? It's a little strange to repeat the word ""community"" twice. I don't have strong feeling about this though.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/vtraag,25,https://github.com/igraph/igraph/pull/990#issuecomment-537041326,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",It seems something is not going well with resetting the label_counters in L2333-2336. Adding back in  igraph_vector_null(&label_counters); after L2262 solves the problem you identified @szhorvat.,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,26,https://github.com/igraph/igraph/pull/990#issuecomment-537075675,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@FerranPares After fixing the above issue, could you make a few changes to the test?

Move to examples/tests (new place for tests, decided after you originally opened the PR)
Make the test deterministic by seeding the RNG.
Make the verification a bit more sensitive (so that it would catch issues like the above). E.g., check that there are exactly as many clusters as expected.

I think it's okay to do this by adding more commits (so we can more easily keep track of changes).",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,27,https://github.com/igraph/igraph/pull/990#issuecomment-537139876,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","I have no clue right now why this is failing. I guess it has something to do with moving the test to the new folder, but I'm missing something.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/vtraag,28,https://github.com/igraph/igraph/pull/990#issuecomment-537368488,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","The output log of Travis CI gives the following information:
/home/travis/build/igraph/igraph/examples/tests/igraph_community_fluid_communities.c: In function 'main':
/home/travis/build/igraph/igraph/examples/tests/igraph_community_fluid_communities.c:31:12: warning: unused variable 'i' [-Wunused-variable]
   long int i;
            ^

The test checks whether the output corresponds to the expected output, and this includes also these types of warnings.
Just delete L31 of igraph_community_fluid_communities.c, and you should be fine.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/szhorvat,29,https://github.com/igraph/igraph/pull/990#issuecomment-537376450,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",Any comments on the naming? Would igraph_community_fluid be better than igraph_community_fluid_communities?,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/vtraag,30,https://github.com/igraph/igraph/pull/990#issuecomment-537377585,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","I agree that igraph_community_fluid_communities is a bit superfluous (pun intended), but the name of the original article is ""Fluid Communities: ..."", so I have no objection.",True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/FerranPares,31,https://github.com/igraph/igraph/pull/990#issuecomment-537402734,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf",Thanks for your help in merging this PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,990,2017-04-28T08:48:01Z,2019-10-02T08:52:37Z,2019-10-02T09:01:39Z,MERGED,True,326,0,8,https://github.com/FerranPares,Fluid Communities implementation,14,[],https://github.com/igraph/igraph/pull/990,https://github.com/vtraag,32,https://github.com/igraph/igraph/pull/990#issuecomment-537403735,"As explained in the issue we created at #983, we are interested on implementing our community detection algorithm called ""Fluid Communities"" [1] into igraph. Fluid Communities is competitive in performance and computational cost, obtaining results close to best community detection algorithms like Multilevel, and being as fast as Label Propagation.
We already implemented the algorithm in igraph, so we open this pull request. Hope everything is fine.
Regards,
Ferran Parés
[1] https://arxiv.org/pdf/1703.09307.pdf","@FerranPares thanks for your perseverance, still engaging after 2 years!",True,{}
igraph/igraph,https://github.com/igraph/igraph,991,2017-04-30T16:01:58Z,2017-04-30T22:13:54Z,2017-04-30T22:13:58Z,MERGED,True,7,6,1,https://github.com/szhorvat,Improve igraph_connect_neighborhood documentation,1,[],https://github.com/igraph/igraph/pull/991,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/991,"Also mention the term ""graph power"".","Also mention the term ""graph power"".",True,{}
igraph/igraph,https://github.com/igraph/igraph,991,2017-04-30T16:01:58Z,2017-04-30T22:13:54Z,2017-04-30T22:13:58Z,MERGED,True,7,6,1,https://github.com/szhorvat,Improve igraph_connect_neighborhood documentation,1,[],https://github.com/igraph/igraph/pull/991,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/991#issuecomment-298260837,"Also mention the term ""graph power"".",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1002,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.","This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1002#issuecomment-301235731,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.",Do you guys prefer a warning for when mode != IGRAPH_ALL and the graph is undirected?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/gaborcsardi,3,https://github.com/igraph/igraph/pull/1002#issuecomment-301237297,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.","Do you guys prefer a warning for when mode != IGRAPH_ALL and the graph is undirected?

No, no warning is necessary.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1002#issuecomment-346345109,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.",Do you need me to do anything else with this one before it can be merged?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1002#issuecomment-346444422,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.",I'll try to find some time to review this and your other PRs this week and then I'll merge it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1002#issuecomment-370764275,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.",Do you need anything else from me before this can be merged?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1002#issuecomment-370767753,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.","Sorry, probably nothing, apart from time, which is not your concern of course. I'm just way too much behind with everything else.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1002#issuecomment-439376639,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.","This is currently okay to merge. I would like to sync up my fork with the official igraph, but it just keeps drifting apart (mostly due to me having started too many unfisnished PRs)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1002,2017-05-12T16:16:08Z,2018-11-21T15:10:09Z,2018-11-21T15:10:14Z,MERGED,True,114,0,3,https://github.com/szhorvat,igraph_rewire_directed_edges,1,[],https://github.com/igraph/igraph/pull/1002,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1002#issuecomment-440698308,"This is a pull request for the feature described in #999
The function is modelled after igraph_rewire_edges and borrows some code from it.  Please review especially the part that handles attributes, as I am not very familiar with this part of igraph, and the code has simply been borrowed from igraph_rewire_edges.","Seems good, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1012,2017-07-05T04:39:51Z,2017-12-22T20:41:16Z,2017-12-22T21:01:14Z,MERGED,True,8,6,1,https://github.com/xuhdev,Clarify the doc of param start_from of igraph_barabasi_game.,1,[],https://github.com/igraph/igraph/pull/1012,https://github.com/xuhdev,1,https://github.com/igraph/igraph/pull/1012,"Clarify what it means by having start_from being a null pointer.

The same issue also exists in the Python API documentation.","Clarify what it means by having start_from being a null pointer.

The same issue also exists in the Python API documentation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1012,2017-07-05T04:39:51Z,2017-12-22T20:41:16Z,2017-12-22T21:01:14Z,MERGED,True,8,6,1,https://github.com/xuhdev,Clarify the doc of param start_from of igraph_barabasi_game.,1,[],https://github.com/igraph/igraph/pull/1012,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1012#issuecomment-353671402,"Clarify what it means by having start_from being a null pointer.

The same issue also exists in the Python API documentation.",Thanks (and sorry that it took so long)!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1015,2017-07-16T10:50:29Z,2017-08-04T03:36:03Z,2017-08-04T03:36:03Z,MERGED,True,35,10,5,https://github.com/jannick0,GCC not tolerating empty variadic argument without ## token before __VA_ARGS__,1,[],https://github.com/igraph/igraph/pull/1015,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1015,"In preprocessor macros GCC does not tolerate an empty variadic argument __VA_ARGS__ without a preceding ## token, since in this case the preceding comma is not removed.
The proposed patch singles out GCC compliant compilers to add the required ## token. In case this syntax is fine for any other compiler, then clearly the #ifdef branches can be removed and only the ## token before __VA_ARGS__ can be added. I checked that MSVC does not complain about the additional ##.","In preprocessor macros GCC does not tolerate an empty variadic argument __VA_ARGS__ without a preceding ## token, since in this case the preceding comma is not removed.
The proposed patch singles out GCC compliant compilers to add the required ## token. In case this syntax is fine for any other compiler, then clearly the #ifdef branches can be removed and only the ## token before __VA_ARGS__ can be added. I checked that MSVC does not complain about the additional ##.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1015,2017-07-16T10:50:29Z,2017-08-04T03:36:03Z,2017-08-04T03:36:03Z,MERGED,True,35,10,5,https://github.com/jannick0,GCC not tolerating empty variadic argument without ## token before __VA_ARGS__,1,[],https://github.com/igraph/igraph/pull/1015,https://github.com/gaborcsardi,2,https://github.com/igraph/igraph/pull/1015#issuecomment-315632204,"In preprocessor macros GCC does not tolerate an empty variadic argument __VA_ARGS__ without a preceding ## token, since in this case the preceding comma is not removed.
The proposed patch singles out GCC compliant compilers to add the required ## token. In case this syntax is fine for any other compiler, then clearly the #ifdef branches can be removed and only the ## token before __VA_ARGS__ can be added. I checked that MSVC does not complain about the additional ##.",I don't understand. We have always used GCC to compile igraph. Why is this a problem now?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1015,2017-07-16T10:50:29Z,2017-08-04T03:36:03Z,2017-08-04T03:36:03Z,MERGED,True,35,10,5,https://github.com/jannick0,GCC not tolerating empty variadic argument without ## token before __VA_ARGS__,1,[],https://github.com/igraph/igraph/pull/1015,https://github.com/jannick0,3,https://github.com/igraph/igraph/pull/1015#issuecomment-315635372,"In preprocessor macros GCC does not tolerate an empty variadic argument __VA_ARGS__ without a preceding ## token, since in this case the preceding comma is not removed.
The proposed patch singles out GCC compliant compilers to add the required ## token. In case this syntax is fine for any other compiler, then clearly the #ifdef branches can be removed and only the ## token before __VA_ARGS__ can be added. I checked that MSVC does not complain about the additional ##.","Well, the issue is raised if flex is asked to produce a scanner file .yy.c  with debug mode enabled (flex -d) which then has some debug lines like fprintf( stderr, ""--(end of buffer or a NUL)\n"" );.
Given the error macro as is now this is the very case with an empty variadic argument gcc complains about (because after preprocessing there is in the argument list a lost comma directly followed by the closing bracket. More details in the link I added to the first posting).
Thus the macro definition is not purely GCC compliant and it looks like the scanners were not run in debug mode for some time though. Separately, today I checked that clang and MSVC are smart enough to remove the single comma if the variadic argument is empty.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1020,2017-07-25T19:16:29Z,2017-07-25T21:17:29Z,2017-07-25T21:18:57Z,MERGED,True,3,3,1,https://github.com/ryanduffin,Change GraphML namespace fprintf calls to use format specifiers,1,[],https://github.com/igraph/igraph/pull/1020,https://github.com/ryanduffin,1,https://github.com/igraph/igraph/pull/1020,"The changes introduced in this commit cause the build to fail when using gcc:
foreign-graphml.c: In function ‘igraph_write_graph_graphml’: foreign-graphml.c:1408:46: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""<graphml xmlns=\"""" GRAPHML_NAMESPACE_URI ""\""\n""); ^ foreign-graphml.c:1412:59: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""         xsi:schemaLocation=\"""" GRAPHML_NAMESPACE_URI ""\n""); ^ foreign-graphml.c:1414:38: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""         "" GRAPHML_NAMESPACE_URI ""/1.0/graphml.xsd\"">\n"");
Changing these lines to use format specifiers should solve this build issue and maintain proper behavior.","The changes introduced in this commit cause the build to fail when using gcc:
foreign-graphml.c: In function ‘igraph_write_graph_graphml’: foreign-graphml.c:1408:46: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""<graphml xmlns=\"""" GRAPHML_NAMESPACE_URI ""\""\n""); ^ foreign-graphml.c:1412:59: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""         xsi:schemaLocation=\"""" GRAPHML_NAMESPACE_URI ""\n""); ^ foreign-graphml.c:1414:38: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""         "" GRAPHML_NAMESPACE_URI ""/1.0/graphml.xsd\"">\n"");
Changing these lines to use format specifiers should solve this build issue and maintain proper behavior.",True,{'THUMBS_UP': ['https://github.com/isalgueiro']}
igraph/igraph,https://github.com/igraph/igraph,1020,2017-07-25T19:16:29Z,2017-07-25T21:17:29Z,2017-07-25T21:18:57Z,MERGED,True,3,3,1,https://github.com/ryanduffin,Change GraphML namespace fprintf calls to use format specifiers,1,[],https://github.com/igraph/igraph/pull/1020,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1020#issuecomment-317875306,"The changes introduced in this commit cause the build to fail when using gcc:
foreign-graphml.c: In function ‘igraph_write_graph_graphml’: foreign-graphml.c:1408:46: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""<graphml xmlns=\"""" GRAPHML_NAMESPACE_URI ""\""\n""); ^ foreign-graphml.c:1412:59: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""         xsi:schemaLocation=\"""" GRAPHML_NAMESPACE_URI ""\n""); ^ foreign-graphml.c:1414:38: error: expected ‘)’ before ‘GRAPHML_NAMESPACE_URI’ ret=fprintf(outstream, ""         "" GRAPHML_NAMESPACE_URI ""/1.0/graphml.xsd\"">\n"");
Changing these lines to use format specifiers should solve this build issue and maintain proper behavior.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1023,2017-08-10T00:55:01Z,2017-10-18T09:20:30Z,2020-11-30T07:50:27Z,MERGED,True,50,10,7,https://github.com/jannick0,pajek: optional time interval info of vertices and edges added to reader grammar ,3,[],https://github.com/igraph/igraph/pull/1023,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1023,"I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.","I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1023,2017-08-10T00:55:01Z,2017-10-18T09:20:30Z,2020-11-30T07:50:27Z,MERGED,True,50,10,7,https://github.com/jannick0,pajek: optional time interval info of vertices and edges added to reader grammar ,3,[],https://github.com/igraph/igraph/pull/1023,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1023#issuecomment-337520315,"I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.","Seems okay to me, thanks! (And sorry for the delay).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1023,2017-08-10T00:55:01Z,2017-10-18T09:20:30Z,2020-11-30T07:50:27Z,MERGED,True,50,10,7,https://github.com/jannick0,pajek: optional time interval info of vertices and edges added to reader grammar ,3,[],https://github.com/igraph/igraph/pull/1023,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1023#issuecomment-337554303,"I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.","Sorry, this pull request had to be reverted because of failing test cases in Pajek-related tests that I cannot seem to figure out right now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1023,2017-08-10T00:55:01Z,2017-10-18T09:20:30Z,2020-11-30T07:50:27Z,MERGED,True,50,10,7,https://github.com/jannick0,pajek: optional time interval info of vertices and edges added to reader grammar ,3,[],https://github.com/igraph/igraph/pull/1023,https://github.com/jannick0,4,https://github.com/igraph/igraph/pull/1023#issuecomment-735433882,"I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.",@ntamas Any chance to get this into the repo to add existing pajek features?  I am not sure if this needs amendments and the lexer/parser basis. the hook into the igraph functionality was open in the first place.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1023,2017-08-10T00:55:01Z,2017-10-18T09:20:30Z,2020-11-30T07:50:27Z,MERGED,True,50,10,7,https://github.com/jannick0,pajek: optional time interval info of vertices and edges added to reader grammar ,3,[],https://github.com/igraph/igraph/pull/1023,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1023#issuecomment-735434289,"I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.",I'll try to revisit this tomorrow and figure out what's wrong with the original PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1023,2017-08-10T00:55:01Z,2017-10-18T09:20:30Z,2020-11-30T07:50:27Z,MERGED,True,50,10,7,https://github.com/jannick0,pajek: optional time interval info of vertices and edges added to reader grammar ,3,[],https://github.com/igraph/igraph/pull/1023,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1023#issuecomment-735609103,"I added optional time interval tags to the Pajek grammar together with implied fixes in the pajek lexer. An issue recently raised in the userlist. I tried to make as little adjustments as possible.
@ntamas & @gaborcsardi  With that Pajek data conforming with the Pajek manual should be parsable (works for the example provided by the user from the userlist) and can thus be fed into graph objects. Implementation of the latter I better leave with you guys.
Separately, two additional innocent commits on guarding __clang__ #pragma's and on error messages glued to the grammar patch. Still a bit struggling with git here, but getting better.
HTH ... just let me know.","Okay, I merged this PR again into the develop branch manually; the most prominent failure is examples/simple/pajek_signed.c, which aborts on my machine. The input file looks like this:
*NETWORK First.net; 14.04.2009 / 09:46:56
*Vertices 10
1 ""S65""
2 ""S29""
3 ""S04""
4 ""S75""
5 ""S24""
6 ""S81""
7 ""S51""
8 ""S78""
9 ""S86""
10 ""S39""
*Matrix
 0 0 0 0 0 1 0 0 0 -1
 0 0 1 1 0 1 1 0 1 0
 -1 0 0 1 0 0 1 0 1 0
 -1 1 0 0 1 1 1 0 1 0
 0 1 0 1 0 0 0 0 -1 -1
 1 -1 0 0 0 0 0 1 0 0
 0 -1 1 1 0 -1 0 0 1 0
 0 0 1 1 0 1 -1 0 1 1
 0 0 0 0 0 0 0 0 0 -1
 1 1 1 1 1 1 1 1 1 0

The parsing fails right on line 1 (syntax error, unexpected ERROR, expecting NEWLINE).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,1,https://github.com/igraph/igraph/pull/1034,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1034#issuecomment-337833732,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Thanks for the pull request and sorry for the delay. I will add a few comments soon.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1034#issuecomment-380084123,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",@alexperrone  Are you still working on this?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,4,https://github.com/igraph/igraph/pull/1034#issuecomment-380143957,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat Yes, I'm still working on this. Not at this moment but I haven't forgotten and it's definitely on my to-do list and it will get off there -- it may be up to a couple months.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1034#issuecomment-439376750,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",@alexperrone Any updates on this?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,6,https://github.com/igraph/igraph/pull/1034#issuecomment-439618731,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",@szhorvat Please keep it open.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1034#issuecomment-474265708,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Any news on this @alexperrone ? It'd be great to have it merged ...,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,8,https://github.com/igraph/igraph/pull/1034#issuecomment-474457214,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat Still working on it... I'm struggling to get it built successfully with igraph as a whole even though the algorithm itself works. Thanks for the update, I'm doing my best on it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1034#issuecomment-474521291,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","I'm struggling to get it built successfully with igraph as a whole

What kinds of problems are you running into?  Did you manage to build igraph itself, without your additions?  What OS are you using, and what compiler?  Maybe I can help.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,10,https://github.com/igraph/igraph/pull/1034#issuecomment-475926296,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat  @ntamas Yes, I just built igraph successfully as far as I can tell (make check looked good and it seemed to install without errors) using a clone of this forked repository which has the truss code. Every test passed except the one for truss in tests/community.at (which is expected right now). However, I can't seem to compile examples/simple/igraph_truss.cpp on its own anymore. Originally, it worked when I developed on Linux Ubuntu. Now I'm on Mac OS 10.12 machine.
To attempt to compile this code, I first ran:
> pkg-config --libs --cflags igraph
-I/usr/local/include/igraph -L/usr/local/lib -ligraph

so I issued the following compile command, which fails. I'm not sure what it's not finding.
igraph/examples/simple >> g++ -std=c++11 igraph_truss.cpp -I /usr/local/include/igraph -I . -I ../../src/ -L /usr/local/lib -ligraph -o truss
Undefined symbols for architecture x86_64:
  ""_igraph_truss"", referenced from:
      _main in igraph_truss-c0d94f.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)

Update: I've determined if I comment out line 67 in examples/simple/igraph_truss.cpp:
igraph_truss(&graph, &truss);
then I can successfully compile and it runs the code, although it does not compute anything so there's no point. However, I can compile it. So it's not able to use the header truss.h even though it is included in the compile command (-I ../../src/ and also if I put the absolute path, the error is the same).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1034#issuecomment-476150539,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","It is not finding the new variant of  libigraph that includes igraph_truss() -- it finds the ""old"" one installed somewhere else on your system. You need DYLD_LIBRARY_PATH=some-folder-that-contains-the-new-libigraph0.dylib ./truss - the folder given in the DYLD_LIBRARY_PATH envvar will take precedence over the standard library paths.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1034#issuecomment-476160280,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@ntamas  I am not familiar with pkg-config, so I'm not sure what that line does ... but would it not be still necessary to add -ligraph to the compilation command?
@alexperrone Side comment: It may not be the best of ideas to install the dev version you're working on in a global location (/usr/local) where all other tools will find it.
Personally, I install it in a private location, then when compiling a program that uses it, I simply do
cc myprog.c -I/path/to/include/igraph -L/path/to/lib -ligraph

If your code requires C++, use c++ instead of cc.
Another note: Since igraph is a C library, it would be good to have the example file (igraph_truss.cpp) use only C and no C++. After a quick glance, it seems that this is already the case. Thus, use the .c extension and compile it with a C compiler.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,13,https://github.com/igraph/igraph/pull/1034#issuecomment-476290906,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat How do you suggest I install the dev version? With configure --prefix, or make install --prefix= or DESTDIR? There are several options (https://stackoverflow.com/questions/11307465/destdir-and-prefix-of-make). I will work on a local version. I want to make sure everything compiles and runs as-is on the present commit before addressing the valuable comments on code.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1034#issuecomment-476294034,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Sorry, I forgot to include that bit. Personally, I have been using ./configure --prefix=.... I am not an expert on this so there might be better ways than my workflow.
Another tip: I have also been compiling with configure --disable-graphml as this reduces the number of dependencies. If you do not need it, you can also --disable-gmp. Then there are no external dependencies left, I believe.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,15,https://github.com/igraph/igraph/pull/1034#issuecomment-476338690,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat

The pkg-config came from here: https://igraph.org/c/doc/igraph-tutorial.html
I've installed a clone of this forked repository (git clone git@github.com:alexperrone/igraph.git) locally in its own directory called install with ./configure --disable-graphml --prefix=/path/to/forked/igraph/install (not sure if it's a bad idea to install it inside the repository itself, just wanted to keep everything together in one folder).
After installing, the install folder has include and lib directories, and I can see install/lib/libigraph.dylib. I do note that the include does not have truss.h (not sure if it needs to).
I still cannot compile the example code with g++ -std=c++11 igraph_truss.cpp -I . -I .. -I ../../src/ -I ../../install/include/igraph -L ../../install/lib -ligraph -o truss. @szhorvat I can set the DYLD_LIBRARY_PATH upon running the compiled example, but I can't compile it yet. It fails with same error as above:

Undefined symbols for architecture x86_64:
  ""_igraph_truss"", referenced from:
      _main in igraph_truss-6b1f23.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)

Thus, I believe igraph_truss is not making it into the libigraph.dylib. How can I ensure that it gets compiled when I make igraph? Or is there some way I can develop outside of the make process?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1034#issuecomment-476560545,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Did you add src/truss.cpp to src/Makefile.am to the SOURCES variable?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1034#issuecomment-476564849,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",@alexperrone I suggest joining https://gitter.im/igraph/igraph to sort these details out. Feel free to ping me there with questions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/apps/stale,18,https://github.com/igraph/igraph/pull/1034#issuecomment-577127026,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,19,https://github.com/igraph/igraph/pull/1034#issuecomment-577206239,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thanks, I'll re-open when I continue this work.
…
On Wed, Jan 22, 2020 at 4:58 AM stale[bot] ***@***.***> wrote:
 This issue has been automatically marked as stale because it has not had
 recent activity. It will be closed if no further activity occurs. Thank you
 for your contributions.

 —
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#1034?email_source=notifications&email_token=ABGCKHFK3ZVXJ4VS3PNADU3Q7ARD5A5CNFSM4D5FKTCKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEJTEE4Q#issuecomment-577127026>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/ABGCKHGCR7QNI7ZDDJ53WT3Q7ARD5ANCNFSM4D5FKTCA>
 .",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,20,https://github.com/igraph/igraph/pull/1034#issuecomment-822189197,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","guys what do you want to do with this? It's 14 months of no update and we are moving to int64, but it seems almost done except for some fairly minor things. Shall I try and fix the PR according to the review suggestions and see if we can have it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1034#issuecomment-822417457,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",@iosonofabio I'd be grateful if you can pick this up and make it up-to-date with the current master first. Then we can review it once again to see if there is anything to be done before we merge it. Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1034#issuecomment-822422902,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Copyright 2017 The Johns Hopkins University Applied Physics Laboratory LLC. All Rights Reserved.
I am wondering if it would be wise to request a transfer of copyright first ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,23,https://github.com/igraph/igraph/pull/1034#issuecomment-822849799,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@alexperrone I'd like to finish this one up so igraph has it. Would you mind confirming that you authorize igraph folks (including me) to make changes to your PR, integrate it into the codebase, and thereby take over the copyright?
The new note will say you are the original author and the code was copyrighted by Johns Hopkins in 2017, but that it was edited by us and copyright is owned by us in 2021.
It should be a formality since it's GPL anyway.
If that's granted I can start pushing commits onto this PR I think.
Thank you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,24,https://github.com/igraph/igraph/pull/1034#issuecomment-822919556,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Actually, I'll wait a day or two but it looks like Alex has done 0 contributions over the last year, so perhaps he's not going to see this at all. Since the code is GPL I think we can just go ahead and edit it while making it clear he was the one writing the initial version.
I've made a branch in case you are interested:
https://github.com/iosonofabio/igraph/tree/ktruss
it addresses @ntamas 's review points except for an output file in the test, which I'm going to try and do now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,25,https://github.com/igraph/igraph/pull/1034#issuecomment-823025345,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@iosonofabio Yes, the edits needed seemed relatively minor. I would kindly request that the original copyright under Johns Hopkins to remain the same since the the core algorithm was published under that copyright, and they allowed me to publish the code under GPL under the condition that the particular copyright is included. Thank you so much for your effort to close this, please let me know any questions at all, including output file, testing, or the algorithm.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,26,https://github.com/igraph/igraph/pull/1034#issuecomment-824416772,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thank you Alex, of course, the original copyright line will stay, you coded the thing up.
I've just pushed directly to this PR.
@ntamas: the compiler cannot find igraph_truss but I'm not sure why. Could you please have a look? Context:

I removed truss.h and put function declarations (renamed as igraph_truss_i_...) at the top of truss.cpp
There is a single function declaration for igraph_truss in include/igraph_community.h (slightly edited to use IGRAPH_EXPORT)
I moved truss.cpp into src/centrality, where the k-cores are too I believe
I moved the test to tests/unit/truss.c and am including only igraph.h, which should include igraph_community.h, which should include igraph_truss, but perhaps is does not?

Thanks! (I'm not so familiar with C++/C cross-compiling and with compiler units or whatever they are called)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1034#issuecomment-824437454,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@ntamas: the compiler cannot find igraph_truss but I'm not sure why. Could you please have a look?

You need to include the header containing the prototype of igraph_truss into truss.cpp (the file where igraph_truss is defined).
Since it is not included, igraph_truss appears as a C++ function (not a C function) in the object file. The caller expects a C function (extern ""C"").",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,28,https://github.com/igraph/igraph/pull/1034#issuecomment-824440410,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thanks @szhorvat I'm a little unsure how you would do it.
The prototype of igraph_truss is currently only in include/igraph_community.h, are you suggesting to include that whole header in truss.cpp? Or to go back to a separate header file for the truss function located in src/centrality?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,29,https://github.com/igraph/igraph/pull/1034#issuecomment-824591360,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Just add #include ""igraph_community.h"".",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,30,https://github.com/igraph/igraph/pull/1034#issuecomment-824593084,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",You also need to add truss.cpp to src/CMakeLists.txt and add the appropriate #includes to truss.cpp for every igraph function that is used in that file.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,31,https://github.com/igraph/igraph/pull/1034#issuecomment-824694647,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Converted this PR into a draft until it is ready for review. @iosonofabio please mark it as ready when you are done.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,32,https://github.com/igraph/igraph/pull/1034#issuecomment-826047671,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","This one should be ready, just waiting for CI but I recomputed the .out file by hand and it should be alright, the test passes locally on my machine.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/apps/codecov,33,https://github.com/igraph/igraph/pull/1034#issuecomment-826047979,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Codecov Report

Merging #1034 (35cc9e6) into develop (4b5f9e7) will increase coverage by 0.04%.
The diff coverage is 100.00%.


❗ Current head 35cc9e6 differs from pull request most recent head 01c7f6f. Consider uploading reports for the commit 01c7f6f to get more accurate results


@@             Coverage Diff             @@
##           develop    #1034      +/-   ##
===========================================
+ Coverage    71.87%   71.92%   +0.04%     
===========================================
  Files          290      291       +1     
  Lines        56711    56803      +92     
===========================================
+ Hits         40763    40855      +92     
  Misses       15948    15948              



Impacted Files
Coverage Δ





src/centrality/truss.cpp
100.00% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4b5f9e7...01c7f6f. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,34,https://github.com/igraph/igraph/pull/1034#issuecomment-826071545,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thanks for the cleanup @iosonofabio ! There seems to be a memory leak, and it's not immediately obvious to me where it comes from.
This is now added to the directory centrality, but the header used is igraph_community.h. We should decide where it fits best, and be consistent in the header and source location used.
@alexperrone :

There are two documented functions, but only one is public. Which one did you mean to make public?
Can you write a brief explanation of the concept in the documentation?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,35,https://github.com/igraph/igraph/pull/1034#issuecomment-826164698,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thank you @szhorvat for the thorough review. I've fixed all of those and renamed the API function to igraph_trussness, which goes well with our preexisting igraph_coreness.
As of which src/ subfolder versus header, I did the same that was there for igraph_coreness. In principle, this function does not compute a community so it should be moved to another header, but then we should move igraph_coreness too. I'm not sure we can do it without breaking API?
NOTE: I now changed the output to reflect the standard definition of trussness, which is that the k-truss has support by at least k-2 triangles (i.e. trussness is now >= 2). I can see why @alexperrone didn't like that very much, but if that's what everyone calls it, we can hardly take another stance without confusing the heck out of our users I think",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,36,https://github.com/igraph/igraph/pull/1034#issuecomment-826355529,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Done with my part of the review as well; let's discuss the points I raised and I think we are good to go afterwards.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,37,https://github.com/igraph/igraph/pull/1034#issuecomment-826405279,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thank you @ntamas
I've implemented the requested changes and renamed the output variable as trussness since that's what t is.
I've converted completed to a vector<bool>, a quick googling indicated we lose nothing and it will be bit-optimized on some platforms. The cost is that when you address pointers along the vector things might not be as clean because of course you are not looking at a specific memory location anymore, but a proxy therefor that is cut to a single bit. Since we only use the values and don't do much with the pointers themselves, we are just fine I think.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,38,https://github.com/igraph/igraph/pull/1034#issuecomment-826553271,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","The final thing would be to go through this:
https://github.com/igraph/igraph/wiki/Checklist-for-new-%28and-old%29-functions
There are several relevant points, such as:

Catching exceptions
Add a test for edge cases (e.g. null graph, singleton, etc.)
Does it work for various kinds of non-simple graphs? If not, can it be made to work? If not, check input / document situation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,39,https://github.com/igraph/igraph/pull/1034#issuecomment-826612425,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","I can add a test case for the trivial graph. On the other hand, I don't have a lot of time atm to check support for multigraphs. Would be great if you could take a look.

edit:
 - created a test for the empty graph as requested. That indeed revealed a bug related to computing the max support of an empty vector, so I fixed it. That also covers any graphs with no edges in general, so singleton and other obvious cases are included.
 - catching exceptions: would be great if you could elaborate on what exact lines you are referring to
 - multi-graph: I tried to do the obvious things to include multigraphs, but I'm not an expert of truss computations and don't have time to look into it. Would be great @szhorvat if you want to delve into it, otherwise I'd say let's just go ahead and be more specific if users raise a feature request",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,40,https://github.com/igraph/igraph/pull/1034#issuecomment-826716072,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Re exceptions: basically just wrap all C++ code in an IGRAPH_HANDLE_EXCEPTIONS() macro from core/exceptions.h and you are OK. I can do it if you are about to go to sleep now.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,41,https://github.com/igraph/igraph/pull/1034#issuecomment-827303148,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","I've wrapped a few things, but it's a little unclear to me what exactly you guys are requesting here. C++ can raise exceptions at every single function call in principle, but wrapping every vector.begin() seems silly.
@ntamas why don't you finish up the wrapping the way you like it and then directly push here and merge? That'd be more efficient than me trying to read your mind.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,42,https://github.com/igraph/igraph/pull/1034#issuecomment-827380615,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Sure, hang on, let me drink my coffee and then I'll get to it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,43,https://github.com/igraph/igraph/pull/1034#issuecomment-827381712,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","haha, sure, thank you! Then I just opened this one to feel the heck overwhelmed with all this:
igraph/python-igraph#389
;-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,44,https://github.com/igraph/igraph/pull/1034#issuecomment-827447006,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Looking good here. I want to add some more tests to cover the cases with loop / multiple edges and then we're good to go.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,45,https://github.com/igraph/igraph/pull/1034#issuecomment-827447956,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Thank you! I wasn't sure if you could wrap the whole function call with IGRAPH_CHECK and all with the exception-catching macro of if that led to conflicts.
Almost there!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,46,https://github.com/igraph/igraph/pull/1034#issuecomment-827473852,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","With C++ code that is not borrowed, I normally use explicit try ... catch blocks. With code that is written by us, we should know precisely what exceptions to expect, and how to best translate them to igraph error codes. I originally wrote IGRAPH_HANDLE_EXCEPTIONS to deal with C++ libraries where we are not fully in control of what may be thrown.
@iosonofabio You only need one try/catch block for every public function. Wrap the entire contents. No extern ""C"" function should throw exceptions. This is a recurring issue, and quite important to be aware of.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,47,https://github.com/igraph/igraph/pull/1034#issuecomment-827474813,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat Tamas is in charge now, perhaps you two have a slightly different opinion on this one, so please feel free to connect with him and suggest him what you think is best",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,48,https://github.com/igraph/igraph/pull/1034#issuecomment-827475919,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","All that said, I see no good reason for this code to use C++. As far as I can tell, originally it only used sets with integer elements. We do have such a set data structure in igraph.
I would not spend the time to rewrite this to use igraph_set_t, but neither would I entangle it more with C++ constructs. In particular the special-cased vector<bool> is widely considered to have been a mistake, and most people wish it could go away.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,49,https://github.com/igraph/igraph/pull/1034#issuecomment-827476352,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@szhorvat Tamas is in charge now, perhaps you two have a slightly different opinion on this one, so please feel free to connect with him and suggest him what you think is best

I pointed out the issue with exceptions as you need to be aware of this any time you work with C++ code in igraph (this code or any other in the future).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,50,https://github.com/igraph/igraph/pull/1034#issuecomment-827477181,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Sure, we all need to be aware, but there doesn't seem to be a single opinion on the table. Perhaps we could discuss it at our next zoom meeting and decide together what is the best practice.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,51,https://github.com/igraph/igraph/pull/1034#issuecomment-827481523,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","Fabio, you misunderstood. There are no differences of opinion, nor is there any reason to dwell on this point. One way or another, you must ensure that any functions that gets called from C will never throw exceptions. Please do this in the future for any function that you write in C++.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/iosonofabio,52,https://github.com/igraph/igraph/pull/1034#issuecomment-827483453,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.",Then I think I had understood just fine ;-),True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,53,https://github.com/igraph/igraph/pull/1034#issuecomment-827640287,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","We do have such a set data structure in igraph.

Yes, we do, but I don't think it's optimized for performance at all. It simply uses a sorted list, which kinda sucks if you do frequent insertions and removals (which is the case here). I believe that std::set should have better performance; most of the STL implementations use a red-black tree or something similar.
I propose leaving the C++ constructs as they are now in the latest revision; we can rewrite this later in C if we feel the urge to do so. I am not going to introduce any further C++ constructs, though.
One final thing that's left here is to test whether the function works fine with multigraphs; I'll take care of this soon, hopefully today.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/ntamas,54,https://github.com/igraph/igraph/pull/1034#issuecomment-827859723,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","The function does not work with multigraphs as is, so I have added a check for that. It is good to merge now. Thanks for all your work on this @alexperrone and @iosonofabio !",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,55,https://github.com/igraph/igraph/pull/1034#issuecomment-829169987,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@iosonofabio Yes, the edits needed seemed relatively minor. I would kindly request that the original copyright under Johns Hopkins to remain the same since the the core algorithm was published under that copyright, and they allowed me to publish the code under GPL under the condition that the particular copyright is included.

Can you please clarify if you mean the algorithm (which cannot be copyrighted at all) or a specific implementation (actual code)?  When writing this code, did you re-use previous code whose copyright you did not own?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/alexperrone,56,https://github.com/igraph/igraph/pull/1034#issuecomment-829723861,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@iosonofabio Yes, the edits needed seemed relatively minor. I would kindly request that the original copyright under Johns Hopkins to remain the same since the the core algorithm was published under that copyright, and they allowed me to publish the code under GPL under the condition that the particular copyright is included.

Can you please clarify if you mean the algorithm (which cannot be copyrighted at all) or a specific implementation (actual code)? When writing this code, did you re-use previous code whose copyright you did not own?

I meant the code. As far as re-use, I'm not sure how to give a clear yes/no... what I did is that I adapted/translated Java code into C++ code that formed this PR. Now, the Java code is under the same copyright (Johns Hopkins) that I do not own and also proprietary anyway. I got permission from Johns Hopkins to publish the C++ code here under a GPL license with the condition the copyright is included as a header.  Does this answer your questions?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1034,2017-09-29T23:11:42Z,2021-04-27T20:06:12Z,2021-04-30T07:50:53Z,MERGED,True,474,3,8,https://github.com/alexperrone,Implemented k-truss,33,['todo'],https://github.com/igraph/igraph/pull/1034,https://github.com/szhorvat,57,https://github.com/igraph/igraph/pull/1034#issuecomment-829912940,"The k-truss algorithm was implemented. This is a C++ implementation since it needs a hashtable (add, delete, find an element, where delete is not supported by igraph_hashtable.c) as well as an ordered vector of these hashtables.
Guidance is needed on how to compile the C++ code to yield an object file as part of the igraph build system. This should be analagous to how the walktrap code (e.g. walktrap_communities.cpp) is compiled.","@alexperrone Yes, thank you. Let's keep it as it is.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1037,2017-10-18T11:02:45Z,2017-10-18T11:03:09Z,2017-10-18T11:04:43Z,MERGED,True,10,50,7,https://github.com/ntamas,"Revert ""pajek: optional time interval info of vertices and edges added to reader grammar """,3,[],https://github.com/igraph/igraph/pull/1037,https://github.com/ntamas,1,https://github.com/igraph/igraph/pull/1037,Reverts #1023,Reverts #1023,True,{}
igraph/igraph,https://github.com/igraph/igraph,1043,2017-11-22T13:31:03Z,2017-11-26T20:21:07Z,2017-11-26T20:21:07Z,MERGED,True,269,3,11,https://github.com/szhorvat,Add igraph_vertex_coloring_greedy(),3,[],https://github.com/igraph/igraph/pull/1043,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1043,"This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.","This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1043,2017-11-22T13:31:03Z,2017-11-26T20:21:07Z,2017-11-26T20:21:07Z,MERGED,True,269,3,11,https://github.com/szhorvat,Add igraph_vertex_coloring_greedy(),3,[],https://github.com/igraph/igraph/pull/1043,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1043#issuecomment-346708168,"This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.","Function naming is okay. The documentation should probably be in a completely separate chapter, e.g., after ""Graph Isomorphism"". Right now the chapter wouldn't be too long, but it can change in the future.
Looking forward to the tests as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1043,2017-11-22T13:31:03Z,2017-11-26T20:21:07Z,2017-11-26T20:21:07Z,MERGED,True,269,3,11,https://github.com/szhorvat,Add igraph_vertex_coloring_greedy(),3,[],https://github.com/igraph/igraph/pull/1043,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1043#issuecomment-346852411,"This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.","I changed the algorithm to use an indexed heap (it's now much faster). I used igraph_2wheap_t.  I am not 100% confident about using this. Could you please look over the code again?
In particular, it wasn't clear what the has_active and deactivate functions do, so I ignored them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1043,2017-11-22T13:31:03Z,2017-11-26T20:21:07Z,2017-11-26T20:21:07Z,MERGED,True,269,3,11,https://github.com/szhorvat,Add igraph_vertex_coloring_greedy(),3,[],https://github.com/igraph/igraph/pull/1043,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1043#issuecomment-346941625,"This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.","I added the missing pieces (tests, documentation), so I think this is basically ready for merging (unless you find problems).
More vertex ordering methods can be added later.
I didn't implement the bitfield thing, as it didn't seem worth the trouble. Does igraph has a data structure for this already, or would I need to implement it from scratch?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1043,2017-11-22T13:31:03Z,2017-11-26T20:21:07Z,2017-11-26T20:21:07Z,MERGED,True,269,3,11,https://github.com/szhorvat,Add igraph_vertex_coloring_greedy(),3,[],https://github.com/igraph/igraph/pull/1043,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1043#issuecomment-347035232,"This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.","Forgot to say, I can squash the commits into a single one before merging, to keep the mess to a minimum. Just let me know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1043,2017-11-22T13:31:03Z,2017-11-26T20:21:07Z,2017-11-26T20:21:07Z,MERGED,True,269,3,11,https://github.com/szhorvat,Add igraph_vertex_coloring_greedy(),3,[],https://github.com/igraph/igraph/pull/1043,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1043#issuecomment-347035457,"This pull request adds a basic vertex colouring algorithm per #1042
Feedback needed on:

function naming
which section to put documentation in

Still needs to be finished:

 integrate documentation
 add test / benchmark
 add more heuristics for greedy colouring

I'll wait for feedback before continuing with these tasks.
I did not check that certain long or double values fit into igraph_integer_t because this is exceedingly unlikely to happen.","That bitfield thing was only an idea and it's probably not worth the fuss at this stage. I'll merge the PR as is, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1045,2017-11-27T10:54:28Z,2017-11-27T11:04:16Z,2017-11-27T11:04:20Z,MERGED,True,1,1,1,https://github.com/szhorvat,Update igraph_adjlist.h,1,[],https://github.com/igraph/igraph/pull/1045,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1045,Clarify igraph_inclist_get() documentation,Clarify igraph_inclist_get() documentation,True,{}
igraph/igraph,https://github.com/igraph/igraph,1045,2017-11-27T10:54:28Z,2017-11-27T11:04:16Z,2017-11-27T11:04:20Z,MERGED,True,1,1,1,https://github.com/szhorvat,Update igraph_adjlist.h,1,[],https://github.com/igraph/igraph/pull/1045,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1045#issuecomment-347149465,Clarify igraph_inclist_get() documentation,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1046,2017-11-27T12:30:18Z,2018-03-06T12:43:11Z,2020-06-13T08:25:07Z,MERGED,True,328,0,6,https://github.com/szhorvat,Add igraph_random_edge_walk(),6,[],https://github.com/igraph/igraph/pull/1046,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1046,"This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.","This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1046,2017-11-27T12:30:18Z,2018-03-06T12:43:11Z,2020-06-13T08:25:07Z,MERGED,True,328,0,6,https://github.com/szhorvat,Add igraph_random_edge_walk(),6,[],https://github.com/igraph/igraph/pull/1046,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1046#issuecomment-347504000,"This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.","Changes in the last two commits:

fix a bug (wrong result when mode != IGRAPH_OUT or the graph is undirected)
add benchmark
attempt to improve performance

About the performance optimization:
In the case of a weighted graph, we need to select an edge to traverse next with a probability proportional to its weight. This is done by constructing a cumulative distribution vector for the incident edges.  In the previous iteration, this was done in every single step of the algorithm.  This new version will cache and re-use the result. This takes an extra O(|E|) memory.
However, the performance improvement isn't clear:

on a small graph, the timing improved from 1.5 s to 1.0 s.
on a big graph, the timing increased from 5.4 to 6.0 s.

I suspect that this is due to caching effect.
A further possible improvement would be using a lazy incidence list instead of an incidence list. In practice, this slows down the program (5.4 s -> 7.2 s with original algorithm), possibly because the lazy incidence list uses double vectors instead of integer ones.
Finally, due to many conditionals in the main loops, branch prediction failures may have a performance impact too. I am not sufficiently familiar with these effects to be able to guess at performance without testing, so I am going to stop here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1046,2017-11-27T12:30:18Z,2018-03-06T12:43:11Z,2020-06-13T08:25:07Z,MERGED,True,328,0,6,https://github.com/szhorvat,Add igraph_random_edge_walk(),6,[],https://github.com/igraph/igraph/pull/1046,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1046#issuecomment-355291543,"This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.","Would a similar implementation be okay for the weighted case of igraph_random_walk()?  I was thinking of leaving the current implementation of igraph_random_walk() mostly alone (other than adding a weights argument), and just adding a second (non-public) function that will be called for the weighted case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1046,2017-11-27T12:30:18Z,2018-03-06T12:43:11Z,2020-06-13T08:25:07Z,MERGED,True,328,0,6,https://github.com/szhorvat,Add igraph_random_edge_walk(),6,[],https://github.com/igraph/igraph/pull/1046,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1046#issuecomment-370767491,"This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.","Re your last comment above (which I have missed somehow): yes, that's okay, just add another non-public function for the weighted case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1046,2017-11-27T12:30:18Z,2018-03-06T12:43:11Z,2020-06-13T08:25:07Z,MERGED,True,328,0,6,https://github.com/szhorvat,Add igraph_random_edge_walk(),6,[],https://github.com/igraph/igraph/pull/1046,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1046#issuecomment-370767563,"This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.",Shall I merge the current PR or will you do it in the same PR?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1046,2017-11-27T12:30:18Z,2018-03-06T12:43:11Z,2020-06-13T08:25:07Z,MERGED,True,328,0,6,https://github.com/szhorvat,Add igraph_random_edge_walk(),6,[],https://github.com/igraph/igraph/pull/1046,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1046#issuecomment-370767995,"This pull request adds the function igraph_random_edge_walk().
It is analogous to igraph_random_walk() with the following differences:

it returns a list of edge indices
it supports edge weights

Related bug: #981
There I asked if random_walk() should be changed to return an edge list instead of a vertex list. It is probably best to have both variants. Obtaining an edge list from a vertex list is not possible when multiple edges are present between the same vertices.  Obtaining a vertex list from an edge list is possible, but it is inconvenient for undirected graphs (because it is not clear in which direction the edge was traversed).
Still missing:

 Unit tests
 Update igraph_random_walk() to also handle weights

I will do these after the review.",I'll do it in a separate PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1047,2017-12-04T10:20:38Z,2017-12-04T11:14:03Z,2018-02-24T19:47:01Z,MERGED,True,2,1,1,https://github.com/shlomif,Fix compile error with -Werror-format-security.,1,[],https://github.com/igraph/igraph/pull/1047,https://github.com/shlomif,1,https://github.com/igraph/igraph/pull/1047,"This patch was originally written for the Mageia Linux package, where
the GCC flag is enforced.","This patch was originally written for the Mageia Linux package, where
the GCC flag is enforced.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1047,2017-12-04T10:20:38Z,2017-12-04T11:14:03Z,2018-02-24T19:47:01Z,MERGED,True,2,1,1,https://github.com/shlomif,Fix compile error with -Werror-format-security.,1,[],https://github.com/igraph/igraph/pull/1047,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1047#issuecomment-348932317,"This patch was originally written for the Mageia Linux package, where
the GCC flag is enforced.","Makes sense, thanks.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1047,2017-12-04T10:20:38Z,2017-12-04T11:14:03Z,2018-02-24T19:47:01Z,MERGED,True,2,1,1,https://github.com/shlomif,Fix compile error with -Werror-format-security.,1,[],https://github.com/igraph/igraph/pull/1047,https://github.com/shlomif,3,https://github.com/igraph/igraph/pull/1047#issuecomment-348945182,"This patch was originally written for the Mageia Linux package, where
the GCC flag is enforced.","On Mon, 04 Dec 2017 03:14:08 -0800 Tamás Nepusz ***@***.***> wrote:
 Makes sense, thanks.

You're welcome and thanks! That was also very quick.
…
-- 
-----------------------------------------------------------------
Shlomi Fish       http://www.shlomifish.org/
http://www.shlomifish.org/humour/bits/facts/Summer-Glau/

The one and only, 100% original, real, actual, and unmatched, Slimy Fish™!

Please reply to list if it's a mailing list post - http://shlom.in/reply .",True,{}
igraph/igraph,https://github.com/igraph/igraph,1065,2018-02-23T22:15:23Z,2020-01-29T11:44:16Z,2020-01-29T11:45:47Z,CLOSED,False,433,0,1,https://github.com/greebie,Add Gexf Writer based on Graphml writer.,1,['stale'],https://github.com/igraph/igraph/pull/1065,https://github.com/greebie,1,https://github.com/igraph/igraph/pull/1065,"This PR provides a writer for GEXF format (1.2 draft) following the code in foreign-graphml.c.
A few notes:


Gexf supports visualization outputs.


<viz:position>. look for attributes x, y & z for values.  If there is x & y but no z, z will be 0.0.


<viz:size> - looks for ""size"" attribute and uses that.


<viz:color> currently looks for r, g, & b values.  For consideration: could include alpha 'a' (transparency) with rgb and/or look for hex if there is no rgb.


Gexf 1.2 does NOT support graph attributes in the schema


I have included graph attributes, even though its not supported in the schema.


I tested outputs in sigmaJS with no troubles. In gephi you get some errors that are ignored.  Graph attributes do not seem to be included in 1.3 so far.


I can easily comment out the graph attribute sections for later support if desired.


** This currently has no unit tests **


I will add these, but wanted to get some advice on desired features above before I lock it in.


I had an odd test failure for Adjacency Spectral Embedding, which has nothing to do with my code (I don't think).


** I still need to examine places where I can free up memory **


** having issues compiling in Mac, so moved to a Debian VM **","This PR provides a writer for GEXF format (1.2 draft) following the code in foreign-graphml.c.
A few notes:


Gexf supports visualization outputs.


<viz:position>. look for attributes x, y & z for values.  If there is x & y but no z, z will be 0.0.


<viz:size> - looks for ""size"" attribute and uses that.


<viz:color> currently looks for r, g, & b values.  For consideration: could include alpha 'a' (transparency) with rgb and/or look for hex if there is no rgb.


Gexf 1.2 does NOT support graph attributes in the schema


I have included graph attributes, even though its not supported in the schema.


I tested outputs in sigmaJS with no troubles. In gephi you get some errors that are ignored.  Graph attributes do not seem to be included in 1.3 so far.


I can easily comment out the graph attribute sections for later support if desired.


** This currently has no unit tests **


I will add these, but wanted to get some advice on desired features above before I lock it in.


I had an odd test failure for Adjacency Spectral Embedding, which has nothing to do with my code (I don't think).


** I still need to examine places where I can free up memory **


** having issues compiling in Mac, so moved to a Debian VM **",True,{}
igraph/igraph,https://github.com/igraph/igraph,1065,2018-02-23T22:15:23Z,2020-01-29T11:44:16Z,2020-01-29T11:45:47Z,CLOSED,False,433,0,1,https://github.com/greebie,Add Gexf Writer based on Graphml writer.,1,['stale'],https://github.com/igraph/igraph/pull/1065,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1065#issuecomment-416218638,"This PR provides a writer for GEXF format (1.2 draft) following the code in foreign-graphml.c.
A few notes:


Gexf supports visualization outputs.


<viz:position>. look for attributes x, y & z for values.  If there is x & y but no z, z will be 0.0.


<viz:size> - looks for ""size"" attribute and uses that.


<viz:color> currently looks for r, g, & b values.  For consideration: could include alpha 'a' (transparency) with rgb and/or look for hex if there is no rgb.


Gexf 1.2 does NOT support graph attributes in the schema


I have included graph attributes, even though its not supported in the schema.


I tested outputs in sigmaJS with no troubles. In gephi you get some errors that are ignored.  Graph attributes do not seem to be included in 1.3 so far.


I can easily comment out the graph attribute sections for later support if desired.


** This currently has no unit tests **


I will add these, but wanted to get some advice on desired features above before I lock it in.


I had an odd test failure for Adjacency Spectral Embedding, which has nothing to do with my code (I don't think).


** I still need to examine places where I can free up memory **


** having issues compiling in Mac, so moved to a Debian VM **","(First of all, apologies for the delay; I know that I'm quite late to the party here, but sadly I hardly have any time to work on igraph any more).
Thanks for your contribution! Seems like a good starting point, but the entire code is in a header file. Header files should not contain code; the code itself should go in a .c file instead.
Further comments:


The code of igraph_i_xml_escape seems to be duplicated from the GraphML reader; instead of that, one should simply use the existing implementation.


There are no test cases that validate whether the GEXF writer works, and there is no documentation for the implemented function.


GEXF_NAMESPACE_URI is not referenced anywhere (although it should be as its value is clearly being used).


igraph_cattribute_has_attr() and related functions assume that the graph uses the C attribute handler; this approach will fail if igraph is being used from R or Python because those higher-level interfaces use a different attribute handler. The same applies to the macros VANV, VASV and so on. You need to use the igraph_i_attribute_... functions just like they are being used from the GraphML writer because they call the right functions from the attribute handler table currently attached to igraph instead of assuming that the C attribute handler is being used.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1065,2018-02-23T22:15:23Z,2020-01-29T11:44:16Z,2020-01-29T11:45:47Z,CLOSED,False,433,0,1,https://github.com/greebie,Add Gexf Writer based on Graphml writer.,1,['stale'],https://github.com/igraph/igraph/pull/1065,https://github.com/apps/stale,3,https://github.com/igraph/igraph/pull/1065#issuecomment-577127027,"This PR provides a writer for GEXF format (1.2 draft) following the code in foreign-graphml.c.
A few notes:


Gexf supports visualization outputs.


<viz:position>. look for attributes x, y & z for values.  If there is x & y but no z, z will be 0.0.


<viz:size> - looks for ""size"" attribute and uses that.


<viz:color> currently looks for r, g, & b values.  For consideration: could include alpha 'a' (transparency) with rgb and/or look for hex if there is no rgb.


Gexf 1.2 does NOT support graph attributes in the schema


I have included graph attributes, even though its not supported in the schema.


I tested outputs in sigmaJS with no troubles. In gephi you get some errors that are ignored.  Graph attributes do not seem to be included in 1.3 so far.


I can easily comment out the graph attribute sections for later support if desired.


** This currently has no unit tests **


I will add these, but wanted to get some advice on desired features above before I lock it in.


I had an odd test failure for Adjacency Spectral Embedding, which has nothing to do with my code (I don't think).


** I still need to examine places where I can free up memory **


** having issues compiling in Mac, so moved to a Debian VM **",This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1065,2018-02-23T22:15:23Z,2020-01-29T11:44:16Z,2020-01-29T11:45:47Z,CLOSED,False,433,0,1,https://github.com/greebie,Add Gexf Writer based on Graphml writer.,1,['stale'],https://github.com/igraph/igraph/pull/1065,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1065#issuecomment-579719004,"This PR provides a writer for GEXF format (1.2 draft) following the code in foreign-graphml.c.
A few notes:


Gexf supports visualization outputs.


<viz:position>. look for attributes x, y & z for values.  If there is x & y but no z, z will be 0.0.


<viz:size> - looks for ""size"" attribute and uses that.


<viz:color> currently looks for r, g, & b values.  For consideration: could include alpha 'a' (transparency) with rgb and/or look for hex if there is no rgb.


Gexf 1.2 does NOT support graph attributes in the schema


I have included graph attributes, even though its not supported in the schema.


I tested outputs in sigmaJS with no troubles. In gephi you get some errors that are ignored.  Graph attributes do not seem to be included in 1.3 so far.


I can easily comment out the graph attribute sections for later support if desired.


** This currently has no unit tests **


I will add these, but wanted to get some advice on desired features above before I lock it in.


I had an odd test failure for Adjacency Spectral Embedding, which has nothing to do with my code (I don't think).


** I still need to examine places where I can free up memory **


** having issues compiling in Mac, so moved to a Debian VM **",@greebie Are you still planning to work on this? It would be great to finish this PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1068,2018-02-27T12:50:47Z,2018-03-01T12:09:47Z,2018-03-01T13:28:53Z,MERGED,True,13,8,2,https://github.com/flying-sheep,Compiles with musl libc,1,[],https://github.com/igraph/igraph/pull/1068,https://github.com/flying-sheep,1,https://github.com/igraph/igraph/pull/1068,"Fixes #1066
I’m not sure which of the branches is hit, but I assume the fallback branch (empty ieee0 function).
This fits with the musl FAQ entry explaining that there is no standards compliant behavior that enables floating point exceptions.
If we really need the behavior specified here and feel adventurous, we could try the assembler code here on x86 and x86_64.","Fixes #1066
I’m not sure which of the branches is hit, but I assume the fallback branch (empty ieee0 function).
This fits with the musl FAQ entry explaining that there is no standards compliant behavior that enables floating point exceptions.
If we really need the behavior specified here and feel adventurous, we could try the assembler code here on x86 and x86_64.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1068,2018-02-27T12:50:47Z,2018-03-01T12:09:47Z,2018-03-01T13:28:53Z,MERGED,True,13,8,2,https://github.com/flying-sheep,Compiles with musl libc,1,[],https://github.com/igraph/igraph/pull/1068,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1068#issuecomment-369572527,"Fixes #1066
I’m not sure which of the branches is hit, but I assume the fallback branch (empty ieee0 function).
This fits with the musl FAQ entry explaining that there is no standards compliant behavior that enables floating point exceptions.
If we really need the behavior specified here and feel adventurous, we could try the assembler code here on x86 and x86_64.",Thanks!,True,{'HOORAY': ['https://github.com/flying-sheep']}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1077,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1077#issuecomment-375015708,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Here's a small demo.
realize_degree_sequence.pdf",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1077#issuecomment-379585899,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","The documentation now builds properly, but I'm not sure how to get rid of the extern ""C"" that shows there without an extra wrapper function.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1077#issuecomment-388472167,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",Seems good so far but there are conflicts that have to be resolved before merging. Are you planning to add anything else to this PR?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1077#issuecomment-388473709,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",Sorry about being slow with some of the PRs. I'll try to clean them up next week. Please don't merge any of my stuff until then.  I'll let you know.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1077#issuecomment-388473928,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",No need to rush -- I have quite a long backlog as well :),True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1077#issuecomment-439391519,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","This is updated now, and ready to merge once the Travis build has passed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1077#issuecomment-442073646,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Also, would it be possible to add some basic test cases? After all, these are deterministic algorithms so it should be easy to write a deterministic test case for them.
Otherwise I'm happy with the proposed changes so I'll merge them once these points are addressed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1077#issuecomment-443164431,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","After all, these are deterministic algorithms so it should be easy to write a deterministic test case for them.

It turns out that this is a bit trickier than I expected.
The algorithms rely on std::sort, which may give different results on different platforms when there are ties.
To put it simply, when two nodes have the same degree, the order in which they are connected up effectively becomes platform dependent.
I think I should switch to std::stable_sort for the sake of a consistent output on all platforms, even if this comes with a small performance degradation.  Do you agree?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1077#issuecomment-443202505,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Yes, you are right, let's switch to stable_sort(), it shouldn't make too much of a difference anyway.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1077#issuecomment-443460007,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Would it be possible to merge igraph_i_havel_hakimi_smallest and igraph_i_havel_hakimi_largest?

Actually, I merged an unmerged this multiple times during development.
Now they're merged again.
Unless I missed something, I think this PR is ready to merge now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1077#issuecomment-443462691,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",Can you rebase this to the current master? I'll merge it once it's done.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1077#issuecomment-443490635,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","By rebase, do you mean squashing all commits into one?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1077#issuecomment-443530283,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Nope, just ensuring that all the conflicts with the base branch are resolved. Right now I cannot merge the PR because it has conflicts with the base branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1077#issuecomment-443532528,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","I'm confused. This is what I see:

""This branch has no conflicts with the base branch""
I have also merged the master branch into the realize_degseq branch and there were no conflicts.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1077#issuecomment-443532744,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Do you have the realize_degseq branch locally on your computer?
There were indeed conflicts, see your May 11 comment above.
While cleaning those conflicts up, I changed the history in this branch (with rebase) in an attempt to make it ""clean"" again.  If you previously had this branch on your own computer, then the equivalence of your copy with the GitHub copy broke at that point.  Maybe I should not have done that.
The one's that on GitHub now has no conflicts.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/1077#issuecomment-443535258,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","This is what I see on my machine (Github web UI, I don't have this PR checked out on my machine):

So, this has nothing to do with what I have on my computer as it is the Github web UI that claims that I cannot merge this PR right now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1077#issuecomment-443535515,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",Do you have any idea what I can do to fix this (since on my end it shows no conflicts)? I'm thinking of just opening a new PR instead with the same changes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,19,https://github.com/igraph/igraph/pull/1077#issuecomment-443535711,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.",I'll try a manual merge from the CLI and see how Github reacts.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1077#issuecomment-443535763,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Please wait, I'll send a new PR. SOmething's really wrong with this branch.
…
On Sun, 2 Dec 2018 at 20:41, Tamás Nepusz ***@***.***> wrote:
 I'll try a manual merge from the CLI and see how Github reacts.

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#1077 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/ABKBx7Ts0b8rUZ5jv_o1mf5cVIBC4-ulks5u1CzdgaJpZM4S0rfw>
 .",True,{}
igraph/igraph,https://github.com/igraph/igraph,1077,2018-03-21T16:42:19Z,2018-12-02T19:42:26Z,2018-12-02T19:42:43Z,MERGED,True,784,3,9,https://github.com/szhorvat,igraph_realize_degree_sequence,9,[],https://github.com/igraph/igraph/pull/1077,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1077#issuecomment-443535817,"This is an implementation of a number of variations on the Havel-Hakimi algorithm.
There are multiple similar versions of functions in the code. Before it's merged, I would appreciate some help on reducing code duplication without affecting performance.","Too late :) Manual merge seems to have worked, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1079,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1079#issuecomment-378966345,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","Potential improvements before merging:


Support directed (i.e. rooted) trees. This can be done by generating an undirected tree, picking a root at random, then orienting all edges away from it.


Add other generating methods. (However, I was unable to find a simple, direct construction method that results in uniform sampling. What I did find was blog posts and papers claiming to have such a method, but not sampling uniformly in reality.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1079#issuecomment-379581562,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","I added a second method for random tree generation based on loop-erased random walks. Since it was easier this time, I also added support for directed trees.
Both methods generate all labelled trees with equal probability.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1079#issuecomment-379582835,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","I should note that I did numerically test uniform sampling for both methods, to verify the implementations.  This is not something that can be easily made into an automated test, so it's not added as such.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1079#issuecomment-379753313,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","Seems good to me, thanks! Please add some test cases nevertheless because I don't have the capacity to review everything thoroughly (including memory access issues and so on), and it improves the process greatly if there are some tests that I could run through Valgrind.
In this particular case, igraph_from_prufer() is deterministic so it should be easy to create some tests for it (I would create a few example graphs, print their edge lists to stdout, and then compare stdout with an expected version coming from a file, like we do it in many other test cases). igraph_tree_game() is stochastic but you can initialize the igraph RNG with a predetermined seed to make the test deterministic.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1079#issuecomment-385787207,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1079#issuecomment-385793344,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","Sorry, this was not quite done yet!  I'll send the remaining test in an additional pull request later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1079#issuecomment-385793498,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","Okay, thanks and no problem.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1079,2018-04-05T14:28:43Z,2018-05-01T20:54:47Z,2020-01-29T09:06:22Z,MERGED,True,306,1,9,https://github.com/szhorvat,Prüfer sequences and random trees,6,[],https://github.com/igraph/igraph/pull/1079,https://github.com/Pascal-Ortiz,9,https://github.com/igraph/igraph/pull/1079#issuecomment-513724630,"This pull request includes two new functions:


igraph_from_prufer creates a tree from a Prüfer sequence


igraph_tree_game will sample uniformly from the set of labelled trees


The tree sampler works by generating random Prüfer sequences and then converting them to trees.
There are other functions that can create random trees, e.g. igraph_growing_game with m=1 and citation=true. However, these don't sample uniformly.  (Specifically, growing_game does generate all its possible results with equal probability, but it cannot generate all labelled trees.)","This pull request includes two new functions:

igraph_from_prufer creates a tree from a Prüfer sequence


Hi Szabolcs!
Good work! there are not so many libraries implementing Prufer conversions.
The algorithm has quadratic time complexity so the implentation was not able to build in a reasonable time a tree having one million of nodes from a Prufer sequence.
There exists linear time algorithms for encoding a Prufer sequence into a tree, for instance this paper.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1081,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/","A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/",True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1081#issuecomment-379721881,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/",Seems good -- please add some tests and then I'll be happy to merge it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1081#issuecomment-379820228,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/","Changes:

more cross references in the documentation
added a simple test",True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1081#issuecomment-379828356,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/","Does igraph already have macros roughly equivalent to std::min and std::max? If not, it would be useful to have them.  Something like
#define igraph_max(a,b) ((a) > (b) ? (a) : (b))

What do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1081#issuecomment-379855406,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/","src/cs/cs.h has a CS_MAX macro. igraph itself does not have its own variant. If you need one, feel free to add it; src/igraph_math.h seems to be a good candidate as it is not part of the public API so we don't provide yet-another-max-macro needlessly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1081#issuecomment-379855532,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/",Can I merge this or do you plan to add something else?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1081#issuecomment-379858215,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/",You can merge it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1081,2018-04-09T10:22:08Z,2018-04-09T19:02:08Z,2018-04-09T19:02:11Z,MERGED,True,139,1,6,https://github.com/szhorvat,igraph_bridges,1,[],https://github.com/igraph/igraph/pull/1081,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1081#issuecomment-379858994,"A function to find bridges in the graph. An edge is a bridge if its removal disconnects the graph.
Based on https://www.geeksforgeeks.org/bridge-in-a-graph/",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1083,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.","A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1083#issuecomment-380083558,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.","Tests are added. I would like to merge this first, as I need it both for additional tests and implementing other functionality.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1083#issuecomment-380151540,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.","I have reviewed the code briefly and I am a bit worried about the DFS recursion. Would this work even with an undirected path graph with, say, ten million vertices? Won’t we run out of stack space earlier than we could recurse all the way down?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1083#issuecomment-380163726,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.",I changed it to a recursion-free implementation.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1083#issuecomment-380585803,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.",Thanks! Let me know if you are okay with merging this (after addressing my two comments above).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1083#issuecomment-380729513,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.","It can be merged. Now all commits are squashed together. Once this is merged, I'll continue with the rest.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1083#issuecomment-381147339,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.",One possible change could be using igraph_tree_mode_t instead of igraph_neimode_t. Let me know which one you prefer.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1083,2018-04-10T11:11:20Z,2018-04-15T20:21:00Z,2019-05-20T14:26:29Z,MERGED,True,302,0,5,https://github.com/szhorvat,igraph_is_tree,1,[],https://github.com/igraph/igraph/pull/1083,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1083#issuecomment-381435008,"A function to test if a graph is a tree.  Fixes #1082. Tests are forthcoming, but comments are welcome before then.  I'd like to merge this before my other pull requests.","igraph_neimode_t is okay, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1086,2018-04-11T18:08:58Z,2018-11-26T11:45:42Z,2018-11-26T11:45:42Z,MERGED,True,147,0,3,https://github.com/szhorvat,igraph_random_spanning_tree,1,[],https://github.com/igraph/igraph/pull/1086,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1086,Uniformly sample spanning trees. Fixes #1085,Uniformly sample spanning trees. Fixes #1085,True,{}
igraph/igraph,https://github.com/igraph/igraph,1086,2018-04-11T18:08:58Z,2018-11-26T11:45:42Z,2018-11-26T11:45:42Z,MERGED,True,147,0,3,https://github.com/szhorvat,igraph_random_spanning_tree,1,[],https://github.com/igraph/igraph/pull/1086,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1086#issuecomment-439410340,Uniformly sample spanning trees. Fixes #1085,The comments above have now been addressed.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1086,2018-04-11T18:08:58Z,2018-11-26T11:45:42Z,2018-11-26T11:45:42Z,MERGED,True,147,0,3,https://github.com/szhorvat,igraph_random_spanning_tree,1,[],https://github.com/igraph/igraph/pull/1086,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1086#issuecomment-441611551,Uniformly sample spanning trees. Fixes #1085,"Seems okay to me now, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1088,2018-04-12T11:17:15Z,2018-04-16T19:25:38Z,2020-01-29T07:59:10Z,MERGED,True,1,7,1,https://github.com/szhorvat,igraph_random_edge_walk: minor code simplification,1,[],https://github.com/igraph/igraph/pull/1088,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1088,Minor simplification for igraph_random_edge_walk,Minor simplification for igraph_random_edge_walk,True,{}
igraph/igraph,https://github.com/igraph/igraph,1096,2018-04-26T12:51:14Z,2018-04-26T14:57:59Z,2020-06-13T08:24:01Z,MERGED,True,58,55,2,https://github.com/szhorvat,Chordal ring fixes,2,[],https://github.com/igraph/igraph/pull/1096,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1096,This is a fix for the problems described in #1093,This is a fix for the problems described in #1093,True,{}
igraph/igraph,https://github.com/igraph/igraph,1100,2018-05-24T23:02:38Z,2018-05-25T07:09:52Z,2018-05-25T07:09:52Z,MERGED,True,1,1,1,https://github.com/msk,A portability fix for configure.ac,1,[],https://github.com/igraph/igraph/pull/1100,https://github.com/msk,1,https://github.com/igraph/igraph/pull/1100,"The ""test"" command, as well as the ""["" command, are not required to
know the ""=="" operator. Only a few implementations like bash and some
versions of ksh support it.
When you run ""test foo == foo"" on a platform that does not support the
""=="" operator, the result will be false instead of true. This can
lead to unexpected behavior.","The ""test"" command, as well as the ""["" command, are not required to
know the ""=="" operator. Only a few implementations like bash and some
versions of ksh support it.
When you run ""test foo == foo"" on a platform that does not support the
""=="" operator, the result will be false instead of true. This can
lead to unexpected behavior.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1100,2018-05-24T23:02:38Z,2018-05-25T07:09:52Z,2018-05-25T07:09:52Z,MERGED,True,1,1,1,https://github.com/msk,A portability fix for configure.ac,1,[],https://github.com/igraph/igraph/pull/1100,https://github.com/gaborcsardi,2,https://github.com/igraph/igraph/pull/1100#issuecomment-391962674,"The ""test"" command, as well as the ""["" command, are not required to
know the ""=="" operator. Only a few implementations like bash and some
versions of ksh support it.
When you run ""test foo == foo"" on a platform that does not support the
""=="" operator, the result will be false instead of true. This can
lead to unexpected behavior.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1105,2018-06-09T07:41:09Z,2018-06-10T15:38:09Z,2018-06-10T15:38:09Z,CLOSED,False,365,0,2,https://github.com/Sarmentor,Laplacian Centrality for Weighted/Unweighted Networks (Static or Evolving),1,[],https://github.com/igraph/igraph/pull/1105,https://github.com/Sarmentor,1,https://github.com/igraph/igraph/pull/1105,"Following the paper in:
[Sarmento et al., 2017] Sarmento, R. P., Cordeiro, M., Brazdil, P., and Gama,  J.  (2017).
Efficient incremental laplace centrality algorithm for dynamic networks.
In International Workshop on Complex Networks and their Applications
,pages 341–352. Springer, Cham
Code Authors:
Mário Cordeiro
Rui P. Sarmento
Luís Lemos
André Martinez

For Unweighted and Weighted Networks
Prepared for Static and Evolving Networks
Core Code in Python
Interface function with R and by using reticulate package","Following the paper in:
[Sarmento et al., 2017] Sarmento, R. P., Cordeiro, M., Brazdil, P., and Gama,  J.  (2017).
Efficient incremental laplace centrality algorithm for dynamic networks.
In International Workshop on Complex Networks and their Applications
,pages 341–352. Springer, Cham
Code Authors:
Mário Cordeiro
Rui P. Sarmento
Luís Lemos
André Martinez

For Unweighted and Weighted Networks
Prepared for Static and Evolving Networks
Core Code in Python
Interface function with R and by using reticulate package",True,{}
igraph/igraph,https://github.com/igraph/igraph,1105,2018-06-09T07:41:09Z,2018-06-10T15:38:09Z,2018-06-10T15:38:09Z,CLOSED,False,365,0,2,https://github.com/Sarmentor,Laplacian Centrality for Weighted/Unweighted Networks (Static or Evolving),1,[],https://github.com/igraph/igraph/pull/1105,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1105#issuecomment-395949089,"Following the paper in:
[Sarmento et al., 2017] Sarmento, R. P., Cordeiro, M., Brazdil, P., and Gama,  J.  (2017).
Efficient incremental laplace centrality algorithm for dynamic networks.
In International Workshop on Complex Networks and their Applications
,pages 341–352. Springer, Cham
Code Authors:
Mário Cordeiro
Rui P. Sarmento
Luís Lemos
André Martinez

For Unweighted and Weighted Networks
Prepared for Static and Evolving Networks
Core Code in Python
Interface function with R and by using reticulate package","This has nothing to do with igraph.
If you just want to provide code to go with your conference paper, you should host it yourself, and include a link in your paper (instead of sending pull requests to projects).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1105,2018-06-09T07:41:09Z,2018-06-10T15:38:09Z,2018-06-10T15:38:09Z,CLOSED,False,365,0,2,https://github.com/Sarmentor,Laplacian Centrality for Weighted/Unweighted Networks (Static or Evolving),1,[],https://github.com/igraph/igraph/pull/1105,https://github.com/Sarmentor,3,https://github.com/igraph/igraph/pull/1105#issuecomment-395949491,"Following the paper in:
[Sarmento et al., 2017] Sarmento, R. P., Cordeiro, M., Brazdil, P., and Gama,  J.  (2017).
Efficient incremental laplace centrality algorithm for dynamic networks.
In International Workshop on Complex Networks and their Applications
,pages 341–352. Springer, Cham
Code Authors:
Mário Cordeiro
Rui P. Sarmento
Luís Lemos
André Martinez

For Unweighted and Weighted Networks
Prepared for Static and Evolving Networks
Core Code in Python
Interface function with R and by using reticulate package","@szhorvat   It is a centrality algorithm for graphs, could you please explain why it has nothing to do with igraph?  Do you require it to be written in another language or the problem is something else?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1105,2018-06-09T07:41:09Z,2018-06-10T15:38:09Z,2018-06-10T15:38:09Z,CLOSED,False,365,0,2,https://github.com/Sarmentor,Laplacian Centrality for Weighted/Unweighted Networks (Static or Evolving),1,[],https://github.com/igraph/igraph/pull/1105,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1105#issuecomment-395949668,"Following the paper in:
[Sarmento et al., 2017] Sarmento, R. P., Cordeiro, M., Brazdil, P., and Gama,  J.  (2017).
Efficient incremental laplace centrality algorithm for dynamic networks.
In International Workshop on Complex Networks and their Applications
,pages 341–352. Springer, Cham
Code Authors:
Mário Cordeiro
Rui P. Sarmento
Luís Lemos
André Martinez

For Unweighted and Weighted Networks
Prepared for Static and Evolving Networks
Core Code in Python
Interface function with R and by using reticulate package","This is the repository for the core of the igraph library, written in the C language. If you wish to contribute, the code should be written in C, not have dependencies on other libraries, fit in well with the rest of the igraph API, and be documented.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/frederik-h,1,https://github.com/igraph/igraph/pull/1117,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1117#issuecomment-427563441,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","Thanks @frederik-h ! As I remember, that was my code.  You are right that the colour-vector permutation has to go the other way.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1117#issuecomment-429632026,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.",Thank you!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1117#issuecomment-430344473,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","It's been already merged, but I would like to make a few comments anyway, partly for the sake of keeping the tests also useful as an example of good igraph programming.
Line 47 of igraph_isomorphic_bliss.c:
Tests should be deterministic. If they fail, they should always fail. If they pass, they should always pass. Use a fixed seed for the RNG.
Use igraph_vector_shuffle to create a random permutation. Additional advantage: it uses igraph's RNG so it behaves the same on all systems.
Line 101:
Variable declarations must go to the start of the function in standard C89 (which igraph uses). Many compilers accept declarations in the middle, but it is not valid according to the standard.
Line 103:
Do not use igraph_empty_attrs if not working with attributes. Use igraph_empty.
However, instead of creating an empty graph and adding edges to it, use igraph_small here. Adding edges to a graph is much slower than creating a graph directly from a list of edges (either using igraph_small for conveniently making small graphs, or igraph_create to use a stored edge list).
Line 132:
Again, declarations go to the front. However, why not re-use existing vectors color1 and color2 (after an appropriate igraph_vector_resize)?
Line 137:
igraph_vector_init already sets the elements to zero. No need for vector_fill or vector_null.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1117#issuecomment-430375152,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","Thanks @szhorvat , I should have probably checked the PR more thoroughly. I'll take care of these tomorrow.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/frederik-h,6,https://github.com/igraph/igraph/pull/1117#issuecomment-430498904,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","At least the first two issues mentioned by @szhorvat were already present in the vf2 tests from which the new file was derived. They should probably also be fixed there. By the way, I think that it is fine to use a RNG in tests as long as you record the seed to enable repeating the test.
Regarding the use of RNGs in tests and the version of the C-standard used be igraph: perhaps this could be clarified, for instance, in the CONTRIBUTING.md?
@ntamas I can also make the changes and send a PR, if that's easier for you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1117#issuecomment-430521373,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","@frederik-h Thanks, it's not needed, I have done the changes yesterday already, I was just too tired to wait for the tests to compile. It's committed now.
I have also fixed the VF2 tests and added a note in CONTRIBUTING.md about test case determinism.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1117#issuecomment-443459864,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","@frederik-h

By the way, I think that it is fine to use a RNG in tests as long as you record the seed to enable repeating the test.

See here why it wasn't fine in this specific case: #1139
(It turns out that seeding was done incorrectly even after changes to this PR.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1117,2018-10-06T09:14:15Z,2018-10-14T14:43:08Z,2018-12-03T06:55:30Z,MERGED,True,174,4,3,https://github.com/frederik-h,Fix isomorphic_bliss verification of coloring,1,[],https://github.com/igraph/igraph/pull/1117,https://github.com/frederik-h,9,https://github.com/igraph/igraph/pull/1117#issuecomment-443607387,"If igraph_isomorphic_bliss is called with colorings, it tries to verify that the isomorphism constructed by bliss does indeed preserve the colors.
The current check applies the isomorphism
in the wrong direction. That is, although the isomorphism map12 is a mapping
from the first to the second graph, it is checked that the coloring of
each vertex in the second graph is equal to the coloring of its image
in the first graph. This leads to igraph_isomorphic_bliss rejecting
isomorphic colored graphs. The problem can be fixed by exchanging the roles
of the two graphs in the check.
An example which demonstrates the problem has been added as a test. (The last test in igraph_isomorphic_bliss.c; the other tests have been adapted from igraph_isomorphic_vf2.c since there seemed to be no dedicated tests covering the behavior of bliss for colored graphs).
The graph of this example has been adapted from the IsomorphismTests.testIsomorphic test of python-igraph.","@frederik-h

By the way, I think that it is fine to use a RNG in tests as long as you record the seed to enable repeating the test.

See here why it wasn't fine in this specific case: #1139
(It turns out that seeding was done incorrectly even after changes to this PR.)

Thanks for the pointer.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1120,2018-10-09T09:21:29Z,2018-10-09T14:38:10Z,2018-10-09T14:38:14Z,MERGED,True,3,3,1,https://github.com/szhorvat,Update auto NCV selection for ARPACK,1,[],https://github.com/igraph/igraph/pull/1120,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1120,"Maximum NCV should be N and not N-1, otherwise it may happen that NCV - NEV < 2, which causes ARPACK to fail.
Fixes #1119
I am unsure why the cap on NCV was N-1 previously. I am going by the error message issued by ARPACK,

NCV must be greater than NEV and less than or equal to N (and for the non-symmetric solver NCV-NEV >=2 must also hold)","Maximum NCV should be N and not N-1, otherwise it may happen that NCV - NEV < 2, which causes ARPACK to fail.
Fixes #1119
I am unsure why the cap on NCV was N-1 previously. I am going by the error message issued by ARPACK,

NCV must be greater than NEV and less than or equal to N (and for the non-symmetric solver NCV-NEV >=2 must also hold)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1120,2018-10-09T09:21:29Z,2018-10-09T14:38:10Z,2018-10-09T14:38:14Z,MERGED,True,3,3,1,https://github.com/szhorvat,Update auto NCV selection for ARPACK,1,[],https://github.com/igraph/igraph/pull/1120,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1120#issuecomment-428218158,"Maximum NCV should be N and not N-1, otherwise it may happen that NCV - NEV < 2, which causes ARPACK to fail.
Fixes #1119
I am unsure why the cap on NCV was N-1 previously. I am going by the error message issued by ARPACK,

NCV must be greater than NEV and less than or equal to N (and for the non-symmetric solver NCV-NEV >=2 must also hold)",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1134,2018-11-22T13:11:15Z,2018-11-22T13:12:25Z,2018-11-22T13:12:25Z,MERGED,True,1,1,1,https://github.com/szhorvat,Fix CXSparse link in docs,1,[],https://github.com/igraph/igraph/pull/1134,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1134,"The old link is broken. The new link is not directly to CXSparse but to SparseSuite, which includes CXSparse","The old link is broken. The new link is not directly to CXSparse but to SparseSuite, which includes CXSparse",True,{}
igraph/igraph,https://github.com/igraph/igraph,1136,2018-11-29T15:19:37Z,2018-11-29T16:28:01Z,2018-11-29T16:28:01Z,MERGED,True,2,1,1,https://github.com/szhorvat,igraph_reingold_tilford_circular: fix for 1- and 2-vertex inputs.,1,[],https://github.com/igraph/igraph/pull/1136,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1136,Fixes #1135,Fixes #1135,True,{}
igraph/igraph,https://github.com/igraph/igraph,1137,2018-12-01T12:02:52Z,2018-12-01T20:26:26Z,2018-12-01T20:26:26Z,MERGED,True,1,1,1,https://github.com/szhorvat,Update coloring.at,1,[],https://github.com/igraph/igraph/pull/1137,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1137,Minor comment fix,Minor comment fix,True,{}
igraph/igraph,https://github.com/igraph/igraph,1139,2018-12-01T21:25:58Z,2018-12-01T21:35:57Z,2020-01-29T09:05:56Z,MERGED,True,2,4,2,https://github.com/szhorvat,Isomorphism tests: set a fixed seed for Bliss and VF2,1,[],https://github.com/igraph/igraph/pull/1139,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1139,"Occasionally, and randomly, I was getting failures from the tests isomorphic_bliss and isomorphic_vf2, in both case with ""Second negative test failed"".
To make a long story short:
In both cases, this test is about vertex-coloured isomorphism. The colour vector contains all zeros, except for precisely two 1s.  The result of the isomorphism test is expected to be ""false"" because the colour vectors are set to be different. However, this is not generally true.  Whether it is true depends on the specific vertex reordering done at the beginning of the test. If we're unlucky, this reordering makes the colour vectors equivalent too.
And this is exactly what was happening.  The tests has an srand(1234), but it was igraph's RNG that was being used. It's igraph's RNG that needs to be seeded.
This PR does that.
Actually, if we use the seed 12345 in the Bliss test, we get a special permutation that makes the test ""fail"" exactly how I described it. I verified manually that this is really what happens.  I chose 54321 instead, for this reason.","Occasionally, and randomly, I was getting failures from the tests isomorphic_bliss and isomorphic_vf2, in both case with ""Second negative test failed"".
To make a long story short:
In both cases, this test is about vertex-coloured isomorphism. The colour vector contains all zeros, except for precisely two 1s.  The result of the isomorphism test is expected to be ""false"" because the colour vectors are set to be different. However, this is not generally true.  Whether it is true depends on the specific vertex reordering done at the beginning of the test. If we're unlucky, this reordering makes the colour vectors equivalent too.
And this is exactly what was happening.  The tests has an srand(1234), but it was igraph's RNG that was being used. It's igraph's RNG that needs to be seeded.
This PR does that.
Actually, if we use the seed 12345 in the Bliss test, we get a special permutation that makes the test ""fail"" exactly how I described it. I verified manually that this is really what happens.  I chose 54321 instead, for this reason.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1139,2018-12-01T21:25:58Z,2018-12-01T21:35:57Z,2020-01-29T09:05:56Z,MERGED,True,2,4,2,https://github.com/szhorvat,Isomorphism tests: set a fixed seed for Bliss and VF2,1,[],https://github.com/igraph/igraph/pull/1139,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1139#issuecomment-443460371,"Occasionally, and randomly, I was getting failures from the tests isomorphic_bliss and isomorphic_vf2, in both case with ""Second negative test failed"".
To make a long story short:
In both cases, this test is about vertex-coloured isomorphism. The colour vector contains all zeros, except for precisely two 1s.  The result of the isomorphism test is expected to be ""false"" because the colour vectors are set to be different. However, this is not generally true.  Whether it is true depends on the specific vertex reordering done at the beginning of the test. If we're unlucky, this reordering makes the colour vectors equivalent too.
And this is exactly what was happening.  The tests has an srand(1234), but it was igraph's RNG that was being used. It's igraph's RNG that needs to be seeded.
This PR does that.
Actually, if we use the seed 12345 in the Bliss test, we get a special permutation that makes the test ""fail"" exactly how I described it. I verified manually that this is really what happens.  I chose 54321 instead, for this reason.","Awesome, thanks for debugging this!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1140,2018-12-02T11:07:00Z,2018-12-02T13:28:38Z,2020-01-29T09:05:39Z,MERGED,True,3,0,1,https://github.com/szhorvat,igraph_barabasi_game: fix for n=0,1,[],https://github.com/igraph/igraph/pull/1140,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1140,Fixes #1138,Fixes #1138,True,{}
igraph/igraph,https://github.com/igraph/igraph,1143,2018-12-07T20:45:23Z,2018-12-08T10:20:46Z,2020-01-29T09:05:03Z,MERGED,True,3,6,2,https://github.com/szhorvat,igraph_destroy should be void (not return anything),1,[],https://github.com/igraph/igraph/pull/1143,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1143,"Changed int igraph_destroy(igraph_t *) to void igraph_destroy(igraph_t *).
No other changes were necessary. Test pass on Mac.
Fixes #1142","Changed int igraph_destroy(igraph_t *) to void igraph_destroy(igraph_t *).
No other changes were necessary. Test pass on Mac.
Fixes #1142",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1144,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1144#issuecomment-445449886,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Details:
Currently in degree_sequence_game we have:
IGRAPH_DEGSEQ_SIMPLE, which generates multigraphs.  Here, the documentation is improved, explaining that this is the configuration model, and providing specific details on sampling probabilities.
There is one point that I notice I did not write down: the probabilities are given in terms of the adjacency matrix. For undirected graphs, this is the kind of adjacency matrix that has a 2 (not a 1) on the diagonal for loop edges.  There are two conventions about loop edges and adjacency matrices: put a 1 in the adjacency matrix (because there is one loop edge) or put a 2 (because both ends of that loop edge connect to the relevant vertex). Maybe I should not this explicitly.
IGRAPH_DEGSEQ_SIMPLE_NO_MULTIPLE, which does not generate multigraphs, but does not sample uniformly either.
This PR adds another method, which does sample uniformly.
There is also IGRAPH_DEGSEQ_VL, but that is a very different method that generates only connected graphs, and does not sample exactly uniformly.

About the naming of enum value:
I find the current naming confusing because the method that does generate multigraphs is called ""SIMPLE"". I did not rename them because that would break compatibility, and it seemed like a minor thing.  Users of the C interface should read the documentation carefully. Renaming can be done in the high-level interfaces, if deemed necessary.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1144#issuecomment-446934997,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Seems good to me! Here's one idea to consider: when the list of stubs is shuffled, we should probably scan the entire list for loop edges first in a quick loop. If we find a loop edge, we can throw away the entire stub list without having to do any set operations at all. If we don't find a loop edge, we can proceed to building the adjacency list using sets without any performance loss. This could speed up the generation of graphs where the probability of generating a loop edge is significant.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1144#issuecomment-446935192,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","I find the current naming confusing because the method that does generate multigraphs is called ""SIMPLE""

True; it's called ""simple"" because it is a simple algorithm, not because it generates simple graphs. Unfortunately, as you have said, there's not much we can do about it without breaking API compatibility.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1144#issuecomment-447260304,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Please let me know whether you'd like to try implementing the check-for-loop-edges-first idea outlined above; if not, I might try it on my own after this one is merged.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1144#issuecomment-447658922,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Sorry for the late response ... I will be away for a while, then work will be busy. So I might not work on this at all until late January.  Feel free to implement this!  I will let you know when I come back to this, so we don't duplicate work.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1144#issuecomment-447902498,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Okay, I've merged the PR for the time being and we can return to this later as time allows.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1144#issuecomment-455805780,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Please let me know whether you'd like to try implementing the check-for-loop-edges-first idea outlined above; if not, I might try it on my own after this one is merged.

If you have not yet done this, I'll do it around next weekend. Let me know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1144#issuecomment-455812595,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Haven't started it yet and I won't start it until next weekend for sure, so feel free to go ahead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1144#issuecomment-479542125,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091","Note to self:
Another improvement that could be made: if the graph is dense (> 50%), then generate the complement instead, then convert it back to the desired graph. The configuration model's algorithm will fail on even tiny almost-complete graphs.
Counter-argument for doing this: we may not be able to judge in the best way when it is worth complementing the sequence. Thus doing this is better left to the user than trying to make our algorithm too smart.
@ntamas  What do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1144,2018-12-07T21:34:45Z,2018-12-17T08:59:10Z,2019-04-03T16:55:34Z,MERGED,True,251,29,4,https://github.com/szhorvat,degree_sequence_game: add uniform sampling,2,[],https://github.com/igraph/igraph/pull/1144,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1144#issuecomment-479572452,"This PR is another one back from April that I did not send in. It adds uniform sampling for simple graphs to degree_sequence_game based on the configuration model. Please do review the code before merging.
Related: #1089
Related: #1072
It also fixes #1091",I would resist the temptation to guess; just document the caveat and then let the user try it if needed.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1152,2019-02-12T07:06:56Z,2019-02-12T08:16:37Z,2019-02-12T08:17:18Z,MERGED,True,2,2,2,https://github.com/heavywatal,igraph_vector_init_copy: Add const to the source pointer,1,[],https://github.com/igraph/igraph/pull/1152,https://github.com/heavywatal,1,https://github.com/igraph/igraph/pull/1152,The copy source should be passed to igraph_vector_init_copy() via const pointer.,The copy source should be passed to igraph_vector_init_copy() via const pointer.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1152,2019-02-12T07:06:56Z,2019-02-12T08:16:37Z,2019-02-12T08:17:18Z,MERGED,True,2,2,2,https://github.com/heavywatal,igraph_vector_init_copy: Add const to the source pointer,1,[],https://github.com/igraph/igraph/pull/1152,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1152#issuecomment-462660832,The copy source should be passed to igraph_vector_init_copy() via const pointer.,"Seems good, thank you!",True,{'THUMBS_UP': ['https://github.com/heavywatal']}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/frederik-h,1,https://github.com/igraph/igraph/pull/1154,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/frederik-h,2,https://github.com/igraph/igraph/pull/1154#issuecomment-464840895,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","I am not a maintainer of igraph, just trying to help with the review.
I do suggest adding a check for whether the input graph is a tree. (...)
I did test the code a bit by integrating it into the Mathematica interface.

Thanks! I have added the check.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1154#issuecomment-465107081,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","Thank you for the contribution. I wanted to do this for a while myself, but I just couldn't get around to it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1154#issuecomment-465287000,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","Thanks for the contribution guys. I'm on holiday in Cyprus till the end of the week, I'll try to get around to reviewing this next week when I am back.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/gaborcsardi,5,https://github.com/igraph/igraph/pull/1154#issuecomment-474295228,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.",Thanks both!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/Pascal-Ortiz,6,https://github.com/igraph/igraph/pull/1154#issuecomment-513699117,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","This is an implementation of the feature requested in #1084.

Hi Frederik!
Good work! there are not so many libraries implementing Prufer conversions.
Looking at the source code, I thought your algorithm has linear complexity. To clarify, I have done some testing and it appears that execution seems to be quadratic (if you double the data size then time execution is multiplied by a factor 4) and the implentation was not able to build in a reasonable time a tree having one million of nodes from a prufer sequence.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1154#issuecomment-513704111,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","@Pascal-Ortiz

and the implentation was not able to build in a reasonable time a tree having one million of nodes from a prufer sequence.

This PR was for a function that takes a tree and creates a Prüfer sequence. You seem to be talking about taking a Prüfer sequence and building a tree. Can you clarify which one you are referring to?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/Pascal-Ortiz,8,https://github.com/igraph/igraph/pull/1154#issuecomment-513711695,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.",I'm talking about the igraph_from_prufer function.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/Pascal-Ortiz,9,https://github.com/igraph/igraph/pull/1154#issuecomment-513720811,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","This PR was for a function that takes a tree and creates a Prüfer sequence.

Sorry for the confusion. PR #1079 is the appropriate one.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1154#issuecomment-513727193,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","@Pascal-Ortiz Can you please open a new issue and describe the problem in detail, along with a link to the linear-time one? (So that I wouldn't forget about this—I did a quick test and indeed it's much slower than it should be.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1154,2019-02-17T18:28:38Z,2019-03-19T10:32:55Z,2019-07-22T10:49:09Z,MERGED,True,261,0,4,https://github.com/frederik-h,Add function for converting a tree to its prufer sequence,2,[],https://github.com/igraph/igraph/pull/1154,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1154#issuecomment-513741664,"This is an implementation of the feature requested in #1084.
Regarding licensing: I'm fine with GPL 2 or later and FDL.","Also a note:
If you want to use this for generating random trees, there's a different function for that (igraph_tree_game) which has a method that will be (much) faster for large trees.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1159,2019-04-14T18:44:34Z,2019-04-14T18:46:52Z,2019-04-14T18:46:57Z,MERGED,True,1,1,1,https://github.com/szhorvat,Fix line comment in C file,1,[],https://github.com/igraph/igraph/pull/1159,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1159,Just to get rid of compiler warning,Just to get rid of compiler warning,True,{}
igraph/igraph,https://github.com/igraph/igraph,1159,2019-04-14T18:44:34Z,2019-04-14T18:46:52Z,2019-04-14T18:46:57Z,MERGED,True,1,1,1,https://github.com/szhorvat,Fix line comment in C file,1,[],https://github.com/igraph/igraph/pull/1159,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1159#issuecomment-483038850,Just to get rid of compiler warning,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1160,2019-04-14T19:29:59Z,2019-04-15T08:57:55Z,2020-01-29T08:05:08Z,MERGED,True,16,2,2,https://github.com/szhorvat,Fix bug in igraph_is_tree,2,[],https://github.com/igraph/igraph/pull/1160,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1160,"There was a bug in igraph_is_tree.  See here: szhorvat/IGraphM#90
I contributed this code originally.
The igraph_i_is_tree_visitor function is effectively measuring the size of a connected component that contains root.  It worked like this: it pushed neighbours of the current version onto a stack. It popped off vertices from the stack and pushed their neighbours, etc.
A counter was incremented every time a vertex was popped. I did not think about the case when a vertex may be pushed more than once before it gets visited. This is exactly what happened here.
Now we only increment the counter if the popped vertex has no yet been visited.","There was a bug in igraph_is_tree.  See here: szhorvat/IGraphM#90
I contributed this code originally.
The igraph_i_is_tree_visitor function is effectively measuring the size of a connected component that contains root.  It worked like this: it pushed neighbours of the current version onto a stack. It popped off vertices from the stack and pushed their neighbours, etc.
A counter was incremented every time a vertex was popped. I did not think about the case when a vertex may be pushed more than once before it gets visited. This is exactly what happened here.
Now we only increment the counter if the popped vertex has no yet been visited.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1160,2019-04-14T19:29:59Z,2019-04-15T08:57:55Z,2020-01-29T08:05:08Z,MERGED,True,16,2,2,https://github.com/szhorvat,Fix bug in igraph_is_tree,2,[],https://github.com/igraph/igraph/pull/1160,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1160#issuecomment-483138799,"There was a bug in igraph_is_tree.  See here: szhorvat/IGraphM#90
I contributed this code originally.
The igraph_i_is_tree_visitor function is effectively measuring the size of a connected component that contains root.  It worked like this: it pushed neighbours of the current version onto a stack. It popped off vertices from the stack and pushed their neighbours, etc.
A counter was incremented every time a vertex was popped. I did not think about the case when a vertex may be pushed more than once before it gets visited. This is exactly what happened here.
Now we only increment the counter if the popped vertex has no yet been visited.",Seems good! Can you add a regression test to examples/simple/igraph_is_tree.c in a way that it fails without the patch but passes with the patch? This should allow us to ensure that the bug does not resurface in later versions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1160,2019-04-14T19:29:59Z,2019-04-15T08:57:55Z,2020-01-29T08:05:08Z,MERGED,True,16,2,2,https://github.com/szhorvat,Fix bug in igraph_is_tree,2,[],https://github.com/igraph/igraph/pull/1160,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1160#issuecomment-483166556,"There was a bug in igraph_is_tree.  See here: szhorvat/IGraphM#90
I contributed this code originally.
The igraph_i_is_tree_visitor function is effectively measuring the size of a connected component that contains root.  It worked like this: it pushed neighbours of the current version onto a stack. It popped off vertices from the stack and pushed their neighbours, etc.
A counter was incremented every time a vertex was popped. I did not think about the case when a vertex may be pushed more than once before it gets visited. This is exactly what happened here.
Now we only increment the counter if the popped vertex has no yet been visited.","Done. Verified that the test detects the issue if the patch is not applied.
I also added an IGRAPH_LIKELY.
__builtin_expect appears to work with clang as well, and the IGRAPH_LIKELY macro could be updated at one point. https://llvm.org/docs/BranchWeightMetadata.html  Not sure if it's worth the effort ... I won't do it now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1160,2019-04-14T19:29:59Z,2019-04-15T08:57:55Z,2020-01-29T08:05:08Z,MERGED,True,16,2,2,https://github.com/szhorvat,Fix bug in igraph_is_tree,2,[],https://github.com/igraph/igraph/pull/1160,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1160#issuecomment-483167482,"There was a bug in igraph_is_tree.  See here: szhorvat/IGraphM#90
I contributed this code originally.
The igraph_i_is_tree_visitor function is effectively measuring the size of a connected component that contains root.  It worked like this: it pushed neighbours of the current version onto a stack. It popped off vertices from the stack and pushed their neighbours, etc.
A counter was incremented every time a vertex was popped. I did not think about the case when a vertex may be pushed more than once before it gets visited. This is exactly what happened here.
Now we only increment the counter if the popped vertex has no yet been visited.","Thanks, it works now!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1164,2019-04-20T08:22:49Z,2019-04-21T08:43:45Z,2019-04-21T08:43:45Z,MERGED,True,461,463,1,https://github.com/szhorvat,Lad crash fix,3,[],https://github.com/igraph/igraph/pull/1164,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1164,"Fixes #927 (finally!)
See there for comments.
The two other commits:

change all tabs to spaces (it was really annoying to have to deal with tab sizes while debugging this)
remove some unnecessary code which was also removed from the original LAD sources","Fixes #927 (finally!)
See there for comments.
The two other commits:

change all tabs to spaces (it was really annoying to have to deal with tab sizes while debugging this)
remove some unnecessary code which was also removed from the original LAD sources",True,{}
igraph/igraph,https://github.com/igraph/igraph,1164,2019-04-20T08:22:49Z,2019-04-21T08:43:45Z,2019-04-21T08:43:45Z,MERGED,True,461,463,1,https://github.com/szhorvat,Lad crash fix,3,[],https://github.com/igraph/igraph/pull/1164,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1164#issuecomment-485235371,"Fixes #927 (finally!)
See there for comments.
The two other commits:

change all tabs to spaces (it was really annoying to have to deal with tab sizes while debugging this)
remove some unnecessary code which was also removed from the original LAD sources","Seems good to me, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1165,2019-04-20T08:42:33Z,2019-04-21T08:48:53Z,2020-01-29T09:17:39Z,MERGED,True,10,0,1,https://github.com/szhorvat,igraph_edge_connectivity: fix for singleton graph,1,[],https://github.com/igraph/igraph/pull/1165,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1165,Fixes #1163 by postulating the edge connectivity of K_1 to be 0. See discussion there.,Fixes #1163 by postulating the edge connectivity of K_1 to be 0. See discussion there.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1167,2019-04-21T19:41:40Z,2019-04-21T20:15:26Z,2019-04-21T20:15:26Z,MERGED,True,1,1,1,https://github.com/szhorvat,Documentation fix,1,[],https://github.com/igraph/igraph/pull/1167,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1167,Change < to &lt; so that the documentation would build and pass XML validation.,Change < to &lt; so that the documentation would build and pass XML validation.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1168,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1168#issuecomment-485710924,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","This should probably be renamed to something better: any suggestions?
I implemented multigraph subgraph matching in IGraph/M based on this. It would be nice to include that in the igraph C core eventually. It's not as trivial as using colours because a smaller multiplicity edge in the pattern graph should match the higher multiplicity edge in the target graph.  Thus we need a custom edge comparator function, which is not available in the high-level interfaces. Even if it were, constant callbacks to the high-level interface would kill performance.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1168#issuecomment-485711370,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","Related (Tamás's answer):

https://stackoverflow.com/questions/33980048/checking-for-multigraph-isomorphism-in-python-igraph",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1168#issuecomment-485828109,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?

Right now this is indeed the case.

This should probably be renamed to something better: any suggestions?

How about igraph_simplify_and_colorize()?
Otherwise the implementation seems okay to be, but as always, there should be some tests in examples/simple that verify the implementation. The ones for igraph_simplify() could probably be re-used.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1168#issuecomment-485838466,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","Since the motivation for adding this function is to handle isomorphism for non-simple graphs, shall we do that at the same time, and merge everything together? Some issues might appear along the way.
If yes, would it be better to extend igraph_isomorphic and igraph_subisomorphic to handle multigraphs, or create entirely new functions?  I think that extending them is a good idea since these are ""generic"" functions that dispatch to the ""best"" implementation for each specific case.  We would just add another branch for multigraphs (for isomorphic) and for non-simple graphs (for subisomorphic).
igraph_isomorphic and igraph_subisomorphic only return a yes/no answer but they do not return an actual mapping. Eventually, it may be a good idea to also add generic functions which return one or more mappings. In particular for the subgraph case, one would typically want to know where a specific subgraph appears.  It's not clear to me what's the best approach here: generic function that returns one mapping, generic function that returns multiple mappings (if requested), or specific functions (i.e. vf2 in the name) that return multiple mappings and use a specific algorithm.  The main motivation for adding such a function is that it is currently not easily implementable for subgraphs/multigraphs in the high-level interfaces.
For the subgraph case, in principle this is implementable both for VF2 and LAD. I would not bother with LAD for now because later versions of LAD handle colours differently than LADv1 (which is in igraph). If LAD ever gets updated, this would have to change as well.
The state-of-the-art algorithms that could be used for this are: RI, VF3 and LADv3.
I experimented a bit with VF3 and the naive integration is often slower than the existing VF2, so I put it aside for now. I suspect that this either has to do with converting the graph format (I did this for vf3lib but igraph's VF2 is well-integrated and maybe it doesn't do a conversion), or more likely with the pre-processing step (it's not clear to me when that's actually necessary).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1168#issuecomment-486175305,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function",Should the res argument come before or after the graph argument? igraph is not entirely consistent in this and has functions of both kinds.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1168#issuecomment-487291438,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?

Right now this is indeed the case.

@ntamas  This should be documented as an invariant, just in case someone contributes a function that messes with the internal graph structure directly ...
On a related note, how do I build the documentation so that it includes \ingroup internal things, such as igraph_t itself?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1168#issuecomment-490807898,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","If yes, would it be better to extend igraph_isomorphic and igraph_subisomorphic to handle multigraphs, or create entirely new functions? I think that extending them is a good idea since these are ""generic"" functions that dispatch to the ""best"" implementation for each specific case.

I would vote for extending igraph_isomorphic and igraph_subisomorphic.

Eventually, it may be a good idea to also add generic functions which return one or more mappings.

Yes, indeed.

Should the res argument come before or after the graph argument? igraph is not entirely consistent in this and has functions of both kinds.

I know that we haven't been consistent with the API in several cases. Right now I would say that I would follow the convention that the first argument is always the ""this"" argument (i.e. what would be ""this"" if we were programming in C++), just like the explicit self argument in Python. The second one could be the output argument (if there is one), and the input arguments could come after that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1168#issuecomment-490810659,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","On a related note, how do I build the documentation so that it includes \ingroup internal things, such as igraph_t itself?

Sorry, I have no idea :( The whole documentation build system was brewed in-house and I don't know exactly how it works by now. I know that a long while ago we started with Doxygen, but then it turned out that it did not really satisfy our needs (we wanted to generate documentation in HTML, PDF and INFO formats), so we wrote a quick regexp-based converter (doc/doxrox.py) that parses the C source code and converts everything into Docbook format (this is done by the rules defined in doc/c-docbook.re). Some of the Doxygen-related tags (such as \ingroup) were not needed in this new setup so we simply instructed doxrox.py to ignore these tags. I don't think that the \ingroup tags are actually used for anything by now - the documentation's XXML files basically specify explicitly what needs to be included where.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1168#issuecomment-490812274,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","Should the res argument come before or after the graph argument? igraph is not entirely consistent in this and has functions of both kinds.

I know that we haven't been consistent with the API in several cases. Right now I would say that I would follow the convention that the first argument is always the ""this"" argument (i.e. what would be ""this"" if we were programming in C++), just like the explicit self argument in Python. The second one could be the output argument (if there is one), and the input arguments could come after that.

That's how I think of it too, but then the question can be rephrased:
Is this function a constructor (that takes a multigraph as input)? Or a method of igraph_t that outputs another graph?
It makes sense to say that it's a method that outputs a graph because it also outputs the colours (multiplicities).  Then we keep it as it currently is (input graph is the first argument, output graph is the second).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1168#issuecomment-490812559,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","In the face of ambiguity, I'd say let's keep stuff as it is now :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1168#issuecomment-491195713,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","I forgot about attribute combiners, but given that this is specifically meant as a helper function to deal with multigraph isomorphism, I think it's fine not to include that. Agreed?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1168#issuecomment-491199331,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function",Yes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1168#issuecomment-493430541,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","Added tests. Also added a file with utility functions for testing.  Once merged, I'll send a PR which adds tests for igraph_tree (see #1097). I have them but they use the new helper functions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1168#issuecomment-493435964,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function","An explanation for why the vector printing and the graph printing are so fancy in the helper functions:
This is so that it can be clear when a vector is empty or a graph has no edges. It would be confusing if a test failed because the number of empty lines didn't match with the expected output.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1168,2019-04-21T20:14:01Z,2019-05-20T09:47:18Z,2019-05-20T09:47:19Z,MERGED,True,291,1,7,https://github.com/szhorvat,igraph_colored_simple_graph,3,[],https://github.com/igraph/igraph/pull/1168,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1168#issuecomment-493915477,"Currently, no included isomorphism algorithm supports multigraphs.
VF2 does not seem to support either self loops (#1166, please verify) or multigraphs (#815)
We can still theoretically deal with multigraphs like so:

simplify the graph (no self-loops / multi-edges)
colour edges based on their original multiplicity (simple edges get 1, edges merged from two parallel ones get 2, etc.)
colour vertices based on how many incident self-loops they had

Now we can use coloured-graph isomorphism (using VF2) to handle the multigraph.
This PR adds a function to do this graph simplification while counting self-loops and multi-edges.
It also rearranges the Isomorphism documentation sections a bit.
Please verify before merging!  It closely follows igraph_simplify in its implementation.
Question: In undirected graphs, do edges always appear sorted, i.e. always 1-2 and not 2-1?  igraph_simplify seems to rely on this where it checks to == pto && from == pfrom but not to == pfrom && from == pto.  I did the same in this function",Seems good to me!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1183,2019-05-16T13:45:44Z,2019-05-16T13:48:21Z,2020-01-29T08:04:45Z,MERGED,True,62,8,3,https://github.com/szhorvat,Expand documentation on isomorphism functions,1,[],https://github.com/igraph/igraph/pull/1183,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1183,"This will take care of #882
Please read through it before merging.","This will take care of #882
Please read through it before merging.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1183,2019-05-16T13:45:44Z,2019-05-16T13:48:21Z,2020-01-29T08:04:45Z,MERGED,True,62,8,3,https://github.com/szhorvat,Expand documentation on isomorphism functions,1,[],https://github.com/igraph/igraph/pull/1183,https://github.com/gaborcsardi,2,https://github.com/igraph/igraph/pull/1183#issuecomment-493074809,"This will take care of #882
Please read through it before merging.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1184,2019-05-16T16:55:56Z,2019-05-16T17:12:34Z,2020-01-29T09:16:18Z,MERGED,True,55,44,14,https://github.com/szhorvat,Reenable tests,2,[],https://github.com/igraph/igraph/pull/1184,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1184,"This PR does two things:


Adds a dead simple test to make sure that the default RNG produces the same sequence of numbers on all platforms. There are other tests which would fail if this were not the case, but I wanted a test that does this and nothing else. As discussed, this went into examples/tests instead of examples/simple. The idea is that examples/simple are supposed to be educational (and some of them included in the docs), while examples/tests have one purpose: testing.


Don't disable tests on non-Mac platforms, see #548


I ran the tests on Mac and x86_64 Linux only so far, but I do not expect problems on MinGW. I suggest merging, and if something breaks on Windows, consider that a separate issue.","This PR does two things:


Adds a dead simple test to make sure that the default RNG produces the same sequence of numbers on all platforms. There are other tests which would fail if this were not the case, but I wanted a test that does this and nothing else. As discussed, this went into examples/tests instead of examples/simple. The idea is that examples/simple are supposed to be educational (and some of them included in the docs), while examples/tests have one purpose: testing.


Don't disable tests on non-Mac platforms, see #548


I ran the tests on Mac and x86_64 Linux only so far, but I do not expect problems on MinGW. I suggest merging, and if something breaks on Windows, consider that a separate issue.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1184,2019-05-16T16:55:56Z,2019-05-16T17:12:34Z,2020-01-29T09:16:18Z,MERGED,True,55,44,14,https://github.com/szhorvat,Reenable tests,2,[],https://github.com/igraph/igraph/pull/1184,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1184#issuecomment-493154207,"This PR does two things:


Adds a dead simple test to make sure that the default RNG produces the same sequence of numbers on all platforms. There are other tests which would fail if this were not the case, but I wanted a test that does this and nothing else. As discussed, this went into examples/tests instead of examples/simple. The idea is that examples/simple are supposed to be educational (and some of them included in the docs), while examples/tests have one purpose: testing.


Don't disable tests on non-Mac platforms, see #548


I ran the tests on Mac and x86_64 Linux only so far, but I do not expect problems on MinGW. I suggest merging, and if something breaks on Windows, consider that a separate issue.",Let's see how it goes. Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1187,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1187#issuecomment-496035973,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.",I think this is done. I understand this is planned for 0.9 but since it's done we could include it already,True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1187#issuecomment-496113186,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Please also change the weighted case, as well as the edge betweenness case (only the weighted calculation is affected for that one).
Have you tested the change already?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/1187#issuecomment-496248048,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Thank you @szhorvat, I can write a test for CI.
Are those other things mentioned in other issues on GitHub? If so it'd be great to collect them all here so I can understand the situation better and close them at once.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1187#issuecomment-496248605,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","I mentioned them in #1050:

unweighted and weighted vertex betweenness is affected
weighted edge betweenness is affected
unweighted edge betweenness is not affected

The same fix you applied should work for the missing two as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1187#issuecomment-496250526,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.",I just verified that closeness calculation is not affected (but found another problem there ... will open an issue).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1187#issuecomment-496260537,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.",You mean issue #56 of igraphM?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1187#issuecomment-496276405,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Sorry, I'm not sure I understand. Are you referring to the closeness issue I mentioned? It's #1197",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,9,https://github.com/igraph/igraph/pull/1187#issuecomment-496279099,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","My fault, wrong link 😋
The closeness is a separate regression bug, the weighted version I'm not sure but I don't have my computer now, let me check and get back to you 😊",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1187#issuecomment-496279597,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Yes, the closeness is independent and unrelated. I simply confirmed that there is no issue with the cutoff parameter and closeness calculations. The only problems are with 3 varieties of betweenness, see my message above. #1187 (comment)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,11,https://github.com/igraph/igraph/pull/1187#issuecomment-496555689,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Good, I fixed the two remaining betwennness measures.
Anything else I should do about this?
Shall we just wait until the checks pass on CI or shall I make a test against this corner case?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1187#issuecomment-496576308,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","In my personal experience, it is very important to test (= try out) every change one makes.  I do not mean adding a test case, but did you actually try it out? Often the easiest way is to build a high-level interface with the change and try it from that.
It has happened to me multiple times that I was completely confident about a change I made and I neglected to test it properly, then it turned out that my change was incorrect.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,13,https://github.com/igraph/igraph/pull/1187#issuecomment-496577634,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.",Agreed. Then I would need to compile python-igraph against the locally built C core and then write a short Python script against that I guess. Is there any info on how to do that?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,14,https://github.com/igraph/igraph/pull/1187#issuecomment-496606091,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Ok I added tests for the vertex and edge betweenness, both for weighted and unweighted. They work fine, so the PR is good to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1187#issuecomment-496647505,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","I would need to compile python-igraph against the locally built C core

Personally, I do it like this:

Install pkg-config and add $HOME/lib/pkgconfig to the environment variable named PKG_CONFIG_PATH. (I have this in my shell profile).
Add $HOME/lib to LD_LIBRARY_PATH (or to DYLD_LIBRARY_PATH on macOS). This is to ensure that libraries installed in $HOME/lib are picked up by the linker.
Build and install igraph locally with mkdir build && cd build && ../configure --prefix=$HOME && make && make install. This installs igraph in $HOME/include/igraph/... and $HOME/lib, and also puts a file in $HOME/lib/pkgconfig that helps pkg-config tell what the igraph compiler and linker flags are. (You can validate this with pkg-config --cflags --libs igraph).
Check out python-igraph's source code somewhere and then run python setup.py install. (Preferably in a virtualenv to avoid messing around with the system Python).

Let me know if you need more help with this.",True,{'HEART': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1187,2019-05-21T20:22:40Z,2019-05-29T07:28:51Z,2019-05-29T07:28:51Z,MERGED,True,155,44,3,https://github.com/iosonofabio,Start working on betweenness cutoff=0 #1050,3,[],https://github.com/igraph/igraph/pull/1187,https://github.com/iosonofabio,16,https://github.com/igraph/igraph/pull/1187#issuecomment-496681057,"Changing an >= 0 into > 0 should work, as the doc says. Of course, as already noted in #1050, there's no good reason to set cutoff = 0 except to get exact betweenness.","Thank you, we should write this up in some docs...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1189,2019-05-21T21:35:17Z,2020-01-22T13:41:49Z,2020-01-22T13:41:57Z,CLOSED,False,16,15,1,https://github.com/vtraag,Compilation instructions Windows,3,[],https://github.com/igraph/igraph/pull/1189,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1189,"Updated the instructions for compilation on Windows slightly. This essentially reflects what @jankatins wrote in #969 (comment).
Removed the instructions for compiling python-igraph. Those instructions should probably be better included in that repository (and will need to be updated anyway).
This (at least partially) addresses #969. You indicated you had problems @szhorvat compiling igraph using MSVC on Windows. Do you have specific issues you run into that aren't in these (admittedly succinct) instructions?","Updated the instructions for compilation on Windows slightly. This essentially reflects what @jankatins wrote in #969 (comment).
Removed the instructions for compiling python-igraph. Those instructions should probably be better included in that repository (and will need to be updated anyway).
This (at least partially) addresses #969. You indicated you had problems @szhorvat compiling igraph using MSVC on Windows. Do you have specific issues you run into that aren't in these (admittedly succinct) instructions?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1189,2019-05-21T21:35:17Z,2020-01-22T13:41:49Z,2020-01-22T13:41:57Z,CLOSED,False,16,15,1,https://github.com/vtraag,Compilation instructions Windows,3,[],https://github.com/igraph/igraph/pull/1189,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1189#issuecomment-494686742,"Updated the instructions for compilation on Windows slightly. This essentially reflects what @jankatins wrote in #969 (comment).
Removed the instructions for compiling python-igraph. Those instructions should probably be better included in that repository (and will need to be updated anyway).
This (at least partially) addresses #969. You indicated you had problems @szhorvat compiling igraph using MSVC on Windows. Do you have specific issues you run into that aren't in these (admittedly succinct) instructions?",I'll give it a go on the weekend.,True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1189,2019-05-21T21:35:17Z,2020-01-22T13:41:49Z,2020-01-22T13:41:57Z,CLOSED,False,16,15,1,https://github.com/vtraag,Compilation instructions Windows,3,[],https://github.com/igraph/igraph/pull/1189,https://github.com/apps/stale,3,https://github.com/igraph/igraph/pull/1189#issuecomment-577127012,"Updated the instructions for compilation on Windows slightly. This essentially reflects what @jankatins wrote in #969 (comment).
Removed the instructions for compiling python-igraph. Those instructions should probably be better included in that repository (and will need to be updated anyway).
This (at least partially) addresses #969. You indicated you had problems @szhorvat compiling igraph using MSVC on Windows. Do you have specific issues you run into that aren't in these (admittedly succinct) instructions?",This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1189,2019-05-21T21:35:17Z,2020-01-22T13:41:49Z,2020-01-22T13:41:57Z,CLOSED,False,16,15,1,https://github.com/vtraag,Compilation instructions Windows,3,[],https://github.com/igraph/igraph/pull/1189,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1189#issuecomment-577147206,"Updated the instructions for compilation on Windows slightly. This essentially reflects what @jankatins wrote in #969 (comment).
Removed the instructions for compiling python-igraph. Those instructions should probably be better included in that repository (and will need to be updated anyway).
This (at least partially) addresses #969. You indicated you had problems @szhorvat compiling igraph using MSVC on Windows. Do you have specific issues you run into that aren't in these (admittedly succinct) instructions?","I believe this is now superseded by #1279, right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1189,2019-05-21T21:35:17Z,2020-01-22T13:41:49Z,2020-01-22T13:41:57Z,CLOSED,False,16,15,1,https://github.com/vtraag,Compilation instructions Windows,3,[],https://github.com/igraph/igraph/pull/1189,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1189#issuecomment-577186928,"Updated the instructions for compilation on Windows slightly. This essentially reflects what @jankatins wrote in #969 (comment).
Removed the instructions for compiling python-igraph. Those instructions should probably be better included in that repository (and will need to be updated anyway).
This (at least partially) addresses #969. You indicated you had problems @szhorvat compiling igraph using MSVC on Windows. Do you have specific issues you run into that aren't in these (admittedly succinct) instructions?","Yes, indeed, it can be closed!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1190,2019-05-21T21:54:33Z,2019-05-21T21:58:06Z,2019-05-21T21:58:06Z,MERGED,True,5,4,1,https://github.com/iosonofabio,Fix for #899: Prevent overflow of maxedges by early conversion to double,1,[],https://github.com/igraph/igraph/pull/1190,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1190,Try and convert n1 and n2 to double before multiplying to avoid overflowing integers,Try and convert n1 and n2 to double before multiplying to avoid overflowing integers,True,{}
igraph/igraph,https://github.com/igraph/igraph,1190,2019-05-21T21:54:33Z,2019-05-21T21:58:06Z,2019-05-21T21:58:06Z,MERGED,True,5,4,1,https://github.com/iosonofabio,Fix for #899: Prevent overflow of maxedges by early conversion to double,1,[],https://github.com/igraph/igraph/pull/1190,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1190#issuecomment-494574543,Try and convert n1 and n2 to double before multiplying to avoid overflowing integers,Seems good to me!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1191,2019-05-21T22:46:21Z,2019-05-23T08:20:51Z,2019-05-23T08:20:59Z,MERGED,True,44,0,3,https://github.com/iosonofabio,Check for #1056: Test for boolean graph attribute,2,[],https://github.com/igraph/igraph/pull/1191,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1191,"Added two files inside `examples/simple' for now:

a C file with the example code
a graphml file with the example graph

Not sure what else needs to be done to include this in the test suite. Also, do we need an XML file in the same folder?","Added two files inside `examples/simple' for now:

a C file with the example code
a graphml file with the example graph

Not sure what else needs to be done to include this in the test suite. Also, do we need an XML file in the same folder?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1191,2019-05-21T22:46:21Z,2019-05-23T08:20:51Z,2019-05-23T08:20:59Z,MERGED,True,44,0,3,https://github.com/iosonofabio,Check for #1056: Test for boolean graph attribute,2,[],https://github.com/igraph/igraph/pull/1191,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1191#issuecomment-495117243,"Added two files inside `examples/simple' for now:

a C file with the example code
a graphml file with the example graph

Not sure what else needs to be done to include this in the test suite. Also, do we need an XML file in the same folder?",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1192,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1192#issuecomment-494689552,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","Just a warning, so we don't duplicate work (also mentioned in the chatroom). I have existing working meant to replace PR #824 , but not complete. I was meaning to send the completed parts soon. We should coordinate on this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1192#issuecomment-494692536,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","OK, good. I'll let you submit your work first then and won't touch it further. Feel free to either use your fork or merge your changes into this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1192#issuecomment-500395157,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","Was it ever verified that the new maximal clique finder performs better even for finding maximal independent vertex sets than the currently used independent vertex set finder? This is the premise of #824.
Equivalently, was it verified that this new max clique finder is faster even for dense graphs?
@gaborcsardi, since you implemented these, do you have any comment on this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/gaborcsardi,5,https://github.com/igraph/igraph/pull/1192#issuecomment-500399818,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","sry, I don't remember. I would think that it is much faster at least for sparse graphs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1192#issuecomment-500400880,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.",I'll do some benchmarks before swapping out the independent vertex set finder (which is effectively the dense graph case).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1192#issuecomment-500827999,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","I doubt that the independent vertex set based finder would perform better. The key problem was that in order to find maximal cliques in a graph using independent vertex sets, you need to construct the complement graph first, which is prohibitively expensive (both memory- and time-wise) for large sparse networks as the complement would be an almost full graph. (I'm talking about the scale of protein-protein interaction networks here with vertices in the order of thousands).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1192#issuecomment-500834472,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","@ntamas Sorry, I misremembered what #824 was about. No problems with the proposals in that PR. I thought it also proposed transitioning the independent vertex set functions to use the new clique finders. But it did not.
As you say, computing the complement is not nice ... would take up a lot of memory. Still, eventually it will be good to investigate if that could help.  We now have fast clique finding implementations for both all cliques (Cliquer) and maximal cliques (the subject of this PR). Maybe they can be modified to work without having to store the complement graph. (I think—not sure— that Cliquer stores the graph as a bit-based adjacency matrix so it wouldn't be a problem to do the complement.)
Anyway, the independent vertex set thing is a project for much later.
I'll send a PR with the few changes I already have towards this before 0.8 and the rest can go into 0.9.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1192#issuecomment-500836471,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","@ntamas Before I send that PR, there's another thing to discuss.
I have a version that can find a limited number of cliques. Just like the VF2 functions, it take a ""clique handler function"" as the argument. This function can signal to stop the search.
In order to stop the search, it uses a special, undocumented return value.
https://github.com/szhorvat/igraph/blob/IGraphM-040/src/maximal_cliques_template.h#L118
https://github.com/szhorvat/igraph/blob/IGraphM-040/include/igraph_error.h#L393
I am not completely comfortable with ""abusing"" error codes like this ... but I don't have a much better simple solution. I think you suggested this method originally, but I can't find the discussion.
What do you think about this? Shall we go on with this method and add the IGRAPH_SEARCH_STOPPED return code / ""error code""?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1192#issuecomment-501231037,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","I think it's fine; I would probably use a shorter name like IGRAPH_STOP, but that's just a matter of taste.
One thing though: if you extend the error enum, please also add a human-readable description of the error in igraph_i_error_strings[] in src/igraph_error.c. I think we also forgot to do this for the IGRAPH_ERWSTUCK error code. igraph_strerror() could return an invalid pointer if we don't do this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1192#issuecomment-501314908,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","@ntamas I'll add the missing error strings. This ""error code"" will be a bit special because it should never propagate to the top and should never be visible to the user. I'll note this in the error string. If anyone sees this message, it indicates a bug, and they should know that it needs to be reported.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1192#issuecomment-501319977,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.","Yes, that’s exactly how I was thinking about it.

T.
…
 On 2019. Jun 12., at 17:03, Szabolcs Horvát ***@***.***> wrote:

 @ntamas I'll add the missing error strings. This ""error code"" will be a bit special because it should never propagate to the top and should never be visible to the user. I'll note this in the error string. If anyone sees this message, it indicates a bug, and they should know that it needs to be reported.

 —
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub, or mute the thread.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1192,2019-05-22T07:34:08Z,2020-01-29T11:44:17Z,2020-02-06T09:16:48Z,CLOSED,False,143,54,5,https://github.com/vtraag,modified igraph_clique_number to use the new maximal clique implementation,6,['stale'],https://github.com/igraph/igraph/pull/1192,https://github.com/apps/stale,13,https://github.com/igraph/igraph/pull/1192#issuecomment-577127005,"This continues PR #824 for which the original fork was removed, so we cannot continue to work on it. In this PR we can continue the work. This should address issue #804.
At the moment further work is required, at the moment I only integrated PR #824 with the current master, and corrected something based on the earlier comments by @szhorvat.",This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1194,2019-05-22T08:40:28Z,2019-05-24T13:24:04Z,2019-06-07T08:14:08Z,MERGED,True,14,7,2,https://github.com/vtraag,Removed membership argument of modularity_matrix.,6,[],https://github.com/igraph/igraph/pull/1194,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1194,Fixes #1035.,Fixes #1035.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1194,2019-05-22T08:40:28Z,2019-05-24T13:24:04Z,2019-06-07T08:14:08Z,MERGED,True,14,7,2,https://github.com/vtraag,Removed membership argument of modularity_matrix.,6,[],https://github.com/igraph/igraph/pull/1194,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1194#issuecomment-494950555,Fixes #1035.,"Ah yeah, of course, sorry. Will do so Friday (won't have time tomorrow).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1195,2019-05-26T19:07:58Z,2019-05-26T19:47:18Z,2019-05-26T19:47:18Z,MERGED,True,19,9,1,https://github.com/iosonofabio,Fix test for #1191,2,[],https://github.com/igraph/igraph/pull/1195,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1195,#1191 was merged but the test actually fails for trivial reasons. Now I confirmed it works locally so this should close #1191 for good :-),#1191 was merged but the test actually fails for trivial reasons. Now I confirmed it works locally so this should close #1191 for good :-),True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1196,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1196#issuecomment-496719726,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","I added tests for this, should be good to go, let's just wait for CI",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1196#issuecomment-497280690,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","Normally, functions that are not part of the public API are named igraph_i_ and are marked as local to the compilation unit (static). I wonder why igraph_clusters_weak and igraph_clusters_strong were not like this. I saw that you modelled igraph_decompose_(strong|weak) after these.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/1196#issuecomment-497378855,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","I'm happy to rename them for consistency. If it's not part of the API, it should be fine.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1196#issuecomment-497398049,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","I wonder why igraph_clusters_weak and igraph_clusters_strong were not like this.

Historical reasons :) (igraph has a looooong history). Feel free to rename these and igraph_decompose_(strong|weak) as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1196#issuecomment-497406927,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","@iosonofabio
Just to make this explicit then, the declaration should be
static int igraph_i_clusters_weak(...);
with the arguments filled in for ..., of course :)

igraph has a looooong history

We're working on it because it has a long enough history that it accumulated more useful functionality than most alternatives :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1196#issuecomment-497410671,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","done, passes tests locally, let's see on CI :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1196,2019-05-27T02:50:26Z,2019-06-01T19:34:18Z,2019-06-01T19:34:18Z,MERGED,True,328,17,4,https://github.com/iosonofabio,Addressing #718: decompose into strongly connected components,6,[],https://github.com/igraph/igraph/pull/1196,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1196#issuecomment-497971906,"DO NOT MERGE YET!
Implemented as a mix of igraph_decompose (now igraph_decompose_weak) and igraph_clusters_strong.
I need to add tests, but wanted to put it out there for you to review if you have a minute.
This addresses #718
Thanks","Seems good to me, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1198,2019-06-07T05:58:40Z,2019-06-25T10:47:43Z,2019-06-25T10:47:43Z,MERGED,True,61,9,1,https://github.com/iosonofabio,"First fixes to #1145, citation games",4,[],https://github.com/igraph/igraph/pull/1198,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1198,"DO NOT MERGE YET!
Started implemented suggested fixes to both citation games in #1145 , seems quite smooth up to now.
Will let you know when this is likely merge-able.","DO NOT MERGE YET!
Started implemented suggested fixes to both citation games in #1145 , seems quite smooth up to now.
Will let you know when this is likely merge-able.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1198,2019-06-07T05:58:40Z,2019-06-25T10:47:43Z,2019-06-25T10:47:43Z,MERGED,True,61,9,1,https://github.com/iosonofabio,"First fixes to #1145, citation games",4,[],https://github.com/igraph/igraph/pull/1198,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1198#issuecomment-500252629,"DO NOT MERGE YET!
Started implemented suggested fixes to both citation games in #1145 , seems quite smooth up to now.
Will let you know when this is likely merge-able.","This only fails on windows (AppVeyor) and only with Python2.7, whatever that means since it's a C library. The error message is:
.\src\games.c(3532) : error C2143: syntax error : missing ';' before 'type'
could anyone who knows AppVeyor or Microsoft quirks please have a look?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1198,2019-06-07T05:58:40Z,2019-06-25T10:47:43Z,2019-06-25T10:47:43Z,MERGED,True,61,9,1,https://github.com/iosonofabio,"First fixes to #1145, citation games",4,[],https://github.com/igraph/igraph/pull/1198,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1198#issuecomment-500330207,"DO NOT MERGE YET!
Started implemented suggested fixes to both citation games in #1145 , seems quite smooth up to now.
Will let you know when this is likely merge-able.","ANSI C requires declarations to come at the beginning of blocks.
{
    doSomething();
    long x = 1; /* invalid */
    doSomethingElse(x);
}
{
    long x; /* valid */
    doSomething();
    x = 1; /* valid */
    doSomethingElse(x);
}
With newer MSVC it does not fail because of some support for C99 (enabled by default), which allows declarations elsewhere.
With gcc it does not fail because it allows this as a GNU extension. The default is -std=gnu89. With -std=c89 it would fail too.
You can fix such problems either by moving the declaration to the beginning of the block, or by adding a new block starting at the point where the declaration was.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1198,2019-06-07T05:58:40Z,2019-06-25T10:47:43Z,2019-06-25T10:47:43Z,MERGED,True,61,9,1,https://github.com/iosonofabio,"First fixes to #1145, citation games",4,[],https://github.com/igraph/igraph/pull/1198,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/1198#issuecomment-505234855,"DO NOT MERGE YET!
Started implemented suggested fixes to both citation games in #1145 , seems quite smooth up to now.
Will let you know when this is likely merge-able.","Ok, this is ready for merging",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1199,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1199#issuecomment-499801011,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",FYI: relevant changes start at line 1576.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1199#issuecomment-499920596,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Perhaps we could use range checking on some of the data structures when compiled with --enable-debug?

We could rely on the NDEBUG macro in C and put range checks and stuff like that in #if !defined(NDEBUG) ... #endif. As far as I know NDEBUG is standard and it is defined when the app is compiled in non-debug mode. (Needs someone to confirm that).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1199#issuecomment-499920901,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",Tests 90 and 91 seem to fail; is this also a case on your machine?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1199#issuecomment-499921283,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see.

You can ask Github to ignore whitespace when diffing so it is actually pretty readable on Github.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1199#issuecomment-499939526,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Yes, I just noticed that these tests fail, I'll investigate, I didn't run them locally.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1199#issuecomment-500018425,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","I've changed it around so that the tests now also work correctly. Probably a similar problem plays in igraph_i_edge_betweenness_estimate_weighted, I'm looking into correcting that as well. So don't merg yet, I'll look into that further.
Do we want to include a test for this case as well by the way?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1199#issuecomment-500032679,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Hmm, compilation fails for old MSVC that compiles using C89 rules that forbid mixed declaration and code. We said we would drop support for python2.7 anyhow, so should we then also disable that build and start allowing C99 from now on?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1199#issuecomment-500044878,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Mixed declarations are very easy to fix, and perhaps not a good enough reason to go to C99 ...
I sometimes write blocks in C:
void fun() {
    int i, j;

    {
        int a;
        doThing(a);
    }

    {
        int b;
        doThing(b);
    }
}
Do you know which is the first MSVC version that supports C99 reasonably fully?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1199#issuecomment-500046443,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","It would seem that Visual Studio 2017 still doesn't support VLAs ... https://stackoverflow.com/a/48615664/695132 Which was one of the major issues with porting LADv3.
Microsoft doesn't even seem to document C standards conformance (they have detailed documentation about C++ standards conformance).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1199#issuecomment-500098732,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Yes, I believe the support is always partial. But at least the mixed declaration and code is supported, I think from 2014 onwards?
Anyway, I'll change it for now, it's indeed straightforward to fix.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1199#issuecomment-500137611,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",Seems good to me - once the declaration is moved I'm happy to merge this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,13,https://github.com/igraph/igraph/pull/1199#issuecomment-500141201,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",Thanks! I'll first take a look at igraph_i_edge_betweenness_estimate_weighted before merging. I'll let you know when it's good to go.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1199#issuecomment-500540603,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","I've corrected the mixed declaration and initialization. I've also improved the numerical stability for igraph_i_edge_betweenness_estimate_weighted.
However, it now runs into a problem with test 93. The problem is that test 93 uses weights of 0. Is there any specific reason for that @iosonofabio ? It is currently allowed to use zero weights for igraph_i_edge_betweenness_estimate_weighted, whereas for igraph_i_betweenness_estimate_weighted zero weights are not allowed. Is there any specific reason for that? To me that doesn't make sense, and I would adjust igraph_i_edge_betweenness_estimate_weighted to only allow strictly positive weights. That then also requires that test 93 is updated to use strictly positive weights. Is there any reason not to do so @iosonofabio ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1199#issuecomment-500549895,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","The same numerical problem also appeared in igraph_i_closeness_estimate_weighted. Again, zero weights are allowed, and I don't understand why, and I would suggest restricting it to strictly positive weights.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,16,https://github.com/igraph/igraph/pull/1199#issuecomment-500728610,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",This PR also fixes #820.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,17,https://github.com/igraph/igraph/pull/1199#issuecomment-500729806,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",This PR also fixes #1009.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/1199#issuecomment-500735872,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Again, zero weights are allowed, and I don't understand why

I agree that we should simply exclude edges with zero weight. It does not really make sense for algorithms where the weights correspond to distances; an edge with zero weight basically means tha the two endpoints are ""infinitely close"", and I think that these measures are not prepared for that. (However, we can allow edges with zero weights in algorithms such as PageRank where the weight means ""closeness""; in that case, an edge with zero weight is essentially a nonexistent edge).
I'm happy to merge this if you add a check that prevents edges with zero weights in these functions.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,19,https://github.com/igraph/igraph/pull/1199#issuecomment-500778316,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","OK, I'll update the code and the tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,20,https://github.com/igraph/igraph/pull/1199#issuecomment-500791599,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1199#issuecomment-500853126,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","@vtraag
The IGraph/M test suite reveals some serious looking breakage in the closeness calculations with weighted graphs after this change ... I was hoping that I could tell you that everything passes, and be done with it, but apparently it'll take a bit of work to investigate. So this is just an advance notice. I'll come back to it later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1199#issuecomment-500854306,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.",In case someone else would investigate before I can get to it:,True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,23,https://github.com/igraph/igraph/pull/1199#issuecomment-500856521,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Hmm, that is a pity! Thanks for checking it carefully though, it seems I was too quick. I'll try to take a look as well, but if you make any progress, let me know!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,24,https://github.com/igraph/igraph/pull/1199#issuecomment-500879139,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","I can't reproduce your closeness measures for igraph in C (assuming these are returned by IGCloseness). I'm running this:
  igraph_i_set_attribute_table(&igraph_cattribute_table);
  
  igraph_t graph;
    
  igraph_vector_t edges;
  igraph_vector_init(&edges, 0);
  igraph_vector_push_back(&edges, 0); igraph_vector_push_back(&edges, 1);
  igraph_vector_push_back(&edges, 1); igraph_vector_push_back(&edges, 2);
  igraph_vector_push_back(&edges, 2); igraph_vector_push_back(&edges, 0);
  igraph_create(&graph, &edges, 3, 0);

  printf(""Graph has %i nodes and %i edges.\n"", igraph_vcount(&graph), igraph_ecount(&graph));
  
  igraph_vector_t weights;
  igraph_vector_init(&weights, 3);
  VECTOR(weights)[0] = 1;
  VECTOR(weights)[1] = 2;
  VECTOR(weights)[2] = 3;

  igraph_vector_t c;
  igraph_vector_init(&c, igraph_vcount(&graph));  
  igraph_closeness(&graph, &c, igraph_vss_all(), IGRAPH_ALL, &weights, 1);
  for (int i = 0; i < 3; i++)
  {
        printf(""Closeness node %i: %e\n"", i, VECTOR(c)[i]);
  }
  igraph_vector_destroy(&c);
      
  igraph_vector_destroy(&weights);
  igraph_destroy(&graph);

This yields
Graph has 3 nodes and 3 edges.
Closeness node 0: 5.000000e-01
Closeness node 1: 6.666667e-01
Closeness node 2: 4.000000e-01

which I believe is in line with the closeness from (I guess) Mathematica?
Am I misinterpreting the Mathematica code in any way?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1199#issuecomment-500880381,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","which I believe is in line with the closeness from (I guess) Mathematica?

Yes.

Am I misinterpreting the Mathematica code in any way?

No, except you don't need to set up an attribute handler. Passing a weights vector is sufficient.
I'll take a closer look later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/szhorvat,26,https://github.com/igraph/igraph/pull/1199#issuecomment-500885216,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Are you certain you are building with the correct version of igraph?
With your code, I get:
Graph has 3 nodes and 3 edges.
Closeness node 0: 2.857143e-01
Closeness node 1: 3.333333e-01
Closeness node 2: 2.500000e-01

This is with latest master.
Here's a simpler way to write the same:
#include <igraph.h>

int main() {
    igraph_t g;
    igraph_vector_t weights, res;

    igraph_small(&g, 3, 0, 0,1, 1,2, 0,2, -1);

    igraph_vector_init(&weights, 3);
    VECTOR(weights)[0] = 1;
    VECTOR(weights)[1] = 2;
    VECTOR(weights)[2] = 4;

    igraph_vector_init(&res, 0);

    igraph_closeness(&g, &res, igraph_vss_all(), IGRAPH_ALL, &weights, 1);

    igraph_vector_print(&res);

    igraph_vector_destroy(&res);
    igraph_vector_destroy(&weights);

    igraph_destroy(&g);

    return 0;
}
Note: In this example, I changed one of the weights from 3 to 4 to ensure that there's only a single shortest path between all pairs, and rule out one possible problem cause. The expected result is still the same.
Output:
0.285714 0.333333 0.25",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/vtraag,27,https://github.com/igraph/igraph/pull/1199#issuecomment-500887711,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","Sorry, yes, I just forgot that I actually checked out code to double check the result before the PR. I'll take a closer look at what's going wrong later today...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1199,2019-06-07T08:22:00Z,2019-06-11T10:57:10Z,2019-06-11T15:17:17Z,MERGED,True,34,18,2,https://github.com/vtraag,Improved numerical stability of betweenness,12,[],https://github.com/igraph/igraph/pull/1199,https://github.com/ntamas,28,https://github.com/igraph/igraph/pull/1199#issuecomment-500889059,"This should fix #591. I've tested it against the provided problem case, and it does solve that issue, and should be more numerically stable in general, I believe. It now also gives a warning in the case of small weights, that there may be numerical issues.
The reason the problem emerged at all is because of some numerical inaccuracies. This resulted in a node being popped already from the heap using igraph_2wheap_delete_max, but it was still updated afterwards using igraph_2wheap_modify. This is not possible, but this error is not explicitly caught by the igraph_2wheap interface.
Doing explicit range checking etc on these type of things will make it easier to do bughunting, but it will of course also slow it down. Perhaps we could use range checking on some of the data structures when compiled with --enable-debug? Anyway, just a thought, this is not for now.
Unfortunately, my editor also removed the trailing white space everywhere, so that the diff is a bit more difficult to read I now see. I can correct that at some later point if you want.","FYI, the Python tests are also breaking: https://travis-ci.org/igraph/python-igraph/jobs/544192558
(It's a pity that some of the igraph functions are actually tested indirectly by higher-level interfaces)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1201,2019-06-09T10:57:36Z,2019-06-09T11:36:03Z,2020-01-29T07:59:27Z,MERGED,True,123,1,6,https://github.com/szhorvat,igraph_tree: examples and tests,1,[],https://github.com/igraph/igraph/pull/1201,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1201,"Add tests and examples for igraph_tree().
Fixes #1097","Add tests and examples for igraph_tree().
Fixes #1097",True,{}
igraph/igraph,https://github.com/igraph/igraph,1203,2019-06-09T21:51:21Z,2019-06-26T19:51:29Z,2019-06-26T19:51:34Z,MERGED,True,12,1,1,https://github.com/iosonofabio,"GRAPHML export and locale, aka #930",6,[],https://github.com/igraph/igraph/pull/1203,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1203,"This PR tries to address issue #930
For now no error handling so the locale might be messed up if anything happens during the XML export.","This PR tries to address issue #930
For now no error handling so the locale might be messed up if anything happens during the XML export.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1203,2019-06-09T21:51:21Z,2019-06-26T19:51:29Z,2019-06-26T19:51:34Z,MERGED,True,12,1,1,https://github.com/iosonofabio,"GRAPHML export and locale, aka #930",6,[],https://github.com/igraph/igraph/pull/1203,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1203#issuecomment-500250301,"This PR tries to address issue #930
For now no error handling so the locale might be messed up if anything happens during the XML export.","Seems good as a starting point, but we should take care of error handling. In particular:

if strdup() returns NULL, return IGRAPH_ENOMEM and bail out
otherwise, add IGRAPH_FINALLY(igraph_free, saved_locale) right after strdup() so saved_locale gets freed properly when any of the functions we call return an igraph error code.
finally, at the end, call igraph_free() on saved_locale yourself and bump the counter in IGRAPH_FINALLY_FREE() by one to clean up the ""finally"" stack properly",True,{}
igraph/igraph,https://github.com/igraph/igraph,1203,2019-06-09T21:51:21Z,2019-06-26T19:51:29Z,2019-06-26T19:51:34Z,MERGED,True,12,1,1,https://github.com/iosonofabio,"GRAPHML export and locale, aka #930",6,[],https://github.com/igraph/igraph/pull/1203,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1203#issuecomment-500347330,"This PR tries to address issue #930
For now no error handling so the locale might be messed up if anything happens during the XML export.","Not quite there yet; IGRAPH_FINALLY(free, saved_locale) basically makes a note that if any subsequent IGRAPH_CHECK() call returns with an error code, igraph should call free(saved_locale) automatically. These entries are stored in a stack which we call the ""finally stack"". More about this here.
Note that the finally stack is not cleaned if you return from the current function with return, so you still need free(saved_locale) at the end. For normal return conditions, the idea is that you free everything that you have put in the finally stack on your own, and then you call IGRAPH_FINALLY_FREE() and tell igraph how many items to discard from the finally stack (the ones that you have taken care of yourself). If you add a new memory allocation somewhere in a function, you need to:

add a corresponding IGRAPH_FINALLY() call to take care of freeing the memory in case of an error (some macros like IGRAPH_VECTOR_INIT_FINALLY() unify the initialization and the handling of the finally stack in a single call).
free the memory on your own upon normal exit
find the IGRAPH_FINALLY_FREE() call at the end of the normal exit route and bump the counter in it by one",True,{}
igraph/igraph,https://github.com/igraph/igraph,1203,2019-06-09T21:51:21Z,2019-06-26T19:51:29Z,2019-06-26T19:51:34Z,MERGED,True,12,1,1,https://github.com/iosonofabio,"GRAPHML export and locale, aka #930",6,[],https://github.com/igraph/igraph/pull/1203,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/1203#issuecomment-505236161,"This PR tries to address issue #930
For now no error handling so the locale might be messed up if anything happens during the XML export.",This should be good now as soon as tests pass,True,{}
igraph/igraph,https://github.com/igraph/igraph,1203,2019-06-09T21:51:21Z,2019-06-26T19:51:29Z,2019-06-26T19:51:34Z,MERGED,True,12,1,1,https://github.com/iosonofabio,"GRAPHML export and locale, aka #930",6,[],https://github.com/igraph/igraph/pull/1203,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1203#issuecomment-506020437,"This PR tries to address issue #930
For now no error handling so the locale might be messed up if anything happens during the XML export.","Seems good to me as well, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1205,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.","This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1205#issuecomment-500710828,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.","It seems that the AppVeyor build was canceled because I pushed a new commit while it was running, but it didn't get restarted. I can't seem to restart the AppVeyor build, perhaps I don't have sufficient rights (I logged in using my GitHub credentials). Perhaps you can restart it @ntamas ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1205#issuecomment-500803463,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.",Restarted the build; fingers crossed.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1205#issuecomment-503125668,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.",I believe this should now be good to go?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1205#issuecomment-503131657,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.","Aaaah, I screwed it up. I accidentally squashed instead of rebasing, and then I tried to revert the PR... can you send it once again please so I could merge it again?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1205#issuecomment-503144692,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.","OK, created a new PR #1210.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1205,2019-06-10T22:20:29Z,2019-06-18T13:18:02Z,2019-06-18T13:52:09Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR,10,[],https://github.com/igraph/igraph/pull/1205,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1205#issuecomment-503144911,"This seems to fix #620. The problem was that some nodes were still being sampled, while there were no nodes actually left to be sampled.","Next time, I'll properly rebase before pushing :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1207,2019-06-11T12:04:03Z,2019-06-11T12:09:03Z,2019-06-18T13:05:24Z,MERGED,True,6,4,1,https://github.com/vtraag,Corrected doc: no refinement in leading eigenvector,8,[],https://github.com/igraph/igraph/pull/1207,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1207,Fixes #831.,Fixes #831.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1207,2019-06-11T12:04:03Z,2019-06-11T12:09:03Z,2019-06-18T13:05:24Z,MERGED,True,6,4,1,https://github.com/vtraag,Corrected doc: no refinement in leading eigenvector,8,[],https://github.com/igraph/igraph/pull/1207,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1207#issuecomment-500811488,Fixes #831.,"Sorry, fixes #831, not #830.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1209,2019-06-11T19:41:35Z,2019-06-12T08:00:43Z,2019-06-18T13:03:50Z,MERGED,True,36,20,2,https://github.com/vtraag,Correction of improved numerical stability for closeness,14,[],https://github.com/igraph/igraph/pull/1209,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1209,"This is the correction for the closeness that was found to be incorrect in the earlier fix in PR
#1199.
The provided example now provides the expected results.
@ntamas, I tried to run the python-igraph tests locally, but I run into an unrelated error
testRandomWalkStuck (igraph.test.walks.RandomWalkTests) ... Segmentation fault (core dumped)

I'm investigating this currently. Perhaps you can run the python tests for this PR to check the closeness calculations?","This is the correction for the closeness that was found to be incorrect in the earlier fix in PR
#1199.
The provided example now provides the expected results.
@ntamas, I tried to run the python-igraph tests locally, but I run into an unrelated error
testRandomWalkStuck (igraph.test.walks.RandomWalkTests) ... Segmentation fault (core dumped)

I'm investigating this currently. Perhaps you can run the python tests for this PR to check the closeness calculations?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1209,2019-06-11T19:41:35Z,2019-06-12T08:00:43Z,2019-06-18T13:03:50Z,MERGED,True,36,20,2,https://github.com/vtraag,Correction of improved numerical stability for closeness,14,[],https://github.com/igraph/igraph/pull/1209,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1209#issuecomment-501012246,"This is the correction for the closeness that was found to be incorrect in the earlier fix in PR
#1199.
The provided example now provides the expected results.
@ntamas, I tried to run the python-igraph tests locally, but I run into an unrelated error
testRandomWalkStuck (igraph.test.walks.RandomWalkTests) ... Segmentation fault (core dumped)

I'm investigating this currently. Perhaps you can run the python tests for this PR to check the closeness calculations?","Thanks for the quick fix Vincent! The Mathematica interface tests all pass now, but I have not yet had time to understand that changed in this PR (or the original one for the same issue).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1209,2019-06-11T19:41:35Z,2019-06-12T08:00:43Z,2019-06-18T13:03:50Z,MERGED,True,36,20,2,https://github.com/vtraag,Correction of improved numerical stability for closeness,14,[],https://github.com/igraph/igraph/pull/1209,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1209#issuecomment-501146858,"This is the correction for the closeness that was found to be incorrect in the earlier fix in PR
#1199.
The provided example now provides the expected results.
@ntamas, I tried to run the python-igraph tests locally, but I run into an unrelated error
testRandomWalkStuck (igraph.test.walks.RandomWalkTests) ... Segmentation fault (core dumped)

I'm investigating this currently. Perhaps you can run the python tests for this PR to check the closeness calculations?","The original problem was the following. The problem is similar for igraph_i_betweenness_estimate_weighted, igraph_i_edge_betweenness_estimate_weighted and igraph_i_closeness_estimate_weighted, but I'll explain what happened in igraph_i_betweenness_estimate_weighted. The igraph_2wheap_t Q contains a (two way) heap, which has at its top the node at the shortest distance of source. This heap was maintained at a zero-based distance, i.e. the source was pushed to the heap at distance 0:

  
    
      igraph/src/centrality.c
    
    
         Line 1632
      in
      9bb8167
    
  
  
    

        
          
           igraph_2wheap_push_with_index(&Q, source, 0); 
        
    
  


At the same time, the distance to all nodes is maintained in the vector dist, which used a one-based distance

  
    
      igraph/src/centrality.c
    
    
         Line 1633
      in
      9bb8167
    
  
  
    

        
          
           VECTOR(dist)[source]=1.0; 
        
    
  


In other words, the distance maintained in the heap Q and the vector dist always differed 1.0. They were therefore compared as follows:

  
    
      igraph/src/centrality.c
    
    
         Line 1659
      in
      9bb8167
    
  
  
    

        
          
           cmp_result = igraph_cmp_epsilon(altdist, curdist-1, eps); 
        
    
  


where altdist is heap-based (i.e. starting at 0) and curdist is vector based (i.e. starting at 1). This is used to decide whether the current distance (curdist) is the shortest or whether the alternative distance (altdist) is actually shorter.
The problem now is that the relative ordering of the heap compares floats around 0, while the decision of whether the current distance (curdist) is the shortest, only happens after adding and extracting 1. In general (x + 1) - 1 != x due to limited floating point accuracy, and so this leads to numerical problems, where the relative ordering in the heap is inconsistent with the comparison in

  
    
      igraph/src/centrality.c
    
    
         Line 1659
      in
      9bb8167
    
  
  
    

        
          
           cmp_result = igraph_cmp_epsilon(altdist, curdist-1, eps); 
        
    
  


Finally, this resulted in an attempt to update the heap in

  
    
      igraph/src/centrality.c
    
    
         Line 1679
      in
      9bb8167
    
  
  
    

        
          
           IGRAPH_CHECK(igraph_2wheap_modify(&Q, to, -altdist)); 
        
    
  


while it was actually already popped from the heap in

  
    
      igraph/src/centrality.c
    
    
         Line 1638
      in
      9bb8167
    
  
  
    

        
          
           igraph_real_t mindist=-igraph_2wheap_delete_max(&Q); 
        
    
  


My solution is to maintain the heap also at a one-based distance, which solves the numerical comparisons. Of course, the accuracy is still limited, but the relative ordering of distances in the heap and the vector is identical.
Finally, the problem with closeness was quite simple. It actually used the zero-based distance from the heap for its calculations

  
    
      igraph/src/centrality.c
    
    
         Line 2581
      in
      9bb8167
    
  
  
    

        
          
           VECTOR(*res)[i] += mindist; 
        
    
  


and also for doing the cutoff comparison

  
    
      igraph/src/centrality.c
    
    
         Line 2584
      in
      9bb8167
    
  
  
    

        
          
           if (cutoff>0 && mindist>=cutoff) continue;    /* NOT break!!! */ 
        
    
  


These were handled differently in igraph_i_betweenness_estimate_weighted and igraph_i_edge_betweenness_estimate_weighted, so I didn't check it. This caused the problem you noticed.
In fact, the code can be cleaned up a little bit more, but I thought it better to keep the edits to a minimum.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1209,2019-06-11T19:41:35Z,2019-06-12T08:00:43Z,2019-06-18T13:03:50Z,MERGED,True,36,20,2,https://github.com/vtraag,Correction of improved numerical stability for closeness,14,[],https://github.com/igraph/igraph/pull/1209,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1209#issuecomment-501168766,"This is the correction for the closeness that was found to be incorrect in the earlier fix in PR
#1199.
The provided example now provides the expected results.
@ntamas, I tried to run the python-igraph tests locally, but I run into an unrelated error
testRandomWalkStuck (igraph.test.walks.RandomWalkTests) ... Segmentation fault (core dumped)

I'm investigating this currently. Perhaps you can run the python tests for this PR to check the closeness calculations?",Python tests are OK as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1210,2019-06-18T13:50:35Z,2019-06-18T13:53:05Z,2020-02-06T09:08:53Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR (part 2),16,[],https://github.com/igraph/igraph/pull/1210,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1210,Continuation of #1205.,Continuation of #1205.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1210,2019-06-18T13:50:35Z,2019-06-18T13:53:05Z,2020-02-06T09:08:53Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR (part 2),16,[],https://github.com/igraph/igraph/pull/1210,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1210#issuecomment-503145260,Continuation of #1205.,"Hmmm, okay, this one cannot be rebased due to conflicts so I'll just create a merge commit to preserve authorship.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1210,2019-06-18T13:50:35Z,2019-06-18T13:53:05Z,2020-02-06T09:08:53Z,MERGED,True,21,12,3,https://github.com/vtraag,Correct numerical issues in SIR (part 2),16,[],https://github.com/igraph/igraph/pull/1210,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1210#issuecomment-503146004,Continuation of #1205.,"Yeah, I believe parts of the changes were already in the master branch again? I tried to rebase in a new branch, but then it only some minor changes compared to what was already in the master branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1214,2019-07-10T14:00:55Z,2019-07-10T20:13:32Z,2019-07-12T09:39:49Z,MERGED,True,835,783,3,https://github.com/vtraag,Corrected average nearest neighbour (direction and weights),5,[],https://github.com/igraph/igraph/pull/1214,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1214,"This should fix #643 about the directionality and fix #987 and #1051 about the weights.
You can now specify the direction (IGRAPH_IN, IGRAPH_OUT, IGRAPH_ALL) for which neighbours to consider and the direction for which degree of the neighbours to average over.
The weighted version now respects the definition provided by Barrat et. al, Eq. (6).","This should fix #643 about the directionality and fix #987 and #1051 about the weights.
You can now specify the direction (IGRAPH_IN, IGRAPH_OUT, IGRAPH_ALL) for which neighbours to consider and the direction for which degree of the neighbours to average over.
The weighted version now respects the definition provided by Barrat et. al, Eq. (6).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1214,2019-07-10T14:00:55Z,2019-07-10T20:13:32Z,2019-07-12T09:39:49Z,MERGED,True,835,783,3,https://github.com/vtraag,Corrected average nearest neighbour (direction and weights),5,[],https://github.com/igraph/igraph/pull/1214,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1214#issuecomment-510211264,"This should fix #643 about the directionality and fix #987 and #1051 about the weights.
You can now specify the direction (IGRAPH_IN, IGRAPH_OUT, IGRAPH_ALL) for which neighbours to consider and the direction for which degree of the neighbours to average over.
The weighted version now respects the definition provided by Barrat et. al, Eq. (6).",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1215,2019-07-15T23:53:57Z,2019-08-16T18:02:24Z,2019-08-16T18:02:24Z,MERGED,True,250,61,4,https://github.com/iosonofabio,Reingold Tilford layout and directed graphs,16,[],https://github.com/igraph/igraph/pull/1215,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1215,"DO NOT MERGE YET!
Trying to address #670 for layouting tree-style directed graphs. The current implementation, which needs a bit of testing, addresses the issue of unreachable nodes within weakly connected components by adding directed nodes from each root to each unreachable node within that component. Better than nothing for 0.8 - and we can brainstorm a bit to improve it in 0.9 if we have time.
Will let you know when this needs serious assessment for merging.","DO NOT MERGE YET!
Trying to address #670 for layouting tree-style directed graphs. The current implementation, which needs a bit of testing, addresses the issue of unreachable nodes within weakly connected components by adding directed nodes from each root to each unreachable node within that component. Better than nothing for 0.8 - and we can brainstorm a bit to improve it in 0.9 if we have time.
Will let you know when this needs serious assessment for merging.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1215,2019-07-15T23:53:57Z,2019-08-16T18:02:24Z,2019-08-16T18:02:24Z,MERGED,True,250,61,4,https://github.com/iosonofabio,Reingold Tilford layout and directed graphs,16,[],https://github.com/igraph/igraph/pull/1215,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1215#issuecomment-512154119,"DO NOT MERGE YET!
Trying to address #670 for layouting tree-style directed graphs. The current implementation, which needs a bit of testing, addresses the issue of unreachable nodes within weakly connected components by adding directed nodes from each root to each unreachable node within that component. Better than nothing for 0.8 - and we can brainstorm a bit to improve it in 0.9 if we have time.
Will let you know when this needs serious assessment for merging.","Sorry, I don't have further time to look at this now, but I just noticed one problem. I'll try to take another look at some later point.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1215,2019-07-15T23:53:57Z,2019-08-16T18:02:24Z,2019-08-16T18:02:24Z,MERGED,True,250,61,4,https://github.com/iosonofabio,Reingold Tilford layout and directed graphs,16,[],https://github.com/igraph/igraph/pull/1215,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1215#issuecomment-522051208,"DO NOT MERGE YET!
Trying to address #670 for layouting tree-style directed graphs. The current implementation, which needs a bit of testing, addresses the issue of unreachable nodes within weakly connected components by adding directed nodes from each root to each unreachable node within that component. Better than nothing for 0.8 - and we can brainstorm a bit to improve it in 0.9 if we have time.
Will let you know when this needs serious assessment for merging.","thank you Vincent, good catch. I think we can merge now",True,{}
igraph/igraph,https://github.com/igraph/igraph,1216,2019-07-16T19:57:46Z,2019-07-17T13:47:26Z,2020-02-06T09:20:51Z,MERGED,True,6,2,1,https://github.com/vtraag,Restricted minimum size separators to undirected graphs.,1,[],https://github.com/igraph/igraph/pull/1216,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1216,"This concerns #992, but it does not solve the underlying issue. It only includes an update to the documentation and I've added a check for whether the graph is directed or not.","This concerns #992, but it does not solve the underlying issue. It only includes an update to the documentation and I've added a check for whether the graph is directed or not.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1217,2019-07-16T20:14:37Z,2019-07-17T13:53:22Z,2020-02-06T09:20:31Z,MERGED,True,14,2,1,https://github.com/vtraag,Checking for undirected simple graphs in transitivity.,1,[],https://github.com/igraph/igraph/pull/1217,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1217,This closes #907 by simply enforcing that graphs should be simple and undirected. This is now also reflected in the documentation.,This closes #907 by simply enforcing that graphs should be simple and undirected. This is now also reflected in the documentation.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1222,2019-07-23T13:17:59Z,2019-07-23T23:42:01Z,2020-01-29T09:06:35Z,MERGED,True,54,26,3,https://github.com/szhorvat,Prufer speedup,2,[],https://github.com/igraph/igraph/pull/1222,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1222,"Fixes #1221
Also includes a new test to verify that empty Prüfer sequences can be handled.","Fixes #1221
Also includes a new test to verify that empty Prüfer sequences can be handled.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1225,2019-08-07T14:25:49Z,2019-08-17T09:17:39Z,2020-02-06T09:08:46Z,MERGED,True,71,2,3,https://github.com/vtraag,Corrected all s-t cuts,2,[],https://github.com/igraph/igraph/pull/1225,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1225,"This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.","This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1225,2019-08-07T14:25:49Z,2019-08-17T09:17:39Z,2020-02-06T09:08:46Z,MERGED,True,71,2,3,https://github.com/vtraag,Corrected all s-t cuts,2,[],https://github.com/igraph/igraph/pull/1225,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1225#issuecomment-520716416,"This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.","OK, I believe the same problem doesn't play a role in igraph_i_all_st_mincuts_pivot, it was only a bug in igraph_i_all_st_cuts_pivot. As far as I'm concerned we can merge it, but perhaps @szhorvat wants to weigh in still?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1225,2019-08-07T14:25:49Z,2019-08-17T09:17:39Z,2020-02-06T09:08:46Z,MERGED,True,71,2,3,https://github.com/vtraag,Corrected all s-t cuts,2,[],https://github.com/igraph/igraph/pull/1225,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1225#issuecomment-520716635,"This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.",I absolutely do. It's been an extremely busy time. Please give me a day or two and I'll give feedback.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1225,2019-08-07T14:25:49Z,2019-08-17T09:17:39Z,2020-02-06T09:08:46Z,MERGED,True,71,2,3,https://github.com/vtraag,Corrected all s-t cuts,2,[],https://github.com/igraph/igraph/pull/1225,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1225#issuecomment-522213622,"This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.","I tried to test it extensively and find the corner cases, and it works well.
There is one minor thing that's unclear (and unrelated to the changes you made):
When the two given vertices are already disconnected, sometimes the function returns zero cuts, and sometimes it returns one empty cut. It's not clear to me why this is happening.
Take e.g. this graph:

For s=2, t=4 I get {{}} as a result, i.e. one cut of size zero.  For s=3, t=1 I get {}, i.e. no cuts.  I don't see why the result shouldn't be the same in both cases.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1225,2019-08-07T14:25:49Z,2019-08-17T09:17:39Z,2020-02-06T09:08:46Z,MERGED,True,71,2,3,https://github.com/vtraag,Corrected all s-t cuts,2,[],https://github.com/igraph/igraph/pull/1225,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1225#issuecomment-522213678,"This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.",My suggestion is that we merge this now and I open a new issue for the small problem I described above. @vtraag do you agree or will you look into this problem before merging?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1225,2019-08-07T14:25:49Z,2019-08-17T09:17:39Z,2020-02-06T09:08:46Z,MERGED,True,71,2,3,https://github.com/vtraag,Corrected all s-t cuts,2,[],https://github.com/igraph/igraph/pull/1225,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1225#issuecomment-522220338,"This should fix #1102. The problem was that some vertices were not relabeled while working on a subgraph. I've also added tests to demonstrate that it functions correctly, I believe.
Potentially a similar problem plays also in some of the other _pivot functions, I'll have to check. Please wait until I've done so. I just wanted to share this, so that you can check whether this solution works.",Thanks for the careful check! I agree that is is best to merge this and open another issue for the other problem you identified.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1226,2019-08-09T06:36:34Z,2019-08-13T07:22:14Z,2020-02-06T09:21:22Z,MERGED,True,13,2,1,https://github.com/vtraag,Limited maximum cardinality search to undirected simple graphs.,2,[],https://github.com/igraph/igraph/pull/1226,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1226,"This partially fixes #1029, that is, it ensures that only undirected simple graphs are accepted as input. The underlying problem itself should still be addressed, but this should then be done for 0.9.0.","This partially fixes #1029, that is, it ensures that only undirected simple graphs are accepted as input. The underlying problem itself should still be addressed, but this should then be done for 0.9.0.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1226,2019-08-09T06:36:34Z,2019-08-13T07:22:14Z,2020-02-06T09:21:22Z,MERGED,True,13,2,1,https://github.com/vtraag,Limited maximum cardinality search to undirected simple graphs.,2,[],https://github.com/igraph/igraph/pull/1226,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1226#issuecomment-519935738,"This partially fixes #1029, that is, it ensures that only undirected simple graphs are accepted as input. The underlying problem itself should still be addressed, but this should then be done for 0.9.0.",Breaks the build on Windows + Python 2.7 because long int v is declared after the block you have inserted. Move the declaration of long int v above your block and it should be okay.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1226,2019-08-09T06:36:34Z,2019-08-13T07:22:14Z,2020-02-06T09:21:22Z,MERGED,True,13,2,1,https://github.com/vtraag,Limited maximum cardinality search to undirected simple graphs.,2,[],https://github.com/igraph/igraph/pull/1226,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1226#issuecomment-520720331,"This partially fixes #1029, that is, it ensures that only undirected simple graphs are accepted as input. The underlying problem itself should still be addressed, but this should then be done for 0.9.0.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1227,2019-08-09T14:01:29Z,2019-08-25T19:33:22Z,2020-02-06T09:21:39Z,MERGED,True,78,6,2,https://github.com/vtraag,Handle incorrect types supplied to bipartite matching.,2,[],https://github.com/igraph/igraph/pull/1227,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1227,"This fixes #1110, by checking whether the graph is correctly bipartite with the supplied labelling. The check is done while performing the matching, instead of checking whether the types are correct beforehand.
I now just realise that this solution goes against our philosophy of doing checks in internal functions (i.e. #1219). Perhaps we should then do a check before passing over to the internal function? The standard is_bipartite is not usable, because it actually finds the correct types (if possible), instead of checking whether the supplied types are valid. Perhaps we should then create a is_valid_bipartite function instead, to check whether the supplied types are valid?","This fixes #1110, by checking whether the graph is correctly bipartite with the supplied labelling. The check is done while performing the matching, instead of checking whether the types are correct beforehand.
I now just realise that this solution goes against our philosophy of doing checks in internal functions (i.e. #1219). Perhaps we should then do a check before passing over to the internal function? The standard is_bipartite is not usable, because it actually finds the correct types (if possible), instead of checking whether the supplied types are valid. Perhaps we should then create a is_valid_bipartite function instead, to check whether the supplied types are valid?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1227,2019-08-09T14:01:29Z,2019-08-25T19:33:22Z,2020-02-06T09:21:39Z,MERGED,True,78,6,2,https://github.com/vtraag,Handle incorrect types supplied to bipartite matching.,2,[],https://github.com/igraph/igraph/pull/1227,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1227#issuecomment-520728716,"This fixes #1110, by checking whether the graph is correctly bipartite with the supplied labelling. The check is done while performing the matching, instead of checking whether the types are correct beforehand.
I now just realise that this solution goes against our philosophy of doing checks in internal functions (i.e. #1219). Perhaps we should then do a check before passing over to the internal function? The standard is_bipartite is not usable, because it actually finds the correct types (if possible), instead of checking whether the supplied types are valid. Perhaps we should then create a is_valid_bipartite function instead, to check whether the supplied types are valid?","The build for Python 3.7 (PYTHON_VERSION=NONE) fails when doing a test for random sampling from consecutive sequence. This seems unrelated to this PR. Any idea why it fails, and what could be the cause? I haven't seen it fail in other PRs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1227,2019-08-09T14:01:29Z,2019-08-25T19:33:22Z,2020-02-06T09:21:39Z,MERGED,True,78,6,2,https://github.com/vtraag,Handle incorrect types supplied to bipartite matching.,2,[],https://github.com/igraph/igraph/pull/1227,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1227#issuecomment-524657349,"This fixes #1110, by checking whether the graph is correctly bipartite with the supplied labelling. The check is done while performing the matching, instead of checking whether the types are correct beforehand.
I now just realise that this solution goes against our philosophy of doing checks in internal functions (i.e. #1219). Perhaps we should then do a check before passing over to the internal function? The standard is_bipartite is not usable, because it actually finds the correct types (if possible), instead of checking whether the supplied types are valid. Perhaps we should then create a is_valid_bipartite function instead, to check whether the supplied types are valid?",I think it's okay this way; checking for bipartiteness has nearly zero overhead in this case so I don't mind a bit of extra safety.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1229,2019-08-13T08:36:01Z,2019-08-14T12:33:12Z,2019-08-14T13:02:35Z,MERGED,True,10,6,1,https://github.com/vtraag,Limited warning when disconnected graph has actually been discovered.,2,[],https://github.com/igraph/igraph/pull/1229,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1229,"This fixes #1197, by only issuing a warning when it is actually discovered that a graph is disconnected. So, if cutoff > 0 , but we still failed to find all nodes within the cutoff, it will issue the warning. If we fail to find all the nodes, but we have reached the cutoff, no warning will be issued.","This fixes #1197, by only issuing a warning when it is actually discovered that a graph is disconnected. So, if cutoff > 0 , but we still failed to find all nodes within the cutoff, it will issue the warning. If we fail to find all the nodes, but we have reached the cutoff, no warning will be issued.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1230,2019-08-14T13:08:40Z,2019-08-14T15:42:14Z,2019-08-14T17:26:17Z,MERGED,True,1,1,1,https://github.com/vtraag,Properly renamed the Python3.7 build environment.,1,[],https://github.com/igraph/igraph/pull/1230,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1230,Closes #1228.,Closes #1228.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1231,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1231#issuecomment-521311476,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!",Can you post the error here? I don't have the full DocBook toolchain on my machine yet but it would be nice to see it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1231#issuecomment-521343310,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","Here is the output of make info:
$ make info
if [ ""x.."" != ""x.."" ]; then cp ../doc/fdl.xml ../doc/gpl.xml ../doc/installation.xml ../doc/introduction.xml ../doc/tutorial.xml ../doc/licenses.xml ../doc/pmt.xml . ; fi && \
cat tutorial.xml | sed '/<link/{N;s/<link\n*[^>]*>//g;}' | \
  sed 's/<\/link>//g' >tutorial-info.xml \
&& sed 's/tutorial\.xml/tutorial-info.xml/' igraph-docs.xml > igraph-docs-info.xml \
&& xmllint --xinclude -o igraph-docs-info2.xml igraph-docs-info.xml \
&& ../tools/removeexamples.py igraph-docs-info2.xml igraph-docs-info3.xml \
&& sed '/<book/q' igraph-docs-info2.xml | grep -v '<book' >igraph-docs-info4.xml\
&& cat igraph-docs-info3.xml >> igraph-docs-info4.xml \
&& db2x_xsltproc --xinclude -s texi igraph-docs-info4.xml -o igraph.txml \
&& db2x_texixml igraph.txml \
&& mv igraph_reference_manual.texi igraph.texi \
&& makeinfo --no-split --number-sections igraph.texi \
&& mv igraph_reference_manual.info igraph.info \
&& patch <../doc/igraph.info.diff
docbook2texi://book[@id='index']: no description for directory entry
/usr/bin/iconv: illegal input sequence at position 445009
/usr/bin/db2x_texixml: program in pipeline exited with an error
make: *** [Makefile:683: igraph.info] Error 1

The problem is in db2x_texixml igraph.txml. The problematic line is
Patric R. J. Östergård, <uref url=""http://users.aalto.fi/~pat/cliquer.html"">http://users.aalto.fi/~pat/cliquer.html</uref>

and the problematic character is å of this line. Changing that manually to an ordinary a everywhere solves the immediate issue, but the problem is of course how to deal with this correctly. In igraph-docs-info4.xml this line reads
Patric R. J. &#214;sterg&#229;rd, <ulink url=""http://users.aalto.fi/~pat/cliquer.html"">http://users.aalto.fi/~pat/cliquer.html</ulink>

so the HTML character codes are translated to utf8 by db2x_xsltproc. However, I don't understand why Ö is not problematic, while å is.  Both are proper utf8 characters I believe.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1231#issuecomment-521607858,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","Okay, I think the problem is not that db2x_texixml does not understand what the input is; it knows the input perfectly fine. The problem is that db2x_texixml tries to convert the input to us-ascii in order to produce the output file; see the documentation here, in particular the default value of the --encoding switch, which is us-ascii. We could try --encoding=utf-8, or --encoding=us-ascii//TRANSLIT and see how it goes (accepting the fact that utf-8 encoded Texinfo documents might not be readable on systems without proper UTF-8 support).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1231#issuecomment-521937148,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","That indeed solves the issue. I still don't fully understand why it only complains about some utf8 characters, and not all. Anyway, it should be solved now, thanks!
I had to change a bit the setup, because the version would actually appear in the filename, while making the info document, which is inconvenient. I also had to change some other things for the inclusion of the version number in the info document.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1231#issuecomment-521997694,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","Okay, great! Is this ready to merge now?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1231#issuecomment-522020676,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","Good question. I think it should be fine for now. I believe the idea is to change the documentation system anyhow a bit (#1188), but perhaps @iosonofabio wants to weigh in on this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1231#issuecomment-529191468,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","Right now it looks like this:

Two questions:


There's a version inbetween the author list and legal notice, and one within the legal notice. Do we need to include the version note specifically in the legal notice? If yes, perhaps it should be in its own paragraph. In the HTML source is written on a separate line, but HTML doesn't care about lines—it will be rendered as a single paragraph.


The version info between the author list and the legal notice is not aligned correctly. If this is where we will put it, an extra entry is needed in style.css.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1231#issuecomment-572141540,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","I left the version both on its own and inside the legal notice. It is now on separate lines though. That way, the version is separately identified as releaseinfo of the docbook (which may be useful in some regard), but it is also explicitly in the release info.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1231,2019-08-14T15:06:58Z,2020-01-12T19:53:33Z,2020-01-20T00:15:35Z,MERGED,True,44,24,4,https://github.com/vtraag,Versioning documentation,7,[],https://github.com/igraph/igraph/pull/1231,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1231#issuecomment-573450447,"This is my attempt to fix #279. It correctly generates html using make html inside the doc directory.
However, there seem to be some problems with some character encodings. In particular, during make info, there is a problem with the ü from Prüfer and the å from Östergård. I managed to fix one error I got (during the parsing of the XML by tools/removeexamples.py) by adding appropriate entity definitions in igraph-docs.xxml. It then still runs into an error when running db2x_texixml. Unfortunately, I don't know what the problem exactly is.
Suggestions are welcome!","That indeed solves the issue. I still don't fully understand why it only complains about some utf8 characters, and not all.

Finally tracked this down -- it is because doc/igraph-docs.xml lists a few entities (that we have used in the past) in the header of the document so docbook ""knows"" these. If you start using other HTML entities, then you need to add them to the top of doc/igraph-docs.xml and it will be okay.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1232,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1232#issuecomment-521998736,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1232#issuecomment-522045432,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Due to the API change, the Python interface needs an update too now (ran into this when installing python-igraph for someone today).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1232#issuecomment-522079909,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Yes, this is also why we should move to using the C core as a submodule in python-igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1232#issuecomment-522100416,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Hmmm, I think we use submodules now in python-igraph so it should be pinned at the revision that was the head of master when I switched to submodules. This commit should not be part of the build.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1232#issuecomment-522102712,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Yes, you are right of course. Perhaps @szhorvat still had an old commit from the python-igraph master branch?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1232#issuecomment-522102949,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"...or he did not run git submodule update --init, in which case we probably still fall back to the old methods of finding the C core of igraph (pkg-config et al).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1232#issuecomment-522106279,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Ah yes, good point, that might also be a possibility. Any reason why you prefer to keep that method of installation in?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1232#issuecomment-522109591,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Because running pip install python-igraph should work even if the user does not have git on his system. Right now this would download the source code of python-igraph from the Python Package Index and run python setup.py install on it, no submodule initialization or anything like that. (We cannot even expect the user to have git installed on his system). Yes, this could break if the user does have some kind of an igraph version on his system but it does not match the one required for python-igraph; however, in the long run I would like to have pre-built Python wheels for all platforms so pip install python-igraph would fall back to running python setup.py install on the source code only if the user has some kind of an obscure Python installation, in which case we would be screwed anyway :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1232#issuecomment-522113473,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,Fair enough!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1232#issuecomment-522257176,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"Yes, this was my fault, I explicitly downloaded the dev version of the C core using the instructions here. I was under time pressure to install a Python 3 compatible version for a summer school student, and I am not yet used to working with the dev version of python-igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/iosonofabio,12,https://github.com/igraph/igraph/pull/1232#issuecomment-522753957,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"hi all,
this PR has been merged, which breaks python-igraph because of the API change. I now opened a PR in python-igraph to fix this by an optional argument in Python: igraph/python-igraph#239",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1232#issuecomment-522755701,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"That's great, I'll merge it soon. However, this probably means that the build process in Travis is not using the git submodule yet; instead of that, it tries to check out the master revision of the C code and link with that. We should clean this up in the Travis CI spec such that it simply runs git submodule update --init instead of getting the C core from elsewhere.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/iosonofabio,14,https://github.com/igraph/igraph/pull/1232#issuecomment-522756726,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"I'll go through the CI stuff anyway since we have to adapt it to produce artifacts for conda, pip, etc etc. so I'll clean up this aspect as well",True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1232#issuecomment-522758846,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,Note that conda-forge feedstocks for python-igraph and igraph already exist.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/iosonofabio,16,https://github.com/igraph/igraph/pull/1232#issuecomment-522776367,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,hmm ok that looks useful,True,{}
igraph/igraph,https://github.com/igraph/igraph,1232,2019-08-16T09:36:40Z,2019-08-16T12:53:11Z,2020-08-31T22:41:14Z,MERGED,True,108,10,5,https://github.com/vtraag,Limit all simple paths to a certain cutoff.,4,[],https://github.com/igraph/igraph/pull/1232,https://github.com/stevepowell99,17,https://github.com/igraph/igraph/pull/1232#issuecomment-684080274,Fixes #774. Changes the public API by introducing additional cutoff argument. Providing a negative cutoff generates all simple paths.,"hi, I think this is not implemented in the R package yet, is there a workaround?",True,"{'THUMBS_UP': ['https://github.com/gabora', 'https://github.com/loreabad6']}"
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1233,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.","This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1233#issuecomment-528522310,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.","Hi guys, this is a stopper for 0.8, but it seems like Vincent already make a working PR... any comments?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1233#issuecomment-528538871,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.",I commented in chat. There's an issue with the graphlet projection function. I get crashes due to double free. I have this on my TODO list and will send the feedback once I figured out what's going on.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1233#issuecomment-528544100,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.","Yes, I believe that the error was that a vector was being written to out of bounds, which lead to the memory problem. This is addressed in this PR. You found another problem @szhorvat ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1233#issuecomment-528546711,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.","Yes, I did. Please give me some time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1233#issuecomment-528549232,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.","OK, sure!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1233,2019-08-16T12:51:37Z,2019-10-24T18:23:56Z,2020-02-06T09:20:11Z,MERGED,True,13,12,1,https://github.com/vtraag,Corrected loop in graphlets,2,[],https://github.com/igraph/igraph/pull/1233,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1233#issuecomment-545959517,"This fixes #869 I believe. The error seemed to have been simply a for loop over the wrong number of items (which may have lead to some memory issues).
I also added IGRAPH_CHECK calls.
Finally, I had some trouble understanding how to properly destroy the returned cliques. It turns out that you have to call
  for (i = 0; i < igraph_vector_ptr_size(&cliques); i++)
  {
    igraph_vector_t* c = VECTOR(cliques)[i];
    igraph_vector_destroy(c);
    igraph_free(c);
  }

so, both igraph_vector_destroy and igraph_free. Perhaps this is already documented somewhere else, but I failed to find it. I therefore also made this more explicit in the documentation.","I am sorry, the problem was indeed with my code. This is good to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1234,2019-08-16T13:30:24Z,2019-08-16T14:24:03Z,2020-02-06T09:22:50Z,MERGED,True,10,5,2,https://github.com/vtraag,Included NONE again to make a non-MSVC build.,2,[],https://github.com/igraph/igraph/pull/1234,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1234,"Previously, in #1230 the python environment was renamed. However, the NONE environment was used to create an ordinary build of the source code, i.e. not using MSVC.
I just wanted to note here that MSVC builds are only necessary for a few versions, as the same MSVC compiler is used for Python 3.5, 3.6 and 3.7. Hence, it is only actually build for Python 3.5, this is correct.","Previously, in #1230 the python environment was renamed. However, the NONE environment was used to create an ordinary build of the source code, i.e. not using MSVC.
I just wanted to note here that MSVC builds are only necessary for a few versions, as the same MSVC compiler is used for Python 3.5, 3.6 and 3.7. Hence, it is only actually build for Python 3.5, this is correct.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1238,2019-08-19T16:33:31Z,2019-08-19T16:39:51Z,2019-08-19T16:39:51Z,CLOSED,False,70648,27689,1422,https://github.com/vickeykumar,latest pull,240,[],https://github.com/igraph/igraph/pull/1238,https://github.com/vickeykumar,1,https://github.com/igraph/igraph/pull/1238,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1238,2019-08-19T16:33:31Z,2019-08-19T16:39:51Z,2019-08-19T16:39:51Z,CLOSED,False,70648,27689,1422,https://github.com/vickeykumar,latest pull,240,[],https://github.com/igraph/igraph/pull/1238,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1238#issuecomment-522656995,,hmm this looks like a mistake?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1241,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1241#issuecomment-523007571,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.",Let me first check if everything is now correctly built.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1241#issuecomment-523020995,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.",Okay - feel free to rebase and merge when the builds pass.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1241#issuecomment-523145655,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","I believe it now correctly generates a source distribution by running make dist. The resulting distribution correctly builds using make and successfully completes make check.
I ran into a problem with generated expected output by some tests because there were some versioning conflicts. Running make distclean did not solve this. I believe this problem is now solved by commit f777ea7. Any comments or thoughts on this @ntamas?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1241#issuecomment-523362987,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.",Seems good to me!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1241#issuecomment-523367537,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","Footnote: running make maintainer-clean seems to delete one of the essential files in test/ that prevents one from running make check without regenerating everything with autoconf and automake. Not sure if it's a problem, and I don't even know whether this was introduced with this patch or not (I did not even know about make maintainer-clean before looking at this patch and trying to figure out what MAINTAINERCLEANFILES does).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1241#issuecomment-523399973,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","The problem I had was that somehow some old version information was retained. The expected output of dot.out, cattributes2.out and gml.out still had an old version number, whereas the compiled version would have the most recent version number. Running make check then encounters errors because of the differences in version numbers.
Running make clean or make distclean and then running ./configure && make && make check did not resolve that situation. Even removing the configure script and rerunning ./bootstrap.sh did not correct this.
Perhaps I should have run make maintainer-clean instead and then restart from ./bootstrap.sh, making commit f777ea7  unnecessary? I'll try it out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1241#issuecomment-523401471,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","Well, I don't know how it works now, but ideally, the test outputs that include the version number should be generated or updated when the user runs make dist. This way we could ensure that the distributed tarballs always contain the up-to-date test outputs that match the version number of the tarball. If the user checks out the repository, then the test outputs should either be generated by ./bootstrap.sh, or when the user runs make check.
There should also be a way for regenerating these test outputs from the command line because it could be an annoyance during development to update the test outputs manually all the time when the git commit hash changes.
Or, even better, we should get rid of the version numbers in the outputs completely or make autotest ignore them somehow :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1241#issuecomment-523404308,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","At the moment, the configure script does not seem be regenerated with a new version number if you don't run make maintainer-clean. This has also consequences for making the tarball during make dist because the tarball is named using the old version, while the new version is actually compiled. It then includes the test files that use the old version, but since the new version is actually compiled it gives a conflict when running make check from the source code in the generated tarball.
It seems that this is impossible to resolve without removing all generated files, since the version is only correctly passed on when rerunning from an entirely clean tree from scratch starting with ./bootstrap.sh. I think that running make maintainer-clean should be sufficient to clean the tree, but I am still investigating.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1241#issuecomment-523426233,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","At the moment, the configure script does not seem be regenerated with a new version number

You know, that's been bugging me forever, but I couldn't figure out how to fix it (other than with a clean start, as even a second run of ./bootstrap.sh isn't sufficient). Thanks for trying to sort this out!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1241,2019-08-20T13:10:57Z,2019-08-21T08:42:08Z,2019-08-21T13:02:44Z,MERGED,True,4,3,3,https://github.com/vtraag,Correcting make dist,3,[],https://github.com/igraph/igraph/pull/1241,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1241#issuecomment-523446959,"This fixes #1240, that is, the second problem that was noticed, the missing structural_properties_internal.h file when running make dist.","I sorted it out, see #1243. It turns out that you need to call make maintainer-clean and then start from scratch using ./bootstrap.sh.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1243,2019-08-21T13:01:53Z,2019-08-21T13:06:59Z,2019-08-21T13:11:17Z,MERGED,True,1,1,1,https://github.com/vtraag,Corrected cleaning,1,[],https://github.com/igraph/igraph/pull/1243,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1243,"This reverts commit f777ea7.
It turns out that it is not necessary to explicitly add aclocal.m4 to be removed. One has to run make maintainer-clean before regenerating all necessary files using bootstrap.sh. This correctly regenerates a configure script that is correctly versioned.","This reverts commit f777ea7.
It turns out that it is not necessary to explicitly add aclocal.m4 to be removed. One has to run make maintainer-clean before regenerating all necessary files using bootstrap.sh. This correctly regenerates a configure script that is correctly versioned.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1244,2019-08-21T14:16:49Z,2019-08-21T15:12:00Z,2019-08-21T16:07:44Z,MERGED,True,21,22,19,https://github.com/vtraag,Corrected include files,2,[],https://github.com/igraph/igraph/pull/1244,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1244,"This PR changes igraph.h so that it can be included directly in C++ without necessitating extern ""C"" (see #1242).
I have also changed the example/test files to ensure that only igraph.h is included instead of any separate headers such as igraph_sparsemat.h since they are already included in igraph.h. I also changed any non-public headers (e.g. igraph_types_internal.h) to be included using ""..."" instead of <...> to clarify the difference.","This PR changes igraph.h so that it can be included directly in C++ without necessitating extern ""C"" (see #1242).
I have also changed the example/test files to ensure that only igraph.h is included instead of any separate headers such as igraph_sparsemat.h since they are already included in igraph.h. I also changed any non-public headers (e.g. igraph_types_internal.h) to be included using ""..."" instead of <...> to clarify the difference.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1244,2019-08-21T14:16:49Z,2019-08-21T15:12:00Z,2019-08-21T16:07:44Z,MERGED,True,21,22,19,https://github.com/vtraag,Corrected include files,2,[],https://github.com/igraph/igraph/pull/1244,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1244#issuecomment-523516203,"This PR changes igraph.h so that it can be included directly in C++ without necessitating extern ""C"" (see #1242).
I have also changed the example/test files to ensure that only igraph.h is included instead of any separate headers such as igraph_sparsemat.h since they are already included in igraph.h. I also changed any non-public headers (e.g. igraph_types_internal.h) to be included using ""..."" instead of <...> to clarify the difference.","All the other igraph headers used the constructs __BEGIN_DECLS and __END_DECLS. Should we use these in the main header as well, for consistency?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1245,2019-08-21T18:02:07Z,2019-08-22T07:37:56Z,2020-02-06T09:18:21Z,MERGED,True,16,8,5,https://github.com/vtraag,Correctly ensure C++ inclusion for each separate header files,2,[],https://github.com/igraph/igraph/pull/1245,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1245,"Previously, in #1244, the entire igraph.h was enclosed in extern C to ensure that the library could be correctly included in C++ projects. However, this was not the proper way to solve the issue. The problem (in #1242) was that some include files (among others igraph_sparsemat.h) were missing __BEGIN_DECLS and __END_DECLS. This has now been corrected.","Previously, in #1244, the entire igraph.h was enclosed in extern C to ensure that the library could be correctly included in C++ projects. However, this was not the proper way to solve the issue. The problem (in #1242) was that some include files (among others igraph_sparsemat.h) were missing __BEGIN_DECLS and __END_DECLS. This has now been corrected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1248,2019-08-27T20:03:26Z,2019-09-01T19:39:27Z,2020-02-06T09:08:50Z,MERGED,True,11,6,1,https://github.com/vtraag,Corrected all s-t cuts for disconnected source-target pairs,1,[],https://github.com/igraph/igraph/pull/1248,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1248,"This fixes #1236, where incorrect results were obtained for disconnected source-target pairs.
The problem was that GammaS contained the source node by default if S is empty. However, in the paper it is (tacitly) assumed that the source and target nodes are connected, in the sense that all nodes in GammaS are contained in the nodes in the dominator tree. This created an inconsistency, which is resolved by ensuring that nodes that are not in the dominator tree are not part of GammaS.","This fixes #1236, where incorrect results were obtained for disconnected source-target pairs.
The problem was that GammaS contained the source node by default if S is empty. However, in the paper it is (tacitly) assumed that the source and target nodes are connected, in the sense that all nodes in GammaS are contained in the nodes in the dominator tree. This created an inconsistency, which is resolved by ensuring that nodes that are not in the dominator tree are not part of GammaS.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1248,2019-08-27T20:03:26Z,2019-09-01T19:39:27Z,2020-02-06T09:08:50Z,MERGED,True,11,6,1,https://github.com/vtraag,Corrected all s-t cuts for disconnected source-target pairs,1,[],https://github.com/igraph/igraph/pull/1248,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1248#issuecomment-526947176,"This fixes #1236, where incorrect results were obtained for disconnected source-target pairs.
The problem was that GammaS contained the source node by default if S is empty. However, in the paper it is (tacitly) assumed that the source and target nodes are connected, in the sense that all nodes in GammaS are contained in the nodes in the dominator tree. This created an inconsistency, which is resolved by ensuring that nodes that are not in the dominator tree are not part of GammaS.","I didn't look at the algorithm, but I did check carefully that the results are correct. I think it's good to go.
One weird thing: running my tests for this with AddressSanitizer through the Mathematica interface leaks memory badly. Without AddressSanitizer, it's fine. It may even be some bad interaction between AddressSanitizer and Mathematica—I didn't check.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1253,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.","This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1253#issuecomment-527496382,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.","I did some randomized tests on this and found a graph where the result looks strange.
Here's the edge list:
[[0, 10], [0, 17], [1, 16], [3, 18], [4, 8], [5, 2], [5, 9], [6, 1], [8, 12], [8, 19], [9, 8], [9, 16], [10, 0], [10, 6], [10, 15], [11, 8], [11, 17], [12, 13], [12, 14], [13, 9], [14, 2], [14, 18], [14, 19], [15, 0], [15, 8], [15, 18], [16, 17], [17, 19], [18, 2], [18, 15]]

Vertices are 0, 1, ..., 19.
Note that there's an isolated vertex, and that the graph is directed.
We look for cuts from 0 -> 19.
This is the result I get:

Python format:
[[[0, 10], [0, 17]],
 [[10, 15], [17, 19]],
 [[15, 8], [17, 19]],
 [[0, 10], [17, 19]],
 [[10, 15], [17, 19]],
 [[15, 8], [17, 19]]]

All returned results are correct, but the last two repeats of earlier results, which is strange.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1253#issuecomment-527502579,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.","Smaller example:

Result for cuts from 0 -> 8 is:

Notice the many duplicates.
Edge list of this graph:
[[0, 4], [0, 7], [1, 6], [2, 1], [3, 8], [4, 0], [4, 2], [4, 5], [5, 0], [5, 3], [6, 7], [7, 8]]",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1253#issuecomment-527814334,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.","I've simplified the problematic case to this

with edge list
[(0,2),  (0,4),  (1,4),  (2,1),  (2,3),  (3,0),  (3,5),  (4,5)]

It yields the cuts for source 0 and target 5:
Found 6 cuts.
Cut 0:
0 - 2
0 - 4
Partition 0: 0

Cut 1:
2 - 3
4 - 5
Partition 1: 0 2 1 4

Cut 2:
3 - 5
4 - 5
Partition 2: 0 2 1 4 3

Cut 3:
0 - 2
4 - 5
Partition 3: 0 4

Cut 4:
2 - 3
4 - 5
Partition 4: 0 4 2 1

Cut 5:
6 7
3 - 5
4 - 5
Partition 5: 0 4 2 1 3

The last two are duplicates. There should be six cuts, but the last two cuts should include edge 0-4 instead of 4-5.
I have not yet found anything that is actually going wrong, I'm investigating.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1253#issuecomment-527820920,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.","I've simplified it even further to

With source 0 and target 4 this yields the cuts:
Found 4 cuts.
Cut 0:
0 - 2
0 - 3
Partition 0: 0

Cut 1:
2 - 4
3 - 4
Partition 1: 0 2 1 3

Cut 2:
0 - 2
3 - 4
Partition 2: 0 3

Cut 3:
2 - 4
3 - 4
Partition 3: 0 3 2 1

The last cut should include edge 0-3 instead of 3-4.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1253#issuecomment-527848861,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.","I've managed to figure it out. Again, this is not really explicit in Provan & Shier (1996), but the sets S and T should be disjoint (see Lemma 2.1). Because Eq. (3.8b) simply states that Isv should include all nodes that can reach v in Sbar, this was not properly considered. Nodes that were already included in T could in this way end up in S.
Another consideration is that the actual partitions and the edges that are cut should be considered only for edges that have positive flow. This is not made explicit in Provan & Shier (1996), but otherwise you end up with edges that are cut which are not necessary. Note that when viewed as a partition, this works slightly differently. For example, in the example provided in #1253 (comment), the partition 0, 2 will generate the cut edges 0 -> 3 and 2 -> 4, which are correct, but it also includes the cut edge 2 -> 1, which should not be included because it has no positive flow (i.e. it cannot reach the target). This is now correctly handled.
Finally, the error was actually already in the test case again! The fourth test case listed the same cut twice. This is now corrected, and the cuts are printed more explicitly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1253,2019-09-03T14:37:06Z,2019-09-04T18:30:54Z,2019-09-04T19:47:54Z,MERGED,True,196,69,3,https://github.com/vtraag,Corrected all s-t mincuts,7,[],https://github.com/igraph/igraph/pull/1253,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1253#issuecomment-528027630,"This fixes #1235 I believe.
There seemed to have been two problems. In Provan & Shier (1996) there are two ingredients that seemed to have gone wrong in the implementation.

In Eq. (3.8a) effectively the target node t is excluded as a pivot element v. This was not implemented. I must admit that Eq. (3.8a) is also a bit strangely written, since only pivot elements v of indegree 0 are admitted, and so t can never reach v, hence the latter condition of (3.8a) only holds for the case that v==t.
It seemed that the following sentence was wrongly interpreted: ""After this preprocessing has been done, the set M0 can be found by successively removing vertices of indegree 0 in G3"" (p. 365). I believe the ""succesive"" here refers to the fact that we repeatedly need to find the set M0. It was now programmed to succesively remove vertices of indegree 0 for simply finding M0. I have corrected this.

Finally, it seemed that for one example included in the test, the results were actually already incorrect. Because the expected output was incorrect, this was of course not noted previously. I believe this is now also corrected.",Good to go then! Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1254,2019-09-04T16:06:13Z,2019-09-05T15:52:02Z,2020-06-13T08:25:48Z,MERGED,True,15,3,1,https://github.com/szhorvat,Limited iterruptibility for GLPK,1,[],https://github.com/igraph/igraph/pull/1254,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1254,"This adds limited interruptibility for GLPK. See glp_ios_terminate in the GLPK manual.
It is limited because:
This method can only be used for glp_intopt(). glp_intopt() may internally call glp_simplex(), which can take a very long time to complete. This stage of the processing still cannot be interrupted.","This adds limited interruptibility for GLPK. See glp_ios_terminate in the GLPK manual.
It is limited because:
This method can only be used for glp_intopt(). glp_intopt() may internally call glp_simplex(), which can take a very long time to complete. This stage of the processing still cannot be interrupted.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1256,2019-09-08T11:28:16Z,2020-01-07T16:18:48Z,2020-01-29T08:08:57Z,MERGED,True,30,32,3,https://github.com/szhorvat,Documentation: Spell check intro,1,[],https://github.com/igraph/igraph/pull/1256,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1256,"Fixed some language/spelling in the introduction to the documentation.
Removed mention of the Ruby interface, as it seems dead.
Added mention of the Mathematica interface.","Fixed some language/spelling in the introduction to the documentation.
Removed mention of the Ruby interface, as it seems dead.
Added mention of the Mathematica interface.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1256,2019-09-08T11:28:16Z,2020-01-07T16:18:48Z,2020-01-29T08:08:57Z,MERGED,True,30,32,3,https://github.com/szhorvat,Documentation: Spell check intro,1,[],https://github.com/igraph/igraph/pull/1256,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1256#issuecomment-571650782,"Fixed some language/spelling in the introduction to the documentation.
Removed mention of the Ruby interface, as it seems dead.
Added mention of the Mathematica interface.","One thing by the way is that the documentation is not compiled on the CI. Should we set this up perhaps, to ensure that documentation builds correctly?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1257,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1257#issuecomment-529329071,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Just some very quick notes without looking through it fully:

This function should return a ptr_vector_t, each element of which is a basis element, i.e. a vector_t of edge indices.
It must work for multigraphs, e.g. 1-2, 1-2, 2-3 has one cycle.
It must also handle self-loops.
It should work on directed graphs and simply ignore edge directions. One may want to use the result to create an edge-cycle matrix where 0, 1 and -1 are used to indicate whether an edge is not in a cycle, in the cycle pointing in the cycle direction, or in the cycle pointing in the reverse direction, respectively. This is a common thing to do with cycle bases.

You seem to be using some raw char * arrays for boolean vectors. We also have igraph_vector_bool_t. I did notice that an igraph_bool_t is an int, i.e. typically 32-bit instead of 8-bit. Perhaps this is why you went with the raw char array? @ntamas Can you comment on why igraph_bool_t is int and not, say, and unsigned char?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1257#issuecomment-529365237,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I have no idea; this has always been this way before I joined the development of igraph. I think we could change this easily. You could try changing the typedef of igraph_bool_t to unsigned char in the source and see if anything breaks (it shouldn't - if it does, then the point where it breaks is probably an interesting place to look at as it could uncover places where we are (ab)using an igraph_bool_t to do something else).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/gaborcsardi,4,https://github.com/igraph/igraph/pull/1257#issuecomment-529374222,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I have no idea; this has always been this way before I joined the development of igraph. I think we could change this easily. You could try changing the typedef of igraph_bool_t to unsigned char in the source and see if anything breaks

This breaks the R interface because is there a logical is an int.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1257#issuecomment-529374787,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Some more comments:
I think the following would be reasonable names / prototypes:
int igraph_fundamental_cycle_basis(const igraph_t *graph, igraph_vector_ptr_t *basis);
int igraph_minimum_cycle_basis(const igraph_t *graph, igraph_vector_ptr_t *basis, const igraph_vector_t *weights);
Alternatively, minimum_weight_cycle_basis would be more precise, but longer.

I do not think we need to include ""undirected"" in the name, as this is understood. In many applications, people would run this on directed (i.e. oriented) graphs and also want to know if each edge points along the cycle direction or opposite to it. This information could even be optionally returned by the function in an additional vector (however, it is easy enough to compute, so maybe we don't need to include it).
I do not think we need to include ""unweighted"" in the name, as weights are not relevant for bases unless we look for the minimum weight one (which is a special application). However, it is useful to indicate that it returns a fundamental basis.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1257#issuecomment-529812492,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I believe the implementation can be made more efficient in the following way.
While doing a BFS, you maintain a vector father that denotes for each node the node through which it was first visited (i.e. this corresponds to the spanning tree). Let us initially set father to -1 for all nodes, so that if father[i] < 0 it means that node i was not yet visited. In addition, we keep a vector dist which is the distance from the root vertex. Whenever you encounter a node i that was already visited (father[i] > 0) when traversing the edge j -> i, you backtrack the fathers of i and j (i.e. ancestors) until dist[i] == dist[j] and then keep iterating until the ancestors are identical. In other words:
int ancestor_i = i;
int ancestor_j = j;
while (ancestor_i != ancestor_j)
{
  if (dist[ancestor_i] > dist[ancestor_j])
    ancestor_i = father[ancestor_i];
  else if (dist[ancestor_i] < dist[ancestor_j])
    ancestor_j = father[ancestor_j];
  else
  {
    ancestor_i = father[ancestor_i];
    ancestor_j = father[ancestor_j];
  }
}
By maintaining the traversed list of ancestors, you have the list of vertices in the cycle. If ancestor_i == j you know that the cycle was directed and otherwise it is an undirected cycle (i.e. a cycle ignoring the edge directions). If you want a vector of edges instead of vertices (which is probably more useful in a multigraph) you can use edge ids instead of vertex ids to identify the father (i.e. the edge that leads to the father). Finally, for multiple components you should include a root vector that identifies from which root the node was reached. If root[i] != root[j] no cycle can be identified.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1257#issuecomment-529834535,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Thank you Vincent, you mean the BFS happens instead of my DFS in the code? Or outside of the for loop? Or we build the tree as we backtrack already?
…
On Tue, Sep 10, 2019, at 09:37, Vincent Traag wrote:
 I believe the implementation can be made more efficient in the following way.

 While doing a BFS, you maintain a vector `father` that denotes for each
 node the node through which it was first visited (i.e. this corresponds
 to the spanning tree). Let us initially set `father` to `-1` for all
 nodes, so that if `father[i] < 0` it means that node `i` was not yet
 visited. In addition, we keep a vector `dist` which is the distance
 from the root vertex. Whenever you encounter a node `i` that was
 already visited (`father[i] > 0`) when traversing the edge `j -> i`,
 you backtrack the fathers of `i` and `j` (i.e. ancestors) until
 `dist[i] == dist[j]` and then keep iterating until the ancestors are
 identical. In other words:

 int ancestor_i = i;
 int ancestor_j = j;
 while (ancestor_i != ancestor_j)
 {
   if (dist[ancestor_i] > dist[ancestor_j])
     ancestor_i = father[ancestor_i];
   else if (dist[ancestor_i] < dist[ancestor_j])
     ancestor_j = father[ancestor_j];
   else
   {
     ancestor_i = father[ancestor_i];
     ancestor_j = father[ancestor_j];
   }
 }
 By maintaining the traversed list of ancestors, you have the list of
 vertices in the cycle. If `ancestor_i == j` you know that the cycle was
 directed and otherwise it is an undirected cycle (i.e. a cycle ignoring
 the edge directions). If you want a vector of edges instead of vertices
 (which is probably more useful in a multigraph) you can use edge ids
 instead of vertex ids to identify the father (i.e. the edge that leads
 to the father). Finally, for multiple components you should include a
 `root` vector that identifies from which root the node was reached. If
 `root[i] != root[j]` no cycle can be identified.

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#1257?email_source=notifications&email_token=AAJFEADFCWHZS4PBWP6UNITQI5FCVA5CNFSM4IUVNRMKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD6KEYDA#issuecomment-529812492>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAJFEAASZ7HY3NI6VSYQPR3QI5FCVANCNFSM4IUVNRMA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1257#issuecomment-529843675,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I believe that the initial BFS that you perform is sufficient for immediately identifying the cycles, while creating the spanning tree. In other words, you identify the cycles as you are building the spanning tree in one go. You now repeatedly perform a DFS on the resulting spanning tree, but you will then repeatedly backtrack the same paths I believe (i.e. the parent variable remains essentially identical across igraph_dfs runs).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1257#issuecomment-529844143,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples",And probably you should indeed call it parent instead of father :),True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,10,https://github.com/igraph/igraph/pull/1257#issuecomment-529974458,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Sounds good, I'll get rid of those DFS loops :-)

I knew it was optimizable, but wanted to have a rough version out there to start the discussion
…
On Tue, Sep 10, 2019, at 11:03, Vincent Traag wrote:
 And probably you should indeed call it `parent` instead of `father` :)

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#1257?email_source=notifications&email_token=AAJFEAHT3FUZAXEH5FW23HLQI5PH5A5CNFSM4IUVNRMKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD6KMPLY#issuecomment-529844143>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAJFEAHIHMKG3S7WCOWHFGTQI5PH5ANCNFSM4IUVNRMA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/apps/stale,11,https://github.com/igraph/igraph/pull/1257#issuecomment-577127000,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples",This issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1257#issuecomment-577128167,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","@iosonofabio If you are still working on this, feel free to remove the wontfix label. Stalebot will also stop bothering this PR if you add the pinned label to it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/apps/stale,13,https://github.com/igraph/igraph/pull/1257#issuecomment-602186827,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,14,https://github.com/igraph/igraph/pull/1257#issuecomment-638584011,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I restarted working on this one, don't worry about the massive merge commits for now, I can squash-rebase at the end.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1257#issuecomment-638601796,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Great! I noticed you merged in develop so perhaps we should discuss whether this should go into master or develop. If my understanding is correct, this is an entirely new function, right? That means it can go into master, because it is backwards compatible. But that means that we should not bring in all the changes from the develop branch. What do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,16,https://github.com/igraph/igraph/pull/1257#issuecomment-638612382,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Good point. I'm working on the weighted graph function which is significantly more messy than the unweighted one, so I'm unclear on the time frame - not so familiar with Horton cycles I admit. There's also no urgency I believe. So maybe develop is fine? But I'm also fine rebasing against master",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/1257#issuecomment-638816566,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I'd say keep it on develop. As for me, I tend to do all development on develop now.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,18,https://github.com/igraph/igraph/pull/1257#issuecomment-640169342,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Ok, I'm sharpening the tools for this one. Some advice would be appreciated, but in terms of general approach and specific code. Two points in particular:


It seems reasonable to me to implement this algorithm: https://dl.acm.org/doi/abs/10.1145/1644015.1644023, see fig 2. Anyone objects or has a better suggestion?


I starting shaping up the code for that and it needs a bunch of auxiliary functions that might be useful beyond this particular PR, e.g. an approximate calculation of a feedback vertex set. If anyone could have a quick look at my igraph_minimum_cycle_basis (only a stub) and comment on what functions exist already and whether any of the private ones should instead be lifted to be part to the API, I'be be grateful.


Thanks!
Fabio",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,19,https://github.com/igraph/igraph/pull/1257#issuecomment-640208502,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","It seems reasonable to me to implement this algorithm: https://dl.acm.org/doi/abs/10.1145/1644015.1644023, see fig 2. Anyone objects or has a better suggestion?

I actually ran into the same publication recently. It sounded like an interesting option, although I have not yet explored the details.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/ntamas,20,https://github.com/igraph/igraph/pull/1257#issuecomment-640542951,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples",@iosonofabio igraph_feedback_arc_set() already has an algo argument that allows us to implement various heuristics for the feedback arc set problem. I think that you should add the particular approximation that you want to use there.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1257#issuecomment-640565058,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","This feedback vertex set is a bit different from what we have because it concerns undirected graphs. What we have is for directed graphs. Specifically, in undirected graphs, the feedback edge set problem is trivial (same as spanning tree) while the feedback vertex set problem is NP-complete.
Our feedback arc set functionality could use some expansion, and I do have some stuff coming for that, if I ever get to it ...
In particular, we should add a mapping between the feedback edge set (FES) and feedback vertex set (FVS) problems in directed graphs.  Solve FEP based on FVP is easy (take the line graph), the other direction not so much.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/ntamas,22,https://github.com/igraph/igraph/pull/1257#issuecomment-640578755,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Ah, sorry, my bad, I mistook feedback vertex sets for feedback edge sets.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,23,https://github.com/igraph/igraph/pull/1257#issuecomment-641707540,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Ok guys, tea time again, thank you if you have 5 minutes to answer the following:

calculating a shortest path/minimum spanning tree rooted at a specified vertex?
argsort? sorry I'm more of a Pythonista and there we just have a util function do the thing for us...

Maybe as an alternative to 2, it would be useful to have a struct here with two ints and a float. But I don't see many structs across the codebase, is that somehow discoraged? How do we manage memory for structs?
Thanks!
Fabio",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1257#issuecomment-641758621,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","not so familiar with Horton cycles I admit

Do you need a short summary of Horton's algorithm (which is relatively simple, and not inefficient), or do you want to do the one the paper you linked?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,25,https://github.com/igraph/igraph/pull/1257#issuecomment-641759741,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","I can read the paper, that's not the problem. How much difference do you think it will make in practice versus the increased complexity?
My understanding is the more recent approach does not use all vertices but just a feedback vertex set (which we have to implement separately - can default to all vertices of degree != 2 for now if I'm not wrong). Moreover it also only analyzes cycles in distinct subtrees from the root.
However this algorithm requires travelling across the trees from root to leaves, which is more difficult than the other way (just storing a parent vector). That's what I'm wondering right now, i.e. what an efficient data type would be for that purpose.
Wait, I should just look a little longer. Seems like the minimum spanning tree prim function uses a vector of edges to store the tree, we can do the same here. Then we can travel from root to children relatively easily.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,26,https://github.com/igraph/igraph/pull/1257#issuecomment-641841169,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","2\. argsort?


If you do need this is practice, I think it would make a great contribution to the igraph_vector* types. It would probably be good to make this a public implementation then.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,27,https://github.com/igraph/igraph/pull/1257#issuecomment-642490052,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Thanks @szhorvat . At this stage I'm not fixing memory leaks and similar stuff, but thanks.
I haven't seen any comments on the general strategy, I'm just pushing ahead then. I'll come back to the nitty gritty details once the core of the algorithm is implemented 👍",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/szhorvat,28,https://github.com/igraph/igraph/pull/1257#issuecomment-642497621,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","@iosonofabio Is the fundamental cycles part considered to be ready now?
For the minimum cycle basis, I am familiar with Horton's algorithm, which is simple:

find fundamental cycles corresponding to a BFS tree starting from each vertex
order the entire group of cycles by weight
starting from the smallest, use Gaussian elimination to find a linearly independent set which is a basis

I am not familiar with the paper you linked. I'd need to look at it in detail to comment, which would take a few hours. I need to force myself off igraph for now, so I can make progress on other projects ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,29,https://github.com/igraph/igraph/pull/1257#issuecomment-642498738,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","Fantastic @szhorvat , thanks for the recap. The paper is an incremental improvement over that. Don't worry too much about this one, it'll take me a few more days ;-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/vtraag,30,https://github.com/igraph/igraph/pull/1257#issuecomment-652401212,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","FYI, I just came across igraph_vector_order (and it siblings igraph_vector_order1 and igraph_vector_order1_int), which essentially provide an argsort of a vector. This really shows that we should make these functions public and provide decent documentation for them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1257,2019-09-09T00:30:06Z,2021-04-19T05:43:11Z,2021-04-19T05:43:11Z,CLOSED,False,900,2,4,https://github.com/iosonofabio,Cycle basis,22,['todo'],https://github.com/igraph/igraph/pull/1257,https://github.com/iosonofabio,31,https://github.com/igraph/igraph/pull/1257#issuecomment-822184138,"DO NOT MERGE YET!
Trying to implement functions for finding a cycle basis:

starting from undirected, unweighted graphs
undirected, weighted graphs in progress

Final TODO before merging:

 finish implementation
 rebase onto most recent develop branch
 check for memory leaks
 special checks for igraph_vector_ptr since current convention is shaky
 convert tabs to spaces
 check docs
 check tests
 add 1-2 examples","This one is also not urgent, esp. since @szhorvat has implemented a similar algorithm. Closing for now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1259,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1259#issuecomment-537393710,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","I believe I covered everything that I wanted to cover.
I decided not to implement a ""simpler"" interface, this could be easily done in any interface implementing the Leiden algorithm. The node_weight should be set to the degree to optimize modularity (or the strenght in the case of weights), and the resolution_parameter divided by 2m. This is also explained in the documentation.
@szhorvat, feel free to do some further checking.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1259#issuecomment-537394928,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Sorry, one more thing to do, I still have to ensure that the documentation is actually compiled (in community.xxml), doing that now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1259#issuecomment-537404853,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","A general comment:
This contribution is huge. It would be better to put it in its own file to keep things more manageable.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1259#issuecomment-537406156,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","It would be better to put it in its own file to keep things more manageable.

Yes, that may be a good idea. In general, community.c is indeed quite bloated because of the large number of functions. I have no objection against including a separate source file, but it feels somewhat strange to only do this for igraph_community_leiden.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1259#issuecomment-537412555,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","but it feels somewhat strange to only do this for igraph_community_leiden.

InfoMAP is also in a separate file (possibly only because it's C++, not C).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1259#issuecomment-537415881,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","OK, I will create a new file community_leiden.c then and move all relevant functions there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1259#issuecomment-539908378,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","In the long run it would definitely be a good idea to separate the various community detection methods into their own files.
To be honest, I would even start structuring the src folder a bit based on ""topics""; e.g., all community detection functions could be placed in src/communities, all flow-related functions could be placed in src/flow, all shortest path-related functions could be placed in src/paths and so on. The smaller files we have, the better it is, and probably it also makes recompilations faster - a single change in one of the community detection algorithms won't recompile all the other algorithms.
One thing that we have to be careful about is that the filenames should be unique even if they are in different folders; I think that Visual Studio does not like having multiple files with the same name in different folders.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1259#issuecomment-539938973,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Good point about updating the overall structure! Perhaps it would be best to open a separate issue for that?
I could still move everything for this contribution to community_leiden.c but leave the rest as is.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1259#issuecomment-539942708,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Perhaps it would be best to open a separate issue for that?

I think so.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1259#issuecomment-546903466,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.",RNG_BEGIN and RNG_END should be added to the relevant parts.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1259#issuecomment-548792810,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","RNG_BEGIN and RNG_END should be added to the relevant parts.

Done",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1259#issuecomment-555325079,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Test suite fails on macOS because one of the expected output lines is
Leiden found 10 clusters using modularity, quality is -nan.

while the actual output is
Leiden found 10 clusters using modularity, quality is nan.

Maybe it's best to avoid printing nan.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1259#issuecomment-555382211,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.",...or simply use isnan() in the test case to test for nan-ness.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1259#issuecomment-555400778,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","OK, I did not know that it failed on MacOS, thanks for letting me know. We don't have a CI setup for MacOS apparently?
I will correct the test.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1259#issuecomment-555473920,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","We don't have a CI setup for MacOS apparently?

Yes, maybe we should add one on Travis, if possible.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/1259#issuecomment-555888001,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Travis now builds igraph on macOS as well. (Unfortunately I could not get it to rebuild this PR -- @vtraag, maybe you need to rebase your PR on master to make it run on macOS as well).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,18,https://github.com/igraph/igraph/pull/1259#issuecomment-555895161,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Thanks @ntamas. I've cherry picked the commit instead, rebasing would require me to force push to the PR invalidating earlier comments.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1259#issuecomment-564933589,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","@vtraag Do you have recommendations for reasonable defaults for the parameters, to be used by a high-level interface?
For beta, you recommend 0.01 as a starting point.
There was the case of using the modularity as the quality function, as described in the docs: vertex weights are chosen to be vertex strengths and resolution = 1/(2*edge_count).
Do you have any other tips/comments on automatically choosing reasonable values?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1259#issuecomment-564940882,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.",Your Python package is actually a good starting point: https://leidenalg.readthedocs.io/en/latest/reference.html#modularityvertexpartition,True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1259#issuecomment-565016813,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","As far as I'm concerned, this is good to go. @ntamas if you have no further comments either, please merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/vtraag,22,https://github.com/igraph/igraph/pull/1259#issuecomment-565091022,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","Thank you for the feedback @szhorvat !
The reasonable default for modularity is a resolution parameter of 1, since it then corresponds to the original definition.
For CPM, I prefer not to give any default resolution parameter, as it forces people to make an active choice. A reasonable range is somewhere around the average (weighted) density of the network. Whether that is most suitable for any particular network really depends on the needs and interpretations of the results by the user. The property of being a resolution-limit-free method depends on not having such a default resolution parameter (see http://arxiv.org/abs/1104.3083). This is a fine thin line, but I think it is worthwhile to stress this by not having such a default parameter in practice.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/iosonofabio,23,https://github.com/igraph/igraph/pull/1259#issuecomment-565094342,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","I've been using cpm for biology data a lot and I agree with Vincent, it really depends on the application
…
On Thu, Dec 12, 2019, at 08:53, Vincent Traag wrote:
 Thank you for the feedback @szhorvat <https://github.com/szhorvat> !

 The reasonable default for modularity is a resolution parameter of 1,
 since it then corresponds to the original definition.

 For CPM, I prefer not to give any default resolution parameter, as it
 forces people to make an active choice. A reasonable range is somewhere
 around the average (weighted) density of the network. Whether that is
 most suitable for any particular network really depends on the needs
 and interpretations of the results by the user. The property of being a
 resolution-limit-free method depends on not having such a default
 resolution parameter (see http://arxiv.org/abs/1104.3083). This is a
 fine thin line, but I think it is worthwhile to stress this by not
 having such a default parameter in practice.

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#1259?email_source=notifications&email_token=AAJFEAGDL7ZTLGNHOMPIXU3QYJUBRA5CNFSM4IXQTMI2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEGXJVTQ#issuecomment-565091022>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAJFEAF5AFWHUHMENW7NXXLQYJUBRANCNFSM4IXQTMIQ>.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/ntamas,24,https://github.com/igraph/igraph/pull/1259#issuecomment-565155913,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1259,2019-09-17T14:13:00Z,2019-12-12T19:43:28Z,2019-12-23T21:03:08Z,MERGED,True,1469,63,11,https://github.com/vtraag,Added basic implementation of Leiden algorithm.,21,[],https://github.com/igraph/igraph/pull/1259,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1259#issuecomment-568579654,"This is a basic implementation of the Leiden algorithm for community detection. It closely follows the Java implementation of the algorithm.
Any comment regarding coding style, memory management or igraph coding standards (i.e. how to best do things) is welcome.
Some things remain to be done; I believe I have included all of them below. If some todo item is missing, let me know, so that I can add it to the list. I just wanted to already share this with you so that you can already take a closer look.
Todo list:

 Add test cases.
 Add documentation.
 Add checks for correct graph types (e.g. undirected, etc...)
 Add additional interface function to use modularity / CPM more easily.
 Double check memory cleaning (also in case of IGRAPH_FINAL).
 Add IGRAPH_ALLOW_INTERRUPTION.

Please only merge after all todo items are finished.","I posted in the chat, but not sure @vtraag has seen it.
I believe that on this line:
https://github.com/igraph/igraph/blob/master/examples/tests/igraph_community_leiden.c#L61
gamma should be set to 1.0 / (2*sum_of_weights) rather than 1.0 / (2*igraph_ecount(graph)).
Of course, it's just a small test case, but it also serves as an example for people who want to use the function. It's better to have it be conceptually correct. Otherwise, it won't be equivalent to the modularity. Do you agree @vtraag ?",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1264,2019-11-18T03:56:45Z,2019-11-18T08:28:30Z,2020-01-29T09:10:26Z,MERGED,True,1,1,1,https://github.com/szhorvat,Fix phrasing of error message,1,[],https://github.com/igraph/igraph/pull/1264,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1264,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1265,2019-11-18T04:18:07Z,2019-11-18T08:25:35Z,2020-02-04T12:30:26Z,MERGED,True,6,0,1,https://github.com/szhorvat,Motifs: check size of cut probability vector,1,[],https://github.com/igraph/igraph/pull/1265,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1265,"This will check that the size of the cut probability vector is not smaller than the motif size (which, as far as I could tell, would result in an out-of-bounds access even though it never crashed for me).
For convenience reason, and also so that we do not have to modify the tests, I still allow longer cut_prob vectors than the motif size.
I opted not to check that the probabilities are all 0 <= p <= 1. Values < 0 or > 1 are effectively treated as 0 and 1, but I think they won't cause trouble.","This will check that the size of the cut probability vector is not smaller than the motif size (which, as far as I could tell, would result in an out-of-bounds access even though it never crashed for me).
For convenience reason, and also so that we do not have to modify the tests, I still allow longer cut_prob vectors than the motif size.
I opted not to check that the probabilities are all 0 <= p <= 1. Values < 0 or > 1 are effectively treated as 0 and 1, but I think they won't cause trouble.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1265,2019-11-18T04:18:07Z,2019-11-18T08:25:35Z,2020-02-04T12:30:26Z,MERGED,True,6,0,1,https://github.com/szhorvat,Motifs: check size of cut probability vector,1,[],https://github.com/igraph/igraph/pull/1265,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1265#issuecomment-554906503,"This will check that the size of the cut probability vector is not smaller than the motif size (which, as far as I could tell, would result in an out-of-bounds access even though it never crashed for me).
For convenience reason, and also so that we do not have to modify the tests, I still allow longer cut_prob vectors than the motif size.
I opted not to check that the probabilities are all 0 <= p <= 1. Values < 0 or > 1 are effectively treated as 0 and 1, but I think they won't cause trouble.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1268,2019-11-22T17:12:50Z,2019-11-23T20:43:18Z,2019-11-23T20:48:38Z,MERGED,True,140,145,5,https://github.com/luav,GCC Warnings Fixed,1,[],https://github.com/igraph/igraph/pull/1268,https://github.com/luav,1,https://github.com/igraph/igraph/pull/1268,Fix for  #1267,Fix for  #1267,True,{}
igraph/igraph,https://github.com/igraph/igraph,1268,2019-11-22T17:12:50Z,2019-11-23T20:43:18Z,2019-11-23T20:48:38Z,MERGED,True,140,145,5,https://github.com/luav,GCC Warnings Fixed,1,[],https://github.com/igraph/igraph/pull/1268,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1268#issuecomment-557792381,Fix for  #1267,"igraph_sample_sphere_volume() is defined in src/dotproduct.c and it can be used in conjunction with igraph_dot_product_game() to generate random graphs. Why is it removed?
The same question also applies to igraph_transitive_closure_dag() and igraph_rng_get_exp() - both are used elsewhere.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1268,2019-11-22T17:12:50Z,2019-11-23T20:43:18Z,2019-11-23T20:48:38Z,MERGED,True,140,145,5,https://github.com/luav,GCC Warnings Fixed,1,[],https://github.com/igraph/igraph/pull/1268,https://github.com/luav,3,https://github.com/igraph/igraph/pull/1268#issuecomment-557794034,Fix for  #1267,"@ntamas igraph_sample_sphere_volume() had subsequent duplicated declarations in the same file (include/igraph_games.h):
DECLDIR int igraph_sample_sphere_surface(igraph_integer_t dim, igraph_integer_t n,
                igraph_real_t radius, 
                igraph_bool_t positive, 
                igraph_matrix_t *res);

/* DECLDIR int igraph_sample_sphere_volume(igraph_integer_t dim, igraph_integer_t n,
                igraph_real_t radius,
                igraph_bool_t positive,
                igraph_matrix_t *res);
/* ln. 217, declaration duplicating the following one is removed */

/* This declaration is remained */
DECLDIR int igraph_sample_sphere_volume(igraph_integer_t dim, igraph_integer_t n,
                igraph_real_t radius,
                igraph_bool_t positive,
                igraph_matrix_t *res);

DECLDIR int igraph_sample_dirichlet(igraph_integer_t n, const igraph_vector_t *alpha,
                igraph_matrix_t *res);
igraph_rng_get_exp() had duplicated declarations in the same file (include/igraph_random.h):
DECLDIR igraph_real_t igraph_rng_get_exp(igraph_rng_t *rng, igraph_real_t rate);  /* 1st declaraion */
DECLDIR unsigned long int igraph_rng_get_int31(igraph_rng_t *rng);
/* DECLDIR igraph_real_t igraph_rng_get_exp(igraph_rng_t *rng, igraph_real_t rate);  /* ln.84, duplicated declaration is removed */
DECLDIR igraph_real_t igraph_rng_get_gamma(igraph_rng_t *rng, igraph_real_t shape,
igraph_transitive_closure_dag() is remained in the include/igraph_topology.h together with other DAG processing API:
/* -------------------------------------------------- */
/* Directed acyclic graphs                            */
/* -------------------------------------------------- */

DECLDIR int igraph_topological_sorting(const igraph_t *graph, igraph_vector_t *res,
			       igraph_neimode_t mode);
DECLDIR int igraph_is_dag(const igraph_t *graph, igraph_bool_t *res);
DECLDIR int igraph_transitive_closure_dag(const igraph_t *graph,
				  igraph_t *closure);",True,{}
igraph/igraph,https://github.com/igraph/igraph,1268,2019-11-22T17:12:50Z,2019-11-23T20:43:18Z,2019-11-23T20:48:38Z,MERGED,True,140,145,5,https://github.com/luav,GCC Warnings Fixed,1,[],https://github.com/igraph/igraph/pull/1268,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1268#issuecomment-557831213,Fix for  #1267,"Thanks -- sorry, I missed that in the diff somehow! It is merged now.",True,{'THUMBS_UP': ['https://github.com/luav']}
igraph/igraph,https://github.com/igraph/igraph,1273,2019-12-20T15:58:36Z,2019-12-20T16:24:12Z,2019-12-21T12:38:16Z,MERGED,True,8,2,1,https://github.com/vtraag,Perform range checking when reindexing membership.,1,[],https://github.com/igraph/igraph/pull/1273,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1273,"This addresses the issue that the build of python-igraph now fails. This is because a cluster index is supplied that is outside the range of 0, ..., n - 1, where n is the number of nodes. This is now explicitly checked and an error is thrown.
This does not yet resolve the failing build of python-igraph, which I need to address in a separate PR for python-igraph.","This addresses the issue that the build of python-igraph now fails. This is because a cluster index is supplied that is outside the range of 0, ..., n - 1, where n is the number of nodes. This is now explicitly checked and an error is thrown.
This does not yet resolve the failing build of python-igraph, which I need to address in a separate PR for python-igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1273,2019-12-20T15:58:36Z,2019-12-20T16:24:12Z,2019-12-21T12:38:16Z,MERGED,True,8,2,1,https://github.com/vtraag,Perform range checking when reindexing membership.,1,[],https://github.com/igraph/igraph/pull/1273,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1273#issuecomment-567983113,"This addresses the issue that the build of python-igraph now fails. This is because a cluster index is supplied that is outside the range of 0, ..., n - 1, where n is the number of nodes. This is now explicitly checked and an error is thrown.
This does not yet resolve the failing build of python-igraph, which I need to address in a separate PR for python-igraph.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1275,2020-01-07T13:06:50Z,2020-01-07T16:39:59Z,2020-02-06T09:19:34Z,MERGED,True,24,17,3,https://github.com/vtraag,Corrected test code and example code for Leiden algorithm.,1,[],https://github.com/igraph/igraph/pull/1275,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1275,This addresses the remark by @szhorvat in #1259 (comment). The start parameter also was not yet properly implemented in the example in the documentation.,This addresses the remark by @szhorvat in #1259 (comment). The start parameter also was not yet properly implemented in the example in the documentation.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1277,2020-01-09T10:27:28Z,2020-01-09T20:20:36Z,2020-01-09T20:20:36Z,MERGED,True,24,24,1,https://github.com/szhorvat,unfold_tree: fix incorrect self-loops,1,[],https://github.com/igraph/igraph/pull/1277,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1277,"Partial fix for #1146, as agreed.","Partial fix for #1146, as agreed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1279,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1279#issuecomment-575547102,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Thanks, this will be very useful - also for me to get things up and running with Appveyor in the python-igraph repo!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1279#issuecomment-575599574,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","One comment: in Appveyor, devenv.exe was not on the PATH for some reason so I had to add its full path manually. Not sure if this is the case with an ordinary Visual Studio installation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1279#issuecomment-575608316,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Thanks for the heads up. I'll look into it.
I'm already running into some other issues before that step. For example, http://mingw.org only provides a 32-bits version, it seems that https://www.msys2.org provides the easiest way to to have a 64-bits version. I'll make adjustments accordingly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1279#issuecomment-575612050,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I believe MinGW and MinGW-w64 are separate projects. You should only use the latter. That's what msys2 provides, so that's the way to go.
I linked this before, but will put it here again: https://github.com/szhorvat/IGraphM/blob/master/Development.md#windows This is (mostly) how I compile igraph on Windows with msys2.
I'll try to test your instructions, but I won't get to it before the freeze date (19th).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1279#issuecomment-575631668,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Yes, they indeed are separate projects, from what I understand. MinGW will not provide any 64-bits support, so indeed msys2 is the way forward. Unfortunately I am running into some issues when installing msys2, presumably related to this issue msys2/MSYS2-packages#1532. Unfortunately I am not in a position to update the BIOS (which may be the cause of the issue), so I'm now trying to take a detour, by simply using the tarball from http://repo.msys2.org/distrib/x86_64/ instead of the .exe.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1279#issuecomment-575820007,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.",I can confirm that this solution indeed provides a workaround for me with the problem I encountered. I am now proceeding through the remaining steps to see what other problems I encounter.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1279#issuecomment-575839092,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I run into a problem while running ./configure in msys2:
Something went wrong bootstrapping makefile fragments
for automatic dependency tracking. Try re-running configure with the
'--disable-dependency-tracking' option to at least be able to build
the package (albeit without support for automatic dependency tracking).

I have now run ./configure with --disable-dependency-tracking as suggested. This then runs fine, but I run into another problem with make, where it cannot find sys/times.h. I am not sure whether that is related, I'll look into that later. I just wanted to report this already here. It seems that this may be a problem of automake, I'm running version 1.16.1. There are some changes to the dependency tracking in the 1.16 version of automake, see release notes. I'm not sure if that causes the problem.
I have already pushed some changes to the instructions, so that if anyone wants to test this further, they at least already have these improved instructions. I will continue to look into this over the weekend (if I can find some time).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1279#issuecomment-575878082,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Something went wrong bootstrapping makefile fragments

I have never seen this, even after building igraph with msys2 on more than one computer.

where it cannot find sys/times.h

You need to add -DMSDOS to CPPFLAGS before running ./configure. This was required by one of the dependencies (f2c? I don't remember which one).
Do take a look at my own notes that I linked.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1279#issuecomment-575879441,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Here's what I usually do, in as much detail as I can remember:

Install msys2, update components. See https://wiki.qt.io/MSYS2
Install needed packages using pacman -S. We need at least mingw-w64-x86_64-toolchain. I do not remember the msys2-specific names of the other needed packages, but try at least automake, autoconf, bison, flex, libtool, git.
We get up to three terminals to work with, ""msys"", ""mingw 32-bit"" and ""mingw 64-bit"". Up to now you were using msys to install stuff. For compiling igraph, use ""mingw 64-bit"".
I build igraph with gmp and without graphml support. I'll go on with this assumption to keep things consistent, even though you'd want to not disable graphml support eventually (which requires additional dependencies).
Build GMP from source and install it. I usually install into $HOME/local, meaning that I pass --prefix=$HOME/local to ./configure. For some reason, igraph won't link properly unless I remove the file libgmp.la from PREFIX/lib. Thus, remove it. I have not yet been able to understand the details of this.
Clone the igraph repo with git
./bootstrap.sh
Assuming GMP is in $HOME/local, first set export CPPFLAGS=""-I$HOME/local/include -DMSDOS"" LDFLAGS=-L$HOME/local/lib  The -DMSDOS part is necessary.
./configure --prefix=$HOME/local --disable-graphml
make -j4 (or however many cores you have)
make install
Now add PREFIX/bin to your PATH environment variable. The igraph .dll needs to be in the path before we can run the tests
make check

These are the steps I actually follow. There are parts that I do not fully understand, and there are things that can probably be done better. Thus I would not publish these steps as they are. But they worked without issue on several Windows machines, so they are a good starting point for polishing things, and for figuring out why @vtraag did not succeed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1279#issuecomment-575881251,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Thanks for reporting the steps you are taking @szhorvat! That should prove useful. I have been using cygwin earlier, which yielded fewer problems it seems. Could you check whether you also encounter the error with the dependency tracking in the most recent installation of msys2 (provided you can install it—otherwise use the tarball)?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1279#issuecomment-575886040,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I regularly update msys2 with pacman -Syuu, and it does work fine.
I can try to uninstall and re-install it and see what happens.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/iosonofabio,13,https://github.com/igraph/igraph/pull/1279#issuecomment-575896096,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Oh another Archer!!
…
On Sat, Jan 18, 2020, at 21:25, Szabolcs Horvát wrote:
 I regularly update msys2 with `pacman -Syuu`, and it does work fine.

 I can try to uninstall and re-install it and see what happens.

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#1279?email_source=notifications&email_token=AAJFEAFTZANIP6TIZWDNXWTQ6LKJZA5CNFSM4KH3FBJKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEJJVFWA#issuecomment-575886040>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAJFEAFZEXOQJVDAOVB3UETQ6LKJZANCNFSM4KH3FBJA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1279#issuecomment-575943722,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","You seem to found out the hint to pass the MSDOS flag @szhorvat here, for f2c indeed, in these files:

  
    
      igraph/src/f2c/dtime_.c
    
    
        Lines 3 to 6
      in
      c517ad2
    
  
  
    

        
          
           #ifdef MSDOS 
        

        
          
           #undef USE_CLOCK 
        

        
          
           #define USE_CLOCK 
        

        
          
           #endif 
        
    
  



  
    
      igraph/src/f2c/etime_.c
    
    
        Lines 3 to 6
      in
      c517ad2
    
  
  
    

        
          
           #ifdef MSDOS 
        

        
          
           #undef USE_CLOCK 
        

        
          
           #define USE_CLOCK 
        

        
          
           #endif 
        
    
  


Unfortunately, I still have not been able to run igraph successfully using msys2, also not with the hints provided by @szhorvat above. At this point, it does seem that igraph is compiled, but there are some linking issues. I will look into that later (no more time today I'm afraid).
Is there any reason why it is necessary to compile igraph on msys2? Frankly, the process seems quite tedious and fragile to me, at least in comparison to the cygwin route. If my understanding is correct, the msys2 route produces a DLL that can be used by native Windows libraries that people may want to develop, while cygwin does not, but I am not 100% sure if that is the case (?). But if a DLL is required in development work, it is probably just as easy (if not easier) to simply compile using MSVC. @szhorvat , do you need msys2 to support the Mathematica interface on Windows? Or would it also be possible to use a DLL that is compiled using MSVC?
Finally, I ran into one point: the patch done in bootstrap.sh is not run because it cannot find the patch program. Perhaps it can be installed using pacman, I have not yet looked into it, but just wanted to raise another point. To be clear, it concerns this part:

  
    
      igraph/bootstrap.sh
    
    
        Lines 23 to 26
      in
      c517ad2
    
  
  
    

        
          
           # Try to patch ltmain.sh to allow -fsanitize=* linker flags to be passed 
        

        
          
           # through to the linker. Don't do anything if it fails; maybe libtool has 
        

        
          
           # been upgraded already. 
        

        
          
           patch -N -p0 -r- <tools/ltmain.patch >/dev/null || true 
        
    
  


I am wondering whether it is actually still necessary to do this, maybe libtool has been upgraded already indeed? Do you know @ntamas ? This patching seems a bit hacky, but perhaps there are good reasons to keep this, I am not sure.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1279#issuecomment-575946980,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Re the patch: it all depends on the version of libtool that you have on your computer when you invoke bootstrap.sh. If libtool is too old (not sure how old, though - our patch is from 2017 so it was definitely a problem in 2017 even though there is a patch from 2015 that should have fixed this in libtool), the generated ltmain.sh script does not let the -fsanitize=... flags get passed through to the linker, which makes it impossible to test igraph with Clang's AddressSanitizer.
All in all, not patching ltmain.sh is not a big deal; it breaks a few stuff that probably only the developers care about. Feel free to update the bootstrap.sh script to skip patching if patch is not installed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,16,https://github.com/igraph/igraph/pull/1279#issuecomment-575979197,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Thanks @ntamas, perhaps good to check if patch is installed or not. Otherwise we might get question about that later. I'll do that later.
The thing I don't understand is that from appveyor.yml the compilation using msys2 seems straightforward. Why I then encounter so many difficulties in compilation I don't understand. I'm comparing the output from the AppVeyor build to my local results to learn more.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1279#issuecomment-575989900,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Is there any reason why it is necessary to compile igraph on msys2?

One might also ask: is there any reason not to (since it seemed to work for me on multiple machines)? I'm sure we'll be able to sort out the problems.
MinGW-w64 is much more useful than Cygwin (since Cygwin is not very interoperable).
I believe the R interface is compiled with MinGW-w64, though I'm not familiar with the details. The standard CRAN toolchain uses MinGW-w64.
The Mathematica interface is currently compiled with msys2 because I have not yet been able to get everything working with MSVC.
I compile the Mathematica interface with GMP, which is essential for me. In fact, I would like to propose making GMP an essential part of igraph because several of the features I plan to contribute require performant bigint arithmetic (and will have functions that return bigints). GMP does not support MSVC at all because its developers are against it. This is solvable: MPIR is an API-compatible replacement, but using it only on Windows is a pain and some extra work. Now that we have much more manpower we can handle it, but I haven't been able to find the time to do it alone for the Mathematica interface.
I also compile the Mathematica interface with an external GLPK because the newest version of GLPK performs better (I needed this for my work). This is again a bit problematic but not unsolvable with MSVC (the solution: WInGLPK).
If all issues get sorted out with MSVC, I would prefer switching the Mathematica interface over to MSVC, as that's Mathematica's preferred toolchain on Windows. However, as the above two examples (GMP and GLPK) illustrate, going for MSVC would have been a lot more work, while msys2, which can run autotools, was quite straightforward. Therefore I think there is great value in supporting msys2, and I am strongly in favour of it.

Regarding the problems you were having with msys2: I strongly suspect that this might be an exception rather than the rule. I compiled igraph on msys2 without problems on three different Windows machine. One of them was a Windows 7 VM set up just for this purpose, i.e. a clean slate. Therefore I'm confident that we will be able to debug the issues.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1279#issuecomment-575991055,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","@vtraag Since we're short on time, I propose that I review the msys2 parts of the instructions and make sure that they work on the two Windows systems I have access to. Let's just go with these imperfect instructions (we know they don't work on your system) for 0.8, as they're still much better than no instructions at all.
Then we'll sort out the rest for 0.9.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,19,https://github.com/igraph/igraph/pull/1279#issuecomment-576035128,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Regarding the problems you were having with msys2: I strongly suspect that this might be an exception rather than the rule. I compiled igraph on msys2 without problems on three different Windows machine.

Fair enough!
I would prefer to get it to work on my machine as well. It seems I'm making progress, and most tests now seem to work. There are still some things to look at (e.g. compiling with libxml2), which I think should be properly explained. If you can give me until Tuesday, I hope to have found enough time to have sorted it all out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1279#issuecomment-576035987,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","If you can give me until Tuesday

I thought the freeze today was meant to cover PRs adding new features. We were still going to work on small fixes, documentation, installation instructions, build system, etc. this week, right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1279#issuecomment-576039420,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Yes; PRs regarding documentation, homepage updates, bugfixes, code formatting etc are still okay during next week.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,22,https://github.com/igraph/igraph/pull/1279#issuecomment-576044895,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Yes, in theory I would have until the end of the week (or even until 28 January). But at some point I should also cut my losses, so if I'm still not there by Tuesday, we'll have to make do with what we have. There are still other things to be updated as well, and other non-igraph things, which also need to be done before the 28th.
But it seems I'm making some progress though, so I'm still hopeful! :) I believe I now have a correctly compiled version of igraph in msys2, including GMP and XML support. I will now restart from scratch again to recheck my instructions. If all goes well, I will push new instructions for that part, and then continue with the MSVC compilation. Explaining compiling with an external GLPK library should not be necessary I think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1279#issuecomment-576047900,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Explaining compiling with an external GLPK library should not be necessary I think?

Actually, it would be useful to note that GLPK needs to be compiled with --disable-reentrant when using MinGW, as this is a non-obvious issue. Unfortunately, I do not remember how I found the solution to this.  https://github.com/szhorvat/IGraphM/blob/master/Development.md#glpk-1",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1279#issuecomment-576048486,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I just compiled with full GraphML support in msys2 and ran the test suite. Things work, but there are two failures.
The Leiden tet failed because once the quality is computed to be 0.2813 but 0.2812 is expected. Clearly some numerical issue that's not a true failure.
SCG of a graph, stochastic matrix fails because complex numbers are printed differently:
-3.14295e-16+0i vs -3.14295e-016+0i
Again, not a true failure.
Things like this keep popping up from time to time as I update MinGW ... (I was aware of one of these ""failures"" before.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,25,https://github.com/igraph/igraph/pull/1279#issuecomment-576049748,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","For future reference, this is the problem I encounter when running the msys2-x86_64-20190524.exe installer:

Perhaps it is due to this issue https://bugreports.qt.io/browse/QTIFW-1110. I'm not sure how to resolve it though. This issue msys2/MSYS2-packages#1532 suggests it may be a problem related to the BIOS (which I am in no position to update), although the reported error is somewhat different. Again, for future reference: I'm running Windows 10, version 1809, build 17763.973.
I will not explain this in the instructions, and simply assume it is a (hopefully) incidental glitch.
The solution by the way is to use the tarball (as I've said before), instead of the installer.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,26,https://github.com/igraph/igraph/pull/1279#issuecomment-576049823,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Thanks for testing @szhorvat ! These were indeed the two tests that still failed me, which are clearly not critical indeed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,27,https://github.com/igraph/igraph/pull/1279#issuecomment-576063804,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","It seems I have now a working set of instructions to compile on msys2. Some of my earlier problems were probably due to incorrect permissions when unpacking the tarball to c:\msys64. I removed all references to administrator rights, since that is probably a result of that faulty installation process.
I think it is possible to simply compile with the provided GMP version for MinGW mingw-w64-x86_64-gmp. This is automatically installed when installing mingw-w64-x86_64-toolchain. Similarly, I think it is better to compile with mingw-w64-x86_64-libxml2 instead of libxml2. The latter gave some issues (some include files of icu were incorrectly not found), while the former worked flawlessly. Perhaps that should also be changed in AppVeyor.yml?
I would propose by the way to include the setting of -DMSDOS in configure.ac, so that this is automatically defined when compiling using MinGW. Do you agree? I actually still don't understand exactly how this is not a problem for the AppVeyor configuration, apparently sys/times.h is included from one path or another, but I'm not sure how.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,28,https://github.com/igraph/igraph/pull/1279#issuecomment-576275617,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","When cloning from GitHub, please ensure that you run git config --global core.autocrlf false before cloning the repository. Otherwise, you might run into problems with line endings.

I never do this and have not had problems so far. Did you experience problems?
More importantly, will turning this off risk introducing CRLF (instead of LF) endings into the source files by a future contributor who uses Windows? <-- This is really my main concern and I do not know the answer.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,29,https://github.com/igraph/igraph/pull/1279#issuecomment-576282407,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I checked the MSYS2 installation instructions on a borrowed clean-slate system that didn't have MSYS2 installed before. They work.
While testing them, I made a few edit. These are all minor things, and none are strictly necessary. @vtraag Please review and feel free to revert anything. There was no problem in the instructions themselves.
Minor nitpick:
MinGW and MinGW-w64 are separate projects. I believe the former is no longer maintained. MinGW-w64 is not simply a 64-bit version of MinGW. It is a different project that provides both 32-bit and 64-bit tools (and I think, though I'm not sure, that the 32-bit tools from MinGW-w64 are not quite compatible with the original MinGW).
I think the patch package is not needed to I removed it.
Mentioned that GMP can be installed to enable additional igraph functionality, though in practice GMP will already be installed as a dependency of some other package.
Corrected --prefix [DIRECTORY] to --prefix=[DIRECTORY]
Mentioned how to run the tests. We should look into fixing those failures.
""If you dispose of the full Microsoft Visual Studio"" <-- I think the usual meaning of ""dispose of"" is ""to get rid of"".
Changes XXX to the actual https://igraph.discourse.group/ URL (which will be made public soon).
Removed the export CPPFLAGS part from the initial setup instructions, so that people would not believe that this changes a setting permanently. This command must be issued in every session before running ./configure. It is already mentioned right before the ./configure step.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,30,https://github.com/igraph/igraph/pull/1279#issuecomment-577080247,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I have now checked the instructions for Windows, and I have updated them according to some issues that I ran into.
The compilations works fine, but there is one thing that should be clarified (which took me some time to figure out). By default the igraph project targets a static library (.lib), but the exports are suitable for a dynamic library (.dll) by using the __declspec(dllexport) keyword (upon compilation) and the __declspec(dllimport) keyword (upon inclusion in another project). When including the static library, one should then include #define IGRAPH_NO_IMPORTS 1 to make sure that the static library names are properly used. If this is not properly done, you will run into linker issues that __imp_* external symbols are unresolved. However, I believe this is nowehere (yet) documented (this is also a recent addition 47ee0ce). I have now clarified this in the instructions. I am not exactly sure how the static library was linked to previously actually. Perhaps that never worked properly before?
Regarding this aspect, there are two things that I would like to suggest. First of all, I think we should rename IGRAPH_NO_IMPORTS to IGRAPH_STATIC to clarify its intention (this is for example also how it is named in libssh). People might get confused because they do want to import function definitions. Secondly, we need to make sure that the igraphtest that is now included can be properly compiled and runs correctly. We therefore need to add #define IGRAPH_NO_IMPORTS 1 to igraphtest.cpp. In the long run, it might be good to include all tests from the test suite also in an MSVC project.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,31,https://github.com/igraph/igraph/pull/1279#issuecomment-577100579,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","However, I believe this is nowehere (yet) documented (this is also a recent addition 47ee0ce). I have now clarified this in the instructions. I am not exactly sure how the static library was linked to previously actually. Perhaps that never worked properly before?

Most likely that never worked properly before. I have figured this out the hard way when trying to make python-igraph compile in Appveyor. That's why it's also not documented - I came up with it only last week.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,32,https://github.com/igraph/igraph/pull/1279#issuecomment-577101053,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","First of all, I think we should rename IGRAPH_NO_IMPORTS to IGRAPH_STATIC to clarify its intention (this is for example also how it is named in libssh)

Sure, go ahead and send a PR. We also need to update setup.py in the Python interface to reflect the change, but it should be okay. I did not know that there are other examples of this in other projects.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,33,https://github.com/igraph/igraph/pull/1279#issuecomment-577270736,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Right now the igraph website briefly explains how to install/compile on Windows. Putting the entire explanation in this PR on the website will be too much I feel. Shall I simply provide a link to these instructions instead? Or perhaps we can include these instructions as a separate page on the website, instead of as a file in the igraph GitHub repository?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,34,https://github.com/igraph/igraph/pull/1279#issuecomment-577352718,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.",IGRAPH_NO_IMPORTS is now renamed to IGRAPH_STATIC,True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,35,https://github.com/igraph/igraph/pull/1279#issuecomment-577355802,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I would create a separate page on the website. If you can wrap these instructions up nicely in a Markdown document, I can add it to the website. We also need to get rid of any references to Cygwin - if I understand correctly, Cygwin is outdated and no one tests it regularly from our end.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,36,https://github.com/igraph/igraph/pull/1279#issuecomment-577557544,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","IGRAPH_NO_IMPORTS is now renamed to IGRAPH_STATIC

Great! I now see that libxml actually also follows the same pattern (see Notes), so good to be consistent there.
I am actually trying to compile with GraphML support by using the provided Windows binaries for libxml. However, the winclude directory (copied from msvc/include) contains include files from libxml, but apparently outdated ones. That is to say, one particular symbol XML_PARSE_HUGE seems to be missing from the parse.h header, which is present in the include files provided by the Windows binaries from Zlatkovic. What is the reason to include those header files in winclude?
The same question holds for the header files for iconv.h and zlib.h.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,37,https://github.com/igraph/igraph/pull/1279#issuecomment-577590530,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","I would create a separate page on the website. If you can wrap these instructions up nicely in a Markdown document, I can add it to the website. We also need to get rid of any references to Cygwin - if I understand correctly, Cygwin is outdated and no one tests it regularly from our end.

OK, I will create a separate page for that. I believe compilation on cygwin works, but the msys2 instructions now seem to work flawlessly, including support of GMP and libxml. In the interest of keeping it simple, I agree that it would be better to focus on MinGW/msys2 instead of cygwin.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/ntamas,38,https://github.com/igraph/igraph/pull/1279#issuecomment-577643776,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","What is the reason to include those header files in winclude?

I don't remember any more - is there a standard mechanism in Windows that allows the discovery of these header files without hardcoding some path in the project file?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,39,https://github.com/igraph/igraph/pull/1279#issuecomment-579135205,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Since we moved the installation instructions to the website (see igraph/igraph.org#17), I removed the instructions from the repository.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,40,https://github.com/igraph/igraph/pull/1279#issuecomment-579148099,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Just an opinion: I think there's value in having the instructions directly in the repo as many people will look for them there, but won't look on the website. You decide what to do :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,41,https://github.com/igraph/igraph/pull/1279#issuecomment-579150504,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.",I prefer not to maintain two different places. We also don't provide installation instructions for Linux or macOS. Perhaps we can include a general INSTALL file that points to the website though.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/szhorvat,42,https://github.com/igraph/igraph/pull/1279#issuecomment-579158202,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","Perhaps we can include a general INSTALL file that points to the website though.

Let's do that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1279,2020-01-16T21:48:34Z,2020-01-28T20:59:54Z,2020-02-06T09:19:23Z,MERGED,True,1,26,3,https://github.com/vtraag,Updated instructions for compilation on Windows.,8,[],https://github.com/igraph/igraph/pull/1279,https://github.com/vtraag,43,https://github.com/igraph/igraph/pull/1279#issuecomment-579452807,"This addresses #969. Please do not merge yet however. I will check whether the instructions work correctly on my Windows machine tomorrow. There are also (very short) instructions on the website for installation on Windows, we probably also need to update those. I will take a look at that tomorrow.","As far as I am concerned, we are good to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1280,2020-01-19T16:52:13Z,2020-01-19T20:12:31Z,2020-01-20T08:32:45Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create .zenodo.json,1,[],https://github.com/igraph/igraph/pull/1280,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1280,"Zenodo automatically extracts metadata about repositories from GitHub APIs. For example, the authors are determined from the repository's contributor statistics. This automatic extraction is solely a best guess. Therefore it is useful to set certain values explicitly in a .zenodo.json files.
This is in preparation for requesting a DOI from Zenodo, which should be set up before we create a release. It is creating a release that triggers auto-archiving on Zenodo. At that point Zenodo will take some of the data from this file.","Zenodo automatically extracts metadata about repositories from GitHub APIs. For example, the authors are determined from the repository's contributor statistics. This automatic extraction is solely a best guess. Therefore it is useful to set certain values explicitly in a .zenodo.json files.
This is in preparation for requesting a DOI from Zenodo, which should be set up before we create a release. It is creating a release that triggers auto-archiving on Zenodo. At that point Zenodo will take some of the data from this file.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1280,2020-01-19T16:52:13Z,2020-01-19T20:12:31Z,2020-01-20T08:32:45Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create .zenodo.json,1,[],https://github.com/igraph/igraph/pull/1280,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1280#issuecomment-576024224,"Zenodo automatically extracts metadata about repositories from GitHub APIs. For example, the authors are determined from the repository's contributor statistics. This automatic extraction is solely a best guess. Therefore it is useful to set certain values explicitly in a .zenodo.json files.
This is in preparation for requesting a DOI from Zenodo, which should be set up before we create a release. It is creating a release that triggers auto-archiving on Zenodo. At that point Zenodo will take some of the data from this file.","We need to decide about how to present the authorship. For now, I put ""The igraph Development Team"". The main purpose of this file is not to let Zenodo just fetch the user accounts that contributed because that tends to end up containing things that don't belong (I ended up with the Gitter Badger ...)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1280,2020-01-19T16:52:13Z,2020-01-19T20:12:31Z,2020-01-20T08:32:45Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create .zenodo.json,1,[],https://github.com/igraph/igraph/pull/1280,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1280#issuecomment-576039233,"Zenodo automatically extracts metadata about repositories from GitHub APIs. For example, the authors are determined from the repository's contributor statistics. This automatic extraction is solely a best guess. Therefore it is useful to set certain values explicitly in a .zenodo.json files.
This is in preparation for requesting a DOI from Zenodo, which should be set up before we create a release. It is creating a release that triggers auto-archiving on Zenodo. At that point Zenodo will take some of the data from this file.","Having ""The igraph development team"" in Zenodo is okay for me. I'll let @vtraag and @gaborcsardi  chime in in the next few days before I merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1280,2020-01-19T16:52:13Z,2020-01-19T20:12:31Z,2020-01-20T08:32:45Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create .zenodo.json,1,[],https://github.com/igraph/igraph/pull/1280,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1280#issuecomment-576041618,"Zenodo automatically extracts metadata about repositories from GitHub APIs. For example, the authors are determined from the repository's contributor statistics. This automatic extraction is solely a best guess. Therefore it is useful to set certain values explicitly in a .zenodo.json files.
This is in preparation for requesting a DOI from Zenodo, which should be set up before we create a release. It is creating a release that triggers auto-archiving on Zenodo. At that point Zenodo will take some of the data from this file.","I'm fine with ""The igraph Development Team"" in Zenodo, sounds good!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1280,2020-01-19T16:52:13Z,2020-01-19T20:12:31Z,2020-01-20T08:32:45Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create .zenodo.json,1,[],https://github.com/igraph/igraph/pull/1280,https://github.com/gaborcsardi,5,https://github.com/igraph/igraph/pull/1280#issuecomment-576041831,"Zenodo automatically extracts metadata about repositories from GitHub APIs. For example, the authors are determined from the repository's contributor statistics. This automatic extraction is solely a best guess. Therefore it is useful to set certain values explicitly in a .zenodo.json files.
This is in preparation for requesting a DOI from Zenodo, which should be set up before we create a release. It is creating a release that triggers auto-archiving on Zenodo. At that point Zenodo will take some of the data from this file.",Fine with me as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1281,2020-01-19T18:13:25Z,2020-01-20T21:11:55Z,2020-01-20T21:11:55Z,MERGED,True,362,73,10,https://github.com/szhorvat,Add more maximal clique functions,4,[],https://github.com/igraph/igraph/pull/1281,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1281,"This PR:

adds a callback-type function for maximal cliques
adds a function that computes a histogram of maximal clique sizes
fixes minor issues in error codes (e.g. missing strings) and adds comments

I want to get this in for 0.8 so that I can start building the Mathematica interface from the main igraph (instead of my fork)
Tests are forthcoming, but I believe this to be correct as I have been using it for a while.","This PR:

adds a callback-type function for maximal cliques
adds a function that computes a histogram of maximal clique sizes
fixes minor issues in error codes (e.g. missing strings) and adds comments

I want to get this in for 0.8 so that I can start building the Mathematica interface from the main igraph (instead of my fork)
Tests are forthcoming, but I believe this to be correct as I have been using it for a while.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1281,2020-01-19T18:13:25Z,2020-01-20T21:11:55Z,2020-01-20T21:11:55Z,MERGED,True,362,73,10,https://github.com/szhorvat,Add more maximal clique functions,4,[],https://github.com/igraph/igraph/pull/1281,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1281#issuecomment-576030937,"This PR:

adds a callback-type function for maximal cliques
adds a function that computes a histogram of maximal clique sizes
fixes minor issues in error codes (e.g. missing strings) and adds comments

I want to get this in for 0.8 so that I can start building the Mathematica interface from the main igraph (instead of my fork)
Tests are forthcoming, but I believe this to be correct as I have been using it for a while.","The function naming and the argument ordering is perhaps not ideal (it does not match the one for the non-maximal cliques), but neither is it bad. I would keep it as is for 0.8, then maybe improve it for 0.9 when we'll have several other breaking changes anyway.
The function naming and argument order takes some work to change because of the templating mechanism that is being used.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1281,2020-01-19T18:13:25Z,2020-01-20T21:11:55Z,2020-01-20T21:11:55Z,MERGED,True,362,73,10,https://github.com/szhorvat,Add more maximal clique functions,4,[],https://github.com/igraph/igraph/pull/1281,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1281#issuecomment-576035676,"This PR:

adds a callback-type function for maximal cliques
adds a function that computes a histogram of maximal clique sizes
fixes minor issues in error codes (e.g. missing strings) and adds comments

I want to get this in for 0.8 so that I can start building the Mathematica interface from the main igraph (instead of my fork)
Tests are forthcoming, but I believe this to be correct as I have been using it for a while.","There was an issue with stopping the search with the callback function. It's fixed now.
I added tests (which discovered the above issue).
Ready to review/merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1283,2020-01-20T08:52:39Z,2020-01-20T09:15:35Z,2020-01-29T09:18:30Z,MERGED,True,29,11,15,https://github.com/szhorvat,Add missing includes and other small fixes,1,[],https://github.com/igraph/igraph/pull/1283,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1283,"This PR adds some missing includes to get rid of implicit-function-declaration warnings and to make IDEs be happier when editing igraph source files.
There are also a few other minor changes:

re-encode some files to UTF-8 from ISO-Latin-1
change LAPACK_H header guard to IGRAPH_LAPACK_H (as LAPACK_H is too likely to be encountered in other projects)
Add some missing __BEGIN_DECL or __END_DECL
Add missing entries for igraph_rng_type_t structs","This PR adds some missing includes to get rid of implicit-function-declaration warnings and to make IDEs be happier when editing igraph source files.
There are also a few other minor changes:

re-encode some files to UTF-8 from ISO-Latin-1
change LAPACK_H header guard to IGRAPH_LAPACK_H (as LAPACK_H is too likely to be encountered in other projects)
Add some missing __BEGIN_DECL or __END_DECL
Add missing entries for igraph_rng_type_t structs",True,{}
igraph/igraph,https://github.com/igraph/igraph,1283,2020-01-20T08:52:39Z,2020-01-20T09:15:35Z,2020-01-29T09:18:30Z,MERGED,True,29,11,15,https://github.com/szhorvat,Add missing includes and other small fixes,1,[],https://github.com/igraph/igraph/pull/1283,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1283#issuecomment-576171969,"This PR adds some missing includes to get rid of implicit-function-declaration warnings and to make IDEs be happier when editing igraph source files.
There are also a few other minor changes:

re-encode some files to UTF-8 from ISO-Latin-1
change LAPACK_H header guard to IGRAPH_LAPACK_H (as LAPACK_H is too likely to be encountered in other projects)
Add some missing __BEGIN_DECL or __END_DECL
Add missing entries for igraph_rng_type_t structs",One thing that bothers me and is unfixed in this PR is the use of igraph_i_vector_binsearch_slice in community_leiden.h without declaration. There should be an internal header for every internal function that we might want to use in other files.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1283,2020-01-20T08:52:39Z,2020-01-20T09:15:35Z,2020-01-29T09:18:30Z,MERGED,True,29,11,15,https://github.com/szhorvat,Add missing includes and other small fixes,1,[],https://github.com/igraph/igraph/pull/1283,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1283#issuecomment-576173535,"This PR adds some missing includes to get rid of implicit-function-declaration warnings and to make IDEs be happier when editing igraph source files.
There are also a few other minor changes:

re-encode some files to UTF-8 from ISO-Latin-1
change LAPACK_H header guard to IGRAPH_LAPACK_H (as LAPACK_H is too likely to be encountered in other projects)
Add some missing __BEGIN_DECL or __END_DECL
Add missing entries for igraph_rng_type_t structs","re-encode some files to UTF-8 from ISO-Latin-1

Can't we do it the other way round and re-encode everything in UTF-8 instead? After all, it's 2020 now :) Are there any (serious) IDEs out there that cannot cope with UTF-8?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1283,2020-01-20T08:52:39Z,2020-01-20T09:15:35Z,2020-01-29T09:18:30Z,MERGED,True,29,11,15,https://github.com/szhorvat,Add missing includes and other small fixes,1,[],https://github.com/igraph/igraph/pull/1283,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1283#issuecomment-576174239,"This PR adds some missing includes to get rid of implicit-function-declaration warnings and to make IDEs be happier when editing igraph source files.
There are also a few other minor changes:

re-encode some files to UTF-8 from ISO-Latin-1
change LAPACK_H header guard to IGRAPH_LAPACK_H (as LAPACK_H is too likely to be encountered in other projects)
Add some missing __BEGIN_DECL or __END_DECL
Add missing entries for igraph_rng_type_t structs","Can't we do it the other way round and re-encode everything in UTF-8 instead? After all, it's 2020 now :) Are there any (serious) IDEs out there that cannot cope with UTF-8?

My phrasing was awkward. That's exactly what I did. It was Latin-1 and now it is UTF-8.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1283,2020-01-20T08:52:39Z,2020-01-20T09:15:35Z,2020-01-29T09:18:30Z,MERGED,True,29,11,15,https://github.com/szhorvat,Add missing includes and other small fixes,1,[],https://github.com/igraph/igraph/pull/1283,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1283#issuecomment-576179833,"This PR adds some missing includes to get rid of implicit-function-declaration warnings and to make IDEs be happier when editing igraph source files.
There are also a few other minor changes:

re-encode some files to UTF-8 from ISO-Latin-1
change LAPACK_H header guard to IGRAPH_LAPACK_H (as LAPACK_H is too likely to be encountered in other projects)
Add some missing __BEGIN_DECL or __END_DECL
Add missing entries for igraph_rng_type_t structs",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1288,2020-01-23T10:09:38Z,2020-01-23T11:29:26Z,2020-02-06T09:19:46Z,MERGED,True,4,4,1,https://github.com/vtraag,"Correct compilation on Windows, including test",1,[],https://github.com/igraph/igraph/pull/1288,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1288,"This is intended to fix #1287. This corrects some aspects related to the make msvc command, which failed if there were no files yet in the igraph-*-msvc directory.
I still intend to look at compiling with libxml support, so please do not merge yet.
Another issue that I preferably would like to correct in this PR is to automatically include the -DMSDOS flag when compiling using MinGW.","This is intended to fix #1287. This corrects some aspects related to the make msvc command, which failed if there were no files yet in the igraph-*-msvc directory.
I still intend to look at compiling with libxml support, so please do not merge yet.
Another issue that I preferably would like to correct in this PR is to automatically include the -DMSDOS flag when compiling using MinGW.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1288,2020-01-23T10:09:38Z,2020-01-23T11:29:26Z,2020-02-06T09:19:46Z,MERGED,True,4,4,1,https://github.com/vtraag,"Correct compilation on Windows, including test",1,[],https://github.com/igraph/igraph/pull/1288,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1288#issuecomment-577642322,"This is intended to fix #1287. This corrects some aspects related to the make msvc command, which failed if there were no files yet in the igraph-*-msvc directory.
I still intend to look at compiling with libxml support, so please do not merge yet.
Another issue that I preferably would like to correct in this PR is to automatically include the -DMSDOS flag when compiling using MinGW.","Another issue that I preferably would like to correct in this PR is to automatically include the -DMSDOS flag when compiling using MinGW.

Sorry, I missed this part and merged the PR without it. Feel free to open a new one.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1289,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.","This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1289#issuecomment-577725404,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.","Would it not be better to try to make the test more specific (instead of basing it only on the presence/absence of sys/time.h?
I wonder if there is a good way to detect an msys2 environment.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1289#issuecomment-577726808,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.",The MSYSTEM environment variable is always defined in an MSYS2 environment.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1289#issuecomment-577729934,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.",One additional issue when building on msys2 is that one must explicitly add the location of the igraph DLL to the PATH before make check will work. It would be nice (but not a 0.8-blocker) to do this automatically on that platform.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1289#issuecomment-577740566,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.","more specific

I actually thought this would be the most specific. In the AppVeyor build environment apparently the sys/times.h is provided (but I'm not sure from where). Hence, testing for msys2, or more precise, for MinGW, would be less specific, not more specific. Of course we could also test for the combination: both sys/times.h is missing and we are compiling using MinGW? I believe we can test that using something like AC_CANONICAL_HOST?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1289#issuecomment-577746848,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.","I'm looking into compilation with libxml. This might be best supported using vcpkg, which seems to work quite nicely. Do you have any experience with this? I'm not sure if I will finish that in time, so perhaps that will have to wait.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1289#issuecomment-577747022,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.","I'm not sure about how to solve the make check thing, suggestions are welcome.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1289,2020-01-23T13:21:59Z,2020-01-28T08:57:51Z,2020-02-06T09:19:49Z,MERGED,True,5,3,1,https://github.com/vtraag,"Compilation on Windows, part 2",1,[],https://github.com/igraph/igraph/pull/1289,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1289#issuecomment-579136226,"This is the continuation of #1288, fixing #1287.
PLEASE DO NOT MERGE YET
I have now set -DMSDOS for compilation when sys/times.h is missing automatically in configure.ac.
Next point to address will be to compile with libxml2 support.","As far as I am concerned, we can merge this. I don't have further time to complete compilation with libxml from Zlatkovic. I believe the detection of sys/times.h works satisfactorily, for now at least.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/YasirKusay,1,https://github.com/igraph/igraph/pull/1290,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1290#issuecomment-578060514,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","Thanks for all your work on this @YasirKusay !
Since you are still working on it, I think it's best to merge this only after the 0.8 release. However, if you discover any bugs while creating the tests, please let us know ASAP.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1290#issuecomment-578060839,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","In case you have not yet seen this wiki page, here are some tips on what to verify: https://github.com/igraph/igraph/wiki/Checklist-for-new-(and-old)-functions",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1290#issuecomment-578084245,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","Yes, indeed thanks for you work @YasirKusay ! As @szhorvat indicates, we should only merge this after the upcoming release.
One other thing: it is useful to indicate in your PR which issue you intend to fix (if any). This will both link the PR to the issue, and indicate in the issue which PR fixes it. In this case, you intend to address issue #1208. If you indicate something like: ""this should fix #1208"", GitHub even automatically picks up on this and closes the issue if we merge the PR. You only need to write the issue number (prepended with #), GitHub will pick up on this and link to the appropriate issue.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/YasirKusay,5,https://github.com/igraph/igraph/pull/1290#issuecomment-578490950,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","Thank you all very much for your advice. I will continue to work on it for now. These tests were intended to address issue #1208 (add tests for igraph_closeness). One more thing, can you explain to me how the cutoff parameter is meant to work? From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1290#issuecomment-581128612,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.",Just a note that I haven't forgotten about this and will get back to you in a couple of days. Thank again for doing all this work!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1290#issuecomment-583404411,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.",Can you please separate changes related to different issues? This PR was started for adding tests for closeness calculations. Things related to bridges should be kept separate.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/iosonofabio,8,https://github.com/igraph/igraph/pull/1290#issuecomment-583630651,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","Hi Yasir,

Thank you for your commitment! The usual way to submit several PRs at once is to have separate branches (both locally on your laptop and remote branches on your GitHub) and then each remote branch is used for one PR. Git will take care of merging them all.
…
On Sat, Feb 8, 2020, at 01:10, Szabolcs Horvát wrote:
 Can you please separate changes related to different issues? This PR
 was started for adding tests for closeness calculations. Things related
 to bridges should be kept separate.

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#1290?email_source=notifications&email_token=AAJFEABPWIQXV5BQCTDT4VTRBVTV5A5CNFSM4KLDGTAKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOELDAW6Y#issuecomment-583404411>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAJFEAF6XE3UMHRDK4XYQDDRBVTV5ANCNFSM4KLDGTAA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1290#issuecomment-583867495,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","One more thing, can you explain to me how the cutoff parameter is meant to work? From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this.

This relates to issue #1053: igraph's current handling of non-connected graphs is rather questionable in my opinion ... Before we can proceed with the tests, we need to think about this carefully, and choose how to handle disconnected graphs, or cases with look ""disconnected"" with a low cutoff.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/YasirKusay,10,https://github.com/igraph/igraph/pull/1290#issuecomment-583946558,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","With regards to issue #1053, I definitely agree! When I was writing tests for a weighted graph, I found it unusual that I was using the number of vertices as the default distance for vertices in separated subgraphs (or even in connected, directed graphs where there was no possible way to reach a vertex from another vertex, e.g. in 1->2->3, where you cannot reach node 2 from node 3). Furthermore, say we have a small graph: 1-2-3, where the distance from 1-2 is 10 and 2-3 is 20, therefore disproving that the number of vertices is "" is always longer than the longest possible geodesic"". I actually did a bit of research into this and I found some very interesting ways of working out closeness centrality, particularly this one:
https://toreopsahl.com/2010/03/20/closeness-centrality-in-networks-with-disconnected-components/
To summarise what that website stated, since the distance between 2 disconnected nodes is infinite, the reciprocal of that distance will be 0 and therefore useless when you are finding the reciprocal of the sum of all distances, as centrality will be 0. Instead, it proposes that you find the distance between 2 nodes and get the reciprocal of that, (doing the same from that node to all of the nodes in the graph, even if they are disconnected) and then sum up these reciprocals. I acknowledge that this will result in a different closeness centrality for graphs that are connected, but perhaps it can be implemented for disconnected graphs and directed graphs where there is no possible path from one node to another (whilst triggering a warning to the user).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/YasirKusay,11,https://github.com/igraph/igraph/pull/1290#issuecomment-583948198,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","@szhorvat, @iosonofabio
Thank you for your advice and I will do that from now on. I am a bit new to github and didnt realise that commits are connected to the same pull request.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1290,2020-01-24T09:23:56Z,2020-02-16T23:57:35Z,2020-02-16T23:57:35Z,CLOSED,False,0,0,0,https://github.com/YasirKusay,Tests for igraph_closeness_estimate,0,[],https://github.com/igraph/igraph/pull/1290,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1290#issuecomment-584252273,"I've implemented a few tests for igraph_closeness_estimate for as many cases that I can think of. I will admit that the code may be unnecessarily complicated to read and that some of the tests are too simple. Furthermore, I have yet to implement tests for specific cutoff values, rather than just calculating the true closeness centrality as I am confused as to how it works. From what I understand, if the path from one node to another exceeds the cutoff value, the cutoff value is used instead but the output I am getting is not consistent with this. Feel free to give me advice as how to improve the tests and the code, and if I need to change my code in order to conform to your test protocols.","@YasirKusay, you may want to read the general contributing guidelines. That also contains some explanations of how to best prepare your PR (it also took me some time to learn it).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1293,2020-01-24T21:36:53Z,2020-01-25T12:57:54Z,2020-01-25T12:57:54Z,MERGED,True,129,233,35,https://github.com/szhorvat,Revert some reformatting and fix more Vim modelines,3,[],https://github.com/igraph/igraph/pull/1293,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1293,"This reverts some reformatting and fixes more Vim modelines.
I didn't look at all files, by far.","This reverts some reformatting and fixes more Vim modelines.
I didn't look at all files, by far.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1294,2020-01-25T14:33:03Z,2020-01-26T11:31:37Z,2020-01-29T07:59:51Z,MERGED,True,10,3,3,https://github.com/szhorvat,Include SIR docs,1,[],https://github.com/igraph/igraph/pull/1294,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1294,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1295,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1295#issuecomment-578532910,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","I just noticed that the ChangeLog file I renamed to CHANGELOG.md had this commit note:

Readded (empty) ChangeLog file, needed for automake.

Despite that, ,/configure gave me no complaints. Does anyone remember why ChangeLog was needed? Should I re-add an empty one or rename CHANGELOG.md back?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1295#issuecomment-578537502,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","I've compare the include directory with the 0.7.1 version, and added some additional changes I noticed. Regarding the need of ChangeLog, I don't know, sorry.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1295#issuecomment-578537873,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","ChangeLog is mandated by the GNU coding standards, so automake complains if you don't have one. (It probably does not fail the build, though). Even the format of the ChangeLog file is strictly specified so you cannot symlink a generic Markdown file as ChangeLog to fool automake. sigh",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1295#issuecomment-578538494,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","ChangeLog is mandated by the GNU coding standards

Do we care about GNU standards?
Should I leave it as is (markdown is nice!) or reformat to GNU standards? I roughly followed https://keepachangelog.com/ combined with a bit of common sense to improve readability.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1295#issuecomment-578539589,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).",Note that I didn't follow a chronological order per se.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1295#issuecomment-578539716,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","igraph_solve_lsap() is not documented. I never knew if it was ready and tested. I believe it was added to eventually replace the R implementation of graph matching.
If we include it in the changelog, we should add documentation.
@gaborcsardi, do you know what status of this function is? Ready to use?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/gaborcsardi,8,https://github.com/igraph/igraph/pull/1295#issuecomment-578542821,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","@gaborcsardi, do you know what status of this function is? Ready to use?

IDK, just ignore it, I would say.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1295#issuecomment-578543751,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).",Removed igraph_solve_lsap from the changelog per Gábor's comment. We can test it later and perhaps make it public in 0.9,True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1295#issuecomment-578690476,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","Do we care about GNU standards?

I guess not so much any more, at least compared to how much we used to care about them several years ago :) I'd prefer to have the changelog in Markdown as well - Github formats it nicely, and later on we could even switch to Conventional Commits, which would allow us to generate changelogs from the commit messages instead of writing them manually. However, in order to silence automake for the time being, we should have a regular ChangeLog file that just points the user to the ""real"" changelog. We can remove it once we switch the build system from Autotools to CMake in the future.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1295#issuecomment-579127424,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","Re-added ChangeLog file and kept CHANGELOG.md as-is.
Please everyone have a read-though of the changelog. If there are no concerns by the end of the day, we should merge this.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1295#issuecomment-579251189,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).",Seems OK to me so far! I'll merge around 10pm CET if there are no objections.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1295#issuecomment-579349561,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","I just noticed that there's already a NEWS file with changes up to 0.6.5 but not 0.7. What do we do with that? Transfer its contents?
Unrelated: There is also an ancient TODO file which should probably be removed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1295#issuecomment-579387336,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).","Both of these are obsolete and can be removed. The NEWS file was also mandated by the GNU coding standards, so we should probably keep a placeholder in it.

T.
…
 On 2020. Jan 28., at 17:57, Szabolcs Horvát ***@***.***> wrote:

 ﻿
 I just noticed that there's already a NEWS file with changes up to 0.6.5 but not 0.7. What do we do with that? Transfer its contents?

 Unrelated: There is also an ancient TODO file which should probably be removed.

 —
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub, or unsubscribe.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1295,2020-01-26T12:19:53Z,2020-01-29T11:17:52Z,2020-02-13T22:56:55Z,MERGED,True,72,0,2,https://github.com/szhorvat,Draft changelog for 0.8,9,[],https://github.com/igraph/igraph/pull/1295,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1295#issuecomment-579409097,"This is a draft changelog for 0.8.
Feel free to edit (edits from maintainers are enabled in this PR).",Old news file renamed from NEWS to ONEWS (as suggested by the GNU coding standards). We can remove this file in 0.9 or so. Added new NEWS file that simply refers the user to CHANGELOG.md. These are already in master.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1298,2020-01-26T18:47:17Z,2020-01-26T20:08:27Z,2020-01-29T08:05:21Z,MERGED,True,25,17,10,https://github.com/szhorvat,Documentation fixes and reshuffling,3,[],https://github.com/igraph/igraph/pull/1298,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1298,"Adds some functions to the docs, see #1297
Moves spatial point sampling form Generators to Non-graph chapter","Adds some functions to the docs, see #1297
Moves spatial point sampling form Generators to Non-graph chapter",True,{}
igraph/igraph,https://github.com/igraph/igraph,1298,2020-01-26T18:47:17Z,2020-01-26T20:08:27Z,2020-01-29T08:05:21Z,MERGED,True,25,17,10,https://github.com/szhorvat,Documentation fixes and reshuffling,3,[],https://github.com/igraph/igraph/pull/1298,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1298#issuecomment-578536405,"Adds some functions to the docs, see #1297
Moves spatial point sampling form Generators to Non-graph chapter",Is this ready for merging or do you want to push more commits?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1298,2020-01-26T18:47:17Z,2020-01-26T20:08:27Z,2020-01-29T08:05:21Z,MERGED,True,25,17,10,https://github.com/szhorvat,Documentation fixes and reshuffling,3,[],https://github.com/igraph/igraph/pull/1298,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1298#issuecomment-578537713,"Adds some functions to the docs, see #1297
Moves spatial point sampling form Generators to Non-graph chapter",Ready to merge 👍,True,{}
igraph/igraph,https://github.com/igraph/igraph,1299,2020-01-26T20:54:03Z,2020-01-26T22:00:50Z,2020-01-29T08:05:36Z,MERGED,True,33,10,3,https://github.com/szhorvat,More doc fixes,1,[],https://github.com/igraph/igraph/pull/1299,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1299,Include docs for igraph_local_scan* functions,Include docs for igraph_local_scan* functions,True,{}
igraph/igraph,https://github.com/igraph/igraph,1299,2020-01-26T20:54:03Z,2020-01-26T22:00:50Z,2020-01-29T08:05:36Z,MERGED,True,33,10,3,https://github.com/szhorvat,More doc fixes,1,[],https://github.com/igraph/igraph/pull/1299,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1299#issuecomment-578544360,Include docs for igraph_local_scan* functions,"@ntamas Ready to merge and after you do, can you please re-build the (preliminary) website? I think this completes as much of #1297 as reasonable for 0.8",True,{}
igraph/igraph,https://github.com/igraph/igraph,1299,2020-01-26T20:54:03Z,2020-01-26T22:00:50Z,2020-01-29T08:05:36Z,MERGED,True,33,10,3,https://github.com/szhorvat,More doc fixes,1,[],https://github.com/igraph/igraph/pull/1299,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1299#issuecomment-578547840,Include docs for igraph_local_scan* functions,Build is underway; it should be rsynced in 15 mins or so.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1299,2020-01-26T20:54:03Z,2020-01-26T22:00:50Z,2020-01-29T08:05:36Z,MERGED,True,33,10,3,https://github.com/szhorvat,More doc fixes,1,[],https://github.com/igraph/igraph/pull/1299,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1299#issuecomment-578548437,Include docs for igraph_local_scan* functions,"Sorry, will do this tomorrow in the morning instead",True,{}
igraph/igraph,https://github.com/igraph/igraph,1299,2020-01-26T20:54:03Z,2020-01-26T22:00:50Z,2020-01-29T08:05:36Z,MERGED,True,33,10,3,https://github.com/szhorvat,More doc fixes,1,[],https://github.com/igraph/igraph/pull/1299,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1299#issuecomment-578607700,Include docs for igraph_local_scan* functions,Docs updated.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1300,2020-01-26T21:52:42Z,2020-01-27T12:33:39Z,2020-02-06T09:19:31Z,MERGED,True,3,3,2,https://github.com/vtraag,Added missing DECLDIR,2,[],https://github.com/igraph/igraph/pull/1300,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1300,Some existing functions did not yet have a proper DECLDIR to ensure proper export under Windows.,Some existing functions did not yet have a proper DECLDIR to ensure proper export under Windows.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1303,2020-01-28T08:15:14Z,2020-01-28T08:56:27Z,2020-02-06T09:19:38Z,MERGED,True,3,27,1,https://github.com/vtraag,Made consecutive random sample test deterministic.,1,[],https://github.com/igraph/igraph/pull/1303,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1303,"This fixes #1302. If you prefer to keep the tests random, we can discuss that.","This fixes #1302. If you prefer to keep the tests random, we can discuss that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1305,2020-01-28T12:17:29Z,2020-01-28T12:32:07Z,2020-02-06T09:19:27Z,MERGED,True,6,1,2,https://github.com/vtraag,Updated the central mail address to igraph@igraph.org.,1,[],https://github.com/igraph/igraph/pull/1305,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1305,"I only updated the central mail address for the package, as used in configure.ac. I left all other mail address (e.g. in copyright statements) intact.","I only updated the central mail address for the package, as used in configure.ac. I left all other mail address (e.g. in copyright statements) intact.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1305,2020-01-28T12:17:29Z,2020-01-28T12:32:07Z,2020-02-06T09:19:27Z,MERGED,True,6,1,2,https://github.com/vtraag,Updated the central mail address to igraph@igraph.org.,1,[],https://github.com/igraph/igraph/pull/1305,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1305#issuecomment-579225176,"I only updated the central mail address for the package, as used in configure.ac. I left all other mail address (e.g. in copyright statements) intact.",@vtraag Was adding the VS Code setting accidental?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1305,2020-01-28T12:17:29Z,2020-01-28T12:32:07Z,2020-02-06T09:19:27Z,MERGED,True,6,1,2,https://github.com/vtraag,Updated the central mail address to igraph@igraph.org.,1,[],https://github.com/igraph/igraph/pull/1305,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1305#issuecomment-579225763,"I only updated the central mail address for the package, as used in configure.ac. I left all other mail address (e.g. in copyright statements) intact.","@vtraag Was adding the VS Code setting accidental?

Sorry, no that passed right by me! Probably better to delete it. But it might be nice to add .vscode to the .gitignore.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1306,2020-01-28T12:41:40Z,2020-01-28T12:44:04Z,2020-02-06T09:19:42Z,MERGED,True,2,5,2,https://github.com/vtraag,"Removed VS Code settings, and added it to .gitignore.",1,[],https://github.com/igraph/igraph/pull/1306,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1306,"As noted by @szhorvat here, I accidentally added some settings from VS Code. I have removed those and added the .vscode folder to .gitignore.","As noted by @szhorvat here, I accidentally added some settings from VS Code. I have removed those and added the .vscode folder to .gitignore.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1307,2020-01-29T08:16:31Z,2020-01-29T08:19:34Z,2020-01-29T09:10:09Z,MERGED,True,5,2,1,https://github.com/szhorvat,Add link to Mathematica interface from README,1,[],https://github.com/igraph/igraph/pull/1307,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1307,Hope this is OK,Hope this is OK,True,{}
igraph/igraph,https://github.com/igraph/igraph,1307,2020-01-29T08:16:31Z,2020-01-29T08:19:34Z,2020-01-29T09:10:09Z,MERGED,True,5,2,1,https://github.com/szhorvat,Add link to Mathematica interface from README,1,[],https://github.com/igraph/igraph/pull/1307,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1307#issuecomment-579645051,Hope this is OK,"Absolutely. If you find any more places where the Mathematica interface is not mentioned, feel free to add it on your own.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1309,2020-01-29T10:29:40Z,2020-01-29T10:33:33Z,2020-02-01T10:49:33Z,MERGED,True,8,54,4,https://github.com/szhorvat,"Update local scan docs, remove unused chapters",1,[],https://github.com/igraph/igraph/pull/1309,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1309,"I just noticed that some of the missing functions that I added to the documentation recently already had their own chapter, those chapters were just not included.
This PR incorporates the additional info from those chapters and removes the chapters.
Epidemics had its own (unincluded) chapter. Now it is in ""Games on graphs"", as it is just another process that happens on graphs.
Local scan statistics had its own chapter. Now it is in ""Structural properties"", as it seems to fit there.
I think that this PR is safe to merge at the last minute for 0.8, but it is not essential. We can also include it in 0.8.1. The only user-visible change is a minor reorganization of the local scan statistics functions.","I just noticed that some of the missing functions that I added to the documentation recently already had their own chapter, those chapters were just not included.
This PR incorporates the additional info from those chapters and removes the chapters.
Epidemics had its own (unincluded) chapter. Now it is in ""Games on graphs"", as it is just another process that happens on graphs.
Local scan statistics had its own chapter. Now it is in ""Structural properties"", as it seems to fit there.
I think that this PR is safe to merge at the last minute for 0.8, but it is not essential. We can also include it in 0.8.1. The only user-visible change is a minor reorganization of the local scan statistics functions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1309,2020-01-29T10:29:40Z,2020-01-29T10:33:33Z,2020-02-01T10:49:33Z,MERGED,True,8,54,4,https://github.com/szhorvat,"Update local scan docs, remove unused chapters",1,[],https://github.com/igraph/igraph/pull/1309,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1309#issuecomment-579693041,"I just noticed that some of the missing functions that I added to the documentation recently already had their own chapter, those chapters were just not included.
This PR incorporates the additional info from those chapters and removes the chapters.
Epidemics had its own (unincluded) chapter. Now it is in ""Games on graphs"", as it is just another process that happens on graphs.
Local scan statistics had its own chapter. Now it is in ""Structural properties"", as it seems to fit there.
I think that this PR is safe to merge at the last minute for 0.8, but it is not essential. We can also include it in 0.8.1. The only user-visible change is a minor reorganization of the local scan statistics functions.","I'm still messing with a few minor compilation issues with f2c on Windows, so I'll let the current CI tests finish and then I'll merge this before tagging the release.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1309,2020-01-29T10:29:40Z,2020-01-29T10:33:33Z,2020-02-01T10:49:33Z,MERGED,True,8,54,4,https://github.com/szhorvat,"Update local scan docs, remove unused chapters",1,[],https://github.com/igraph/igraph/pull/1309,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1309#issuecomment-579704515,"I just noticed that some of the missing functions that I added to the documentation recently already had their own chapter, those chapters were just not included.
This PR incorporates the additional info from those chapters and removes the chapters.
Epidemics had its own (unincluded) chapter. Now it is in ""Games on graphs"", as it is just another process that happens on graphs.
Local scan statistics had its own chapter. Now it is in ""Structural properties"", as it seems to fit there.
I think that this PR is safe to merge at the last minute for 0.8, but it is not essential. We can also include it in 0.8.1. The only user-visible change is a minor reorganization of the local scan statistics functions.","Are there any issues with f2c in Windows that we should report in the installation/compilation instructions? If not before the release, we can do so afterwards still?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1309,2020-01-29T10:29:40Z,2020-01-29T10:33:33Z,2020-02-01T10:49:33Z,MERGED,True,8,54,4,https://github.com/szhorvat,"Update local scan docs, remove unused chapters",1,[],https://github.com/igraph/igraph/pull/1309,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1309#issuecomment-579709147,"I just noticed that some of the missing functions that I added to the documentation recently already had their own chapter, those chapters were just not included.
This PR incorporates the additional info from those chapters and removes the chapters.
Epidemics had its own (unincluded) chapter. Now it is in ""Games on graphs"", as it is just another process that happens on graphs.
Local scan statistics had its own chapter. Now it is in ""Structural properties"", as it seems to fit there.
I think that this PR is safe to merge at the last minute for 0.8, but it is not essential. We can also include it in 0.8.1. The only user-visible change is a minor reorganization of the local scan statistics functions.","No, nothing to worry about. I made a last-minute change in the compilation of the C core when I realized that src/f2c/arith.h should actually be generated on the machine where igraph is being compiled, but this broke the MSVC build because we cannot generate this file on MSVC (this is basically a pre-build step that I'm not familiar how to hack into the build process). So I ended up providing a pre-generated copy of arith.h for MSVC, but at least it is now generated properly in POSIX environments.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1312,2020-01-31T16:22:53Z,2020-01-31T20:42:46Z,2020-01-31T20:42:46Z,MERGED,True,31,1,3,https://github.com/nograpes,Fix #1311 by checking if number of edges is zero,2,[],https://github.com/igraph/igraph/pull/1312,https://github.com/nograpes,1,https://github.com/igraph/igraph/pull/1312,"In igraph_community_edge_betweenness, if the number of edges in the
graph is zero, and an initialized pointer is passed for the edge
betweenness variable, then the array will be indexed at -1, which
causes memory corruption in the chunk header, making the pointer
invalid. This will segfault when free is called on the pointer.
I have added a test as well, but you may not find that necessary.
I think this directly fix #1311, which will indirectly fix
igraph/rigraph#336.","In igraph_community_edge_betweenness, if the number of edges in the
graph is zero, and an initialized pointer is passed for the edge
betweenness variable, then the array will be indexed at -1, which
causes memory corruption in the chunk header, making the pointer
invalid. This will segfault when free is called on the pointer.
I have added a test as well, but you may not find that necessary.
I think this directly fix #1311, which will indirectly fix
igraph/rigraph#336.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1312,2020-01-31T16:22:53Z,2020-01-31T20:42:46Z,2020-01-31T20:42:46Z,MERGED,True,31,1,3,https://github.com/nograpes,Fix #1311 by checking if number of edges is zero,2,[],https://github.com/igraph/igraph/pull/1312,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1312#issuecomment-580903517,"In igraph_community_edge_betweenness, if the number of edges in the
graph is zero, and an initialized pointer is passed for the edge
betweenness variable, then the array will be indexed at -1, which
causes memory corruption in the chunk header, making the pointer
invalid. This will segfault when free is called on the pointer.
I have added a test as well, but you may not find that necessary.
I think this directly fix #1311, which will indirectly fix
igraph/rigraph#336.",Tests are always nice to have :) Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1313,2020-02-02T11:43:16Z,2020-02-03T08:50:22Z,2020-02-04T12:31:28Z,MERGED,True,56,41,1,https://github.com/szhorvat,Update changelog,3,[],https://github.com/igraph/igraph/pull/1313,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1313,"I'm sending this as  PR in case there are concerns.

Started an Unreleased section (like at https://keepachangelog.com/) so we can record changes as we go. Mentioned PR #1312
Mentioned more breaking changes for 0.8. While this file will only be included in 0.8.1, it is better to do it late than never. This information is useful for users.
Converted sub-subsections to bullet lists to improve readability.","I'm sending this as  PR in case there are concerns.

Started an Unreleased section (like at https://keepachangelog.com/) so we can record changes as we go. Mentioned PR #1312
Mentioned more breaking changes for 0.8. While this file will only be included in 0.8.1, it is better to do it late than never. This information is useful for users.
Converted sub-subsections to bullet lists to improve readability.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1314,2020-02-03T17:10:08Z,2020-02-03T17:32:55Z,2020-02-04T12:30:20Z,MERGED,True,2,0,1,https://github.com/szhorvat,Add Zenodo DOI to docs,1,[],https://github.com/igraph/igraph/pull/1314,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1314,"This PR adds the master DOI from Zenodo to the Citing igraph section of the docs.
Zenodo assigns a separate DOI to each release. This is the master DOI that refers to all of them at once.","This PR adds the master DOI from Zenodo to the Citing igraph section of the docs.
Zenodo assigns a separate DOI to each release. This is the master DOI that refers to all of them at once.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1314,2020-02-03T17:10:08Z,2020-02-03T17:32:55Z,2020-02-04T12:30:20Z,MERGED,True,2,0,1,https://github.com/szhorvat,Add Zenodo DOI to docs,1,[],https://github.com/igraph/igraph/pull/1314,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1314#issuecomment-581527780,"This PR adds the master DOI from Zenodo to the Citing igraph section of the docs.
Zenodo assigns a separate DOI to each release. This is the master DOI that refers to all of them at once.",I'll rebuild the docs on the site to include this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1319,2020-02-04T13:45:35Z,2020-02-04T13:48:48Z,2020-06-13T08:23:44Z,MERGED,True,23,1,1,https://github.com/szhorvat,Configuration model: check for loop edges in an initial pass,1,[],https://github.com/igraph/igraph/pull/1319,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1319,"This implements Tamás's idea from here:
#1144 (comment)
The speedup is very minor in practice. It was only noticeable for heavy-tail degree distributions. An example of the biggest speedups I noticed: 7.7 s -> 5.9 s.
This is because the set data structure is quite efficient, and because most of the time is spent in the random number generator anyway.","This implements Tamás's idea from here:
#1144 (comment)
The speedup is very minor in practice. It was only noticeable for heavy-tail degree distributions. An example of the biggest speedups I noticed: 7.7 s -> 5.9 s.
This is because the set data structure is quite efficient, and because most of the time is spent in the random number generator anyway.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1319,2020-02-04T13:45:35Z,2020-02-04T13:48:48Z,2020-06-13T08:23:44Z,MERGED,True,23,1,1,https://github.com/szhorvat,Configuration model: check for loop edges in an initial pass,1,[],https://github.com/igraph/igraph/pull/1319,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1319#issuecomment-583423745,"This implements Tamás's idea from here:
#1144 (comment)
The speedup is very minor in practice. It was only noticeable for heavy-tail degree distributions. An example of the biggest speedups I noticed: 7.7 s -> 5.9 s.
This is because the set data structure is quite efficient, and because most of the time is spent in the random number generator anyway.","@ntamas I think what we (or I) should try is to not do a complete shuffle of the vector before rejecting a trial.
What we do now: 1) do complete shuffle 2) check for self-loops 3) check for multi-edges. Originally, 2) and 3) were combined. This PR separates them. Since 3) works with sets, it was potentially slow, and this PR did indeed lead to some speedup. But I believe most time is spent in calling the RNG (i.e. shuffling), and not in checking whether the result is a simple graph. We could try to combine steps 1) and 2): do not complete the Fisher-Yates shuffle once we detect that a self-loop would arise. Just short-circuit and restart.  This will save a lot of calls to the RNG.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1321,2020-02-06T11:00:44Z,2020-02-06T11:48:10Z,2020-02-13T22:56:36Z,MERGED,True,6,7,1,https://github.com/szhorvat,"forest_fire_game: improve argument checking, fixes #1320",1,[],https://github.com/igraph/igraph/pull/1321,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1321,"Now the probability-related arguments are checked carefully.
There is no more warning with 0 ambassadors. There is no reason for a warning in my opinion.
Conceptually, the model is meaningful for a forward or backward burning probability of exactly 1, but the current implementation does not support that. I did not fix this limitation a practical workaround is using a very close number e.g. 0.99999.","Now the probability-related arguments are checked carefully.
There is no more warning with 0 ambassadors. There is no reason for a warning in my opinion.
Conceptually, the model is meaningful for a forward or backward burning probability of exactly 1, but the current implementation does not support that. I did not fix this limitation a practical workaround is using a very close number e.g. 0.99999.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1326,2020-02-10T15:41:39Z,2020-02-29T21:23:11Z,2020-02-29T21:23:12Z,CLOSED,False,25,2,4,https://github.com/YasirKusay,Check in igraph_bridges if graph has loops and edges,7,[],https://github.com/igraph/igraph/pull/1326,https://github.com/YasirKusay,1,https://github.com/igraph/igraph/pull/1326,"This is a pull request intended to solve issue #1180
This will check if the current graph has multi-edges and loops, raising a warning if there is. It does this at runtime and therefore, is more efficient than calling a function to check if there are bridges or loops.","This is a pull request intended to solve issue #1180
This will check if the current graph has multi-edges and loops, raising a warning if there is. It does this at runtime and therefore, is more efficient than calling a function to check if there are bridges or loops.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1326,2020-02-10T15:41:39Z,2020-02-29T21:23:11Z,2020-02-29T21:23:12Z,CLOSED,False,25,2,4,https://github.com/YasirKusay,Check in igraph_bridges if graph has loops and edges,7,[],https://github.com/igraph/igraph/pull/1326,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1326#issuecomment-584346451,"This is a pull request intended to solve issue #1180
This will check if the current graph has multi-edges and loops, raising a warning if there is. It does this at runtime and therefore, is more efficient than calling a function to check if there are bridges or loops.","Hi Yasir,
Great to see you are starting to delve into PR plumbing! It's best if we sit down and go through some details together before you proceed.
Let me write you a separate email about possible dates.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1326,2020-02-10T15:41:39Z,2020-02-29T21:23:11Z,2020-02-29T21:23:12Z,CLOSED,False,25,2,4,https://github.com/YasirKusay,Check in igraph_bridges if graph has loops and edges,7,[],https://github.com/igraph/igraph/pull/1326,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1326#issuecomment-592996070,"This is a pull request intended to solve issue #1180
This will check if the current graph has multi-edges and loops, raising a warning if there is. It does this at runtime and therefore, is more efficient than calling a function to check if there are bridges or loops.","Closing, since this was split into separate PRs for bridges (which is resolved) and closeness (which is not yet resolved).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1330,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).","This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1330#issuecomment-585663433,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).","What is happening? Here's another failure, and this test was already deterministic.
https://travis-ci.org/igraph/igraph/jobs/649885327",True,{}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1330#issuecomment-585665315,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).","I don't think that test was deterministic to start with? That is, as far as I know

  
    
      igraph/examples/simple/igraph_community_label_propagation.c
    
    
         Line 54
      in
      e485141
    
  
  
    

        
          
           igraph_community_label_propagation(&g, &membership, 0, 0, 0, 
        
    
  


is not a deterministic function, and so the RNG should be seeded for this. I hadn't seen the error before, but perhaps we just got lucky earlier?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1330#issuecomment-585668541,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).","Of course! The method is not determinisitc.
@vtraag  I am not familiar with the details of this method. Is there any reason to expect it not to return more than 4 clusters for this graph?
BTW the probability of this test failing is about 0.1%:
In[116]:= g = ExampleData[{""NetworkGraph"", ""ZacharyKarateClub""}];

In[129]:= Table[
     Length[IGCommunitiesLabelPropagation[g][""Communities""]],
     {10000}
     ] // Counts // KeySort // N // Normalize[#, Total] &

Out[129]= <|1 -> 0.0351, 2 -> 0.5074, 3 -> 0.4066, 4 -> 0.0493, 5 -> 0.0016|>
The output is the probabilities of getting a certain number of clusters.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1330#issuecomment-585669502,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).",It is still good to have a test that exercises the function even if it does not explicitly check any condition. It helps prevent crashes and it's useful with AddressSanitizer. But the test should at least check the return value of the function (IGRAPH_SUCCESS).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1330#issuecomment-585672562,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).","No, as far as I know, label propagation does not provide any guarantee on the number of clusters. Well, that is perhaps too strong: I assume that the number of clusters will always be strictly lower than the number of nodes. But there's no guarantee that it will be not more than 4 clusters.
We can either make the test deterministic by seeding the RNG. Or we can simply not check the condition, and only check the return value, as you suggest.
By the way: a similar problem of not checking values that may be under-determined (and can hence change in certain conditions) appears in issue #678. Perhaps better to address that separately, but I just wanted to mention it here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1330,2020-02-13T10:04:37Z,2020-02-13T19:22:06Z,2020-03-05T16:10:27Z,MERGED,True,11,24,16,https://github.com/szhorvat,Make all tests deterministic,1,[],https://github.com/igraph/igraph/pull/1330,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1330#issuecomment-594429707,"This PR tries to make all tests deterministic by setting a fixed random seed. Some tests use igraph's own RNG, some use the one from the C standard library.
This was motivated by this spurious failure which may have happened because of numerical precision issues:
https://travis-ci.org/igraph/igraph/jobs/648828440
I am not sure how to get the full build state from Travis (if it's even possible).","and only check the return value, as you suggest.

I think it is actually not necessary to check the return value of functions in tests. If the return value is not zero, the function will print an error or warning message. It should be sufficient to let the test frame work check the output of the program.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1331,2020-02-13T16:22:20Z,2020-02-13T19:18:42Z,2020-03-05T16:11:58Z,MERGED,True,4,0,1,https://github.com/szhorvat,degree_sequence_game: make DEGSEQ_SIMPLE_NO_MULTIPLE interruptible,1,[],https://github.com/igraph/igraph/pull/1331,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1331,"degree_sequence_game with DEGSEQ_SIMPLE_NO_MULTIPLE does not do well with some degree sequence (e.g. power-law distributed) and will in practice keep running forever.
This makes it interruptible.","degree_sequence_game with DEGSEQ_SIMPLE_NO_MULTIPLE does not do well with some degree sequence (e.g. power-law distributed) and will in practice keep running forever.
This makes it interruptible.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1331,2020-02-13T16:22:20Z,2020-02-13T19:18:42Z,2020-03-05T16:11:58Z,MERGED,True,4,0,1,https://github.com/szhorvat,degree_sequence_game: make DEGSEQ_SIMPLE_NO_MULTIPLE interruptible,1,[],https://github.com/igraph/igraph/pull/1331,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1331#issuecomment-585909303,"degree_sequence_game with DEGSEQ_SIMPLE_NO_MULTIPLE does not do well with some degree sequence (e.g. power-law distributed) and will in practice keep running forever.
This makes it interruptible.","As far as I can tell, there are some unnecessary IGRAPH_CHECK's, such as this:
https://github.com/igraph/igraph/pull/1331/files#diff-734e1282742f6a82c91db2984452de0dL975
That vector seems to be already initialized to the correct size, so the _update function shouldn't fail due to out-of-memory.
I didn't remove them as it's not harmful and it won't be what slows things down. I didn't want to mess up anything by accident.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1331,2020-02-13T16:22:20Z,2020-02-13T19:18:42Z,2020-03-05T16:11:58Z,MERGED,True,4,0,1,https://github.com/szhorvat,degree_sequence_game: make DEGSEQ_SIMPLE_NO_MULTIPLE interruptible,1,[],https://github.com/igraph/igraph/pull/1331,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1331#issuecomment-585928066,"degree_sequence_game with DEGSEQ_SIMPLE_NO_MULTIPLE does not do well with some degree sequence (e.g. power-law distributed) and will in practice keep running forever.
This makes it interruptible.","That particular IGRAPH_CHECK() is probably not necessary with the current implementation (and it's unlikely that we'll ever implement another version of igraph_vector_update() that might return an error code if no memory allocation is necessary for the update). However, I'd rather stick to the practice of putting IGRAPH_CHECK() macros everywhere where the wrapped function returns an igraph_error_t so if we ever decide to return an error code from a function that did not do so in certain conditions before, we won't break existing code with it. The overhead of the IGRAPH_CHECK() macro is probably minimal; it might even be the case that the compiler optimizes it away if it detects that the only valid return code from a function is IGRAPH_SUCCESS.",True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/YasirKusay,1,https://github.com/igraph/igraph/pull/1333,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1333#issuecomment-586907098,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","FYI, CI tests were failing on Windows with MSVC. This is because some variable declarations were in the middle of their blocks (not at the top). This is not permitted in C89 but is totally fine with any modern C compiler. Unfortunately we still need to support C89 because igraph's Python interface for Python 2.7 is compiled with MSVC and MSVC is very picky about this.
(It is probably a good practice anyway to move all variable declarations to the top of the corresponding blocks because otherwise one would have to scan the entire block to figure out which variables are declared in the block).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1333#issuecomment-586907501,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","DO NOT MERGE YET, FOR REVIEW ONLY

There is a ""draft PR"" feature in Github - you can mark a PR as ""draft"" to indicate that it's still work in progress. I think it's not possible to change this after the PR has been created, but you can use it next time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1333#issuecomment-589985787,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","I meant to comment on this a few days ago. Unfortunately a bad flu prevented me from doing so.
Do I understand it correctly that this is basically complete, except for testing cutoffs?  There are a lot of tests here, so I suggest we finalize and merge these as soon as possible. The cutoff case is problematic, and requires a complete re-think of how closeness estimation should work, and whether estimation with a cutoff makes sense at all. It will almost certainly require changes to the closeness function. That should be a separate project, and I suggest we leave it for another time.
Some comments on the current tests:
When a test fails, one would want to determine (with as little effort as possible) which part of the test failed, and how it failed exactly. Therefore it is preferable to print the results and let the test framework compare the printed output to the expected one. Is there are reason you think the direct comparison was necessary (instead of printing results)?
I notice you implemented a function to compare with tolerance. If we print the output, a small difference can be allowed by printing with a limited number of digits. This is, in fact, the default behaviour of printf with %f, so usually nothing special needs to be done.
To make it easier to print vectors, and to reduce duplication of code in test programs, you can #include the file test_utilities.inc and use the printing functions there.
Some smaller nitpicks:
We aim for C89 compatibility in igraph, and also try to maintain a consistent style. Therefore please change //-comments to /* */-comments and main(void) to main(). main() (i.e. no prototype) will work with any old C compiler, and I believe some MSVC versions may choke on main(void).
Don't forget to move the declarations to the beginning of blocks, as Tamás asked.
Thanks for all your work on this so far! Is there any other tests you wanted to add (other than the cutoff ones), or do you agree with merging after the above points have been addressed?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/iosonofabio,5,https://github.com/igraph/igraph/pull/1333#issuecomment-589994024,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","Agree with Szabolcs,

@YasirKusay let's meet one of these days and fix these few things?
…
On Sun, Feb 23, 2020, at 05:38, Szabolcs Horvát wrote:
 I meant to comment on this a few days ago. Unfortunately a bad flu
 prevented me from doing so.

 Do I understand it correctly that this is basically complete, except
 for testing cutoffs? There are a lot of tests here, so I suggest we
 finalize and merge these as soon as possible. The cutoff case is
 problematic, and requires a complete re-think of how closeness
 estimation should work, and whether estimation with a cutoff makes
 sense at all. It will almost certainly require changes to the closeness
 function. That should be a separate project, and I suggest we leave it
 for another time.

 Some comments on the current tests:

 When a test fails, one would want to determine (with as little effort
 as possible) which part of the test failed, and how it failed exactly.
 Therefore it is preferable to print the results and let the test
 framework compare the printed output to the expected one. Is there are
 reason you think the direct comparison was necessary (instead of
 printing results)?

 I notice you implemented a function to compare with tolerance. If we
 print the output, a small difference can be allowed by printing with a
 limited number of digits. This is, in fact, the default behaviour of
 `printf` with `%f`, so usually nothing special needs to be done.

 To make it easier to print vectors, and to reduce duplication of code
 in test programs, you can `#include` the file `test_utilities.inc`
 <https://github.com/igraph/igraph/blob/master/examples/tests/test_utilities.inc> and use the printing functions there.

 Some smaller nitpicks:

 We aim for C89 compatibility in igraph, and also try to maintain a
 consistent style. Therefore please change `//`-comments to `/*
 */`-comments and `main(void)` to `main()`. `main()` (i.e. no prototype)
 will work with any old C compiler, and I believe some MSVC versions may
 choke on `main(void)`.

 Don't forget to move the declarations to the beginning of blocks, as
 Tamás asked.

 Thanks for all your work on this so far! Is there any other tests you
 wanted to add (other than the cutoff ones), or do you agree with
 merging after the above points have been addressed?

 —
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#1333?email_source=notifications&email_token=AAJFEADYOVDCOGXFZ2DSBOTREFWMDA5CNFSM4KWIJS22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEMVHP6Y#issuecomment-589985787>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAJFEAGRAITFYN4YFXMBTYLREFWMDANCNFSM4KWIJS2Q>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/YasirKusay,6,https://github.com/igraph/igraph/pull/1333#issuecomment-590022481,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","Hello @szhorvat, thank you for your feedback. With regards to your statement concerning printing the output, I did do that originally when I was first writing the function. Whenever I had a mismatch, I would call the print function that I wrote to see the output but when I saw that they were matching, I decided to remove it to make my output cleaner as a function . However, although I have confirmed that all the tests have passed, you are correct in pointing out that it may be hard for someone else to determine if I passed or failed some of the tests, and I can add some print statements in the main() function to address that, e.g. ""test 1 passed"", ""test 1 failed"", ""all tests passed"", etc. Although none of the tests fail here, I can add a feature to print the expected results and actual results side by side, in case someone wants to play around with my tests. What do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1333#issuecomment-590113026,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","Whenever I had a mismatch, I would call the print function

You do not need to check the result in your program at all. Leave this to the testing framework. Simply print all results, then create a file that contains the expected results and add it to the test. Take a look at the other tests which have two items in AT_COMPILE_CHECK to see examples.

and I can add some print statements in the main() function to address that, e.g. ""test 1 passed"", ""test 1 failed""

Yes, it's a good idea to print some information about what is being tested, so when the test fails, we can quickly jump to the part of the test program which failed.
But I suggest you leave the comparison to the testing framework. Thus, do not print ""failed"" or ""passed"". Simply print the title of the sub-test, then the result of the closeness calculation. Verify manually that the results are correct. You have already done this, so no need to do it again. When you are sure the result is correct, then create the expected output file:
./myprog > igraph_closeness.out

Then add the test program and the expected output to the .at file, and we're good to go.

One thing I forgot to mention is that since we're not testing estimation yet, please rename the test to closeness instead of closeness_estimate.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1333#issuecomment-592996216,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).",@YasirKusay Looking forward to seeing this completed. Let us know if you have questions/comments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/YasirKusay,9,https://github.com/igraph/igraph/pull/1333#issuecomment-593209390,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).",Passes CI on all 3 platforms. Ready to merge.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/iosonofabio,10,https://github.com/igraph/igraph/pull/1333#issuecomment-593291212,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","The CI tests do not catch any of these things, in particular not the C89 comment. It's ok that you look at every PR by hand for now, but that's obviously not ideal. Any suggestions for checking these things at CI?
…
On Mon, Mar 2, 2020, at 19:16, Szabolcs Horvát wrote:
 ***@***.**** requested changes on this pull request.

 Thanks again for your work on this Yasir. I added some comments on the code.

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +    igraph_vector_view(&vector_edges, real_edges,
 sizeof(real_edges)/sizeof(igraph_real_t));
 +    igraph_create(&g, &vector_edges, /*number of vertices*/ 2,
 IGRAPH_DIRECTED);
 Tip: You can use `igraph_small` to keep the code simpler and more
 concise.

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +int igraph_check_vectors_equal(igraph_vector_t *v, igraph_vector_t *w, int size) {
 +    for (int i = 0; i < size; i++) {
 +        int v1 = 1000000 * VECTOR(*v)[i];
 +        int v2 = 1000000 * VECTOR(*w)[i];
 +
 +        if (v1 != v2) {
 +            /* taking into account rounding up/down issues
 +            e.g. for intermediate case no weights
 +            100000 == 99999 */
 +            if (v2+1 != v1) {
 +                return 0;
 +            }
 +        }
 +    }
 +    return 1;
 +}
 Please remove any unused code.

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +    }
 +    return 1;
 +}
 +
 +int simple_test_case_no_weights_undirected() {
 +
 +    igraph_t g;
 +    igraph_vector_t vector_edges, vector_expected_results,
 vector_actual_results, vector_expected_results_normalised;
 +
 +    igraph_real_t real_edges[] = {0,1 , 1,2};
 +    igraph_real_t real_expected_results[] = {0.333333, 0.5, 0.333333};
 +    igraph_real_t real_expected_results_normalised[] = {0.666666, 1,
 0.666666};
 +
 +    printf(""Simple test case, no weights, undirected\n"");
 +
 +    igraph_vector_init(&vector_actual_results, 3);
 It is not necessary to initialize result vectors to their final size.
 Functions like `igraph_closeness` will always resize them as needed.

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +/* helper function, useful for viewing output */
 +void igraph_vector_t_print(igraph_vector_t *exp, igraph_vector_t
 *actual, int size) {
 +    for (int i = 0; i < size; i++) {
 +        double res = VECTOR(*exp)[i];
 +        double res_2 = VECTOR(*exp)[i];
 +        printf(""%lf %lf\n"", res, res_2);
 +    }
 +    printf(""\n"");
 +}
 Please do not include the expected results in the code.

 The expected results should to in the `.out` file. The program prints
 the actual results. Leave it to the test framework to compare them, and
 do not print superfluous information.

 You can use the printing function from `test_utilities.inc` to simplify
 the test program and reduce code duplication

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +/* helper function, useful for viewing output */
 +void igraph_vector_t_print(igraph_vector_t *exp, igraph_vector_t
 *actual, int size) {
 +    for (int i = 0; i < size; i++) {
 +        double res = VECTOR(*exp)[i];
 +        double res_2 = VECTOR(*exp)[i];
 +        printf(""%lf %lf\n"", res, res_2);
 +    }
 +    printf(""\n"");
 +}
 (Note that there was also a bug in this: you print `exp` twice instead
 of printing `exp` and `actual`. But let's just get rid of this function
 and go with the method in my comment above.)

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +/* helper function, useful for viewing output */
 +void igraph_vector_t_print(igraph_vector_t *exp, igraph_vector_t
 *actual, int size) {
 +    for (int i = 0; i < size; i++) {
 +        double res = VECTOR(*exp)[i];
 +        double res_2 = VECTOR(*exp)[i];
 +        printf(""%lf %lf\n"", res, res_2);
 +    }
 +    printf(""\n"");
 +}
 Yet another issue here was that

 `for (int i=0; i < size; i++)
 `
 is not valid C89. The variable declaration cannot be inside of the
 `for`. Declarations must always go to the beginning of the block.

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > @@ -0,0 +1,287 @@
 +#include <igraph.h>
 +#include <stdio.h>
 +#include <math.h>
 It seems that the `math.h` header is not needed.

 In examples/tests/igraph_closeness.c
 <#1333 (comment)>:

 > +        int v1 = 1000000 * VECTOR(*v)[i];
 +        int v2 = 1000000 * VECTOR(*w)[i];
 +
 +        if (v1 != v2) {
 +            /* taking into account rounding up/down issues
 +            e.g. for intermediate case no weights
 +            100000 == 99999 */
 +            if (v2+1 != v1) {
 +                return 0;
 +            }
 +        }
 +    }
 +    return 1;
 +}
 +
 +int simple_test_case_no_weights_undirected() {
 Since the test functions don't actually return anything (the return
 value, which is always `0`, is never used), make them `void`.

 —
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub
 <#1333?email_source=notifications&email_token=AAJFEAFKP4TYAPYVAKGKI3TRFNTMTA5CNFSM4KWIJS22YY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCXQAH3Y#pullrequestreview-367002607>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAJFEADQFDQ7IMA2JOZPG2LRFNTMTANCNFSM4KWIJS2Q>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1333#issuecomment-593304669,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","It is possible to catch these using the -std=c89 compiler flag (supported by gcc and clang). The problem is that this is much too strict and disables stuff we rely on and is not easy to replace (such as isnan()). It also disables extensions that are sometimes used in igraph and which may potentially improve performance (inline).
What might work better is handpicking a number of relevant compiler flags to enable warnings and turn warnings into errors.
I am in favour of relaxing the standards in some reasonable way (I have asked for this in the past). But until that is done, and until we come to an agreement about which constructs are important to avoid (for compatibility without various older systems) and which are safe to use, I think it is better to be conservative and stick to the standards that we were using before.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1333#issuecomment-593306926,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).",BTW a good IDE that understands code and flags issues early can be really helpful. I use Qt Creator.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1333#issuecomment-593311605,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","I am in favour of relaxing the standards in some reasonable way (I have asked for this in the past)

We can switch to C99 once we drop support for Python 2.7 in python-igraph (which we did, in theory, after the release of 0.8.0). However, I'd still prefer to have variable declarations at the top of code blocks and not at random places throughout the code - it makes it easier to see what variables a particular code block relies on.
One thing that we need to confirm is that recent versions of Microsoft's C compiler are okay with a more modern dialect of C. It has been notoriously lagging behind in the past.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1333#issuecomment-593322299,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","I don't think any version of MSVC has full C99 support, and it is not a bad idea to keep supporting somewhat older versions too. Older MSVC versions definitely require declarations to be at the start of the block. It's actually really weird that they didn't throw an error about the for (int i=0; ...)
At this point, C99 would mostly give us convenience features. There is nothing in it that we need at this point. I do not want to risk compatibility (or creating extra work in the future to fix issues with an older system or older compiler) just to get some minor convenience.  The one exception is maybe //-comments which are very unlikely to cause problems with any compiler (and there are already multiple instances in the codebase).
When I said that I am in favour of relaxing standards, I was mainly thinking of C++11. We might want to integrate code which requires C++11. Porting C++11 to C++98 is often not at all easy (unlike porting C99 to C89).

@YasirKusay, for now, please try to stick to C89 and address the comments I made.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1333#issuecomment-593384725,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","@YasirKusay Thanks for the changes. Is there any reason you insist on using a custom printing function instead using what was already provided?
If you really want to use this printing function, e.g. to print as columns, then please remove the size argument. The size is encoded in the igraph_vector_t and should be retrieved from there instead of hard-coding it. Please also change the name of the printing function so it doesn't start with igraph_ (so people would not confuse it with an igraph API function in the future, and it wouldn't conflict with any API functions that may be added later).
That said, if there is any good reason not to re-use existing test facilities, please mention it. It would be preferable to improve the existing printing functions instead of coming up with a different alternative in each test program.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/YasirKusay,16,https://github.com/igraph/igraph/pull/1333#issuecomment-593388764,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","When I started work on this, I wrote the functions that I needed as I did not have as much knowledge of the functions back then. Is there a function that will enable me to print values from an igraph_vector_t type as I couldn't find one.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1333#issuecomment-593405107,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","There is a function for this purpose in examples/test/test_utilities.inc. This file is meant to be included as
#include ""test_utilities.inc""

in test programs, immediately after the usual header #includes. It is not part of igraph.
If you judge that this function is not suitable for this application, or not the best one, then we should think about whether an improved version could be useful for other (future) tests as well. If yes, we should include it in test_utilities.inc so people wouldn't have to re-invert their own helper functions in the future. If not, it's fine to create a one-time helper function just for this test.
For an example use of these utilities, see tree.c or simplify_and_colorize.c in examples/tests.
Let me know if you need any help with this! :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/iosonofabio,18,https://github.com/igraph/igraph/pull/1333#issuecomment-593616105,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","Let's keep the discussion on C89/99 for another day. Also for that day is the unrelated topic of using CI for what it's designed to do, which is catch these problems that might be hard to spot by the human eye.

@YasirKusay: feel free to drop in today and we can look into the print function and hopefully get this merged ;-)
…
On Tue, Mar 3, 2020, at 00:35, Szabolcs Horvát wrote:
 There is a function for this purpose in
 `examples/test/test_utilities.inc`. This file is meant to be included as

 `#include ""test_utilities.inc""
 `
 in test programs, immediately after the usual header `#include`s. It is
 not part of igraph.

 If you judge that this function is not suitable for this application,
 or not the best one, then we should think about whether an improved
 version could be useful for other (future) tests as well. If yes, we
 should include it in `test_utilities.inc` so people wouldn't have to
 re-invert their own helper functions in the future. If not, it's fine
 to create a one-time helper function just for this test.

 For an example use of these utilities, see `tree.c` or
 `simplify_and_colorize.c` in `examples/tests`.

 Let me know if you need any help with this! :-)

 —
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub
 <#1333?email_source=notifications&email_token=AAJFEAAKYHTT5IBT6Y3J7VDRFOY3VA5CNFSM4KWIJS22YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOENPKJMY#issuecomment-593405107>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAJFEAGATX4JJGOHRIISORLRFOY3VANCNFSM4KWIJS2Q>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1333#issuecomment-594396093,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","@YasirKusay If you have any questions or concerns, do not hesitate to ask. If you disagree with the changes I asked for, feel free to say so and explain why. That's how we find the best solution.
Let's merge this ASAP, then you can focus on more exciting things such as #1346",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/YasirKusay,20,https://github.com/igraph/igraph/pull/1333#issuecomment-594452128,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).",Oh no I had no issues with it. I did not get the chance to work on it until just now and it has been finalised. Sorry for any inconveniences.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1333#issuecomment-594453960,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","No inconvenience caused. Thanks for all your work on this!  Once the CI tests pass, I will squash the commits and merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1333,2020-02-17T00:37:16Z,2020-03-04T12:30:01Z,2020-03-04T12:36:32Z,MERGED,True,226,0,3,https://github.com/YasirKusay,Tests for closeness centrality calculations,1,[],https://github.com/igraph/igraph/pull/1333,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1333#issuecomment-594495439,"This is a new PR rebased on an updated master aimed at adding tests for igraph_closeness_estimate issue #1208.
DO NOT MERGE YET, FOR REVIEW ONLY (fixing the cutoff values).","Oops, I didn't realize that there was a ""squash and merge"" option and I squashed the commits right here on this branch. Sorry about that Yasir. We're all learning!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1334,2020-02-17T01:28:49Z,2020-02-17T20:24:01Z,2020-02-17T20:24:01Z,CLOSED,False,23,0,1,https://github.com/YasirKusay,"Issue #1180, new clean PR",1,[],https://github.com/igraph/igraph/pull/1334,https://github.com/YasirKusay,1,https://github.com/igraph/igraph/pull/1334,"This PR addresses issue #1180, which checks if there are loops or multi-edges in both directed/undirected graphs on runtime in the function, igraph_bridges.
DO NOT MERGE YET, WORK IN PROGRESS","This PR addresses issue #1180, which checks if there are loops or multi-edges in both directed/undirected graphs on runtime in the function, igraph_bridges.
DO NOT MERGE YET, WORK IN PROGRESS",True,{}
igraph/igraph,https://github.com/igraph/igraph,1334,2020-02-17T01:28:49Z,2020-02-17T20:24:01Z,2020-02-17T20:24:01Z,CLOSED,False,23,0,1,https://github.com/YasirKusay,"Issue #1180, new clean PR",1,[],https://github.com/igraph/igraph/pull/1334,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1334#issuecomment-587105414,"This PR addresses issue #1180, which checks if there are loops or multi-edges in both directed/undirected graphs on runtime in the function, igraph_bridges.
DO NOT MERGE YET, WORK IN PROGRESS","Hi Yasir,
I looked at the bridges algorithm again, and the fix to allow multigraphs turned out to be relatively simple. The algorithm kept track of the parent of each vertex in the DFS tree so that it wouldn't try to ""go back the way it came from"" during the DFS. In a multigraph, we need to keep track of the incoming edge instead. Please take a look at #1335
The problem with checking for multi-edges the way it is done here is that it worsens the complexity of the algorithm, due to the nested for loop, as you note.
Some tips for future PRs:
Please use /* ... */ comments only, as // is not valid in C89.
As Tamas noted, please put variable declarations to the start of a block.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1334,2020-02-17T01:28:49Z,2020-02-17T20:24:01Z,2020-02-17T20:24:01Z,CLOSED,False,23,0,1,https://github.com/YasirKusay,"Issue #1180, new clean PR",1,[],https://github.com/igraph/igraph/pull/1334,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1334#issuecomment-587146109,"This PR addresses issue #1180, which checks if there are loops or multi-edges in both directed/undirected graphs on runtime in the function, igraph_bridges.
DO NOT MERGE YET, WORK IN PROGRESS",PR obsoleted by #1335 by @szhorvat -- thanks for your work on this @YasirKusay!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1335,2020-02-17T17:53:09Z,2020-02-17T20:22:26Z,2020-12-03T19:06:50Z,MERGED,True,27,15,3,https://github.com/szhorvat,igraph_bridges: support multigraphs,2,[],https://github.com/igraph/igraph/pull/1335,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1335,"This PR fixes igraph_bridges so it supports multigraphs. Fixes #1180
After reviewing the algorithm, the fix turned out to be very simple: instead of keeping track of parents of vertices in the DFS tree, we keep track of the incoming edges. This is important only so that we don't try to ""go back the same way we came from"" during DFS.
There is still room for improvement here, in particular, we should get rid of the recursion to prevent any stack overflow. But that's for later.","This PR fixes igraph_bridges so it supports multigraphs. Fixes #1180
After reviewing the algorithm, the fix turned out to be very simple: instead of keeping track of parents of vertices in the DFS tree, we keep track of the incoming edges. This is important only so that we don't try to ""go back the same way we came from"" during DFS.
There is still room for improvement here, in particular, we should get rid of the recursion to prevent any stack overflow. But that's for later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1335,2020-02-17T17:53:09Z,2020-02-17T20:22:26Z,2020-12-03T19:06:50Z,MERGED,True,27,15,3,https://github.com/szhorvat,igraph_bridges: support multigraphs,2,[],https://github.com/igraph/igraph/pull/1335,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1335#issuecomment-587141892,"This PR fixes igraph_bridges so it supports multigraphs. Fixes #1180
After reviewing the algorithm, the fix turned out to be very simple: instead of keeping track of parents of vertices in the DFS tree, we keep track of the incoming edges. This is important only so that we don't try to ""go back the same way we came from"" during DFS.
There is still room for improvement here, in particular, we should get rid of the recursion to prevent any stack overflow. But that's for later.",Seems good to me! Is this ready to be merged? Would this affect #1334?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1335,2020-02-17T17:53:09Z,2020-02-17T20:22:26Z,2020-12-03T19:06:50Z,MERGED,True,27,15,3,https://github.com/szhorvat,igraph_bridges: support multigraphs,2,[],https://github.com/igraph/igraph/pull/1335,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1335#issuecomment-587144824,"This PR fixes igraph_bridges so it supports multigraphs. Fixes #1180
After reviewing the algorithm, the fix turned out to be very simple: instead of keeping track of parents of vertices in the DFS tree, we keep track of the incoming edges. This is important only so that we don't try to ""go back the same way we came from"" during DFS.
There is still room for improvement here, in particular, we should get rid of the recursion to prevent any stack overflow. But that's for later.","Yes, it's ready.
It obsoletes #1334 as that PR was about adding a check for multigraphs. We no longer need that since now the algorithm works correctly for multigraphs (and it already worked fine for self-loops). Originally I did not realize that the fix would be so easy.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1338,2020-02-24T23:44:19Z,2020-02-25T09:07:54Z,2020-02-25T09:07:54Z,MERGED,True,18,15,2,https://github.com/vtraag,Updated functions.def for R.,1,[],https://github.com/igraph/igraph/pull/1338,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1338,The functions.def file was not yet properly updated. We should probably also add this to the checklist for new (and exisiting) functions.,The functions.def file was not yet properly updated. We should probably also add this to the checklist for new (and exisiting) functions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1339,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1339#issuecomment-590830539,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"I would like to suggest bringing a bit more order to commit messages. I would not go as far as to make strict and inflexible rules (like MacPorts), as at this stage what will be too much of a burden for us. But we could come up with some guidelines which will make it easier to read commits.
One of these could be to mention which function is being modified.  For example,
avg_nearest_neighbor_degree(): fix memory leak

or similar.
It's just a suggestion. It will also help in preparing changelogs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1339#issuecomment-590831064,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,How about conventional commits?,True,{'ROCKET': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1339#issuecomment-590834973,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"I have no objection to that, but I must say that it looks a bit complicated. In the interest of not putting too many obstacles in front of external contributions, I would write a shorter summary with many igraph-specific examples.
So what would be the appropriate message for this change?
fix(avg_nearest_neighbor_degree): memory leak

The easiest way forward would be to just try to use it for a while, see if everyone likes it, and let igraph-specific conventions develop naturally.
If there are no objections, I will try to follow the Conventional Commits standard from now on.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1339#issuecomment-590850586,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"@szhorvat, you mean for commits or for PRs? I'm fine with doing this for PRs. Do you want me to update my initial PR comment? For commits it looks actually a bit overkill to me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1339#issuecomment-590850910,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,An alternative could be to also update the CHANGELOG.md with every PR?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1339#issuecomment-590895062,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"My original suggestion was to bring some (soft) order to commit message formats so that it is easier for all of us to keep track of what is happening (not specifically to construct a changelog, although it would make that easier too).
Mentioning avg_nearest_neighbor_degree in the commit message makes it easier to understand what was changed, should one ever have to skim through commits in the future.
Whether that is done with Conventional Commits or otherwise, I do not mind. Originally I was imagining something laid back that does not feel like a burden to anyone, but I can certainly follow the Conventional Commits standard too.
My comment referred to commit messages specifically, not to PRs (which are not part of the git repo).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1339#issuecomment-591027106,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"As far as I am concerned, following Conventional Commits will prove impractical. In practice, this will require a lot of rewriting commits when merging PRs (or asking people submitting a PR to properly rewrite their commits). Especially when responding to reviews of PRs this will involve commits of corrections (or fixes) of new features, which would be better rewritten as a single commit (as which point you lose the PR reviews). This can become quite burdensome I believe.
The question is what the goal is of following such a Conventional Commit type of style. If the goal is to simply have a more extensive description of a commit, as you suggest, that is fine. I'm used to making one-liner commits, but having a somewhat more extensive description could be fine. Having said that, I think the context (or scope) is quite clear from the commit itself. The file and function are clearly identifiable, and to my mind it would be doing double work to then state also explicitly in the commit message what part is affected. Isn't it immediately clear that when looking at the commit that is concerns igraph_i_avg_nearest_neighbor_degree_weighted?

If the goal is to help with maintaining the CHANGELOG, or making sure Semantic Versioning is followed, I think this will not be achieved in this way. To use it to keep track of (or even generate) a CHANGELOG we would need such a strict adherence to this that it becomes impractical, and a burden, as you say. If we want to maintain the CHANGELOG, I think it would be more doable to simply request to update the CHANGELOG with every PR. I think the PR is the more reasonable unit of work. It can consist of multiple interdependent commits which form a coherent whole, while each individual commit may only be adjusting relatively minor elements. Updating the CHANGELOG then after each PR (if necessary) sounds quite reasonable, and can also always be requested during the review of a PR.
In summary, I would suggest that, as long as the commit message is sufficiently descriptive, the exact format shouldn't matter. So, I don't object against using Conventional Commits, I just think we shouldn't require it of anybody in particular.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1339#issuecomment-591029771,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"Okay, let's keep it simple and forget about Conventional Commits for now.
Back to this PR: CI checks seem to have completed without problems - can I merge this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1339#issuecomment-591040699,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"If the goal is to simply have a more extensive description of a commit, as you suggest, that is fine.

Yes, that was my goal.

Isn't it immediately clear that when looking at the commit that is concerns igraph_i_avg_nearest_neighbor_degree_weighted?

Well, not always, at least not to me. The screenshot shows GitHub's special feature where it extracts the function name. The Git GUI I use is not that smart :-)

If the goal is to help with maintaining the CHANGELOG, or making sure Semantic Versioning is followed

No, that was not why I suggested it.

I think it would be more doable to simply request to update the CHANGELOG with every PR

I've been keeping an eye on the changelog since 0.8.0 and periodically verified that it was up to date. I would not enforce a changelog update in every PR because it will lead to merge conflicts.

In summary, I would suggest that, as long as the commit message is sufficiently descriptive, the exact format shouldn't matter.

I did not feel the need to make commits machine-readable, but I think it would be beneficial to improve human-readability. As time passes, I tend to get more and more (not less!) disciplined with documenting what I do. I have had too many bad experiences where something that seemed completely obvious made zero sense to me a few years later. Then I had to spend a couple of hours figuring out what I was originally thinking.
This applies much more to commenting code than to commit messages, but the two aren't entirely independent. Sometimes the only documentation of a change is the commit message.
Suppose we have some problem with the knn function in the future. If the commit message includes the function name, it'll be quicker to find relevant recent changes. Of course, it's still possible to find them (git's ""blame"") but with clearer messages it's even quicker (for a human).
So I think I'll try to keep adding a bit more context and will try to maintain clarity in commit messages, but I won't push others to do it too :-)  Here's what I did in the last few:",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1339#issuecomment-591292555,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"If the commit message includes the function name, it'll be quicker to find relevant recent changes.

OK, fair enough. I have indeed been using git blame or the interactive blame on GitHub to identify this. I have just force pushed the commit with a more appropriate commit message.

Back to this PR: CI checks seem to have completed without problems - can I merge this?

Yes, you can merge it. Probably best to await the CI to pass for the force pushed commit, but since there's nothing new, there shouldn't be any surprises.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1339#issuecomment-591350478,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"@ntamas , thanks for merging. @szhorvat , do you want me to update the CHANGELOG?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1339,2020-02-25T11:04:48Z,2020-02-26T10:10:21Z,2020-02-26T10:25:33Z,MERGED,True,5,1,1,https://github.com/vtraag,Some cleaning up of memory was not done properly.,1,[],https://github.com/igraph/igraph/pull/1339,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1339#issuecomment-591352954,Some vectors were not properly destroyed when calculating the weighted average nearest neighbour degree.,"do you want me to update the CHANGELOG?

Sure, go ahead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1340,2020-02-27T16:09:45Z,2020-03-03T11:57:10Z,2020-03-03T11:57:10Z,MERGED,True,2851,0,8,https://github.com/szhorvat,Ensure that all licenses are noted and included.,1,[],https://github.com/igraph/igraph/pull/1340,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1340,"This PR notes the licenses of all included code and all linked-to libraries.
The ACKNOWLEDGEMENTS.md files has all copyright lines, and either includes the full license text or references licenses. Referenced licences are in doc/licenses. I believe that shipping all these (ACKNOWLEDGEMENTS.md and doc/licenses) with binary distributions will be sufficient.
plfit is now marked a GPLv2+. We can correct this depending on the decision Tamás makes.
The only other change is the addition of a Copyright.txt file in msvc/include/libxml.
As far as I could tell, all other code has the license noted. It is either included in a separate file in the directory where the code lives, or it is noted in the source files (when the source has only a reference, the full license text is found in doc/licenses).","This PR notes the licenses of all included code and all linked-to libraries.
The ACKNOWLEDGEMENTS.md files has all copyright lines, and either includes the full license text or references licenses. Referenced licences are in doc/licenses. I believe that shipping all these (ACKNOWLEDGEMENTS.md and doc/licenses) with binary distributions will be sufficient.
plfit is now marked a GPLv2+. We can correct this depending on the decision Tamás makes.
The only other change is the addition of a Copyright.txt file in msvc/include/libxml.
As far as I could tell, all other code has the license noted. It is either included in a separate file in the directory where the code lives, or it is noted in the source files (when the source has only a reference, the full license text is found in doc/licenses).",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1340,2020-02-27T16:09:45Z,2020-03-03T11:57:10Z,2020-03-03T11:57:10Z,MERGED,True,2851,0,8,https://github.com/szhorvat,Ensure that all licenses are noted and included.,1,[],https://github.com/igraph/igraph/pull/1340,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1340#issuecomment-592173845,"This PR notes the licenses of all included code and all linked-to libraries.
The ACKNOWLEDGEMENTS.md files has all copyright lines, and either includes the full license text or references licenses. Referenced licences are in doc/licenses. I believe that shipping all these (ACKNOWLEDGEMENTS.md and doc/licenses) with binary distributions will be sufficient.
plfit is now marked a GPLv2+. We can correct this depending on the decision Tamás makes.
The only other change is the addition of a Copyright.txt file in msvc/include/libxml.
As far as I could tell, all other code has the license noted. It is either included in a separate file in the directory where the code lives, or it is noted in the source files (when the source has only a reference, the full license text is found in doc/licenses).","plfit will be licensed as GPLv2+ from version 0.8; I'm in the process of incorporating it into igraph but it takes more time than expected because the computation of p-values changed between plfit 0.6 and 0.7 (plus there are other minor discrepancies in the results). But anyway, it's coming soon.
Re the included licenses: the license files for GPLv2 and GPLv3 contain an additional section about ""How to Apply These Terms to Your New Programs"". I think these sections should be removed from the license files that we include.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1340,2020-02-27T16:09:45Z,2020-03-03T11:57:10Z,2020-03-03T11:57:10Z,MERGED,True,2851,0,8,https://github.com/szhorvat,Ensure that all licenses are noted and included.,1,[],https://github.com/igraph/igraph/pull/1340,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1340#issuecomment-592178426,"This PR notes the licenses of all included code and all linked-to libraries.
The ACKNOWLEDGEMENTS.md files has all copyright lines, and either includes the full license text or references licenses. Referenced licences are in doc/licenses. I believe that shipping all these (ACKNOWLEDGEMENTS.md and doc/licenses) with binary distributions will be sufficient.
plfit is now marked a GPLv2+. We can correct this depending on the decision Tamás makes.
The only other change is the addition of a Copyright.txt file in msvc/include/libxml.
As far as I could tell, all other code has the license noted. It is either included in a separate file in the directory where the code lives, or it is noted in the source files (when the source has only a reference, the full license text is found in doc/licenses).","but it takes more time than expected

I think we're not in a rush.

""How to Apply These Terms to Your New Programs"". I think these sections should be removed from the license files that we include.

Done.
Keep the comments coming. Once everyone is happy, I will squash all the commits to keep things tidy. Please do not merge until then.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1340,2020-02-27T16:09:45Z,2020-03-03T11:57:10Z,2020-03-03T11:57:10Z,MERGED,True,2851,0,8,https://github.com/szhorvat,Ensure that all licenses are noted and included.,1,[],https://github.com/igraph/igraph/pull/1340,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1340#issuecomment-593885005,"This PR notes the licenses of all included code and all linked-to libraries.
The ACKNOWLEDGEMENTS.md files has all copyright lines, and either includes the full license text or references licenses. Referenced licences are in doc/licenses. I believe that shipping all these (ACKNOWLEDGEMENTS.md and doc/licenses) with binary distributions will be sufficient.
plfit is now marked a GPLv2+. We can correct this depending on the decision Tamás makes.
The only other change is the addition of a Copyright.txt file in msvc/include/libxml.
As far as I could tell, all other code has the license noted. It is either included in a separate file in the directory where the code lives, or it is noted in the source files (when the source has only a reference, the full license text is found in doc/licenses).",There were no comments in the last five days; can this be merged now?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1340,2020-02-27T16:09:45Z,2020-03-03T11:57:10Z,2020-03-03T11:57:10Z,MERGED,True,2851,0,8,https://github.com/szhorvat,Ensure that all licenses are noted and included.,1,[],https://github.com/igraph/igraph/pull/1340,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1340#issuecomment-593913049,"This PR notes the licenses of all included code and all linked-to libraries.
The ACKNOWLEDGEMENTS.md files has all copyright lines, and either includes the full license text or references licenses. Referenced licences are in doc/licenses. I believe that shipping all these (ACKNOWLEDGEMENTS.md and doc/licenses) with binary distributions will be sufficient.
plfit is now marked a GPLv2+. We can correct this depending on the decision Tamás makes.
The only other change is the addition of a Copyright.txt file in msvc/include/libxml.
As far as I could tell, all other code has the license noted. It is either included in a separate file in the directory where the code lives, or it is noted in the source files (when the source has only a reference, the full license text is found in doc/licenses).","As far as I'm concerned, it is good.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1341,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.","As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1341#issuecomment-592563353,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.","So should this be included in 0.8.1 even though it's adding to the API? Personally I am not against including it in 0.8.1, but it's also very easy to merge only after 0.8.1 is out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1341#issuecomment-592573694,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.",I'm fine with merging this after 0.8.1.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1341#issuecomment-592599687,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.",Let's postpone this to 0.9 to be consistent with semantic versioning.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1341#issuecomment-610607822,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.","Actually, now that I think of it: we can actually merge this in master, given our policy of that it has to be backwards-compatible with previous minor releases. This PR only adds to the API. Do you agree?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1341#issuecomment-610815879,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.","Sure, I'm okay with that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1341,2020-02-28T13:54:42Z,2020-05-26T12:17:50Z,2020-05-26T20:08:02Z,MERGED,True,52,3,4,https://github.com/vtraag,Made vector_binsearch_slice public,1,['todo'],https://github.com/igraph/igraph/pull/1341,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1341#issuecomment-633892868,"As discussed in #981 (comment), we decided to make igraph_vector_binsearch_slice properly public, because the igraph_community_leiden was improperly relying on the igraph_i_vector_binsearch_slice function.
In accordance with our earlier discussion in #1219 (comment), I made an internal version, igraph_i_vector_binsearch_slice (which is used by igraph_vector_intersect_sorted, for which it is properly defined) which does not perform any argument checking, and a public version igraph_vector_binsearch_slice, which checks arguments. From the perspective of igraph as a whole, igraph_community_leiden should be allowed to use ""internal"" functions that perform no argument checking. This then in turn begs the question of how to deal exactly with these type of internal functions that should be included in a proper (internal) header. For now igraph_community_leiden simply uses the public igraph_vector_binsearch_slice to keep it simple.","@ntamas It seems you made essentially the same change as this PR here:
f525ef3
We should merge this ASAP.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1342,2020-02-28T15:27:34Z,2020-02-28T20:00:25Z,2020-02-28T20:00:26Z,MERGED,True,5,0,1,https://github.com/szhorvat,plfit: ensure math.h defines are present with MSVC,1,[],https://github.com/igraph/igraph/pull/1342,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1342,"Hopefully this will fix the missing M_LN2. See this test failure:
https://ci.appveyor.com/project/ntamas/igraph/builds/31127044/job/rpktetnh87thu4x3#L4306","Hopefully this will fix the missing M_LN2. See this test failure:
https://ci.appveyor.com/project/ntamas/igraph/builds/31127044/job/rpktetnh87thu4x3#L4306",True,{}
igraph/igraph,https://github.com/igraph/igraph,1342,2020-02-28T15:27:34Z,2020-02-28T20:00:25Z,2020-02-28T20:00:26Z,MERGED,True,5,0,1,https://github.com/szhorvat,plfit: ensure math.h defines are present with MSVC,1,[],https://github.com/igraph/igraph/pull/1342,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1342#issuecomment-592598455,"Hopefully this will fix the missing M_LN2. See this test failure:
https://ci.appveyor.com/project/ntamas/igraph/builds/31127044/job/rpktetnh87thu4x3#L4306","@ntamas I made a mistake and forgot to push a small modification (which I thought I pushed). I guess it makes more sense to put this in platform.h (then change the order of includes so math.h is included through platform.h).
Take another look at let me know which version you want. Then I'll update the PR and squash the commits.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1342,2020-02-28T15:27:34Z,2020-02-28T20:00:25Z,2020-02-28T20:00:26Z,MERGED,True,5,0,1,https://github.com/szhorvat,plfit: ensure math.h defines are present with MSVC,1,[],https://github.com/igraph/igraph/pull/1342,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1342#issuecomment-592598885,"Hopefully this will fix the missing M_LN2. See this test failure:
https://ci.appveyor.com/project/ntamas/igraph/builds/31127044/job/rpktetnh87thu4x3#L4306",Seems OK to me. Do you mind if I also include this in ntamas/plfit?,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1342,2020-02-28T15:27:34Z,2020-02-28T20:00:25Z,2020-02-28T20:00:26Z,MERGED,True,5,0,1,https://github.com/szhorvat,plfit: ensure math.h defines are present with MSVC,1,[],https://github.com/igraph/igraph/pull/1342,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1342#issuecomment-592676076,"Hopefully this will fix the missing M_LN2. See this test failure:
https://ci.appveyor.com/project/ntamas/igraph/builds/31127044/job/rpktetnh87thu4x3#L4306","It's good to merge now.
I went back to the original change because the header reordering caused another failure that I couldn't fix (or didn't have the patience for).
https://ci.appveyor.com/project/ntamas/igraph/builds/31131963/job/nu8srmk8x061el43#L4310
The only difference from the change you made in the plfit repo is that I also added the hzeta.h header (my IDE was complaining about missing declarations).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1344,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1344#issuecomment-592996481,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","Note that I started a new file, shortest_paths.c. structural_properties.c is too large (7000+ lines). Eventually, all shortest path stuff can be moved over to this file.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1344#issuecomment-593075891,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","Thanks for this contribution @szhorvat! I will have to review it some later time (but that should not be a problem if it is only for 0.9).
For now, I would just like to comment on the merging of PRs and the maintenance of different versions. If we want to respect Semantic Versioning (which we do), I think we will really need to have separate branches. Right now there are two PRs in the pipeline for 0.9 (this PR and PR #1341), and the longer we wait, the more conflicts we will get when we only start merging those PRs when we want to release 0.9. If, instead, we can simply merge these PRs to a develop branch (which may be unstable), other PRs that target 0.9 can simply build on that branch. Otherwise, all new PRs that target 0.9 (i.e. introduce some API change) will always need to be based on the master branch, which by definition will not (yet) include those changes intended for 0.9. For example, if you want to now push another PR for shortest paths that builds on this PR, you cannot, unless you also include all of the changes in this PR in the new PR, which the whole workflow very opaque.
Finally, note that some changes are backwards compatible (I believe both this PR and PR #1341 are backwards compatible). Since we are in development versioning still (0.x), an increment of the MINOR version number could be restricted to backwards incompatible changes, while backwards compatible changes might not need to trigger an increment in the MINOR version number. This means that, in principle, we could allow this PR and PR #1341 to merge already in a 0.8.x release. I'm fine with leaving both PRs for 0.9, but I just wanted to raise this point, because at some point we may want to include backwards compatible changes in a 0.8.x release. So perhaps it would be good to already discuss this point now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1344#issuecomment-593080354,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","I did not forget that we were going to change the branching structure. It's not a concern. I'll (figure out how to) move the PR over to the develop branch when that is created. For now, it's a draft (and I'm still fixing some bugs just now).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1344#issuecomment-593082097,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","OK, good! Yes, it's no problem retargeting the PR to a develop branch, whenever we created it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1344#issuecomment-593109150,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","Before this can go ahead, we must make a decision about #1345. This PR adds a weighted average shortest path implementation, which creates a similar inconsistency as the diameter calculation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1344#issuecomment-594195898,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","@vtraag I need some help. This PR changes the signature of igraph_average_path_length and adds the unconn_pairs output argument.
https://github.com/igraph/igraph/pull/1344/files#diff-0940a69f1637f0b1b42209a7c34179d1R113
It is okay to just pass NULL for this argument if one does not want the result.
What is the proper way to include this in functions.def? I am hoping that it's easy to just set it to NULL there and not expose it in the R interface for now. I don't have the expertise to update the R interface.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1344#issuecomment-603407897,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()",@vtraag Just a small reminder about the above question. I am not very confident poking around in the functions.def file,True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1344#issuecomment-603538512,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","@szhorvat , regarding the functions.def I believe this is now correct. The changes will require some further changes in the R interface, since igraph_average_path_length is called directly in rinterface.c.in, so that it doesn't use the generated one from functions.def (if I understand the process correctly). But this only needs to be (and can be) changed when the R interface starts using the C core that includes this PR. We need to make sure the CHANGELOG is properly updated, so that we keep track of this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/jgmbenoit,10,https://github.com/igraph/igraph/pull/1344#issuecomment-649620324,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","Concerning the bibliography, the PRL letter was followed by a long articlem in EPJB:
https://doi.org/10.1140/epjb/e2003-00095-5",True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1344#issuecomment-712657183,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()",Note to self: the feature/cmake-build branch needs to be updated separately to make sure that the new test is called with CMake.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1344,2020-02-29T21:21:21Z,2020-10-20T09:28:16Z,2020-10-20T09:28:16Z,MERGED,True,1353,436,12,https://github.com/szhorvat,Implement global/local efficiency and weighted average shortest paths,27,['todo'],https://github.com/igraph/igraph/pull/1344,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1344#issuecomment-712659084,"This PR implements global and local efficiency.
Global: https://dx.doi.org/10.1103/PhysRevLett.87.198701
Local: http://dx.doi.org/10.1103/PhysRevE.71.036122 (this is a modification/improvement of the ""local efficiency"" from the previous paper)
These measures are based on averaging not shortest path lengths, but their inverses. This makes it easy to handle non-connected vertex pairs, as their distance can be taken to be infinity, and inverse distance 0.
Since it's closely related, this PR also adds weighted average shortest path computation, and modifies the unweighted one too to reduce code duplication.
Still, there is a lot of code duplication. Much of this is copy/paste from other shortest path implementations with modifications on top. Ideally, eventually we would somehow unify the various implementations without a performance hit. Doing this in C is not easy (C++ would make it easier with templates). I am thinking of something like the preprocessor-based templating used in the maximal clique implementation. Unfortunately, that is ugly, very hard to work with (my IDE can't handle it), and quite a bit of work to get right. So for now, I just went with the copy/paste + modify approach. I needed this functionality right now (with good performance).
Naturally, this is for 0.9. Marked as draft, but it is ready for a basic review. Please comment.
Fixes #1343

Summary of changes
Added

igraph_average_path_length_dijkstra() (#1343)
igraph_global_efficiency()
igraph_local_efficiency()
igraph_average_local_efficiency()

Changed

Create a file shortest_paths.c and moved over these functions from structural_properties.c: average_path_length(), diameter(), diameter_dijkstra()
igraph_average_path_length() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)
igraph_average_path_length() now also returns the number of unconnected ordered vertex pairs.
igraph_diameter() now returns an igraph_real_t instead of an igraph_integer_t
igraph_diameter() now returns IGRAPH_INFINITY when unconn=false and the graph is not connected (#1345)

Fixed

All functions moved to shortest_paths.c now use igraph_free()/igraph_Free() instead of free()","Okay, it looks good to me, assuming that we can make the tests pass :)
I assumed that there were no significant changes to the shortest path routines that were moved to shortest_paths.c from structural_properties.c that would need my review.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,1,https://github.com/igraph/igraph/pull/1346,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1346#issuecomment-593268396,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I am not sure as how I can include my files into the compiling and tests steps, can you please help me?

You can add the .c and .h files to src/Makefile.am, to the SOURCES and HEADERS_PUBLIC sections, respectively. Before you can do this, any main must be removed.
I know that you are still working on this, but when it is done there must be no printing in the code.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1346#issuecomment-593283913,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","A few more comments:

Please stick to the C89 standard (notice // comments and variable definitions not at the start of the block).
Follow igraph's function naming conventions (igraph_is_eulerian())
Any igraph function that can fail in any way must return an error code (not a result). Results are returned through arguments passed by reference.
Arguments passed by reference that won't be modified must be const (const igraph_t *graph)
igraph_t copy = *graph does not make a copy. See igraph_copy().",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,4,https://github.com/igraph/igraph/pull/1346#issuecomment-602130734,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, I apologise for my inactivity and I will get back to working on this now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,5,https://github.com/igraph/igraph/pull/1346#issuecomment-602175158,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, I am very close to finishing but when calling make, there are no warnings/errors but there is a ""linker command failed with exit code 1 issue"", could you help me with this issue?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1346#issuecomment-602178093,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",Not without more details. We need to see what you have (or at least the complete error message from the linker).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,7,https://github.com/igraph/igraph/pull/1346#issuecomment-602179366,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1346#issuecomment-602189338,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","The linking error relates to address sanitizer. Have you tried compiling without that?
It's not really possible to say more without knowing what you are doing exactly (each step described precisely).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,9,https://github.com/igraph/igraph/pull/1346#issuecomment-602199136,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I am following the compilation steps on: https://igraph.org/c/#docs
./configure
make
make check
make install
./configure worked fine, but when calling make (the next step), it presented me with the error above",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1346#issuecomment-602200476,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","AddressSanitizer is not enabled by default. Are you certain that this is precisely what you did and nothing else? I do not see how ASAN would get in there otherwise.
Did you do a make distclean before changing any ./configure arguments? Did you change any compiler flags (CFLAGS variable or similar)?
Please try to do it again with a clean source tree.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,11,https://github.com/igraph/igraph/pull/1346#issuecomment-602963560,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I apologise for asking a pretty trivial issue here, however, when calling one of the functions that I wrote into my test file, it says implicit declaration of that function.

Ive made sure to have all the necessary includes in my files and also to have declared my new functions and function file in all necessary locations.
Are there any locations that I may be missing? What would you recommend I do?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1346#issuecomment-603076308,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Ive made sure to have all the necessary includes in my files and also to have declared my new functions and function file in all necessary locations.

The error message says that this is not the case. The declaration is not included into this test file.
It is not possible to say more than this without seeing what you have. If you are stuck, I suggest you push the changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,13,https://github.com/igraph/igraph/pull/1346#issuecomment-603100654,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Ive push all my changes to you, hopefully you can see them now",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1346#issuecomment-603111123,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","The prototype is not included in your test file: it is only present in igraph_eulerian.h, but that file is not included in igraph.h (it should be). You only have #include <igraph.h> in your test file. So the contents of igraph_eulerian.h are not visible from your test file.
#include literally includes the entire contents of the included file. The prototype must be in some way included in the file where the function is going to be used.
Are you familiar with how includes and prototypes work?

Let us know when you are ready to start receiving feedback. There are quite a few issues, such as things that should not be part of the public API are put in a public header, and naming conventions not being followed. Maybe you are aware of these, but have not yet finalized them?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,15,https://github.com/igraph/igraph/pull/1346#issuecomment-603122538,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Thank you for your reply, I am aware of how includes and prototypes work. It was a silly mistake as  I forgot to include it into igraph.h.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1346#issuecomment-603132157,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","One more thing that's worth mentioning now:

When calling any function that returns an error code, it must be wrapped in IGRAPH_CHECK
Any function that has IGRAPH_CHECK in it must return an error code (because that's what IGRAPH_CHECK does: it returns with an error code when something goes wrong)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,17,https://github.com/igraph/igraph/pull/1346#issuecomment-603246353,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, I am pretty close to completion. The is_eulerian function works as expected and the function to find eulerian paths works partially, for undirected graphs. For directed graphs, testing them separately worked fine but in the igraph_eulerian file that I have committed, I am getting an assertion failure (where no < 100) in the igraph_finally_real function and I traced that issue to the delete_edges function. I am going to stop working on it now and will resume working on it tomorrow after work. I believe that I can finish by the end of tomorrow.
Furthermore, I would like to add that I am storing paths as igraph_vector_t momentarily and I will change it to a more appropriate type at the end.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1346#issuecomment-603332819,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I am getting an assertion failure (where no < 100) in the igraph_finally_real function

This is usually an indication that the number of IGRAPH_FINALLYs does not match the number of IGRAPH_FINALLY_CLEANs.

I believe that I can finish by the end of tomorrow.

There's no rush, and also no need to have everything 100% complete before you ask for feedback. Just let us know when it's ready for some feedback.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,19,https://github.com/igraph/igraph/pull/1346#issuecomment-603714527,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Could you help me understand that issue in the context of my code? By looking closer, I noticed that the program breaks with the above invocation (assertion failure where no < 100) on line 317 of igraph_eulerian.c where I am calling igraph_delete_edges(graph, es); I call the same function for the non directed graph case and the worked fine but in the case of this, it presents me issues.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1346#issuecomment-603732482,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","If you are not sure what a certain function or macro does exactly, please ask instead of copying usage patterns from elsewhere. Doing that blindly will lead to errors that will be hard to fix later.
IGRAPH_FINALLY and related macros are documented here:
https://igraph.org/c/doc/igraph-Error.html#igraph-deallocatingmemory
The purpose of IGRAPH_FINALLY is to register a data structure for deallocation in case of error or interruption. If the function succeeded (no error or interruption), the registered deallocation commands must be cleaned up (removed) with IGRAPH_FINALLY_CLEAN right after the deallocation is performed manually.
Here you use IGRAPH_FINALLY, but there is no matching IGRAPH_FINALLY_CLEAN at the end of the function. Since you registered two cleanup instructions (two igraph_stack_destroys), you need IGRAPH_FINALLY_CLEAN(2) right after you call igraph_stack_destroy() manually at the end.
Does this clarify things? Let me know if you have more questions.
Be very careful with this as with complicated algorithms it can be hard to keep track of how many things have been registered. It is critical that precisely the same number are cleaned.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1346#issuecomment-603742079,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Yes, having to use these macros is pretty annoying, especially if you are familiar with exceptions in C++. But in C, we don't really have any better choices. Sometimes I really wish igraph were written in C++ ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1346#issuecomment-603751697,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Should this have been a 1?
b9ccea6#diff-272142b27a0fb1dab2fdde056555e68cR275",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,23,https://github.com/igraph/igraph/pull/1346#issuecomment-603752759,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","(Thanks for pointing the above out).
It appears to be working fine now, you can go ahead and give me feedback.
There is something I am interested in though, I really like the igraph_vector_t type and find that it is very flexible to work with (I store all paths inside it). However, it would make more sense to store the result as an int (it would make no sense to denote a vertice as a float). Are there any similar functions to igraph_vector_t that I can use?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1346#issuecomment-603762201,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","It looks like the functions return vertex IDs. An Eulerian path (circuit) consists of edges, not vertices. A list of edge IDs should be returned, not vertex IDs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1346#issuecomment-603763677,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I added a few comments (not a review, as there's still a lot to be done). Most comments apply to many parts of the code, not just where they were added.
As for storing vertex or edge IDs as double instead of integers, yes, this is not good, and it is a leftover from earlier days of igraph. We plan to fix this throughout the code base for version 1.0. For now, please continue returning an igraph_vector_t because any function that expects vertex/edge IDs as input takes this type. In other situations (e.g. internal use), if you need an integer vector, there's igraph_vector_int_t (which you already used).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,26,https://github.com/igraph/igraph/pull/1346#issuecomment-603769361,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Thank you for your extensive and speedy feedback. I am happy to change the implementation such that edge id's are stored, rather than vertex id's. Rather than returning the result as just edge id's, would you like to have an extra feature (perhaps an extra parameter in the function), giving the user the option to return the result as vertex id's or edge id's?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1346#issuecomment-604361541,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Rather than returning the result as just edge id's, would you like to have an extra feature (perhaps an extra parameter in the function), giving the user the option to return the result as vertex id's or edge id's?

It wouldn't hurt I guess ... but my opinion is that it is better to stick to returning edges only, to avoid user confusion.
Returning vertices is a very minor convenience; one can easily compute this with good performance from the edges. If we wanted to provide such a convenience, it would better be implemented as a separate function that transforms an edge-walk to a vertex-walk.

On a related note, did you verify the algorithm for multigraphs and graph with self-loops? We should aim for an implementation that supports both.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,28,https://github.com/igraph/igraph/pull/1346#issuecomment-605437336,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I guess it would make sense to store edge id's rather than vertex id's. I will modify it as such.
As per the second question, I have not but plan on expanding the tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,29,https://github.com/igraph/igraph/pull/1346#issuecomment-605443071,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",Also consider what happens when calling the function with the null graph (no vertices) or with a non-connected graph.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,30,https://github.com/igraph/igraph/pull/1346#issuecomment-605443148,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",Can you give a summary of the proposed public API (just post the prototypes here in the comments and explain the meaning of any arguments if they're not obvious)?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,31,https://github.com/igraph/igraph/pull/1346#issuecomment-605451231,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","igraph_is_eulerian(igraph_t *graph) -> pretty much takes any graph and determines if it is eulerian or not. The function automatically determines if it is directed or not.
igraph_eulerian_paths(igraph_t *graph, igraph_vector_t *res) -> takes any graph and finds the eulerian path/cycle and stores that in res. Similar to the above, it automatically determines if the graph is directed or not.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,32,https://github.com/igraph/igraph/pull/1346#issuecomment-605453950,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Does it find a path or a cycle?
You used the name paths. Does it find a single path or multiple?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,33,https://github.com/igraph/igraph/pull/1346#issuecomment-605537365,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Just a single path, it can also find cycles",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,34,https://github.com/igraph/igraph/pull/1346#issuecomment-605598670,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@YasirKusay  This is not what I was asking for. You posted what you have now, without addressing any of the issues I brought up 4 days ago. This version is not going to work.
Before you go on to fix anything, it is a good idea to do a little planning.
I suggest you plan the final API, which hopefully will need no more adjustments,  and show us what you propose. Make sure you address all the issues.  Describe anything that is not obvious (i.e. write a small version of the documentation, what is each argument, what is the return value).

You didn't address the return value issue with igraph_is_eulerian. Also, document the meaning of the result—what does ""Eulerian"" mean? Address a naïve user, new to the concept.
Why paths and not path if returning one?
How does a naïve user know if they are going to get a path or a cycle?
What is being returned through the *res argument?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,35,https://github.com/igraph/igraph/pull/1346#issuecomment-605600302,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",@YasirKusay why don't we skype tomorrow afternoon and go through these together? It might be easier that way,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,36,https://github.com/igraph/igraph/pull/1346#issuecomment-605795414,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, I just spoke with Fabio and here is what we decided that I should do:
Here is the proposed public API:
int igraph_is_eulerian(igraph_t *graph) -> this takes a pointer to the graph determines if it has a path, cycle, or neither, and the function will return 2, 1 or 0 respectively. It can do this for both directed and undirected graphs. An eulerian path is a trail that visits exactly each edge once, and a eulerian cycle is also a trail that visits exactly each edge once, but also starts and ends on the same vertex.
I understand that the user may be confused by the use of ""paths"", as it implies that my function is going to return multiple paths when it will only return 1. Therefore:
int igraph_eulerian_path(igraph_t *graph, igraph_vector_t *res) -> this takes a pointer to a graph to which it will find an eulerian path for, and store the edge id trail in res. It will return an error if there are no paths in the graph.
Furthermore, although the way I have written the function ""igraph_eulerian_path"" to be able to find paths and cycles, I understand that a user may be confused by this and not know if they are getting a path or a cycle, and therefore, I will write an extra function:
int igraph_eulerian_cycle(igraph_t *graph, igraph_vector_t *res), taking a pointer to a graph to which it will find a eulerian cycle for, and store the edge id trail in res. It will return an error if there are no cycles in the graph.
I will modify the implementation of igraph_eulerian_path/igraph_eulerian_cycle such that it will store edge id's rather than vertex id's.
In the future, if these functions get merged, I can try to write extra functions, e.g. igraph_eulerian_paths, that will return more than one eulerian path, and igraph_eulerian cycles, that will return more than one eulerian cycles.
Finally, with respect the the failed checks, it appears that this is because of a small issue to do with linux that I have not had in mac, where I wrote my implementation. I will make a commit today that will fix the issue.
I hope this has been of help, if you have any extra questions, please let me know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,37,https://github.com/igraph/igraph/pull/1346#issuecomment-605804454,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Your current implementation of igraph_is_eulerian uses functions that can fail. Therefore, igraph_is_eulerian itself can fail. As I said above in several messages, this means that it must return an error code. In fact, you currently use IGRAPH_CHECK in its implementation, and IGRAPH_CHECK effectively includes return error_code.
Furthermore, igraph's public API only uses int for error codes. For integers, it uses igraph_integer_t. For collections of discrete values, each encoding a meaning, enums are more appropriate.
In this case, please use the following prototoype:
int igraph_is_eulerian(const igraph_t *graph, igraph_bool_t *has_path, igraph_bool_t *has_cycle);

The return value is an error code. The existence of paths/cycles is returned through two output arguments.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,38,https://github.com/igraph/igraph/pull/1346#issuecomment-605817587,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I understand what you mean now, and I will change it such that it follows your prototype.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,39,https://github.com/igraph/igraph/pull/1346#issuecomment-605846243,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",good idea @szhorvat that signature is even better,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,40,https://github.com/igraph/igraph/pull/1346#issuecomment-626801738,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",Thank you for all your feedback. I will continue refining my implementation tomorrow.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,41,https://github.com/igraph/igraph/pull/1346#issuecomment-629587932,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, just a quick update I have decided that rather than deleting edges during the eulerian walk, I will instead have a list of visited and unvisited edges. A visited edge will essentially be similar to a ""deleted"" edge and the advantages of this are that I will avoid issues to do with the edge id's being changed when the edges are deleted.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,42,https://github.com/igraph/igraph/pull/1346#issuecomment-629666340,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, I have just finished implementing the changes that I said I would do in my last comment on this pull request. It appears to be working fine but I will need to do further tests to ensure that this is working correctly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,43,https://github.com/igraph/igraph/pull/1346#issuecomment-631323134,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",Let us know when all the comments I made previously have been addressed. I'll take a more detailed look then.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,44,https://github.com/igraph/igraph/pull/1346#issuecomment-631382881,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I believe that I have addressed all your comments. However, with respect to the comment you made about weak connectivity in a directed graph being insufficient is not necessarily true. For example, 0->1->2  is not a strongly connected graph, but it does have an eulerian path. While it is true that for a directed graph to have a circuit, it must be strongly connected, a directed graph that has a path does not need to be strongly connected (0->1->2).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,45,https://github.com/igraph/igraph/pull/1346#issuecomment-631397923,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Yes, you are correct. Sorry about that. You can respond to comments directly. Please do respond directly, even if you believe that a comment was addressed, so we can more easily keep track.
However, I see several unaddressed comments. Can you please address all of them, including seemingly cosmetic ones? Do not introduce unnecessary variables in tests. Remove all unneeded #includes, there is still a comment about is_eulerian_undirected returning 0, 1 or 2, etc. It would be great if you could try to make the PR merge-ready.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,46,https://github.com/igraph/igraph/pull/1346#issuecomment-631423546,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@iosonofabio Could you please look through this PR when @YasirKusay says that it is ready?
@YasirKusay It might be a good idea to look through all the old individual comments I made, to see if anything was missed (I would need to do that too, as I do not remember all of them). Just check above in this thread, and make sure you click the ""Load more"" button to see all of them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,47,https://github.com/igraph/igraph/pull/1346#issuecomment-631424318,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@szhorvat
I will do that. Thank you for your reviews.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,48,https://github.com/igraph/igraph/pull/1346#issuecomment-631429444,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I have some pressing deadlines at the moment, but I'll take a detailed look at the algorithm, and will do a comprehensive review during the upcoming couple of weeks. Thanks for all the work you put into this @YasirKusay !",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,49,https://github.com/igraph/igraph/pull/1346#issuecomment-631746388,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@szhorvat Yasir and I had a chat just yesterday.
Honestly this PR raises a warning for igraph development I think. In this particular case, I am not sure going back through 80 messages looking for unaddressed comments is particularly robust, but we'll do it anyway because that's the way things are now - your time is greatly appreciated as well @szhorvat, thank you for that.
However it is very difficult for new developers, despite a good training in CS, to contribute to igraph if every PR needs to be pitch perfect before merging. I would advocate for lowering that bar and going through a few routine checks as a second step before merging the development branch into master. Anyway, I'll open a thread on the discourse.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,50,https://github.com/igraph/igraph/pull/1346#issuecomment-633834182,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Here a list of things that still need fixing:

 ignore vertices with degree 0
 add public functions to functions.def for R interface
 rebase against dev and change target
 IGRAPH_CHECK in all needed places
 add a note to CHANGELOG.md
 documentation (in progress)
 try and figure out runtime complexity
 recode the undirected graph function as Hierholzer's
 pass tests on Travis
 maybe rename non-API functions
 pass tests on AppVeyor (should work again in a few days)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/ntamas,51,https://github.com/igraph/igraph/pull/1346#issuecomment-634007704,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Regarding Appveyor: you need to install zstd in the build setup; some of the packages that MSYS2 tries to install are compressed with zst, but it is not installed by default. I believe I fixed it already in the master branch, but this PR was forked off before that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,52,https://github.com/igraph/igraph/pull/1346#issuecomment-634009776,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","To avoid confusion: the response from @ntamas was to a post I made earlier today, but then deleted (as I didn't want a link back to here from the msys2 repo, where I referenced a bug).
I think Appveyor will be broken for a few days anyway, see https://igraph.discourse.group/t/appveyor-currently-broken/245/5",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,53,https://github.com/igraph/igraph/pull/1346#issuecomment-634012100,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",@iosonofabio @YasirKusay One more for the TODO list: could you please change the target to the develop branch and pull in the latest changes from there? This will also pull in the latest test configuration.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,54,https://github.com/igraph/igraph/pull/1346#issuecomment-634056426,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hi, I just saw your messages and will do these things after I come from work tomorrow.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,55,https://github.com/igraph/igraph/pull/1346#issuecomment-635163606,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Just a small comment:
 \example examples/test/igraph_is_eulerian.c

Please do not add any tests to the documentation. We are trying to separate examples from tests. It's okay not to have a usage example in the docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,56,https://github.com/igraph/igraph/pull/1346#issuecomment-635164390,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@szhorvat we could use a little advice on the bridge checks. We used to compute all bridges for every edge, which is inefficient. We obviously don't need to check for bridge/no bridge if this is the only unvisited edge out of a vertex because we're going that way anyways.
However, if there are several unvisited edges we need to do a DFS from the current vertex with/without the current edge to figure out whether this particular edge is now a bridge. Notice the edge might not have been a bridge initially, but could have become a bridge once a few other edges have been visited.
I see that igraph has igraph_dfs, however it's not used much internally, instead the recursion is written down explicitely (e.g. in the bridges function itself). How would you go about this? Shall we call igraph_dfs for readability or code out the recursive DFS algorithm again?
Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,57,https://github.com/igraph/igraph/pull/1346#issuecomment-635201544,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@iosonofabio I must beg for some patience until next week because of looming deadlines ... I must go through the code in detail to be able to answer this well.
A question:
The comments in the current version suggest that you wanted to implement Fleury's algorithm for the undirected case and Hierholzer's algorithm for the directed case. Is this the case? If yes, why not use Hierholzer's for the undirected case as well? It is much more efficient, and it avoids all the trouble with the bridges. It is possible that I am missing an important point here.
Regarding Fleury's algorithm:
The reason why it is a good idea to avoid both igraph_bridges and igraph_dfs is that these functions take an igraph_t as input. Then internally they convert it to a different representation (some sort of adjacency list) and operate on that.  Doing this conversion repeatedly seems like a waste. Furthermore, since these functions take an igraph_t data structure as input, we would be stuck with having to delete edges explicitly from the igraph_t with functions like igraph_delete_edges. This is also very expensive (linear time for a single deletion).
Usually, the better approach is to decide what representation is the best to use for a given algorithm, convert the graph to that representation once, then use it throughout the function. This is what most igraph functions do currently. This is more work, as graph traversals like DFS must be implemented separately for each function / each representation. But it gives us the option to make significant optimizations. For example, an edge can be simply marked as deleted/handled (O(1) time) instead of actually deleting it from the igraph_t data structure (which takes O(n) time). Then we can write our specialized DFS to simply avoid edges marked as deleted. Or, we can use a data structure in which edge deletion is cheaper (an incidence list with an appropriate storage container for edges).
What I said above is just the principle of the matter. I tried to explain why you almost never see igraph_dfs used explicitly.
To give a proper answer for this specific case, I must look through the code in detail first. This is why I asked for more time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,58,https://github.com/igraph/igraph/pull/1346#issuecomment-635204789,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Awesome, thanks for the info. I wonder whether there might be a way to have one or two generic but efficient DFS functions for typical representations of the graph. Anyway not for this PR.
@YasirKusay let's look into Hierholzer for undirected as well first.
@szhorvat let us try and use that algorithm for everything first. No need to spend more time on this until we get back to you. Thank you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,59,https://github.com/igraph/igraph/pull/1346#issuecomment-635207871,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I wonder whether there might be a way to have one or two generic but efficient DFS functions for typical representations of the graph.

Yes, personally I am a bit frustrated by this situation. The internal data structure is very commonly an igraph_adjlist or an igraph_inclist. Sometimes, one might need some functionality that is already implemented, and it would be very convenient to be able to run this directly on that adjlist or inclist. Actually, a few internal functions seem to take an adjlist (not an igraph_t) as input. Sometimes I wish that more of them had this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/ntamas,60,https://github.com/igraph/igraph/pull/1346#issuecomment-635215131,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Yes, personally I am a bit frustrated by this situation. The internal data structure is very commonly an igraph_adjlist or an igraph_inclist.

True, true. In theory, we could replace the current graph representation in type_indexededgelist.c with an adjacency list or an incidence list (or both, in parallel). What I don't know yet is how many other algorithms are there in the library that benefit more from the current indexed edge list representation and that would become slower if we switched to an adjacency list. The best would be to create a comprehensive benchmarking suite for igraph that reflects typical use-cases, and then we could measure what happens if we replace the current representation with another one.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,61,https://github.com/igraph/igraph/pull/1346#issuecomment-636676107,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@szhorvat Yasir has rewritten the undirected graph algorithm to use Hierholzer and it now works fine. Tests on Linux/OSX pass, tests on AppVeyor seem to pass, although a few are still ongoing. Yasir will ping us tonight if everything is fine and then it'd be great to have you or @ntamas review the code.
We are so close!!
Thanks,
Fabio",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,62,https://github.com/igraph/igraph/pull/1346#issuecomment-636698234,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@YasirKusay Appveyor passes except for Python3.8 because it cannot find the ""conda"" command. That seems unrelated to this PR, so I'd say the PR is ready for review!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/ntamas,63,https://github.com/igraph/igraph/pull/1346#issuecomment-636768339,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Yes, that's unrelated; I tried to add Python 3.8 to the test environment on Appveyor but it would need a newer Appveyor image (the Visual Studio 2013 image does not have Python 3.8 yet).
However, when you think about it: why do we even test the C build for various versions of Python? Could be an artifact from the times when we did not have proper CI setup in python-igraph; I need to revise whether it's necessary at all.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,64,https://github.com/igraph/igraph/pull/1346#issuecomment-637051805,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","We still need to add this to the docs. @iosonofabio, any suggestions on where it would fit? We can add ti to the Structural Properties chapter, but that chapter is already overloaded and incoherent. I would not give this topic its own chapter though, it's too short.
Perhaps start a chapter on cycles? Later we can move tha DAG section there, and eventually also add the cycle basis there. If/when we get any Hamiltonian cycle implementation, that will fit too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,65,https://github.com/igraph/igraph/pull/1346#issuecomment-637052112,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I'll take a careful look during this week and will post a review.
@YasirKusay I'm happy to integrate the docs once we come to a decision, you don't need to spend time on that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,66,https://github.com/igraph/igraph/pull/1346#issuecomment-637163156,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","A new one on cycles sounds great. Structural props really needs a little love.
Thank you so much!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,67,https://github.com/igraph/igraph/pull/1346#issuecomment-640001809,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, I have addressed all of the things that you have requested. As for the very basic cases (graphs with 0 vertices, etc), thank you for pointing it out! I agree with you with most of the things, except one case, that being a graph with 1 vertex. If a graph has 1 vertex and 0 edges, it should have an empty return, whenever igraph_eulerian_cycle or igraph_eulerian_path is called, but not when there are edges. E.g. a graph with one vertex (vertex 0) that has one or more self loops should not have an empty cycle/path, rather should have a normal cycle/path return.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,68,https://github.com/igraph/igraph/pull/1346#issuecomment-640195934,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","If a graph has 1 vertex and 0 edges, it should have an empty return, whenever igraph_eulerian_cycle or igraph_eulerian_path is called, but not when there are edges. E.g. a graph with one vertex (vertex 0) that has one or more self loops should not have an empty cycle/path, rather should have a normal cycle/path return.

You are of course perfectly right!
I notice that in the is_eulerian functions now you use (igraph_vcount(graph) == 1 && igraph_ecount(graph) == 0). However, if there is a single vertex only, both has_cycleand has_edge are always true. Thus, this check:
if (igraph_vcount(graph) == 0 || (igraph_vcount(graph) == 1 && igraph_ecount(graph) == 0) || (igraph_vcount(graph) > 0 && igraph_ecount(graph) == 0)) {
    *has_path = 1;
    *has_cycle = 1;
    return  IGRAPH_SUCCESS;
}

could be simplified to
if (igraph_ecount(g) == 0 || igraph_vcount(g) <= 1) {
    *has_path = 1;
    *has_cycle = 1;
    return  IGRAPH_SUCCESS;
}

Do you agree @YasirKusay ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,69,https://github.com/igraph/igraph/pull/1346#issuecomment-640196441,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","In igraph_i_is_eulerian_directed, you check both strong and weak connectivity. I think it is sufficient to check weak connectivity (more precisely, that there is precisely one weakly connected component that has size > 1).
Weak connectivity plus the fact that all vertices have equal in- and out-degree implies strong connectivity.
Do you agree @YasirKusay? Let me know if I missed something.
UPDATE: https://math.stackexchange.com/q/2296452",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,70,https://github.com/igraph/igraph/pull/1346#issuecomment-640197894,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Another small improvement that could be made is to have igraph_i_is_eulerian_directed and igraph_i_is_eulerian_undirected (the internal versions) compute and return the start and end vertices (for the case when we have a path). They have to do this anyway when checking that there is only one vertex with outdegee - indegree == 1 and with indegree - outdegree == 1.
Thus you can save re-calculating the start/end vertices a second time in the function that finds the path/cycle.
Take this as a suggestion only (not required for merging).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,71,https://github.com/igraph/igraph/pull/1346#issuecomment-640200838,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",igraph_i_eulerian_path_directed appears to duplicate the check of whether the graph is Eulerian. You already do this check before calling igraph_i_eulerian_path_directed. Do not do it a second time.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,72,https://github.com/igraph/igraph/pull/1346#issuecomment-640219924,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hello, thanks for the extensive feedback and suggestions! As for your query regarding checking strongly connected clusters, I did it because I need to consider the disconnected graph case. However, thanks for linking that stackexchange post, as indegree == outdegree for all nodes does nullify the need to check if a graph is strongly connected (but as you pointed out, the weakly connected check is still necessary to ensure that there are no 2 disconnected clusters, each containing more than 1 edges).
You are also very correct in pointing out that checking whether a graph is strongly/weakly connected does not need to be carried out in igraph_i_eulerian_directed, as by this point, we are now certain that the graph contains either a graph or cycle. I have modified it as such and removed the need to check clusters and whether the graph is strongly and weakly connected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,73,https://github.com/igraph/igraph/pull/1346#issuecomment-640685579,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@YasirKusay Earlier you proposed to return both the edge-path and the vertex-path. I said no to that, as I thought it was unnecessary.
Thinking about it more, it may make sense to return vertex paths as well, or at least optionally return the starting vertex of the path. If the graph is undirected, it is obvious which one is the starting vertex. But if it is not, it takes extra work to find it (the odd-degree endpoint of the starting edge).
Consider a graph like this,

The vertex path is 1-2-1-2-3.
The edge path could be 1-2-3-4. It's a bit hard to see how that actually goes.
@iosonofabio @vtraag Any opinions on this?
Since @YasirKusay's code already computes the vertex path (I added a comment above asking to remove it), maybe let's go with Yasir's original suggestion, and make it possible to get both the vertex and edge paths? If the user doesn't want one of them, they should be able to pass NULL.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,74,https://github.com/igraph/igraph/pull/1346#issuecomment-641593389,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@szhorvat there's a reason I suppose why the whole Eulerian business is defined on edges and your plot makes for a good case. On the other hand, with multiedges it doesn't matter which edge you choose, both choices lead to a Eulerian path/cycle. So I'm fine either way, as long as it's deterministic.
Also, @szhorvat since you prefer to fix the last few bolts and nuts yourself, feel free to push to the PR from now on!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/vtraag,75,https://github.com/igraph/igraph/pull/1346#issuecomment-641717486,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","make it possible to get both the vertex and edge paths?

Sounds reasonable to me! Indeed, as you say, a user can always pass NULL, and I imagine that it does not degrade performance.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,76,https://github.com/igraph/igraph/pull/1346#issuecomment-643732787,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",I merged the recently added tools that verify the FINALLY stack size. It appears that there are some more mismatches between the number of IGRAPH_FINALLY and IGRAPH_FINALLY_CLEAN.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,77,https://github.com/igraph/igraph/pull/1346#issuecomment-647140639,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Just a quick update, I am still working on this but will inform you of when I am done. Although I fixed the issue to do with a graph having edges: 0,0, 1,1, the fix is inefficient and I will think about a potentially faster method when I am able to work on this repo next time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,78,https://github.com/igraph/igraph/pull/1346#issuecomment-647377476,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@YasirKusay Haven't looked at your new changes yet, just wanted to ask: Will it help if I push an efficient function that checks the connectivity of the line graph (i.e. the type of connectivity that is relevant here)?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,79,https://github.com/igraph/igraph/pull/1346#issuecomment-650201983,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",I wouldn't mind that @szhorvat. Any help would be appreciated.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,80,https://github.com/igraph/igraph/pull/1346#issuecomment-650308499,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I'll do that, give me a couple of days.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,81,https://github.com/igraph/igraph/pull/1346#issuecomment-653396432,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Hi guys, I did a buncha changes that address each and every comment in the last half a year.
Although this PR is not and never will be a perfect exercise of style, I think this is ready for merging.
Please let me know if you find issues that are not caught by the relatively extensive tests and I'll be happy to fix them. Otherwise, let's merge it ;-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/ntamas,82,https://github.com/igraph/igraph/pull/1346#issuecomment-653438548,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Thanks for your hard work for all of you guys (@YasirKusay @iosonofabio @szhorvat )! I'll wait for a final nod from @szhorvat as he was doing most of the reviewing - if he is okay with things, I'll be happy to merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,83,https://github.com/igraph/igraph/pull/1346#issuecomment-653439086,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Perfect! As I said, happy to implement any reasonable changes :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,84,https://github.com/igraph/igraph/pull/1346#issuecomment-653745993,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@iosonofabio It's really busy times right now for me, so I'll post here what I notice gradually. I'd like to try out the functionality again and run a few tests before merging.
Two things I noticed:

The docs need to be updated to describe the new argument
Instead of vector_res, it's clearer to use vertex_res, as this vector contains vertex IDs (right?)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/ntamas,85,https://github.com/igraph/igraph/pull/1346#issuecomment-653762448,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.",Docs updated and vector_res renamed to vertex_res in 2d36c3c (I had a bit of spare time),True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,86,https://github.com/igraph/igraph/pull/1346#issuecomment-653771108,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","The result for graphs that contain one vertex with one or more self-loops and several other zero-degree vertices is incorrect. The functions say that this graph is not Eulerian, but it is.  Example graph:",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,87,https://github.com/igraph/igraph/pull/1346#issuecomment-653859817,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Alright guys, here's the next iteration.
@szhorvat pointed out a bunch of problems that honestly I should have spotted myself. I missed the forest for the trees while polishing the code.
Now I redesigned both undirected and directed functions for is_eulerian using a parallel and simplified logic, a new test covering the corner case that was raised, and sometimes better variable names. I also reorganized the order of tests.
I think this should be good by now - all tests pass. If @szhorvat and @ntamas could both have a look one of the next days then we can close :-)
thank you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,88,https://github.com/igraph/igraph/pull/1346#issuecomment-657581144,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Merged 🥳, thanks @YasirKusay and @iosonofabio !",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,89,https://github.com/igraph/igraph/pull/1346#issuecomment-657581514,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@iosonofabio I clarified some comments before merging (no code changes). If you disagree, please just fix it directly in develop.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/szhorvat,90,https://github.com/igraph/igraph/pull/1346#issuecomment-657705912,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","@iosonofabio There's some weirdness in how doc comments work, so paragraphs must be separated using </para><para>, without an opening <para>.
Fixed it here: 313bdc7",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/iosonofabio,91,https://github.com/igraph/igraph/pull/1346#issuecomment-657814345,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","Thank you, happy to see it done! Yes a few comments were a little off, including the paragraph thing. No problem from my side!
…
On Tue, Jul 14, 2020, at 04:00, Szabolcs Horvát wrote:


 @iosonofabio <https://github.com/iosonofabio> There's some weirdness in
 how doc comments work, so paragraphs must be separated using
 `</para><para>`, *without* an opening `<para>`.

 Fixed it here: 313bdc7
 <313bdc7>

 —
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#1346 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAAEECMNI23GP5JQGVDR3NDSZANCNFSM4K7L7OIA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1346,2020-03-02T04:08:35Z,2020-07-13T14:04:18Z,2020-07-14T11:26:54Z,MERGED,True,1836,4,19,https://github.com/YasirKusay,Basic draft for eulerian paths/circuits,74,[],https://github.com/igraph/igraph/pull/1346,https://github.com/YasirKusay,92,https://github.com/igraph/igraph/pull/1346#issuecomment-658126698,"I started to implement eulerian cycles/paths. I made:

.c file in src with a few functions, will refine later on
.h in include, containing only one function for now
a .c file in examples/tests
a .at file inside tests

I am not sure as how I can include my files into the compiling and tests steps, can you please help me?
After that, I will refine the code that I have.","I am happy to see that this pull request is now closed, being a relatively new programmer, this definitely provided me with a lot of experience and allowed me to improve as a programmer. Thank you all for the opportunity, and for helping me out with this pull request.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1347,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1347#issuecomment-593883786,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","Thanks, this is great, thank you for working on this!
On a somewhat related note, the current codebase throws a bunch of (probably meaningless) warnings on MSVC; at some point we should probably start cleaning that up as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1347#issuecomment-593884099,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","By the way, a rule of thumb is that 99% of the functions prefixed with igraph_i_ can safely be made static (at least that was the original intention).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1347#issuecomment-594001722,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","Good to start doing this @szhorvat !
I think there is a connection here with argument checking, as discussed in issue #1219.
If all internal (igraph_i_*) functions are only visible within their proper translation unit, then they are also not usable from other igraph functions. For example, if we do some argument check (e.g. igraph_has_multiple) that we perform only in public igraph functions (for example, suppose we would do that in igraph_hub_score), and we want to use that function elsewhere within igraph, we cannot use the internal counterpart that would not do that check (e.g. igraph_i_hub_score in this hypothetical example).
We should hence make clear the intended use of different functions. There seem three possibilities I believe:

local use, which should not be used by other parts of igraph. These should be declared static.
internal use, which could be used by other parts of igraph. These should be declared in an internal header.
external use, which should be used by external consumers of igraph. These should be declared in a public header.

Are there other possibilities that I am missing? Or do we not want to (try to) maintain this distinction between internal/external versions of functions that perform argument checking or not as discussed in issue #1219?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1347#issuecomment-594041626,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","@vtraag Yes, basically this PR does an imperfect pre-sort of functions to separate ""local"" from ""internal"".
Let me show an example of why I think this is important. Suppose we have two translation units, A and B, and B uses a function from A, like this:
/* A.c */

int foo(int x) { return x; }

/* B.c */

/* Prototype of function from A.c */
int foo(int x);

int bar(int x) { return foo(x)*foo(x); }

There are many instances of this pattern in igraph.
Now suppose someone goes into A.c and makes a change to foo(), assuming it is not used anywhere else. Now it's int foo(int x, int y);. But the file B.c has an entirely separate prototype included, which does not know about A.c at all. bar() calls foo() with one argument, but foo() wants to read two arguments off the stack: bang! crash, or more likely something worse: foo() subtly returns a wrong result without crashing, and we never detect what is going wrong.
This is why both A.c and B.c should include the same header, which contains the prototype of foo(). Prototypes shouldn't be copied around in an ad-hoc way.

What I am doing in this PR is that I add static to everything that looks local, and try to compile. If the function was used somewhere else I get a linker error. Now we know it's used in multiple places. For now, I simply add a note to the file where the function is defined, and remove static.  If linking succeeded with static, then we know that the function is not used anywhere else.

After this PR is finished, consider anything named as igraph_i_ without static or an explanatory comment as suspect and in need of investigation. There are so many functions that I can't possibly catch everything.
As a next step, we can try to sort out the header/prototype situation, but for now I'm just adding either static or a comment. Cleaning this up is huge work, and I can only do it one small step at a time (even if this creates some temporary ugliness like the explanatory comments).",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1347#issuecomment-594065754,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","I think that the policy in the past has been that the headers in include/ are the public interface, and any other headers in src/ are cross-module ""internal"" headers that may be used ""inside"" igraph but not ""outside"". We may have been sloppy here and there by not putting a declaration into an ""internal"" header and just copying it into the translation unit where it was used, and we should fix those of course. Otherwise, I think this pattern is sustainable for the time being.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1347,2020-03-03T09:23:00Z,2020-03-03T21:48:40Z,2020-03-03T21:48:40Z,MERGED,True,1177,1125,55,https://github.com/szhorvat,Make functions 'static' when appropriate,4,[],https://github.com/igraph/igraph/pull/1347,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1347#issuecomment-594172403,"This PR attempts to make functions 'static' (i.e. local to the translation unit) when appropriate.
This is a step towards cleaning up the code, finding unused functions (the compiler can provide better warnings), sorting internal functions from ones that should be public, and making sure that everything used across multiple translation units has a prototype in a header.
This is not completed yet (still some files to go through) but I'm putting it out here in case anyone has comments.","@ntamas If the tests pass, this is good to go.  Hope I didn't mess up anything with all the rebasing ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1348,2020-03-03T11:00:18Z,2020-03-03T11:58:45Z,2020-12-03T19:07:37Z,MERGED,True,49,49,12,https://github.com/szhorvat,change some instances of free() to igraph_free() or igraph_Free(),1,[],https://github.com/igraph/igraph/pull/1348,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1348,"This changes many instances of IGRAPH_FINALLY(free, ...) to IGRAPH_FINALLY(igraph_free, ...) and also free() to igraph_Free().
structural_properties.c is not included as I'm working on that and it will cause inconvenient conflicts.
Reference: https://igraph.discourse.group/t/todo-in-unweighted-shortest-path-implementations-bfs/125/3","This changes many instances of IGRAPH_FINALLY(free, ...) to IGRAPH_FINALLY(igraph_free, ...) and also free() to igraph_Free().
structural_properties.c is not included as I'm working on that and it will cause inconvenient conflicts.
Reference: https://igraph.discourse.group/t/todo-in-unweighted-shortest-path-implementations-bfs/125/3",True,{}
igraph/igraph,https://github.com/igraph/igraph,1348,2020-03-03T11:00:18Z,2020-03-03T11:58:45Z,2020-12-03T19:07:37Z,MERGED,True,49,49,12,https://github.com/szhorvat,change some instances of free() to igraph_free() or igraph_Free(),1,[],https://github.com/igraph/igraph/pull/1348,https://github.com/gaborcsardi,2,https://github.com/igraph/igraph/pull/1348#issuecomment-593894657,"This changes many instances of IGRAPH_FINALLY(free, ...) to IGRAPH_FINALLY(igraph_free, ...) and also free() to igraph_Free().
structural_properties.c is not included as I'm working on that and it will cause inconvenient conflicts.
Reference: https://igraph.discourse.group/t/todo-in-unweighted-shortest-path-implementations-bfs/125/3",Why does structural_properties.c  cause conflicts?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1348,2020-03-03T11:00:18Z,2020-03-03T11:58:45Z,2020-12-03T19:07:37Z,MERGED,True,49,49,12,https://github.com/szhorvat,change some instances of free() to igraph_free() or igraph_Free(),1,[],https://github.com/igraph/igraph/pull/1348,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1348#issuecomment-593912065,"This changes many instances of IGRAPH_FINALLY(free, ...) to IGRAPH_FINALLY(igraph_free, ...) and also free() to igraph_Free().
structural_properties.c is not included as I'm working on that and it will cause inconvenient conflicts.
Reference: https://igraph.discourse.group/t/todo-in-unweighted-shortest-path-implementations-bfs/125/3","I am working on another PR (#1344) which makes big changes to structural_properties.c and moves some code over into a new file shortest_paths.c (see also #1345). Modifying structural_properties.c in this PR as well would cause conflicts which would be painful for me to handle, especially since I am trying to manage the changes in #1344 on two branches: one for the PR and one from which I build the Mathematica interface (which I use for testing any change I make to igraph).
How about I add the fixes only to those parts of structural_properties.c which have not yet been touched in the other PR?
The remaining free()s will be fixed as part of PR #1344 (which was the original reason I brought this up in the first place)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1348,2020-03-03T11:00:18Z,2020-03-03T11:58:45Z,2020-12-03T19:07:37Z,MERGED,True,49,49,12,https://github.com/szhorvat,change some instances of free() to igraph_free() or igraph_Free(),1,[],https://github.com/igraph/igraph/pull/1348,https://github.com/gaborcsardi,4,https://github.com/igraph/igraph/pull/1348#issuecomment-593913561,"This changes many instances of IGRAPH_FINALLY(free, ...) to IGRAPH_FINALLY(igraph_free, ...) and also free() to igraph_Free().
structural_properties.c is not included as I'm working on that and it will cause inconvenient conflicts.
Reference: https://igraph.discourse.group/t/todo-in-unweighted-shortest-path-implementations-bfs/125/3","Oh, ok, you can just do that file later. But also, the free() fixes are not urgent, so you can also just keep this PR open, and merge it after you are done with the refactoring. Up to you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1348,2020-03-03T11:00:18Z,2020-03-03T11:58:45Z,2020-12-03T19:07:37Z,MERGED,True,49,49,12,https://github.com/szhorvat,change some instances of free() to igraph_free() or igraph_Free(),1,[],https://github.com/igraph/igraph/pull/1348,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1348#issuecomment-593914890,"This changes many instances of IGRAPH_FINALLY(free, ...) to IGRAPH_FINALLY(igraph_free, ...) and also free() to igraph_Free().
structural_properties.c is not included as I'm working on that and it will cause inconvenient conflicts.
Reference: https://igraph.discourse.group/t/todo-in-unweighted-shortest-path-implementations-bfs/125/3",I'm merging this now and I'll do that file later. I want this to be out of the way.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1352,2020-03-04T10:13:49Z,2020-03-04T10:31:31Z,2020-03-05T16:12:58Z,MERGED,True,117,69,5,https://github.com/szhorvat,label_propagation: fix test and make it deterministic,1,[],https://github.com/igraph/igraph/pull/1352,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1352,"This PR:

fixes the label propagation test which (see this failure: #1330 (comment))
makes the test deterministic
moves it to the tests directory and replaced the original test file with an example (for inclusion in the docs)
also removed the executable bit from the igraph_community_fluid_communities.c test file","This PR:

fixes the label propagation test which (see this failure: #1330 (comment))
makes the test deterministic
moves it to the tests directory and replaced the original test file with an example (for inclusion in the docs)
also removed the executable bit from the igraph_community_fluid_communities.c test file",True,{}
igraph/igraph,https://github.com/igraph/igraph,1355,2020-03-04T21:10:43Z,2020-03-06T13:58:33Z,2020-03-06T13:58:33Z,MERGED,True,36,21,1,https://github.com/szhorvat,avg_nearest_neighbor_degree: improve documentation,2,[],https://github.com/igraph/igraph/pull/1355,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1355,"The docs were a bit messed up, e.g. they claimed that edge directions are ignored. @vtraag please have a look and make sure it looks fine (I'm tired tonight).","The docs were a bit messed up, e.g. they claimed that edge directions are ignored. @vtraag please have a look and make sure it looks fine (I'm tired tonight).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1355,2020-03-04T21:10:43Z,2020-03-06T13:58:33Z,2020-03-06T13:58:33Z,MERGED,True,36,21,1,https://github.com/szhorvat,avg_nearest_neighbor_degree: improve documentation,2,[],https://github.com/igraph/igraph/pull/1355,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1355#issuecomment-595776282,"The docs were a bit messed up, e.g. they claimed that edge directions are ignored. @vtraag please have a look and make sure it looks fine (I'm tired tonight).","@vtraag I tried to address all your comments, though I did not always literally take the suggestion. I also fixed some incorrect index notation.
About ""nearest"", I was thinking the same myself. I removed this word from the docs. I believe it is used because the referenced paper is using the same name. However, igraph itself generally uses ""neighbour"" to refer to first neighbours. We need to be consistent within igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1355,2020-03-04T21:10:43Z,2020-03-06T13:58:33Z,2020-03-06T13:58:33Z,MERGED,True,36,21,1,https://github.com/szhorvat,avg_nearest_neighbor_degree: improve documentation,2,[],https://github.com/igraph/igraph/pull/1355,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1355#issuecomment-595778414,"The docs were a bit messed up, e.g. they claimed that edge directions are ignored. @vtraag please have a look and make sure it looks fine (I'm tired tonight).","Thanks for the changes, they look good to me! Indeed, the sum had an incorrect index, I did not yet notice.
We can probably best squash these two commits when merging?

About ""nearest"", I was thinking the same myself. I removed this word from the docs.

OK, so we may want to update the name in 0.9.0 for example (but keep the old name with a deprecation message)?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1355,2020-03-04T21:10:43Z,2020-03-06T13:58:33Z,2020-03-06T13:58:33Z,MERGED,True,36,21,1,https://github.com/szhorvat,avg_nearest_neighbor_degree: improve documentation,2,[],https://github.com/igraph/igraph/pull/1355,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1355#issuecomment-595778563,"The docs were a bit messed up, e.g. they claimed that edge directions are ignored. @vtraag please have a look and make sure it looks fine (I'm tired tonight).","@vtraag  If you're happy with it, please go ahead and ""squash and merge"" Apparently GitHub has a button for this (which I didn't know before). I don't want more than one commit on master for a simple change like this. If you want to make small changes, feel free to do so on this branch (GitHub's web-based editor is very convenient).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1357,2020-03-06T13:26:16Z,2020-03-06T14:43:38Z,2020-03-06T14:43:38Z,MERGED,True,8,8,1,https://github.com/vtraag,Community_leiden: fixed refinement bug and corrected warnings.,1,[],https://github.com/igraph/igraph/pull/1357,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1357,"This fixes #1356. The bug arised whenever the refinement didn't result in an aggregation, in which case the aggregation is based on the current clustering (instead of the refinement). However, the number of clusters was incorrectly not updated to the current clustering instead of the refinement.
This also fixes #1353. I've chosen to not have a const qualifier anymore on the internal function igraph_i_community_leiden. When using actual const consistently becomes more problematic in places elsewhere, and this is the cleanest approach I believe. The problem is that the graph (and corresponding edge weights and node weights) are initially supplied (and not modified), hence the const qualifier makes sense. However, the graph is continuously being aggregated, at which point the const makes less sense. I think the current solution is a reasonable compromise. The warning about igraph_i_vector_binsearch_slice is separately addressed in PR #1341, but that can only be merged for version 0.9.0.","This fixes #1356. The bug arised whenever the refinement didn't result in an aggregation, in which case the aggregation is based on the current clustering (instead of the refinement). However, the number of clusters was incorrectly not updated to the current clustering instead of the refinement.
This also fixes #1353. I've chosen to not have a const qualifier anymore on the internal function igraph_i_community_leiden. When using actual const consistently becomes more problematic in places elsewhere, and this is the cleanest approach I believe. The problem is that the graph (and corresponding edge weights and node weights) are initially supplied (and not modified), hence the const qualifier makes sense. However, the graph is continuously being aggregated, at which point the const makes less sense. I think the current solution is a reasonable compromise. The warning about igraph_i_vector_binsearch_slice is separately addressed in PR #1341, but that can only be merged for version 0.9.0.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1357,2020-03-06T13:26:16Z,2020-03-06T14:43:38Z,2020-03-06T14:43:38Z,MERGED,True,8,8,1,https://github.com/vtraag,Community_leiden: fixed refinement bug and corrected warnings.,1,[],https://github.com/igraph/igraph/pull/1357,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1357#issuecomment-595798344,"This fixes #1356. The bug arised whenever the refinement didn't result in an aggregation, in which case the aggregation is based on the current clustering (instead of the refinement). However, the number of clusters was incorrectly not updated to the current clustering instead of the refinement.
This also fixes #1353. I've chosen to not have a const qualifier anymore on the internal function igraph_i_community_leiden. When using actual const consistently becomes more problematic in places elsewhere, and this is the cleanest approach I believe. The problem is that the graph (and corresponding edge weights and node weights) are initially supplied (and not modified), hence the const qualifier makes sense. However, the graph is continuously being aggregated, at which point the const makes less sense. I think the current solution is a reasonable compromise. The warning about igraph_i_vector_binsearch_slice is separately addressed in PR #1341, but that can only be merged for version 0.9.0.",I'll merge this when the CI checks pass. Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1359,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes",True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1359#issuecomment-596238417,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","@ntamas Is there a better solution here?
edcb7d1
See just above this why this change was necessary.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1359#issuecomment-596446513,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","Is there a better solution here?

Probably not, other than replacing the documentation generator entirely with a solution that does not rely on dumb regular expressions :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1359#issuecomment-596738574,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","I added one more commit where I comment out the prototypes of some functions that were already commented out earlier. This gets rid of a few compiler warnings.
Please check that one as well.
I responded to your comments in the review. The using namespace std is taken care of. Looking at the config.h revealed a potential issue in igraph_vector.h. I think this should not be there, but it's unclear why it's there in the first place:
#ifdef HAVE_STDINT_H
    #include <stdint.h>
#else
    #if defined(HAVE_SYS_INT_TYPES_H) && HAVE_SYS_INT_TYPES_H
        #include <sys/int_types.h>    /* for Solaris */
    #endif
#endif

On macOS is compiles fine without that part, and I do not see why stdint.h would ever be needed.
See my comment on the review for more details.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1359#issuecomment-596750845,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","It came from here: 6b68ff5
https://lists.nongnu.org/archive/html/igraph-help/2010-01/msg00081.html",True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1359#issuecomment-596822748,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","The original stdint.h inclusion comes from a8092fb, but as far as I can tell it was never truly necessary because igraph_vectors of this type are not defined in igraph_vector.h. They are only defined in bigint.h which is a private header. It should be sufficient to have this include in bignum.h (where it is present).
I am adding a commit to remove this piece of code.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1359,2020-03-08T13:34:50Z,2020-03-10T16:21:26Z,2020-03-10T16:21:26Z,MERGED,True,236,321,97,https://github.com/szhorvat,Various small code cleanups,13,[],https://github.com/igraph/igraph/pull/1359,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1359#issuecomment-597178329,"This PR contains various small cleanups (with the #include cleanup touching lots of files). Please see the commits for details.

Any unneeded header includes are removed and headers are included in a consistent order, from most specific to least specific, i.e.:

igraph headers
config.h (unless there's a reason to put it in a different location in the header order)
system headers


Some always-true conditionals are removed from sir.c (if those pointers were NULL, the preceding code would fail too in that function).

Consistent header guard naming (I was uncomfortable with names like ARPACK_H that lacked the IGRAPH_ prefix)

Re-encode some files are UTF8

Comments and minor fixes","Thanks, merged!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1362,2020-03-24T17:45:34Z,2020-03-26T08:46:42Z,2020-03-26T08:46:42Z,MERGED,True,21,17,2,https://github.com/szhorvat,igraph_sir: interruption support and other fixes,6,[],https://github.com/igraph/igraph/pull/1362,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1362,Please see commit messages for details.,Please see commit messages for details.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1362,2020-03-24T17:45:34Z,2020-03-26T08:46:42Z,2020-03-26T08:46:42Z,MERGED,True,21,17,2,https://github.com/szhorvat,igraph_sir: interruption support and other fixes,6,[],https://github.com/igraph/igraph/pull/1362,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1362#issuecomment-603407308,Please see commit messages for details.,@ntamas Could you take a look at the AppVeyor setup? Something went wrong there.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1362,2020-03-24T17:45:34Z,2020-03-26T08:46:42Z,2020-03-26T08:46:42Z,MERGED,True,21,17,2,https://github.com/szhorvat,igraph_sir: interruption support and other fixes,6,[],https://github.com/igraph/igraph/pull/1362,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1362#issuecomment-603422015,Please see commit messages for details.,"Seems like a tug-of-war between xz and zip (well, their dependencies). Guess we could remove xz from the default installation as we don't need it, but I expect this to be a temporary problem.
By the way, the commits seem okay for me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1362,2020-03-24T17:45:34Z,2020-03-26T08:46:42Z,2020-03-26T08:46:42Z,MERGED,True,21,17,2,https://github.com/szhorvat,igraph_sir: interruption support and other fixes,6,[],https://github.com/igraph/igraph/pull/1362,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1362#issuecomment-604077561,Please see commit messages for details.,"Please wait with merging, there's an occasional crash with the interruption.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1362,2020-03-24T17:45:34Z,2020-03-26T08:46:42Z,2020-03-26T08:46:42Z,MERGED,True,21,17,2,https://github.com/szhorvat,igraph_sir: interruption support and other fixes,6,[],https://github.com/igraph/igraph/pull/1362,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1362#issuecomment-604095084,Please see commit messages for details.,"OK, the problem was that igraph_i_sir_destroy did not set the destroyed vector_ptr elements to NULL. Therefore the caller could not detect that some elements should not be destroyed when an interruption occurred.
The fix was a bit ugly because I had to get rid of the s variable. Alternatively, I could have used an igraph_sir_t **s, but then the compiler warns about incompatible pointer types (since assigning from a void **). I don't see any alternative. @ntamas ?
I also added two other commits.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1362,2020-03-24T17:45:34Z,2020-03-26T08:46:42Z,2020-03-26T08:46:42Z,MERGED,True,21,17,2,https://github.com/szhorvat,igraph_sir: interruption support and other fixes,6,[],https://github.com/igraph/igraph/pull/1362,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1362#issuecomment-604102670,Please see commit messages for details.,"Just clearing the vector_ptr at the end of igraph_i_sir_destroy would have been simpler, I guess ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1365,2020-03-31T22:00:59Z,2020-04-02T10:57:11Z,2020-04-02T10:57:12Z,MERGED,True,15,6,1,https://github.com/vtraag,all_st_mincuts: check whether capacities are strictly positive.,2,[],https://github.com/igraph/igraph/pull/1365,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1365,"The capacities for igraph_all_st_mincuts are asssumed to be strictly positive, but this was not yet checked. This PR also updates the docs to make clear that not all minimal cuts may be found due to numerical precision errors. This fixes #1363.","The capacities for igraph_all_st_mincuts are asssumed to be strictly positive, but this was not yet checked. This PR also updates the docs to make clear that not all minimal cuts may be found due to numerical precision errors. This fixes #1363.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1365,2020-03-31T22:00:59Z,2020-04-02T10:57:11Z,2020-04-02T10:57:12Z,MERGED,True,15,6,1,https://github.com/vtraag,all_st_mincuts: check whether capacities are strictly positive.,2,[],https://github.com/igraph/igraph/pull/1365,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1365#issuecomment-607098691,"The capacities for igraph_all_st_mincuts are asssumed to be strictly positive, but this was not yet checked. This PR also updates the docs to make clear that not all minimal cuts may be found due to numerical precision errors. This fixes #1363.","I would like to recommend integer weights in the docs, as these will be free from numerical errors.
Do you want me to go ahead and edit it, or do you want to do it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1365,2020-03-31T22:00:59Z,2020-04-02T10:57:11Z,2020-04-02T10:57:12Z,MERGED,True,15,6,1,https://github.com/vtraag,all_st_mincuts: check whether capacities are strictly positive.,2,[],https://github.com/igraph/igraph/pull/1365,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1365#issuecomment-607475634,"The capacities for igraph_all_st_mincuts are asssumed to be strictly positive, but this was not yet checked. This PR also updates the docs to make clear that not all minimal cuts may be found due to numerical precision errors. This fixes #1363.","Feel free to edit! Does this really hold generally? This means that all integers should be representable as floats. I'm not sure whether that is the case for all architectures and OS's. Probably this will (nearly) never be a problem, but it might be possible, wouldn't it? But still, the general recommendation makes sense.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1365,2020-03-31T22:00:59Z,2020-04-02T10:57:11Z,2020-04-02T10:57:12Z,MERGED,True,15,6,1,https://github.com/vtraag,all_st_mincuts: check whether capacities are strictly positive.,2,[],https://github.com/igraph/igraph/pull/1365,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1365#issuecomment-607483071,"The capacities for igraph_all_st_mincuts are asssumed to be strictly positive, but this was not yet checked. This PR also updates the docs to make clear that not all minimal cuts may be found due to numerical precision errors. This fixes #1363.","I don't mean integers as int or long. I mean integer values, with no fractional part.
Generally, what is needed is that both the weights and their sums be exactly representable in binary. Integer multiples of 1/2 or 1/4 would also work in practice, but I think that saying so may be too confusing for many users.
I'll edit it a bit in the morning, with a clearer head.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1365,2020-03-31T22:00:59Z,2020-04-02T10:57:11Z,2020-04-02T10:57:12Z,MERGED,True,15,6,1,https://github.com/vtraag,all_st_mincuts: check whether capacities are strictly positive.,2,[],https://github.com/igraph/igraph/pull/1365,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1365#issuecomment-607660007,"The capacities for igraph_all_st_mincuts are asssumed to be strictly positive, but this was not yet checked. This PR also updates the docs to make clear that not all minimal cuts may be found due to numerical precision errors. This fixes #1363.","This means that all integers should be representable as floats. I'm not sure whether that is the case for all architectures and OS's.

Pretty much all architectures use IEEE754 single- or double-precision floats nowadays, where it is guaranteed that integers have an exact representation. This is an excellent read about the pitfalls of IEEE754 floating point arithmetic and this is a neat summary.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1366,2020-04-04T20:16:07Z,2020-04-07T14:44:48Z,2020-04-07T20:30:32Z,MERGED,True,34,17,3,https://github.com/vtraag,Introduction of develop branching structure,3,[],https://github.com/igraph/igraph/pull/1366,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1366,"This PR introduces our intended branching structure.
To recap, we will respect semantic versioning. For the development release (0.x) we follow a specific procedure. Any released minor version (0.x.z) will be API backwards-compatible with any previous release of the same minor version (0.x.y, with y < z). If there is an API incompatible change, we will increase the minor version.
We will have two versions of igraph: the most recent released version, and the next upcoming minor release, which is by definition not yet released. The most recent release version is in the master branch, while the next upcoming minor release is in the develop branch. API-incompatible changes with the current release must be merged to the develop branch. If changes are API backwards-compatible, it can be merged to the master branch.
In most cases, changes in the master branch should also be merged to the develop branch by the maintainers, in order to keep them as much as possible in sync, and make sure that any improvements to the master branch will also be included in the next minor release in the develop branch.
All of this is explained in the CONTRIBUTING.md. I first would like to merge this PR before we setup the new develop branch. That way the CONTRIBUTING.md is already immediately correct in the develop branch as well.
Finally, in order to make the versioning system clear, I propose we switch to a slightly different versioning system (as implemented in tools/getversion.sh). All intermediate commits of a release will be versioned as 0.x.y-post+<sha> in the master branch. All commits in the develop branch will be versioned as 0.a.b-pre+<sha>, none of which are released yet of course. In other words, any commits in the master branch will be versioned as 0.8.1-post+<sha> after this PR gets merged. In the develop branch, commits should then be versioned as 0.9.0-pre+<sha>. This will be done automatically by adding back the NEXT_VERSION file. If we wouldn't change the versioning system, commits in master that end up being part of 0.8.2 would first be labelled 0.9.0-pre+<sha> in the current versioning system, incorrectly suggesting that it contains API-incompatible changes. I hope you agree that this is more clear.
Let me know if you have any comments or are OK with this.","This PR introduces our intended branching structure.
To recap, we will respect semantic versioning. For the development release (0.x) we follow a specific procedure. Any released minor version (0.x.z) will be API backwards-compatible with any previous release of the same minor version (0.x.y, with y < z). If there is an API incompatible change, we will increase the minor version.
We will have two versions of igraph: the most recent released version, and the next upcoming minor release, which is by definition not yet released. The most recent release version is in the master branch, while the next upcoming minor release is in the develop branch. API-incompatible changes with the current release must be merged to the develop branch. If changes are API backwards-compatible, it can be merged to the master branch.
In most cases, changes in the master branch should also be merged to the develop branch by the maintainers, in order to keep them as much as possible in sync, and make sure that any improvements to the master branch will also be included in the next minor release in the develop branch.
All of this is explained in the CONTRIBUTING.md. I first would like to merge this PR before we setup the new develop branch. That way the CONTRIBUTING.md is already immediately correct in the develop branch as well.
Finally, in order to make the versioning system clear, I propose we switch to a slightly different versioning system (as implemented in tools/getversion.sh). All intermediate commits of a release will be versioned as 0.x.y-post+<sha> in the master branch. All commits in the develop branch will be versioned as 0.a.b-pre+<sha>, none of which are released yet of course. In other words, any commits in the master branch will be versioned as 0.8.1-post+<sha> after this PR gets merged. In the develop branch, commits should then be versioned as 0.9.0-pre+<sha>. This will be done automatically by adding back the NEXT_VERSION file. If we wouldn't change the versioning system, commits in master that end up being part of 0.8.2 would first be labelled 0.9.0-pre+<sha> in the current versioning system, incorrectly suggesting that it contains API-incompatible changes. I hope you agree that this is more clear.
Let me know if you have any comments or are OK with this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1366,2020-04-04T20:16:07Z,2020-04-07T14:44:48Z,2020-04-07T20:30:32Z,MERGED,True,34,17,3,https://github.com/vtraag,Introduction of develop branching structure,3,[],https://github.com/igraph/igraph/pull/1366,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1366#issuecomment-610021453,"This PR introduces our intended branching structure.
To recap, we will respect semantic versioning. For the development release (0.x) we follow a specific procedure. Any released minor version (0.x.z) will be API backwards-compatible with any previous release of the same minor version (0.x.y, with y < z). If there is an API incompatible change, we will increase the minor version.
We will have two versions of igraph: the most recent released version, and the next upcoming minor release, which is by definition not yet released. The most recent release version is in the master branch, while the next upcoming minor release is in the develop branch. API-incompatible changes with the current release must be merged to the develop branch. If changes are API backwards-compatible, it can be merged to the master branch.
In most cases, changes in the master branch should also be merged to the develop branch by the maintainers, in order to keep them as much as possible in sync, and make sure that any improvements to the master branch will also be included in the next minor release in the develop branch.
All of this is explained in the CONTRIBUTING.md. I first would like to merge this PR before we setup the new develop branch. That way the CONTRIBUTING.md is already immediately correct in the develop branch as well.
Finally, in order to make the versioning system clear, I propose we switch to a slightly different versioning system (as implemented in tools/getversion.sh). All intermediate commits of a release will be versioned as 0.x.y-post+<sha> in the master branch. All commits in the develop branch will be versioned as 0.a.b-pre+<sha>, none of which are released yet of course. In other words, any commits in the master branch will be versioned as 0.8.1-post+<sha> after this PR gets merged. In the develop branch, commits should then be versioned as 0.9.0-pre+<sha>. This will be done automatically by adding back the NEXT_VERSION file. If we wouldn't change the versioning system, commits in master that end up being part of 0.8.2 would first be labelled 0.9.0-pre+<sha> in the current versioning system, incorrectly suggesting that it contains API-incompatible changes. I hope you agree that this is more clear.
Let me know if you have any comments or are OK with this.","Thanks for the great job, this is totally fine for me.
Maybe, if we are editing CONTRIBUTING.md anyway, can we consistently capitalize pull requests in lowercase (opposed to ""Pull Request"", which we are using in two places now)?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1366,2020-04-04T20:16:07Z,2020-04-07T14:44:48Z,2020-04-07T20:30:32Z,MERGED,True,34,17,3,https://github.com/vtraag,Introduction of develop branching structure,3,[],https://github.com/igraph/igraph/pull/1366,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1366#issuecomment-610600614,"This PR introduces our intended branching structure.
To recap, we will respect semantic versioning. For the development release (0.x) we follow a specific procedure. Any released minor version (0.x.z) will be API backwards-compatible with any previous release of the same minor version (0.x.y, with y < z). If there is an API incompatible change, we will increase the minor version.
We will have two versions of igraph: the most recent released version, and the next upcoming minor release, which is by definition not yet released. The most recent release version is in the master branch, while the next upcoming minor release is in the develop branch. API-incompatible changes with the current release must be merged to the develop branch. If changes are API backwards-compatible, it can be merged to the master branch.
In most cases, changes in the master branch should also be merged to the develop branch by the maintainers, in order to keep them as much as possible in sync, and make sure that any improvements to the master branch will also be included in the next minor release in the develop branch.
All of this is explained in the CONTRIBUTING.md. I first would like to merge this PR before we setup the new develop branch. That way the CONTRIBUTING.md is already immediately correct in the develop branch as well.
Finally, in order to make the versioning system clear, I propose we switch to a slightly different versioning system (as implemented in tools/getversion.sh). All intermediate commits of a release will be versioned as 0.x.y-post+<sha> in the master branch. All commits in the develop branch will be versioned as 0.a.b-pre+<sha>, none of which are released yet of course. In other words, any commits in the master branch will be versioned as 0.8.1-post+<sha> after this PR gets merged. In the develop branch, commits should then be versioned as 0.9.0-pre+<sha>. This will be done automatically by adding back the NEXT_VERSION file. If we wouldn't change the versioning system, commits in master that end up being part of 0.8.2 would first be labelled 0.9.0-pre+<sha> in the current versioning system, incorrectly suggesting that it contains API-incompatible changes. I hope you agree that this is more clear.
Let me know if you have any comments or are OK with this.","OK, thanks for merging. I created the develop branch. I think we can now go ahead and merge in changes that we want to make for version 0.9.0 (e.g. #1341 and #1344 ) to the develop branch. @szhorvat, I will try to review #1344 in not too much time, are you in a hurry?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1366,2020-04-04T20:16:07Z,2020-04-07T14:44:48Z,2020-04-07T20:30:32Z,MERGED,True,34,17,3,https://github.com/vtraag,Introduction of develop branching structure,3,[],https://github.com/igraph/igraph/pull/1366,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1366#issuecomment-610604808,"This PR introduces our intended branching structure.
To recap, we will respect semantic versioning. For the development release (0.x) we follow a specific procedure. Any released minor version (0.x.z) will be API backwards-compatible with any previous release of the same minor version (0.x.y, with y < z). If there is an API incompatible change, we will increase the minor version.
We will have two versions of igraph: the most recent released version, and the next upcoming minor release, which is by definition not yet released. The most recent release version is in the master branch, while the next upcoming minor release is in the develop branch. API-incompatible changes with the current release must be merged to the develop branch. If changes are API backwards-compatible, it can be merged to the master branch.
In most cases, changes in the master branch should also be merged to the develop branch by the maintainers, in order to keep them as much as possible in sync, and make sure that any improvements to the master branch will also be included in the next minor release in the develop branch.
All of this is explained in the CONTRIBUTING.md. I first would like to merge this PR before we setup the new develop branch. That way the CONTRIBUTING.md is already immediately correct in the develop branch as well.
Finally, in order to make the versioning system clear, I propose we switch to a slightly different versioning system (as implemented in tools/getversion.sh). All intermediate commits of a release will be versioned as 0.x.y-post+<sha> in the master branch. All commits in the develop branch will be versioned as 0.a.b-pre+<sha>, none of which are released yet of course. In other words, any commits in the master branch will be versioned as 0.8.1-post+<sha> after this PR gets merged. In the develop branch, commits should then be versioned as 0.9.0-pre+<sha>. This will be done automatically by adding back the NEXT_VERSION file. If we wouldn't change the versioning system, commits in master that end up being part of 0.8.2 would first be labelled 0.9.0-pre+<sha> in the current versioning system, incorrectly suggesting that it contains API-incompatible changes. I hope you agree that this is more clear.
Let me know if you have any comments or are OK with this.","No hurry, and it's actually not fully done. I wanted to change the lazy inclist to a normal inclist, since there seems to be no point in having it lazy. Much of the Dijkstra code was copied and adapted from other functions.
I was also going to make changes to diameter calculations, as discussed in #1345.
Other than the inclist thing, please consider the efficiency functions in the PR complete. Feedback is welcome.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1369,Fixes #1368,Fixes #1368,True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1369#issuecomment-612382771,Fixes #1368,"@ntamas Do you know why the Travis checks went missing? Also, AppVeyor issue doesn't seem to want to go away.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1369#issuecomment-612406368,Fixes #1368,"I see I left some other functions (at least the quality function) also without a proper IGRAPH_CHECK, which should also still be corrected. I can't correct it right now, but I'll take a look when I get around to it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1369#issuecomment-612474657,Fixes #1368,@vtraag Perhaps it's easiest to just push to this PR?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1369#issuecomment-612481121,Fixes #1368,"Yes, I'll push to this PR when I get around to it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1369#issuecomment-612868614,Fixes #1368,"Do you know why the Travis checks went missing?

I have no idea; Travis itself was correctly executed on this PR (see this link, but it did not appear above in the CI summary for some reason. I'll try to figure this out.

Also, AppVeyor issue doesn't seem to want to go away.

I'll try to sort this out; stay tuned.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1369#issuecomment-612870535,Fixes #1368,Appveyor seems to work again now; the fix is in the develop branch so feel free to merge it back into this PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1369#issuecomment-613898727,Fixes #1368,"Looks like the Travis checks also came back, although I have no idea what could have caused this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1369#issuecomment-613911809,Fixes #1368,"If there are no comments/concerns, I'll merge this in a few hours.",True,"{'THUMBS_UP': ['https://github.com/ntamas', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1369#issuecomment-614213388,Fixes #1368,"@vtraag @ntamas  OK, it's merged but I've forgotten about the two branches now. Should I simply merge it also into develop? Or cherry pick just the relevant part and add that to develop?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1369,2020-04-11T09:41:12Z,2020-04-15T16:59:46Z,2020-04-15T19:36:01Z,MERGED,True,17,17,3,https://github.com/szhorvat,community_leiden: fix crash when interrupting,4,[],https://github.com/igraph/igraph/pull/1369,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1369#issuecomment-614239436,Fixes #1368,"I've just merged the fixed/issue-1368 branch to the develop branch, thanks for taking note @szhorvat .",True,{}
igraph/igraph,https://github.com/igraph/igraph,1379,2020-04-29T13:16:12Z,2020-04-30T09:47:05Z,2020-04-30T09:47:26Z,MERGED,True,1,1,1,https://github.com/khitrin,Fix arpack callback for sparse matrixes,1,[],https://github.com/igraph/igraph/pull/1379,https://github.com/khitrin,1,https://github.com/igraph/igraph/pull/1379,"Fix wrong vector usage in igraph_i_eigen_matrix_sym_arpack_cb: source vector was completely ignored leading to incorrect multiplications in igraph_eigen_matrix_symmetric for sparse matrix.
Also, there is the duplicate code in sparsemat.c (function igraph_i_sparsemat_arpack_multiply), but I propose to add small patch to next bugfix release without major refactoring.","Fix wrong vector usage in igraph_i_eigen_matrix_sym_arpack_cb: source vector was completely ignored leading to incorrect multiplications in igraph_eigen_matrix_symmetric for sparse matrix.
Also, there is the duplicate code in sparsemat.c (function igraph_i_sparsemat_arpack_multiply), but I propose to add small patch to next bugfix release without major refactoring.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1379,2020-04-29T13:16:12Z,2020-04-30T09:47:05Z,2020-04-30T09:47:26Z,MERGED,True,1,1,1,https://github.com/khitrin,Fix arpack callback for sparse matrixes,1,[],https://github.com/igraph/igraph/pull/1379,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1379#issuecomment-621729882,"Fix wrong vector usage in igraph_i_eigen_matrix_sym_arpack_cb: source vector was completely ignored leading to incorrect multiplications in igraph_eigen_matrix_symmetric for sparse matrix.
Also, there is the duplicate code in sparsemat.c (function igraph_i_sparsemat_arpack_multiply), but I propose to add small patch to next bugfix release without major refactoring.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1383,2020-05-15T15:08:00Z,2020-05-15T18:16:23Z,2020-05-15T18:16:23Z,MERGED,True,1,1,1,https://github.com/vtraag,doc(components.c): fixed typo.,1,[],https://github.com/igraph/igraph/pull/1383,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1383,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1384,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1384#issuecomment-630810142,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.",Perhaps one immediate question: why were some of the defintions changed from igraph... to igraphx... @gaborcsardi? Is this necessary for any particular reason?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1384#issuecomment-630819952,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","I would like to raise the following points:

It seems that most of the explicit (void*) casts could be easily integrated.
There are a couple of return type changes from int to void. This might reduce some warnings, I will have to see.
There are a couple of changes from int to long int, perhaps this is indeed necessary to accommodate some use cases. Perhaps this is also necessary in order to support R (better). Can you comment @gaborcsardi?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1384#issuecomment-630936462,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","It looks like some of the changes should be kept in the cran branch unless we find a workaround that makes both us and CRAN happy. For instance, df716b9 removes a try..catch handler from the C++ code because it makes CRAN unhappy, but it also means that we won't return an IGRAPH_ENOMEM when we cannot allocate enough memory.
1eee899 is legit and it can easily be merged into the master branch.
d474630 actually seems to be multiple commits in one; some changes (e.g., the ones in the parsers) are unrelated to R and ARPACK. They probably belong to the next commit, but I'm okay with these in general.
The magic with igraphxdgemv vs igraphdgemv seems to work around some imcompatibility between the dgemv function when igraph is built with gfortran vs when it is built without it; I cannot comment on why this is necessary.
I don't see why the explicit (void*) casts in realloc() are necessary; I wonder what sort of warning it triggers on CRAN's side -- isn't it allowed to pass in an arbitrary pointer to a function that expects void*?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1384#issuecomment-631054559,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","I don't see why the explicit (void*) casts in realloc() are necessary; I wonder what sort of warning it triggers on CRAN's side -- isn't it allowed to pass in an arbitrary pointer to a function that expects void*?

I agree, casting to void should not be necessary in C. In fact, after some searching, it seems to be considered bad practice because it can hide mistakes (because the compiler won't complain about using void * where a more specific pointer is required). I also tried if I can trigger warnings, but I cannot, even with -Wpedantic. https://godbolt.org/z/GzkXoX
In C++, this cast would be needed, but not in C.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1384#issuecomment-631054946,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","The Bliss modification, I'll check that in more detail later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1384#issuecomment-631056824,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","In C++, this cast would be needed, but not in C.

That could be an issue. I don't know how the CRAN pipeline works, but it could be the case that they compile everything with a C++ compiler by default.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1384#issuecomment-631058192,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","While we're on the topic of R-specific changes, take a look at this:
https://github.com/igraph/igraph/blob/develop/src/cliquer/misc.h#L38
A Cliquer error would terminate the process, but when USING_R, it just call a generic R error function.
This is why I still believe that we need a special igraph_abort() that is a replacement for abort() but does not terminate the process.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1384#issuecomment-631059287,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","In C++, this cast would be needed, but not in C.

That could be an issue. I don't know how the CRAN pipeline works, but it could be the case that they compile everything with a C++ compiler by default.

The Cliquer stuff can't be compiled as C++ at all because it uses new as a variable name. So it cannot be this. I know this because I tried to compile it as C++ in order to deal with that ASSERT macro I define above. The idea was to use an exception to bail out. (I no longer think that's a good idea.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/gaborcsardi,10,https://github.com/igraph/igraph/pull/1384#issuecomment-631099938,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","I don't think you need to merge this, I can try to use the master branch again for the next R release, and fix there whatever issues come up.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1384#issuecomment-632581895,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","I will go through the changes in this branch and merge some of these changes (the ones that I do understand and that cause no semantic changes) manually into master. Then we can close this PR and try to build igraph's C core from the master branch. If the build fails on CRAN, let's try to fix them again based on the cran branch to see which one of the changes are still necessary, and merge them back into master if they are not too R-specific to avoid having to maintain two separate branches.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1384#issuecomment-632583819,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","@szhorvat

While we're on the topic of R-specific changes, take a look at this:

Having an igraph_abort() is a good idea and I'm all in favour of it. The R headers do the following to mark a function as not returning:
#if defined(__GNUC__) && __GNUC__ >= 3
#define NORET __attribute__((noreturn))
#else
#define NORET
#endif

Clang has _Noreturn instead; we need to incorporate this as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1384#issuecomment-632614860,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","Closing this PR; I have merged a few changes from this PR back to master (and then develop) where it made sense.
As for the remaining hackery with BLAS, LAPACK etc -- I am more and more convinced that we should simply get rid of all the embedded libraries in igraph and just admit it that igraph is a complex library with lots of dependencies that have to be installed first. This should probably be discussed in the forum first, though, so I'm not going to do anything about it right now. Let me know if you have opinions about this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1384#issuecomment-633311602,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.",Thanks for cleaning this up @ntamas ! Shall we remove the cran branch to make sure there will be no confusion in the future?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1384,2020-05-19T13:14:09Z,2020-05-22T10:15:43Z,2020-05-25T09:39:21Z,CLOSED,False,113,114,20,https://github.com/vtraag,Pull in changes from the CRAN branch.,7,[],https://github.com/igraph/igraph/pull/1384,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1384#issuecomment-633481704,"This PR is meant to discuss the changes that were made in the cran branch. It seems that there have been some useful changes, but also some changes were superseded by more recent commits in the master branch.
I will simply go through all the changes, and indicate which changes I think should be corrected. I believe we will be able to merge to the master, if it turns out that we will need to make API breaking changes, we could retarget it to develop.","It is @gaborcsardi 's turf; there might be some nightly build servers at CRAN or anywhere else that look for this branch, so let's keep it around until he is okay with the removal.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/jmonlong,1,https://github.com/igraph/igraph/pull/1386,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1386#issuecomment-633276936,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","@jmonlong Thanks so much for the PR!
First, a note that this will need to go on the develop branch, as it breaks the API (we can deal with this later).
@vtraag What is your opinion on modifying the igraph_modularity function directly? I notice that you did not do this when contributing igraph_community_leiden, which uses a similarly defined quality measure. Would it be better to separate this into another function?
If we do change igraph_modularity itself, some explanation in the documentation will be necessary (e.g. which included community detection functions does this apply to?), as well as an update of the formula.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1386#issuecomment-633294568,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?

Because this PR breaks API, as @szhorvat  already noted, we will first have to wait until the next minor version is released (0.9.0). Once that is released, we have to update the C core of rigraph, after which we can open a PR to include the updated functionality. We will no longer work with the cran branch, rigraph should start using the master branch again (soon).
Note that we use the develop branch for the next upcoming minor release (0.9.0 at the moment), while we use the master branch for any patch releases (0.8.x at the moment). This is why the PR needs to be merged to develop, not to master. Once we have released 0.9.0, it will become available from the master branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1386#issuecomment-633299005,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","One other nitpick thing is the order of the arguments. I think it would be good if we default to having const parameter first, if possible. That way, any parameters that are used as ""output"" are at the end of the function. This is not always possible because some arguments function both as input and output, but it might be useful as a principle. That means we should move the resolution_parameter before the other arguments. We haven't yet discussed any standard for that @szhorvat , @ntamas, but what do you think?

I think this discussion can be left for later (after this is merged). It's okay to change the API again before the 0.9 release, and this discussion would involve other functions too.


Perhaps we should add a test for modularity with a resolution parameter? Currently only the default is tested, perhaps it would also be good to test with another resolution parameter.

I think this is important. @jmonlong If you have time, and know your way around igraph's testing framework, it would be really great if you could add this. If you don't know how to add tests, a C program, along with a text file containing its expected output, is fine. We'll take care of the rest.


Probably better to use resolution_parameter, to be consistent with the current leiden implementation.

Indeed, the best name is an explicitly descriptive name. Most users won't already be familiar with the method and come looking for it. Instead, they'll be browsing the library to see what's available for community detection. For them, the name gamma is absolutely uninformative.
If too long, consider resolution?

@vtraag If you have time, could you fix up the docs a little bit and push to this PR directly, before merging?
In particular, in the docs of igraph_modularity:

the generalized modularity needs a bit more explanation and the formula needs updating
it would be useful to have a reference for this generalized definition
explicitly point out that gamma = 1 needs to be used to get the classical definition
link to other igraph functions which use this generalized definition (i.e. igraph_community_multilevel at this point)

In the docs of igraph_community_multilevel:

explicitly point out that the modularity output parameter uses the generalized definition (otherwise some will certainly be confused about what the value returned by this function does not match the well-known classic definition).
include a reference to the paper where this was originally described

@vtraag If you don't have time now, please help with the paper references and I'll push a draft. Then you can fix it up as the community detection expert.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/jmonlong,5,https://github.com/igraph/igraph/pull/1386#issuecomment-633316258,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","No problem, I can do my part today. Even the parameter ordering (const first) makes a lot of sense, I added the new thing at the end without thinking.
Just a clarification about having multilevel test with a different resolution. Do you mean adding a small test to prevent future regression or a test to ensure the code works correctly?
The former is easy, I can add a test checking for the output of the current membership assignment of the multilevel code. The latter is harder because I don't really have an example with a known truth. As a sanity check, I just tested that increasing the resolution increased the number of communities and that they look like communities in the graph.


Perhaps we should add a test for modularity with a resolution parameter? Currently only the default is tested, perhaps it would also be good to test with another resolution parameter.

I think this is important. @jmonlong If you have time, and know your way around igraph's testing framework, it would be really great if you could add this. If you don't know how to add tests, a C program, along with a text file containing its expected output, is fine. We'll take care of the rest.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1386#issuecomment-633533083,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","Thanks for the fast response @jmonlong!
Regarding a test, I thought you could do something as follows:

This comes from this article.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1386#issuecomment-633569009,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?",I made some more edits to the docs.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/jmonlong,8,https://github.com/igraph/igraph/pull/1386#issuecomment-633703954,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","The good news: I could reproduce the figure from the paper you linked using Rigraph. That's reassuring!

The bad news: I'm still not sure how I should add a test to igraph. I didn't find a value for the membership/modularity in the paper that I could use as expected value for the test. I think the algorithm also depends on the edges/nodes order in the graph definition anyway, so the same graph would get different results depending on how it was constructed.
Should I just add whatever output we get now as the expected value for the test? Just as safeguard against future regressions?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1386#issuecomment-633863558,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","Great, good to see it all works as expected!
Adding a test is relatively straightforward. You can simply add it to the existing file examples/simple/igraph_community_multilevel.c. If you compile and run that C program, you can then store the output in examples/simple/igraph_community_multilevel.out. When running make check the testing framework automatically compiles the C program and compares it to the expected output.
If you can't get it to work, no problem, if you can post the code here, I will make sure to add it as a proper test.",True,{'THUMBS_UP': ['https://github.com/jmonlong']}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/iosonofabio,10,https://github.com/igraph/igraph/pull/1386#issuecomment-633875674,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","Hi guys, actually it'd be great if new tests could be addeed to examples/tests instead of examples/simple. Thank you!
Edit: Oh sorry seems like I misunderstood. If there is already a test file, of course feel free to just edit it.",True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1386#issuecomment-634038620,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","Regarding resolution_parameter vs resolution: I would prefer the latter; _parameter seems to be redundant -- in a strict sense, all function arguments are parameters one way or another. We can call it ""resolution parameter"" in the docs, though, if we want to improve searchability.",True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1386#issuecomment-634108035,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","@ntamas Do you have any opinion on the argument reshuffling that happened here?
Personally, I am not sure I am comfortable with the const-first approach applied in general, but my question refers only to this single instance. The general discussion should be left for another day.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/jmonlong,13,https://github.com/igraph/igraph/pull/1386#issuecomment-634444073,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?",I updated the test with the output for a higher resolution and renamed the parameter to resolution. Let me know if you want the argument order back like it was before (+ the new parameter at the end).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1386#issuecomment-634516730,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","I'm happy with changing the name to resolution instead of resolution_parameter. The current order of arguments makes sense to me, we can indeed leave the more general discussion for another time. The test with a higher resolution parameter is also fine with me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1386#issuecomment-634519824,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","If we all agree that resolution is the proper name, and that the arguments are in the right order, then the only thing left to do is to make sure that resolution is used everywhere, also for the internal functions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1386#issuecomment-634531316,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","the only thing left to do is to make sure that resolution is used everywhere

Done.
Also changed some error messages and added a missing check.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/1386#issuecomment-634597686,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?","@szhorvat

Do you have any opinion on the argument reshuffling that happened here?

What we have here right is perfectly fine for me. The const-first approach is a good rule of thumb, but we can deviate from it if it feels unnatural in some cases. The only rule that I want to stick to at all costs is that the ""this"" argument (i.e. in most cases the graph that the function operates on) comes first.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1386,2020-05-24T18:08:01Z,2020-05-30T19:29:14Z,2020-05-30T19:29:14Z,MERGED,True,184,105,7,https://github.com/jmonlong,Gamma resolution for louvain/multilevel community detection,13,[],https://github.com/igraph/igraph/pull/1386,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1386#issuecomment-634604229,"I added a the gamma resolution parameter for louvain/multilevel community detection. This stems from a request on the rigraph repo: igraph/rigraph#239.
It compiles and the test from make check worked on my machine (ubuntu). I also wrote the rigraph side of it and tested the new parameters on a few examples. It performs as expected so all looks good to me.
I'm not sure what's the next steps to coordinate with the rigraph repo. Should I wait until this is merged here (or in the cran branch?) before creating a pull request in the rigraph repo?",Can be merged as far as I'm concerned.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1388,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name","Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name",True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1388#issuecomment-633885092,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name","I just added build parallelization using make -j2, as recommended by Travis. This comes with the disadvantage of messing up the output order, so I'm not sure we want it. Let me know what you think.
The overall run time came down from 10:43 to 7:32, mostly due to the Mac build. I'm not sure that's worth it.
Non-parallel build:

Parallel build (make -j2):",True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1388#issuecomment-634005264,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name","Seems OK for me -- apart from the test failure of course.
Regarding the output order: to be honest, I hardly ever look at the detailed CI logs if there is a failure, so I don't mind if the output is messed up a bit. However, I do mind waiting for 20 mins for the results of a CI build, especially when merging a PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1388#issuecomment-634005987,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name",Shall I merge this or do you want to work on this further?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1388#issuecomment-634007583,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name","Go ahead and merge.
If you have time, can you also merge into develop? Merging master into develop will need resolving the conflict from #1341",True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1388#issuecomment-634012554,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name","#1341 conflicts with feature/cmake-build, not with develop.
develop should now be up-to-date with master.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1388,2020-05-25T15:13:59Z,2020-05-26T13:04:09Z,2020-06-13T08:25:30Z,MERGED,True,21,6,1,https://github.com/szhorvat,Improvements to CI,1,[],https://github.com/igraph/igraph/pull/1388,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1388#issuecomment-634015016,"Fixes #1387
Changes:

Build with external GLPK for a small speedup
Remove stages and use only jobs for full parallelization (i.e. test doc build in parallel)
Test with 80-bit x87 floating-point arithmetic (currently reveals failures)
Identify each job by name","oops, you're right!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1391,2020-05-27T13:11:34Z,2020-05-28T11:14:00Z,2020-05-28T11:14:00Z,MERGED,True,114,61,5,https://github.com/szhorvat,topological_sorting: raise error if the graph is not acyclic,1,[],https://github.com/igraph/igraph/pull/1391,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1391,"topological_sorting would only show a warning if the graph is not acyclic. Now it raises an error. Fixes #1380.
Additional changes:

Error message formatting (see https://igraph.discourse.group/t/standardize-error-and-warning-styles/249)
Move tests to examples/tests
Retain examples/simple/igraph_topological_sorting.c in a simplified form for the docs
Edit the documentation

This goes to develop because it changes the behaviour significantly.","topological_sorting would only show a warning if the graph is not acyclic. Now it raises an error. Fixes #1380.
Additional changes:

Error message formatting (see https://igraph.discourse.group/t/standardize-error-and-warning-styles/249)
Move tests to examples/tests
Retain examples/simple/igraph_topological_sorting.c in a simplified form for the docs
Edit the documentation

This goes to develop because it changes the behaviour significantly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1391,2020-05-27T13:11:34Z,2020-05-28T11:14:00Z,2020-05-28T11:14:00Z,MERGED,True,114,61,5,https://github.com/szhorvat,topological_sorting: raise error if the graph is not acyclic,1,[],https://github.com/igraph/igraph/pull/1391,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1391#issuecomment-635276133,"topological_sorting would only show a warning if the graph is not acyclic. Now it raises an error. Fixes #1380.
Additional changes:

Error message formatting (see https://igraph.discourse.group/t/standardize-error-and-warning-styles/249)
Move tests to examples/tests
Retain examples/simple/igraph_topological_sorting.c in a simplified form for the docs
Edit the documentation

This goes to develop because it changes the behaviour significantly.",Many thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1392,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1392#issuecomment-634992560,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","I started working on this but there seemed to be a strong opinion that each function deserves its own PR.
My opinion is we should fix the whole file in a single PR. If you do it it's great, or I can do it too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1392#issuecomment-635113564,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","Ah, sorry, I though you were still looking for what the error was! But let me indeed follow up on the other functions. I think it makes sense to treat all functions in this PR, and we can then do the larger overhaul in another PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/1392#issuecomment-635115838,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","That'd be fantastic. I had a look at your changes and it looks good except maybe some corner case when the cutoff is set to exactly 0?
edit: I know that makes no sense, but still, we probably want to cover those corner cases now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1392#issuecomment-635346802,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","Well, yes, I made a slight modification to the cutoff, which makes more sense I think. As the documentation says, the cutoff  indicates

The maximal length of paths that will be considered.

That means that only paths that are strictly longer than the cutoff should not be considered. Paths that are equal to the cutoff should then be included still.
For a cutoff of zero, this implies that no paths should be explored at all. In other words, only for strictly negative cutoff the cutoff will not be used. I now realize that the explanation for the zero-cutoff should still be corrected in the documentation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1392#issuecomment-635829173,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","Note that the test fails because I have not corrected them yet. @szhorvat, if you agree that this solution works, I will update those tests, and also correct the other functions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1392#issuecomment-636310755,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","I can confirm that the examples I looked at in #1316 do work as I would expect them to.
#1316 (comment)
I'll do more checks later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1392#issuecomment-636312526,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","I wrote a dead slow, but exact (rational numbers) and easy to verify implementation of betweenness with cutoff in Mathematica, and tested this for several random graphs of different densities. It's all good! Go ahead and update the tests @vtraag.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1392#issuecomment-636312695,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","Maybe it's worth noting that the precision of the results is not that great. The difference between the exact results and the ones returned by igraph is tends to be on the order of 10^-8 to 10^-9 for graphs on up to 100 vertices.
I should have noted that the verification program I wrote only works for unweighted graphs. I did not test the weighted case extensively.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1392#issuecomment-638207353,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.",Thanks so much @vtraag and @iosonofabio! I was really bothered by this bug.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1392#issuecomment-640896047,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","I was now just working on improving things for other related functions. It seems that for igraph_closeness the same problem does not hold.
However, I did want to change the cutoff to be consistent with the implementation as I now made it for igraph_betweenness. I decided that only negative cutoffs are used to indicate that no cutoff will be used. I just came across issue #1050, in which @ntamas states to prefer not to use cutoff = 0 to calculate results. To me, the documentation

The maximal length of paths that will be considered.

indicates that lengths that are strictly larger than the maximal length should not be considered. Hence, paths of length 4 will be considered if the cutoff = 4, but not if cutoff = 3.9. That is also why I used cutoff = 0 to indicate that essentially no paths will be considered, because it is consistent with this interpretation. @ntamas, @szhorvat , @iosonofabio , can we all agree that a cutoff < 0 will be used to indicate that no cutoff will be used, and that we use a strict inequality, i.e. paths for which distance > cutoff will not be considered.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1392#issuecomment-640898269,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","On a different, yet slightly related note, I was checking igraph_edge_betweenness. The problem with the cutoff does appear for the weighted variant. Incidentally, some things work better for the unweighted variant, because some of the vectors are cleared repeatedly.

  
    
      igraph/src/centrality.c
    
    
        Lines 2421 to 2424
      in
      87f4142
    
  
  
    

        
          
           memset(distance, 0, (size_t) no_of_nodes * sizeof(long int)); 
        

        
          
           memset(nrgeo, 0, (size_t) no_of_nodes * sizeof(unsigned long long int)); 
        

        
          
           memset(tmpscore, 0, (size_t) no_of_nodes * sizeof(double)); 
        

        
          
           igraph_stack_clear(&stack); /* it should be empty anyway... */ 
        
    
  


@ntamas, I assume this is just legacy code, and that I can change it so as to work similar to the current implementation of igraph_betweenness_estimate?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1392#issuecomment-641389132,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","can we all agree that a cutoff < 0 will be used to indicate that no cutoff will be used

Yes, it seems logical to me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1392,2020-05-27T13:17:44Z,2020-06-03T13:36:24Z,2022-02-24T09:47:25Z,MERGED,True,217,18,4,https://github.com/vtraag,Correct cutoff for betweenness.,3,[],https://github.com/igraph/igraph/pull/1392,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1392#issuecomment-641389329,"This should fix #1316, where incorrect results for betweenness were reported when a cutoff was being used.
The problem was twofold:

Some nodes were incorrectly being seen as too distant for some source node because the distance was not reset if that node was too distant for another source node.
Nodes were still being added to the predecessor list, even when they were too distant.

The same problem may also play in other parts:

igraph_i_edge_betweenness_estimate_weighted
igraph_i_closeness_estimate_weighted
igraph_closeness_estimate

These should still be corrected.
I would like to suggest to rewrite significant parts of the code. First of all, it would be a lot clearer if we indeed would use actual distances, instead of using distances + 1. Secondly, some variable names are not as clear as they could be. Finally, some parts seem to use a sort of legacy code, where simply direct arrays are used instead of igraph_vector_t. I think it would be good to simply use the types that are supplied by igraph as much as possible, instead of arrays. If you agree, I will do so in this PR.
@szhorvat, could you first double check if things are working correctly now? I have a test case, we could also add it to the tests, let me know what you prefer.","I assume this is just legacy code, and that I can change it so as to work similar to the current implementation of igraph_betweenness_estimate?

Yes, feel free to change this. Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1399,2020-06-08T09:04:11Z,2020-06-08T20:46:54Z,2020-06-08T20:47:06Z,MERGED,True,50,5,5,https://github.com/szhorvat,count_multiple: fix counting self-loops in directed graphs,3,[],https://github.com/igraph/igraph/pull/1399,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1399,"See here:
https://igraph.discourse.group/t/computing-loops-using-count-multiple/276/3?u=szhorvat
There are a few style fixes too.","See here:
https://igraph.discourse.group/t/computing-loops-using-count-multiple/276/3?u=szhorvat
There are a few style fixes too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1399,2020-06-08T09:04:11Z,2020-06-08T20:46:54Z,2020-06-08T20:47:06Z,MERGED,True,50,5,5,https://github.com/szhorvat,count_multiple: fix counting self-loops in directed graphs,3,[],https://github.com/igraph/igraph/pull/1399,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1399#issuecomment-640686777,"See here:
https://igraph.discourse.group/t/computing-loops-using-count-multiple/276/3?u=szhorvat
There are a few style fixes too.",(This is ready to merge.),True,{}
igraph/igraph,https://github.com/igraph/igraph,1399,2020-06-08T09:04:11Z,2020-06-08T20:46:54Z,2020-06-08T20:47:06Z,MERGED,True,50,5,5,https://github.com/szhorvat,count_multiple: fix counting self-loops in directed graphs,3,[],https://github.com/igraph/igraph/pull/1399,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1399#issuecomment-640877781,"See here:
https://igraph.discourse.group/t/computing-loops-using-count-multiple/276/3?u=szhorvat
There are a few style fixes too.","Thanks, merged!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1400,2020-06-08T10:04:45Z,2020-06-08T12:41:30Z,2020-06-08T12:41:31Z,MERGED,True,48,1,12,https://github.com/szhorvat,test_utilities: add support for checking that the FINALLY stack is empty,1,[],https://github.com/igraph/igraph/pull/1400,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1400,In response to #1346 (comment),In response to #1346 (comment),True,{}
igraph/igraph,https://github.com/igraph/igraph,1400,2020-06-08T10:04:45Z,2020-06-08T12:41:30Z,2020-06-08T12:41:31Z,MERGED,True,48,1,12,https://github.com/szhorvat,test_utilities: add support for checking that the FINALLY stack is empty,1,[],https://github.com/igraph/igraph/pull/1400,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1400#issuecomment-640578304,In response to #1346 (comment),You beat me to it -- I wanted to do the same thing this afternoon :),True,{}
igraph/igraph,https://github.com/igraph/igraph,1402,2020-06-08T22:08:59Z,2020-06-08T22:19:37Z,2020-06-08T22:19:42Z,MERGED,True,6,6,2,https://github.com/vtraag,Corrected edge attribute description in the documentation,1,[],https://github.com/igraph/igraph/pull/1402,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1402,"Accidentally, some edge attribute were described as being set for all vertices, instead of all edges.","Accidentally, some edge attribute were described as being set for all vertices, instead of all edges.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1402,2020-06-08T22:08:59Z,2020-06-08T22:19:37Z,2020-06-08T22:19:42Z,MERGED,True,6,6,2,https://github.com/vtraag,Corrected edge attribute description in the documentation,1,[],https://github.com/igraph/igraph/pull/1402,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1402#issuecomment-640917324,"Accidentally, some edge attribute were described as being set for all vertices, instead of all edges.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1403,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1403#issuecomment-641140725,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","The problem of the incorrect FINAL stack size is resolved in PR #1405. I have pushed that solution separately, because it should also be merged to master, while this PR should only be pushed to develop.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1403#issuecomment-641149693,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","#1405 is also merged in develop now, you can pull it into this PR",True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1403#issuecomment-641182476,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","#1405 is also merged in develop now, you can pull it into this PR

Thanks! I force-pushed commits that are rebased against the updated develop branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1403#issuecomment-641186870,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.",Why was a force-push necessary? Would it be sufficient to just pull into this PR branch?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1403#issuecomment-641188487,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","Why was a force-push necessary? Would it be sufficient to just pull into this PR branch?

I just wanted to keep the commits neat, so I rebased, that's all.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1403#issuecomment-641283099,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1403#issuecomment-642797656,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","@vtraag Do we want to update modularity_matrix as well? While the analogous generalization is trivial, I have not used this concept in my work. Any changes should be made with real applications in mind.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1403,2020-06-09T08:20:16Z,2020-06-09T13:12:34Z,2020-06-11T17:34:51Z,MERGED,True,210,31,6,https://github.com/vtraag,Support for directed graphs when calculating modularity,1,[],https://github.com/igraph/igraph/pull/1403,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1403#issuecomment-642828546,"I implemented the calculation of modularity for directed graphs, as requested in #1358. Note that many functions currently do not support directed graphs, and hence, for those functions igraph_modularity now returns the undirected version of modularity. One function does support directed graphs (igraph_community_edge_betweenness) and for that it does return the directed version of modularity (if so indicated).
I've also provided some tests to check whether the directed definition provides the same modularity as the undirected definition when simply expanding an undirected graph to a directed graph with both directions present. Additionally, I check whether the aggregation also works correctly and provides the same modularity.
Note that for this test it seems that the stack is not empty. I am still checking where the problem is (not in igraph_modularity). But great improvement to catch these things early on @szhorvat and @ntamas ! Until that is sorted out, I mark this as a draft PR, but feel free to already comment if you want.","@szhorvat, yes I was thinking it would be most reasonable to do that as well. I left that for another occasion though. We could open a separate issue for that to keep track.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1404,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1404#issuecomment-641140793,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","One short comment:
I would rather not use NDEBUG for this as I am not convinced that it is a good idea to compile release binaries with NDEBUG defined (and therefore all asserts disabled).
I would suggest introducing a separate flag, i.e. something ike
#if (IGRAPH_VERIFY_FINALLY == 1)
...
#endif
This can then be toggled explicitly, and can also be coupled to another flag, should we decide to have a global debug flag (NDEBUG or something else) later. #if is better than #ifdef here because one can also explicitly toggle it off on the compiler command line as gcc -DIGRAPH_VERIFY_CHECK=0, should it be necessary.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1404#issuecomment-641145314,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","Great idea BTW! 👍
First let's concentrate on fixing everything detected by this, and then we can polish the details.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1404#issuecomment-641187429,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",Can you please pull the latest master branch into this one as well so we can see how many of the test failures were fixed by #1405?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1404#issuecomment-641204721,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",This broke the doc build. I think it wants the doc comment to come before the #define line (it won't tolerate an #ifdef intruding between the doc comment and the #define).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1404#issuecomment-641206077,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","Here's the list of failing tests. When you start working on any of them, edit the list below and add your name to it. This way we can avoid accidentally duplicating work.
If you just want to add some helpful comment, and them as sublist items.


 140: LAD subgraph isomorphism algorithm              FAILED (topology.at:47) @szhorvat

lad.c line 1576, IGRAPH_CHECK(igraph_i_lad_createGraph(pattern, &Gp));



 182: All minimal s-t cuts of a graph (igraph_all_st_mincuts):  FAILED (flow.at:58) @ntamas


 235: Minimum size separators (igraph_minimum_size_separators):  FAILED (separators.at:46) @ntamas


 236: Cohesive blocking (igraph_cohesive_blocks):     FAILED (separators.at:52) @ntamas",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1404#issuecomment-641213388,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",@vtraag Let's print the difference between the initial and final stack sizes. It will aid debugging.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1404#issuecomment-641231419,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","The LAD thing is not technically a bug. There is not expected to be a match in the stack size at the function call boundary.
It concerns the igraph_i_lad_createGraph function. There is no corresponding destroyGraph function which could be added to FINALLY. Therefore, each member of LAD's Tgraph struct is freed separately.
We can fix it up so that stack sizes are enforced to match at function call boundaries, but I can not do it today. It will require care. This is a port of the original LAD code to use igraph's memory management, so it's easy to break things.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1404#issuecomment-641237699,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",@vtraag Can I push fixes to the issues above directly to this PR branch? It'll make it simpler to verify that they're indeed fixed.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1404#issuecomment-641247668,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","@szhorvat, yes, feel free to push to this PR! And also feel free to adjust the definition as you see fit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1404#issuecomment-641254561,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",Great idea guys! I'll also add this to the CMake build branch once it has made its way to master.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1404#issuecomment-641267018,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",Is it OK if I convert this PR to draft until all the test failures are resolved?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1404#issuecomment-641287777,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","@ntamas please take a look at the last commit I made, and check that it's fine. As I remember you made the LAD port originally (sorry if I'm wrong).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1404#issuecomment-641306981,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","It wasn't me, but it seems okay to me, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1404#issuecomment-641375299,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",#1406 is now in master; rebasing this against master should allow us to check whether #1406 fixed anything.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1404#issuecomment-642539463,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",The remaining failures can all be attributed to st-cuts.c; I'll try to fix this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/1404#issuecomment-642542174,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","@vtraag seems like I can't push to this branch; you need to merge this to fix the failing tests scratch that, I mistyped the branch name",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/vtraag,18,https://github.com/igraph/igraph/pull/1404#issuecomment-642543617,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","I was just pulling it in, only to be looking at your commit :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,19,https://github.com/igraph/igraph/pull/1404#issuecomment-642544173,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","Regarding the NDEBUG flag: I would also prefer to have a separate compile-time switch for this; something we can also configure from ./configure, similarly to --enable-lto (although we can simply connect it to --enable-debug, that's also okay for me).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/vtraag,20,https://github.com/igraph/igraph/pull/1404#issuecomment-642544845,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",I'm fine with either --enable-debug or with a new flag.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1404#issuecomment-643622318,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","I integrated it into the configure script as a separate option: --enable-verify-finally. This will add -DIGRAPH_VERIFY_FINALLY_STACK=1 to CPPFLAGS.
First I added the define to config.h, but I realized that config.h is not installed. It is only used during compilation. The alternative is to have a new header (something.h.in) that ./configure can modify. That seemed too complicated.
@vtraag  I'll leave squashing and reordering commits to you. I did not want to do a force push.
Take this as a proposal. We can still modify it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1404#issuecomment-643622997,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","I also added it to Travis, but not to AppVeyor. I'll leave that to @ntamas. It's not clear to me if the version uploaded to PyPI is from AppVeyor—if yes, there should be no performance-ruining debug options enabled there.
I need to leave before the CI is done, hope I didn't break anything.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1404#issuecomment-643629150,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","I had to return because of a thunderstorm. I am happy to report that after running the Mathematica test suite (with some modifications so that direct calls from the Mma interface are also checked), everything is fine. No other mismatches were detected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,24,https://github.com/igraph/igraph/pull/1404#issuecomment-643635816,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","The alternative is to have a new header (something.h.in) that ./configure can modify. That seemed too complicated.

This is what we are doing with igraph_threading.h (which is generated from igraph_threading.h.in at configuration time. Maybe we could rename that header (as it only contains one #define regarding thread safety) and use it?
As for the Appveyor CI, tbh I have no idea what we are doing there with different Python versions as it has nothing to do with the Python interface - that one is built and published from python-igraph. I think it's only used to check whether our Python-based build scripts work fine on Windows with varying versions of Pythons, so it is safe to update appveyor.yml as well. (I'll do it).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/ntamas,25,https://github.com/igraph/igraph/pull/1404#issuecomment-643638191,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",Also ported to the feature/cmake-build branch in e91296d,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/vtraag,26,https://github.com/igraph/igraph/pull/1404#issuecomment-643642126,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!","I have no idea what we are doing there with different Python versions

One reason to keep it to ensure that igraph is properly build against all relevant MSVC versions (e.g. C89 style declarations). Indeed another one is that we need to ensure that make msvc works properly in all Python versions. Finally,make check is also checked in MSYS, but this is done only once.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1404#issuecomment-643665608,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",@vtraag I'm quite happy about this addition. It was a really good idea 👍,True,{}
igraph/igraph,https://github.com/igraph/igraph,1404,2020-06-09T08:45:16Z,2020-06-13T15:01:01Z,2020-06-13T19:40:57Z,MERGED,True,95,50,5,https://github.com/vtraag,Verify FINAL stack size when debugging.,7,[],https://github.com/igraph/igraph/pull/1404,https://github.com/vtraag,28,https://github.com/igraph/igraph/pull/1404#issuecomment-643668745,"Following up on the excellent idea in PR #1400, I thought it would be good to test whether stack sizes are the same when entering and exiting functions. This is most readily done in the IGRAPH_CHECK macro, because these are already defined in many places. Obviously, missing IGRAPH_CHECK will continue to be a problem.
Note that this degrades performance significantly, so this should never be used in actual compilation, and only when compiled in debug mode (i.e. NDEBUG should be defined to prevent using this), but it does make it a lot easier to track down bugs in the error handling. This PR reveals a number of problems across igraph, which we should check out in more detail. I think it would be best to solve those problems in separate PRs to keep everything neat.
Curious to hear what you all think of this suggestion!",Thanks @szhorvat ! Perhaps there are similar improvements possible that might make it easier to identify potential bugs.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1405,2020-06-09T08:59:26Z,2020-06-09T09:11:59Z,2022-02-24T09:47:34Z,MERGED,True,1,1,1,https://github.com/vtraag,Corrected non-matching FINALLY and FINALLY_CLEAN when combining edges,1,[],https://github.com/igraph/igraph/pull/1405,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1405,"Using PR #1404, it became clear that the non-matching FINAL stack size in PR #1403 was due to a non-matching number of IGRAPH_FINALLY and IGRAPH_FINALLY_CLEAN calls. This PR corrects that problem, and hence, also corrects the problem report in #1403.","Using PR #1404, it became clear that the non-matching FINAL stack size in PR #1403 was due to a non-matching number of IGRAPH_FINALLY and IGRAPH_FINALLY_CLEAN calls. This PR corrects that problem, and hence, also corrects the problem report in #1403.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1406,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.",True,"{'HEART': ['https://github.com/gaborcsardi'], 'THUMBS_UP': ['https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1406#issuecomment-641267171,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","Nice trick!
Is it OK if I convert this PR to draft until all the test failures are resolved?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1406#issuecomment-641272935,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.",Converted to draft.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1406#issuecomment-641273111,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","I'll collect a list of warnings/issues in this post. Feel free to edit.

foreign.c:1158:48: warning: incompatible pointer types passing 'igraph_vector_ptr_t *(*)[3]' to parameter of type 'igraph_vector_ptr_t **'
      (aka 'struct s_vector_ptr **') [-Wincompatible-pointer-types]
    IGRAPH_FINALLY(igraph_i_gml_destroy_attrs, &attrs);
                                               ^~~~~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
foreign.c:980:62: note: passing argument to parameter 'ptr' here
static void igraph_i_gml_destroy_attrs(igraph_vector_ptr_t **ptr) {

^ Fixed by @ntamas
igraph_hashtable.c:35:41: warning: incompatible pointer types passing 'igraph_strvector_t *' (aka 'struct s_igraph_strvector *') to parameter of type
      'igraph_trie_t *' (aka 'struct s_igraph_trie *') [-Wincompatible-pointer-types]
    IGRAPH_FINALLY(igraph_trie_destroy, &ht->elements);
                                        ^~~~~~~~~~~~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
./igraph_types_internal.h:188:41: note: passing argument to parameter 't' here
void igraph_trie_destroy(igraph_trie_t *t);
                                        ^

^ Fixed by @ntamas
flow.c:745:47: warning: incompatible pointer types passing 'igraph_vector_int_t *' (aka 'struct igraph_vector_int_t *') to parameter of type
      'igraph_dqueue_t *' (aka 'struct igraph_dqueue_t *') [-Wincompatible-pointer-types]
        IGRAPH_FINALLY(igraph_dqueue_destroy, &added);
                                              ^~~~~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
../include/igraph_dqueue_pmt.h:37:69: note: passing argument to parameter 'q' here
DECLDIR void FUNCTION(igraph_dqueue, destroy) (TYPE(igraph_dqueue)* q);
                                                                    ^

^ Fixed by @ntamas
cattributes.c:3804:47: warning: incompatible pointer types passing 'igraph_vector_bool_t *' (aka 'struct igraph_vector_bool_t *') to parameter of type
      'igraph_vector_t *' (aka 'struct igraph_vector_t *') [-Wincompatible-pointer-types]
        IGRAPH_FINALLY(igraph_vector_destroy, log);
                                              ^~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
../include/igraph_vector_pmt.h:34:68: note: passing argument to parameter 'v' here
DECLDIR void FUNCTION(igraph_vector, destroy)(TYPE(igraph_vector)* v);
                                                                   ^

^ Fixed by @ntamas
igraph_fixed_vectorlist.c:53:53: warning: incompatible pointer types passing 'igraph_vector_ptr_t *' (aka 'struct s_vector_ptr *') to parameter of type
      'igraph_fixed_vectorlist_t *' (aka 'struct igraph_fixed_vectorlist_t *') [-Wincompatible-pointer-types]
    IGRAPH_FINALLY(igraph_fixed_vectorlist_destroy, &l->v);
                                                    ^~~~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
igraph_fixed_vectorlist.c:27:65: note: passing argument to parameter 'l' here
void igraph_fixed_vectorlist_destroy(igraph_fixed_vectorlist_t *l) {
                                                                ^

^ Fixed by @ntamas
scg_optimal_method.c:116:43: warning: incompatible pointer types passing 'igraph_matrix_int_t *' (aka 'struct igraph_matrix_int_t *') to parameter of type
      'igraph_matrix_t *' (aka 'struct igraph_matrix_t *') [-Wincompatible-pointer-types]
    IGRAPH_FINALLY(igraph_matrix_destroy, &Q);
                                          ^~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
../include/igraph_matrix_pmt.h:37:68: note: passing argument to parameter 'm' here
DECLDIR void FUNCTION(igraph_matrix, destroy)(TYPE(igraph_matrix) *m);
                                                                   ^

^ Fixed by @ntamas
glet.c:176:43: warning: incompatible pointer types passing 'igraph_vector_int_t *' (aka 'struct igraph_vector_int_t *') to parameter of type
      'igraph_vector_t *' (aka 'struct igraph_vector_t *') [-Wincompatible-pointer-types]
    IGRAPH_FINALLY(igraph_vector_destroy, &mark);
                                          ^~~~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
../include/igraph_vector_pmt.h:34:68: note: passing argument to parameter 'v' here
DECLDIR void FUNCTION(igraph_vector, destroy)(TYPE(igraph_vector)* v);
                                                                   ^
glet.c:178:43: warning: incompatible pointer types passing 'igraph_vector_int_t *' (aka 'struct igraph_vector_int_t *') to parameter of type
      'igraph_vector_t *' (aka 'struct igraph_vector_t *') [-Wincompatible-pointer-types]
    IGRAPH_FINALLY(igraph_vector_destroy, &map);
                                          ^~~~
../include/igraph_error.h:568:23: note: expanded from macro 'IGRAPH_FINALLY'
        if (0) { func(ptr); } \
                      ^~~
../include/igraph_vector_pmt.h:34:68: note: passing argument to parameter 'v' here
DECLDIR void FUNCTION(igraph_vector, destroy)(TYPE(igraph_vector)* v);
                                                                   ^

^ Fixed by @ntamas

That's all. If you want to fix one, add a note below it with your name.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1406#issuecomment-641299722,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","I won't be able to do more igraph stuff today, so everyone feel free to fix some of the above.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1406#issuecomment-641308645,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.",I'll take up a few of these now.,True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1406#issuecomment-641321672,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","Okay, fixed all of these, now I only need to figure out how to push to this PR :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1406#issuecomment-641323447,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","Clone https://github.com/szhorvat/igraph.git, check out fixes/finally-arg-check, then you can just push.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1406#issuecomment-641324707,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","Turns out there's an easier way: git push git@github.com:szhorvat/igraph fixes/finally-arg-check:fixes/finally-arg-check, no need for a separate checkout.
(I was using gh pr checkout 1406 on the CLI to get a copy of this PR in my own repo, I was sort-of-hoping that there is a gh pr push shortcut but it looks like there isn't).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1406#issuecomment-641326479,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","I actually have your repositories as remotes as well so that I can easily push to your PRs as well. But indeed, a gh pr push should be really the easiest!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1406#issuecomment-641327572,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","Please keep sharing these tips so we can all learn. I'm not a programmer, just a scientist 😁",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1406#issuecomment-641328590,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.","Looks like ready for review then. Can we merge this now?
When merged, it should also be pulled into #1404 to aid with all that work on FINALLYs",True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1406#issuecomment-641329216,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.",Let's wait for the CI checks; we can merge if they look all right.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1406,2020-06-09T12:40:04Z,2020-06-09T15:26:08Z,2020-06-09T15:26:09Z,MERGED,True,27,21,11,https://github.com/szhorvat,Check that the arguments of IGRAPH_FINALLY have the correct type,6,[],https://github.com/igraph/igraph/pull/1406,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1406#issuecomment-641373167,"I tend to make the mistake that I swap the arguments of IGRAPH_FINALLY and I write IGRAPH_FINALLY(ptr, fun) instead of the correct IGRAPH_FINALLY(fun, ptr).
Normally, my IDE (or the compiler) would warn when something like this is wrong. But IGRAPH_FINALLY is casting its arguments, which masks any errors.
This PR attempts to allow IGRAPH_FINALLY to check its args, like this:
#define IGRAPH_FINALLY(func,ptr) \
    { \
        if (0) { func(ptr); } \
        IGRAPH_FINALLY_REAL((igraph_finally_func_t*)(func), (ptr)); \
    }
The if (0) should be optimized away by the compiler, so performance is not a concern (unless I am missing something). But this line will cause the compiler to complain if the types don't match.
As expected, this keeps revealing errors. I did not fix them yet. Even if we do not decide to keep this modification to IGRAPH_FINALLY, we should fix these errors. I invite everyone to push to this PR and contribute. Note that we must pay attention to compiler warnings as well as to errors. Some problems show up as warnings only.
If you plan to work on a particular issue, post a note so we don't end up working on the same thing in parallel.",Travis builds passed; I think this is good to go.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1408,2020-06-10T02:18:48Z,2020-06-11T08:41:49Z,2020-06-11T08:41:51Z,MERGED,True,2,50,1,https://github.com/iosonofabio,Separate tips on writing igraph code onto wiki,1,[],https://github.com/igraph/igraph/pull/1408,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1408,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1408,2020-06-10T02:18:48Z,2020-06-11T08:41:49Z,2020-06-11T08:41:51Z,MERGED,True,2,50,1,https://github.com/iosonofabio,Separate tips on writing igraph code onto wiki,1,[],https://github.com/igraph/igraph/pull/1408,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1408#issuecomment-641852645,,Good idea to concentrate all support for development in the Wiki! I added the new page also to the sidebar.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1408,2020-06-10T02:18:48Z,2020-06-11T08:41:49Z,2020-06-11T08:41:51Z,MERGED,True,2,50,1,https://github.com/iosonofabio,Separate tips on writing igraph code onto wiki,1,[],https://github.com/igraph/igraph/pull/1408,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1408#issuecomment-642412420,,I started this: https://github.com/igraph/igraph/wiki/Contributing-your-first-function-to-igraph,True,{}
igraph/igraph,https://github.com/igraph/igraph,1408,2020-06-10T02:18:48Z,2020-06-11T08:41:49Z,2020-06-11T08:41:51Z,MERGED,True,2,50,1,https://github.com/iosonofabio,Separate tips on writing igraph code onto wiki,1,[],https://github.com/igraph/igraph/pull/1408,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1408#issuecomment-642503018,,"Thanks @iosonofabio, that looks great!
I'll merge this PR soon. A few comments to the wiki page that you have started:


How about using a feat/ or feature/ prefix for branches that contain new features and fix/ or bugfix/ for branches that contain bugfixes?


Regarding the copyright at the top of new files: we did not really bother updating the copyright notices in old files so in almost all places you see fairly old year numbers in the files (basically we added the copyright notice once when the file was added, and did not bother updating it after that, so the end year of the copyright notice reflects the year the file was added in). Assuming that the copyright notice refers to the contents of the file and not the entire library, I think it's enough to put The igraph development team in the header for new files, no need to include Gábor separately.


I also made a few changes to the example here and there; for instance, when an igraph function takes a vector or any other complex data structure as an output argument, it must always be initialized by the caller (except if the very purpose of the function is to create something anew). I also added missing IGRAPH_CHECK() calls and mentioned that internal functions are to be declared static unless needed from another compilation unit.


Just a note to myself: if (or, rather, when) we switch to CMake, we need to update these guidelines as well because adding a new test would look a bit different in CMake.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1409,2020-06-10T10:11:17Z,2020-06-11T09:25:03Z,2020-06-12T13:18:58Z,MERGED,True,35,23,2,https://github.com/vtraag,Corrected cutoff for edge_betweenness,1,[],https://github.com/igraph/igraph/pull/1409,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1409,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_edge_beweenness.
There are two changes in this PR. For igraph_edge_betweenness all vectors were always being cleared (unlike for igraph_betweenness), making the cutoff not problematic. This is changed, so that only the actually used nodes are being reset, similar to the implementation in igraph_betweenness. The resetting of these nodes is now correctly implemented, so that the cutoff works properly.
Secondly, the cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_edge_beweenness.
There are two changes in this PR. For igraph_edge_betweenness all vectors were always being cleared (unlike for igraph_betweenness), making the cutoff not problematic. This is changed, so that only the actually used nodes are being reset, similar to the implementation in igraph_betweenness. The resetting of these nodes is now correctly implemented, so that the cutoff works properly.
Secondly, the cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1409,2020-06-10T10:11:17Z,2020-06-11T09:25:03Z,2020-06-12T13:18:58Z,MERGED,True,35,23,2,https://github.com/vtraag,Corrected cutoff for edge_betweenness,1,[],https://github.com/igraph/igraph/pull/1409,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1409#issuecomment-642265681,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_edge_beweenness.
There are two changes in this PR. For igraph_edge_betweenness all vectors were always being cleared (unlike for igraph_betweenness), making the cutoff not problematic. This is changed, so that only the actually used nodes are being reset, similar to the implementation in igraph_betweenness. The resetting of these nodes is now correctly implemented, so that the cutoff works properly.
Secondly, the cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.",Same as for #1410: I think this should go into develop and not master - is that OK with you?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1409,2020-06-10T10:11:17Z,2020-06-11T09:25:03Z,2020-06-12T13:18:58Z,MERGED,True,35,23,2,https://github.com/vtraag,Corrected cutoff for edge_betweenness,1,[],https://github.com/igraph/igraph/pull/1409,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1409#issuecomment-643265591,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_edge_beweenness.
There are two changes in this PR. For igraph_edge_betweenness all vectors were always being cleared (unlike for igraph_betweenness), making the cutoff not problematic. This is changed, so that only the actually used nodes are being reset, similar to the implementation in igraph_betweenness. The resetting of these nodes is now correctly implemented, so that the cutoff works properly.
Secondly, the cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.",@vtraag The docs should be updated too.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1409,2020-06-10T10:11:17Z,2020-06-11T09:25:03Z,2020-06-12T13:18:58Z,MERGED,True,35,23,2,https://github.com/vtraag,Corrected cutoff for edge_betweenness,1,[],https://github.com/igraph/igraph/pull/1409,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1409#issuecomment-643266240,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_edge_beweenness.
There are two changes in this PR. For igraph_edge_betweenness all vectors were always being cleared (unlike for igraph_betweenness), making the cutoff not problematic. This is changed, so that only the actually used nodes are being reset, similar to the implementation in igraph_betweenness. The resetting of these nodes is now correctly implemented, so that the cutoff works properly.
Secondly, the cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","I'm sorry, they're already updated. I was looking at the wrong version of the source file.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1410,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1410#issuecomment-642264593,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Seems OK to me, but shouldn't this go into develop instead? This is a breaking change to the API (in case anyone relied on cutoff = 0 to reproduce the exact closeness calculation) so if we merge this into master, we won't be able to release 0.8.3 (if needed) from master.
Also, the changelog should be updated as part of the PR to make note of the breaking change.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1410#issuecomment-642270784,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","OK, fair point.
I only considered it an API breaking change if the function signature changed, not if the implementation did something different. I believe this is in line with general semantic versioning guidelines.
If we want to be a bit more stringent in that regard, that might be fine, but it might become difficult along the way. After all, the same problem occurs for many other fixes of course: the results may change, but the API itself remains unchanged. What do we consider then a breaking change, and what not? The API change is a clear decision criterion: if it changes (non-backwards-compatible), it is a breaking change. Considering implementation details may muddy the waters a bit I fear.
I do understand your concern though, and I'm not 100% sure what is the best solution here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1410#issuecomment-642271548,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","As another consideration, we then might have to rethink what we did with #1392, because that was already merged in master.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1410#issuecomment-642276162,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Well, in this particular case I think this is a breaking change because we even had unit tests for the edge betweenness case that checked whether cutoff = 0 behaves the same way as cutoff = -1, so in some sense we considered this as the ""expected"" behaviour. With this change, the expected behaviour suddenly changes and the unit tests had to be adjusted, so we essentially broke our earlier ""promise"" that cutoff = 0 is the same as cutoff = -1 (even if that promise was not explicit in the documentation). In my personal opinion, this is a breaking change. (In the JavaScript world, some teams even use automated tools for projects with good test coverage to decide whether a commit is a breaking change or not: just run the new codebase with the old tests, and if the tests break, then the commit was a breaking change).
However, if we did not have the tests in the codebase, we could in theory claim that this is merely a ""bugfix"" and thus does not constitute a breaking change. With the unit tests already in place, claiming that this is a bugfix is harder.
As for #1392, I failed to realize soon enough that this would get merged into master -- I would have probably complained otherwise :) I think that it's probably better to target the develop branch with all PRs by default, and if we decide that something is indeed a bugfix only, we can cherry-pick it into master. It's probably not worth undoing #1392 now as we are not really semver-compliant anyway (and even in semver, anything can happen in the 0.x series :)), but let's try to keep this in mind in the future.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1410#issuecomment-642457183,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","How about this?

We keep these changes on develop (I agree with @ntamas)
For #1392 we add an extra change on master only: we check if the cutoff is 0 and if so, we change it to -1. In the vast majority of cases, people would not want to use cutoff=0 anyway, as it's an extreme edge case. The priority is to maintain the interpretation of 0 as infinity for 0.8. Of course, #1392 does change the interpretation of cutoffs in other ways too, but that is part of a bugfix, so it's okay to keep.
Since we periodically merge master into develop, after the above change we need to do this merge and immediately undo this change on develop .
Expand the changelog, and carefully explain how the use of cutoff has changed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1410#issuecomment-642478922,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","OK, so we will consider something an API breaking change if its behaviour changes with respect to what is stated in the documentation? A correction of an implementation (e.g. something that did not work as documented) would then be considered not an API breaking change, but a bugfix. This also implies that the documentation is leading in what is (or should be) done in the function, which is a good thing. That is a principle that I can live with.
I'm fine with reverting the change in #1392 back to using cutoff = 0 indicating that no cutoff will be used in master. Indeed we need to be careful to change it back again in develop. Will you do this @szhorvat ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1410#issuecomment-642484924,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Will you do this @szhorvat ?

OK, if others agree, I'll do it next week. #1412",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1410#issuecomment-642503923,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Great, I'm happy that we are on the same page. Can I merge this into develop then?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1410,2020-06-10T10:48:11Z,2020-06-11T09:24:47Z,2020-06-11T09:24:47Z,MERGED,True,15,15,2,https://github.com/vtraag,Corrected cutoff for closenes,1,[],https://github.com/igraph/igraph/pull/1410,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1410#issuecomment-642527123,"Similar to #1316 and as implemented in #1392, this changes the cutoff as used for igraph_closeness.
Unlike for igraph_betweenness, the cutoff was not problematic for closeness.
The cutoff that is now used is consistent with the implementation in #1392, and considers all paths for which distance <= cutoff, as opposed to distance < cutoff, which it was before. Because of this, cutoff = 0 is also used, and will return all zero results (this reverts #1050). When cutff < 0, no cutoff is used at all, and paths of all lengths are considered.","Can I merge this into develop then?

As far as I am concerned, yes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1411,2020-06-11T04:42:12Z,2020-06-11T06:57:42Z,2020-06-11T06:57:47Z,MERGED,True,5,0,1,https://github.com/iosonofabio,IGRAPH_VECTOR_CHAR_INIT_FINALLY,1,[],https://github.com/igraph/igraph/pull/1411,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1411,"As inspired by the cycle basis PR, but as an isolated change","As inspired by the cycle basis PR, but as an isolated change",True,{}
igraph/igraph,https://github.com/igraph/igraph,1411,2020-06-11T04:42:12Z,2020-06-11T06:57:42Z,2020-06-11T06:57:47Z,MERGED,True,5,0,1,https://github.com/iosonofabio,IGRAPH_VECTOR_CHAR_INIT_FINALLY,1,[],https://github.com/igraph/igraph/pull/1411,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1411#issuecomment-642451452,"As inspired by the cycle basis PR, but as an isolated change",Thanks! I'll cherry-pick this into master as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1415,2020-06-11T19:49:13Z,2020-06-11T20:37:02Z,2020-06-11T20:37:02Z,MERGED,True,51,7,4,https://github.com/szhorvat,"Document IGRAPH_TO, IGRAPH_FROM, IGRAPH_OTHER",1,[],https://github.com/igraph/igraph/pull/1415,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1415,Fixes #1296,Fixes #1296,True,{}
igraph/igraph,https://github.com/igraph/igraph,1415,2020-06-11T19:49:13Z,2020-06-11T20:37:02Z,2020-06-11T20:37:02Z,MERGED,True,51,7,4,https://github.com/szhorvat,"Document IGRAPH_TO, IGRAPH_FROM, IGRAPH_OTHER",1,[],https://github.com/igraph/igraph/pull/1415,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1415#issuecomment-642904065,Fixes #1296,"If you fixed the typos, feel free to merge. Thanks a lot!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1416,2020-06-12T11:06:32Z,2020-06-12T13:11:49Z,2020-06-12T13:44:58Z,MERGED,True,72,58,1,https://github.com/szhorvat,degree_sequence_game: speedup for DEGSEQ_SIMPLE_NO_MULTIPLE_UNIFORM,1,[],https://github.com/igraph/igraph/pull/1416,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1416,"This speeds up the configuration model implementation significantly when sampling simple graphs.
The old implementation first shuffled the stubs vector, then checked for self-loops or multi-edges.
The new implementation checks for self-loops or multi-edges concurrently with shuffling.
The speedup depends on the degree sequence and the speed of the RNG. In the Mathematica interface, the default RNG is not very fast. In a small test I got a 3x speedup for undirected and 5x speedup for directed. This will vary considerably depending on the deg. seq. but it will always be faster than the old one.
Does not break the API so goes on master.
@ntamas Something to note is the SWAP_INT_ELEM macro, which is also used in tree_game. Here I added a second identical copy. It always undef'd after use.","This speeds up the configuration model implementation significantly when sampling simple graphs.
The old implementation first shuffled the stubs vector, then checked for self-loops or multi-edges.
The new implementation checks for self-loops or multi-edges concurrently with shuffling.
The speedup depends on the degree sequence and the speed of the RNG. In the Mathematica interface, the default RNG is not very fast. In a small test I got a 3x speedup for undirected and 5x speedup for directed. This will vary considerably depending on the deg. seq. but it will always be faster than the old one.
Does not break the API so goes on master.
@ntamas Something to note is the SWAP_INT_ELEM macro, which is also used in tree_game. Here I added a second identical copy. It always undef'd after use.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1416,2020-06-12T11:06:32Z,2020-06-12T13:11:49Z,2020-06-12T13:44:58Z,MERGED,True,72,58,1,https://github.com/szhorvat,degree_sequence_game: speedup for DEGSEQ_SIMPLE_NO_MULTIPLE_UNIFORM,1,[],https://github.com/igraph/igraph/pull/1416,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1416#issuecomment-643265207,"This speeds up the configuration model implementation significantly when sampling simple graphs.
The old implementation first shuffled the stubs vector, then checked for self-loops or multi-edges.
The new implementation checks for self-loops or multi-edges concurrently with shuffling.
The speedup depends on the degree sequence and the speed of the RNG. In the Mathematica interface, the default RNG is not very fast. In a small test I got a 3x speedup for undirected and 5x speedup for directed. This will vary considerably depending on the deg. seq. but it will always be faster than the old one.
Does not break the API so goes on master.
@ntamas Something to note is the SWAP_INT_ELEM macro, which is also used in tree_game. Here I added a second identical copy. It always undef'd after use.","So, my understanding now is that you shuffle until you encounter a loop or multi-edge, and then restart the shuffling completely. Why not simply skip that particular random swap and continue with another random swap? That should speed it up still more, right? Of course, this is only possible if not creating a self-loop or multi-edge is at all feasible. Or do you then get into some problems with uniform sampling?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1416,2020-06-12T11:06:32Z,2020-06-12T13:11:49Z,2020-06-12T13:44:58Z,MERGED,True,72,58,1,https://github.com/szhorvat,degree_sequence_game: speedup for DEGSEQ_SIMPLE_NO_MULTIPLE_UNIFORM,1,[],https://github.com/igraph/igraph/pull/1416,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1416#issuecomment-643269998,"This speeds up the configuration model implementation significantly when sampling simple graphs.
The old implementation first shuffled the stubs vector, then checked for self-loops or multi-edges.
The new implementation checks for self-loops or multi-edges concurrently with shuffling.
The speedup depends on the degree sequence and the speed of the RNG. In the Mathematica interface, the default RNG is not very fast. In a small test I got a 3x speedup for undirected and 5x speedup for directed. This will vary considerably depending on the deg. seq. but it will always be faster than the old one.
Does not break the API so goes on master.
@ntamas Something to note is the SWAP_INT_ELEM macro, which is also used in tree_game. Here I added a second identical copy. It always undef'd after use.","Why not simply skip that particular random swap and continue with another random swap?

That's a very common mistake that people make. It will not ensure uniform sampling.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1416,2020-06-12T11:06:32Z,2020-06-12T13:11:49Z,2020-06-12T13:44:58Z,MERGED,True,72,58,1,https://github.com/szhorvat,degree_sequence_game: speedup for DEGSEQ_SIMPLE_NO_MULTIPLE_UNIFORM,1,[],https://github.com/igraph/igraph/pull/1416,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1416#issuecomment-643271112,"This speeds up the configuration model implementation significantly when sampling simple graphs.
The old implementation first shuffled the stubs vector, then checked for self-loops or multi-edges.
The new implementation checks for self-loops or multi-edges concurrently with shuffling.
The speedup depends on the degree sequence and the speed of the RNG. In the Mathematica interface, the default RNG is not very fast. In a small test I got a 3x speedup for undirected and 5x speedup for directed. This will vary considerably depending on the deg. seq. but it will always be faster than the old one.
Does not break the API so goes on master.
@ntamas Something to note is the SWAP_INT_ELEM macro, which is also used in tree_game. Here I added a second identical copy. It always undef'd after use.","@vtraag The IGRAPH_DEGSEQ_SIMPLE does something like that. If it encounters a loop or a multi-edge, it tries another connection. If it still doesn't succeed, only then does it re-try from the start. However, 1) this breaks uniform sampling 2) actually computing the sampling probabilities is not easy for an ad-hoc modification like this.
I'm literally writing a paper on this right now :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1416,2020-06-12T11:06:32Z,2020-06-12T13:11:49Z,2020-06-12T13:44:58Z,MERGED,True,72,58,1,https://github.com/szhorvat,degree_sequence_game: speedup for DEGSEQ_SIMPLE_NO_MULTIPLE_UNIFORM,1,[],https://github.com/igraph/igraph/pull/1416,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1416#issuecomment-643278296,"This speeds up the configuration model implementation significantly when sampling simple graphs.
The old implementation first shuffled the stubs vector, then checked for self-loops or multi-edges.
The new implementation checks for self-loops or multi-edges concurrently with shuffling.
The speedup depends on the degree sequence and the speed of the RNG. In the Mathematica interface, the default RNG is not very fast. In a small test I got a 3x speedup for undirected and 5x speedup for directed. This will vary considerably depending on the deg. seq. but it will always be faster than the old one.
Does not break the API so goes on master.
@ntamas Something to note is the SWAP_INT_ELEM macro, which is also used in tree_game. Here I added a second identical copy. It always undef'd after use.","It will not ensure uniform sampling.

Yes, this was my worry indeed.

I'm literally writing a paper on this right now :-)

Great! Good luck with it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1418,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1418#issuecomment-648681260,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?",I haven't looked through this yet. Let us know when it's ready (it's still marked as draft).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1418#issuecomment-648681631,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","igraph_edge is used in a few more .c files, shall I go over them and fix it?

I don't think it's necessary; when you have an edge ID and you need both endpoints, I think it's totally OK to use igraph_edge. I think you can gain the most (in terms of readability) in cases when you have one endpoint of the edge and an edge ID, and you need the other endpoint - in that case IGRAPH_OTHER() is much more readable than the alternatives.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1418#issuecomment-648682800,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","@ntamas When I added the IGRAPH_TO/FROM/OTHER docs, I wrote that they don't check the input (i.e. is the edge ID valid?), but igraph_edge does.  That turns out not to be true. I assumed it does error checking because it returns an error code, but in fact it always returns IGRAPH_SUCCESS. Now that igraph_edge is abolished from the internal functions, what do you think about actually adding that check to it? I.e., if the supplied edge ID is not valid, return IGRAPH_EINVAL.
If we don't do that, I'll fix up the docs instead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1418#issuecomment-648686984,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","Since IGRAPH_TO, IGRAPH_FROM and IGRAPH_OTHER are also public, I think it's okay to make the distinction such that igraph_edge() checks for errors while the others don't. (Python also does this in its C API; e.g., PyLIST_SET_ITEM() does not check for errors while PyList_SetItem() does). So, please go ahead and update igraph_edge() to do the checks.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/iosonofabio,6,https://github.com/igraph/igraph/pull/1418#issuecomment-648694848,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","Related to this: since igraph_edge will check, I assume we can remove it from or internal functions when it's safe to do so
…
On Wed, Jun 24, 2020, at 18:48, Tamás Nepusz wrote:


 Since `IGRAPH_TO`, `IGRAPH_FROM` and `IGRAPH_OTHER` are also public, I
 think it's okay to make the distinction such that `igraph_edge()`
 checks for errors while the others don't. (Python also does this in its
 C API; e.g., `PyLIST_SET_ITEM()` does not check for errors while
 `PyList_SetItem()` does). So, please go ahead and update
 `igraph_edge()` to do the checks.

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#1418 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAGH7YNBR5IEYIJTBCLRYG4UTANCNFSM4OECK6OA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1418#issuecomment-649134899,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","I am surveying the codebase for IGRAPH_OTHER and it seems like the most common signature is:
igraph_integer_t neighbor = IGRAPH_OTHER(graph, (igraph_integer_t) edge, actnode);
but also found failry often that edge is used as long int without recasting to igraph_integer_t.
Any idea what's going on? I've starting enforcing the igraph_integer_t cast for consistency, but am wondering if that makes sense.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1418#issuecomment-649723048,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","Any idea what's going on? I've starting enforcing the igraph_integer_t cast for consistency, but am wondering if that makes sense.

Quite confusingly, igraph_integer_t used to be a double in older version of igraph. (I think it had to do something with R and the fact that certain 32-bit platforms that we used at the research institute years ago used 16 bits for ints, but I don't remember any more). This is not the case any more, but several explicit casts to igraph_integer_t (or to long int) are related to this and are not necessary any more. (It also caused utter confusion when you had to use %f or %g when printing an igraph_integer_t).
I think we should try to reduce the clutter in the codebase by not casting stuff unless we really have to, so I'd probably vote for removing the casts where possible.
In the case of IGRAPH_OTHER(), it is not necessary to cast because IGRAPH_OTHER() eventually boils down to IGRAPH_FROM() or IGRAPH_TO(), both of which cast their edge ID argument to a long int anyway because it is used as an array index. Back in the old days, when igraph_integer_t was a double, we needed an explicit cast to long int because you cannot use doubles as array indices. In this particular place, I think we need to keep the cast because IGRAPH_FROM(), IGRAPH_TO() and IGRAPH_OTHER() are part of the public API and removing the cast would disallow certain variable types that compile correctly with the current version. However, when you use IGRAPH_OTHER() internally in some function, I think it's not necessary to do any casting at all.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/iosonofabio,9,https://github.com/igraph/igraph/pull/1418#issuecomment-649957430,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?",I think this is ready to merge,True,{}
igraph/igraph,https://github.com/igraph/igraph,1418,2020-06-21T23:29:40Z,2020-06-26T08:36:16Z,2020-06-26T11:22:51Z,MERGED,True,156,175,8,https://github.com/iosonofabio,Modernizing older files,19,[],https://github.com/igraph/igraph/pull/1418,https://github.com/iosonofabio,10,https://github.com/igraph/igraph/pull/1418#issuecomment-650058034,"...learning from #1257
Changes:

igraph_edge converted into IGRAPH_OTHER
igraph_vector_size moved out of for loop declaration

I changed a number of files that used these two patterns. Tests pass and logic appears to be preserved.
Anything else that jumps to mind?","Awesome! Thank you!
…
On 6/26/20 6:21 PM, Tamás Nepusz wrote:
 ***@***.**** approved this pull request.

 I have removed the explicit |(igraph_integer_t)| casts inside
 |IGRAPH_OTHER()| in a commit, otherwise it's good to go.

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#1418 (review)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAD3CLCBCDUTHJOITADRYRLCJANCNFSM4OECK6OA>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1419,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1419#issuecomment-650516430,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","I tried all kinds of bisections on test 27, i.e. conversions between sparse and dense matrices, but can't for the best of me diagnose the problem. If anyone could have a look that'd be fantastic!
The file is examples/simple/igraph_sparsemat6.c.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1419#issuecomment-651348106,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",I'll try to reproduce this in Docker on an alpine image.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1419#issuecomment-651358241,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",I think f6797e8 fixes this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,5,https://github.com/igraph/igraph/pull/1419#issuecomment-653262704,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",Should be fine I think,True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1419#issuecomment-653439623,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",Tests seem to pass in CI -- is this ready to merge?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1419#issuecomment-653440605,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","The only thing is I'm not sure if the after_failure trigger works correctly from inside the chroot. The CI fails alright when at least one test fails, but it causes an exclamation mark instead of an X. Do you have any clue what this could be? Maybe an exit code in bash?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1419#issuecomment-653443601,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","Hmmm, good point. I think the Travis policy is to mark the build as ""errored"" if any of the commands in the build steps returns a non-zero exit code, except the script section, where a non-zero exit code would simply indicate a test failure.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1419#issuecomment-653446735,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",Do you have a link to a recently failed Travis build that errored out? I can't find one in the build history in my account.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,10,https://github.com/igraph/igraph/pull/1419#issuecomment-653858328,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","This would be one:
https://travis-ci.org/github/igraph/igraph/jobs/702599842
It says the test failed unexpectedly, but fails to show the log...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1419#issuecomment-653881103,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","Okay, this is totally a stab in the dark, but basically Travis marks the build as ""errored"" if there is an error in the before_install, install or before_script phases (i.e. any command that is invoked in these stages returns with a non-zero error code). Any non-zero error code in the script phase should mark the build as ""failed"". The reason why this build is marked as ""errored"" might be because you invoke the build command via alpine(), which is a function that you defined in the install phase. Try invoking make check without using the function defined in the install phase, or re-define it in the script phase.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,12,https://github.com/igraph/igraph/pull/1419#issuecomment-653953448,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","I redefined the function in the script phase, but it still errors with an exclamation mark instead of a cross, so it does not trigger the after_failure. I'll try asking Travis folks...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/iosonofabio,13,https://github.com/igraph/igraph/pull/1419#issuecomment-653958972,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little","Alright, it seems like set -e messes up the Travis error codes. They had a bug report in 2013 which they seem to have fixed, but there must be something still broken about that...
either way it's fixed now, ready for merge",True,{}
igraph/igraph,https://github.com/igraph/igraph,1419,2020-06-26T06:41:37Z,2020-07-06T09:12:39Z,2020-07-06T09:12:46Z,MERGED,True,24,2,2,https://github.com/iosonofabio,added Alpine Linux test run to Travis CI,21,[],https://github.com/igraph/igraph/pull/1419,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1419#issuecomment-654114737,"I added a chroot into Alpine linux as suggested in the open issue #1070
Currently one test only fails: conversion from sparse to dense matrix.
I'm trying to get the exact log out but the chrooting seems to interfere a little",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1420,2020-06-26T09:42:13Z,2020-06-26T15:35:06Z,2020-06-26T15:35:08Z,MERGED,True,16,53,1,https://github.com/ntamas,"Appveyor: rewriting config to run with and without MSVC, irrespectively of Python version",3,[],https://github.com/igraph/igraph/pull/1420,https://github.com/ntamas,1,https://github.com/igraph/igraph/pull/1420,"This PR rewrites the Appveyor CI config file to run only once on MSVC and one with MinGW/MSYS.
@iosonofabio Is that what you had in mind?
@vtraag Is this in line with what we've discussed in the Discourse group?","This PR rewrites the Appveyor CI config file to run only once on MSVC and one with MinGW/MSYS.
@iosonofabio Is that what you had in mind?
@vtraag Is this in line with what we've discussed in the Discourse group?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1420,2020-06-26T09:42:13Z,2020-06-26T15:35:06Z,2020-06-26T15:35:08Z,MERGED,True,16,53,1,https://github.com/ntamas,"Appveyor: rewriting config to run with and without MSVC, irrespectively of Python version",3,[],https://github.com/igraph/igraph/pull/1420,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1420#issuecomment-650124440,"This PR rewrites the Appveyor CI config file to run only once on MSVC and one with MinGW/MSYS.
@iosonofabio Is that what you had in mind?
@vtraag Is this in line with what we've discussed in the Discourse group?","Yes, I believe this covers it.
There is one thing that we can perhaps now solve, since we are changing things anyway. It states that we are using conda to install suitable libraries, but I don't think that is the case. We install libxml2 when but I don't think the libxml2 from conda is actually used when compiling from MSVC. We can simply get rid of all conda dependencies here I think.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1420,2020-06-26T09:42:13Z,2020-06-26T15:35:06Z,2020-06-26T15:35:08Z,MERGED,True,16,53,1,https://github.com/ntamas,"Appveyor: rewriting config to run with and without MSVC, irrespectively of Python version",3,[],https://github.com/igraph/igraph/pull/1420,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1420#issuecomment-650227837,"This PR rewrites the Appveyor CI config file to run only once on MSVC and one with MinGW/MSYS.
@iosonofabio Is that what you had in mind?
@vtraag Is this in line with what we've discussed in the Discourse group?",Great! As far as I'm concerned we are good to go.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1421,2020-06-26T12:02:54Z,2020-06-26T15:06:01Z,2020-06-26T15:06:02Z,CLOSED,False,10,10,3,https://github.com/vtraag,Removed some unnecessary casts.,1,[],https://github.com/igraph/igraph/pull/1421,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1421,"Continuing from #1418 (review), this PR simply removes some unnecessary casts.","Continuing from #1418 (review), this PR simply removes some unnecessary casts.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1421,2020-06-26T12:02:54Z,2020-06-26T15:06:01Z,2020-06-26T15:06:02Z,CLOSED,False,10,10,3,https://github.com/vtraag,Removed some unnecessary casts.,1,[],https://github.com/igraph/igraph/pull/1421,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1421#issuecomment-650193078,"Continuing from #1418 (review), this PR simply removes some unnecessary casts.","Should this go into master or develop? On one hand, this does not break anything so it could go into master. On the other hand, since this does not fix anything either, it should probably go to develop instead and we merge stuff directly into master only if it's a bugfix (and then we merge master into develop immediately afterwards). I'm just worried that the two branches go out of sync if we don't stick to a strict policy about which branch new PRs should primarily target.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1421,2020-06-26T12:02:54Z,2020-06-26T15:06:01Z,2020-06-26T15:06:02Z,CLOSED,False,10,10,3,https://github.com/vtraag,Removed some unnecessary casts.,1,[],https://github.com/igraph/igraph/pull/1421,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1421#issuecomment-650228749,"Continuing from #1418 (review), this PR simply removes some unnecessary casts.","Yes, sorry, PR #1418 was targeted at develop so it probably makes more sense to merge it there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1421,2020-06-26T12:02:54Z,2020-06-26T15:06:01Z,2020-06-26T15:06:02Z,CLOSED,False,10,10,3,https://github.com/vtraag,Removed some unnecessary casts.,1,[],https://github.com/igraph/igraph/pull/1421,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1421#issuecomment-650229417,"Continuing from #1418 (review), this PR simply removes some unnecessary casts.","Forget about this one, I will close it and start a new PR, properly rebased first against develop (some other time though). Sorry for messing up.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1422,2020-06-26T22:19:02Z,2020-07-01T10:27:26Z,2020-07-01T10:27:29Z,MERGED,True,9,0,1,https://github.com/vtraag,Added Leiden algorithm to functions.def,1,[],https://github.com/igraph/igraph/pull/1422,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1422,"In order to make the Leiden algorithm available in R the function still needed to be added to functions.def. This is done in this PR. I used a branch on the main repository, so that the PR in the rigraph repository can immediately use this commit, see igraph/rigraph#399 for the PR for the R interface.
That PR now currently points to this commit. I think that after we merge the commit reference will remain the same, or not? I'm not 100% sure. If it remains the same, we can simply merge this without any problems.","In order to make the Leiden algorithm available in R the function still needed to be added to functions.def. This is done in this PR. I used a branch on the main repository, so that the PR in the rigraph repository can immediately use this commit, see igraph/rigraph#399 for the PR for the R interface.
That PR now currently points to this commit. I think that after we merge the commit reference will remain the same, or not? I'm not 100% sure. If it remains the same, we can simply merge this without any problems.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1425,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1425#issuecomment-652496090,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.

IMO we should go by the public headers, which are always installed with the library, and not the documentation.
If it's in the public headers, it should be exported, regardless of whether it's documented or not. If it really not appropriate to export it, it should probably removed from the public headers and added to the private one instead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1425#issuecomment-652571709,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","@szhorvat made a good point here; if we put something in the public headers but don't export it, that bit of code is basically useless. So yes, I think that if there is something that is already in the public headers, we need to export it.
I'll go through this PR in detail soon, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1425#issuecomment-652572768,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","I think that DECLDIR can't replace extern entirely, so if something was originally declared as extern, we now need to declare it as DECLDIR extern instead of simply DECLDIR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1425#issuecomment-652582945,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","I think that if there is something that is already in the public headers, we need to export it.

OK, I will go through it again to see if there were any other missing symbols from public include files (i.e. from the include/ directory).

I think that DECLDIR can't replace extern entirely, so if something was originally declared as extern, we now need to declare it as DECLDIR extern instead of simply DECLDIR.

I believe the only effect of extern is to make sure it is properly exported when compiled as part of a C++ library, right? That is already properly dealt with by the __BEGIN_DECLS, __END_DECLS symbols. But correct me if I am wrong here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1425#issuecomment-652589099,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","I believe the only effect of extern is to make sure it is properly exported when compiled as part of a C++ library, right?

I think for constants it has an additional meaning: ""dear compiler, the value of this stuff is defined in another compilation unit"". Apparently this is why the Travis build errors out now; certain constants that were declared extern in the headers are not extern any more and the compiler tries to come up with a ""default constructor"" for them, which is not always possible.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1425#issuecomment-652602936,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","Ah yes, of course! Sorry, forgot about that...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1425,2020-07-01T15:37:31Z,2020-07-02T10:14:40Z,2020-07-02T10:14:40Z,MERGED,True,347,358,10,https://github.com/vtraag,Added missing DECLDIR specs to fix DLL exports on Windows,3,[],https://github.com/igraph/igraph/pull/1425,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1425#issuecomment-652867263,"As discussed during the CMake development, for building a shared library on Windows, some DECLDIR seemed to be missing. This PR corrects this in the master branch. Note that there are a few ""border"" cases of what could be considered ""public"" and what not. Some functions were commented to be ""internal"", yet were included in the public headers, and some were even explicitly included in the documentation. Some of them I marked with DECLDIR if I thought it would be appropriate. But feel free to comment on this.","I added back one extern, the other externs are actually unnecessary, it now compiles and checks correctly locally (i.e. for the master branch).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1426,2020-07-02T13:36:26Z,2020-07-03T13:12:15Z,2020-07-03T13:12:15Z,MERGED,True,10,10,1,https://github.com/vtraag,Added missing DECLDIR specs for array3 to fix DLL exports on Windows,1,[],https://github.com/igraph/igraph/pull/1426,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1426,"Sorry, I forgot about the array3 DECLDIR specs, because I first wanted to discuss this (see the igraph forum). Given @szhorvat's reply, we should probably leave it public, and hence, add DECLDIR.","Sorry, I forgot about the array3 DECLDIR specs, because I first wanted to discuss this (see the igraph forum). Given @szhorvat's reply, we should probably leave it public, and hence, add DECLDIR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1427,2020-07-02T13:37:09Z,2020-07-03T09:42:19Z,2020-07-03T09:42:20Z,MERGED,True,7,7,2,https://github.com/vtraag,Removed internal functions from public header for heap,1,[],https://github.com/igraph/igraph/pull/1427,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1427,"This PR moves the declaration of some internal functions (that are clearly marked for internal use) of the heap type to the source file. This is line with the earlier comment by @szhorvat:

If it's in the public headers, it should be exported, regardless of whether it's documented or not. If it really not appropriate to export it, it should probably removed from the public headers and added to the private one instead.

I think this is a good suggestion, and that we should generally follow this.","This PR moves the declaration of some internal functions (that are clearly marked for internal use) of the heap type to the source file. This is line with the earlier comment by @szhorvat:

If it's in the public headers, it should be exported, regardless of whether it's documented or not. If it really not appropriate to export it, it should probably removed from the public headers and added to the private one instead.

I think this is a good suggestion, and that we should generally follow this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1429,2020-07-07T08:43:55Z,2020-09-21T02:41:57Z,2020-09-21T02:41:57Z,CLOSED,False,120,31,4,https://github.com/iosonofabio,First stub with igraph_set_t,1,['stale'],https://github.com/igraph/igraph/pull/1429,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1429,"We recently discussed the possibility of exposing and documenting a bunch of internal types.
This PR is bringing that discussion forth, currently with a single example of igraph_set_t.
Seems like for each type one has to:

make a igraph_<type>.h file by copying from another type
make a igraph_<type>_pmt.h file by moving and adapting what's currently in igraph_types_internal.h
change the header include in the implementation file
add documentation if needed.

What do you guys think? Shall we make a list or abandon this PR until 1.0?","We recently discussed the possibility of exposing and documenting a bunch of internal types.
This PR is bringing that discussion forth, currently with a single example of igraph_set_t.
Seems like for each type one has to:

make a igraph_<type>.h file by copying from another type
make a igraph_<type>_pmt.h file by moving and adapting what's currently in igraph_types_internal.h
change the header include in the implementation file
add documentation if needed.

What do you guys think? Shall we make a list or abandon this PR until 1.0?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1429,2020-07-07T08:43:55Z,2020-09-21T02:41:57Z,2020-09-21T02:41:57Z,CLOSED,False,120,31,4,https://github.com/iosonofabio,First stub with igraph_set_t,1,['stale'],https://github.com/igraph/igraph/pull/1429,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1429#issuecomment-655501140,"We recently discussed the possibility of exposing and documenting a bunch of internal types.
This PR is bringing that discussion forth, currently with a single example of igraph_set_t.
Seems like for each type one has to:

make a igraph_<type>.h file by copying from another type
make a igraph_<type>_pmt.h file by moving and adapting what's currently in igraph_types_internal.h
change the header include in the implementation file
add documentation if needed.

What do you guys think? Shall we make a list or abandon this PR until 1.0?","This is something that we should do sooner or later, but personally I won't be able to work on this until I finish and merge the CMake build branch. (I can do code review of course). But if you would like to go ahead with this, feel free to do so and I'll be happy to do a review.
One other approach that we could consider instead of the ""poor man's templates"" (in case you ever wondered what ""pmt"" stands for :)) is to use a pure macro-based, header-only approach, similarly to how hash tables and linked lists are done in the uthash and utlist libraries. The general idea here is that the library provides a set of macros that make certain assumptions about the types they operate on -- e.g., for singly linked lists the struct must have a member named next that points to the next element of the list, but otherwise the struct can contain any additional data members. Not sure how this would work for sets (or whether it would work at all), and also I'm not sure whether we should use it in igraph (for sake of consistency), but it's a possibility.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1429,2020-07-07T08:43:55Z,2020-09-21T02:41:57Z,2020-09-21T02:41:57Z,CLOSED,False,120,31,4,https://github.com/iosonofabio,First stub with igraph_set_t,1,['stale'],https://github.com/igraph/igraph/pull/1429,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1429#issuecomment-655818711,"We recently discussed the possibility of exposing and documenting a bunch of internal types.
This PR is bringing that discussion forth, currently with a single example of igraph_set_t.
Seems like for each type one has to:

make a igraph_<type>.h file by copying from another type
make a igraph_<type>_pmt.h file by moving and adapting what's currently in igraph_types_internal.h
change the header include in the implementation file
add documentation if needed.

What do you guys think? Shall we make a list or abandon this PR until 1.0?","OMG that's what PMT stands for. https://github.com/troydhanson/uthash/blob/master/src/utlist.h looks somewhere between amazing and witchcraft, holy cow.
For now I just implemented this stub to collect opinions around the table. Since @szhorvat recently expressed the desire for linked lists, we might consider including utlist for that instead of implementing a new PMT ourselves?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1429,2020-07-07T08:43:55Z,2020-09-21T02:41:57Z,2020-09-21T02:41:57Z,CLOSED,False,120,31,4,https://github.com/iosonofabio,First stub with igraph_set_t,1,['stale'],https://github.com/igraph/igraph/pull/1429,https://github.com/apps/stale,4,https://github.com/igraph/igraph/pull/1429#issuecomment-687960662,"We recently discussed the possibility of exposing and documenting a bunch of internal types.
This PR is bringing that discussion forth, currently with a single example of igraph_set_t.
Seems like for each type one has to:

make a igraph_<type>.h file by copying from another type
make a igraph_<type>_pmt.h file by moving and adapting what's currently in igraph_types_internal.h
change the header include in the implementation file
add documentation if needed.

What do you guys think? Shall we make a list or abandon this PR until 1.0?",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1430,2020-07-07T09:12:01Z,2020-07-08T09:10:00Z,2020-07-08T09:10:01Z,MERGED,True,4,12,1,https://github.com/iosonofabio,Wrap val/dom in LAD algorithm in ALLOC_ARRAY,2,[],https://github.com/igraph/igraph/pull/1430,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1430,"Addressing #1407
I wrapped the two variables in ALLOC_ARRAY which seems to basically allocate the memory, check for failure, and put the variable on the stack.","Addressing #1407
I wrapped the two variables in ALLOC_ARRAY which seems to basically allocate the memory, check for failure, and put the variable on the stack.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1430,2020-07-07T09:12:01Z,2020-07-08T09:10:00Z,2020-07-08T09:10:01Z,MERGED,True,4,12,1,https://github.com/iosonofabio,Wrap val/dom in LAD algorithm in ALLOC_ARRAY,2,[],https://github.com/igraph/igraph/pull/1430,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1430#issuecomment-655363250,"Addressing #1407
I wrapped the two variables in ALLOC_ARRAY which seems to basically allocate the memory, check for failure, and put the variable on the stack.","You missed an exit point of the function. It's a good idea to look for returns that are not at the very end whenever touchnig any FINALLY counts. Fixed this, and will merge when the tests pass. Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1431,2020-07-08T04:40:11Z,2020-07-08T08:02:41Z,2020-07-08T08:14:01Z,MERGED,True,28,10,6,https://github.com/iosonofabio,Gcc warnings,1,[],https://github.com/igraph/igraph/pull/1431,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1431,"Addressing issue #297.
There are quite a few more warnings, but they are related to dependencies (f2c or lapack in particular). Probably not going to fix those.
Also, the fix for triangles_template.h is a little questionable - a sometimes unused variable is now defined under an #ifdef. Suggestions to improve that one are welcome.","Addressing issue #297.
There are quite a few more warnings, but they are related to dependencies (f2c or lapack in particular). Probably not going to fix those.
Also, the fix for triangles_template.h is a little questionable - a sometimes unused variable is now defined under an #ifdef. Suggestions to improve that one are welcome.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1431,2020-07-08T04:40:11Z,2020-07-08T08:02:41Z,2020-07-08T08:14:01Z,MERGED,True,28,10,6,https://github.com/iosonofabio,Gcc warnings,1,[],https://github.com/igraph/igraph/pull/1431,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1431#issuecomment-655358487,"Addressing issue #297.
There are quite a few more warnings, but they are related to dependencies (f2c or lapack in particular). Probably not going to fix those.
Also, the fix for triangles_template.h is a little questionable - a sometimes unused variable is now defined under an #ifdef. Suggestions to improve that one are welcome.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1431,2020-07-08T04:40:11Z,2020-07-08T08:02:41Z,2020-07-08T08:14:01Z,MERGED,True,28,10,6,https://github.com/iosonofabio,Gcc warnings,1,[],https://github.com/igraph/igraph/pull/1431,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1431#issuecomment-655364476,"Addressing issue #297.
There are quite a few more warnings, but they are related to dependencies (f2c or lapack in particular). Probably not going to fix those.
Also, the fix for triangles_template.h is a little questionable - a sometimes unused variable is now defined under an #ifdef. Suggestions to improve that one are welcome.","I have merged this but I realized that I've already committed something in src/triangles_template.h in the feature/cmake-build branch that was supposed to fix this; basically I have added this:
/* deg1 is not used in all instantiations of this template */
IGRAPH_UNUSED(deg1);

Can you please check whether this also fixes things with your version of gcc? (It worked for me). If it does, I believe this is cleaner than the #ifdef trickery.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1433,2020-07-09T01:15:07Z,2020-07-09T07:25:53Z,2020-07-09T07:25:53Z,MERGED,True,51,2,2,https://github.com/iosonofabio,Doc improvs,1,[],https://github.com/igraph/igraph/pull/1433,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1433,Addressing part of #1297,Addressing part of #1297,True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1434,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1434#issuecomment-655954061,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,"Not sure whether this is really meant as an example or as a test case. If we don't have a test case for igraph_full() yet, maybe it's worth moving (or copying) this to examples/tests/ and check whether the graph that was created is indeed a full graph? (Printing the edge list to a file and providing an .out file for the test case would be enough I think).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1434#issuecomment-657322309,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,"Alright, I copied the file into example/tests and added checks that the edges are really there with an output file. I think we can merge now?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1434#issuecomment-657373967,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,"Once again, tab-indentation and space-indentation are being mixed randomly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/iosonofabio,5,https://github.com/igraph/igraph/pull/1434#issuecomment-657374288,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,"Indeed, my editor fixes it for me. Please feel free to improve my humble, incorregible habits.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1434#issuecomment-657374807,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,"You can use print_graph from test_utilities.inc to output the graph.
Please always add VERYIFY_FINALLY_STACK(); at the end of tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1434,2020-07-09T02:18:33Z,2020-07-13T10:24:36Z,2020-07-13T10:24:37Z,MERGED,True,391,1,4,https://github.com/iosonofabio,Write example for igraph_full,5,[],https://github.com/igraph/igraph/pull/1434,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1434#issuecomment-657376042,Fixing #1200 with a few examples for undirected/directed full graphs with and without self loops.,"Yes, added the verify statement at the end of the test.
I don't see why print_graph is better. The way used here is simple, commonly used across the library, and works well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1436,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1436#issuecomment-656484644,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","Might it not be better to add an additional internal function like igraph_i_add_int_safe which does the overflow (and underflow) checks and raises an error? Otherwise the pattern needs to be repeated every time, inviting possible bugs. A macro instead of a function would also work of course.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1436#issuecomment-656485175,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","I'd be happy with that, a macro probably less problematic in terms of performance hit. Where do you think the macro could sit?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1436#issuecomment-656490923,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","Good question! I don't have any file in mind immediately, perhaps @ntamas has a suggestion. Perhaps we need a different header for this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1436#issuecomment-657587699,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","Testing tip:
Overflow in (edge or vertex) betweenness calculations should occur with a grid graph of size 35*35, but not at size 34*35.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/apps/stale,6,https://github.com/igraph/igraph/pull/1436#issuecomment-691173771,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1436#issuecomment-745543120,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","@iosonofabio In case you were still working on this: I tested out changing the long long to double and it does not seem to have any noticeable precision penalty while preventing overflow. It even makes the use of bigints unnecessary (though I don't want to remove bigint support as it was exactly that that allowed me to verify that doubles work well). Details are in the chat.
Thus this check won't be necessary.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/iosonofabio,8,https://github.com/igraph/igraph/pull/1436#issuecomment-745544213,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?","Sounds good, thanks for that.
…
On Wed, Dec 16, 2020, at 07:19, Szabolcs Horvát wrote:


 @iosonofabio <https://github.com/iosonofabio> In case you were still
 working on this: I tested out changing the `long long` to `double` and
 it does not seem to have any noticeable precision penalty while
 preventing overflow. It even makes the use of bigints unnecessary
 (though I don't want to remove bigint support as it was exactly that
 that allowed me to verify that `double`s work well). Details are in the
 chat.

 Thus this check won't be necessary.

 —
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#1436 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAHEHHIIK3NQBXFV3O3SU7AFZANCNFSM4OWGL2XQ>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1436,2020-07-10T03:46:07Z,2020-12-18T12:39:34Z,2020-12-18T12:39:34Z,CLOSED,False,29,6,3,https://github.com/iosonofabio,Check for int overflow in edge_betweenness,2,['todo'],https://github.com/igraph/igraph/pull/1436,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1436#issuecomment-748063435,"Addressing #51
Problems found:

 edge_betweenness
 betweenness is already using doubles... is that alright??
 community_edge_betweenness

There are no other instances of unsigned long long int or unsigned long int or long long int in the src folder, so I take it that these should be the only two obvious cases.
Is that fine that the betweenness is using doubles?",Closing in favour of #1576.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1437,2020-07-10T06:21:41Z,2020-07-12T11:06:57Z,2020-07-12T12:24:14Z,CLOSED,False,34,8,4,https://github.com/iosonofabio,Add search box to html C manual,2,[],https://github.com/igraph/igraph/pull/1437,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1437,"I added an additional filter with sed to the docs Makefile.am such that only in the html version, a customized google search box for the C manual is inserted before the table of contents.
That should partially address (for now) the lack of searchability of the docs.
I also renamed the shebang in the custom python filter to use python2.7. Notice that is past end of life, so we should do something about that within a year or so.
I also added Vincent, Szabolcs and myself to the list of authors. @gaborcsardi and @ntamas , you might want to update your affiliations. If so please push to this PR or just write in the comments and I'll update them.","I added an additional filter with sed to the docs Makefile.am such that only in the html version, a customized google search box for the C manual is inserted before the table of contents.
That should partially address (for now) the lack of searchability of the docs.
I also renamed the shebang in the custom python filter to use python2.7. Notice that is past end of life, so we should do something about that within a year or so.
I also added Vincent, Szabolcs and myself to the list of authors. @gaborcsardi and @ntamas , you might want to update your affiliations. If so please push to this PR or just write in the comments and I'll update them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1437,2020-07-10T06:21:41Z,2020-07-12T11:06:57Z,2020-07-12T12:24:14Z,CLOSED,False,34,8,4,https://github.com/iosonofabio,Add search box to html C manual,2,[],https://github.com/igraph/igraph/pull/1437,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1437#issuecomment-656552434,"I added an additional filter with sed to the docs Makefile.am such that only in the html version, a customized google search box for the C manual is inserted before the table of contents.
That should partially address (for now) the lack of searchability of the docs.
I also renamed the shebang in the custom python filter to use python2.7. Notice that is past end of life, so we should do something about that within a year or so.
I also added Vincent, Szabolcs and myself to the list of authors. @gaborcsardi and @ntamas , you might want to update your affiliations. If so please push to this PR or just write in the comments and I'll update them.","doxrox.py is being revamped in the feature/cmake-build branch so it is actually 3.x-compatible in that branch. The reason why I did not merge it back immediately is because I slightly changed the invocation and the workflow to speed up the CMake build a bit. But anyway, we don't need to about this as soon as we switch to CMake.
I'll review the rest of this PR today, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1437,2020-07-10T06:21:41Z,2020-07-12T11:06:57Z,2020-07-12T12:24:14Z,CLOSED,False,34,8,4,https://github.com/iosonofabio,Add search box to html C manual,2,[],https://github.com/igraph/igraph/pull/1437,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1437#issuecomment-657207045,"I added an additional filter with sed to the docs Makefile.am such that only in the html version, a customized google search box for the C manual is inserted before the table of contents.
That should partially address (for now) the lack of searchability of the docs.
I also renamed the shebang in the custom python filter to use python2.7. Notice that is past end of life, so we should do something about that within a year or so.
I also added Vincent, Szabolcs and myself to the list of authors. @gaborcsardi and @ntamas , you might want to update your affiliations. If so please push to this PR or just write in the comments and I'll update them.","Let's break this PR down into multiple parts:


the shebang was updated in doxrox.py to use Python 2.7; this is OK but I suggest you simply add this to the develop branch as a separate commit (no need to send a PR, you have write access).


the list of authors in the documentation was extended to reflect the recent CZI grant, this is also okay -- feel free to commit this to the develop branch


the search box was added to the generated HTML pages. I would rather make this part of the webpage (i.e. the igraph.org repo), not this repo. Right now the idea is that the scripts in this repo generate a ""plain"" DocBook HTML docset without any additional styling, and the igraph.org repo adds the styling and any additional things that are needed to make the documentation behave nicely within the context of the webpage.


I'll close this PR and add the search box to the webpage based on the snippet found in this PR, so no need to take care of that yourself. As for the remaining two points above, just add a commit to develop.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1437,2020-07-10T06:21:41Z,2020-07-12T11:06:57Z,2020-07-12T12:24:14Z,CLOSED,False,34,8,4,https://github.com/iosonofabio,Add search box to html C manual,2,[],https://github.com/igraph/igraph/pull/1437,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1437#issuecomment-657214985,"I added an additional filter with sed to the docs Makefile.am such that only in the html version, a customized google search box for the C manual is inserted before the table of contents.
That should partially address (for now) the lack of searchability of the docs.
I also renamed the shebang in the custom python filter to use python2.7. Notice that is past end of life, so we should do something about that within a year or so.
I also added Vincent, Szabolcs and myself to the list of authors. @gaborcsardi and @ntamas , you might want to update your affiliations. If so please push to this PR or just write in the comments and I'll update them.",Search bar is now added to the C documentation: igraph/igraph.org@c69ebe0,True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1438,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1438#issuecomment-657295087,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","edit: I had missed one of the finally statements for the new tmp_graph.
This one leaves me a little confused.
If I understand correctly, in the first iteration level is zero and aggregated_graph is actually the initial graph, so of course you don't want to destroy it. But the edge list is created first and destroyed first since the new tmp_graph is needed in the next iteration.
The naive suggestion would be of course to first allocate the tmp_graph and put it on the stack before the inclist. That makes sense logically since it's longer lived than the inclist. The problem with that is that for iterations except the first one you want to destroy the old aggregated_graph before destroying its own inclist. Now I'm wondering since you destroy the graph, chances are you can destroy its inclist at the same time?
Even if you cannot do that, the inclist is created in this iteration, so you know how to destroy it. So you could easily reorder the top part of the stack:
    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. Because this graph will survive until the next iteration,
     * swap it on the stack with the inclist of the old graph, which will be removed earlier */
    IGRAPH_FINALLY_CLEAN(1);
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(4);
        IGRAPH_FINALLY(igraph_destroy, tmp_graph);
        IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);
    }

Perhaps not the prettiest, but it would work.
More generally, of course a stack cannot cover all cases. Think about vectors of pointers, those are basically unchecked memory leak landmines waiting to explode - since we don't put each item in the vector on the stack. However I am not sure redesigning the whole finally stack is our top priority now. So I'd vote for having a look across the codebase for similar interleaved cases like this and fixing them to agree with the stack rather than vice versa. For now ;-)
We could even write one or two macros that inserts/remove things into the stack at specified positions couldn't we?
IGRAPH_FINALLY_AT_STACK_POSITION(igraph_destroy, tmp_graph, 1);

and
IGRAPH_FINALLY_CLEAN_AT_STACK_POSITION(2, 2);",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1438#issuecomment-657405366,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","The stack model has worked fine for 99% of the use-cases so far, and maintaining hardcoded position indices in the finally stack will become hard if we ever have to refactor any of these algorithms, so I'd vote for not changing anything in the low-level code and just try to find a workaround for it in the Leiden algorithm.
If we really want to extend the existing solution: how about allowing the user to create multiple ""finally stacks"" such that when a new stack is created, a function that destroys everything that was put in the newly created stack is automatically placed on top of the old stack (from which the new stack was ""forked"")? This way one can keep on pushing items to the top of the old stack or to the new stack, which would essentially ""insert"" or ""remove"" items at a specific place in the old stack (where the two stacks were forked)? I don't know how hard it would be to track multiple stacks in one's head while writing code, but it would solve the problem of ""removing something from the middle of the stack"" in a relatively structured way, without having to rely on hardcoded indices.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1438#issuecomment-657791929,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","@vtraag Here's an idea for a solution:

igraph_i_community_leiden_aggregate does not create the graph. Instead, it takes an empty graph as input and adds the edges to it. (igraph_create also just calls igraph_add_edges internally, so performance won't be affected.)
Conceptually, we will operate not on graphs, but on pointers to graphs. This is what is being passed to IGRAPH_FINALLY, therefore we need a destructor for a ""pointer to graph"".

Here is an example constructor and destructor that can be used with IGRAPH_FINALLY:
static int create_graph_ptr(igraph_t **graph) {
    *graph = igraph_Calloc(1, igraph_t);
    if (*graph == NULL) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, *graph);
    IGRAPH_CHECK(igraph_empty(*graph, 0, IGRAPH_UNDIRECTED));
    IGRAPH_FINALLY_CLEAN(1);
    return IGRAPH_SUCCESS;
}

static void destroy_graph_ptr(igraph_t **graph) {
    if (*graph) {
        igraph_destroy(*graph);
        igraph_Free(*graph);
    }
}
If we now do IGRAPH_FINALLY(destroy_graph_ptr, &graph_ptr), then what gets destroyed is whatever graph_ptr is pointing to at the time when destroy_graph_ptr is called (not not what graph_ptr was pointing to at the time when the IGRAPH_FINALLY was executed).
We will work with two pointers, aggregate_ptr and temp_ptr. The loop will look like this:

Loop:

create inclist_aggregate
create temp_ptr
call igraph_i_community_leiden_aggregate
swap(aggregate_ptr, temp_ptr)
if level > 0, destroy temp_ptr
destroy inclist_aggregate


if level > 0, destroy aggregate_ptr

If you like the idea, I can push this tomorrow.
It's quite late here, I hope I didn't make a mistake here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1438#issuecomment-657810566,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","I am not sure if I follow entirely @szhorvat (it's getting late here as well :), but I think the crucial insight is indeed that I could simply create the graph beforehand. That way, I don't need to push/pop it off the FINALLY stack, I can simply allocate an empty graph initially (and push it to FINALLY stack), and then reuse that same graph by emptying it every time. I actually also need to do that on a couple of other variables (vectors), but for those vectors the solution was more clear.
I will try to see if I can find some time to do this later this week.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1438#issuecomment-657813522,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","That's not what I meant, but looking more closely, it seems to be a simpler solution. aggregated_graph and tmp_graph seem to be never used at the same time. Right now, igraph_i_community_leiden_aggregate takes aggregated_graph and creates tmp_graph from it. Do you mean that instead of doing this, igraph_i_community_leiden_aggregate could simply update aggregated_graph in-place? That does indeed seem to be the cleanest solution (it will require copying the original graph before the algorithm starts, but IMO that's a reasonable cost to pay for a simpler implementation).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/iosonofabio,7,https://github.com/igraph/igraph/pull/1438#issuecomment-657816282,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","Of course, if you can allocate variables and memory beforehand and just play with what's inside simplifies things.
…
On Tue, Jul 14, 2020, at 07:56, Szabolcs Horvát wrote:


 That's not what I meant, but looking more closely, it seems to be a
 simpler solution. `aggregated_graph` and `tmp_graph` seem to be never
 used at the same time. Right now, `igraph_i_community_leiden_aggregate`
 takes `aggregated_graph` and creates `tmp_graph` from it. Do you mean
 that instead of doing this, `igraph_i_community_leiden_aggregate` could
 simply update `aggregated_graph` in-place? That does indeed seem to be
 the cleanest solution.

 —
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub
 <#1438 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEADMOKV6SUMCHGVGFGDR3N7KFANCNFSM4OX7BKNQ>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1438#issuecomment-657820126,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","Hmm, I see that the igraph_t object is not able to remove all edges in an efficient manner. This makes it difficult to reuse the same variable. I could of course add that function (igraph_clear). What do you think?
I will have to rethink your original proposal @szhorvat at some later time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/iosonofabio,9,https://github.com/igraph/igraph/pull/1438#issuecomment-657823919,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","I'd be in favor of adding an `igraph_clear_graph` kind of thing that removes all edges and sets the number of boxes to zero.
…
On Tue, Jul 14, 2020, at 08:15, Vincent Traag wrote:


 Hmm, I see that the `igraph_t` object is not able to remove all edges
 in an efficient manner. This makes it difficult to reuse the same
 variable. I could of course add that function. What do you think?

 I will have to rethink your original proposal @szhorvat
 <https://github.com/szhorvat> at some later time.

 —
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub
 <#1438 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAF53J243SWDPPADB7TR3OBORANCNFSM4OX7BKNQ>.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1438#issuecomment-657983555,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","@vtraag Don't complicate it, just destroy and re-create the graph in-place.
Right now, we have:
int igraph_i_community_leiden_aggregate(const igraph_t *graph, igraph_t *aggregated_graph) {
    igraph_vector_t aggregated_edges;

    /* compute aggregated_edges */

    igraph_create(aggregated_graph, &aggregated_edges, nb_refined_clusters, IGRAPH_UNDIRECTED)
}

Change this to:
int igraph_i_community_leiden_aggregate(igraph_t *graph) {
    igraph_vector_t aggregated_edges;

    /* compute aggregated_edges from 'graph' */
    
    igraph_destroy(graph);
    igraph_create(graph, &aggregated_edges, nb_refined_clusters, IGRAPH_UNDIRECTED)
}

We don't need to try to gain additional efficiency, just re-shuffle the order of creation and destruction to make it compatible with how the finally stack works.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1438#issuecomment-658062317,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","@vtraag If we go with updating the graph in-place, the most straightforward implementation would need to start by copying the entire graph. Since this whole thing grew out of a user running into an out-of-memory condition, that makes me worried.
The current implementation will create a new graph after the first aggregation step anyway. Then the question is: how big is the size difference between the original graph, and the graph after the first aggregation step? (Sorry, I am not deeply familiar with the method.)
My current understanding is that after aggregation, the graph is likely to become several times smaller. Is this correct, and do you have an estimate of the size reduction? If it were to become 5 times smaller, than a 10 GB graph would currently require 10 + 10/5 = 12 GB of memory (not counting other things). If we copy the graph immediately, that means 10 + 10 = 20 GB of memory. That doesn't look good ...
Another thing to consider: is the algorithm fast enough to deal with huge graphs? In the original issue, the user was talking about billions of edges. Is there a chance that computation time will be the limiting factor anyway, and not memory?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1438#issuecomment-658072733,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","Don't complicate it, just destroy and re-create the graph in-place.

Yes, you are right, I can simply destroy and re-create the graph.

after aggregation, the graph is likely to become several times smaller.

The graph is indeed likely to become a couple of times smaller, especially in terms of edges, since those are most likely to be in between the nodes that are aggregated. I don't have exact statistics on that, but probably 4-5 times sounds reasonable.

If we copy the graph immediately, that means 10 + 10 = 20 GB of memory. That doesn't look good ...

No, exactly, this is why I don't copy the graph to begin with. Although, to be fair, a igraph_inclist_t is being allocated which also takes considerable amount of memory. This touches upon the question of whether we may actually improve the current graph object (which we started to discuss on the forum), instead of having this need to create fast iterators each time anyway.

Another thing to consider: is the algorithm fast enough to deal with huge graphs? In the original issue, the user was talking about billions of edges. Is there a chance that computation time will be the limiting factor anyway, and not memory?

We have run the algorithm on networks with up to about 1 billion edges (although fewer nodes), which takes up to an hour or so. I doubt that computation time will be the problem.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,13,https://github.com/igraph/igraph/pull/1438#issuecomment-663489670,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","Thanks for the suggestion again @szhorvat, I believe the latest commit should solve all issues. In fact, the code only got better because of the stack constraint on the FINALLY handler, so the constraint may actually be a good one! 😄
@munhyunsu perhaps you could try to run this PR against your network to see if all problems are then resolved? That is, you might still run out of memory of course, but there should then be some error provided (if it is not killed by an OOM killer first). To be clear, I didn't test anything yet against the network you provided.
I'm going on holidays as of tomorrow. I will be back in three weeks. I will see if things have been merged or if there are still some other remaining things that should be done. ⛱️",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1438#issuecomment-663509931,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","I will see if things have been merged

So it's okay to merge before you come back if everything looks good and we get positive feedback from @munhyunsu?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1438#issuecomment-663510054,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?",Enjoy the holidays! ☀️,True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,16,https://github.com/igraph/igraph/pull/1438#issuecomment-663510539,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","So it's okay to merge before you come back if everything looks good and we get positive feedback from @munhyunsu?

Yes, if think there are no more problems left, please feel free to merge at your discretion!

Enjoy the holidays! ☀️

Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1438#issuecomment-678496973,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","So this didn't fix #1435 (the problem was integer overflow), but we still merge this, right? After discovering that the problem was overflow, I didn't want to touch this until you were back @vtraag",True,{}
igraph/igraph,https://github.com/igraph/igraph,1438,2020-07-12T20:52:07Z,2020-08-22T08:42:58Z,2020-08-22T08:42:58Z,MERGED,True,72,100,1,https://github.com/vtraag,Memory and error handling in Leiden algorithm,3,[],https://github.com/igraph/igraph/pull/1438,https://github.com/vtraag,18,https://github.com/igraph/igraph/pull/1438#issuecomment-678505090,"This PR addresses some issues around memory allocation and error handling that might be causing some problems that were identified in #1435.
The first commit already releases some chunk of memory before allocating an additional chunk of memory, thereby decreasing the overall memory footprint.
The second commit changes the order of an IGRAPH_FINALLY(igraph_Free, ...) and the initialization of a vector. In the current code, it might be that the memory to create the vector itself was not allocated, in which case the vector might have been incorrectly attempted to be initalised. This is now corrected.
However, I believe there is an issue with the way that FINALLY error handling currently works. As it stands, it is implemented as a stack, meaning that the last one to be pushed on should be the first one to be popped off. However, this is not the case in the Leiden algorithm I notice (and it might also not be the case elsewhere). In particular, the Leiden algorithm uses something as follows:
do {

    /* Get incidence list for fast iteration */
    IGRAPH_CHECK(igraph_inclist_init(aggregated_graph, &edges_per_node, IGRAPH_ALL));
    IGRAPH_FINALLY(igraph_inclist_destroy, &edges_per_node);

    ...

    /* Allocate temporary graph */
    tmp_graph = igraph_Calloc(1, igraph_t);
    if (tmp_graph == 0) {
        IGRAPH_ERROR(""Leiden algorithm failed, could not allocate memory for aggregate graph"", IGRAPH_ENOMEM);
    }
    IGRAPH_FINALLY(igraph_free, tmp_graph);

    IGRAPH_CHECK(igraph_i_community_leiden_aggregate(
                        aggregated_graph, &edges_per_node, aggregated_edge_weights, aggregated_node_weights,
                        aggregated_membership, &refined_membership, nb_refined_clusters,
                        tmp_graph, &tmp_edge_weights, &tmp_node_weights, &tmp_membership));

    /* Graph has been created by aggregation, ensure it is properly destroyed if
     * an error occurs. */
    IGRAPH_FINALLY(igraph_destroy, tmp_graph);

    if (level >= 1) {
        /* Destroy previously allocated graph (note that aggregated_graph points to
         * the previously allocated tmp_graph). */
        igraph_destroy(aggregated_graph);
        igraph_Free(aggregated_graph);
        IGRAPH_FINALLY_CLEAN(2);
    }

    /* Set the aggregated graph correctly */
    aggregated_graph = tmp_graph;    

    ...

    /* We are done iterating, so we destroy the incidence list */
    igraph_inclist_destroy(&edges_per_node);
    IGRAPH_FINALLY_CLEAN(1);
} while (continue_clustering);
(Here, the ... indicate some code that is nonessential for this discussion).
The problem now is the following. What gets pushed on the stack is (in this order):

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_destroy(tmp_graph)

The last line that cleans one FINALLY, meaning the last one is popped off the stack, meaning the stack will read

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)

When the do .. while loop continues in its next iteration, it will become

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph2)
igraph_destroy(tmp_graph2)

(here tmp_graph2 refers to a newly allocated igraph_t object), and the last two will be popped off (when destroying tmp_graph), so that the FINALLY stack becomes

igraph_inclist_destroy(&edges_per_node)
igraph_free(tmp_graph)
igraph_inclist_destroy(&edges_per_node)

after which the last one is correctly popped off.
This explains the error with the inclist being destroyed when an out-of-memory error occurs (which I noted here). While executing everything from the FINALLY stack, the igraph_inclist_destroy(&edges_per_node) is on the stack one time too many (and some graph objects are actually not properly destroyed).
I have been thinking of finding a way to rewrite this part without causing a problem, but I'm afraid I don't see an easy solution. Do you have any idea whether this problem might occur more often? Does anybody have any suggestion for how to solve this problem?","Yes, we can still merge this. The issue will need to be re-opened after merging then.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1440,2020-07-13T01:22:51Z,2020-07-13T10:35:52Z,2020-07-13T10:35:52Z,MERGED,True,28,1,2,https://github.com/iosonofabio,Document and add to docs: Even-Tarjan reduction,2,[],https://github.com/igraph/igraph/pull/1440,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1440,Adding rest of doc for Even-Tarjan reduction in issue #1297 .,Adding rest of doc for Even-Tarjan reduction in issue #1297 .,True,{}
igraph/igraph,https://github.com/igraph/igraph,1441,2020-07-17T18:23:42Z,2020-07-19T17:45:22Z,2020-07-20T12:29:00Z,MERGED,True,82,14,5,https://github.com/szhorvat,Fixes igraph_is_graphical_degree_sequence for the undirected case,3,[],https://github.com/igraph/igraph/pull/1441,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1441,"The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph","The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph",True,{}
igraph/igraph,https://github.com/igraph/igraph,1441,2020-07-17T18:23:42Z,2020-07-19T17:45:22Z,2020-07-20T12:29:00Z,MERGED,True,82,14,5,https://github.com/szhorvat,Fixes igraph_is_graphical_degree_sequence for the undirected case,3,[],https://github.com/igraph/igraph/pull/1441,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1441#issuecomment-660269610,"The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph","The problems were:

must sort deg. seq. decreasingly
the code did not use the sorted version at all
must check that sum of degrees is even",True,{}
igraph/igraph,https://github.com/igraph/igraph,1441,2020-07-17T18:23:42Z,2020-07-19T17:45:22Z,2020-07-20T12:29:00Z,MERGED,True,82,14,5,https://github.com/szhorvat,Fixes igraph_is_graphical_degree_sequence for the undirected case,3,[],https://github.com/igraph/igraph/pull/1441,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1441#issuecomment-660673509,"The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph","@ntamas Sorry about being a bit pushy, but the rest of PRs to come are conditional on this. I'm happy to address even minor-sounding concerns. My priority is to correct the problem and move on.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1441,2020-07-17T18:23:42Z,2020-07-19T17:45:22Z,2020-07-20T12:29:00Z,MERGED,True,82,14,5,https://github.com/szhorvat,Fixes igraph_is_graphical_degree_sequence for the undirected case,3,[],https://github.com/igraph/igraph/pull/1441,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1441#issuecomment-660682114,"The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph","Sorry about the delay, we went on a short holiday break with the family and this fell through the cracks somehow. I'm merging it soon.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1441,2020-07-17T18:23:42Z,2020-07-19T17:45:22Z,2020-07-20T12:29:00Z,MERGED,True,82,14,5,https://github.com/szhorvat,Fixes igraph_is_graphical_degree_sequence for the undirected case,3,[],https://github.com/igraph/igraph/pull/1441,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1441#issuecomment-660936080,"The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph",I messed up and duplicated one of the checks. Will send an extra PR soon.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1441,2020-07-17T18:23:42Z,2020-07-19T17:45:22Z,2020-07-20T12:29:00Z,MERGED,True,82,14,5,https://github.com/szhorvat,Fixes igraph_is_graphical_degree_sequence for the undirected case,3,[],https://github.com/igraph/igraph/pull/1441,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1441#issuecomment-660997081,"The new undirected graphicality test based on Kiraly's paper was bugged, as I mentioned in #1432 This PR fixes the problem.
Changes:

fix igraph_is_graphical_degree_sequence for undirected case
explicitly check degree sequence for negative entries, and return ""false"" is any are found
add igraph_vector_reverse_sort (used in igraph_is_graphical_degree_sequence)
document igraph_vector_reverse_sort (we may remove the docs if we don't want to explicitly support a newly added function in a 0.8.x release)
remove claim that igraph_vector_sort was using qsort from the standard C library, as it is using qsort.c shipped with igraph",Fixed here 8373efc,True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1445,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1445#issuecomment-660937187,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","The intent is to deprecate igraph_is_degree_sequence and igraph_is_graphical_degree_sequence in favour of igraph_is_graphical.  I opted to leave the implementations of igraph_is_degree_sequence and igraph_is_graphical_degree_sequence as they are (even though a bit of code is duplicated) because there are some tiny differences: if the in- and out-degree sequence were not of the same length, previously false was returned. Now it throws an error for this case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1445#issuecomment-660938400,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","I should note that I plan to extend igraph_realize_degree_sequence in the same way, but that will be a followup PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1445#issuecomment-661799348,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.",@ntamas No objections so far with the bit-switches (even though one of the constants I introduced set 2 bits at once)? :-),True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1445#issuecomment-661805846,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","Seems to be okay so far! I haven't checked the actual implementation steps yet, only the API. I'll go through the implementation once I'm back from holidays (Thursday-ish).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1445#issuecomment-661808494,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","I haven't checked the actual implementation steps yet,

Don't do that yet, I am still making changes. I only wanted feedback on the API. Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1445#issuecomment-662085173,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","I gave up hope on keeping commits organized. We are going to do squash-and-merge. Since the last two commits are all mixed up and only make sense together, please only look at the final result when reviewing.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1445#issuecomment-662690154,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","Will do, thanks! (That's my default mode of operation anyway).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1445#issuecomment-663690637,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","A summary of what's in this PR:

Deprecate is_graphical_degree_sequence and is_degree_sequence in favour of is_graphical.
is_graphical now works for directed/undirected graphs, loops/no-loops, multi-edges/simple-edges. That's 2*2*2 = 8 cases.
The old is_degree_sequence corresponded to loops/multi-edges.
Undirected simple graph case gets a new implementation (Cloteaux), which is both practically faster and O(n) (not O(n log n) as before).
Undirected loopy graph case uses a modified version of the previous simple graph case implementation (Király). It could be sped up with a similar approach to the simple graph case, but I simply don't have the time to do this now.
Realizing degree sequences is now possible also for loopless and loopy undirected multigraphs, with a nice analogue of the three Havel-Hakimi variants we used for the simple graph case. It even works out that IGRAPH_REALIZE_DEGSEQ_SMALLEST guarantees that we get a connected graph. Why this works is not entirely trivial, if you want the proof just email me.
I did not implement graph realization for the loopy simple graph case yet. There is a simple way to do it (make a loop on every vertex with degree >=2 before we start), but it's not a nice analogue of the methods used for the other cases. I want something nicer, but don't have the time to fuss with the math right now.  Same goes for directed cases. The directed case is easier and I'll probably do it later this summer, but not in this PR. If everything were implemented, we'd have 2*2*2*3 = 24 cases (!) with the three kinds of methods ...
Some bugs were fixed in realizing degree sequences: sometimes negative degrees were not detected.
There's some ugliness in how some tests are done. I used macros instead of functions. Functions would be better, but macros work, and I don't have the energy to make this prettier ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1445#issuecomment-663695421,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","@ntamas A careful review would be appreciated, but please don't merge it, just let me know if you find any issues, or if anything is unclear in the docs. This was a lot more work than I expected ...
I'll have another read-through in a couple of days and I'll merge it myself (after you approved it).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1445#issuecomment-663858425,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","@ntamas I added some more tests today which revealed some (old) issues. I will commit the fix to those directly to master as well.  It's good now, ready for review. AppVeyor fails again, but that's not because of this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1445#issuecomment-663966907,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.",AppVeyor failures are caused by this issue. I'd rather wait a few more days and see if they fix it on AppVeyor's side rather than introducing a fix on our side (i.e. importing the missing PGP key manually) because it is likely to affect all projects using MSYS2 so chances are that something will be done in AppVeyor anyway.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1445#issuecomment-663966941,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","Also, I'll start reviewing it tomorrow, thanks for your work on this!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1445#issuecomment-665462721,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","What I like to do when reviewing new functionality is to integrate it into the Mathematica interface.
It would be really nice if this (especially realize_degree_sequence) could be integrated into the Python interface. Then I could also reference it in my paper, where I show that the ""smallest"" method always creates a connected graph.
BTW there's no hurry at all in reviewing this. It is not blocking any of my current projects.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1445#issuecomment-666452911,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.",Seems okay to me in general - only a few minor changes requested.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1445#issuecomment-666601592,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.","@ntamas One more thing: When I fixed the Erdos-Gallai test on master, I added the igraph_vector_reverse_sort function, and also added it to the documentation. If there is no objection, I am going to remove it from the docs on master and keep it on develop only. There's some way til 0.9 and 0.8.3 is not the right time to officially introduce new functions. I'll keep the function (since it's actually needed for the fix), but I won't include it in the docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1445,2020-07-20T10:08:52Z,2020-08-01T14:11:40Z,2020-08-01T14:11:40Z,MERGED,True,2911,883,23,https://github.com/szhorvat,igraph_is_graphical and igraph_is_bigraphical,35,[],https://github.com/igraph/igraph/pull/1445,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1445#issuecomment-666620719,"Closes #1432 .
This draft is open for general comments on the API/design/documentation. Feedback is welcome.
I still need to verify the implementation, add tests, and possibly complete igraph_i_is_graphical_undirected_loopy_simple if all goes well.
I chose the SW suffix constants that represent bitwise switches and can be combined with |.",I addressed everything you pointed out. I'll merge this myself in a couple of days. Thanks for the review!,True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1447,2020-07-22T16:19:17Z,2020-10-05T18:36:09Z,2020-10-05T19:36:04Z,CLOSED,False,9,3,3,https://github.com/ObiWahn,Fix appveyor test execution.,4,['stale'],https://github.com/igraph/igraph/pull/1447,https://github.com/ObiWahn,1,https://github.com/igraph/igraph/pull/1447,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1447,2020-07-22T16:19:17Z,2020-10-05T18:36:09Z,2020-10-05T19:36:04Z,CLOSED,False,9,3,3,https://github.com/ObiWahn,Fix appveyor test execution.,4,['stale'],https://github.com/igraph/igraph/pull/1447,https://github.com/ObiWahn,2,https://github.com/igraph/igraph/pull/1447#issuecomment-662649291,,Just one test failing:),True,{}
igraph/igraph,https://github.com/igraph/igraph,1447,2020-07-22T16:19:17Z,2020-10-05T18:36:09Z,2020-10-05T19:36:04Z,CLOSED,False,9,3,3,https://github.com/ObiWahn,Fix appveyor test execution.,4,['stale'],https://github.com/igraph/igraph/pull/1447,https://github.com/apps/stale,3,https://github.com/igraph/igraph/pull/1447#issuecomment-696081070,,This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1447,2020-07-22T16:19:17Z,2020-10-05T18:36:09Z,2020-10-05T19:36:04Z,CLOSED,False,9,3,3,https://github.com/ObiWahn,Fix appveyor test execution.,4,['stale'],https://github.com/igraph/igraph/pull/1447,https://github.com/ObiWahn,4,https://github.com/igraph/igraph/pull/1447#issuecomment-703832975,,Is there hope to get this merged?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1447,2020-07-22T16:19:17Z,2020-10-05T18:36:09Z,2020-10-05T19:36:04Z,CLOSED,False,9,3,3,https://github.com/ObiWahn,Fix appveyor test execution.,4,['stale'],https://github.com/igraph/igraph/pull/1447,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1447#issuecomment-703844544,,Can you please provide a description about what issues this PR is supposed to fix? Note that the feature/cmake-build branch has diverged from yours a while ago so it is possible that some of the issues are already fixed.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1451,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1451#issuecomment-665483482,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","Sorry to keep hammering on this but there are still tab characters ;-)
A question: Is there a point to using a lazy adjlist instead of an adjlist? Won't it usually traverse the whole graph anyway, meaning that a lazy adjlist is more likely to be a performance hit than a performance gain?  I don't know. It won't traverse the whole graph if the graph is not connected. Perhaps that is not such an uncommon situation with real-world directed graphs.
Anyway, it's just a thought. I wouldn't necessarily spend time changing this—it might turn out to make next to no difference. However, if you are going for the ultimate performance (part of the reason for this function is to have better performance than igraph_dfs, right?) then you might want to investigate this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1451#issuecomment-665484709,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","Thanks, I finally fixed my editor to avoid tabs, sorry about that. Laziness is a difficult beast.
Honestly I'm happy with either igraph_dfs, having a new igraph_i_dfs, or even using Python. The main push from me is having some kind of Graph.dfs in Python since it's such an essential function, for the rest I'm just molding on existing infra.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1451#issuecomment-666556853,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","I think it's useful to have igraph_i_dfs() separately in the C core, but maybe we shouldn't mark these functions as ""internal"". The reason why igraph_i_bfs() exists is that for certain use-cases (running a ""quick"" BFS) all the arguments in igraph_bfs() are overkill -- to such an extent that the Python interface basically wraps igraph_i_bfs() with the Graph.bfs() method and no one complained about the missing features so far. So maybe calling these igraph_bfs_simple() and igraph_dfs_simple() would be more appropriate.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1451#issuecomment-666558140,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","As for whether igraph_i_bfs() is faster than igraph_bfs() (and whether it would be true for igraph_i_dfs()), I don't know. This would need to be benchmarked, and we need to understand why igraph_i_bfs() is faster if it is indeed faster. Is it faster because it does not have to do as much bookkeeping as igraph_bfs() has to (because of the extra arguments), or is it faster because there are some optimizations in igraph_i_bfs() that were not ported to igraph_bfs()?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1451#issuecomment-666558353,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","Otherwise, @iosonofabio I am totally fine with the proposed simple interface for igraph_i_dfs().",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/apps/stale,7,https://github.com/igraph/igraph/pull/1451#issuecomment-700325456,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1451#issuecomment-815929112,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","Just a heads up; this PR was originally motivated by the fact that we've had an igraph_i_bfs() function that made things a whole lot simpler in the Python interface. igraph_i_bfs() was renamed to igraph_bfs_simple() in the meanwhile to ensure that we don't expose internal functions in the public API. In a similar vein, we could have igraph_dfs_simple() instead of igraph_i_dfs().
@iosonofabio We are about to turn things upside down soon(ish) by transitioning to 64-bit integer types and there will probably be lots of merge conflicts with pending PRs. What's the status of this PR, shall we try and finish this and get this merged before the integer transition or shall we put this aside and deal with it again after the integer transition? (The same question also applies to #1257)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/iosonofabio,9,https://github.com/igraph/igraph/pull/1451#issuecomment-816169440,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","Thanks. The main reason for me was Python, that was solved separately.
I also don't know if the simple function is faster than the full one, for either BFS or DFS. So renaming the other one was good but the key issues are out there.
I could just quickly finish this one for symmetry, then we have bsf and dfs with both simple siblings, or i could just let it fall and come back to it after the 64 bit transition with a fresh PR",True,{}
igraph/igraph,https://github.com/igraph/igraph,1451,2020-07-29T03:53:01Z,2021-04-19T05:42:06Z,2021-04-19T05:42:25Z,CLOSED,False,104,3,2,https://github.com/iosonofabio,igraph_i_dfs,1,['todo'],https://github.com/igraph/igraph/pull/1451,https://github.com/iosonofabio,10,https://github.com/igraph/igraph/pull/1451#issuecomment-822183802,"I'm trying to implement depth first search in the Python interface copying from breath first.
Python-level BFS uses the C core igraph_i_bfs function, which is a quicker and less flexible version of igraph_bfs.
We don't have an equivalent igraph_i_dfs function.
This PR aims initially at providing the latter function for internal use and for use in the Python interface. Depending on the feedback received, that scope might expand into a slightly deeper redesign of both visitor functions.
Either way, efficient traversal functions are essential to both igraph and its high-level interfaces, so this is quite useful I think.","We can come back to this after the int64 transition, since it's not urgent.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1453,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1453#issuecomment-667582699,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","@ntamas Is it okay to use the Visual Studio 2019 image for AppVeyor? It is claimed that it has a new (working) msys2. I'm not so familiar with AppVeyor. We should somehow get it working again before merging this.
@jannick0 According to the Travis tests, it works on macOS and Linux.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1453#issuecomment-667584287,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.",Totally fine; I'll try to switch the Appveyor image and then rebuild the CI tests for this PR. It looks like there's quite a bit of arcane autotools magic in there - thanks for the great job @jannick0!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1453#issuecomment-667586250,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","@szhorvat so it looks like we are using the Visual Studio 2019 image already. I fixed things in master by importing the missing PGP key manually; it seems to work now.
I'll take a chance and merge this into master as is and see whether the CI checks pass there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/jannick0,5,https://github.com/igraph/igraph/pull/1453#issuecomment-667629808,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","Great - I am glad that everything runs smoothly now. Thanks, guys! Happy to close #1401.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1453#issuecomment-667658195,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","I think we are having some problems with this on some more exotic platforms:
https://travis-ci.com/github/szhorvat/igraph/builds/178149534",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/jannick0,7,https://github.com/igraph/igraph/pull/1453#issuecomment-667659692,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","Uuuh, let me have a look.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1453#issuecomment-667669345,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.",@jannick0 The problem is that fgetc returns an int and EOF is generally an int not a char. We must change the type of c and c_prev into int in order to make it work.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1453#issuecomment-667669751,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","I pushed a fix, let's see if the tests pass.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/jannick0,10,https://github.com/igraph/igraph/pull/1453#issuecomment-667669939,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","OK - great. Thanks.  To be on the very safe side the while loop could be forced to be finite (e.g., using a counter).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1453#issuecomment-667671336,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","it passes now: https://travis-ci.com/github/szhorvat/igraph/builds/178154491

To be on the very safe side the while loop could be forced to be finite (e.g., using a counter).

I think it's fine with the while (1). An EOF must come up eventually. The problem was that the value returned by fgetc was implicitly cast to a char. The program worked on platforms where char(EOF) == EOF, but it failed on those where this is not the case. Why exactly this comparison happened to be true on x86, I don't understand ... but with the correct type for c and c_prev everything should be fine on all platforms.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1453,2020-08-01T14:56:31Z,2020-08-01T20:58:09Z,2020-08-02T13:03:03Z,MERGED,True,107,30,4,https://github.com/jannick0,autoconf: EOL issue on Windows (testsuite),5,[],https://github.com/igraph/igraph/pull/1453,https://github.com/jannick0,12,https://github.com/igraph/igraph/pull/1453#issuecomment-667671537,"With this commit series all tests pass on my Windows 10 machine (using MSYS2 MINGW64).
Please run testse on other platforms, too, on OSX in particular (where \r is special). Thanks.","Yes, fully agree. Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1454,2020-08-02T05:30:22Z,2020-08-02T09:48:06Z,2020-08-02T11:02:50Z,MERGED,True,5,13,2,https://github.com/jannick0,build process: appveyor.yml and bootstrap.sh,2,[],https://github.com/igraph/igraph/pull/1454,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1454,Tiny issues I was putting on my list during the EOL Windows exercise.,Tiny issues I was putting on my list during the EOL Windows exercise.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1461,2020-09-08T11:26:13Z,2020-09-08T13:19:38Z,2020-09-08T13:19:39Z,MERGED,True,4,3,2,https://github.com/vtraag,Changed Leiden algorithm test code to avoid rounding errors.,1,[],https://github.com/igraph/igraph/pull/1461,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1461,"In issue #1337, it appeared that on Windows the test code for the Leiden algorithm failed due to a rounding problem. It seems that rounding is working differently on Windows than on other platforms (see https://www.exploringbinary.com/inconsistent-rounding-of-printed-floating-point-numbers/). In particular, the rounding of halves work differently, where on Windows the rounding is always done away from 0 (i.e. halves are rounded up for positive numbers), whereas on other platforms it is rounded to the nearest even number (e.g. 3.5 is rounded to 4, while 2.5 is rounded to 2), following the IEEE 754 standard.
This PR changes the test so that no such rounding error appears, which fixes #1337.
Note that this ""problem"" might appear more often also in other contexts. A more fundamental correction would be to somehow set the correct rounding mode somewhere using fesetround.","In issue #1337, it appeared that on Windows the test code for the Leiden algorithm failed due to a rounding problem. It seems that rounding is working differently on Windows than on other platforms (see https://www.exploringbinary.com/inconsistent-rounding-of-printed-floating-point-numbers/). In particular, the rounding of halves work differently, where on Windows the rounding is always done away from 0 (i.e. halves are rounded up for positive numbers), whereas on other platforms it is rounded to the nearest even number (e.g. 3.5 is rounded to 4, while 2.5 is rounded to 2), following the IEEE 754 standard.
This PR changes the test so that no such rounding error appears, which fixes #1337.
Note that this ""problem"" might appear more often also in other contexts. A more fundamental correction would be to somehow set the correct rounding mode somewhere using fesetround.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1464,2020-09-14T16:17:47Z,2020-09-14T18:26:30Z,2020-09-14T18:26:30Z,MERGED,True,22,9,2,https://github.com/szhorvat,igraph_isomorphic: check for multigraphs and clarify documentation,2,[],https://github.com/igraph/igraph/pull/1464,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1464,"igraph_isomorphic did not support multigraphs, but did not check for them. Now it does. This has a performance cost, but it should be negligible compared to the isomorphism test (unless the graphs differ in vertex-count or edge-count and are thus non-isomorphic).
igraph_isomoprhic is a high-level function so I think it is best if it does this check instead of leaving it to the user to ensure that they don't pass in multigraphs.","igraph_isomorphic did not support multigraphs, but did not check for them. Now it does. This has a performance cost, but it should be negligible compared to the isomorphism test (unless the graphs differ in vertex-count or edge-count and are thus non-isomorphic).
igraph_isomoprhic is a high-level function so I think it is best if it does this check instead of leaving it to the user to ensure that they don't pass in multigraphs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1465,2020-09-14T17:32:56Z,2020-09-16T14:16:56Z,2020-09-16T14:16:56Z,MERGED,True,271,264,18,https://github.com/szhorvat,Bliss: catch exceptions and convert to igraph error codes,3,[],https://github.com/igraph/igraph/pull/1465,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1465,"This is meant to fix #1178, but I am not completely happy with it. Any comments, @ntamas?
Bliss itself does not seem to ever throw exceptions explicitly, but it may do so implicitly (e.g. out-of-memory condition).
The first commit simply removes/comments any printing to terminal (fprtintf) from the code.","This is meant to fix #1178, but I am not completely happy with it. Any comments, @ntamas?
Bliss itself does not seem to ever throw exceptions explicitly, but it may do so implicitly (e.g. out-of-memory condition).
The first commit simply removes/comments any printing to terminal (fprtintf) from the code.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1465,2020-09-14T17:32:56Z,2020-09-16T14:16:56Z,2020-09-16T14:16:56Z,MERGED,True,271,264,18,https://github.com/szhorvat,Bliss: catch exceptions and convert to igraph error codes,3,[],https://github.com/igraph/igraph/pull/1465,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1465#issuecomment-692223406,"This is meant to fix #1178, but I am not completely happy with it. Any comments, @ntamas?
Bliss itself does not seem to ever throw exceptions explicitly, but it may do so implicitly (e.g. out-of-memory condition).
The first commit simply removes/comments any printing to terminal (fprtintf) from the code.","Just did a force-push. The change is that now all (hopefully) C++ code is wrapped in try ... catch blocks.
Also, one more commit to make some functions in bliss.cc static.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1465,2020-09-14T17:32:56Z,2020-09-16T14:16:56Z,2020-09-16T14:16:56Z,MERGED,True,271,264,18,https://github.com/szhorvat,Bliss: catch exceptions and convert to igraph error codes,3,[],https://github.com/igraph/igraph/pull/1465,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1465#issuecomment-693435999,"This is meant to fix #1178, but I am not completely happy with it. Any comments, @ntamas?
Bliss itself does not seem to ever throw exceptions explicitly, but it may do so implicitly (e.g. out-of-memory condition).
The first commit simply removes/comments any printing to terminal (fprtintf) from the code.","Seems okay to me, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1467,2020-09-15T14:14:34Z,2020-09-15T20:46:33Z,2020-09-15T20:46:33Z,MERGED,True,134,42,11,https://github.com/vtraag,Building shared library on Windows,6,[],https://github.com/igraph/igraph/pull/1467,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1467,"These commits are an initial attempt at correctly building a shared library on Windows.
Note that there is one problem remaining. The compiled igraph.dll cannot be found when simply running ctest. When manually copying this file over to the proper test directory, all the tests do run correctly. This should of course not happen, but I don't immediately know how to best configure this in CMake. Any suggestions @ntamas ?
I wanted to check what you think of the current solution of how to enable/disable tests that rely on internal functions (i.e. which are not exported when building a shared library on Windows). Is this what you had in mind @ntamas?
Of course, in the long term, we should correctly export symbols, and as said, we can also start doing this in gcc by using  visibility markers. Even then, we will of course not be able to test internal functions when building a shared library.","These commits are an initial attempt at correctly building a shared library on Windows.
Note that there is one problem remaining. The compiled igraph.dll cannot be found when simply running ctest. When manually copying this file over to the proper test directory, all the tests do run correctly. This should of course not happen, but I don't immediately know how to best configure this in CMake. Any suggestions @ntamas ?
I wanted to check what you think of the current solution of how to enable/disable tests that rely on internal functions (i.e. which are not exported when building a shared library on Windows). Is this what you had in mind @ntamas?
Of course, in the long term, we should correctly export symbols, and as said, we can also start doing this in gcc by using  visibility markers. Even then, we will of course not be able to test internal functions when building a shared library.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1467,2020-09-15T14:14:34Z,2020-09-15T20:46:33Z,2020-09-15T20:46:33Z,MERGED,True,134,42,11,https://github.com/vtraag,Building shared library on Windows,6,[],https://github.com/igraph/igraph/pull/1467,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1467#issuecomment-692969842,"These commits are an initial attempt at correctly building a shared library on Windows.
Note that there is one problem remaining. The compiled igraph.dll cannot be found when simply running ctest. When manually copying this file over to the proper test directory, all the tests do run correctly. This should of course not happen, but I don't immediately know how to best configure this in CMake. Any suggestions @ntamas ?
I wanted to check what you think of the current solution of how to enable/disable tests that rely on internal functions (i.e. which are not exported when building a shared library on Windows). Is this what you had in mind @ntamas?
Of course, in the long term, we should correctly export symbols, and as said, we can also start doing this in gcc by using  visibility markers. Even then, we will of course not be able to test internal functions when building a shared library.","The compiled igraph.dll cannot be found when simply running ctest. When manually copying this file over to the proper test directory, all the tests do run correctly.

I don't have a solution for this off the top of my head but I'll look around to see how this should be done with ctest. It might be the case that copying is the canonical solution in Windows unless there's a way to specify an additional directory to look for DLLs apart from the current directory and the standard system paths.

I wanted to check what you think of the current solution of how to enable/disable tests that rely on internal functions

Seems okay to me! I'll merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1468,2020-09-16T09:18:01Z,2020-09-16T13:17:16Z,2020-09-16T13:17:27Z,MERGED,True,214,225,37,https://github.com/szhorvat,Documentation: manually add IDs to all sections,2,[],https://github.com/igraph/igraph/pull/1468,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1468,This fixes #1315,This fixes #1315,True,{}
igraph/igraph,https://github.com/igraph/igraph,1468,2020-09-16T09:18:01Z,2020-09-16T13:17:16Z,2020-09-16T13:17:27Z,MERGED,True,214,225,37,https://github.com/szhorvat,Documentation: manually add IDs to all sections,2,[],https://github.com/igraph/igraph/pull/1468,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1468#issuecomment-693303986,This fixes #1315,"Because of the force-pushes above, I'm just noting that this is ready to merge now. I verified that there are no more random section IDs, except in the license.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1468,2020-09-16T09:18:01Z,2020-09-16T13:17:16Z,2020-09-16T13:17:27Z,MERGED,True,214,225,37,https://github.com/szhorvat,Documentation: manually add IDs to all sections,2,[],https://github.com/igraph/igraph/pull/1468,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1468#issuecomment-693387595,This fixes #1315,"I ran a spell check on some, but not all IDs, and made some more corrections. The dashes went missing because part of the job was automated and my script forgot about - characters. I also removed the igraph- prefixes in error.xxml and added in some dashes.
Pushed separate commit so you can see the changes. We can then squash-and-merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1468,2020-09-16T09:18:01Z,2020-09-16T13:17:16Z,2020-09-16T13:17:27Z,MERGED,True,214,225,37,https://github.com/szhorvat,Documentation: manually add IDs to all sections,2,[],https://github.com/igraph/igraph/pull/1468,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1468#issuecomment-693398593,This fixes #1315,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1472,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!","Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1472#issuecomment-698386668,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!","Sorry, for some reason I no longer had this solution in mind about just adapting the path. I have now done that, this is indeed a much simpler setup. This is now simplified in the latest commit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1472#issuecomment-714705245,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!",Trying to pick up this thread now -- is this ready for review or are you still working on it?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1472#issuecomment-714706581,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!",Probably better to wait for it a little bit more. I will ping you when ready.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1472#issuecomment-714711439,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!","Yes, good to go. There are essentially three things here:

Correct RPATH setting for running tests on recent gcc versions (necessary because of --enable-new-dtags is set by default).
Distinguish internal tests (i.e. those which use functions that are not exported when building a shared library) from other tests. These internal tests are disable when building a shared library on Windows.
Export warning/error handler when building a shared library.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1472#issuecomment-714735448,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!","I have seen that you have consistently changed this:
if (BUILD_SHARED_LIBS)
  set_property(TARGET bliss PROPERTY POSITION_INDEPENDENT_CODE ON)
endif()

to this:
set_property(TARGET bliss PROPERTY POSITION_INDEPENDENT_CODE ${BUILD_SHARED_LIBS})

There might be a bit of semantic difference between the two; in the original version, BUILD_SHARED_LIBS implies POSITION_INDEPENDENT_CODE being set to ON, but it leaves it at the default setting if BUILD_SHARED_LIBS is OFF. In the new version, setting BUILD_SHARED_LIBS to OFF forces POSITION_INDEPENDENT_CODE to be OFF as well.
Did you have specific problems that were solved by this change or is this purely a cosmetic one?
For what it's worth, the CMake documentation says this:

The POSITION_INDEPENDENT_CODE property determines whether position independent executables or shared libraries will be created. This property is True by default for SHARED and MODULE library targets and False otherwise.

If this is true, then there is probably no need to force it to OFF explicitly, as it would prevent the user from manually setting the global CMAKE_POSITION_INDEPENDENT_CODE to ON to force all targets to be built with -fPIC even for static libs (as we set it back to OFF afterwards).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1472#issuecomment-714736777,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!",Feel free to merge this after we've discussed the two points I've raised above.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1472,2020-09-24T07:23:26Z,2020-10-22T21:26:58Z,2020-10-22T21:26:58Z,MERGED,True,29,14500,54,https://github.com/vtraag,Further correcting tests on Windows,15,[],https://github.com/igraph/igraph/pull/1472,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1472#issuecomment-714767356,"Below is the best way I could find to copy over the necessary DLLs for testing. It relies on GET_RUNTIME_DEPENDENCIES to get all runtime dependencies, but I exclude all dependencies that should be in the common path. This problem is also discussed on the CMake Discourse forum.
For some reason I get a missing error dependency on vcruntime14_1d.dll, even though it simply exists in my path in C:\Windows\system32. I am not sure why this is happening, but I now excluded it in order to not trigger a warning.
There is one other drawback: this is executed for each test. This is the only way I could think of that ensures that all necessary files are copied over, even if only a single test is being build. It should not physically copy the files again if the files are already present, if I am correct. However, it does trace the dependencies of igraph.dll each time. This makes it a bit slower, although I have not noticed it in practice (the build is taking long enough anyway).
If you have any other recommendations or tips on how to solve this, happy to hear from you!","Did you have specific problems that were solved by this change or is this purely a cosmetic one?

This was purely cosmetic. I did not consider it would also change the default setting, perhaps indeed better to stick to the previous formulation then. I will change this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1476,2020-09-25T20:59:41Z,2020-09-29T15:30:45Z,2020-09-29T15:30:46Z,MERGED,True,31,11,4,https://github.com/vtraag,community_leiden: corrected self-loops,4,[],https://github.com/igraph/igraph/pull/1476,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1476,This fixes the problem that was identified in #1475. The problem was that self-loops were not consistently being ignored. This PR fixes #1475 by ignoring self-loops consistently throughout.,This fixes the problem that was identified in #1475. The problem was that self-loops were not consistently being ignored. This PR fixes #1475 by ignoring self-loops consistently throughout.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1476,2020-09-25T20:59:41Z,2020-09-29T15:30:45Z,2020-09-29T15:30:46Z,MERGED,True,31,11,4,https://github.com/vtraag,community_leiden: corrected self-loops,4,[],https://github.com/igraph/igraph/pull/1476,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1476#issuecomment-699456656,This fixes the problem that was identified in #1475. The problem was that self-loops were not consistently being ignored. This PR fixes #1475 by ignoring self-loops consistently throughout.,"It looks like the tests also need an update, don’t they?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1476,2020-09-25T20:59:41Z,2020-09-29T15:30:45Z,2020-09-29T15:30:46Z,MERGED,True,31,11,4,https://github.com/vtraag,community_leiden: corrected self-loops,4,[],https://github.com/igraph/igraph/pull/1476,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1476#issuecomment-699459646,This fixes the problem that was identified in #1475. The problem was that self-loops were not consistently being ignored. This PR fixes #1475 by ignoring self-loops consistently throughout.,Can you add something to the changelog to explain what changed?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1476,2020-09-25T20:59:41Z,2020-09-29T15:30:45Z,2020-09-29T15:30:46Z,MERGED,True,31,11,4,https://github.com/vtraag,community_leiden: corrected self-loops,4,[],https://github.com/igraph/igraph/pull/1476,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1476#issuecomment-699482147,This fixes the problem that was identified in #1475. The problem was that self-loops were not consistently being ignored. This PR fixes #1475 by ignoring self-loops consistently throughout.,"Right, I didn't realise there were examples with self-loops included. I'll correct that early next week. I'll also update the CHANGELOG.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1476,2020-09-25T20:59:41Z,2020-09-29T15:30:45Z,2020-09-29T15:30:46Z,MERGED,True,31,11,4,https://github.com/vtraag,community_leiden: corrected self-loops,4,[],https://github.com/igraph/igraph/pull/1476,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1476#issuecomment-699665382,This fixes the problem that was identified in #1475. The problem was that self-loops were not consistently being ignored. This PR fixes #1475 by ignoring self-loops consistently throughout.,"@vtraag I changed the bug number on the ""fixes"" line in the original post above. I think you meant to say 1475 but wrote 1474 (which will trigger auto-closing that bug once the PR is merged).",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1478,2020-10-02T05:48:38Z,2020-12-18T21:57:45Z,2020-12-18T21:57:45Z,CLOSED,False,13,8,2,https://github.com/iosonofabio,Delimiter write edgelist,1,['stale'],https://github.com/igraph/igraph/pull/1478,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1478,"This is an attempt at enabling a custom delimiter when reading/writing edgelists from/to text files (#797 )
It currently breaks the API because I am not sure as of how to handle default arguments of this kind.
Anyone can advise on this one? Shall we just break and require a del argument from 0.9, or how else would you handle this kind of trivial but API-breaking fix?
NOTE: I haven't changed the tests yet, so they will probably fail.","This is an attempt at enabling a custom delimiter when reading/writing edgelists from/to text files (#797 )
It currently breaks the API because I am not sure as of how to handle default arguments of this kind.
Anyone can advise on this one? Shall we just break and require a del argument from 0.9, or how else would you handle this kind of trivial but API-breaking fix?
NOTE: I haven't changed the tests yet, so they will probably fail.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1478,2020-10-02T05:48:38Z,2020-12-18T21:57:45Z,2020-12-18T21:57:45Z,CLOSED,False,13,8,2,https://github.com/iosonofabio,Delimiter write edgelist,1,['stale'],https://github.com/igraph/igraph/pull/1478,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1478#issuecomment-703664283,"This is an attempt at enabling a custom delimiter when reading/writing edgelists from/to text files (#797 )
It currently breaks the API because I am not sure as of how to handle default arguments of this kind.
Anyone can advise on this one? Shall we just break and require a del argument from 0.9, or how else would you handle this kind of trivial but API-breaking fix?
NOTE: I haven't changed the tests yet, so they will probably fail.","We will break the API several times in 0.9 so I don't mind adding an extra argument to igraph_write_graph_edgelist() and igraph_read_graph_edgelist().
However, note that igraph_read_graph_edgelist() used isspace() for comparisons because isspace() also matches newline characters -- so, it was only recommended (but not required) to use one edge per line. The user was free to put all edges on the same line. This won't work after your modifications, and you would need an extra piece of code to look for a newline after every second vertex ID.
I think that since igraph_read_graph_edgelist() does not mandate the usage of one edge per line, a better place for this functionality would be a function like igraph_read_graph_edgelist_with_separators() (but let's find a better/shorter name for that), which could be organized similarly to igraph_read_graph_ncol() (which is a terrible name because most people don't realize that this is essentially an edge list where the vertex names can also be strings). So, one edge per line, but the separator could be chosen arbitrarily.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1478,2020-10-02T05:48:38Z,2020-12-18T21:57:45Z,2020-12-18T21:57:45Z,CLOSED,False,13,8,2,https://github.com/iosonofabio,Delimiter write edgelist,1,['stale'],https://github.com/igraph/igraph/pull/1478,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1478#issuecomment-703665436,"This is an attempt at enabling a custom delimiter when reading/writing edgelists from/to text files (#797 )
It currently breaks the API because I am not sure as of how to handle default arguments of this kind.
Anyone can advise on this one? Shall we just break and require a del argument from 0.9, or how else would you handle this kind of trivial but API-breaking fix?
NOTE: I haven't changed the tests yet, so they will probably fail.","Footnote: I can foresee that once we added this feature, people would start reading edge lists in CSV files with it, only to realize that quotes are not handled properly so they cannot have vertices with commas in their names. The next step would then be to add a fully fledged CSV parser :) I was wondering whether we could anticipate that and create a function that takes a delimiter character and a quote character as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1478,2020-10-02T05:48:38Z,2020-12-18T21:57:45Z,2020-12-18T21:57:45Z,CLOSED,False,13,8,2,https://github.com/iosonofabio,Delimiter write edgelist,1,['stale'],https://github.com/igraph/igraph/pull/1478,https://github.com/apps/stale,4,https://github.com/igraph/igraph/pull/1478#issuecomment-738984949,"This is an attempt at enabling a custom delimiter when reading/writing edgelists from/to text files (#797 )
It currently breaks the API because I am not sure as of how to handle default arguments of this kind.
Anyone can advise on this one? Shall we just break and require a del argument from 0.9, or how else would you handle this kind of trivial but API-breaking fix?
NOTE: I haven't changed the tests yet, so they will probably fail.",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1485,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1485#issuecomment-713776430,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"Looks good, I think you should merge. We should add a test which properly exercises these functions ...
(I should note that I never used igraph's attribute handlers. The Mma interface doesn't use them.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1485#issuecomment-713803933,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"LGTM
The attribute handlers are exercised heavily from the Python interface, but bugs like these are hard to spot as you need to repeat the buggy operation many times to reach the size limit of the finally stack. Anyway, I should have noticed this had I queried the size of the ""finally"" stack at the end of the Python test suite; during normal operation, the ""finally"" stack must always be empty when the execution flow gets back to Python's REPL loop.
It might be a good idea to expose a function that reports the size of the ""finally"" stack somewhere hidden in the API of the higher-level interfaces so test suites can use them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1485#issuecomment-713807044,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"@ntamas We already have --enable-verify-finally, it could be used for the Python tests as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1485#issuecomment-713811406,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"Just realized that the bug here was in the C attribute handler, which is not used by the Python interface. So yes, @vtraag is right, we need more tests for this part of the code.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1485#issuecomment-713879652,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"I might have been too quick with this fix. It seems that instead that the
    igraph_i_cattribute_permute_free(new_val);

was missing, the
IGRAPH_FINALLY(igraph_i_cattribute_permute_free, new_val);

was uncalled for. By freeing new_val, I think the new values of the combined attributes would actually be freed, which should not be the intention. Hence, this should also not have been pushed to the FINALLY stack. What do you think?
See vtraag@d945281 for a proper fix. I have now also asked the OP to test that fix, we should probably also wait until (s)he confirms.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1485#issuecomment-714228153,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,The OP also confirms this is the correct fix. I think we should merge the proper fix. It seems that the same pattern (pushing permute_free to the FINALLY stack) is also happening in other places in cattributes.c. I will have a look at those other instances later today.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1485#issuecomment-714350636,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"Okay - will you send another PR later today when you've had the chance to take a look at all the other instances, or shall I just fix it now on my own?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1485#issuecomment-714364650,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,"A question: would adding VERIFY_FINALLY_STACK() to the end of the C attribute handler tests have revealed any of these issues? We should really take the time to separate tests from usage examples, move the tests to the test directory, and add  VERIFY_FINALLY_STACK() to the end of each test. But only after the cmake branch is merged, otherwise we just create extra work.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1485,2020-10-21T18:03:09Z,2020-10-21T18:57:06Z,2020-10-22T10:11:31Z,MERGED,True,2,1,1,https://github.com/vtraag,igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls.,1,[],https://github.com/igraph/igraph/pull/1485,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1485#issuecomment-714387538,This fixes the problem identified in #1484 of mismatching FINALLY calls in igraph_i_cattribute_combine_vertices.,Just created a new PR (#1486). I think you are right @szhorvat : we should indeed clearly separate tests from examples.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1486,2020-10-22T10:10:56Z,2020-10-22T11:09:45Z,2020-10-22T11:09:45Z,MERGED,True,0,1,1,https://github.com/vtraag, igraph_i_cattribute_combine_vertices: correct mismatching FINALLY calls (part 2),2,[],https://github.com/igraph/igraph/pull/1486,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1486,"Continuation of #1485, after it appeared the solution was actually incorrect (see #1485 (comment)).","Continuation of #1485, after it appeared the solution was actually incorrect (see #1485 (comment)).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1487,2020-10-22T11:56:54Z,2020-10-22T12:26:39Z,2020-10-22T12:57:23Z,MERGED,True,5,0,2,https://github.com/szhorvat,igraph_blas_internal.h: add missing defines,2,[],https://github.com/igraph/igraph/pull/1487,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1487,"Fixes building with internal LAPACK, external BLAS.
When trying to build the tests, I got:
Undefined symbols for architecture x86_64:
  ""_igraphdsymv_"", referenced from:
      _dlatrd_ in libigraph.a(dlatrd.c.o)
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2_"", referenced from:
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2k_"", referenced from:
      _dsytrd_ in libigraph.a(dsytrd.c.o)
  ""_igraphdtrmv_"", referenced from:
      _dlahr2_ in libigraph.a(dlahr2.c.o)
      _dlarft_ in libigraph.a(dlarft.c.o)
ld: symbol(s) not found for architecture x86_64

This fixes the problem, at least for the static build.","Fixes building with internal LAPACK, external BLAS.
When trying to build the tests, I got:
Undefined symbols for architecture x86_64:
  ""_igraphdsymv_"", referenced from:
      _dlatrd_ in libigraph.a(dlatrd.c.o)
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2_"", referenced from:
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2k_"", referenced from:
      _dsytrd_ in libigraph.a(dsytrd.c.o)
  ""_igraphdtrmv_"", referenced from:
      _dlahr2_ in libigraph.a(dlahr2.c.o)
      _dlarft_ in libigraph.a(dlarft.c.o)
ld: symbol(s) not found for architecture x86_64

This fixes the problem, at least for the static build.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1487,2020-10-22T11:56:54Z,2020-10-22T12:26:39Z,2020-10-22T12:57:23Z,MERGED,True,5,0,2,https://github.com/szhorvat,igraph_blas_internal.h: add missing defines,2,[],https://github.com/igraph/igraph/pull/1487,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1487#issuecomment-714460610,"Fixes building with internal LAPACK, external BLAS.
When trying to build the tests, I got:
Undefined symbols for architecture x86_64:
  ""_igraphdsymv_"", referenced from:
      _dlatrd_ in libigraph.a(dlatrd.c.o)
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2_"", referenced from:
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2k_"", referenced from:
      _dsytrd_ in libigraph.a(dsytrd.c.o)
  ""_igraphdtrmv_"", referenced from:
      _dlahr2_ in libigraph.a(dlahr2.c.o)
      _dlarft_ in libigraph.a(dlarft.c.o)
ld: symbol(s) not found for architecture x86_64

This fixes the problem, at least for the static build.",Was this really intended for master? Shouldn't this have been targeted at the feature/cmake-build branch?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1487,2020-10-22T11:56:54Z,2020-10-22T12:26:39Z,2020-10-22T12:57:23Z,MERGED,True,5,0,2,https://github.com/szhorvat,igraph_blas_internal.h: add missing defines,2,[],https://github.com/igraph/igraph/pull/1487,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1487#issuecomment-714461912,"Fixes building with internal LAPACK, external BLAS.
When trying to build the tests, I got:
Undefined symbols for architecture x86_64:
  ""_igraphdsymv_"", referenced from:
      _dlatrd_ in libigraph.a(dlatrd.c.o)
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2_"", referenced from:
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2k_"", referenced from:
      _dsytrd_ in libigraph.a(dsytrd.c.o)
  ""_igraphdtrmv_"", referenced from:
      _dlahr2_ in libigraph.a(dlahr2.c.o)
      _dlarft_ in libigraph.a(dlarft.c.o)
ld: symbol(s) not found for architecture x86_64

This fixes the problem, at least for the static build.",I think this affects the non-CMake build as well. At least that was my understanding.,True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1487,2020-10-22T11:56:54Z,2020-10-22T12:26:39Z,2020-10-22T12:57:23Z,MERGED,True,5,0,2,https://github.com/szhorvat,igraph_blas_internal.h: add missing defines,2,[],https://github.com/igraph/igraph/pull/1487,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1487#issuecomment-714475426,"Fixes building with internal LAPACK, external BLAS.
When trying to build the tests, I got:
Undefined symbols for architecture x86_64:
  ""_igraphdsymv_"", referenced from:
      _dlatrd_ in libigraph.a(dlatrd.c.o)
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2_"", referenced from:
      _dsytd2_ in libigraph.a(dsytd2.c.o)
  ""_igraphdsyr2k_"", referenced from:
      _dsytrd_ in libigraph.a(dsytrd.c.o)
  ""_igraphdtrmv_"", referenced from:
      _dlahr2_ in libigraph.a(dlahr2.c.o)
      _dlarft_ in libigraph.a(dlarft.c.o)
ld: symbol(s) not found for architecture x86_64

This fixes the problem, at least for the static build.","Yes, it was for master as well. The problem was that --with-external-blas --with-external-lapack worked, but --with-external-blas (and internal lapack) did not work.
However, I only tested on the cmake branch, which has unrelated problems. A few more things need to be fixed. I'll push those now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1488,2020-10-23T08:23:59Z,2020-10-23T11:47:47Z,2020-10-23T11:47:47Z,MERGED,True,27,25,9,https://github.com/szhorvat,"Further fixes for building with external blas, internal lapack",2,[],https://github.com/igraph/igraph/pull/1488,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1488,"More fixes for building with external BLAS, internal LAPACK.
Changes:

When building internal LAPACK, do not also include the objects belonging to internal BLAS (internal LAPACK should be able to use external BLAS)
xerbla.c and len_trim.c belong to LAPACK, I believe, not to BLAS, so move them there in CMakeLists.txt
igraph_lapack_ddot is renamed to igraph_blas_ddot and moved to igraph_blas.c/igraph_blas.h, as this is a BLAS function, not a LAPACK one. This function was exposed publicly, so this is a breaking change.
in igraph_blas_internal.h, give a prototype to igraphddot_ (which may be changed by a #define to ddot_) so that there would be no complaints about missing prototypes. There are already other similar prototypes there.
igraph_blas_internal.h can now be removed from lapack.c (I added it yesterday in dada582, but the better fix is to move the ddot stuff to blas.c instead as noted above)","More fixes for building with external BLAS, internal LAPACK.
Changes:

When building internal LAPACK, do not also include the objects belonging to internal BLAS (internal LAPACK should be able to use external BLAS)
xerbla.c and len_trim.c belong to LAPACK, I believe, not to BLAS, so move them there in CMakeLists.txt
igraph_lapack_ddot is renamed to igraph_blas_ddot and moved to igraph_blas.c/igraph_blas.h, as this is a BLAS function, not a LAPACK one. This function was exposed publicly, so this is a breaking change.
in igraph_blas_internal.h, give a prototype to igraphddot_ (which may be changed by a #define to ddot_) so that there would be no complaints about missing prototypes. There are already other similar prototypes there.
igraph_blas_internal.h can now be removed from lapack.c (I added it yesterday in dada582, but the better fix is to move the ddot stuff to blas.c instead as noted above)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1488,2020-10-23T08:23:59Z,2020-10-23T11:47:47Z,2020-10-23T11:47:47Z,MERGED,True,27,25,9,https://github.com/szhorvat,"Further fixes for building with external blas, internal lapack",2,[],https://github.com/igraph/igraph/pull/1488,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1488#issuecomment-715281313,"More fixes for building with external BLAS, internal LAPACK.
Changes:

When building internal LAPACK, do not also include the objects belonging to internal BLAS (internal LAPACK should be able to use external BLAS)
xerbla.c and len_trim.c belong to LAPACK, I believe, not to BLAS, so move them there in CMakeLists.txt
igraph_lapack_ddot is renamed to igraph_blas_ddot and moved to igraph_blas.c/igraph_blas.h, as this is a BLAS function, not a LAPACK one. This function was exposed publicly, so this is a breaking change.
in igraph_blas_internal.h, give a prototype to igraphddot_ (which may be changed by a #define to ddot_) so that there would be no complaints about missing prototypes. There are already other similar prototypes there.
igraph_blas_internal.h can now be removed from lapack.c (I added it yesterday in dada582, but the better fix is to move the ddot stuff to blas.c instead as noted above)","Thanks for the cleanup! I think it's all good, with one exception: len_trim is not BLAS but a Fortran intrinsic. If we want to be consistent, we should probably move it to src/fortran_intrinsics.c instead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1500,2020-10-24T20:15:10Z,2020-10-25T08:49:44Z,2020-10-25T18:59:09Z,MERGED,True,3,3,1,https://github.com/vtraag,Use realloc from CXSparse,1,[],https://github.com/igraph/igraph/pull/1500,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1500,"This PR changes igraph_sparsemat_add_cols to use cs_realloc to ensure that the reallocation is happening from the same runtime from CXSparse. This ensures that the reallocation is done with the same runtime that originally allocated the memory. If this is not done, this might lead to memory problem such as noted in #1492, which is fixed by this PR.","This PR changes igraph_sparsemat_add_cols to use cs_realloc to ensure that the reallocation is happening from the same runtime from CXSparse. This ensures that the reallocation is done with the same runtime that originally allocated the memory. If this is not done, this might lead to memory problem such as noted in #1492, which is fixed by this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1500,2020-10-24T20:15:10Z,2020-10-25T08:49:44Z,2020-10-25T18:59:09Z,MERGED,True,3,3,1,https://github.com/vtraag,Use realloc from CXSparse,1,[],https://github.com/igraph/igraph/pull/1500,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1500#issuecomment-716110909,"This PR changes igraph_sparsemat_add_cols to use cs_realloc to ensure that the reallocation is happening from the same runtime from CXSparse. This ensures that the reallocation is done with the same runtime that originally allocated the memory. If this is not done, this might lead to memory problem such as noted in #1492, which is fixed by this PR.",Looks good.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1502,2020-10-25T10:27:07Z,2020-10-26T09:10:37Z,2020-10-26T09:10:37Z,MERGED,True,6,3,2,https://github.com/szhorvat,DECLDIR cleanup,2,[],https://github.com/igraph/igraph/pull/1502,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1502,"Justification:


_WIN32 is defined both on 32-bit and 64-bit Windows. It is define by the compiler itself, and does not depend on the inclusion of any header. It appears to me that it is the correct way to test for Windows. Reference: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019


WIN32 is not a standard macro (it may be defined by some headers though). We don't need it. Reference: see above and https://stackoverflow.com/q/9025708/695132 and https://stackoverflow.com/q/662084/695132


declspec is supported by MINGW, so no need to exclude it from MINGW. Reference: https://stackoverflow.com/q/22285240/695132


Cygwin is pretending to be Unix as much as possible, and does not actually define _WIN32, unless using the -mwin32 option. However, there are suggestion that in the past it did, so it is better to keep explicitly excluding it. Reference: https://stackoverflow.com/q/47150492/695132 and https://cygwin.com/faq/faq.html#faq.programming.preprocessor


While __CYGWIN32__ exists (both on 32- and 64-bit), the Cygwin documentation suggests using __CYGWIN__.  Reference: https://cygwin.com/faq/faq.html#faq.programming.preprocessor","Justification:


_WIN32 is defined both on 32-bit and 64-bit Windows. It is define by the compiler itself, and does not depend on the inclusion of any header. It appears to me that it is the correct way to test for Windows. Reference: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019


WIN32 is not a standard macro (it may be defined by some headers though). We don't need it. Reference: see above and https://stackoverflow.com/q/9025708/695132 and https://stackoverflow.com/q/662084/695132


declspec is supported by MINGW, so no need to exclude it from MINGW. Reference: https://stackoverflow.com/q/22285240/695132


Cygwin is pretending to be Unix as much as possible, and does not actually define _WIN32, unless using the -mwin32 option. However, there are suggestion that in the past it did, so it is better to keep explicitly excluding it. Reference: https://stackoverflow.com/q/47150492/695132 and https://cygwin.com/faq/faq.html#faq.programming.preprocessor


While __CYGWIN32__ exists (both on 32- and 64-bit), the Cygwin documentation suggests using __CYGWIN__.  Reference: https://cygwin.com/faq/faq.html#faq.programming.preprocessor",True,{}
igraph/igraph,https://github.com/igraph/igraph,1502,2020-10-25T10:27:07Z,2020-10-26T09:10:37Z,2020-10-26T09:10:37Z,MERGED,True,6,3,2,https://github.com/szhorvat,DECLDIR cleanup,2,[],https://github.com/igraph/igraph/pull/1502,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1502#issuecomment-716124304,"Justification:


_WIN32 is defined both on 32-bit and 64-bit Windows. It is define by the compiler itself, and does not depend on the inclusion of any header. It appears to me that it is the correct way to test for Windows. Reference: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019


WIN32 is not a standard macro (it may be defined by some headers though). We don't need it. Reference: see above and https://stackoverflow.com/q/9025708/695132 and https://stackoverflow.com/q/662084/695132


declspec is supported by MINGW, so no need to exclude it from MINGW. Reference: https://stackoverflow.com/q/22285240/695132


Cygwin is pretending to be Unix as much as possible, and does not actually define _WIN32, unless using the -mwin32 option. However, there are suggestion that in the past it did, so it is better to keep explicitly excluding it. Reference: https://stackoverflow.com/q/47150492/695132 and https://cygwin.com/faq/faq.html#faq.programming.preprocessor


While __CYGWIN32__ exists (both on 32- and 64-bit), the Cygwin documentation suggests using __CYGWIN__.  Reference: https://cygwin.com/faq/faq.html#faq.programming.preprocessor",Note: this is not yet properly tested!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1502,2020-10-25T10:27:07Z,2020-10-26T09:10:37Z,2020-10-26T09:10:37Z,MERGED,True,6,3,2,https://github.com/szhorvat,DECLDIR cleanup,2,[],https://github.com/igraph/igraph/pull/1502,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1502#issuecomment-716125191,"Justification:


_WIN32 is defined both on 32-bit and 64-bit Windows. It is define by the compiler itself, and does not depend on the inclusion of any header. It appears to me that it is the correct way to test for Windows. Reference: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019


WIN32 is not a standard macro (it may be defined by some headers though). We don't need it. Reference: see above and https://stackoverflow.com/q/9025708/695132 and https://stackoverflow.com/q/662084/695132


declspec is supported by MINGW, so no need to exclude it from MINGW. Reference: https://stackoverflow.com/q/22285240/695132


Cygwin is pretending to be Unix as much as possible, and does not actually define _WIN32, unless using the -mwin32 option. However, there are suggestion that in the past it did, so it is better to keep explicitly excluding it. Reference: https://stackoverflow.com/q/47150492/695132 and https://cygwin.com/faq/faq.html#faq.programming.preprocessor


While __CYGWIN32__ exists (both on 32- and 64-bit), the Cygwin documentation suggests using __CYGWIN__.  Reference: https://cygwin.com/faq/faq.html#faq.programming.preprocessor",In other cases this seemed insufficiently general: https://igraph.discourse.group/t/cmake-on-windows/298/42?u=vtraag. I'll have a look though.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1502,2020-10-25T10:27:07Z,2020-10-26T09:10:37Z,2020-10-26T09:10:37Z,MERGED,True,6,3,2,https://github.com/szhorvat,DECLDIR cleanup,2,[],https://github.com/igraph/igraph/pull/1502,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1502#issuecomment-716125742,"Justification:


_WIN32 is defined both on 32-bit and 64-bit Windows. It is define by the compiler itself, and does not depend on the inclusion of any header. It appears to me that it is the correct way to test for Windows. Reference: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019


WIN32 is not a standard macro (it may be defined by some headers though). We don't need it. Reference: see above and https://stackoverflow.com/q/9025708/695132 and https://stackoverflow.com/q/662084/695132


declspec is supported by MINGW, so no need to exclude it from MINGW. Reference: https://stackoverflow.com/q/22285240/695132


Cygwin is pretending to be Unix as much as possible, and does not actually define _WIN32, unless using the -mwin32 option. However, there are suggestion that in the past it did, so it is better to keep explicitly excluding it. Reference: https://stackoverflow.com/q/47150492/695132 and https://cygwin.com/faq/faq.html#faq.programming.preprocessor


While __CYGWIN32__ exists (both on 32- and 64-bit), the Cygwin documentation suggests using __CYGWIN__.  Reference: https://cygwin.com/faq/faq.html#faq.programming.preprocessor",Do you have an example where _WIN32 was not defined on Windows (not Cygwin!)? The official documentation says that it should always be defined by the compiler itself.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1502,2020-10-25T10:27:07Z,2020-10-26T09:10:37Z,2020-10-26T09:10:37Z,MERGED,True,6,3,2,https://github.com/szhorvat,DECLDIR cleanup,2,[],https://github.com/igraph/igraph/pull/1502,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1502#issuecomment-716127303,"Justification:


_WIN32 is defined both on 32-bit and 64-bit Windows. It is define by the compiler itself, and does not depend on the inclusion of any header. It appears to me that it is the correct way to test for Windows. Reference: https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019


WIN32 is not a standard macro (it may be defined by some headers though). We don't need it. Reference: see above and https://stackoverflow.com/q/9025708/695132 and https://stackoverflow.com/q/662084/695132


declspec is supported by MINGW, so no need to exclude it from MINGW. Reference: https://stackoverflow.com/q/22285240/695132


Cygwin is pretending to be Unix as much as possible, and does not actually define _WIN32, unless using the -mwin32 option. However, there are suggestion that in the past it did, so it is better to keep explicitly excluding it. Reference: https://stackoverflow.com/q/47150492/695132 and https://cygwin.com/faq/faq.html#faq.programming.preprocessor


While __CYGWIN32__ exists (both on 32- and 64-bit), the Cygwin documentation suggests using __CYGWIN__.  Reference: https://cygwin.com/faq/faq.html#faq.programming.preprocessor","My motivation for this change was to go by something that is officially documented. I added a comment pointing to the documentation, to avoid future confusion.
There is a lot of confusion out there. You'll find all sort of inconsistent attempts to check for Windows in various projects. I want to avoid this, and want to avoid relying on guesswork. I'd like to use the official way, and be confident about why we are doing it this way.
If we include other checks, we should know why and when they are needed (according to the MS documentation, they are not needed).",True,"{'THUMBS_UP': ['https://github.com/vtraag', 'https://github.com/ntamas']}"
igraph/igraph,https://github.com/igraph/igraph,1504,2020-10-25T23:03:11Z,2020-10-26T09:15:55Z,2020-10-26T09:15:55Z,MERGED,True,1,1,1,https://github.com/vtraag,CMake add path for test on MinGW,1,[],https://github.com/igraph/igraph/pull/1504,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1504,"This PR adds the correct path for tests on MinGW. Before this the path was being added only for MSVC. This is now generalised to WIN32, which also includes MinGW. This fixes #1501.
One important note, which we should also include in the installation instructions (#1497) is that the mingw64/bin directory should be added to the Windows path. Without this, running ctest will fail (even from the msys2 terminal).","This PR adds the correct path for tests on MinGW. Before this the path was being added only for MSVC. This is now generalised to WIN32, which also includes MinGW. This fixes #1501.
One important note, which we should also include in the installation instructions (#1497) is that the mingw64/bin directory should be added to the Windows path. Without this, running ctest will fail (even from the msys2 terminal).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1508,2020-10-27T15:30:04Z,2020-10-27T19:07:55Z,2020-10-28T07:56:28Z,MERGED,True,11,1,1,https://github.com/vtraag,Properly fix path problems with CTest on MinGW,2,[],https://github.com/igraph/igraph/pull/1508,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1508,"This is a continuation of #1504. There were some further problems with paths on MinGW, see #1501 (comment) for some more details. This now finally properly fixes #1501.","This is a continuation of #1504. There were some further problems with paths on MinGW, see #1501 (comment) for some more details. This now finally properly fixes #1501.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1508,2020-10-27T15:30:04Z,2020-10-27T19:07:55Z,2020-10-28T07:56:28Z,MERGED,True,11,1,1,https://github.com/vtraag,Properly fix path problems with CTest on MinGW,2,[],https://github.com/igraph/igraph/pull/1508,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1508#issuecomment-717326393,"This is a continuation of #1504. There were some further problems with paths on MinGW, see #1501 (comment) for some more details. This now finally properly fixes #1501.","Sorry, I now realise that we should document this monstrosity properly. I unfortunately don't have time now anymore, I have to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1508,2020-10-27T15:30:04Z,2020-10-27T19:07:55Z,2020-10-28T07:56:28Z,MERGED,True,11,1,1,https://github.com/vtraag,Properly fix path problems with CTest on MinGW,2,[],https://github.com/igraph/igraph/pull/1508,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1508#issuecomment-717330024,"This is a continuation of #1504. There were some further problems with paths on MinGW, see #1501 (comment) for some more details. This now finally properly fixes #1501.","Let's wait for the CI tests; if they pass, I'm okay to merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1508,2020-10-27T15:30:04Z,2020-10-27T19:07:55Z,2020-10-28T07:56:28Z,MERGED,True,11,1,1,https://github.com/vtraag,Properly fix path problems with CTest on MinGW,2,[],https://github.com/igraph/igraph/pull/1508,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1508#issuecomment-717471040,"This is a continuation of #1504. There were some further problems with paths on MinGW, see #1501 (comment) for some more details. This now finally properly fixes #1501.","I now tried to rerun this locally in MinGW to double check something. I rebased against the latest cmake branch before opening this PR (without testing actually), but I am now running into several errors similar to the following:
C:/Users/traagva1/src/igraph/src/adjlist.c:95:5: error: 'igraph_adjlist_init' redeclared without dllimport attribute: previous dllimport ignored [-Werror=attributes]
   95 | int igraph_adjlist_init(const igraph_t *graph, igraph_adjlist_t *al,
      |     ^~~~~~~~~~~~~~~~~~~

I don't know immediately what commit caused this, I think this might have been a warning instead of an error earlier.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1508,2020-10-27T15:30:04Z,2020-10-27T19:07:55Z,2020-10-28T07:56:28Z,MERGED,True,11,1,1,https://github.com/vtraag,Properly fix path problems with CTest on MinGW,2,[],https://github.com/igraph/igraph/pull/1508,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1508#issuecomment-717473065,"This is a continuation of #1504. There were some further problems with paths on MinGW, see #1501 (comment) for some more details. This now finally properly fixes #1501.","This is probably unrelated so let's keep track of it in a separate issue.
The doc generation fails now, but that's also another issue, I'll fix it soon.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1509,2020-10-27T18:24:19Z,2020-10-27T21:58:59Z,2020-10-27T21:58:59Z,MERGED,True,20,18,5,https://github.com/szhorvat,cmake: Condition warning options on C_COMPILER_ID,1,[],https://github.com/igraph/igraph/pull/1509,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1509,"This PR makes all warning options conditional on the compiler. GCC,Clang,AppleClang are included, as these are what we use, and these usually take the same options.
These options are not actually needed for compilation. They are just a nice to have during development. They alert us to problems.
However, they will also prevent other compilers from working:


Compilation failed with the Intel compiler, so options had to be adjusted for that one a bit. Removing them entirely would have worked as well, but adjusting them made it easier for us to make use of the Intel compiler's warning.


Compilation also failed with the PGI compiler. With this PR, it passes (after adjusting the source code a bit, but that's a separate thing). Of course, it shows lots of warning, but igraph does compiler, and the tests pass, and that's what matters.","This PR makes all warning options conditional on the compiler. GCC,Clang,AppleClang are included, as these are what we use, and these usually take the same options.
These options are not actually needed for compilation. They are just a nice to have during development. They alert us to problems.
However, they will also prevent other compilers from working:


Compilation failed with the Intel compiler, so options had to be adjusted for that one a bit. Removing them entirely would have worked as well, but adjusting them made it easier for us to make use of the Intel compiler's warning.


Compilation also failed with the PGI compiler. With this PR, it passes (after adjusting the source code a bit, but that's a separate thing). Of course, it shows lots of warning, but igraph does compiler, and the tests pass, and that's what matters.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1509,2020-10-27T18:24:19Z,2020-10-27T21:58:59Z,2020-10-27T21:58:59Z,MERGED,True,20,18,5,https://github.com/szhorvat,cmake: Condition warning options on C_COMPILER_ID,1,[],https://github.com/igraph/igraph/pull/1509,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1509#issuecomment-717438990,"This PR makes all warning options conditional on the compiler. GCC,Clang,AppleClang are included, as these are what we use, and these usually take the same options.
These options are not actually needed for compilation. They are just a nice to have during development. They alert us to problems.
However, they will also prevent other compilers from working:


Compilation failed with the Intel compiler, so options had to be adjusted for that one a bit. Removing them entirely would have worked as well, but adjusting them made it easier for us to make use of the Intel compiler's warning.


Compilation also failed with the PGI compiler. With this PR, it passes (after adjusting the source code a bit, but that's a separate thing). Of course, it shows lots of warning, but igraph does compiler, and the tests pass, and that's what matters.","There is one additional change here: adding include(compilers) to the vendored GLPK, so that any globally set compiler options take effect for it too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1509,2020-10-27T18:24:19Z,2020-10-27T21:58:59Z,2020-10-27T21:58:59Z,MERGED,True,20,18,5,https://github.com/szhorvat,cmake: Condition warning options on C_COMPILER_ID,1,[],https://github.com/igraph/igraph/pull/1509,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1509#issuecomment-717503633,"This PR makes all warning options conditional on the compiler. GCC,Clang,AppleClang are included, as these are what we use, and these usually take the same options.
These options are not actually needed for compilation. They are just a nice to have during development. They alert us to problems.
However, they will also prevent other compilers from working:


Compilation failed with the Intel compiler, so options had to be adjusted for that one a bit. Removing them entirely would have worked as well, but adjusting them made it easier for us to make use of the Intel compiler's warning.


Compilation also failed with the PGI compiler. With this PR, it passes (after adjusting the source code a bit, but that's a separate thing). Of course, it shows lots of warning, but igraph does compiler, and the tests pass, and that's what matters.",Ready to merge if the CI build passes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1510,2020-10-27T18:35:08Z,2020-10-27T20:12:11Z,2020-12-03T19:07:05Z,MERGED,True,1,5,1,https://github.com/szhorvat,igraph_attribute_combination: make compatible with PGI compiler,1,[],https://github.com/igraph/igraph/pull/1510,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1510,"The PGI compiler choked on this:
/src/attributes.c"", line 426: error: expected an
          expression
              func = va_arg(ap, (void (*)(void)) );
                     ^

I expect other compilers choked on it too because it was conditioned on the macro __GCC__, but the PGI compiler has that macro defined. This version should be more compatible, and works fine with the PGI compiler.","The PGI compiler choked on this:
/src/attributes.c"", line 426: error: expected an
          expression
              func = va_arg(ap, (void (*)(void)) );
                     ^

I expect other compilers choked on it too because it was conditioned on the macro __GCC__, but the PGI compiler has that macro defined. This version should be more compatible, and works fine with the PGI compiler.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1511,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270","I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270",True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1511#issuecomment-717840643,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270","It appears that when I create an undirected graph, the 'from' vertex will always be the smaller index one, and the 'to' the larger index one. I.e., 1,0,  1,2,  3,0 is transformed to 0,1,  1,2,  0,3.
@ntamas @gaborcsardi Do you know if this ordering is guaranteed or not?
Also pinging @vtraag, as you've been looking into the igraph_t structure recently.
When the graph construction goes through igraph_add_edges, then endpoints of undirected edges will be ordered (""canonicalized"") like this:
https://github.com/igraph/igraph/blob/master/src/type_indexededgelist.c#L277
However, I do not know if all construction paths go through here, and if there are an modification paths that may violate it.
The comment here suggests that the canonicalization of undirected edges is not guaranteed:
https://github.com/igraph/igraph/blob/master/include/igraph_datatype.h#L60
However, this code suggests that it is guaranteed after all (at least the code seems to rely on it):
https://github.com/igraph/igraph/blob/master/src/type_indexededgelist.c#L1110

In this PR, the ACYCLIC method basically just orders the endpoints of undirected edges before creating the directed one. If undirected edges are already canonicalized, then the ARBITRARY method effectively does the same. This does not mean that there should not be an ACYCLIC method, as it's semantically different, and the behaviour of ARBITRARY could change in the future. But knowing whether edge canonicalization is done is important for the implementation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/gaborcsardi,3,https://github.com/igraph/igraph/pull/1511#issuecomment-717848156,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270","@ntamas @gaborcsardi Do you know if this ordering is guaranteed or not?

It is guaranteed, but you probably should not rely on it, because it is a contract in the implementation layer only, AFAIR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1511#issuecomment-717851191,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270","OK, then I will:


Update the comment here to note that this is currently guaranteed: https://github.com/igraph/igraph/blob/master/include/igraph_datatype.h#L60


Not rely on it outside of type_indexedgelist.c, in particular not rely on it in this PR",True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/gaborcsardi,5,https://github.com/igraph/igraph/pull/1511#issuecomment-717852679,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270","Right, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1511#issuecomment-717862078,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270",Ready for review. Should be squashed before merging.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1511,2020-10-27T19:26:23Z,2020-10-28T14:46:24Z,2020-10-28T14:46:24Z,MERGED,True,186,26,5,https://github.com/szhorvat,to_directed: add RANDOM and ACYCLIC modes,5,[],https://github.com/igraph/igraph/pull/1511,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1511#issuecomment-717885927,"I don't use this function in the Mma interface, so it would be nice to integrate it into Python for easier testing.
Fixes #1270","Regarding the FINALLY stuff, I wasn't paying attention as it was old code. You are correct: IGRAPH_I_ATTRIBUTE_COPY can fail. Pls see the last commit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1512,2020-10-28T12:34:28Z,2020-10-29T10:17:20Z,2020-10-29T10:17:20Z,MERGED,True,26,1827,9,https://github.com/vtraag,Correctly compiling vendored libraries as OBJECT libraries on MinGW/MSVC,2,[],https://github.com/igraph/igraph/pull/1512,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1512,"This PR includes the IGRAPH_STATIC definition for vendored libraries that are included as OBJECT libraries. Without this, some of the libraries include igraph headers, which are then imported with a declspec declaration. This then fails, because they are not external libraries, but linked as OBJECT libraries.","This PR includes the IGRAPH_STATIC definition for vendored libraries that are included as OBJECT libraries. Without this, some of the libraries include igraph headers, which are then imported with a declspec declaration. This then fails, because they are not external libraries, but linked as OBJECT libraries.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1514,2020-10-29T20:47:21Z,2020-10-29T21:14:34Z,2020-11-06T13:16:07Z,MERGED,True,20,20,6,https://github.com/vtraag,CMake: fix compiling and testing static library on MinGW.,1,[],https://github.com/igraph/igraph/pull/1514,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1514,"This fixes compiling and testing a static library on MinGW using CMake. At the moment, the symbols were not properly defined, as they actually still used dllspec declaration style when compiling a static library. Similarly, IGRAPH_STATIC was not properly defined for the tests. After merging this we can definitely close #1495.","This fixes compiling and testing a static library on MinGW using CMake. At the moment, the symbols were not properly defined, as they actually still used dllspec declaration style when compiling a static library. Similarly, IGRAPH_STATIC was not properly defined for the tests. After merging this we can definitely close #1495.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1516,2020-10-31T17:26:07Z,2020-10-31T22:26:58Z,2020-10-31T22:26:58Z,MERGED,True,7,7,1,https://github.com/szhorvat,fix prototypes of fortran intrinsics,1,[],https://github.com/igraph/igraph/pull/1516,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1516,"The prototypes of fortran intrinsics seems to be bad. See how they are actually used from LAPACK:
https://github.com/igraph/igraph/blob/master/src/lapack/dlamch.c#L88
As with all fortran functions, the arguments should be pointers.
I found this while compiling with LTO on Linux.","The prototypes of fortran intrinsics seems to be bad. See how they are actually used from LAPACK:
https://github.com/igraph/igraph/blob/master/src/lapack/dlamch.c#L88
As with all fortran functions, the arguments should be pointers.
I found this while compiling with LTO on Linux.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1516,2020-10-31T17:26:07Z,2020-10-31T22:26:58Z,2020-10-31T22:26:58Z,MERGED,True,7,7,1,https://github.com/szhorvat,fix prototypes of fortran intrinsics,1,[],https://github.com/igraph/igraph/pull/1516,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1516#issuecomment-719963622,"The prototypes of fortran intrinsics seems to be bad. See how they are actually used from LAPACK:
https://github.com/igraph/igraph/blob/master/src/lapack/dlamch.c#L88
As with all fortran functions, the arguments should be pointers.
I found this while compiling with LTO on Linux.","We could also #include ""f2c.h"" and use doublereal and integer instead of double and int.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1517,2020-10-31T17:47:53Z,2020-10-31T22:24:22Z,2020-10-31T22:24:22Z,MERGED,True,6,6,3,https://github.com/szhorvat,"GLPK: replace explicit ""opaque"" structs with extern structs",1,[],https://github.com/igraph/igraph/pull/1517,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1517,"The vendored GLPK uses very dubious structs which don't match their original definition. E.g., compare these:
Original: https://github.com/igraph/igraph/blob/master/optional/glpk/glpbfx.c#L31
Substitute: https://github.com/igraph/igraph/blob/master/optional/glpk/glpbfx.h#L32
In C, it is not actually necessary to have a full declaration of a struct in order to write prototypes of functions that use that struct. Therefore, I removed these substitutes.
The substitutes were causing many warnings when compiling with LTO with gcc on Linux.","The vendored GLPK uses very dubious structs which don't match their original definition. E.g., compare these:
Original: https://github.com/igraph/igraph/blob/master/optional/glpk/glpbfx.c#L31
Substitute: https://github.com/igraph/igraph/blob/master/optional/glpk/glpbfx.h#L32
In C, it is not actually necessary to have a full declaration of a struct in order to write prototypes of functions that use that struct. Therefore, I removed these substitutes.
The substitutes were causing many warnings when compiling with LTO with gcc on Linux.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1518,2020-10-31T21:02:32Z,2020-10-31T21:55:43Z,2020-10-31T21:55:43Z,MERGED,True,1,1,1,https://github.com/vtraag,CPack: incorrect directory for config.h.in,1,[],https://github.com/igraph/igraph/pull/1518,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1518,"There was an incorrect directory listed for config.h.in, which is included in the src directory.","There was an incorrect directory listed for config.h.in, which is included in the src directory.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1519,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1519#issuecomment-720047400,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.",I now realise that we should then also disable the bison and flex dependencies if those files are not included.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1519#issuecomment-720325461,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","This is actually a bit of a catch-22 situation. The dependencies need to be setup before including the subdirectories, but it only becomes clear whether the flex and bison dependencies are need when including the subdirectories. The easiest solution is probably to include the flex and bison dependencies only in the relevant subdirectory (i.e. src). Or do you have any other suggestion @ntamas?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1519#issuecomment-720405937,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","Aren't Flex and Bison declared as optional dependencies at the moment? I think they are, which means that the build will happily commence even if you don't have Flex and/or Bison.
We can probably improve this by moving them from the OPTIONAL_DEPENDENCIES variable to the REQUIRED_DEPENDENCIES variable if we add at least one Flex or Bison target, assuming that we can sort out the visibility problems of the variables, but the current situation is not as bad as it seems. I'm inclined to merge this PR and then experiment with it further in the CMake branch. Any objections?
(I'll merge by the end of the day if there aren't any).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1519#issuecomment-720428384,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","Yes, fine to merge and experiment further! I have thought also about a more general setup, more in the line of the generated_sources approach. However, this seems not straightforward. Right now, the generated sources are in a separate directory (i.e. parsers). Adding arbitrary directories and automatically excluding the meta-source files (i.e. used to generate the source files) is also more difficult because of the way that CMake includes entire directories. It might therefore be better to also keep the current naming, so that is it clear that it concerns the parser sources (although we might call it parser_sources to make it more clear?)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1519#issuecomment-722459150,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","Oh, by the way, one thing that I now realise I didn't get around to anymore is that it would be preferable to simply make dist an ALIAS for package_source. We should then add the dependency to package_source. Right now, the packaging only correctly generates the parser sources if we run cmake --build . --target dist, not if we call cmake --build . --target package_source, which might be a default expectation in some cases.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1519#issuecomment-722677940,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","For some reason we cannot add any dependencies to the package_source target, not even if I add them after calling include(CPack). I think this is because the package_source target is some sort of a ""virtual"" target that gets created only for the makefile and the Ninja generators.
I tried adding it to etc/cmake/cpack_install_script.cmake as an execute_process() command, but now make package_source fails with:
CMake Error at /Users/tamas/dev/igraph/igraph/etc/cmake/cpack_install_script.cmake:22 (file):
  file INSTALL cannot find ""/Users/tamas/dev/igraph/igraph/IGRAPH_VERSION"":
  No such file or directory.

and I have no idea where this is coming from. There's nothing like that in cpack_install_script.cmake near line 22.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1519#issuecomment-722854787,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","Ok, probably better then to simple leave it as is, and clearly document that source packages should be build with dist, not with package_source.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1519#issuecomment-723000025,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.","Okay, in the meanwhile I managed to read the message properly and now I understand :) (I needed to get some sleep). We need to generate the IGRAPH_VERSION file for the tarball.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1519,2020-10-31T22:25:26Z,2020-11-04T07:39:56Z,2020-11-06T13:15:04Z,MERGED,True,12,5,2,https://github.com/vtraag,CMake: create parsers/lexers before packaging.,1,[],https://github.com/igraph/igraph/pull/1519,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1519#issuecomment-723011955,"This PR adds a separate target to build the parser sources, called parsersources. The built parsers (i.e. the .c files) are placed in a separate directory parsers in the src folder in the build tree, and are hence used from there in the build tree. Hence, you can also separately (only) build the parser sources by calling cmake --build . --target parsersources.
Note that the separate parsers folder was necessary to make it easier to include the entire directory.
This PR now also excludes the parser (.y) and lexer (.l) files from the packaged source.
We might think about moving the original parser sources also to a separate parser directory in the original src directory to avoid confusion.",Fixed in 8752ab5,True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1529,2020-11-03T16:12:25Z,2020-11-03T20:01:29Z,2020-11-06T13:15:51Z,MERGED,True,30,59,1,https://github.com/vtraag,CMake: Re-enabled some internal tests.,1,[],https://github.com/igraph/igraph/pull/1529,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1529,"This re-enables some test as discussed previously in #1528. Additionally, it includes some comments for files for which it is less clear why they are marked as ""internal"".","This re-enables some test as discussed previously in #1528. Additionally, it includes some comments for files for which it is less clear why they are marked as ""internal"".",True,{'HOORAY': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1529,2020-11-03T16:12:25Z,2020-11-03T20:01:29Z,2020-11-06T13:15:51Z,MERGED,True,30,59,1,https://github.com/vtraag,CMake: Re-enabled some internal tests.,1,[],https://github.com/igraph/igraph/pull/1529,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1529#issuecomment-721257048,"This re-enables some test as discussed previously in #1528. Additionally, it includes some comments for files for which it is less clear why they are marked as ""internal"".",LGTM. Will merge when the CI checks pass.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1530,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1530#issuecomment-721656428,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","I also addressed warning C4100: unreferenced formal parameter in b55d3ad. Most often I marked this argument as unused, using IGRAPH_UNUSED. However, there were also a number of instances for which the arguments really did seem superfluous. In that case, I did remove the actual argument. Please do check if you are OK with this.
@szhorvat , this also holds for the callback function for cliquer. The graph argument (g) never seems to be used. I left the argument in, because it might be that some callback function in the future would actually use the graph. But perhaps you think this argument actually should be removed?
Edit: there still remain a number of C4100 warnings that occus in bliss and cs, but I don't think we should address those, so we should just silence them I think. If you agree I will add the relevant no-warning flags for bliss and cs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1530#issuecomment-721656808,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","Let me simply consider all warnings in this PR, but you can then already provide feedback on the ones that I did solve.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1530#issuecomment-721657967,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","@tamas, on another note, there seem to be some functions from plfit that would need to be updated for version 0.9. I have now also marked this in the comments with a TODO, but perhaps better to open a separate issue for that, so that we don't loose track?",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1530#issuecomment-721668008,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","I am not very comfortable with the mass-removal of unused arguments. Unused argument is one of those warnings which IMO should be turned off. (Heck, with one of the compilers I used it was IGRAPH_UNUSED itself that was triggering un-disableable warnings!)
I think argument removal should be discussed on a case-by-case basis. Making warnings go away is just not a useful goal. We should be clear about why an argument is or isn't needed now, and why it wouldn't ever be needed. It's also not something that's worth breaking API for.
As an example, take the inclist_remove_duplicates function. There are considerations such as: 1. consistency with the adjlist equivalent 2. the fact that an inclist is meaningless without its graph 3. did past implementations use the graph? if yes, might future ones use it? 4. this function came up when dealing with eigenvector centrality and as I remember, the conclusion was that such functions are not a good solution to deal with duplicate self-loops—instead those should be controlled when calling the inclist/adjlist generator. I.e. this function may be removed soon anyway. Therefore, it's not clear to me that it's a good idea to change it again at this point.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1530#issuecomment-721668220,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","tl;dr Before removing arguments, we should write down the justification (and silencing warnings is a not a good justification).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1530#issuecomment-721670510,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","This PR seems to have broken something in the Appveyor build:

C:\projects\igraph\src\eigen.c(1531): error C2065: 'cmplxvector': undeclared identifier [C:\projects\igraph\build\src\igraph.vcxproj]",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1530#issuecomment-721677638,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","Please let us not be overeager in silencing warnings.
We want a robust and easy to maintain library. That does not equate no warnings for any given compiler.
I also see some of the non-trivial algorithms, such as push-relabel, being touched here. Do we know that there is no useful information in these arguments and their names for human readers? Do we know that it would be easier, and not harder, to make changes to these algorithms in the future with these arguments removed? Maybe they communicate the intention of the original implementor.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1530#issuecomment-721691234,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","This PR seems to have broken something in the Appveyor build:

C:\projects\igraph\src\eigen.c(1531): error C2065: 'cmplxvector': undeclared identifier [C:\projects\igraph\build\src\igraph.vcxproj]


This was an old error (fixed in f5fdb33), but it turned out there was another error that I fixed now in d595d27.

Before removing arguments, we should write down the justification (and silencing warnings is a not a good justification).

OK, that is fine. I went through all the warnings, and added IGRAPH_UNUSED if the argument is not used and removed it in some cases.
I think that it generally makes sense to only include arguments that actually do something, it might otherwise lead to incorrect expectations. In some cases there are good argument for including unused arguments:

they might be used, such as in callback options:
the actual functionality is not yet implemented, but is expected to be in the future.

In other cases I removed unused arguments, unless the code was too complicated to understand correctly. Perhaps it is easier to discuss details in actual comments in the code: feel free to point to specific removal of unused arguments that you would disagree with.

Do we know that there is no useful information in these arguments and their names for human readers? Do we know that it would be easier, and not harder, to make changes to these algorithms in the future with these arguments removed? Maybe they communicate the intention of the original implementor.

I am not sure I understand how the unused argument could communicate some intention, but I'd be happy to discuss it further. The arguments that I removed in flow.c are never actually used, and I don't immediately see what would be communicated there. If you think these arguments should be in place, I would have no problem in putting them back.

Please let us not be overeager in silencing warnings.
We want a robust and easy to maintain library. That does not equate no warnings for any given compiler.

Well, I think it would be helpful if we would have as few warnings as possible. In some circumstances warnings are unavoidable, and we turn them off them when compiling, instead of changing the source code. However, there may be circumstances in which warnings are actually helpful to see that some things may have gone wrong. If these warnings are turned off in the compiler, we will simply not be notified about it, even though it may reveal an actual bug. If possible, I would therefore prefer to address all warnings in as far as that is reasonably possible.
So, all in all, I think having as few warnings as possible helps to reduce (future) maintenance load.
Regarding unused variables, IGRAPH_UNUSED was already included for this specific purpose, and used across the code base, so I think it makes sense to continue doing that (if the unused argument actually makes sense).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1530#issuecomment-721701720,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","It seems I was too quick to judge with flow.c indeed, I now corrected these using IGRAPH_UNUSED in
d8162df. The problem is that the macro's hide a lot of the arguments that are being passed around, so I didn't see clearly that some argument might be used in some places.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1530#issuecomment-721748799,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","I'm afraid my comments may have come through as a bit too harsh.  Let me try to rephrase the concern from a different perspective:
A lot is changed here, and I freaked out a bit, because I cannot immediately judge if there may be negative effects. It's too overwhelming.
I would like to ask to discuss each change individually (even if extremely briefly, in just one sentence), for the sake of making the changes (and their effects / benefits / risks) more transparent for all who are involved. I won't have time for this today, but I'll try to take them one by one and write comments here noting when I'm happy with then, or raising specific concerns when not.
Maybe it would have been better to keep these 'unused-fix' changes in a separate PR from the other, more straightforward and more clearly necessary fixes (e.g. the rint one).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1530,2020-11-04T08:41:15Z,2020-11-04T14:27:49Z,2020-11-06T13:15:25Z,CLOSED,False,82,27,19,https://github.com/vtraag,CMake: MSVC warnings,6,[],https://github.com/igraph/igraph/pull/1530,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1530#issuecomment-721763436,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","I'm afraid my comments may have come through as a bit too harsh.

No worries! It didn't come off as too harsh...

Maybe it would have been better to keep these 'unused-fix' changes in a separate PR from the other, more straightforward and more clearly necessary fixes (e.g. the rint one).

Yes, maybe you are right, I created PR #1531 and #1532 to separate the issues. I now close this PR, we can then continue the discussion there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1531,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1531#issuecomment-721865366,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","@ntamas Looking at this makes me realize that there are a lot more #ifndef HAVE_XXX in the source code, e.g.
./src/igraph_math.h:#ifndef HAVE_LOG2
./src/igraph_math.h:#ifndef HAVE_LOG1P
./src/igraph_math.h:#ifndef HAVE_FABSL
./src/igraph_math.h:#ifndef HAVE_FMIN
./src/igraph_math.h:#ifndef HAVE_ROUND

These are just a few of the examples. I was grepping the sources for HAVE_
These aren't created by cmake though, as far as I can tell.
Shouldn't we either get rid of these (if not needed) or make sure that cmake defines them as appropriate? Is there any other way that they might get defined that I am missing?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1531#issuecomment-721911468,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","I don't think these are automatically defined elsewhere. I think it would be useful to leave them in, in case there is a compiler that doesn't support these functions. I think that with recent MSVC version these are supported. We should just include some additional check_function_exists for these functions. Additionally, there is some stuff around infinity in math.c that we might want to take a closer look at.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1531#issuecomment-721915092,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","@vtraag is right, all that we need is a bunch of check_function_exists() or check_symbol_exists() calls in the top-level CMakeLists.txt and an adjustment of src/config.h.in so CMake knows to export these variables into config.h. I vote for keeping these and adding the necessary checks in CMakeLists.txt.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1531#issuecomment-721919083,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","@vtraag Regarding erf, erfc and ungetc -- I would vote for patching f2c such that it does not erroneously try to override the existing declaration from math.h or stdio.h.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1531#issuecomment-721924713,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","Added HAVE_ macros for a few of the functions that @szhorvat has found, FYI.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1531,2020-11-04T14:24:54Z,2020-11-04T19:13:51Z,2020-11-04T21:36:20Z,MERGED,True,4,0,2,https://github.com/vtraag,CMake: MSVC warning C4273: inconsistent DLL linkage,1,[],https://github.com/igraph/igraph/pull/1531,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1531#issuecomment-721988218,"Regarding warning C4273: inconsistent dll linkage in #1507, the problem is that these functions are defined multiple times. Most often these occur in f2c, but also once in random.c. For random.c there is already a solution, we simply detect whether rint and rintf already exist. This PR corrects that.
For f2c the situation is slightly more complicated. The relevant functions (erf, erfc and ungetc) are defined in the MSVC libraries (cmath). Of course, it is defined there with a (correct) declspec declaration, while in f2c it is not defined as such (only with extern). There are multiple possible solutions: (a) simply remove the relevant definitions (of erf, erfc and ungetc) completely; or (b) add the correct declspec declarations. What option do you think would be better? Or are there perhaps other options still?
`","Yes, that was what I meant: need more check_function_exists()",True,{}
igraph/igraph,https://github.com/igraph/igraph,1532,2020-11-04T14:24:57Z,2020-11-10T14:00:33Z,2022-04-03T08:27:22Z,MERGED,True,78,27,18,https://github.com/vtraag,CMake: MSVC warning C4100: unreferenced formal parameter,5,[],https://github.com/igraph/igraph/pull/1532,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1532,"This PR addresses warning C4100: unreferenced formal parameter mentioned in #1507. Most often I marked this argument as unused, using IGRAPH_UNUSED. However, there were also a number of instances for which the arguments really did seem superfluous. In that case, I did remove the actual argument. Please do check if you are OK with this.
There still remain a number of C4100 warnings that occus in bliss and cs, but I don't think we should address those, so we should just silence them I think. If you agree I will add the relevant no-warning flags for bliss and cs.","This PR addresses warning C4100: unreferenced formal parameter mentioned in #1507. Most often I marked this argument as unused, using IGRAPH_UNUSED. However, there were also a number of instances for which the arguments really did seem superfluous. In that case, I did remove the actual argument. Please do check if you are OK with this.
There still remain a number of C4100 warnings that occus in bliss and cs, but I don't think we should address those, so we should just silence them I think. If you agree I will add the relevant no-warning flags for bliss and cs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1532,2020-11-04T14:24:57Z,2020-11-10T14:00:33Z,2022-04-03T08:27:22Z,MERGED,True,78,27,18,https://github.com/vtraag,CMake: MSVC warning C4100: unreferenced formal parameter,5,[],https://github.com/igraph/igraph/pull/1532,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1532#issuecomment-723167388,"This PR addresses warning C4100: unreferenced formal parameter mentioned in #1507. Most often I marked this argument as unused, using IGRAPH_UNUSED. However, there were also a number of instances for which the arguments really did seem superfluous. In that case, I did remove the actual argument. Please do check if you are OK with this.
There still remain a number of C4100 warnings that occus in bliss and cs, but I don't think we should address those, so we should just silence them I think. If you agree I will add the relevant no-warning flags for bliss and cs.","That's all, no more comments from me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1532,2020-11-04T14:24:57Z,2020-11-10T14:00:33Z,2022-04-03T08:27:22Z,MERGED,True,78,27,18,https://github.com/vtraag,CMake: MSVC warning C4100: unreferenced formal parameter,5,[],https://github.com/igraph/igraph/pull/1532,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1532#issuecomment-724688149,"This PR addresses warning C4100: unreferenced formal parameter mentioned in #1507. Most often I marked this argument as unused, using IGRAPH_UNUSED. However, there were also a number of instances for which the arguments really did seem superfluous. In that case, I did remove the actual argument. Please do check if you are OK with this.
There still remain a number of C4100 warnings that occus in bliss and cs, but I don't think we should address those, so we should just silence them I think. If you agree I will add the relevant no-warning flags for bliss and cs.",As far as I am concerned we can (squash and) merge this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1536,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1536#issuecomment-723237886,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","Yes, I don't really understand why these functions are defined there. To me it seems completely superfluous. But then again, there might be a reason for it. Perhaps to ensure it at least compiles, even if the implementation of those functions are not available?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1536#issuecomment-723275299,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","@vtraag Could you please try the following? Instead of these changes, simply add the expected headers:

#include <math.h> in erf_.c, derf_.c,  erfc_.c and derfc_.c

Add it right after #include ""f2c.""
Then remove all the declarations for the C functions, both the K&R and the modern ones.
Can you please try this and let me know if it fixes the problem?
In the meantime I'll look at what's going on with ungetc(), as that should have been declared already in stdio.h, which is included ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1536#issuecomment-723275509,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","Perhaps to ensure it at least compiles, even if the implementation of those functions are not available?

It will compile, but it will not link.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1536#issuecomment-723277437,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","If this solves it, we still could test for these functions with cmake and let it abort if it didn't find them, but it would only make sense to do it if f2c is compiled at all (it's needed by the internal arpack, lapack, blas). It's a bit annoying to have to fuss with this because these functions in f2c are not actually called by any of arpack, lapack, blas ... in principle we could even just remove them, though that would leave us with a partial f2c, which is strange.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1536#issuecomment-723350084,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","Adding the headers won't solve the issue. The problem is that they are defined with different attributes, once without declspec (in the f2c sources) and once with declspec ( in math). The solution is hence to simply remove the declarations if the functions are already properly defined, which is exactly what is tested for at the moment. This is also the problem with unget.c.
We could also simply remove the declarations all together, but in that case it won't compile if the function is missing. I am not too familiar with the details going on inside the linking step, but perhaps in situation in which this function is not defined (i.e. extern) and not invoked anywhere, the linking might still work?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1536#issuecomment-723351989,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","It makes no sense to remove these declarations conditionally. Declarations indicate that the function exists. If it does not exist, there will be a linking error.
<math.h> should be included (currently it is not, unless I missed a nested include), and there should not be any additional declarations.
Does doing this not resolve the problem?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1536#issuecomment-723414278,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","I have not checked if/how/where math.h is included. It should be somehow, otherwise it shouldn't even compile in the current PR, right? The warning arises exactly because the function is declared twice. I'm happy to include math.c explicitly as well, but I won't get around to it this weekend.
The check_function_exists checks if the function can be linked by the way, not whether it is declared, according to the CMake documentation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1536#issuecomment-723900146,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","Removing the declarations does work (obviously). As clarified, I can either add or not the #include <math.h>, that does not make a difference. This begs the question how exactly these functions (i.e. erf and friends) are included. I still haven't figured that out yet, but I want to ask a related question.
Many other f2c source files use #include ""math.h"" suggesting there is some local header file that is used. I don't see such an include file immediately, except for math.hvc, which does use #include <math.h> and undefines complex immediately afterwards. This file does seem to be used in the old autotools build system in some way (being copied to math.h effectively). As stated in math.hvc, it says for VC 4.2, presumably referring to Visual C. Additionally, in these files, abs is undefined before including math.h, perhaps in some cases this function is both included in the C library and the specific math library? At the moment, we don't use something like this in CMake. @ntamas, have you ever taken a look at this particular setup for the CMake build? It is not entirely clear to me whether the source files in f2c are generated in some way, and if so how.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1536#issuecomment-723957684,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","As far as I know the only source file that is generated for f2c is a file named arithchk.h.

@ntamas, have you ever taken a look at this particular setup for the CMake build?

No, but I strongly suspect it's some legacy stuff; there are similar issues floating around from year 2008 on the Internet. VC 4.2 is something that I don't think we should support anyway, so feel free to drop the extra math.hvc.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1536#issuecomment-723958586,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","Regarding HAVE_ERF et al in this PR, I think that our goal is to check whether there already exists a declaration for said function, so we should probably use CheckSymbolExists - this looks for a declaration in a specific include file. We could also rename HAVE_ERF to HAVE_ERF_DECLARATION to make the intent clear.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1536#issuecomment-724047698,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","This seems to simply be a case of non-matching declspec between the declarations of erf()/ercf() that f2c comes with, and what they actually are in MSVC.
All that seems to be needed is not to rely on the declarations that come with f2c and include math.h properly.
When f2c was written, erf was not a standard C function. Now it is.  Notice this in the f2c README:
Both ERF and DERF assume your C library provides the
	underlying erf() function (which not all systems do).

With the way f2c was written in the dark ages, your system either had erf and things worked, or it didn't, in which case you were still free to link in your own implementation without needing to change any of f2c's own sources. The generic declaration was there.

To fix the problem here, derf_.c should look like this:
#include ""f2c.h""
#include ""math.h""

#ifdef __cplusplus
extern ""C"" {
#endif

#ifdef KR_headers
double derf_(x) doublereal *x;
#else
double derf_(doublereal *x)
#endif
{
return( erf(*x) );
}
#ifdef __cplusplus
}
#endif

There do not need to be any checks done with cmake.
Either the user's system has erf (which is practically always the case given that it is required by C99, a 20+ yr old standard, and it was often present even before than), and things work, or it doesn't, in which case there will be a linking error. There will not be an error from using the function without a declaration, as that is not an error in C. Nothing will change compared to the current situation except MSVC won't show warnings.

If we want to be extra nice in how errors are shown, cmake could check if the function is present, and simply abort if it is not. Then basically the same error that the linker would report at the end of compilation would get reported early, during the configuration step. To do this right, it must only abort when actually compiling the internal f2c, and not otherwise. In my opinion, adding these details to an already complicated build system is pointless. igraph doesn't even use erf, or any function that indirectly uses erf. It'll just add 2-3 seconds to an already painfully slow configuration step on Windows.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,13,https://github.com/igraph/igraph/pull/1536#issuecomment-724715107,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","I have been trying to understand why not using #include <math.h> does not end up in a compiler error/warning about a missing declaration. When using a simple test file
#include <stdio.h>

int main()
{
    printf(""Erf: %.2f\n"", erf(1.96));
}

I get, as expected, the following error: warning C4013: 'erf' undefined; assuming extern returning int. Again, as expected, when properly including math.h, this warning goes away. I have no idea why not including math.h in erf_.c and friends does not show this warning.
I gave up trying to understand this further, and simply include math.h, just to be sure. I also removed the check_function_exists calls and corresponding definitions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1536#issuecomment-724718706,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",That is actually an important point. I do recall seeing several C4013 warnings. You showed several examples of this warning in this issue: #1507 (comment) We should indeed try to understand why it doesn't happen here ...,True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1536#issuecomment-724725994,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","OK, I just found out. We include f2c.h, which includes igraph_blas_internal.h, which includes igraph_types.h, which finally includes math.h (and stdio.h for ungetc). I found out using this command cl /c /P /d1PP [src.c] (with relevant src.c obviously) as suggested here: https://stackoverflow.com/questions/15951728/how-to-find-issues-concerning-includes-visualize-inclusion-tree.
This suggest that we can leave out math.h and stdio.h in the inclusion in the relevant files. If you agree with this, I will do so.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1536#issuecomment-724727252,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","Yes, wanted to post the same :-)  I didn't know this convenient command though. I used an IDE to explore.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1536#issuecomment-724728094,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",I would still suggest including math.h and stdio.h explicitly where they belong. It is not good practice to rely on too many nested includes. igraph_blas_internal.h could change in the future and end up not including math.h. The person changing igraph_blas_internal.h  (likely using some sort of Unix) won't even notice that they're bringing this issue back on Windows.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,18,https://github.com/igraph/igraph/pull/1536#issuecomment-724728339,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",It would still be nice to get a nice visual overview of the entire include hierarchy. I have not managed to get something like that yet.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,19,https://github.com/igraph/igraph/pull/1536#issuecomment-724728837,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.","I would still suggest including math.h and stdio.h explicitly where they belong. It is not good practice to rely on too many nested includes. igraph_blas_internal.h could change in the future and end up not including math.h.

Yes, good point.  I will add the inclusion for stdio.h for ungetc then still.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/vtraag,20,https://github.com/igraph/igraph/pull/1536#issuecomment-724965165,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",Note that the failing build was due to the problem that was solved by PR #1545.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1536#issuecomment-724970739,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",Is this ready to merge then?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1536,2020-11-06T16:12:56Z,2020-11-10T21:41:04Z,2020-11-10T22:01:10Z,MERGED,True,10,17,6,https://github.com/vtraag,CMake: Fix incorrect DLL linkage of some functions in f2c,4,[],https://github.com/igraph/igraph/pull/1536,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1536#issuecomment-724973218,"As suggested here #1531 (comment), we might patch f2c to make sure that functions are correctly linked. This PR does so. This is done for the erf, the erfc and the ungetc function.",I'm happy with this one (noting it because I complained the most).,True,{'LAUGH': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1540,2020-11-09T13:32:50Z,2020-11-09T18:43:37Z,2020-11-09T18:43:44Z,MERGED,True,59,8,1,https://github.com/szhorvat,igraph_diameter: add special case for null graph,1,[],https://github.com/igraph/igraph/pull/1540,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1540,Fixes #1538,Fixes #1538,True,{}
igraph/igraph,https://github.com/igraph/igraph,1540,2020-11-09T13:32:50Z,2020-11-09T18:43:37Z,2020-11-09T18:43:44Z,MERGED,True,59,8,1,https://github.com/szhorvat,igraph_diameter: add special case for null graph,1,[],https://github.com/igraph/igraph/pull/1540,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1540#issuecomment-724202257,Fixes #1538,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1544,2020-11-10T14:45:24Z,2020-11-10T20:08:43Z,2020-11-10T20:08:44Z,MERGED,True,4,2,1,https://github.com/vtraag,Correct Release compilation of test on MSVC,1,[],https://github.com/igraph/igraph/pull/1544,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1544,"This PR fixes #1543. I am not 100% sure what the problem was, possibly the problem was that the compiler was trying to optimise something with that conditional operator. At any rate, this does not change anything substantively, but does compile correctly also under the Release configuration.","This PR fixes #1543. I am not 100% sure what the problem was, possibly the problem was that the compiler was trying to optimise something with that conditional operator. At any rate, this does not change anything substantively, but does compile correctly also under the Release configuration.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1545,2020-11-10T16:27:32Z,2020-11-10T20:08:34Z,2020-11-10T21:02:01Z,MERGED,True,2,5,1,https://github.com/vtraag,Correct layout_mds test,1,[],https://github.com/igraph/igraph/pull/1545,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1545,"Apparently, I missed that igraph_layout_mds was used in a test, and did not correct the test when removing arguments in PR #1532. This PR corrects that.","Apparently, I missed that igraph_layout_mds was used in a test, and did not correct the test when removing arguments in PR #1532. This PR corrects that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1545,2020-11-10T16:27:32Z,2020-11-10T20:08:34Z,2020-11-10T21:02:01Z,MERGED,True,2,5,1,https://github.com/vtraag,Correct layout_mds test,1,[],https://github.com/igraph/igraph/pull/1545,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1545#issuecomment-724815207,"Apparently, I missed that igraph_layout_mds was used in a test, and did not correct the test when removing arguments in PR #1532. This PR corrects that.","Sorry, I jsut did it with a direct commit one min ago before I saw your PR ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1545,2020-11-10T16:27:32Z,2020-11-10T20:08:34Z,2020-11-10T21:02:01Z,MERGED,True,2,5,1,https://github.com/vtraag,Correct layout_mds test,1,[],https://github.com/igraph/igraph/pull/1545,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1545#issuecomment-724815517,"Apparently, I missed that igraph_layout_mds was used in a test, and did not correct the test when removing arguments in PR #1532. This PR corrects that.","And I did it wrong, which shows I shouldn't have ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1545,2020-11-10T16:27:32Z,2020-11-10T20:08:34Z,2020-11-10T21:02:01Z,MERGED,True,2,5,1,https://github.com/vtraag,Correct layout_mds test,1,[],https://github.com/igraph/igraph/pull/1545,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1545#issuecomment-724840988,"Apparently, I missed that igraph_layout_mds was used in a test, and did not correct the test when removing arguments in PR #1532. This PR corrects that.",No problem...,True,{}
igraph/igraph,https://github.com/igraph/igraph,1546,2020-11-10T20:56:53Z,2020-11-11T11:02:10Z,2020-11-11T11:02:10Z,MERGED,True,19,1,4,https://github.com/szhorvat,cmake: disable uninteresting MSVC warnings,1,[],https://github.com/igraph/igraph/pull/1546,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1546,This disables some uninteresting warnings from MSVC. See #1507,This disables some uninteresting warnings from MSVC. See #1507,True,{}
igraph/igraph,https://github.com/igraph/igraph,1546,2020-11-10T20:56:53Z,2020-11-11T11:02:10Z,2020-11-11T11:02:10Z,MERGED,True,19,1,4,https://github.com/szhorvat,cmake: disable uninteresting MSVC warnings,1,[],https://github.com/igraph/igraph/pull/1546,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1546#issuecomment-724965198,This disables some uninteresting warnings from MSVC. See #1507,"The MSVC output should hopefully be less chaotic, see here when build has finished: https://ci.appveyor.com/project/ntamas/igraph/builds/36240321",True,{}
igraph/igraph,https://github.com/igraph/igraph,1546,2020-11-10T20:56:53Z,2020-11-11T11:02:10Z,2020-11-11T11:02:10Z,MERGED,True,19,1,4,https://github.com/szhorvat,cmake: disable uninteresting MSVC warnings,1,[],https://github.com/igraph/igraph/pull/1546,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1546#issuecomment-724971085,This disables some uninteresting warnings from MSVC. See #1507,"Sorry, I didn't get around to replying to your comment #1507 (comment) anymore. I'm perfectly fine with the (silence) warning flags that you put in here now.
I do want to raise the point that I think we should address error warning C4456: declaration of variable hides previous local declaration. This can point out potential issues with new code, and I therefore think that it would be nice if we can enable this warning again.
Finally, after we have silenced/fixed all warning, we should then enable error on warnings (/WX). That way, any new contributions get verified well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1546,2020-11-10T20:56:53Z,2020-11-11T11:02:10Z,2020-11-11T11:02:10Z,MERGED,True,19,1,4,https://github.com/szhorvat,cmake: disable uninteresting MSVC warnings,1,[],https://github.com/igraph/igraph/pull/1546,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1546#issuecomment-725301154,This disables some uninteresting warnings from MSVC. See #1507,"The MSVC build output looks much better now.
How about this: we address the warnings that we think need to be addressed, based on the current CI output, and push changes to this branch until we get close to zero warnings. Then we re-enable C4456 as proposed by @vtraag, do another iteration until we are happy with the output, and then merge this PR. Basically this PR would be the clean-up-the-warnings-in-MSVC branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1546,2020-11-10T20:56:53Z,2020-11-11T11:02:10Z,2020-11-11T11:02:10Z,MERGED,True,19,1,4,https://github.com/szhorvat,cmake: disable uninteresting MSVC warnings,1,[],https://github.com/igraph/igraph/pull/1546,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1546#issuecomment-725324601,This disables some uninteresting warnings from MSVC. See #1507,"It might be better to merge this PR first and open separate PRs for separate warnings. The previous issues were also addressed in separate PRs as well (#1531, #1532, #1536), which might be needed, as we first discussed in PR #1530.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1546,2020-11-10T20:56:53Z,2020-11-11T11:02:10Z,2020-11-11T11:02:10Z,MERGED,True,19,1,4,https://github.com/szhorvat,cmake: disable uninteresting MSVC warnings,1,[],https://github.com/igraph/igraph/pull/1546,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1546#issuecomment-725357437,This disables some uninteresting warnings from MSVC. See #1507,"Okay, let's merge and continue in separate PRs.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1548,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.","This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1548#issuecomment-732004644,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.","Initially I was a bit uneasy with this PR so let me describe how I understand the purpose of this PR to put my mind at ease.
Right now we have a few places in the codebase where we provide different implementations for R and non-R environments because we are not allowed to use abort() in the R code. This is one of the reasons why we have the USING_R macro at all (the other one is to avoid printf() when compiling the R interface). This PR essentially centalizes the use of abort() to the fatal error handler, and then in the R interface we only need to replace the fatal error handler with a call to R's error() instead.
The reason why I was worried about this PR a bit in the beginning is that the Python C API has no function similar to R's error() so I would either have to use abort() there or re-write lots of hand-written interface functions to set up the stage for longjmp() with setjmp() before diving down into the C layer. However, it looks like I wouldn't really ""lose"" anything with just having abort() in the code of the Python interface because they are already there now. So it seems fine for me as it is now.
The new doc chunks still have to be inserted into the documentation, though. I also vaguely remember that we have a guide somewhere in the wiki about integrating third-party code with igraph; we should make a note of replacing abort() calls with fatal errors there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1548#issuecomment-732013134,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.","Yes, your understanding is correct.
But it is not only about R. There is a good reason why they forbid abort() (and also assert) in R packages: if something goes wrong, ideally it should not take the whole session down with it. The same applies to all other high-level interfaces.
I think I can make use of this in the Mathematica interface as well (through setjmp/longjmp), although I have not implemented yet. I will implement it before making this PR ready, just to see that it works.
In summary, some errors cannot be handled gracefully, and at this moment they result in aborting the entire process. This PR will make it possible for high-level interfaces to at least avoid an abort/crash, and let the user save their work. The error still won't be handled very nicely: memory won't be freed, resources won't be cleaned up, and in the worst case, it might even leave a graph in a broken internal state. But at least we didn't crash the session!  We might even choose to give the user a severe warning, like MATLAB does, although in the case of igraph such an error is unlikely to compromise the process.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1548#issuecomment-732013524,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.","One additional type of error where this is useful is an assertion failure. With asserts, we don't want full error handling (""finally"" stack) because assertions should never fail. If they do, it's a bug. But of course there are bugs in igraph. When they are triggered, it is best to show some informative message to the user rather than just segfault, or much worse: silently return wrong results. This is why I am strongly in favour of leaving in asserts. However, with the Mathematica interface, when an assert is triggered, the user won't see the message because it is printed to a terminal, not the notebook. Maybe it's the same with Jupyter notebooks? I don't know. This feature would not only make it possible to not crash the session, but it will also let the message be output in whatever way is most appropriate (e.g. print to the notebook with Mathematica).
Thus, this PR would also transition all asserts to IGRAPH_ASSERTs. I need feedback on this too before I do it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1548#issuecomment-732730247,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.",@szhorvat fixed a minor copy-paste error above. I see no problems with the IGRAPH_ASSERT() implementation. Feel free to go ahead.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1548#issuecomment-734367500,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.","I think it would make sense to clear the ""finally stack"" in a fatal error handler. But this should probably be left for the handler function to do instead of doing it automatically, the same way as calling IGRAPH_FINALLY_FREE() is left to the error handler.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1548#issuecomment-734810920,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.","The reason why I was worried about this PR a bit in the beginning is that the Python C API has no function similar to R's error() so I would either have to use abort() there or re-write lots of hand-written interface functions to set up the stage for longjmp() with setjmp() before diving down into the C layer. However, it looks like I wouldn't really ""lose"" anything with just having abort() in the code of the Python interface because they are already there now. So it seems fine for me as it is now.

It would even be okay to not set up a fatal error handler in Python. Then the system will use the default, which aborts.
The fatal error handler would only be called in situation where in the past we simply aborted anyway.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1548,2020-11-21T15:03:37Z,2020-11-27T14:15:49Z,2020-11-27T21:08:43Z,MERGED,True,270,53,6,https://github.com/szhorvat,Implement fatal error handling,8,[],https://github.com/igraph/igraph/pull/1548,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1548#issuecomment-734838062,"This PR adds fatal error handling, as well as igraph-specific assertions.
When a fatal error occurs, we don't do any cleanup, just bail immediately. This is necessary in some libraries where it would be difficult to integrate igraph's own error handler.
This can also be used for assertions that we do not want to be disabled by NDEBUG. Some asserts don't hurt performance, and the messages they print can be very useful to debug user problems. Also, when an assert macro is done properly, the compiler can be aware that is never returns, and can optimize the code much better. Thus, the idea that assertions should simply be removed for better performance is flawed.
A fatal error handler is expected to never return. Reasonable options are to abort() or to do a longjmp. The R interface would use the error() function provided by R, which simply returns to the R top level after printing a message. See the modification I made in the Cliquer sources—originally, R's error() was used.
This is still a draft, awaiting feedback before I go further.",This should be ready now (and should be squashed-and-merged). I'll leave replacing some asserts with IGRAPH_ASSERTs for a second PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1549,2020-11-22T10:38:53Z,2020-11-22T20:30:02Z,2020-12-03T19:06:37Z,MERGED,True,4923,25,13,https://github.com/szhorvat,Use Mini-GMP when GMP is not available,2,[],https://github.com/igraph/igraph/pull/1549,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1549,"Mini-GMP is a tiny partial implementation of the GMP API. It is meant to be included in projects directly. See mini-gmp/README within the GMP distribution.
Fixes #1351.","Mini-GMP is a tiny partial implementation of the GMP API. It is meant to be included in projects directly. See mini-gmp/README within the GMP distribution.
Fixes #1351.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1549,2020-11-22T10:38:53Z,2020-11-22T20:30:02Z,2020-12-03T19:06:37Z,MERGED,True,4923,25,13,https://github.com/szhorvat,Use Mini-GMP when GMP is not available,2,[],https://github.com/igraph/igraph/pull/1549,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1549#issuecomment-731842407,"Mini-GMP is a tiny partial implementation of the GMP API. It is meant to be included in projects directly. See mini-gmp/README within the GMP distribution.
Fixes #1351.",This seems okay for me; there's only one minor comment about the missing license header in src/igraph_gmp.h.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1549,2020-11-22T10:38:53Z,2020-11-22T20:30:02Z,2020-12-03T19:06:37Z,MERGED,True,4923,25,13,https://github.com/szhorvat,Use Mini-GMP when GMP is not available,2,[],https://github.com/igraph/igraph/pull/1549,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1549#issuecomment-731842433,"Mini-GMP is a tiny partial implementation of the GMP API. It is meant to be included in projects directly. See mini-gmp/README within the GMP distribution.
Fixes #1351.","Okay, I'll just merge and then add the license :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1549,2020-11-22T10:38:53Z,2020-11-22T20:30:02Z,2020-12-03T19:06:37Z,MERGED,True,4923,25,13,https://github.com/szhorvat,Use Mini-GMP when GMP is not available,2,[],https://github.com/igraph/igraph/pull/1549,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1549#issuecomment-731843193,"Mini-GMP is a tiny partial implementation of the GMP API. It is meant to be included in projects directly. See mini-gmp/README within the GMP distribution.
Fixes #1351.","So you're fine with calling it ""vendored GMP"" in the CMake files? It's of course convenient.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1549,2020-11-22T10:38:53Z,2020-11-22T20:30:02Z,2020-12-03T19:06:37Z,MERGED,True,4923,25,13,https://github.com/szhorvat,Use Mini-GMP when GMP is not available,2,[],https://github.com/igraph/igraph/pull/1549,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1549#issuecomment-731843523,"Mini-GMP is a tiny partial implementation of the GMP API. It is meant to be included in projects directly. See mini-gmp/README within the GMP distribution.
Fixes #1351.","Yes, it would be too much hassle to re-write the CMake files to have another category (almost-vendored-but-simplified :)) just for the sake of GMP. If it becomes too confusing for users, we can reconsider.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1554,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1554#issuecomment-734812358,,"@jannick0 You say in the commit message that _WIN32 and __CYGWIN__ are mutually exclusive. Do you know if this has always been so, i.e. if Cygwin has never defined _WIN32 (of course unless targeting Win32)?
This SO question suggests that Cygwin used to define _WIN32. This is why I left in an explicit check for it. However, we might just forget about old Cygwin to keep things simpler.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/jannick0,3,https://github.com/igraph/igraph/pull/1554#issuecomment-735425690,,"@jannick0 You say in the commit message that _WIN32 and __CYGWIN__ are mutually exclusive. Do you know if this has always been so, i.e. if Cygwin has never defined _WIN32 (of course unless targeting Win32)?

Unfortunately, I do not know. However, I had checked it for the latest gcc version for CYGWIN (gcc version 10.2.0), MSYS2 (gcc version 10.2.0) and MSYS (gcc version 3.4.4 from 2005).  The latter suggests that the mutual exclusivity must be in for 15 years already I guess.

This SO question suggests that Cygwin used to define _WIN32. This is why I left in an explicit check for it. However, we might just forget about old Cygwin to keep things simpler.

Yes - I agree. As given in the commit log, all this boils down to MSVC I believe, doesn't it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1554#issuecomment-735446983,,"As given in the commit log, all this boils down to MSVC I believe, doesn't it?

We'd like to make the decldir thing work with MinGW as well for version 0.9, but for 0.8, maybe the best solution is to just switch it off. We don't want to make big changes to 0.8 (in case we hoped that 0.8.4 would be the last 0.8.x release)

However, I had checked it for the latest gcc version for CYGWIN (gcc version 10.2.0), MSYS2 (gcc version 10.2.0) and MSYS (gcc version 3.4.4 from 2005). The latter suggests that the mutual exclusivity must be in for 15 years already I guess.

Thanks for this! I'll just remove the reference to Cygwin then. Cygwin is free, so there's no good reason not to use a version more recent than 2005 :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1554#issuecomment-737264020,,"I'm trying to wrap my head around the thread here (without much experience in the intricacies of development on/for Windows). What's the conclusion then? Shall we remove the #if defined (__CYGWIN__) check as suggested by @szhorvat, or shall we replace it with #if defined (__GNUC__) as proposed in the original PR?
If I understand correctly, the CI runs that were recently added using Github workflows is based on MINGW32/64 using a non-Cygwin-style compiler, so the problem is that we are hitting the part of the #if defined(_WIN32) branch and start adding __declspec() directives in the headers. The same __declspec() modifiers are not present in the actual source files, and the non-Cygwin compiler complains about that. I don't understand the reason, though; this answer on SO claims that the __declspec() directives can be omitted if the declarations are identical (and they seem to be). It seems like the compiler in MINGW32/64 insists on repeating the __declspec() declarations. On the other hand, @jannick0 suggests that these declarations are not needed at all for the non-Cygwin compiler in MINGW32/64 and the PR aims to fix that by narrowing things down to non-GNU compilers only. Am I correct?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1554#issuecomment-737282038,,"There are two cases:


develop branch, Cmake: here everything works fine at the moment. We can use decldir without problems both with MSVC and MinGW.


master branch, autotools: Making the decldir stuff work fine with autotools seems to be a bit of a challenge, so we might want to just drop it at least for MinGW. Someone needs to test if if actually works fine with MSVC or not, and based on that decide what to do exactly.  @vtraag said in chat that in order to drop decldir safely, we need to add some new compiler options for MinGW. @vtraag Can you explain the details?


We will probably end up with different DECLDIR definitions on the master and develop branches, and will need to be careful when merging master into develop.
As for CygWin, I'll remove any reference to it. It seems that all non-ancient versions of CygWin will present themselves as proper Unix, so we don't need to special case them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/jannick0,7,https://github.com/igraph/igraph/pull/1554#issuecomment-737290139,,"MINGW is GNUC which does not need any DECLDIR, while on Windows it is needed by MSVC (please note that any requirements MSDN suggests to be Windows specific does not neccessarily extend to all Windows compilers). Any other systems which need dllimport/dllexport?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1554#issuecomment-737295073,,"Not exporting symbols which are not meant to be public seems like generally a good idea. Though not standard on other platforms, it is possible.
Given that everything works perfectly on the develop branch, and we have the additional safety provided by not exporting non-public symbols (and risking a conflict), is there any reason not to keep DECLDIR as it is on develop?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1554#issuecomment-737328525,,"OK — on the master branch I changed DECLDIR to be active only #ifdef _MSV_VER. On develop it is as before, and it works with MinGW. In both cases, I removed any references to CygWin.
Hopefully this will work.
Compilation with MSVC succeeds on the master branch even when building a DLL. Compilation with MinGW also seems to work. @vtraag was referring to this MinGW doc page which mentions that certain linking options are necessary. But things appear to work without them. Maybe they are not necessary for MinGW-w64?
If there are any concerns about this solution, please let me know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1554#issuecomment-737369288,,LGTM. I have also merged the XML2_CFLAGS related change. Thanks a lot for everyone!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1554,2020-11-25T18:08:45Z,2020-12-02T17:10:54Z,2020-12-03T09:50:58Z,MERGED,True,2,0,1,https://github.com/jannick0,V0.8.4: MINGW32/64 fixes,4,[],https://github.com/igraph/igraph/pull/1554,https://github.com/jannick0,11,https://github.com/igraph/igraph/pull/1554#issuecomment-737802289,,"If there are any concerns about this solution, please let me know.

In case there are are any complaints #if defined _WIN32 && ! defined __GNUC__ instead of  #ifdef _MSC_VER could help (see here, explanation and bottom of section). Logically equivalent to my suggestion which I drafted with the goal of minimal changes.  But I cannot see any real concern.
Many thanks to you guys!",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1557,2020-11-28T20:30:57Z,2020-12-13T15:41:01Z,2020-12-13T15:41:01Z,CLOSED,False,312,1,6,https://github.com/szhorvat,Add a function to check potential connectedness,3,[],https://github.com/igraph/igraph/pull/1557,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1557,"This PR adds a function to check potential connectedness of a degree sequence.
Which name do you prefer? igraph_is_potentially_connected or igraph_is_potentially_connected_degree_sequence?
This PR should be merged as normal, not squash-and-merged.","This PR adds a function to check potential connectedness of a degree sequence.
Which name do you prefer? igraph_is_potentially_connected or igraph_is_potentially_connected_degree_sequence?
This PR should be merged as normal, not squash-and-merged.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1557,2020-11-28T20:30:57Z,2020-12-13T15:41:01Z,2020-12-13T15:41:01Z,CLOSED,False,312,1,6,https://github.com/szhorvat,Add a function to check potential connectedness,3,[],https://github.com/igraph/igraph/pull/1557,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1557#issuecomment-735287982,"This PR adds a function to check potential connectedness of a degree sequence.
Which name do you prefer? igraph_is_potentially_connected or igraph_is_potentially_connected_degree_sequence?
This PR should be merged as normal, not squash-and-merged.","How about igraph_is_degree_sequence_potentially_connected? Not sure which one is better, this one seems more natural to me, but YMMV. I am okay with the other proposals as well.
igraph_is_potentially_connected_degree_sequence() is the way to go; it is consistent with igraph_is_graphical_degree_sequence().",True,{}
igraph/igraph,https://github.com/igraph/igraph,1557,2020-11-28T20:30:57Z,2020-12-13T15:41:01Z,2020-12-13T15:41:01Z,CLOSED,False,312,1,6,https://github.com/szhorvat,Add a function to check potential connectedness,3,[],https://github.com/igraph/igraph/pull/1557,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1557#issuecomment-735289840,"This PR adds a function to check potential connectedness of a degree sequence.
Which name do you prefer? igraph_is_potentially_connected or igraph_is_potentially_connected_degree_sequence?
This PR should be merged as normal, not squash-and-merged.","igraph_is_potentially_connected_degree_sequence() is the way to go; it is consistent with igraph_is_graphical_degree_sequence().

These are actually deprecated in favour of is_graphical which is short, but doesn't say anything about degree sequences.
is_graphical is not released yet, so we can change its name.
We could e.g. use is_graphical_degseq and is_potentially_connected_degseq. These not so horribly long.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1557,2020-11-28T20:30:57Z,2020-12-13T15:41:01Z,2020-12-13T15:41:01Z,CLOSED,False,312,1,6,https://github.com/szhorvat,Add a function to check potential connectedness,3,[],https://github.com/igraph/igraph/pull/1557,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1557#issuecomment-735291474,"This PR adds a function to check potential connectedness of a degree sequence.
Which name do you prefer? igraph_is_potentially_connected or igraph_is_potentially_connected_degree_sequence?
This PR should be merged as normal, not squash-and-merged.","I fixed the doc build, improved the docs, and added \experimental for now.
The reason for marking it as experimental is that I want to think about how to check if there is a weakly connected realization of a pair of in- and out-degree sequences.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1557,2020-11-28T20:30:57Z,2020-12-13T15:41:01Z,2020-12-13T15:41:01Z,CLOSED,False,312,1,6,https://github.com/szhorvat,Add a function to check potential connectedness,3,[],https://github.com/igraph/igraph/pull/1557,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1557#issuecomment-744025531,"This PR adds a function to check potential connectedness of a degree sequence.
Which name do you prefer? igraph_is_potentially_connected or igraph_is_potentially_connected_degree_sequence?
This PR should be merged as normal, not squash-and-merged.","Closing this, as the implementation is incorrect. Will open a new PR sometime after the source reorganization is complete.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1558,This is meant as a start for CI runs on MSYS2.,This is meant as a start for CI runs on MSYS2.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/jannick0,2,https://github.com/igraph/igraph/pull/1558#issuecomment-735835039,This is meant as a start for CI runs on MSYS2.,We should add branch restrictions for CI builds using autoconf.  Is there any rule in terms of branch names or is master the only one to run this workflow on?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1558#issuecomment-735839254,This is meant as a start for CI runs on MSYS2.,"master is the only remaining autoconf-based branch; all other branches will be based on CMake. (We have lots of dead branches that we are not going to touch, we can leave them as they are).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/jannick0,4,https://github.com/igraph/igraph/pull/1558#issuecomment-736542656,This is meant as a start for CI runs on MSYS2.,"Many thanks for merging!
@ntamas @szhorvat I believe we need to finetune as to when pushes to branches on a fork of this repo should fire up the github workflow - and/or the other CIs. Here a suggestion for a simplistic branch name nomenclature triggering the various CIs (let's keep it really stupid and simple):

master/appveyor/<branch> - run appveyor CI only
master/msys/<branch> - run the msys github workflow only
master/travis/<branch> - run travis CI only
master/<branch> - run all CIs above

Agree? Any other suggestions?
Happy to put this in place. Likewise for the develop branch (instead of master), of course.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/jannick0,5,https://github.com/igraph/igraph/pull/1558#issuecomment-736548602,This is meant as a start for CI runs on MSYS2.,"Just discovered that git dislikes slashes in branch names. So let's replace them above by, say, hyphens (e.g. master-appveyor-<branch>).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1558#issuecomment-737251972,This is meant as a start for CI runs on MSYS2.,"Just discovered that git dislikes slashes in branch names.

Does it? I routinely use Git Flow styled branch names like feature/some-fancy-feature or fix/some-annoying-bug (without actually sticking to the Git Flow toolset). What should I have noticed?
The proposed naming scheme is okay for me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1558,2020-11-29T19:47:57Z,2020-12-01T08:28:36Z,2020-12-02T14:56:41Z,MERGED,True,42,0,1,https://github.com/jannick0,[master/autoconf] add github workflow for MSYS2's MINGW32 and MINGW64,2,[],https://github.com/igraph/igraph/pull/1558,https://github.com/jannick0,7,https://github.com/igraph/igraph/pull/1558#issuecomment-737281785,This is meant as a start for CI runs on MSYS2.,"Just discovered that git dislikes slashes in branch names.

Does it?

Actually no - git does like slashes. I got trapped by a glitch of the git viewer I am using. Happy to go with slashes then.

The proposed naming scheme is okay for me.

I'll shoot a PR shortly - for the develop branch, too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1559,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1559#issuecomment-735470386,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","Sorry about the stupid question, but do we need to enable Github Actions to see this work? Or do I just not see the link to the results? @ntamas, can you take a look?—I assume it needs admin access.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/jannick0,3,https://github.com/igraph/igraph/pull/1559#issuecomment-735472012,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","I cannot remember what exactly I did to have workflows being fired up. But try to look into Settings > Actions > ... to enable the feature for the repo.
Then look into Actions which should show the list of repo workflows, more here.  Not sure if workflows committed prior to enabling the feature immediately work, though.
HTH.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1559#issuecomment-735641790,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","do we need to enable Github Actions to see this work?

They are enabled, but I think we won't see the build results in develop until we actually merge the PR. Until then, we can take a look at the results in @jannick0 's branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1559#issuecomment-735641942,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)",Is #1558 a duplicate of this?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/jannick0,6,https://github.com/igraph/igraph/pull/1559#issuecomment-735678245,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","Sorry about the confusion: No, it is meant for the develop branch using cmake. To make things more clear, I just changed the issue title.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1559#issuecomment-735678257,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","#1558 Was for the master branch with autotools, this is for the develop branch with cmake.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1559#issuecomment-735714287,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","LGTM. @szhorvat , is it okay if I merge this? I know that we are currently trying to figure out which CI system to use in the long run, but this would be quite useful until we manage to fix the MINGW32/MINGW64 issues.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/jannick0,9,https://github.com/igraph/igraph/pull/1559#issuecomment-735722771,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","Could you please wait merging, since I believe the CI config needs branch restrictions?  I am working on this. Thx.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1559#issuecomment-735728111,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","@ntamas Sorry, I thought I responded already. Yes, we should absolutely merge this when Jannick is ready. But it is possible that someone with admin access to the igraph organizations needs to enable the GitHub Actions CI before it starts working. Can you please look into this?
With CI services like Travis restricting the amount of services that OSS projects can use, it might be best if we split the runs across several CI services. We'll also get results faster, plus if one breaks (as it sometimes happens), the other ones will still be working. Its a win-win (we take less resources from individual providers, but gain some robustness).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/jannick0,11,https://github.com/igraph/igraph/pull/1559#issuecomment-735782068,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","@ntamas Ready to go.

The workflow is restricted to the branch 'develop', although it exists on this branch only.  But I have no idea how github workflows are fired up, so this restriction should be helpful for safety reasons if other branches are forked from 'develop'.
Since the branch in my repo underlying this PR has a name other than 'develop', the workflow is not fired up in my repo - I just checked that before the force-push.

... so, fingers crossed. Still the MINGW issue does exist, such that we should not be disappointed that the builds will fail, but they should start.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1559#issuecomment-735827196,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)",Let's roll then! Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/jannick0,13,https://github.com/igraph/igraph/pull/1559#issuecomment-735833068,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)",Great - works: CI is fired up. ... Now we can try to tackle the MINGW issue.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1559#issuecomment-735968946,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","Now we can try to tackle the MINGW issue.

It's fixed now on develop, see a4d7f26
But I don't quite understand why this ever worked at all with MSVC ... @vtraag, any tips?
Note: the scg test failures are known, and not related to MinGW, see #1499",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1559#issuecomment-735992007,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","But I don't quite understand why this ever worked at all with MSVC ... @vtraag, any tips?

No, I don't know. There were some warnings in the log though
[00:06:40] sampling.obj : warning LNK4049: locally defined symbol igraph_rng_default imported [C:\projects\igraph\build\src\igraph.vcxproj]
[00:06:40] sampling.obj : warning LNK4217: locally defined symbol igraph_rng_get_integer imported in function plfit_walker_alias_sampler_sample [C:\projects\igraph\build\src\igraph.vcxproj]
[00:06:40] sampling.obj : warning LNK4217: locally defined symbol igraph_rng_get_unif imported in function plfit_runif [C:\projects\igraph\build\src\igraph.vcxproj]
[00:06:40] sampling.obj : warning LNK4217: locally defined symbol igraph_rng_get_unif01 imported in function plfit_rpareto [C:\projects\igraph\build\src\igraph.vcxproj]

All igraph calls  in plfit/random.c are done through a MACRO expansion. Perhaps the name mangling is done at some other stage in the MSVC compiler than with MinGW?
At any rate, IGRAPH_STATIC should indeed be defined for all object libraries, including plfit, so your solution looks good to me. There's just one thing I don't understand: why do you include this definition in prpack/CMakeList.txt? Shouldn't this be included in plfit/CMakeList.txt? It might be just lucky that this works because plfit is included before prpack in src/CMakeList.txt.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1559,2020-11-29T22:33:13Z,2020-11-30T14:42:15Z,2020-11-30T19:32:59Z,MERGED,True,46,0,1,https://github.com/jannick0,[develop/cmake] Github Workflow for MSYS2's MINGW32/MINGW64,1,[],https://github.com/igraph/igraph/pull/1559,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1559#issuecomment-735995050,"Here as a start a github workflow for MSYS2's MINGW32/MINGW64

static library only
tests fail due to unresolvable symbol with names beginning with __imp, so the known MINGW issue to be fixed.

To be done:

add shared library build
add various scenarios for -D flags (?)","There's just one thing I don't understand: why do you include this definition in prpack/CMakeList.txt?

Thanks for noticing. I was comparing the two files and somehow ended up putting it into the wrong one without noticing it. I fixed it.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1561,2020-12-02T19:36:06Z,2020-12-02T22:01:38Z,2020-12-02T22:01:38Z,MERGED,True,323,326,21,https://github.com/szhorvat,Replace assert() by IGRAPH_ASSERT(),2,[],https://github.com/igraph/igraph/pull/1561,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1561,"As the title says, this PR replaces assert() by IGRAPH_ASSERT() in the sources, except in C++ code and in source borrowed from elsewhere (e.g. bliss).
The one exception is a minor variables renaming in cliques.c.","As the title says, this PR replaces assert() by IGRAPH_ASSERT() in the sources, except in C++ code and in source borrowed from elsewhere (e.g. bliss).
The one exception is a minor variables renaming in cliques.c.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1561,2020-12-02T19:36:06Z,2020-12-02T22:01:38Z,2020-12-02T22:01:38Z,MERGED,True,323,326,21,https://github.com/szhorvat,Replace assert() by IGRAPH_ASSERT(),2,[],https://github.com/igraph/igraph/pull/1561,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1561#issuecomment-737458780,"As the title says, this PR replaces assert() by IGRAPH_ASSERT() in the sources, except in C++ code and in source borrowed from elsewhere (e.g. bliss).
The one exception is a minor variables renaming in cliques.c.","Added another commit disabling the unused-variable warning for Bliss and mini-gmp. This warning comes up when NDEBUG is defined. Some variables were only used by assert. In this code, I did not change assert to IGRAPH_ASSERT: Bliss is C++, so it's not appropriate there, and mini-gmp should not be touched by us.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1562,2020-12-03T19:54:38Z,2020-12-04T13:37:23Z,2020-12-04T14:17:26Z,MERGED,True,0,364,15,https://github.com/szhorvat,Remove functions that were deprecated in 0.6,1,[],https://github.com/igraph/igraph/pull/1562,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1562,"This PR removes functions that were deprecated in 0.6.
There was a disabled test for igraph_es_adj, but it seems to have been written for a very old version of igraph, and did not work anymore. I considered fixing and re-enabling it (for the replacement of igraph_es_adj, i.e. igraph_es_incident), but it looks like it's less work to write a new test from scratch. So I didn't fix it.","This PR removes functions that were deprecated in 0.6.
There was a disabled test for igraph_es_adj, but it seems to have been written for a very old version of igraph, and did not work anymore. I considered fixing and re-enabling it (for the replacement of igraph_es_adj, i.e. igraph_es_incident), but it looks like it's less work to write a new test from scratch. So I didn't fix it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1562,2020-12-03T19:54:38Z,2020-12-04T13:37:23Z,2020-12-04T14:17:26Z,MERGED,True,0,364,15,https://github.com/szhorvat,Remove functions that were deprecated in 0.6,1,[],https://github.com/igraph/igraph/pull/1562,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1562#issuecomment-738280068,"This PR removes functions that were deprecated in 0.6.
There was a disabled test for igraph_es_adj, but it seems to have been written for a very old version of igraph, and did not work anymore. I considered fixing and re-enabling it (for the replacement of igraph_es_adj, i.e. igraph_es_incident), but it looks like it's less work to write a new test from scratch. So I didn't fix it.",LGTM.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1562,2020-12-03T19:54:38Z,2020-12-04T13:37:23Z,2020-12-04T14:17:26Z,MERGED,True,0,364,15,https://github.com/szhorvat,Remove functions that were deprecated in 0.6,1,[],https://github.com/igraph/igraph/pull/1562,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1562#issuecomment-738803380,"This PR removes functions that were deprecated in 0.6.
There was a disabled test for igraph_es_adj, but it seems to have been written for a very old version of igraph, and did not work anymore. I considered fixing and re-enabling it (for the replacement of igraph_es_adj, i.e. igraph_es_incident), but it looks like it's less work to write a new test from scratch. So I didn't fix it.","It seems that we missed a reference to igraph_subgraph in structure_generators.c:45, which we should still delete.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1562,2020-12-03T19:54:38Z,2020-12-04T13:37:23Z,2020-12-04T14:17:26Z,MERGED,True,0,364,15,https://github.com/szhorvat,Remove functions that were deprecated in 0.6,1,[],https://github.com/igraph/igraph/pull/1562,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1562#issuecomment-738807985,"This PR removes functions that were deprecated in 0.6.
There was a disabled test for igraph_es_adj, but it seems to have been written for a very old version of igraph, and did not work anymore. I considered fixing and re-enabling it (for the replacement of igraph_es_adj, i.e. igraph_es_incident), but it looks like it's less work to write a new test from scratch. So I didn't fix it.",Removed.,True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1563,2020-12-03T21:55:53Z,2020-12-03T22:31:46Z,2020-12-04T15:01:21Z,CLOSED,False,18,0,2,https://github.com/szhorvat,Set up CI with Azure Pipelines,4,[],https://github.com/igraph/igraph/pull/1563,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1563,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1564,2020-12-03T22:11:35Z,2020-12-04T15:30:08Z,2020-12-10T15:18:09Z,MERGED,True,190,0,2,https://github.com/szhorvat,Add Azure Pipelines,35,[],https://github.com/igraph/igraph/pull/1564,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1564,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1564,2020-12-03T22:11:35Z,2020-12-04T15:30:08Z,2020-12-10T15:18:09Z,MERGED,True,190,0,2,https://github.com/szhorvat,Add Azure Pipelines,35,[],https://github.com/igraph/igraph/pull/1564,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1564#issuecomment-738762481,,"@vtraag I'm done with this for now. There are several improvements one could make but I'm lost in the docs. You've used Azure before, so please take a look, and if you're happy, then squash-and-merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1564,2020-12-03T22:11:35Z,2020-12-04T15:30:08Z,2020-12-10T15:18:09Z,MERGED,True,190,0,2,https://github.com/szhorvat,Add Azure Pipelines,35,[],https://github.com/igraph/igraph/pull/1564,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1564#issuecomment-738775383,,"Great work! It looks to build quite nice, and fast! Perhaps we could also add Windows builds?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1564,2020-12-03T22:11:35Z,2020-12-04T15:30:08Z,2020-12-10T15:18:09Z,MERGED,True,190,0,2,https://github.com/szhorvat,Add Azure Pipelines,35,[],https://github.com/igraph/igraph/pull/1564,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1564#issuecomment-738775806,,One minor suggestion though: perhaps we can simply write out fully internal instead shortening it to int to avoid any confusion?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1564,2020-12-03T22:11:35Z,2020-12-04T15:30:08Z,2020-12-10T15:18:09Z,MERGED,True,190,0,2,https://github.com/szhorvat,Add Azure Pipelines,35,[],https://github.com/igraph/igraph/pull/1564,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1564#issuecomment-738780178,,"I would keep it short. The whole point of the template syntax was to make everything more compact, and this will mostly be used by us, and never by users. I can add a clarifying comment to the template though.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1564,2020-12-03T22:11:35Z,2020-12-04T15:30:08Z,2020-12-10T15:18:09Z,MERGED,True,190,0,2,https://github.com/szhorvat,Add Azure Pipelines,35,[],https://github.com/igraph/igraph/pull/1564,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1564#issuecomment-738785495,,"this will mostly be used by us, and never by users

True of course, but my own code might still confuse me later as well 😄",True,{}
igraph/igraph,https://github.com/igraph/igraph,1565,2020-12-04T03:24:14Z,2020-12-04T09:07:31Z,2020-12-04T13:24:59Z,MERGED,True,40,13,4,https://github.com/jannick0,CI MINW32/MINGW64(autoconf): github workflow enhancements,8,[],https://github.com/igraph/igraph/pull/1565,https://github.com/jannick0,1,https://github.com/igraph/igraph/pull/1565,"A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.","A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1565,2020-12-04T03:24:14Z,2020-12-04T09:07:31Z,2020-12-04T13:24:59Z,MERGED,True,40,13,4,https://github.com/jannick0,CI MINW32/MINGW64(autoconf): github workflow enhancements,8,[],https://github.com/igraph/igraph/pull/1565,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1565#issuecomment-738663652,"A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1565,2020-12-04T03:24:14Z,2020-12-04T09:07:31Z,2020-12-04T13:24:59Z,MERGED,True,40,13,4,https://github.com/jannick0,CI MINW32/MINGW64(autoconf): github workflow enhancements,8,[],https://github.com/igraph/igraph/pull/1565,https://github.com/jannick0,3,https://github.com/igraph/igraph/pull/1565#issuecomment-738678202,"A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.","One of the two jobs fail because of git fetch --prune --unshallow which might compete with the same of the other job.  If this persists, then git fetch --prune --unshallow || true might help.
The same could be added to the develop branch.  I am running out of time, so I am wondering if one of you guys could amend the github workflow there.  That would be helpful.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1565,2020-12-04T03:24:14Z,2020-12-04T09:07:31Z,2020-12-04T13:24:59Z,MERGED,True,40,13,4,https://github.com/jannick0,CI MINW32/MINGW64(autoconf): github workflow enhancements,8,[],https://github.com/igraph/igraph/pull/1565,https://github.com/jannick0,4,https://github.com/igraph/igraph/pull/1565#issuecomment-738687373,"A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.",actions/checkout#400 - feature request to add fetching tags into action/checkout.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1565,2020-12-04T03:24:14Z,2020-12-04T09:07:31Z,2020-12-04T13:24:59Z,MERGED,True,40,13,4,https://github.com/jannick0,CI MINW32/MINGW64(autoconf): github workflow enhancements,8,[],https://github.com/igraph/igraph/pull/1565,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1565#issuecomment-738692253,"A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.","@jannick0, not sure if this helps, but in another project I used the following piece for GitHub actions to make sure we have all commits necessary to identify a version from git tags.
    - uses: actions/checkout@v2
      with:
        fetch-depth: 0",True,{}
igraph/igraph,https://github.com/igraph/igraph,1565,2020-12-04T03:24:14Z,2020-12-04T09:07:31Z,2020-12-04T13:24:59Z,MERGED,True,40,13,4,https://github.com/jannick0,CI MINW32/MINGW64(autoconf): github workflow enhancements,8,[],https://github.com/igraph/igraph/pull/1565,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1565#issuecomment-738782060,"A mixed commit series in tiny steps covering mostly CI MINGW32/MINGW64 (autoconf):

It appears that a github action is only triggered on a branch when the workflow file exists on that branch. So no need to restrict any branch names here.
Branches with names starting with github/, travis/ or appveyor/ trigger the mentioned CI only or - as implemented - are ignored by all CIs other than the mentioned one.
Fix to EOL issue (Windows).

The implemented name convention differs from the logic suggested in the discussion  of #1558. I am open for discussion, of course. Please edit as you may find appropriate.
NB: git prohibits brach names composed as <existing branch name>/<feature> (e.g. a branch name like master/abc is rejected when master already exists).
More details in the commit messages.
TODO: Once this is in, badges could be added to README.md.",Merged this PR into develop and tried to reconcile the changes with CMake. We'll see how it goes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/Keivin98,1,https://github.com/igraph/igraph/pull/1567,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/Keivin98,2,https://github.com/igraph/igraph/pull/1567#issuecomment-740221880,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.",Thank you for the comments @szhorvat! I modified the code according to your instructions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1567#issuecomment-740460785,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","I have never really found a good way to remove unrelated files from a PR without having to create a new PR from scratch

We could push a commit to this PR that deletes the extra files, and then squash-and-merge?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1567#issuecomment-740483268,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","The wording of some error message still needs to be changed, so please do not merge yet, even after removing the accidentally committed changes (I don't have time to fix that now).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1567#issuecomment-740484221,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","We could push a commit to this PR that deletes the extra files, and then squash-and-merge?

The problem is that these are not really ""extra files"" -- they are alreaedy in the repo but the modifications do not belong to this PR. So one would need to commit a patch to this PR that reverts the extra files, and then squash-and-merge at the end.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1567#issuecomment-740500443,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.",Maybe it's cleanest to start a new PR then.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1567#issuecomment-741627332,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","@Keivin98 Can you please start a new PR where you do not include any other changes than to the file games.c? An alternative solution is that we include the changes manually, and not through this PR, but then it would not be recorded you your contribution by GitHub. Let me know how you want to proceed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1567#issuecomment-742731094,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","@Keivin98 Let us know if you want to open a new PR with the unneeded files excluded. The purpose of this would be so that you 'get credit', as GitHub will records your contribution. Otherwise, I can merge the changes manually. Let me know how you want to proceed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1567#issuecomment-742743589,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.","@szhorvat, wouldn't it be the easiest to simply revert the files that should not have been touched in this PR?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1567,2020-12-07T16:07:37Z,2020-12-11T09:54:57Z,2020-12-11T09:54:57Z,MERGED,True,33,1,1,https://github.com/Keivin98,added parameter check in igraph_callaway_traits_game,4,[],https://github.com/igraph/igraph/pull/1567,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1567#issuecomment-742761033,"Performed a parameter check based on the issue #1322.

type_dist and pref_matrix size consistent with the number of types (types)?
type_dist entires non-negative?
types certainly must not be negative.
nodes must be non-negative.",I'd be happy to do this tomorrow btw.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1568,2020-12-10T16:44:39Z,2020-12-10T20:44:17Z,2020-12-10T20:44:26Z,MERGED,True,56,81,8,https://github.com/szhorvat,fix: make igraph_scg_grouping3 and igraph_scg_semiprojectors2 tests less sensitive to numerical instability,5,[],https://github.com/igraph/igraph/pull/1568,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1568,"This attempts to fix #1499 by using an eigenvector / graph combination where all elements of the eigenvector are different.
The problematic tests were igraph_scg_grouping3 and igraph_scg_semiprojectors2. #1499 explains the cause of the failure (numerical instability in some LAPACKS).


Both tests used an igraph_tree(10,3) graph. This is now replaced with a tree of the same size but no symmetries (as this was an easy way to avoid repetition of elements in the eigenvector)


Additionally, the p vector is not computed simply as the degree vector. As I noted in #1499, this is a simpler way to compute p for undirected graphs.


Finally, I removed unnecessary igraph_rng_seed calls.


Fixes #1499.","This attempts to fix #1499 by using an eigenvector / graph combination where all elements of the eigenvector are different.
The problematic tests were igraph_scg_grouping3 and igraph_scg_semiprojectors2. #1499 explains the cause of the failure (numerical instability in some LAPACKS).


Both tests used an igraph_tree(10,3) graph. This is now replaced with a tree of the same size but no symmetries (as this was an easy way to avoid repetition of elements in the eigenvector)


Additionally, the p vector is not computed simply as the degree vector. As I noted in #1499, this is a simpler way to compute p for undirected graphs.


Finally, I removed unnecessary igraph_rng_seed calls.


Fixes #1499.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1568,2020-12-10T16:44:39Z,2020-12-10T20:44:17Z,2020-12-10T20:44:26Z,MERGED,True,56,81,8,https://github.com/szhorvat,fix: make igraph_scg_grouping3 and igraph_scg_semiprojectors2 tests less sensitive to numerical instability,5,[],https://github.com/igraph/igraph/pull/1568,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1568#issuecomment-742787502,"This attempts to fix #1499 by using an eigenvector / graph combination where all elements of the eigenvector are different.
The problematic tests were igraph_scg_grouping3 and igraph_scg_semiprojectors2. #1499 explains the cause of the failure (numerical instability in some LAPACKS).


Both tests used an igraph_tree(10,3) graph. This is now replaced with a tree of the same size but no symmetries (as this was an easy way to avoid repetition of elements in the eigenvector)


Additionally, the p vector is not computed simply as the degree vector. As I noted in #1499, this is a simpler way to compute p for undirected graphs.


Finally, I removed unnecessary igraph_rng_seed calls.


Fixes #1499.",Thanks a lot for your hard work on this!,True,{'HOORAY': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1576,2020-12-18T10:30:00Z,2020-12-18T21:23:40Z,2020-12-18T21:23:46Z,MERGED,True,134,3165,20,https://github.com/szhorvat,betweenness: improve precision and speed,5,[],https://github.com/igraph/igraph/pull/1576,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1576,"Changes in this PR:

Betweenness functions now use double instead of long long to count paths. This avoids overflow.
Betweenness tests are moved to tests/unit; VERIFY_FINALLY_STACK is added to each; some tests are improves/extended.
Support for using bigints to count paths is removed.  I verified that the previous implementation was in fact less precise because dividing two bigints to get a double was done as bigint a, b; bigint c = (a * shift) / b; double res = double(c) / shift where shift  = 1000000000. This shift was not large enough for good precision. After correcting that, the results between bigint and double agree to 14 decimal digits.
nobigint arguments are removed from all functions
All bigint functionality is stripped from igraph. It was only used for betweenness. If we need bigints in the future, we will use GMP instead, which is much faster.","Changes in this PR:

Betweenness functions now use double instead of long long to count paths. This avoids overflow.
Betweenness tests are moved to tests/unit; VERIFY_FINALLY_STACK is added to each; some tests are improves/extended.
Support for using bigints to count paths is removed.  I verified that the previous implementation was in fact less precise because dividing two bigints to get a double was done as bigint a, b; bigint c = (a * shift) / b; double res = double(c) / shift where shift  = 1000000000. This shift was not large enough for good precision. After correcting that, the results between bigint and double agree to 14 decimal digits.
nobigint arguments are removed from all functions
All bigint functionality is stripped from igraph. It was only used for betweenness. If we need bigints in the future, we will use GMP instead, which is much faster.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1576,2020-12-18T10:30:00Z,2020-12-18T21:23:40Z,2020-12-18T21:23:46Z,MERGED,True,134,3165,20,https://github.com/szhorvat,betweenness: improve precision and speed,5,[],https://github.com/igraph/igraph/pull/1576,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1576#issuecomment-748090629,"Changes in this PR:

Betweenness functions now use double instead of long long to count paths. This avoids overflow.
Betweenness tests are moved to tests/unit; VERIFY_FINALLY_STACK is added to each; some tests are improves/extended.
Support for using bigints to count paths is removed.  I verified that the previous implementation was in fact less precise because dividing two bigints to get a double was done as bigint a, b; bigint c = (a * shift) / b; double res = double(c) / shift where shift  = 1000000000. This shift was not large enough for good precision. After correcting that, the results between bigint and double agree to 14 decimal digits.
nobigint arguments are removed from all functions
All bigint functionality is stripped from igraph. It was only used for betweenness. If we need bigints in the future, we will use GMP instead, which is much faster.","@ntamas  I suggest a plain merge, not squash-and-merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1576,2020-12-18T10:30:00Z,2020-12-18T21:23:40Z,2020-12-18T21:23:46Z,MERGED,True,134,3165,20,https://github.com/szhorvat,betweenness: improve precision and speed,5,[],https://github.com/igraph/igraph/pull/1576,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1576#issuecomment-748326256,"Changes in this PR:

Betweenness functions now use double instead of long long to count paths. This avoids overflow.
Betweenness tests are moved to tests/unit; VERIFY_FINALLY_STACK is added to each; some tests are improves/extended.
Support for using bigints to count paths is removed.  I verified that the previous implementation was in fact less precise because dividing two bigints to get a double was done as bigint a, b; bigint c = (a * shift) / b; double res = double(c) / shift where shift  = 1000000000. This shift was not large enough for good precision. After correcting that, the results between bigint and double agree to 14 decimal digits.
nobigint arguments are removed from all functions
All bigint functionality is stripped from igraph. It was only used for betweenness. If we need bigints in the future, we will use GMP instead, which is much faster.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1579,2020-12-20T14:34:48Z,2020-12-20T15:02:54Z,2020-12-20T15:02:54Z,MERGED,True,1,1,1,https://github.com/jgmbenoit,fix spelling error as reported by lintian,1,[],https://github.com/igraph/igraph/pull/1579,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1579,"Description: source typo
Correct spelling errors as reported by lintian in some binaries;
meant to silence lintian.
Origin: debian
Comment: spelling-error-in-binary
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","Description: source typo
Correct spelling errors as reported by lintian in some binaries;
meant to silence lintian.
Origin: debian
Comment: spelling-error-in-binary
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1580,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1580#issuecomment-748617726,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","Hello @jgmbenoit, thanks for the contributions!
It is very likely that there will be no more 0.8.x releases of igraph. Version 0.8 is the current master branch. All the development is happening on the develop branch at the moment, which will become 0.9. Therefore, please do not spend any effort on the master branch at the moment.  Contributions on develop are very welcome, of course.
Today I am doing some refactoring on the tests, so if you plan to touch any other tests, please give me a heads up first.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/jgmbenoit,3,https://github.com/igraph/igraph/pull/1580#issuecomment-748621556,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","Hello, thanks for your message. Concerning the examples in version 0.8.5, i I have notice that some off them are private.
It would be nice to put private examples in a distinct folder in order to easy package maintenance.
Otherwise, I would be great to have a Release Candidate of version 0.9.0 so that I can package it on Debian experimental.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1580#issuecomment-748631312,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","Concerning the examples in version 0.8.5, i I have notice that some off them are private.
It would be nice to put private examples in a distinct folder in order to easy package maintenance.

Could you please clarify what you mean by ""private"" here? Can you give an example? The examples and tests are indeed mixed up and we are in the process of separating them and cleaning them up for 0.9.

Otherwise, I would be great to have a Release Candidate of version 0.9.0 so that I can package it on Debian experimental.

We changed the build system in 0.9 so it will indeed be a good idea to have a release candidate.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1580#issuecomment-748634994,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20",@jgmbenoit The draft installation instructions for the develop branch (which will be 0.9) are here. I just added a section for package maintainers at the end. Any feedback from the perspective of a package maintainer is welcome.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/jgmbenoit,6,https://github.com/igraph/igraph/pull/1580#issuecomment-748638301,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20",By private I meant examples that include igraph_marked_queue.h and *_internal.h headers: they are not in the /usr/include/igraph folder.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1580#issuecomment-748643862,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","@jgmbenoit On the develop branch, all tests that were not linked from the documentation (i.e. which were no examples) are in tests/unit. Examples remain in examples/simple and do no use internal headers. Does this solve any problems you encountered when packaging for Debian?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/jgmbenoit,8,https://github.com/igraph/igraph/pull/1580#issuecomment-748667071,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","This is the idea indeed. In the current develop branch, e/s/igraph_sparsemat2.c includes two linalg/*_internal.h .
This is just a very quick grep check. I would need a complete packaging to be complete.
Please note that you should rename the folder etc . The folder /etc has a clear meaning in *NIX world: this can confuse a lot of people.
I would move etc/cmake to cmake , move etc/{abstracts,papers.presentations} in a new folder in doc : doc/academia ? doc/extra ?
(but not doc/etc ). I will try to get a closer look the next week-end.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1580,2020-12-20T14:37:20Z,2020-12-20T15:02:16Z,2020-12-22T12:16:48Z,MERGED,True,1,2,1,https://github.com/jgmbenoit,e/s/igraph_community_leiden.c silence gcc warnings,1,[],https://github.com/igraph/igraph/pull/1580,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1580#issuecomment-749512179,"Description: examples/simple: silence gcc Warnings
Silence gcc Warnings to ease tests.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","@jgmbenoit I collected the problem examples in #1582, let's continue the discussion there. These will be fixed for 0.9.  I still don't understand why these are a problem for Debian. Can you elaborate? Do you plan to package the examples in a special way?
I can't comment on etc, I will leave making a decision on that to @ntamas",True,{}
igraph/igraph,https://github.com/igraph/igraph,1581,2020-12-20T14:38:55Z,2020-12-20T15:04:12Z,2020-12-20T15:04:13Z,MERGED,True,2,0,1,https://github.com/jgmbenoit,missing include in e/benchmarks header,1,[],https://github.com/igraph/igraph/pull/1581,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1581,"Description: add missing header in examples/benchnmakrs/bench.h' Include sys/resource.h in e/b/bench.h'.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20","Description: add missing header in examples/benchnmakrs/bench.h' Include sys/resource.h in e/b/bench.h'.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20",True,{}
igraph/igraph,https://github.com/igraph/igraph,1581,2020-12-20T14:38:55Z,2020-12-20T15:04:12Z,2020-12-20T15:04:13Z,MERGED,True,2,0,1,https://github.com/jgmbenoit,missing include in e/benchmarks header,1,[],https://github.com/igraph/igraph/pull/1581,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1581#issuecomment-748619263,"Description: add missing header in examples/benchnmakrs/bench.h' Include sys/resource.h in e/b/bench.h'.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-20",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1583,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1583#issuecomment-749508131,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","@ntamas This is not yet done, but I need input to proceed. I noticed that weighted closeness uses comparison with tolerance to determine if two paths have the same length:
https://github.com/igraph/igraph/pull/1583/files#diff-3a9a78ccf7f2683f60b049001de999de2e35b3547aba20517c2f41a3fd31e97fR131
https://github.com/igraph/igraph/pull/1583/files#diff-3a9a78ccf7f2683f60b049001de999de2e35b3547aba20517c2f41a3fd31e97fR144-R146
https://github.com/igraph/igraph/pull/1583/files#diff-3a9a78ccf7f2683f60b049001de999de2e35b3547aba20517c2f41a3fd31e97fR194-R199
This seems pointless to me. It does not matter if we choose the ""wrong"" path as the shortest one due to numerical errors, as closeness is defined based on path length. If the error in the path length is tiny, then the error in closeness will be tiny. Am I missing something important?
The weighted betweenness calculation also has this. There, it is indeed very necessary because the betweenness value depends on which is the shortest path, not its length. Small errors can change the result dramatically.
In order to implement harmonic centrality, I copied and edited the closeness sources. I think it makes sense to remove this comparison-with-tolerance, and go with a normal comparison for the sake of simplicity and performance. I would also do this for plain closeness. Agreed?
tl;dr. Using a tolerance when comparing path lengths is necessary for betweenness, but not for closeness. I will remove it from closeness, and exclude it from the newly implemented harmonic version of closeness. Agreed?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1583#issuecomment-750329424,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","The links that you provided are broken (they all point to this PR in general, the anchors have no effect), but I think I understand the problem that you mentioned, and I think that historically, the weighted closeness and the betweenness implementations were developed in parallel or close to each other in time, and the closeness centrality code simply copied code that worked from betweenness without thinking through whether the tolerance check is needed or not. I agree with removing the tolerance check from the closeness centrality implementation -- and to do the same with the harmonic centrality.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1583#issuecomment-756935801,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","@ntamas Please take a very careful look, but do not squash-and-merge, (just merge or leave it to me).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1583#issuecomment-756936861,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","The deprecated functions are no inserted in the docs at the moment. I can insert them, as the doc comments are retained. Let me know what you think about this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1583#issuecomment-760511116,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).",Just a quick heads up that I've started reviewing this and that there is no need to keep the deprecated functions in the docs.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1583#issuecomment-760791664,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","Finished with all the files except closeness.c; I'm starting that now.
As for the test cases, I trust that you calculated harmonic centrality for these graphs in some other tool (e.g., Mathematica?) and we are using those values in the test cases, right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1583#issuecomment-760793350,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","Yes, I checked the values.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1583,2020-12-21T12:16:11Z,2021-01-16T13:25:26Z,2021-01-16T13:25:26Z,MERGED,True,2804,2020,16,https://github.com/szhorvat,Implement harmonic centrality,17,[],https://github.com/igraph/igraph/pull/1583,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1583#issuecomment-760799280,"Changes in this PR:

Break up centrality_other.c into smaller parts and remove unneeded headers

Update copyright notice in these files


Implement harmonic centrality: igraph_harmonic_centrality and igraph_harmonic_centrality_range_limited. Fixes #1373.
Made sure that igraph_vector_min is not called on empty vectors in betweenness/closeness calculations. This would result in a crash.
Replace igraph_closeness_estimate with igraph_closeness_cutoff:

igraph_closeness_estimate is retained, but deprecated. Now it issues a warning.
igraph_closeness_cutoff has the cutoff argument moved to the end.


Also replace igraph_(edge)_betweenness_estimate with igraph_(edge)_betweenness_cutoff and move cutoff to the end. The original functions are deprecated.
Remove the unneeded comparison-with-tolerances from the closeness calculation. A small error will not affect the result here (with betweenness it will, so using tolerances was important there).","This is great, thanks for your hard work on this! I'm not merging as requested above, I'm leaving it up to you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/AdamKorcz,1,https://github.com/igraph/igraph/pull/1584,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/AdamKorcz,2,https://github.com/igraph/igraph/pull/1584#issuecomment-749098896,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.",The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877,True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1584#issuecomment-749117332,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","Hello @AdamKorcz, thanks for this nice contribution! Currently, all development happens on the develop branch, which will become igraph 0.9. We have switched to a CMake-based build system. Build instructions are roughly:
mkdir build && cd build
cmake ..
make

More info here. Note that the current build system auto-detect dependencies and defaults to system libraries if they are available. If so, programs built with igraph also need to link against these libraries. Otherwise, igraph can be configured to use bundled (vendored) dependencies, which may be the best thing to do here.
libigraph.a is created in build/src.
Would you be able to re-base this PR against develop and make sure that oss-fuzzer uses that branch? Let me know if you need any help with this on the igraph side.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1584#issuecomment-749519296,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","Alternatively, we can do it on master first then I'll merge this into develop with all the necessary changes. I'll get back to this later today. Feel free to add my email (as shown in GitHub) in the other PR. Perhaps @ntamas would prefer his to be included as well?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/AdamKorcz,5,https://github.com/igraph/igraph/pull/1584#issuecomment-749691952,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","I would be happy to merge this into master and then merge it into dev. I will get your email address added @szhorvat
I will also be happy to rebase this to develop, but it will happen in a week or so due to the holidays.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/AdamKorcz,6,https://github.com/igraph/igraph/pull/1584#issuecomment-752684849,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.",Closing to reopen,True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1584#issuecomment-1004800012,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.",@AdamKorcz Why did you use if(size<5) return 0;? I would like to understand if there is any good reason for this before adding more fuzzers.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/AdamKorcz,8,https://github.com/igraph/igraph/pull/1584#issuecomment-1004803620,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","@AdamKorcz Why did you use if(size<5) return 0;? I would like to understand if there is any good reason for this before adding more fuzzers.

Generally there may be some false positives in the case of short byte arrays. I cannot remember whether it applies to igraph though. If you add more fuzzers, you might be able to leave that out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1584#issuecomment-1008024876,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","@AdamKorcz I removed the limits and so far everything seems to be good.
Another question:
Do you know why this performance report complains about logging? The log files linked from the report do not contain any messages written by the program. In fact I do not think this program is outputting anything at all (or at least it shouldn't).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1584,2020-12-21T17:14:03Z,2020-12-30T16:40:05Z,2022-01-13T07:46:51Z,CLOSED,False,78,0,3,https://github.com/AdamKorcz,Added fuzzer to integrate igraph into OSS-fuzz,12,[],https://github.com/igraph/igraph/pull/1584,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1584#issuecomment-1011879218,"This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
I will shortly set up the integration on the OSS-fuzz side. All that is needed to complete the integration is to:

Merge in the files in this PR
Add at least one maintainers email address for potential bug reports.","@AdamKorcz Is there a way to completely remove any generated corpus for a target and start from zero again?
I was experimenting with adding targets for some of the more complicated functions that process graphs. These need to receive the graph in some appropriate binary format that the fuzzer can mutate in a useful way. I think my first attempt was not very successful, and the graph format should be changed. This would make any existing corpus useless.
(In fact, I am not sure that fuzzing such functions is useful at all, even with a better input format and custom mutators. But it's always worth experimenting a bit. If you don't seek, you won't find anything.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1587,2020-12-26T15:18:47Z,2020-12-27T20:46:47Z,2020-12-27T20:46:47Z,MERGED,True,33,10,3,https://github.com/jgmbenoit,external SuiteSparse library suite,1,[],https://github.com/igraph/igraph/pull/1587,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1587,"I understand that externalizing SuiteSparse is already done in the coming version 0.9 (develop branch).
This is mainly for the record as it can be useful to others meanwhile.
Description: external SuiteSparse library suite
Allow to use the system wide SuiteSparse library suite
instead of using the one furnished in the upstream source.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-26","I understand that externalizing SuiteSparse is already done in the coming version 0.9 (develop branch).
This is mainly for the record as it can be useful to others meanwhile.
Description: external SuiteSparse library suite
Allow to use the system wide SuiteSparse library suite
instead of using the one furnished in the upstream source.
Origin: debian
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2020-12-26",True,{}
igraph/igraph,https://github.com/igraph/igraph,1588,2020-12-30T16:44:29Z,2021-01-04T11:46:02Z,2021-01-07T16:30:51Z,MERGED,True,78,0,3,https://github.com/AdamKorcz,Added fuzzer and OSS-fuzz build script,1,[],https://github.com/igraph/igraph/pull/1588,https://github.com/AdamKorcz,1,https://github.com/igraph/igraph/pull/1588,"Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877","Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877",True,{}
igraph/igraph,https://github.com/igraph/igraph,1588,2020-12-30T16:44:29Z,2021-01-04T11:46:02Z,2021-01-07T16:30:51Z,MERGED,True,78,0,3,https://github.com/AdamKorcz,Added fuzzer and OSS-fuzz build script,1,[],https://github.com/igraph/igraph/pull/1588,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1588#issuecomment-753898008,"Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877",Thanks a lot -- see my two minor comments above. Please fix the copyright notice in the newly added file and then I'll merge.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1588,2020-12-30T16:44:29Z,2021-01-04T11:46:02Z,2021-01-07T16:30:51Z,MERGED,True,78,0,3,https://github.com/AdamKorcz,Added fuzzer and OSS-fuzz build script,1,[],https://github.com/igraph/igraph/pull/1588,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1588#issuecomment-753930037,"Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1588,2020-12-30T16:44:29Z,2021-01-04T11:46:02Z,2021-01-07T16:30:51Z,MERGED,True,78,0,3,https://github.com/AdamKorcz,Added fuzzer and OSS-fuzz build script,1,[],https://github.com/igraph/igraph/pull/1588,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1588#issuecomment-755423559,"Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877","@AdamKorcz seeing the crash reports from today, I realized that the logic in fuzzing/read_lgl_fuzzer.c might be incorrect (and it should be called read_gml_fuzzer.c as it is targeting the igraph_read_graph_gml function). The problem is that in case of an invalid input, it attempts to call igraph_destroy(&g) anyway, even if igraph_read_graph_gml() returned an error code. When igraph_read_graph_gml() returns an error code, the graph object is left in an undefined state so it is not safe to call igraph_destroy(&g) on it; what we should do instead is as follows:


if igraph_read_graph_gml() returns zero, the code should proceed and call igraph_destroy(&g) as before.


if igraph_read_graph_gml() returns nonzero, the code should not call igraph_destroy(&g).


in both cases, it should somehow be checked that there was no memory leaked, even if the input was invalid (in other words, igraph_read_graph_gml() must clean up after itself for invalid inputs).


Questions:


If I modify fuzzing/read_lgl_fuzzer.c in the repo, will that be picked up automatically by OSS-fuzz?


Can I mark today's reports as ""stale"" somehow, at least for those where I suspect this could be the cause of the problem (i.e. incorrect logic in the fuzzer, not a bug in igraph's code).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1588,2020-12-30T16:44:29Z,2021-01-04T11:46:02Z,2021-01-07T16:30:51Z,MERGED,True,78,0,3,https://github.com/AdamKorcz,Added fuzzer and OSS-fuzz build script,1,[],https://github.com/igraph/igraph/pull/1588,https://github.com/AdamKorcz,5,https://github.com/igraph/igraph/pull/1588#issuecomment-755438218,"Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877","If I modify fuzzing/read_lgl_fuzzer.c in the repo, will that be picked up automatically by OSS-fuzz?

Yup.

Can I mark today's reports as ""stale"" somehow, at least for those where I suspect this could be the cause of the problem (i.e. incorrect logic in the fuzzer, not a bug in igraph's code).

Yes, there should be some command to leave in the comment on the bug report, however I can't remember what it is. The OSS-fuzz maintainers should answer quickly if you raise an issue over there. I am sure they will be happy to help.
Your suggestions sound good to me  from a fuzzing-perspective as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1588,2020-12-30T16:44:29Z,2021-01-04T11:46:02Z,2021-01-07T16:30:51Z,MERGED,True,78,0,3,https://github.com/AdamKorcz,Added fuzzer and OSS-fuzz build script,1,[],https://github.com/igraph/igraph/pull/1588,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1588#issuecomment-756225440,"Reopens #1584 - I apologize for double-posting. Rebasing to develop in last PR became a little messy.
This PR adds a fuzzer with build script to run it continuously through OSS-fuzz.
Fuzzing is a way of testing programs whereby pseudo-random data is passed to a target application with the goal of finding bugs and vulnerabilities. I can see that igraph previously has been fuzzed by the community.
OSS-fuzz is a project by Google into which open-source projects can integrate and have their fuzzers run continuously. If bugs are found, maintainers get notified with an email containing a link to a detailed bug report with stack trace and reproducible test case.
The integration files on the OSS-fuzz side have been added here: google/oss-fuzz#4877","@AdamKorcz Thanks so much for this contribution, and thanks @ntamas for merging it and fixing the bugs it revealed! It took me longer to get back to igraph in the new year than I expected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/AdamKorcz,1,https://github.com/igraph/igraph/pull/1589,This fixes the broken afl++ build: google/oss-fuzz#4877,This fixes the broken afl++ build: google/oss-fuzz#4877,True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1589#issuecomment-754169956,This fixes the broken afl++ build: google/oss-fuzz#4877,"Thanks, merged!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/AdamKorcz,3,https://github.com/igraph/igraph/pull/1589#issuecomment-754172674,This fixes the broken afl++ build: google/oss-fuzz#4877,thanks! @ntamas Would you like to be on the mailing list for bug reports?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1589#issuecomment-754173125,This fixes the broken afl++ build: google/oss-fuzz#4877,Yes please.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/AdamKorcz,5,https://github.com/igraph/igraph/pull/1589#issuecomment-754174478,This fixes the broken afl++ build: google/oss-fuzz#4877,What is your email address?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1589#issuecomment-754190737,This fixes the broken afl++ build: google/oss-fuzz#4877,redacted :),True,{}
igraph/igraph,https://github.com/igraph/igraph,1589,2021-01-04T12:33:53Z,2021-01-04T19:22:03Z,2021-01-04T22:09:39Z,MERGED,True,5,4,2,https://github.com/AdamKorcz,Add support for AFL++,1,[],https://github.com/igraph/igraph/pull/1589,https://github.com/AdamKorcz,7,https://github.com/igraph/igraph/pull/1589#issuecomment-754248810,This fixes the broken afl++ build: google/oss-fuzz#4877,Hereby added!,True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1594,2021-01-09T15:07:42Z,2021-01-09T17:37:07Z,2021-01-09T17:37:43Z,MERGED,True,47,0,2,https://github.com/GroteGnoom,Add unit test for st_mincut_value,2,[],https://github.com/igraph/igraph/pull/1594,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1594,"Part of issue #1592.
I was planning to test the actual cut instead of just the value, but usually there are multiple min cuts possible and I didn't want to have a failed test when a different min cut is returned. (A test with only one possible min cut can of course still be added)
The functionality is already tested in maxflow, but this is a simple check to see that everything is correctly connected.","Part of issue #1592.
I was planning to test the actual cut instead of just the value, but usually there are multiple min cuts possible and I didn't want to have a failed test when a different min cut is returned. (A test with only one possible min cut can of course still be added)
The functionality is already tested in maxflow, but this is a simple check to see that everything is correctly connected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1594,2021-01-09T15:07:42Z,2021-01-09T17:37:07Z,2021-01-09T17:37:43Z,MERGED,True,47,0,2,https://github.com/GroteGnoom,Add unit test for st_mincut_value,2,[],https://github.com/igraph/igraph/pull/1594,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1594#issuecomment-757340577,"Part of issue #1592.
I was planning to test the actual cut instead of just the value, but usually there are multiple min cuts possible and I didn't want to have a failed test when a different min cut is returned. (A test with only one possible min cut can of course still be added)
The functionality is already tested in maxflow, but this is a simple check to see that everything is correctly connected.",Thank you! I made one small modification to the copyright notice. Please use this one as the template for future contributions.,True,"{'THUMBS_UP': ['https://github.com/GroteGnoom'], 'HOORAY': ['https://github.com/GroteGnoom']}"
igraph/igraph,https://github.com/igraph/igraph,1595,2021-01-11T09:41:10Z,2021-01-12T13:45:29Z,2021-01-12T13:45:29Z,MERGED,True,78,0,3,https://github.com/GroteGnoom,Add unit test for st_mincut,5,[],https://github.com/igraph/igraph/pull/1595,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1595,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1595,2021-01-11T09:41:10Z,2021-01-12T13:45:29Z,2021-01-12T13:45:29Z,MERGED,True,78,0,3,https://github.com/GroteGnoom,Add unit test for st_mincut,5,[],https://github.com/igraph/igraph/pull/1595,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1595#issuecomment-758039412,Part of #1592,"This is one possible assignmetn of capacities:

The unique solution is then 1->2, 3->4.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1595,2021-01-11T09:41:10Z,2021-01-12T13:45:29Z,2021-01-12T13:45:29Z,MERGED,True,78,0,3,https://github.com/GroteGnoom,Add unit test for st_mincut,5,[],https://github.com/igraph/igraph/pull/1595,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1595#issuecomment-758203159,Part of #1592,"Thanks for this contribution!

Thank you for taking the time to check and correct everything!

You mentioned that in general, there is more than one min-cut, so one can't easily test that the result is correct. However, if we choose the graph wisely, then there will be precisely one min-cut. I would suggest outputting the cut, and verifying that it is what it should be (0->1 here).
It would also be nice to add a weighted version (i.e. having capacities) which also has precisely one solution, and where the solution would be different from the unweighted one.

Allright, I will work on that tomorrow.

Helper functions to print vectors are in test_utilities.inc. Trivial cases can be verified with assert, but if the min-cut consists of more than a single edge, then it becomes more convenient to print. You can sort the edge index vector to canonicalize it (since there are no guarantees about ordering).

Thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1595,2021-01-11T09:41:10Z,2021-01-12T13:45:29Z,2021-01-12T13:45:29Z,MERGED,True,78,0,3,https://github.com/GroteGnoom,Add unit test for st_mincut,5,[],https://github.com/igraph/igraph/pull/1595,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1595#issuecomment-758658672,Part of #1592,"Please, in the future do use an explicit #include <igraph.h> even if we already have an #include ""test_utilities.inc"".
No need to do anything for this PR. I'll do it quickly before I merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1596,2021-01-11T11:31:10Z,2021-01-12T13:48:08Z,2021-01-12T13:48:08Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add st_edge_connectivity unit test,6,[],https://github.com/igraph/igraph/pull/1596,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1596,part of #1592,part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1596,2021-01-11T11:31:10Z,2021-01-12T13:48:08Z,2021-01-12T13:48:08Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add st_edge_connectivity unit test,6,[],https://github.com/igraph/igraph/pull/1596,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1596#issuecomment-758616488,part of #1592,"I will :)
I did notice that if I forget a igraph_destroy(&g) and then call VERIFY_FINALLY_STACK(), there are no errors. Is this the expected behavior? Should there be a different check for that?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1596,2021-01-11T11:31:10Z,2021-01-12T13:48:08Z,2021-01-12T13:48:08Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add st_edge_connectivity unit test,6,[],https://github.com/igraph/igraph/pull/1596,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1596#issuecomment-758627484,part of #1592,"Yes, that's normal; VERIFY_FINALLY_STACK() simply checks whether the so-called ""finally"" stack is empty. This stack is an internal data structure where igraph pushes pointers that should be cleaned up in case an error happens in an igraph function, and these pointers are freed automatically when igraph returns from any of its own functions with IGRAPH_ERROR(). During normal termination of an igraph function, the ""finally"" stack is processed ""manually"" because there could be cases (e.g., in constructor functions) when we want to return a pointer to the user whose associated memory area was allocated by igraph so we cannot blindly free everything that is in the stack. This leads to the problem: if the manual cleanup code is incorrect, there could be a pointer left in the ""finally"" stack when the execution exits igraph's turf, leading to a memory leak. Furthermore, if the user calls another igraph function later on, and this other function returns with IGRAPH_ERROR(), stuff that was accidentally left in the ""finally"" gets cleaned up at an incorrect time.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1596,2021-01-11T11:31:10Z,2021-01-12T13:48:08Z,2021-01-12T13:48:08Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add st_edge_connectivity unit test,6,[],https://github.com/igraph/igraph/pull/1596,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1596#issuecomment-758627725,part of #1592,@szhorvat is it okay to merge?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1597,2021-01-11T12:01:14Z,2021-01-12T13:49:12Z,2021-01-12T13:49:12Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add edge_disjoint_paths unit test,6,[],https://github.com/igraph/igraph/pull/1597,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1597,part of #1592,part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1597,2021-01-11T12:01:14Z,2021-01-12T13:49:12Z,2021-01-12T13:49:12Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add edge_disjoint_paths unit test,6,[],https://github.com/igraph/igraph/pull/1597,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1597#issuecomment-757909163,part of #1592,"I'll get to these PRs European-time evening today.
In the future, feel free to add more than a single test through a PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1597,2021-01-11T12:01:14Z,2021-01-12T13:49:12Z,2021-01-12T13:49:12Z,MERGED,True,41,0,2,https://github.com/GroteGnoom,Add edge_disjoint_paths unit test,6,[],https://github.com/igraph/igraph/pull/1597,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1597#issuecomment-758609842,part of #1592,"Please add calls to VERIFY_FINALLY_STACK() at the end of all test cases before returning 0 and handing control back to the OS. This macro validates that igraph has properly cleaned up after itself and there are no remaining pointers-to-be-destroyed left on the error handler stack. We have recently started doing this so not all test cases have them in the library yet, but new ones should definitely do.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1598,2021-01-11T15:42:46Z,2021-01-12T15:51:23Z,2021-01-12T15:51:23Z,MERGED,True,210,2,6,https://github.com/GroteGnoom,"Add 4 unit tests, fix residual_graph bug",9,[],https://github.com/igraph/igraph/pull/1598,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1598,"Part of #1592
residual_graph didn't give the residual capacity, but the original
capacity of the residual graph.","Part of #1592
residual_graph didn't give the residual capacity, but the original
capacity of the residual graph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1598,2021-01-11T15:42:46Z,2021-01-12T15:51:23Z,2021-01-12T15:51:23Z,MERGED,True,210,2,6,https://github.com/GroteGnoom,"Add 4 unit tests, fix residual_graph bug",9,[],https://github.com/igraph/igraph/pull/1598,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1598#issuecomment-758609210,"Part of #1592
residual_graph didn't give the residual capacity, but the original
capacity of the residual graph.","Please add calls to VERIFY_FINALLY_STACK() at the end of all test cases before returning 0 and handing control back to the OS. This macro validates that igraph has properly cleaned up after itself and there are no remaining pointers-to-be-destroyed left on the error handler stack. We have recently started doing this so not all test cases have them in the library yet, but new ones should definitely do.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1601,2021-01-13T12:22:58Z,2021-01-14T10:38:03Z,2021-01-14T10:42:27Z,MERGED,True,76,44,2,https://github.com/GroteGnoom,Add igraph_write_graph_lgl example,3,[],https://github.com/igraph/igraph/pull/1601,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1601,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1601,2021-01-13T12:22:58Z,2021-01-14T10:38:03Z,2021-01-14T10:42:27Z,MERGED,True,76,44,2,https://github.com/GroteGnoom,Add igraph_write_graph_lgl example,3,[],https://github.com/igraph/igraph/pull/1601,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1601#issuecomment-759425853,Part of #1592,"287/288 Test #288: igraph_read_graph_gml_invalid_inputs ......***Failed    0.05 sec

=================================================================
==12515==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 8 byte(s) in 4 object(s) allocated from:
    #0 0x7efdf0098d28 in __interceptor_calloc (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xded28)
    #1 0x55742ec40d73 in igraph_i_gml_get_keyword /home/vsts/work/1/s/src/io/gml-parser.y:162
    #2 0x55742ec424b5 in igraph_gml_yyparse /home/vsts/work/1/s/src/io/gml-parser.y:140
    #3 0x55742ec3b223 in igraph_read_graph_gml ../src/io/gml.c:209
    #4 0x55742ec2d0f5 in test_file ../tests/regression/igraph_read_graph_gml_invalid_inputs.c:37
    #5 0x55742ec2d23f in main ../tests/regression/igraph_read_graph_gml_invalid_inputs.c:69
    #6 0x7efdef84cbf6 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21bf6)

SUMMARY: AddressSanitizer: 8 byte(s) leaked in 4 allocation(s).

I'm guessing I'm not handling the names and weights correctly.
Is it normal this shows up at a different test?
Edit: Ah, I see the gml tests were recently changed. @ntamas, do you know what's going on?
Build are failing since 293fd42
With output:
https://dev.azure.com/igraph-team/igraph/_build/results?buildId=186&view=logs&j=4c3a8381-b9de-5463-904f-918810769be8&t=a906eab8-d2a3-5e54-d199-606dbbfb0805",True,{}
igraph/igraph,https://github.com/igraph/igraph,1601,2021-01-13T12:22:58Z,2021-01-14T10:38:03Z,2021-01-14T10:42:27Z,MERGED,True,76,44,2,https://github.com/GroteGnoom,Add igraph_write_graph_lgl example,3,[],https://github.com/igraph/igraph/pull/1601,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1601#issuecomment-760110500,Part of #1592,"The failure above is unrelated; it's in the GML parser. It has already been fixed in develop so if you rebase your PR on the most recent develop revision (or merge develop into it), it should go away.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1601,2021-01-13T12:22:58Z,2021-01-14T10:38:03Z,2021-01-14T10:42:27Z,MERGED,True,76,44,2,https://github.com/GroteGnoom,Add igraph_write_graph_lgl example,3,[],https://github.com/igraph/igraph/pull/1601,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1601#issuecomment-760111069,Part of #1592,Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1601,2021-01-13T12:22:58Z,2021-01-14T10:38:03Z,2021-01-14T10:42:27Z,MERGED,True,76,44,2,https://github.com/GroteGnoom,Add igraph_write_graph_lgl example,3,[],https://github.com/igraph/igraph/pull/1601,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1601#issuecomment-760113297,Part of #1592,"Thanks a lot!

You're welcome :) This is a very nice project to work on.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1603,2021-01-13T13:10:22Z,2021-01-15T12:49:49Z,2021-01-15T12:49:55Z,MERGED,True,89,0,3,https://github.com/GroteGnoom,Add write_graph_dimacs unit test,2,[],https://github.com/igraph/igraph/pull/1603,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1603,"Part of #1592
Yes, it just outputs the source and target, even if they don't exist","Part of #1592
Yes, it just outputs the source and target, even if they don't exist",True,{}
igraph/igraph,https://github.com/igraph/igraph,1603,2021-01-13T13:10:22Z,2021-01-15T12:49:49Z,2021-01-15T12:49:55Z,MERGED,True,89,0,3,https://github.com/GroteGnoom,Add write_graph_dimacs unit test,2,[],https://github.com/igraph/igraph/pull/1603,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1603#issuecomment-760485984,"Part of #1592
Yes, it just outputs the source and target, even if they don't exist","@ntamas It seems a bit unusual that the DIMACS writer takes source/target as parameters and writes specifically a max-flow problem file. This format is not used only for max-flow problems.
Would it make sense to remove these arguments, or perhaps make them optional in some sense, and make this into a generic DIMACS graph format writer? Here's a more generic format description: http://prolland.free.fr/works/research/dsat/dimacs.html
The difference would be that:

The n line would not be included. This specified the source/target for the flow problem.
The p line would look like p edge NODES EDGES instead of p max NODES EDGES.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1603,2021-01-13T13:10:22Z,2021-01-15T12:49:49Z,2021-01-15T12:49:55Z,MERGED,True,89,0,3,https://github.com/GroteGnoom,Add write_graph_dimacs unit test,2,[],https://github.com/igraph/igraph/pull/1603,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1603#issuecomment-760491485,"Part of #1592
Yes, it just outputs the source and target, even if they don't exist","Totally fine for me; I'm not familiar with the DIMACS format and I think it was primarily added to gain access to lots of max-flow problems that we could test our max-flow implementation with. If it makes sense to make it into a more generic reader/writer, feel free to go ahead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1603,2021-01-13T13:10:22Z,2021-01-15T12:49:49Z,2021-01-15T12:49:55Z,MERGED,True,89,0,3,https://github.com/GroteGnoom,Add write_graph_dimacs unit test,2,[],https://github.com/igraph/igraph/pull/1603,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1603#issuecomment-760772537,"Part of #1592
Yes, it just outputs the source and target, even if they don't exist","There are many different DIMACS challenge formats, designed not so much for graph exchange, but for use during the competitions. Here is the most complete description I could find:
http://dimacs.rutgers.edu/archive/Challenges/
It would be nice to have a generic reader that can extract at least the graph portion of most versions. As you say, the main use of this is to access various benchmark sets.
To do all this will be quite a bit of work, so for now I'll merge this PR, and will open a new issue for the idea of a more general DIMACS reader.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1603,2021-01-13T13:10:22Z,2021-01-15T12:49:49Z,2021-01-15T12:49:55Z,MERGED,True,89,0,3,https://github.com/GroteGnoom,Add write_graph_dimacs unit test,2,[],https://github.com/igraph/igraph/pull/1603,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1603#issuecomment-760923695,"Part of #1592
Yes, it just outputs the source and target, even if they don't exist",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/1604,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1604#issuecomment-759812990,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?

I believe all other functions that work directly on the igraph_t object are stored in igraph_interface.h.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1604#issuecomment-759857624,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","two quick questions:

do we want this function to return igraph_bool_t instead of int?
I haven't learned how to run tests locally yet with the new CMake system. I tried to follow the pattern in .github/workflows/cmake... but it says 0% tests passed. Sorry about that, having a working local test suite would reduce the number of commits in these PRs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/1604#issuecomment-759867813,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?",hmm the test failure seems to be due to memory leaks in the erdos-renyi test? I'm not sure what's going on here... @ntamas?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1604#issuecomment-759972527,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","do we want this function to return igraph_bool_t instead of int?

That's probably a good idea.

I haven't learned how to run tests locally yet with the new CMake system.

You did compile the tests first with cmake --build . --target check (or simply make check)? Running them should be done using ctest, possibly including a configuration, e.g. ctest -C Debug, but I think that is Windows only.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,6,https://github.com/igraph/igraph/pull/1604#issuecomment-759987417,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Thanks, now it returns igraph_bool_t. I got it to test locally by using:
mkdir build
cd build
cmake ..
make
make check

and that already tests it. All good here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1604#issuecomment-760002114,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","that already tests it.

Ah, so make check both builds and runs the tests, even better. Just FYI, with ctest you can run specific tests with a regex specifier, e.g. ctest -R is_same_graph. That way, you can easily test only one test case. SImilarly, you can build only that test by invoking cmake --build . --target test_igraph_is_same_graph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,8,https://github.com/igraph/igraph/pull/1604#issuecomment-760034894,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","There is a reason, which is that it is the truth ;-)
But sure edit at will, nothing personal",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1604#issuecomment-760176571,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","do we want this function to return igraph_bool_t instead of int?

The rule of thumb is: if the function can fail, ever, then it should return an int with an igraph error code (zero if everything was OK), and the real result should be returned in an output argument. Failure can mean things like ""not enough memory to allocate auxiliary data structures"" as well. So, if we decide to return igraph_bool_t here, we commit ourselves to never use memory allocations inside the function, and to never use any igraph function that can fail on its own. I'm okay with that, just wanted to make sure that you are aware of it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1604#issuecomment-760180257,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","I'm not particularly happy with the direct usage of graph->ii, but there might be valid reasons for that.
Roughly speaking, anything that accesses the internals of an igraph_t object is considered to be part of the ""basic graph interface"". We are aiming for this interface to be as small as possible in order to make it easier for us to experiment with alternative graph representations. My plans for the future are to make the basic graph interface smaller, not larger; we already have several methods in the basic graph interface that could be moved outside:


igraph_empty() simply calls igraph_empty_attrs(), and I cannot really conceive any graph data structure where this would not be true, so igraph_empty() could be moved outside the basic API, leaving only igraph_empty_attrs() in there.


igraph_delete_vertices() delegates everything to igraph_delete_vertices_idx() so this could be removed from the basic API as well.


...and so on, and so on.
The point I'm trying to make here is that if we decide to reach into the internals of igraph_t in igraph_is_same_graph(), and then later on we decide to implement a new graph data structure to see whether we gain something in terms of efficiency, we would need to deal with the implementation of igraph_is_same_graph() again with this new graph data structure.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1604#issuecomment-760183345,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","By the way, I have seen the comment from @vtraag in the original issue where he advocates for this function being part of the core graph API. I'm okay with that as well, just wanted to make sure that we understand the implications. Also, if we do decide that this function becomes part of the core graph API, then we should make sure to document very carefully what the function needs to do (compare directednes, compare number of nodes, ensure that the edge sets are the same, not necessarily in the same order, but with same edge multiplicities -- so basically a ""multiset equality""), and what the function does not need to do (e.g., compare attributes). This is to help future implementors of other graph data structures to know what to deal with and what not to deal with.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,12,https://github.com/igraph/igraph/pull/1604#issuecomment-760186494,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Yes @ntamas that is clear. I agree with the goal to reduce the basic interface.
Double sorted edges are useful for this function, whether (1) they are sorted using an internal data structure like current ii or (2) by calling a public function to get the sorted edge ids (which is how ii is made in the first place, o'course).
If you prefer option 2 then such a public function needs to be written. Its implementation would currently rely on ii for speed but would need to change if we drop ii. Or we could make it slower and recompute the sorted edges pretending that we don't know about ii.
The bottom line is that if ii is just a source of worry we should just dump it and consider it deprecated. But if it's useful for internal functions like this then there's nothing wrong in using it.
Btw @szhorvat this whole discussion is exactly why I added the documentation line warning users that this function is internal.
edit: let's keep options open re memory allocation. I will change the signature to pass a pointer to igraph_bool_t",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,13,https://github.com/igraph/igraph/pull/1604#issuecomment-760192296,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","I'm thinking that if this function creates such headaches in the public API, we could move it to the file that contains other test utility functions and be done with it",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1604#issuecomment-760194413,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","I think we need a more precise terminology. Yes, this function igraph_is_same_graph should be considered part of the core graph API, as @ntamas formulated it. This is what I referred to as ""internal"" previously, but this is a misleading nomenclature it now seems, which is causing some confusion. It should be a public function, that can be used by users of the library, hence the declaration should be made in include/igraph_interface.h, as it is done now. If the function is not public, it should not be declared in include/igraph_interface.h. Hence, the comment by @szhorvat that we should not state in the documentation that this function is only for internal use, which I agree with.
It does imply, as @ntamas already observed, that this implementation is part of the core graph API, and hence, should be changed along with a different implementation.
Although it could technically be possible to move it outside the current graph representation, I think that would sacrifice too much on speed. At the moment the graph is already internally sorted, and you essentially need to perform exactly this operation in order to identify whether two graphs are identical (i.e. the exact same edges, even if the original edge ordering is different). That was the original reason why I proposed it should be part of the core graph API.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1604#issuecomment-760196394,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","if we decide to return igraph_bool_t here, we commit ourselves to never use memory allocations inside the function, and to never use any igraph function that can fail on its own. I'm okay with that, just wanted to make sure that you are aware of it.

Yes, this is a good point. I assumed that it could never fail because it does not call any other functions that can fail at the moment. However, that is not necessarily the case for future representations, because they are able to fail, for example because they do need to sort some edges. For that reason, I think you are correct, and the API should be declared with returning an int, and the result should be provided in a pointer/reference.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1604#issuecomment-760218201,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","A lot has happened here while I was out. In short, here are my preferences:

During the winter break I did think a bit about whether to make this part of the core API (i.e. messing with internal data structures), but didn't reach a definitive conclusion. I am weakly in favour of making it part of the core API, for performance reasons.
I am strongly in favour of returning an error code instead of returning a bool. Especially for the core API, stability is paramount, and it is not at all unlikely that if we change the graph data structure, it will become possible for this function to fail.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1604#issuecomment-760419828,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","hmm the test failure seems to be due to memory leaks in the erdos-renyi test? I'm not sure what's going on here... @ntamas?

This is now fixed (it wasn't a leak, but there was a problem, see #1606).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,18,https://github.com/igraph/igraph/pull/1604#issuecomment-760470124,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Aaargh, I was pushing my changes at the same time...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1604#issuecomment-760472070,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Aaargh, I was pushing my changes at the same time...

I'm sorry about that, I wanted to push these before you woke up, but my internet stopped working for a while ...
Feel free to overwrite my version (but please keep the docs).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,20,https://github.com/igraph/igraph/pull/1604#issuecomment-760472204,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Alright, it's too messy to have two people editing the code in parallel.
@szhorvat please ask before changing the code in my PRs next time. My understanding was that you were going to change the documentation text, not a bunch of other things too. In any case, please keep pushing here and then we can merge, I'm stopping my contribution to this PR now.
Things to fix now:

error codes are ints, not igraph_bool_t\
your tests should assert(!res) to be futureproof.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,21,https://github.com/igraph/igraph/pull/1604#issuecomment-760475296,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","@szhorvat in the tests, you still have to assert that the error code returned by the function is zero, to avoid issues in the future.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1604#issuecomment-760475951,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","I'm sorry, my intention was to merge it. I considered this to be basically complete save for documentation and a tedious detail about how it returns it result, which was easy enough to fix prior to merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,23,https://github.com/igraph/igraph/pull/1604#issuecomment-760476757,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","that's ok, but please add those asserts in the tests if that's our practice now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1604#issuecomment-760481655,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","that's ok, but please add those asserts in the tests if that's our practice now.

That's done now. Can you take a look with a fresh morning mind and if you're happy and the CI tests pass, then squash-and-merge it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,25,https://github.com/igraph/igraph/pull/1604#issuecomment-760483043,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Thank you @szhorvat!
It looks good to me.
@ntamas is the current practice to squash and merge or just merge? I remember a previous conversation on this topic but can't quite recall what the conclusion was, sorry about that",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/szhorvat,26,https://github.com/igraph/igraph/pull/1604#issuecomment-760489115,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","is the current practice to squash and merge or just merge?

It depends on the situation. When the commits are messy, and the commit messages assume a specific context that won't be apparent when reading them a year later, it should be squash-and-merge. I find it easier to work this way as I can just push many commits without having to keep all of them organized. The tradeoff is that the PR should be relatively small (so the final single commit does not contain too many things).
Sometimes, when the PR is too big, or if it touches on multiple things, it's better to keep commits separate. But then the PR author should make sure that the commits are all nice and well-structured, which can be a pain. This is the case in PR #1583 (and I very much regret choosing this path because it's a pain)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/iosonofabio,27,https://github.com/igraph/igraph/pull/1604#issuecomment-760495022,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?","Personally I never squash because you can see in the git DAG that those commits all came together by the same author(s) anyway, and a git DAG is not a showroom, I'd rather have it a little verbose than too terse.
Anyway, I don't usually merge my own PRs out of courtesy, @ntamas feel free to do either one, your call.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1604,2021-01-13T22:48:08Z,2021-01-15T07:09:52Z,2021-01-15T07:10:01Z,MERGED,True,180,0,5,https://github.com/iosonofabio,Add function igraph_is_same_graph for tests,11,[],https://github.com/igraph/igraph/pull/1604,https://github.com/ntamas,28,https://github.com/igraph/igraph/pull/1604#issuecomment-760700144,"Addressing #1599.
This relies on graph->ii which is a vector of edge ids, double sorted by source and target vertices. If that representation goes, we should adapt this function. The easiest way to do that would be to sort the edges ourselves in the same way inside the function.
edit: I should put a header somewhere. Which header file would be appropriate for this to be considered internal?",Thanks a lot guys!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1605,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1605#issuecomment-760272569,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","OK, I improved a number of things in stimulus.py and functions.def. It now does build correctly, and creates correct R code for the interface, so in principle, this could be merged. But since we are touching this now anyway, we might see if we can improve it in any other way. In particular, there seems to be a problem still on line 670, because pname is not properly defined for that case. That doesn't happen to be ever invoked, so it is not a problem currently, but it still is incorrect.
I won't be working on this anymore today, so if you want to do a further check with regards to this issue and other non-idiomatic Python 3 stuff @iosonofabio or @ntamas , feel free to have a go at it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1605#issuecomment-760476356,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","alright, @ntamas has already formatted everything ;-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1605#issuecomment-763693194,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","I think this is mostly done. I thought about updating all string formatting to use ''.format(...), but this seems quite a lot of work, and I cannot find a way how to do this automatically. Perhaps @ntamas or @iosonofabio you know of a way? Otherwise, as far as I am concerned, this is good to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1605#issuecomment-763704162,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","I thought about updating all string formatting to use ''.format(...)

It depends on which Python version you are targeting anyway. str.format() is soooo 2016 now that Python 3.6 has f-strings :)
So I'd say if we want to support older Python versions, then let's just leave the string formatting as it is because we need to use obsolete constructs to support old versions. If we drop support for Python 3.5 and earlier, then we should use f-strings where possible -- but maybe it's enough to upgrade the code if we stumble upon instances of old percent-style formatting and we are working on that part of the code anyway.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1605#issuecomment-763709331,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","Okay, I went through the PR and it looks good to me, apart from a few obsolete Python constructs that do not affect functionality. I think I'll just merge it now and we can tidy it up if we plan to work more on it in the future.
@vtraag What do you think about separating it to a repo on its own and including it as a submodule in rigraph?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1605#issuecomment-763728720,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","Thanks for all the observations still about some obsolete things. Clearly, I hand't seen f-strings yet, lagging behind apparently :)

@vtraag What do you think about separating it to a repo on its own and including it as a submodule in rigraph?

Yes, that might be a good idea. At least it detaches the functionality of stimulus from the igraph repository, which makes it a bit easier to separate the maintenance of the two. However, it also raises a couple of questions. The most essential piece of the functionality is the functions.def, and I am not yet sure what to do with it. If we keep it in the igraph repository, we still have the dependency on the igraph repository for that part still. If we put it in a separate stimulus repository, it would be strange to update that repository if igraph is updated. The other question regards the language specific code and type definitions. Right now, the language specific code is in stimulus.py, while ideally you would take that out and put it in the language specific repository (i.e. rigraph), as is now already the case for the language specific type definitions. I am not sure what is the best approach here, I will have to think about it. If you have any thoughts on it, please do share.
It seems most elegant to keep everything separate: functions.def in igraph, stimulus.py (the core) in stimulus, language type definitions (e.g. types-RR.def) and language code (e.g. RRCodeGenerator.py or something, to be developed) in language specific interfaces, i.e. rigraph. However, it may also make things a bit more complex to manage and coordinate.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1605#issuecomment-763756701,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","Well, yes, ideally the core stimulus package should be a language-independent backend that provides some functionality that allows us to generate glue code for higher-level interfaces. The part of the generator that is specific to a higher-level language should live in the repository that belongs to that particular higher-level language.
On the other hand, it doesn't hurt to do the first step now (i.e. moving stimulus.py out of the C igraph repo to its own) and then pluck out the R-specific parts in a later step.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1605#issuecomment-763859563,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","OK, let's see if we can move it outside to its own stimulus package. Do you have any idea why it is called stimulus? Something like CodeGenerator sounds a lot more logical, if a bit less poetic.
There's one more idea that I had. Perhaps we could make a simply C CodeGenerator that generates the appropriate C declarations for all functions. That way, we can check if the functions.def is still correct. What do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1605#issuecomment-765695899,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","Do you have any idea why it is called stimulus?

That's a pun that makes sense only in Hungarian. ""Interface generator"", abbreviated as inger (the original name of the script) means ""stimulus"" in Hungarian. stimulus sounded better :) I'm okay with renaming it to igraph-glue-code-generator or something like that if you can find a name that is short and snappy. :)

Perhaps we could make a simply C CodeGenerator

I'm not that familiar with the syntax of functions.def to decide whether it's possible at all. Even if it is, how would we compare the generated C declarations with the original ones? Shall we try to replace the headers with a generated one and see if the compilation still works?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1605,2021-01-13T23:31:26Z,2021-01-20T15:27:28Z,2021-01-23T20:27:01Z,MERGED,True,801,1061,5,https://github.com/vtraag,Fix/stimulus,12,[],https://github.com/igraph/igraph/pull/1605,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1605#issuecomment-766174221,"This PR upgrades stimulus.py to work correctly with Python 3 and removes the dependency on seqdist, by replacing it with OrderedDict.
It appeared there were many functions had missing DEPS specifications in functions.def, which lead to some problems during the upgrading of the code to Python 3. It turned out most were actually in functions that were not automatically translated by stimulus in the R interfaces. Nevertheless, they are now all corrected in the functions.def.
The upgraded code was tested in the R interface, and builds correctly. There still seem to be some issues, which I am looking into.","That's a pun that makes sense only in Hungarian. ""Interface generator"", abbreviated as inger (the original name of the script) means ""stimulus"" in Hungarian. stimulus sounded better :) I'm okay with renaming it to igraph-glue-code-generator or something like that if you can find a name that is short and snappy. :)

That's a nice one. We should definitely keep this name :)

I'm not that familiar with the syntax of functions.def to decide whether it's possible at all.

I believe it should not be too difficult.

Shall we try to replace the headers with a generated one and see if the compilation still works?

Yes, that was the idea indeed. I wasn't sure exactly how to do this, because when actually compiling the library, we of course rely not on the generic igraph.h include file, but on all other individual include files. This would imply we would need to generate separate include files, but this then becomes much more complex to generate and replace easily. So we will have to give this a bit more thought.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1607,2021-01-15T11:45:14Z,2021-01-15T12:40:28Z,2021-01-15T12:40:34Z,MERGED,True,74,38,4,https://github.com/GroteGnoom,"Add growing_random_game test, fix docs",1,[],https://github.com/igraph/igraph/pull/1607,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1607,"part of #1592
Docs change: The first vertex does not generate edges,
citation does not make loops","part of #1592
Docs change: The first vertex does not generate edges,
citation does not make loops",True,{}
igraph/igraph,https://github.com/igraph/igraph,1607,2021-01-15T11:45:14Z,2021-01-15T12:40:28Z,2021-01-15T12:40:34Z,MERGED,True,74,38,4,https://github.com/GroteGnoom,"Add growing_random_game test, fix docs",1,[],https://github.com/igraph/igraph/pull/1607,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1607#issuecomment-760919382,"part of #1592
Docs change: The first vertex does not generate edges,
citation does not make loops",Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1609,2021-01-16T12:50:21Z,2021-01-16T13:04:07Z,2021-01-16T13:04:15Z,MERGED,True,0,7,1,https://github.com/GroteGnoom,Remove nonlinear_barabasi_game declaration,1,[],https://github.com/igraph/igraph/pull/1609,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1609,"It was not implemented, because it had already been moved to
barabasi_game.
See also https://igraph.discourse.group/t/should-undefined-declaration-be-removed/592
igraph_nonlinear_barabasi_game is part of #1592","It was not implemented, because it had already been moved to
barabasi_game.
See also https://igraph.discourse.group/t/should-undefined-declaration-be-removed/592
igraph_nonlinear_barabasi_game is part of #1592",True,{}
igraph/igraph,https://github.com/igraph/igraph,1609,2021-01-16T12:50:21Z,2021-01-16T13:04:07Z,2021-01-16T13:04:15Z,MERGED,True,0,7,1,https://github.com/GroteGnoom,Remove nonlinear_barabasi_game declaration,1,[],https://github.com/igraph/igraph/pull/1609,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1609#issuecomment-761560205,"It was not implemented, because it had already been moved to
barabasi_game.
See also https://igraph.discourse.group/t/should-undefined-declaration-be-removed/592
igraph_nonlinear_barabasi_game is part of #1592",Thanks again!,True,"{'LAUGH': ['https://github.com/GroteGnoom'], 'THUMBS_UP': ['https://github.com/GroteGnoom']}"
igraph/igraph,https://github.com/igraph/igraph,1610,2021-01-16T14:22:50Z,2021-01-16T14:41:58Z,2021-01-16T14:42:05Z,MERGED,True,58,0,2,https://github.com/GroteGnoom,Add full_citation unit test,2,[],https://github.com/igraph/igraph/pull/1610,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1610,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1610,2021-01-16T14:22:50Z,2021-01-16T14:41:58Z,2021-01-16T14:42:05Z,MERGED,True,58,0,2,https://github.com/GroteGnoom,Add full_citation unit test,2,[],https://github.com/igraph/igraph/pull/1610,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1610#issuecomment-761571880,Part of #1592,"Can you update the copyright header please?
The igraph_rewire test is failing at the moment, that's expected (I'm working on it).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1610,2021-01-16T14:22:50Z,2021-01-16T14:41:58Z,2021-01-16T14:42:05Z,MERGED,True,58,0,2,https://github.com/GroteGnoom,Add full_citation unit test,2,[],https://github.com/igraph/igraph/pull/1610,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1610#issuecomment-761572101,Part of #1592,"Can you update the copyright header please?

:( Good catch, I though I updated everything. I'll fix it.
Thanks for the test info, I always get nervous when I see my tests fail. 🙂",True,{}
igraph/igraph,https://github.com/igraph/igraph,1610,2021-01-16T14:22:50Z,2021-01-16T14:41:58Z,2021-01-16T14:42:05Z,MERGED,True,58,0,2,https://github.com/GroteGnoom,Add full_citation unit test,2,[],https://github.com/igraph/igraph/pull/1610,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1610#issuecomment-761574563,Part of #1592,Thanks again! :-),True,{}
igraph/igraph,https://github.com/igraph/igraph,1611,2021-01-17T20:17:12Z,2021-01-17T21:40:02Z,2021-01-17T21:40:14Z,MERGED,True,70,2,3,https://github.com/GroteGnoom,"Add linegraph unit tests, add to docs",2,[],https://github.com/igraph/igraph/pull/1611,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1611,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1611,2021-01-17T20:17:12Z,2021-01-17T21:40:02Z,2021-01-17T21:40:14Z,MERGED,True,70,2,3,https://github.com/GroteGnoom,"Add linegraph unit tests, add to docs",2,[],https://github.com/igraph/igraph/pull/1611,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1611#issuecomment-761884856,Part of #1592,Thanks for the documentation clarification!,True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1612,2021-01-18T09:08:01Z,2021-01-18T10:10:09Z,2021-01-18T10:10:10Z,MERGED,True,64,1,3,https://github.com/GroteGnoom,"Add kautz unit test, add to docs",1,[],https://github.com/igraph/igraph/pull/1612,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1612,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1613,2021-01-18T20:09:15Z,2021-01-19T06:43:53Z,2021-01-19T06:43:53Z,MERGED,True,187,102,4,https://github.com/szhorvat,Add a canonical graph printer to test_utilities,3,[],https://github.com/igraph/igraph/pull/1613,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1613,"This PR adds a print_graph_canon graph printer to test_utilities.inc. It prints the graph with a sorted edge list, i.e. makes the printed representation non-dependent on the internal representation.
This is to aid @GroteGnoom with the tests he's been adding lately.
I sort the edge list manually, as I wanted to avoid poking around in the internal graph representation.
Two tests (igraph_full and igraph_tree) are updated to demonstrate that the printer works.","This PR adds a print_graph_canon graph printer to test_utilities.inc. It prints the graph with a sorted edge list, i.e. makes the printed representation non-dependent on the internal representation.
This is to aid @GroteGnoom with the tests he's been adding lately.
I sort the edge list manually, as I wanted to avoid poking around in the internal graph representation.
Two tests (igraph_full and igraph_tree) are updated to demonstrate that the printer works.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1615,2021-01-19T18:56:29Z,2021-01-21T13:00:09Z,2021-01-21T13:00:09Z,MERGED,True,2921,3587,22,https://github.com/szhorvat,Update Bliss to 0.74,7,[],https://github.com/igraph/igraph/pull/1615,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1615,"Upgrades Bliss to the just-released version 0.74, and therefore fixes #1171.","Upgrades Bliss to the just-released version 0.74, and therefore fixes #1171.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1615,2021-01-19T18:56:29Z,2021-01-21T13:00:09Z,2021-01-21T13:00:09Z,MERGED,True,2921,3587,22,https://github.com/szhorvat,Update Bliss to 0.74,7,[],https://github.com/igraph/igraph/pull/1615,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1615#issuecomment-763139373,"Upgrades Bliss to the just-released version 0.74, and therefore fixes #1171.","@ntamas I'd like to get a review on this, but please do not merge. I did not yet test the interruption support. I will do that tomorrow, then I'll merge it myself.
You can ignore the first commit. Look at the igraph-changes.md instead.
Please review the subsequent commits, in particular interruption support (note the global variable—avoiding this would require a few more changes to Bliss, I think).
Note that Bliss now uses C++11, therefore I had to enable support for that in the top-level CMakeLists.txt. Are we fine with this? I'm a but reluctant to try to patch Bliss for C++98 support ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1615,2021-01-19T18:56:29Z,2021-01-21T13:00:09Z,2021-01-21T13:00:09Z,MERGED,True,2921,3587,22,https://github.com/szhorvat,Update Bliss to 0.74,7,[],https://github.com/igraph/igraph/pull/1615,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1615#issuecomment-763872393,"Upgrades Bliss to the just-released version 0.74, and therefore fixes #1171.","@szhorvat Looks good to me so far! C++11 is okay, as well as the global variable for interruption support.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1616,2021-01-19T18:59:40Z,2021-01-19T21:10:23Z,2021-01-19T21:10:27Z,MERGED,True,86,4,3,https://github.com/GroteGnoom,Add new extended chordal ring unit test,5,[],https://github.com/igraph/igraph/pull/1616,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1616,"Part of #1592
See also:
https://igraph.discourse.group/t/extended-chordal-ring-ouputs-a-multigraph/596/2","Part of #1592
See also:
https://igraph.discourse.group/t/extended-chordal-ring-ouputs-a-multigraph/596/2",True,{}
igraph/igraph,https://github.com/igraph/igraph,1616,2021-01-19T18:59:40Z,2021-01-19T21:10:23Z,2021-01-19T21:10:27Z,MERGED,True,86,4,3,https://github.com/GroteGnoom,Add new extended chordal ring unit test,5,[],https://github.com/igraph/igraph/pull/1616,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1616#issuecomment-763143438,"Part of #1592
See also:
https://igraph.discourse.group/t/extended-chordal-ring-ouputs-a-multigraph/596/2",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1617,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1617#issuecomment-763620338,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","I just amended the list of functions in #1560. After this PR has merged, we can tick off individual items from that list.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1617#issuecomment-763622648,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Ha, for macOS the build fails with the message: error: self-comparison always evaluates to false for  !(max != max).
The whole point of this construction was to check for nan for max without explicitly relying on igraph_is_nan, because that introduces a dependency on the base type of the vector. Traditionally, the x != x would evaluate to true for x == nan, while for any other value this would evaluate to false. @ntamas, @szhorvat , you are on macOS, do you have any suggestions?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1617#issuecomment-763693384,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Nope, other than turning off the tautological-compare warning. It would be great if we could be selective about turning off the warning from CMake, preferably only for this single file and only for Clang, because this warning has the potential to catch bugs that would otherwise go unnoticed (one example I can think of is a comparison of if (x >= 0) where x is assumed to be signed but is in fact unsigned).
If it's too big of a hassle to be selective, then let's just turn off the warning for good.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1617#issuecomment-763698997,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","OK, I will think about whether there is another way to solve this issue, without requiring to turn off warning flags. The only reason for introducing this is that I wanted to be consistent with the NaN reporting: it should report the first such element, as it would for the maximal/minimal element. Perhaps there is a way to do this differently still.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1617#issuecomment-763701061,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Looks good to me, but can we add unit tests for the behaviour of igraph_vector_{which_}_{min,max} to ensure that it deals consistently with NaN values? (Especially considering that you have spotted inconsistent behaviour that you had to fix in this PR).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1617#issuecomment-763729437,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Looks good to me, but can we add unit tests for the behaviour of igraph_vector_{which_}_{min,max} to ensure that it deals consistently with NaN values? (Especially considering that you have spotted inconsistent behaviour that you had to fix in this PR).

Yes, good point, I though of doing this as well, but didn't get around to it anymore. I will include unit test for this, probably tomorrow.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1617#issuecomment-763900231,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","I added a test and corrected the spelling in the documentation. Please do not merge yet, I will still think about how to deal with the NaN comparisons on macOS.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/iosonofabio,9,https://github.com/igraph/igraph/pull/1617#issuecomment-763910276,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Perhaps
x + 1 > x
would be true except for nan? Or even
((x < 1) && (x + 1 > x)) || (x - 1 < x)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1617#issuecomment-763978096,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Sorry, the implementation is not correct anyway, I will correct it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1617#issuecomment-764000004,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","OK, now it is correct. Unfortunately, I see no way of working around a comparison that involves doing something like x != x. If we really don't want to turn off the warning for this file, I could make specific implementations that differ for the integer and floating point base types.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1617#issuecomment-764547004,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Almost there, I'm fixing the docs and then I'll merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/GroteGnoom,13,https://github.com/igraph/igraph/pull/1617#issuecomment-764590089,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Ha, for macOS the build fails with the message: error: self-comparison always evaluates to false for  !(max != max).
The whole point of this construction was to check for nan for max without explicitly relying on igraph_is_nan, because that introduces a dependency on the base type of the vector.

Are you sure igraph_is_nan doesn't just work, even for ints?
#include <math.h>

int my_isnan(double a) {
	return isnan(a);
}

int main() {
	int a = 5;
	return my_isnan(a);
}

works. If the base type is int, it gets changed into a double, and still gives the correct result.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1617#issuecomment-764593704,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","Docs are now fixed; I think the build will succeed this time. @vtraag once you think that the NaN testing is sorted out adequately, this is ready to merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1617,2021-01-20T13:49:42Z,2021-01-21T12:36:13Z,2021-01-21T12:36:13Z,MERGED,True,377,209,12,https://github.com/vtraag,Disallowing NaN weights for several path based functions,10,[],https://github.com/igraph/igraph/pull/1617,https://github.com/vtraag,15,https://github.com/igraph/igraph/pull/1617#issuecomment-764604766,"This partially fixes #1560 for path based functions by disallowing NaN edge weights. Although it could theoretically be argued that some functions may still return proper value for some limited NaN edge weights, this quickly becomes quite challenging. This PR ensures that proper errors are returned in case there is any NaN edge weight, and also corrects the documentation.
In addition, the vector functions igraph_vector_min and igraph_vector_max are now guaranteed to return NaN whenever an NaN value appears anywhere in the vector. Previously, this was only the case if the NaN happened to appear in the first position (i.e. index 0).","OK, I now changed it to an explicit isnan, to avoid any potential probles with x != x type of formulation. Possibly, this might have been optimised away by clang on macOS. This way, I think it should build fine on all platforms.
And thanks for the documentation correction!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1621,2021-01-21T20:44:00Z,2021-01-22T10:07:49Z,2021-01-22T10:07:49Z,MERGED,True,83,0,3,https://github.com/GroteGnoom,"Add callaway traits unit tests, add error on zero distribution",1,[],https://github.com/igraph/igraph/pull/1621,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1621,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1621,2021-01-21T20:44:00Z,2021-01-22T10:07:49Z,2021-01-22T10:07:49Z,MERGED,True,83,0,3,https://github.com/GroteGnoom,"Add callaway traits unit tests, add error on zero distribution",1,[],https://github.com/igraph/igraph/pull/1621,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1621#issuecomment-765202889,Part of #1592,@szhorvat I think the documentation fails after 6f6b6a2,True,{}
igraph/igraph,https://github.com/igraph/igraph,1622,2021-01-22T16:41:54Z,2021-01-23T12:15:30Z,2021-01-23T12:15:31Z,MERGED,True,71,0,2,https://github.com/GroteGnoom,Add new rewire directed edges unit test,2,[],https://github.com/igraph/igraph/pull/1622,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1622,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1624,2021-01-23T11:55:42Z,2021-02-15T12:24:45Z,2021-02-15T12:24:45Z,MERGED,True,470,265,6,https://github.com/szhorvat,Update traits-based games,11,[],https://github.com/igraph/igraph/pull/1624,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1624,"This PR makes the changes detailed in #1620 .
Details:

Add const to input-only arguments.
Improve docs (e.g. edges_per_step is not the number of edges added, but the number of edges tried to be added with some probability)
callaway_traits and establishment now return vertex types in a new output argument
callaway_traits and establishment: type_dist is now allowed to be NULL in which case it is taken to be uniform
improve parameter checks
asymmetic_preference: allow different number of in- and out-types, reorder argument to always be out-types, then in-types as this feel natural given the interpretation of the type distribution matrix and preference matrix (rows: out, cols: in).
update old tests from return-style to ASSERT-style (otherwise the leak detector complains on failure)","This PR makes the changes detailed in #1620 .
Details:

Add const to input-only arguments.
Improve docs (e.g. edges_per_step is not the number of edges added, but the number of edges tried to be added with some probability)
callaway_traits and establishment now return vertex types in a new output argument
callaway_traits and establishment: type_dist is now allowed to be NULL in which case it is taken to be uniform
improve parameter checks
asymmetic_preference: allow different number of in- and out-types, reorder argument to always be out-types, then in-types as this feel natural given the interpretation of the type distribution matrix and preference matrix (rows: out, cols: in).
update old tests from return-style to ASSERT-style (otherwise the leak detector complains on failure)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1624,2021-01-23T11:55:42Z,2021-02-15T12:24:45Z,2021-02-15T12:24:45Z,MERGED,True,470,265,6,https://github.com/szhorvat,Update traits-based games,11,[],https://github.com/igraph/igraph/pull/1624,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1624#issuecomment-765912247,"This PR makes the changes detailed in #1620 .
Details:

Add const to input-only arguments.
Improve docs (e.g. edges_per_step is not the number of edges added, but the number of edges tried to be added with some probability)
callaway_traits and establishment now return vertex types in a new output argument
callaway_traits and establishment: type_dist is now allowed to be NULL in which case it is taken to be uniform
improve parameter checks
asymmetic_preference: allow different number of in- and out-types, reorder argument to always be out-types, then in-types as this feel natural given the interpretation of the type distribution matrix and preference matrix (rows: out, cols: in).
update old tests from return-style to ASSERT-style (otherwise the leak detector complains on failure)","@GroteGnoom : I'm planning to touch establishment_game, so please wait with tests for that function. If you're already working on it,  let me know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1624,2021-01-23T11:55:42Z,2021-02-15T12:24:45Z,2021-02-15T12:24:45Z,MERGED,True,470,265,6,https://github.com/szhorvat,Update traits-based games,11,[],https://github.com/igraph/igraph/pull/1624,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1624#issuecomment-765936560,"This PR makes the changes detailed in #1620 .
Details:

Add const to input-only arguments.
Improve docs (e.g. edges_per_step is not the number of edges added, but the number of edges tried to be added with some probability)
callaway_traits and establishment now return vertex types in a new output argument
callaway_traits and establishment: type_dist is now allowed to be NULL in which case it is taken to be uniform
improve parameter checks
asymmetic_preference: allow different number of in- and out-types, reorder argument to always be out-types, then in-types as this feel natural given the interpretation of the type distribution matrix and preference matrix (rows: out, cols: in).
update old tests from return-style to ASSERT-style (otherwise the leak detector complains on failure)","@GroteGnoom : I'm planning to touch establishment_game, so please wait with tests for that function. If you're already working on it, let me know.

I've skipped it for now, thanks for asking. Go ahead!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1625,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1625#issuecomment-765928826,Part of #1592,"I should have realized this earlier: asserting that the return value is IGRAPH_SUCCESS is usually unnecessary because the default error handling function will abort anyway in that case. The exception is when you set an error handling function yourself, e.g. to be able to test non-successful values.
That said, please do not remove any existing assertions about this, as they do not hurt, and they would become useful if the error handler were changed in a test.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1625#issuecomment-765935818,Part of #1592,"Also, thanks for paying attention to the details and fixing or bringing up anything that looks off!",True,{'LAUGH': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1625#issuecomment-765944284,Part of #1592,"@szhorvat I only now realize that this has the same issue as noticed in #1620, the length of the preferences vector is 1 + pagebins. So you can infer one from the other instead of checking they are equal. Should that be fixed here too?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1625#issuecomment-766003146,Part of #1592,"I should have realized this earlier: asserting that the return value is IGRAPH_SUCCESS is usually unnecessary because the default error handling function will abort anyway in that case. The exception is when you set an error handling function yourself, e.g. to be able to test non-successful values.
That said, please do not remove any existing assertions about this, as they do not hurt, and they would become useful if the error handler were changed in a test.

Yes, for this reason I think I'll keep on adding them. If you still slightly prefer them not being there I will of course leave them out :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1625#issuecomment-766389543,Part of #1592,"When you write new error messages, or touch old ones, please use start with a capital letter and end in a fullstop. I know that this is not how most error messages are at the moment, but we'll update them eventually.
Unless the meaning of parameter names are obvious, it's best to spell out what they mean in the error message. This is because the message may be seen by e.g. a python-igraph user who doesn't know what the C function looks like.
Some guidelines are here: https://github.com/igraph/igraph/wiki/Error-reporting-guidelines
Could we change the pagebins parameter name to agebins, to make it less confusing? (In the documentation too, not just the code.) I know it will conflict with the agebins variable, but is that variable needed at all? It seems the purpose might be to avoid compiler warnings about mixing long with igraph_integer_t. It could either be removed or renamed.

@szhorvat I only now realize that this has the same issue as noticed in #1620, the length of the preferences vector is 1 + pagebins. So you can infer one from the other instead of checking they are equal. Should that be fixed here too?

Let's leave it for now. Later we can add a convenient default for the preference vector when NULL is supplied, such as the cubic decay default used by the R interface now: https://igraph.org/r/doc/sample_last_cit.html
@ntamas Any opinions on this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1625#issuecomment-766401826,Part of #1592,The default used by the R interface seems good to me.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/1625#issuecomment-766424466,Part of #1592,"When you write new error messages, or touch old ones, please use start with a capital letter and end in a fullstop. I know that this is not how most error messages are at the moment, but we'll update them eventually.

Can we have an IGRAPH_ERRORF macro so I can provide better info (using igraph_errorf) without adding the line and file manually? That would also clear up things a lot.
I'm also happy to clean up error messages in general for the functions I'm working with.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1625#issuecomment-766604852,Part of #1592,"Now that we have switched to C99 a while ago I have nothing against having IGRAPH_ERRORF, provided that MSVC can cope with it.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1625#issuecomment-767442198,Part of #1592,"LGTM, except for the typo in recieved :)",True,{'LAUGH': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1625#issuecomment-767458753,Part of #1592,The failing build is because of connection time-outs to github.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1625,2021-01-23T12:07:46Z,2021-01-26T11:48:33Z,2021-01-26T11:48:41Z,MERGED,True,147,15,4,https://github.com/GroteGnoom,Add lastcit game unit tests,6,[],https://github.com/igraph/igraph/pull/1625,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1625#issuecomment-767491550,Part of #1592,Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1626,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1626#issuecomment-796611537,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","I think this is a great start, and it similar in some ways to an earlier integer transition attempt I made privately.
There are some concerns though I would like to note:

One main goal is to make use of 64-bit indices when available. This is accomplished this PR.
Another main goal (that I had in mind) is to have a simple and predictable way to work. Having two types is not in this spirit. I would still like to see a single public integer type. I would like to have some easy to understand properties and guarantees for the single integer type, such as:

It can index anything. Vector indices and sizes can be this type. Vertex and edge IDs can be this type.
This makes it clear what the limits are on things such as graph sizes. If something can't be indexed with this type, then it is too large, and not supported.

This is only partially accomplished by this PR.

Side note: Should we end up using more than one type anyway, I don't like the names int and long because people will assume that these are related to C's own int and long but they are not the same kind of thing.

The reason @vtraag gives for having two types is so that we can interface with other libraries. I encountered this problem as well, with CXSparse as well as with BLAS/LAPACK/ARPACK. However, simply having two types will not solve this problem entirely because the sizes of types often differ from platform to platform. If, for example, we choose our_int to be int32_t and it matched libx_int from libX on one platform, it may not match it on a different platform. Thus we still would not be able to simply have our_int and our_long and always use our_int with libX on any platform. It may be (and it is!) the case that libx_int == our_long on Linux but libx_int == our_int (and libx_int != our_long) on Windows.
How do we deal with external libraries then?  I think the only general and manageably simple way is to convert data to that library's format (i.e. copy). Yes, this can affect performance, so we need to consider carefully when this solution is or isn't acceptable. A slightly faster but also slightly more complicated solution is to do a full copy/conversion when there is no match between types, and pass arrays unmodified (no copying) when there is a match. We would need to set up facilities for this.
Which libraries matter in practice?

CXSparse. Good news: this library is in fact adaptable to different integer sizes. It is not going to be a problem.
Fortran-origin things, namely BLAS/LAPACK/ARPACK. This is where it got unpleasant when I did my own exercise in changing igraph's integer type. However, the use of integers does not seem to be performance-critical with these libraries, meaning that it is okay to convert/copy without a major peformance impact.  Additionally, some implementations of these libraries come in multiple versions, with different integer sizes (MKL always does, but some other more common implementations don't). In the end, this stems from the fact that these libraries use Fortran's integer type which may have different sizes depending on the compiler ...

One more note about having multiple types:  When I did my own exercise in this, it seemed to me that CXSparse can be handled, but I have not done it (so I may have missed some things). I focused on BLAS mostly. When I did, I found it useful to introduce an internal  (not public!) fortran_int and igraph_vector_fortran_int_t type just so I can manage vectors more easily, can convert from an igraph_vector_int_t to an  igraph_vector_fortran_int_t.  The purpose of these types was simply to make it easier to interface with BLAS and convert igraph's native integers to Fortran-compatible integers.

In summary, I would do the following:


I would still like to have one single predictable and easy to understand integer type for igraph's public API, as well as the majority of internal igraph programming.


When interfacing with other libraries, it may be convenient to introduce additional vector types, so we can write more concise code when dealing with those libraries. I think these types should be strictly private. It seems to me that in theory we may need different such types in order to interface with different libraries. However, at present, the only one to deal with is BLAS/LAPACK/ARPACK. So there would be only one such thing for now.


CXSparse comes with multiple APIs, using multiple types. There are all combinations of double / complex double and int / UF_long where UF_long is designed to be precisely what we also want to do in igraph: 32-bit on 32-bit platforms and 64-bit on 64-bit platforms (including Windows 64). We should use the dl API (instead of the current di), i.e. double with UF_long, and let CMake verify at configure time that UF_long is indeed the same as igraph's native integer. This is true on every system I am familiar with, but there are weird things out there, so it's best to check ...  Sparse arrays are very useful when working with graphs, and I would like to ensure that any graph that igraph supports can be converted to sparse adjacency matrix. The dl API will allow this.


Additionally, I would try to do:

It would be a nice optimization to avoid copying/converting to Fortran libraries (BLAS, etc.) when their integer type matches igraph's. This would even make it possible to link to a 64-bit int BLAS when available and avoid copying. I think this is doable without too much trouble, but if not (if problems arise), I believe that there will be no serious performance impact from just copying/converting integer on every platform, as BLAS/LAPACK focus on floating-point and rarely use integer vectors.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1626#issuecomment-809619444,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","I am about to jump on this bandwagon but I was wondering whether you guys know about ways to make compilers be super picky about integer upcasts / downcasts (i.e. implied conversion from 32-bit to 64-bit or vice versa). I know that there are tons of MSVC warnings that are related to this, but I would be interested to know whether it's possible to turn on something like this for Clang / gcc. I believe it would be useful in this stage so we can spot places where we could be running into problems by mixing integer types.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1626#issuecomment-809626769,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","Also, I tend to agree with @szhorvat, it would be great if we could have one public integer type and make that configurable by the user. I would even try to keep on calling it igraph_integer_t to avoid confusing the user (just imagine how carefully we would need to explain that a new igraph_int_t is not the same as the old igraph_integer_t, and no matter how careful we are, many users would not read it anyway because not everyone is fond of reading changelogs).
@vtraag when you were creating this PR, were you simply running search-and-replace on the code w.r.t. the integer types or did you go through all source files manually? What was the general process? I would try to replicate what you did on the current develop branch just to get a feeling of it; merging develop into your PR creates lots of conflicts so I would not attempt that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1626#issuecomment-809688613,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","Overall, I agree with @szhorvat that it would be preferable to have a single (public) integer type.
The suggestion to make integer types that are necessary to deal with external libraries strictly private sounds quite reasonable. Doing something similar for vector types that require different integer types is similarly reasonable. Dealing with non-matching and matching integer types separately sounds slightly more complicated, but it might be doable. I am not sure if this introduces fragilities into the build process and/or during runtime, and how large the gain would be of doing this in more complicated ways. I would be in favour of keeping it as simple as possible, if the performance hit is not too large.
I agree that igraph_integer_t is the preferable name. The only reason that I started using igraph_int_t and igraph_long_t is because I needed different types. If we make any other integer types strictly internal, I agree that the proper name for the public type should be igraph_integer_t.
I had not noticed that CXSparse actually has 64-bit type functionality, I believe that the X actually stands for that extension. That will already make that part of the codebase easier to work with. Nonetheless, if the integer type is configurable, we then might have to switch implementations, depending on whether the integer type is 32 or 64-bit, i.e. call cs_di_xxx or cs_dl_xxx respectively.
@ntamas, most of this PR indeed needs to be redone against the most recent develop branch. My approach was pretty simple, and you can mostly trace this via the long list of commits :) I basically just substituted every integer type to the new integer type, which initially was still called igraph_integer_t. This raises a whole list of issues, which later commits simply try to correct. There are number of issues that you will run into again when redoing this:

Variadic arguments are never correctly interpreted as int64_t, they should always be interpreted as int (assuming int type will always work with variadic arguments). Perhaps we should further research this in order to be 100% sure that int will always be correctly interpreted. Since variadic argument will be limited anyway, this is not so problematic I believe.
Random number generators use particular types. Since they may do something with bitwise operators, I think it is best to leave these as is. Presumably, anything that is ever done with any bitwise operators will have to be carefully checked. I had not yet check this in-depth, but this should obviously this done for a proper implementation.
There are a few instances in which unsigned types are used. As we all agree, we should preferably have only a single (public) integer type. I think it is fine to leave the unsigned types as they are, instead of creating separate private unsigned integer types, assuming they work well with the integer types that will be implemented.
There are a few instances of shorts, I believe I mostly left them as they were, but I am not 100% sure.

I haven't tried any tool that checks upcasting/downcasting and reports potential problems. I did do this for Java using IntelliJ, perhaps CLion would also have similar capabilities, I'm not sure. I guess that something like that should also be possible using clang, it seems that wimplicit-int-conversion might do the trick.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1626#issuecomment-809994422,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","I had not noticed that CXSparse actually has 64-bit type functionality, I believe that the X actually stands for that extension. That will already make that part of the codebase easier to work with. Nonetheless, if the integer type is configurable, we then might have to switch implementations, depending on whether the integer type is 32 or 64-bit, i.e. call cs_di_xxx or cs_dl_xxx respectively.

The dl interface is not quite a 64-bit version one, but one that is 64-bit on 64-bit platforms and 32-bit on 32-bit one. We only need to use the dl functions, never the di ones. The dl functions use 32-bit integers on 32-bit platforms.
In other words, we are lucky and CXSparse's ""UFlong"" type aligns with what we want igraph's integer type to be.

Dealing with non-matching and matching integer types separately sounds slightly more complicated, but it might be doable. I am not sure if this introduces fragilities into the build process and/or during runtime, and how large the gain would be of doing this in more complicated ways. I would be in favour of keeping it as simple as possible, if the performance hit is not too large.

Agreed.
This will only affect BLAS/LAPACK/ARPACK, which do not use integers extensively. Therefore, copying/covnerting integer types before passing to BLAS/LAPACK/ARPACK functions will likely not affect performance noticeably.
It's good to note that these Fortran packages often come in two versions on 64-bit platforms: The LP64 version uses 32-bit integers and the ILP64 one uses 64-bit integers. LP64 is more common, and some BLAS implementations do not seem to support ILP64 at all (e.g. Apple's). Also, most distros / package managers include LP64 versions only.
For all these reasons it might be easier to just go with LP64 and copy/convert integers. However, given the amount of work we need to spend on the integer conversion anyway, it would be good to prepare for all eventualities, and make it so that it would not be too much work to move to ILP64 in the future.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1626#issuecomment-810002763,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","The dl interface is not quite a 64-bit version one, but one that is 64-bit on 64-bit platforms and 32-bit on 32-bit one. We only need to use the dl functions, never the di ones. The dl functions use 32-bit integers on 32-bit platforms.
In other words, we are lucky and CXSparse's ""UFlong"" type aligns with what we want igraph's integer type to be.

For most of the cases, yes, I would agree. However, R may be the exception here. If I understood correctly, the R interface doesn't have 64-bit integers. There are two solutions to this. The easiest one it to make the type configurable so that it does represent 32-bit integers, also on 64-bit platforms in order to accommodate for this for R. This way, it seamlessly integrated with R. The downside of this is that R will always need a special treatment. The alternative would be to always translate integers to whatever type R desires in the C-R interface.
The latter solution would have my preference I think. I would be in favour of getting rid of all R specifics in the C core library, so that, ultimately, it should be possible for the R interface to simply link to an external igraph library (which then also has fewer CRAN-related requirements). Realistically, we cannot expect to do this until a 1.0 release is made. Nonetheless, if we want to make the integer type configurable, we might still need to accommodate for this in our interaction with CXSparse. The question is whether we really want to make it configurable or not.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1626#issuecomment-810022632,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","Right, of course: UFlong doesn't fully align with our type as we might want ours to be configurable (potentially 32-bit on 64-bit).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1626#issuecomment-810048105,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","Note to ourselves: we need to make IGRAPH_PRId (the printf format specifier for igraph_integer_t) public if we go down this road. Right now it's in a public header but the comment says that it is ""for internal use only"". We need to provide a portable way for users to print an igraph_integer_t without casting, no matter whether it's 32-bit or 64-bit (and we need to explain in the documentation that igraph_integer_t can be 32-bit or 64-bit).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1626#issuecomment-815512624,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","For reference, this also has to be changed, and in practice it's much more important than the typedef of igraph_integer_t:
https://github.com/igraph/igraph/blob/master/include/igraph_pmt.h#L77
Changing igraph_integer_t alone won't lead to many compilation errors, but changing the type in the vector will.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1626#issuecomment-815694640,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","@szhorvat  This is probably something we can change right now, even in master, without breaking things:
diff --git a/include/igraph_pmt.h b/include/igraph_pmt.h
index e97b27422..35f492cdb 100644
--- a/include/igraph_pmt.h
+++ b/include/igraph_pmt.h
@@ -74,9 +74,9 @@
     #define EQ(a,b) ((a && b) || (!a && !b))

 #elif defined(BASE_INT)
-    #define BASE int
+    #define BASE igraph_integer_t
     #define SHORT int
-    #define OUT_FORMAT ""%d""
+    #define OUT_FORMAT ""%"" IGRAPH_PRId
     #define ZERO 0
     #define ONE 1
     #define MULTIPLICITY 1
All the tests still pass after making this change; no wonder since igraph_integer_t is an alias for int at the moment. Things start to break if I also change igraph_integer_t to be an int64_t, because then people who potentially used printf(""%d"") to print an element of an igraph_vector_int_t will use the wrong format string.",True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1626#issuecomment-816516927,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","So I'm going ahead with the patch proposed above. Note that strictly speaking this change invalidates all code where we have an igraph_vector_int_t and we take the address of one of its elements and store it in an int*. It works right now because igraph_integer_t aligns with int, but it will break in the future when we change the type that igraph_integer_t points to.
Therefore, what I'm doing now is that I'm temporarily changing igraph_integer_t to an int64_t and identify all the places in the code where the compiler complains about incompatible pointer types, and I'm fixing it where possible. Then I'll switch igraph_integer_t back to int in order not to break the API. I was wondering whether I should commit this to master or develop; I'm leaning towards develop even if it is not a breaking change. Any objections?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1626#issuecomment-816518348,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!",I think this is fine for master. I was actually quite surprised that you considered vector_int_t to have a different base type than igraph_integer_t. I always assumed that these two are the same.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1626#issuecomment-816525732,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","In other words, we are lucky and CXSparse's ""UFlong"" type aligns with what we want igraph's integer type to be.

Well, the match is not 100% perfect. It is true that UFlong is 64 bits on 64-bit platforms, but on macOS both long int and long long int are 64 bits. UFlong is defined to be a long. If I naively change igraph_integer_t to be an int64_t, then I get a long long on macOS and the compiler throws warnings all around the places because long long* is incompatible with long*. So it is not enough to match the sizes; we need to match the exact types.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1626#issuecomment-816532117,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","We have to work with whatever type CXSparse supports. It supports a 32-bit one and a 64-bit one. On all platforms of relevance, all 32-bit types have the same representation, and all 64-bit ones have the same representation again.
There is the annoyance that to C, they may be different types and there will be warnings. That is what it is: one has to deal with it in some way. I have seen the same problem before, and I do not think there is any nice and clean way around it. Libraries (including the C standard library) will sometimes use different types to get an integer of a certain width. One library's 64-bit type may be long and another's a long long, and whether there is a match will be platform dependent. There will always be some platform where there's a mismatch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1626#issuecomment-816542786,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","CXSparse actually allows you to override UF_long to whatever you want, so one option is to pick a type in igraph and then override UF_long, UF_long_max and UF_long_id (which is the printf format specifier) as needed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1626#issuecomment-816546446,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","CXSparse actually allows you to override UF_long to whatever you want, so one option is to pick a type in igraph and then override UF_long, UF_long_max and UF_long_id (which is the printf format specifier) as needed.

That is an option for a bundled CXSparse, but not an external CXSparse. Or am I missing something?
(However: I do not think there's anything wrong with enforcing using a bundled CXSparse.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/1626#issuecomment-816554295,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!","You are right, indeed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/apps/stale,19,https://github.com/igraph/igraph/pull/1626#issuecomment-856734710,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1626,2021-01-24T23:35:07Z,2021-06-08T15:30:35Z,2021-06-08T15:30:35Z,CLOSED,False,10994,11670,537,https://github.com/vtraag,Fix integer types,21,['stale'],https://github.com/igraph/igraph/pull/1626,https://github.com/ntamas,20,https://github.com/igraph/igraph/pull/1626#issuecomment-856873159,"This PR is an attempt at fixing integer types, as previously discussed in issue #1450.
This attempt is in essence quite straightforward, I have tried to make all internal integers that were internally used 64-bits, by introducing a new igraph_long_t type, which is typedefed as int64_t. The existing igraph_integer_t type is changed to be named igraph_int_t and is typedefed as int32_t. Unfortunately, we must maintain both integer types for compatibility with external libraries (e.g. CXSparse), which expect int's to be provided. Hence, where needed, the integer type is igraph_int_t, but where possible the integer type is igraph_long_t. Similar changes were made for integer vectors (and other types), that are now changed to igraph_vector_long_t where possible.
In addition, I added an additional igraph_error_t, which is simply typedefed as an int. This is to ensure that the error code can always be interpreted as an int, but in practice it should always refer to an item of the igraph_error_type_t enumeration. All functions are changed accordingly, so that functions that return an error code now return igraph_error_t instead of some integer type. This makes the return type a bit more clear.
The library does build correctly, as do all tests. Some still fail however, which I need to look into still. Nonetheless, I already wanted to share this with you for feedback.
Regarding the configurability of the integer types, this is not yet done. But obviously, if we only use internal types consistently anyway (i.e. never an int or long, but only igraph_int_t and igraph_long_t), the configurability is (in theory) straightforward. Do note of course that when forcing an igraph_long_t to be 32-bits for compatibility with R also does limit internal integer sizes. Whether this is an immediate problem is difficult to see. The alternative solution would be to have some separate igraph_public_integer_t or something which is always only used for the public API, so that we can always use 64-bit integers internally and 32-bit integers in the public API, if R needs it. Of course, this will take quite some additional work.
Anyway, comments are welcome!",People interested in the progress of the 64-bit integer transition should follow the feature/int-size-64-bit branch instead of this PR so I'm closing this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1627,2021-01-25T14:18:31Z,2021-01-25T18:02:24Z,2021-01-25T18:03:06Z,MERGED,True,150,2,5,https://github.com/GroteGnoom,"Add WARNINGF, ERRORF and FATALF macros",3,[],https://github.com/igraph/igraph/pull/1627,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1627,"Also discussed at
https://igraph.discourse.group/t/the-unit-tests-thread/597/6","Also discussed at
https://igraph.discourse.group/t/the-unit-tests-thread/597/6",True,{}
igraph/igraph,https://github.com/igraph/igraph,1627,2021-01-25T14:18:31Z,2021-01-25T18:02:24Z,2021-01-25T18:03:06Z,MERGED,True,150,2,5,https://github.com/GroteGnoom,"Add WARNINGF, ERRORF and FATALF macros",3,[],https://github.com/igraph/igraph/pull/1627,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1627#issuecomment-766957630,"Also discussed at
https://igraph.discourse.group/t/the-unit-tests-thread/597/6",Thanks again! I'm happy with this but I'll leave it to @ntamas to merge.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1627,2021-01-25T14:18:31Z,2021-01-25T18:02:24Z,2021-01-25T18:03:06Z,MERGED,True,150,2,5,https://github.com/GroteGnoom,"Add WARNINGF, ERRORF and FATALF macros",3,[],https://github.com/igraph/igraph/pull/1627,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1627#issuecomment-766959903,"Also discussed at
https://igraph.discourse.group/t/the-unit-tests-thread/597/6","Actually, there is one thing I forgot: can you please add these new macros to doc/error.xxml, so that they would be included in the documentation?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1627,2021-01-25T14:18:31Z,2021-01-25T18:02:24Z,2021-01-25T18:03:06Z,MERGED,True,150,2,5,https://github.com/GroteGnoom,"Add WARNINGF, ERRORF and FATALF macros",3,[],https://github.com/igraph/igraph/pull/1627,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1627#issuecomment-767005066,"Also discussed at
https://igraph.discourse.group/t/the-unit-tests-thread/597/6",Thanks a lot!,True,{'HOORAY': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1629,2021-01-26T16:16:10Z,2021-02-10T15:05:57Z,2021-02-10T15:05:57Z,MERGED,True,275,27,4,https://github.com/GroteGnoom,Add new barabasi aging game unit test ,14,[],https://github.com/igraph/igraph/pull/1629,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1629,"One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.","One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1629,2021-01-26T16:16:10Z,2021-02-10T15:05:57Z,2021-02-10T15:05:57Z,MERGED,True,275,27,4,https://github.com/GroteGnoom,Add new barabasi aging game unit test ,14,[],https://github.com/igraph/igraph/pull/1629,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1629#issuecomment-767706245,"One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.",Thanks for the PR! I'd like to take a closer look tomorrow before merging. Something looks off in the documentation (including in the original version).,True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1629,2021-01-26T16:16:10Z,2021-02-10T15:05:57Z,2021-02-10T15:05:57Z,MERGED,True,275,27,4,https://github.com/GroteGnoom,Add new barabasi aging game unit test ,14,[],https://github.com/igraph/igraph/pull/1629,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1629#issuecomment-776584488,"One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.","@gaborcsardi :
The documentation of the aging_bin parameter in the C interface was inconsistent with what this argument actually did.
The (detailed) C docs said that aging_bin controls the bin width, i.e. age increases by 1 after aging_bin steps. In reality, aging_bin controlled the number of bins. The bin width was computed as no_of_nodes / aging_bin + 1 (which IMO is a bit weird due to the integer division). The R docs are consistent with what the function actually did.
@gaborcsardi Which fix do you prefer? Change the C docs or change what the function does? This PR now changes what the function does.
The same question applies to igraph_recent_degree_aging_game. These two functions should be consistent with each other.
This is an old function with probably a niche application, so perhaps we don't want to change what it does at this point.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1629,2021-01-26T16:16:10Z,2021-02-10T15:05:57Z,2021-02-10T15:05:57Z,MERGED,True,275,27,4,https://github.com/GroteGnoom,Add new barabasi aging game unit test ,14,[],https://github.com/igraph/igraph/pull/1629,https://github.com/gaborcsardi,4,https://github.com/igraph/igraph/pull/1629#issuecomment-776586082,"One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.","This is an old function with probably a niche application, so perhaps we don't want to change what it does at this point.

Yeah, agreed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1629,2021-01-26T16:16:10Z,2021-02-10T15:05:57Z,2021-02-10T15:05:57Z,MERGED,True,275,27,4,https://github.com/GroteGnoom,Add new barabasi aging game unit test ,14,[],https://github.com/igraph/igraph/pull/1629,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1629#issuecomment-776648718,"One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.",@GroteGnoom I reverted the meaning of aging_bins. Please have another look at the test program before merging.,True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1629,2021-01-26T16:16:10Z,2021-02-10T15:05:57Z,2021-02-10T15:05:57Z,MERGED,True,275,27,4,https://github.com/GroteGnoom,Add new barabasi aging game unit test ,14,[],https://github.com/igraph/igraph/pull/1629,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1629#issuecomment-776747999,"One issue that remains is that the first number in the outseq vector is ignored. Is that supposed to happen?
A bug I fixed is that the definition of age_bin didn't fit with the documentation. It divided up the nodes into bins instead of specifying the nodes required for a time step.
I find this function really confusing. I can barely get it to do what I want, and usually require trial and error. Maybe that's just because I'm using it in an unusual way. I guess the main issue is that I didn't realize soon enough that you can't change the relative importance of the degree and age factors because they're multiplied. The degree and age coefficients are only used to scale it compared to the zero appeals. The mathematical function is of course not that complicated but maybe the naming and interpretation threw me off.
Aha! I have an index out of bounds because the code assumes there are nodes here:
IGRAPH_CHECK(igraph_psumtree_update(&sumtree, 0, zero_deg_appeal * (1 + zero_age_appeal)));
I'll fix that too.",It all seems to be tested as intended 👍,True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1630,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1630#issuecomment-767812129,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","Changes in this PR so far:

Fix the progress reporting.
Add two optional (i.e. can be NULL) output arguments: (1) reachable_count, number of reachable vertices for each vertex. This is precisely the normalization factor used by normalize (2) all_reachable is set to true if all vertices of the graph could be reached from all vertices for which we do the computation. This is for convenience. A high-level interface could use this to issue a warning if we noticed that the graph was not connected.
For vertices with no paths (undirected: isolated vertices, directed: zero in- or out-degree depending on mode) we return NaN. This necessitated a change for the ""centralization"" test. Since ""centralization"" depends on the centrality scores of all vertices, even a single NaN derails the calculation. Some other systems (networkx) use 0 instead of NaN, but in my opinion this is not well-founded—NaN is better as it forces the user to deal with isolated vertices instead of ignoring their effect.
Re-write documentation.

This PR is a draft, but I'd like feedback on this approach ASAP.
Still to do:

Add more tests
Fix an off-by-one issue with the cutoff parameter",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1630#issuecomment-767853262,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","This is now done and ready for review, but please don't merge. I want to add more tests for the newly added parameters (it's informal tested from Mathematica).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1630#issuecomment-768994588,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","I'm not sure how useful this is, but I tried to break your code, read the documentation and looked at all the changes (not the whole algorithm) and I couldn't really find anything wrong. The documentation and code is very clear. The tests are clear and thorough.
I can get a segfault at 
  
    
      igraph/src/centrality/closeness.c
    
    
         Line 222
      in
      34727b5
    
  
  
    

        
          
           igraph_real_t curdist = VECTOR(dist)[to]; 
        
    
  

 by putting a NAN in the real_edges of simple_test_case_with_weights_undirected, but that's probably not too important.
I was also wondering if infinity isn't sometimes more sensible than a NaN when replacing 1/0 in lines like
VECTOR(*res)[i] = VECTOR(*res)[i] == 0 ? IGRAPH_NAN : 1.0 / VECTOR(*res)[i];",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1630#issuecomment-768995295,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","Looks good to me! The argument list is getting scary long now, but I don't really have a better idea about what to do here, and it's C so we can make the arguments optional in the higher level interfaces.
functions.def still needs to be updated for the new declaration.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1630#issuecomment-769012395,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","I chose to use NaN in order to have a consistent output regardless of whether we have normalization or not. Mathematica and networkx both return 0 for this case (isolated vertices). It's a special case that we need to make a choice for.
Generally, closeness doesn't make a lot of sense for isolated vertices, and this is IMO better communicated by returning NaN than returning zero. If the user does some arithmetic with the closeness values, a zero will go unnoticed (but still influence the results) while a NaN will wreak havoc and draw attention (it won't go unnoticed).
An example where one does arithmetic with all centrality values is the computation of ""centralization""",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1630#issuecomment-769014723,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","I chose to use NaN in order to have a consistent output regardless of whether we have normalization or not. Mathematica and networkx both return 0 for this case (isolated vertices). It's a special case that we need to make a choice for.
Generally, closeness doesn't make a lot of sense for isolated vertices, and this is IMO better communicated by returning NaN than returning zero.

Definitely. I was mainly looking at infinity as an alternative. I'm guessing that if NaN's are supported that infinity is too.
...Maybe that does still create the same problems.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1630#issuecomment-769041761,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","There are two distinct issues:

What to return for isolated vertices (or vertices with zero in- or out-degree)? Could be 0, NaN, Inf ...
Should there be a difference in what we return based on normalization?

The direct calculation gives 0/0 for the normalized case and 1/0 for the unnormalized case. Naively, this would give us NaN and Infinity.
While this is subjective, I think that it is more useful to return the same value both in the normalized and unnormalized cases. This is less confusing for users. Now the question is: should we return Infinity or NaN? Given that the value isn't really meaningful, I would choose NaN. NaN indicates that ""this makes no sense, don't use it"" better. Furthermore, the usual definition of closeness is the normalized one, which would naively give NaN.
For these edge cases, usually there is no single correct solution, but neither is the choice we make critically important. It's good to try to make a choice that's most useful during practical numerical work though (as opposed to analytic calculations on paper).
If there's a good case to be made against NaN, of course I'm happy to hear it :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1630,2021-01-26T20:29:09Z,2021-01-28T13:29:55Z,2021-01-28T13:29:56Z,MERGED,True,443,142,7,https://github.com/szhorvat,Generalize the closeness centrality computation,6,[],https://github.com/igraph/igraph/pull/1630,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1630#issuecomment-769049812,"This PR generalizes the closeness calculation and addresses #1053.
Reminder: closeness is the inverse of the mean distance to all other vertices.
In short, closeness centrality is problematic for disconnected graphs. Currently, igraph takes the distance to non-reachable nodes to be n (the number of vertices). This is an ad-hoc choice that makes no sense for the weighted case.
The simplest solution would be to throw an error for disconnected graphs, but: (1) this is not useful for closeness_cutoff, where some vertices are always unreachable for a low-enough cutoff (2) doesn't serve users the best.
Here are possible ways to deal with this issue:

igraph's current approach (not good).
Use the mean distance to reachable vertices, not all vertices. In the undirected case, this effectively computes the closeness per-component. Problem: the centrality scores will be much larger in small components, and not comparable to those in large components.
Refuse to work with disconnected graphs and throw an error. Problems: (1) not useful with closeness_cutoff (2) in the directed case, when computing the closeness only for some vertices, we can't immediately detect if the graph is connected. Note that igraph currently does show a warning if it detects that the graph is disconnected (but it won't always detect this).
There are approaches which first use the mean distance only to reachable vertices, but then re-scale the scores using some function of the number of vertices that could be reached. I've seen more than one way. networkx does this and points to a certain reference (Wasserman and Faust). Problem: The Wasserman and Faust approach effectively assumes that the mean distance scales linearly with the graph size (component size) and attempt to correct for this. This is simply not true. Consider a spatial network: the scaling depends on the spatial dimension.

My conclusion: There are many way to handle this and igraph should not choose to use one. Instead, it should provide maximum flexibility to use either of them.
My solution:

Use the mean distance to reachable vertices (not all vertices).
Also return the number of vertices that could be reached.

With this information, one can easily get the result of any of approaches 1-4 from above.  I would leave it to high-level interfaces to make a choice on what to implement, or provide multiple options.","Allright, thanks, now I understand 🙂.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1631,2021-01-27T10:12:05Z,2021-02-15T12:59:32Z,2021-02-15T12:59:32Z,MERGED,True,134,8,4,https://github.com/GroteGnoom,Add recent degree game unit test,5,[],https://github.com/igraph/igraph/pull/1631,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1631,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1632,2021-01-27T14:03:30Z,2021-02-15T14:56:38Z,2021-02-15T14:56:38Z,MERGED,True,184,20,4,https://github.com/GroteGnoom,Add cited_type_game unit tests,6,[],https://github.com/igraph/igraph/pull/1632,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1632,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1632,2021-01-27T14:03:30Z,2021-02-15T14:56:38Z,2021-02-15T14:56:38Z,MERGED,True,184,20,4,https://github.com/GroteGnoom,Add cited_type_game unit tests,6,[],https://github.com/igraph/igraph/pull/1632,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1632#issuecomment-768970751,Part of #1592,"@gaborcsardi I'm playing with this function in the R interface to reproduce the bug that was fixed in this PR by making nnval be real instead of integral, but I don't understand the behaviour I see:


Why does this not throw an error? cited.type.game(n=10, edges=1, types=c(1,2), pref=c(3,4))  The length of types should be the same as n, and this is already checked in the C interface.


Why is the default value of pref in the R interface pref = rep(1,   length(types)) instead of pref = rep(1,   max(types))? It does not seem right.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1632,2021-01-27T14:03:30Z,2021-02-15T14:56:38Z,2021-02-15T14:56:38Z,MERGED,True,184,20,4,https://github.com/GroteGnoom,Add cited_type_game unit tests,6,[],https://github.com/igraph/igraph/pull/1632,https://github.com/gaborcsardi,3,https://github.com/igraph/igraph/pull/1632#issuecomment-769086315,Part of #1592,"Why does this not throw an error?

Because there is no check in the C code of the R package yet (?).

Why is the default value of ...

Seems like a bug to me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1635,2021-01-28T17:52:52Z,2021-02-15T13:12:30Z,2021-02-15T13:12:30Z,MERGED,True,153,12,4,https://github.com/GroteGnoom,Add recent degree aging unit tests,15,[],https://github.com/igraph/igraph/pull/1635,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1635,"Part of #1592.
This should wait for the results of #1629","Part of #1592.
This should wait for the results of #1629",True,{}
igraph/igraph,https://github.com/igraph/igraph,1635,2021-01-28T17:52:52Z,2021-02-15T13:12:30Z,2021-02-15T13:12:30Z,MERGED,True,153,12,4,https://github.com/GroteGnoom,Add recent degree aging unit tests,15,[],https://github.com/igraph/igraph/pull/1635,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1635#issuecomment-777626998,"Part of #1592.
This should wait for the results of #1629","#1629 has been cleared up, so I'll change this code according to those results.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1638,2021-01-29T16:15:33Z,2021-01-29T19:02:23Z,2021-01-29T19:02:23Z,MERGED,True,183,64,4,https://github.com/vtraag,Improve NaN documentation and fixing various functions for vectors,5,[],https://github.com/igraph/igraph/pull/1638,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1638,"This PR fixes some remaining functions of the vector API, as was previously started in #1617, aimed at addressing issue #1560 (although this PR doesn't fix any other functions).
For any function that defines any ordering, or depends on any ordering, I included a note in the documentation that the order is undefined when NaN elements are included (which I think is the best solution). There are still a number of functions that are not documented, I have not touched these.","This PR fixes some remaining functions of the vector API, as was previously started in #1617, aimed at addressing issue #1560 (although this PR doesn't fix any other functions).
For any function that defines any ordering, or depends on any ordering, I included a note in the documentation that the order is undefined when NaN elements are included (which I think is the best solution). There are still a number of functions that are not documented, I have not touched these.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1638,2021-01-29T16:15:33Z,2021-01-29T19:02:23Z,2021-01-29T19:02:23Z,MERGED,True,183,64,4,https://github.com/vtraag,Improve NaN documentation and fixing various functions for vectors,5,[],https://github.com/igraph/igraph/pull/1638,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1638#issuecomment-769970068,"This PR fixes some remaining functions of the vector API, as was previously started in #1617, aimed at addressing issue #1560 (although this PR doesn't fix any other functions).
For any function that defines any ordering, or depends on any ordering, I included a note in the documentation that the order is undefined when NaN elements are included (which I think is the best solution). There are still a number of functions that are not documented, I have not touched these.",It's fine by me.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1640,2021-01-30T09:07:52Z,2021-01-31T09:16:35Z,2021-01-31T09:16:35Z,MERGED,True,418,288,7,https://github.com/szhorvat,PageRank: the walk should be restarted consistently between the ARPACK and PRPACK methods,6,[],https://github.com/igraph/igraph/pull/1640,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1640,"This PR fixes the problem where personalized PageRank results for disconnected graphs differ between the ARPACK and PRPACK methods.
A hint about what goes wrong is from examining an graph with no edges. With damping d approaching 1, the PRPACK result is uniform. With d -> 0, the PRPACK result is the same as the reset vector. PRPACK has two parameters, u and v. u was set to NULL and v was set to reset. Thus, u controls the vertex choice after resetting due to being stuck in a sink, and v controls the vertex choice during ""normal"" reset.
This PR sets both to be the same and explains the behaviour in the docs.
Additionally, the tests are moved to tests/unit, updated with a more modern approach, and expanded. I added a new small example in examples/simple.","This PR fixes the problem where personalized PageRank results for disconnected graphs differ between the ARPACK and PRPACK methods.
A hint about what goes wrong is from examining an graph with no edges. With damping d approaching 1, the PRPACK result is uniform. With d -> 0, the PRPACK result is the same as the reset vector. PRPACK has two parameters, u and v. u was set to NULL and v was set to reset. Thus, u controls the vertex choice after resetting due to being stuck in a sink, and v controls the vertex choice during ""normal"" reset.
This PR sets both to be the same and explains the behaviour in the docs.
Additionally, the tests are moved to tests/unit, updated with a more modern approach, and expanded. I added a new small example in examples/simple.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1642,"Hi,
This PR is answering the PR welcome #1569.
thanks!","Hi,
This PR is answering the PR welcome #1569.
thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1642#issuecomment-770270401,"Hi,
This PR is answering the PR welcome #1569.
thanks!","Thanks for the PR! We'll take a look likely next week.
Here are some tips for dealing with the test failures:
The macOS failure is trivial: you just need to add a newline at the end.
For the Linux one with sanitizers, I suggest some rewriting of the tests before you try to solve this:

Please move the test to test/unit instead of examples/simple and remove the reference to the file from the docs. It is not that useful as an example—let's make it purely a test.
Add #include ""test_utilities.inc"" and eventually we should transition to using the vector printing functions from there. Transitioning to these printing functions can be done as the very last step.
Do add VERIFY_FINALLY_STACK() to just before the end of the test.
Now comes the important part to help you track down the leaks: do not use exit() for failing the test. This will trigger the leak sanitizer which will mask the true cause of the failure. Instead, use IGRAPH_ASSERT to check assumptions. Once this has been done, you will see if the leaks are true leaks or are caused by an early exit due to a test failure.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1642#issuecomment-770270473,"Hi,
This PR is answering the PR welcome #1569.
thanks!",There are updated tips for writing unit tests here: https://github.com/igraph/igraph/wiki/How-to-write-unit-tests%3F,True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1642#issuecomment-770417745,"Hi,
This PR is answering the PR welcome #1569.
thanks!","There still seem to be some memory leaks. I'll take a detailed look around mid-next week (unless someone else gets to it first) and will help you finalize the PR then.
Until then you can look at the output from the leak sanitizer, which includes line number references, and try to figure out where the remaining leaks are coming from.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/guyroznb,5,https://github.com/igraph/igraph/pull/1642#issuecomment-770430288,"Hi,
This PR is answering the PR welcome #1569.
thanks!",Hi @szhorvat I managed to solve the memory leaks.. thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1642#issuecomment-771672983,"Hi,
This PR is answering the PR welcome #1569.
thanks!","Please move the test to test/unit instead of examples/simple and remove the reference to the file from the docs. It is not that useful as an example—let's make it purely a test.


Add #include ""test_utilities.inc"" and eventually we should transition to using the vector printing functions from there. Transitioning to these printing functions can be done as the very last step.


Do add VERIFY_FINALLY_STACK() to just before the end of the test.


Now comes the important part to help you track down the leaks: do not use exit() for failing the test. This will trigger the leak sanitizer which will mask the true cause of the failure. Instead, use IGRAPH_ASSERT to check assumptions. Once this has been done, you will see if the leaks are true leaks or are caused by an early exit due to a test failure.



If you'd be able to rewrite the tests using the above guidelines, that would be really helpful. We would need to make this change before merging these feature. While it's not difficult, it takes some time to do.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/guyroznb,7,https://github.com/igraph/igraph/pull/1642#issuecomment-771975942,"Hi,
This PR is answering the PR welcome #1569.
thanks!","Hi @szhorvat.
So, I managed to move the example to tests (and pull the latest igraph_path.h from develop).
I left with this weird problem (""Failed to connect to github.com port 443: Timed out"") which I don't know how to resolve.
Do you have any Idea?
thanks.....",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/1642#issuecomment-772061980,"Hi,
This PR is answering the PR welcome #1569.
thanks!","I left with this weird problem (""Failed to connect to github.com port 443: Timed out"") which I don't know how to resolve.

I think usually when you get this error you didn't do anything wrong and can't fix it, but you just have to try again later.
You can trigger the automated checks again by amending your last commit, changing nothing and then force-pushing, or adding an empty commit.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/guyroznb,9,https://github.com/igraph/igraph/pull/1642#issuecomment-772322051,"Hi,
This PR is answering the PR welcome #1569.
thanks!",thanks @GroteGnoom...,True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1642#issuecomment-772386138,"Hi,
This PR is answering the PR welcome #1569.
thanks!","Thanks for working on fixing up the tests! It seems there was a misunderstanding about the purpose of IGRAPH_ASSERT: it is used to verify that a condition is true.
Thus, instead of writing
if (expected_to_be_one != 1) {
    printf(""Value was not 1!\n"");
    return 13;
}

we should use
IGRAPH_ASSERT(expected_to_be_one == 1);

If the condition within the IGRAPH_ASSERT is not true, the test program will be aborted, and a message containing the condition, as well as its location within the source file will be printed.
If anything is unclear, feel free to ask.
I have a deadline coming up, so I ask for some more time before dealing with the details.",True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/guyroznb,11,https://github.com/igraph/igraph/pull/1642#issuecomment-777766313,"Hi,
This PR is answering the PR welcome #1569.
thanks!",thanks for the review @ntamas,True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1642#issuecomment-778662735,"Hi,
This PR is answering the PR welcome #1569.
thanks!",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1642#issuecomment-778670222,"Hi,
This PR is answering the PR welcome #1569.
thanks!","Something that was missing is adding this to the documentation. This is now done in efc6e2b  Some problems that needed to be fixed:

We don't support \test (and tests are not of concern to users, so don't need to be linked from docs).
There were some small syntax errors that prevented the docs from being built.

Since all the other similar functions has a get_shortest_path (not paths) version, it would be nice to add one here too, for consistency.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1642#issuecomment-779201415,"Hi,
This PR is answering the PR welcome #1569.
thanks!","@guyroznb Let me know if you plan to add igraph_get_shortest_path_bellman_ford (note path not paths) today. If not, I'll add it. Just want to avoid stepping on each others' toes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1642,2021-01-30T19:25:41Z,2021-02-13T19:00:10Z,2021-02-15T23:17:18Z,MERGED,True,541,6,6,https://github.com/guyroznb,igraph_get_shortest_path() using Bellman-Ford algorithm,28,[],https://github.com/igraph/igraph/pull/1642,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1642#issuecomment-779489213,"Hi,
This PR is answering the PR welcome #1569.
thanks!",igraph_get_shortest_path_bellman_ford is now implemented.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1644,2021-02-01T11:56:31Z,2021-02-02T14:03:49Z,2021-02-02T14:03:49Z,MERGED,True,2785,2785,82,https://github.com/szhorvat,Do not export non-public symbols from shared library,9,[],https://github.com/igraph/igraph/pull/1644,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1644,"This uses CMake's own features to handle dllimpor/dllexport, and uses visibility on Unix as well.
This is not even close to being done, it's just a proof of concept. Comments are welcome.","This uses CMake's own features to handle dllimpor/dllexport, and uses visibility on Unix as well.
This is not even close to being done, it's just a proof of concept. Comments are welcome.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1644,2021-02-01T11:56:31Z,2021-02-02T14:03:49Z,2021-02-02T14:03:49Z,MERGED,True,2785,2785,82,https://github.com/szhorvat,Do not export non-public symbols from shared library,9,[],https://github.com/igraph/igraph/pull/1644,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1644#issuecomment-771147682,"This uses CMake's own features to handle dllimpor/dllexport, and uses visibility on Unix as well.
This is not even close to being done, it's just a proof of concept. Comments are welcome.","This is working now, so I am marking it as ready for review.
We may want to make some cosmetic changes, such as the location of the #include in igraph_decls.h, and renaming DECLDIR to avoid conflict with other libraries.
I suggest renaming DECLDIR to IGRAPH_EXPORT as this is what CMake produces by default (not the difference from igraph_EXPORTS which used to be called IGRAPH_EXPORTS). Alternatively, we can us IGRAPH_DECLDIR (although DIR/direction is not meaningful for visibility on non-Windows platforms).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1644,2021-02-01T11:56:31Z,2021-02-02T14:03:49Z,2021-02-02T14:03:49Z,MERGED,True,2785,2785,82,https://github.com/szhorvat,Do not export non-public symbols from shared library,9,[],https://github.com/igraph/igraph/pull/1644,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1644#issuecomment-771149681,"This uses CMake's own features to handle dllimpor/dllexport, and uses visibility on Unix as well.
This is not even close to being done, it's just a proof of concept. Comments are welcome.","You can check that this works as intended by listing the symbols in the shared library with something like nm -gUC libigraph.0.dylib (macOS) and checking that only public symbols are shown. There will be a few more ""typeinfo"" in there, for C++ exceptions (I don't understand the technical details of why these appear).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1644,2021-02-01T11:56:31Z,2021-02-02T14:03:49Z,2021-02-02T14:03:49Z,MERGED,True,2785,2785,82,https://github.com/szhorvat,Do not export non-public symbols from shared library,9,[],https://github.com/igraph/igraph/pull/1644,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1644#issuecomment-771158599,"This uses CMake's own features to handle dllimpor/dllexport, and uses visibility on Unix as well.
This is not even close to being done, it's just a proof of concept. Comments are welcome.","Thanks, great to see this! I'll try to take a closer look shortly.

I suggest renaming DECLDIR to IGRAPH_EXPORT as this is what CMake produces by default

Yes, that sounds good.
One small remark: we should check that the generated include file igraph_export.h is properly packaged. Now that I am looking at this, we should double check the same for the other generated files (i.e. igraph_version.h and igraph_threading.h are at least in include/ in my build folder). At least, I'm now not 100% sure if these are being packaged. @ntamas, what do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1644,2021-02-01T11:56:31Z,2021-02-02T14:03:49Z,2021-02-02T14:03:49Z,MERGED,True,2785,2785,82,https://github.com/szhorvat,Do not export non-public symbols from shared library,9,[],https://github.com/igraph/igraph/pull/1644,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1644#issuecomment-771159299,"This uses CMake's own features to handle dllimpor/dllexport, and uses visibility on Unix as well.
This is not even close to being done, it's just a proof of concept. Comments are welcome.","Or actually, we of course don't need to package these files since they will be regenerated.",True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/ntamas']}"
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1645,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.","Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1645#issuecomment-771570718,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.","Allright, linux outputs:
Adjusted Rand result: -nan
and Windows and Mac do:
Adjusted Rand result: -nan(ind)
I'll see what's going on there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1645#issuecomment-771576264,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.",We have igraph_real_printf() in igraph_types.h that is meant to work around platform-specific printing styles for NaN. We also have print_real() in test_utilities.inc for the same purpose.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1645#issuecomment-771579327,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.","Ah, perfect, thank you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1645#issuecomment-771609872,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.","All is fine with this PR, but I'm confused about how one gets a -NaN. I thought NaNs don't have a sign. Perhaps some implementations print the sign bit anyway?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1645#issuecomment-771611322,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.","Are we using -ffast-math? I think that NaNs get all screwed up with that.
Edit: okay, so I researched a bit and it looks like NaN values have a sign bit (just like any other float value) but most implementations ignore it. Some don't. For future reference, a NaN value in 32-bit looks like s111 1111 1axx xxxx xxxx xxxx xxxx xxxx (experiment with it here), where s is the sign bit, a determines whether the NaN is quiet or signaling, and x is an extra payload that is ignored.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1645,2021-02-02T10:39:12Z,2021-02-02T13:46:10Z,2021-02-02T13:46:10Z,MERGED,True,165,8,4,https://github.com/GroteGnoom,Add compare_communities unit tests,3,[],https://github.com/igraph/igraph/pull/1645,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1645#issuecomment-771639333,"Part of #1592
The Adjusted Rand on 2 vertices in 2 clusters still outputs -NaN,
but that seems correct and a bit excessive to check for up front.
I'm not sure why this function is used instead of just having separate
function calls. Separate function calls would also clear up the
documentation.","Thanks for that website 🙂 It's kind of strange how complicated a NaN is.
I do agree that -NaN doesn't make sense, but I guess in practice (as in this case) it just means -0.0/0.0.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1646,2021-02-02T15:11:11Z,2021-02-02T18:52:37Z,2021-02-02T18:52:44Z,MERGED,True,95,1,4,https://github.com/GroteGnoom,Add split_join_distance unit tests,1,[],https://github.com/igraph/igraph/pull/1646,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1646,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1646,2021-02-02T15:11:11Z,2021-02-02T18:52:37Z,2021-02-02T18:52:44Z,MERGED,True,95,1,4,https://github.com/GroteGnoom,Add split_join_distance unit tests,1,[],https://github.com/igraph/igraph/pull/1646,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1646#issuecomment-771887828,Part of #1592,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1647,2021-02-04T10:32:02Z,2021-02-08T21:31:39Z,2021-02-08T21:31:39Z,MERGED,True,181,14,6,https://github.com/GroteGnoom,Add le_community_to_membership unit tests,4,[],https://github.com/igraph/igraph/pull/1647,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1647,"Part of #1592
I removed the
igraph_matrix_nrow(merges) < steps
test from le_community_to membership, because doesn't do any good there and is already tested in community_to_membership.
I added a 'already merged' test to community_to_membership because it shouldn't happen and gives unexpected results.","Part of #1592
I removed the
igraph_matrix_nrow(merges) < steps
test from le_community_to membership, because doesn't do any good there and is already tested in community_to_membership.
I added a 'already merged' test to community_to_membership because it shouldn't happen and gives unexpected results.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1647,2021-02-04T10:32:02Z,2021-02-08T21:31:39Z,2021-02-08T21:31:39Z,MERGED,True,181,14,6,https://github.com/GroteGnoom,Add le_community_to_membership unit tests,4,[],https://github.com/igraph/igraph/pull/1647,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1647#issuecomment-773227234,"Part of #1592
I removed the
igraph_matrix_nrow(merges) < steps
test from le_community_to membership, because doesn't do any good there and is already tested in community_to_membership.
I added a 'already merged' test to community_to_membership because it shouldn't happen and gives unexpected results.","Thanks a lot! I've requested some changes here and there, hopefully they are easy to fix.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1648,2021-02-04T15:49:43Z,2021-02-04T18:48:13Z,2021-02-04T18:48:13Z,MERGED,True,199,221,19,https://github.com/szhorvat,private functions used in tests are now exported from the shared library,5,[],https://github.com/igraph/igraph/pull/1648,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1648,"Private functions used in tests are now exported from the shared library (i.e. you can see them in the .dylib/.so using the nm command and programs linking to the library can use them), but they do not appear in public headers and users have no way of discovering them (other than looking at internals and adding the function prototypes to their programs explicitly).
All of these have IGRAPH_PRIVATE_EXPORT instead of IGRAPH_EXPORT so it is easy to disable exporting them if we want to do that.
Exceptionally, igraph_i_bfs gets IGRAPH_PRIVATE_EXPORT in a public header. This is the only use of IGRAPH_PRIVATE_EXPORT in a public header. This function is in a public header because the Python interface uses it (see #1301). I assume Debian wants its version of the Python interface to link to the C/igraph shared library. Thus for igraph_i_bfs maybe a plain IGRAPH_EXPORT makes more sense.","Private functions used in tests are now exported from the shared library (i.e. you can see them in the .dylib/.so using the nm command and programs linking to the library can use them), but they do not appear in public headers and users have no way of discovering them (other than looking at internals and adding the function prototypes to their programs explicitly).
All of these have IGRAPH_PRIVATE_EXPORT instead of IGRAPH_EXPORT so it is easy to disable exporting them if we want to do that.
Exceptionally, igraph_i_bfs gets IGRAPH_PRIVATE_EXPORT in a public header. This is the only use of IGRAPH_PRIVATE_EXPORT in a public header. This function is in a public header because the Python interface uses it (see #1301). I assume Debian wants its version of the Python interface to link to the C/igraph shared library. Thus for igraph_i_bfs maybe a plain IGRAPH_EXPORT makes more sense.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1648,2021-02-04T15:49:43Z,2021-02-04T18:48:13Z,2021-02-04T18:48:13Z,MERGED,True,199,221,19,https://github.com/szhorvat,private functions used in tests are now exported from the shared library,5,[],https://github.com/igraph/igraph/pull/1648,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1648#issuecomment-773446068,"Private functions used in tests are now exported from the shared library (i.e. you can see them in the .dylib/.so using the nm command and programs linking to the library can use them), but they do not appear in public headers and users have no way of discovering them (other than looking at internals and adding the function prototypes to their programs explicitly).
All of these have IGRAPH_PRIVATE_EXPORT instead of IGRAPH_EXPORT so it is easy to disable exporting them if we want to do that.
Exceptionally, igraph_i_bfs gets IGRAPH_PRIVATE_EXPORT in a public header. This is the only use of IGRAPH_PRIVATE_EXPORT in a public header. This function is in a public header because the Python interface uses it (see #1301). I assume Debian wants its version of the Python interface to link to the C/igraph shared library. Thus for igraph_i_bfs maybe a plain IGRAPH_EXPORT makes more sense.","As part of addressing #1301, I just removed some functions from public headers.
I was forced to comment out the _i_spmatrix functions because if I just make them static, the compiler will throw a warning (which is taken as an error with current settings) about the function not being used.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1648,2021-02-04T15:49:43Z,2021-02-04T18:48:13Z,2021-02-04T18:48:13Z,MERGED,True,199,221,19,https://github.com/szhorvat,private functions used in tests are now exported from the shared library,5,[],https://github.com/igraph/igraph/pull/1648,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1648#issuecomment-773526491,"Private functions used in tests are now exported from the shared library (i.e. you can see them in the .dylib/.so using the nm command and programs linking to the library can use them), but they do not appear in public headers and users have no way of discovering them (other than looking at internals and adding the function prototypes to their programs explicitly).
All of these have IGRAPH_PRIVATE_EXPORT instead of IGRAPH_EXPORT so it is easy to disable exporting them if we want to do that.
Exceptionally, igraph_i_bfs gets IGRAPH_PRIVATE_EXPORT in a public header. This is the only use of IGRAPH_PRIVATE_EXPORT in a public header. This function is in a public header because the Python interface uses it (see #1301). I assume Debian wants its version of the Python interface to link to the C/igraph shared library. Thus for igraph_i_bfs maybe a plain IGRAPH_EXPORT makes more sense.","igraph_i_bfs() is special and I'm not sure what to do about it. The Python interface exposes igraph_i_bfs() as the BFS function, and does not use igraph_bfs() at all. At the same time, the Python interface also reimplements BFS in a BFSIter class because Python users naturally expect the BFS traversal to behave like an iterator, and there's no way we can simulate that with the current C implementation.
So, considering that igraph_i_bfs() is actually the function that is exposed in Python as the BFS function, it might be worth renaming it to something like igraph_bfs_simple(), because this is essentially what it is -- it's a simpler interface to BFS for use-cases when one does not need the ""full"" BFS solution with order, rank, pred, succ, father, dist and callback as they are in igraph_bfs().",True,{}
igraph/igraph,https://github.com/igraph/igraph,1648,2021-02-04T15:49:43Z,2021-02-04T18:48:13Z,2021-02-04T18:48:13Z,MERGED,True,199,221,19,https://github.com/szhorvat,private functions used in tests are now exported from the shared library,5,[],https://github.com/igraph/igraph/pull/1648,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1648#issuecomment-773526739,"Private functions used in tests are now exported from the shared library (i.e. you can see them in the .dylib/.so using the nm command and programs linking to the library can use them), but they do not appear in public headers and users have no way of discovering them (other than looking at internals and adding the function prototypes to their programs explicitly).
All of these have IGRAPH_PRIVATE_EXPORT instead of IGRAPH_EXPORT so it is easy to disable exporting them if we want to do that.
Exceptionally, igraph_i_bfs gets IGRAPH_PRIVATE_EXPORT in a public header. This is the only use of IGRAPH_PRIVATE_EXPORT in a public header. This function is in a public header because the Python interface uses it (see #1301). I assume Debian wants its version of the Python interface to link to the C/igraph shared library. Thus for igraph_i_bfs maybe a plain IGRAPH_EXPORT makes more sense.",I'm going to merge this and we can continue the discussion about igraph_i_bfs() on Slack.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1649,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1649#issuecomment-773963133,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","We recently made the choice to return NaN for the modularity when the number of edges is zero, and document this.
I would suggest catching this case (sw == 0) and returning a matrix filled with all NaNs. This is a bit more consistent than letting NaNs and Infs happen arbitrarily.
Also, it should be documented that the modularity matrix is not well-defined when there are zero edges. This is what's important.
What to return for the meaningless case is not that critical (for as long as it's clear that it's meaningless, as it is now).
@vtraag any comments?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1649#issuecomment-773967332,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","@vtraag Since igraph_modularity was updated for the directed case, do you want to update this function as well (#1413)? It's a trivial, very low risk (but API-breaking!) change and would make the system a bit more consistent. Also, maybe @GroteGnoom would enjoy adding some features instead of just tests.
If we don't do it, then it is important to document that ""edge directions are ignored"".",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1649#issuecomment-773976089,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","I would suggest catching this case (sw == 0) and returning a matrix filled with all NaNs. This is a bit more consistent than letting NaNs and Infs happen arbitrarily.

Yes, I agree, this makes sense.
I think it would make sense to update igraph_modularity_matrix to also work for the directed case. The function itself is never used anywhere in igraph itself it seems, to there are no dependencies to think about. I don't have time to do so now however. Perhaps @GroteGnoom, you would be interested in doing this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1649#issuecomment-773980359,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.",IMO it is also fine to skip testing the zero-edge case and state in the documentation that the result for this case is undefined.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1649#issuecomment-773991226,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","IMO it is also fine to skip testing the zero-edge case and state in the documentation that the result for this case is undefined.

Allright, I will go with this option 🙂

I think it would make sense to update igraph_modularity_matrix to also work for the directed case. The function itself is never used anywhere in igraph itself it seems, to there are no dependencies to think about. I don't have time to do so now however. Perhaps @GroteGnoom, you would be interested in doing this?

Sure!
If I understand correctly, the adjacency matrix does currently take the directions in to account, so what needs to be changed is to use in-degrees and out-degrees for the next part (the edge-probability matrix).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1649#issuecomment-774008091,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","If I understand correctly, the adjacency matrix does currently take the directions in to account, so what needs to be changed is to use in-degrees and out-degrees for the next part (the edge-probability matrix).

Yes, the igraph_get_adjacency call already returns a directed matrix (if the graph is directed). You then indeed need to get in- and out-degree (or strenghts) separately and multiply them as out[i] * in[j] / (2 *m), similar to how it is done in igraph_modularity. You can make it a bit more efficient by scaling the degree/strength vectors by 2 * m before the double loop, requiring only 2 n operations instead of n^2, similar to how it is done in igraph_modularity.
For a unit test, it would be nice to check if igraph_modularity and igraph_matrix_modularity matrix give the same outcome for a given partition.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1649#issuecomment-774008411,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.",@vtraag I would call the current version buggy actually ... It uses a directed adjacency matrix with undirected (i.e. total) degrees.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1649#issuecomment-774009547,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","@vtraag I would call the current version buggy actually ... It uses a directed adjacency matrix with undirected (i.e. total) degrees.

Yes, quite right. I think it was never intended to be used for directed graphs, but this is neither checked nor documented. Improving this is then all the more important.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1649#issuecomment-774015285,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","OK, a bit of care is needed to make sure we get this right.
modularity has a directed argument that can be used to ignore edge directions. This is useful as most community detection methods ignore edge directions. modularity_matrix should also have such an argument.
Ignoring edge directions in directed graph will lead to multigraphs when we have reciprocal edges. This case must not be forgotten. Thus, if A is the adj. mat. then:

We retrieve A using get_adjacency.
If the graph is undirected set directed=false.
If the graph itself is undirected (not the same as directed == false!), multiply A_ii by 2.
If:

directed == false, compute (A_ij + A_ji) / 2 - gamma * k_i * k_j / (2*m). This works for undirected adjacency matrices (thanks to multiplying the diagonal) and effectively ignores edge directions for the directed adjacency matrices.
directed == true, compute A_ij - gamma * k_out_i * k_in_j / (m). Notice that there is no factor 2 in front of m (@vtraag you got this wrong above)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1649#issuecomment-774018150,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","directed == true, compute A_ij - gamma * k_out_i * k_in_j / (m). Notice that there is no factor 2 in front of m (@vtraag you got this wrong above)

Yes, correct, there should be no 2 for the directed case.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/GroteGnoom,12,https://github.com/igraph/igraph/pull/1649#issuecomment-774264948,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","I notice I haven't been careful enough in checking the output for the weighted graph. I think the adjacency matrix should take the weights into account, but it doesn't.
Is there a function that generates the weighted adjacency matrix?
(I can't seem to find it, but I expected it to be there. R has it. It's definitely not weighted_adjacency, which does the reverse)",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1649#issuecomment-774282968,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","Wow, this function is in bad repair ...

Is there a function that generates the weighted adjacency matrix?

I can't find one either, except for sparse matrices (igraph_weighted_sparsemat, but that takes the weight from an attribute).
I checked the R source code and it is implemented directly in R.
I suggest writing a helper function that does whatever modularity_matrix needs, but not more. Since we are so close to the release of version 0.9, I would not try to polish it and make it public. That is something we can do later (after the release).
igraph_get_adjacency is a good model for how to write such a function: iterate through the edges and do MATRIX(mat, IGRAPH_FROM(graph, eid), IGRAPH_TO(graph, eid)) += weights[eid] where eid is the edge index. In the undirected case, also add it to the transpose matrix element. This will naturally put twice the weight on the diagonal, so for the weighted undirected case we won't need to bother multiplying the diagonal by 2.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1649#issuecomment-774308325,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","In the undirected case, also add it to the transpose matrix element.

Is this also consistent with the output from the unweighted igraph_get_adjacency?

I suggest writing a helper function that does whatever modularity_matrix needs, but not more

Most functions with weights would just have a weights argument which could be NULL to note take weights into account. Once 0.9 is released we fix the API, so perhaps is makes sense to simply add this weights argument to the existing igraph_get_adjacency function instead of creating a new one?

Wow, this function is in bad repair ...

Clearly. I doubt that anyone ever actually uses this function though.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1649#issuecomment-774326628,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","Is this also consistent with the output from the unweighted igraph_get_adjacency?

No, it's not. igraph_get_adjacency specifically avoids doubling the diagonal elements.
But for now we just need to fix this function, and later (post-0.9) we can think about how to expand the API.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/GroteGnoom,16,https://github.com/igraph/igraph/pull/1649#issuecomment-774435828,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","I have a new version.
I also added the option to ignore direction in the adjacency matrix.
I think igraph_modularity is not implemented correctly, because it scales k_in and k_out both, which would result in a division by m^2 instead of m.
Tests are now failing because of tiny floating point offsets.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1649#issuecomment-774459470,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","I think igraph_modularity is not implemented correctly, because it scales k_in and k_out both, which would result in a division by m^2 instead of m.

I believe that the modularity calculation is correct because there is an extra 1/m (or 1/2m) factor in front of the definition. Thus effectively it is sum_ij (A_ij / m - k_in/m * k_out/m) * delta_c(i)_c(j).",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1649#issuecomment-774460091,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.","It looks correct to me. It would be nice to add a test to compare with igraph_modularity by explicitly calculation the modularity from the modularity matrix and an arbitrary partitioning.
Let me when you're done with this and I'll finish any remaining nitpicks and merge.
Thanks again for all your work on the tests and for carefully checking all cases!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1649,2021-02-05T10:20:48Z,2021-02-07T18:03:01Z,2021-02-07T18:03:01Z,MERGED,True,293,28,6,https://github.com/GroteGnoom,Add modularity_matrix unit tests,4,[],https://github.com/igraph/igraph/pull/1649,https://github.com/GroteGnoom,19,https://github.com/igraph/igraph/pull/1649#issuecomment-774668150,"Part of #1592
I wasn't too sure if I should leave the NaN's and infs in (https://igraph.discourse.group/t/the-unit-tests-thread/597/17), but it could be just fine.",I think I fixed everything.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1652,Creating a PR to make review/commenting easier.,Creating a PR to make review/commenting easier.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1652#issuecomment-774481097,Creating a PR to make review/commenting easier.,"@ntamas One concern I have is performance. It seems to me that it would be very easy to generate loops only once instead of twice directly in the source at igraph_neighbors or igraph_incident. Am I mistaken? What we do now instead is to first generate double loops, them remove them.  For example, igraph_i_remove_loops_from_incidence_vector_in_place adds already seen loops to a plain vector and repeatedly checks if newly found loops are already in this vector. Vector search is expensive (linear). The functions we are dealing with are fundamental, used all over the library, so it makes sense to avoid unnecessary overhead.
Why do we not then tackle the problem at the source, i.e. igraph_neighbors / igraph_incident?",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1652#issuecomment-774482987,Creating a PR to make review/commenting easier.,"There are two sections of these functions: mode & IGRAPH_OUT and mode & IGRAPH_IN. For loops=none, we skip adding loops in both sections. For loops=once, we skip adding loops in one section. For loops=twice, we don't skip them at all. Isn't this all that's needed, and isn't this more performant?
I keep looking at the NO/ONCE/TWICE choices made in some functions. For some it would actually make sense to switch to ""no loops"" or ""once"". But I feel uncomfortable about the performance implications. It would be so much simpler if we never had to think about that.
Of course, with multi-edge removal there will be some slowdown no matter what, but that's a separate case. Even there, the addition of these arguments is immensely useful. There are functions (e.g. chordal graph stuff) where we added a check to see if the graph is simple and abort if not. Sometimes the better solution is to just ignore loops and multi-edges. This is very easy to do now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1652#issuecomment-774490406,Creating a PR to make review/commenting easier.,"@ntamas Other than the LAD thing, the behaviour seems correct to me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1652#issuecomment-774683774,Creating a PR to make review/commenting easier.,"Why do we not then tackle the problem at the source, i.e. igraph_neighbors / igraph_incident?

Because that would be a significant API breakage less than 10 days before the scheduled release of 0.9.0, and I cannot judge what the implications would be. igraph_neighbors() and igraph_incident() are used pretty much everywhere from the C core to the higher level interfaces, so if I add options for handling loop/multiple edges, it would have far-reaching implications for the higher level interfaces as well.
We can do this later, for 0.10.0, although to be honest I'm not so sure about this; it would make these functions much harder to use from the C interface because then you would have to specify two extra arguments with every call, even if your particular graph does not have loop or multiple edges and will never have. In C++ it wouldn't be a problem because we could just pick sensible defaults for these arguments, but it is not the case here.
An alternative would be to expand the igraph_neimode_t enum with additional bits to indicate what to deal with loop / multiple edges, so one could use something like IGRAPH_OUT | IGRAPH_NO_MULTIPLE | IGRAPH_LOOPS_TWICE if he wants to be super specific, but could also simply use IGRAPH_OUT to use reasonable defaults (we just need to specify the bit fields in a way that zero bits represent the defaults).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1652#issuecomment-774684255,Creating a PR to make review/commenting easier.,"For example, igraph_i_remove_loops_from_incidence_vector_in_place adds already seen loops to a plain vector and repeatedly checks if newly found loops are already in this vector. Vector search is expensive (linear).

Yes, it's linear, but in 99.99% of the cases the ""already seen loops"" vector will be empty, and in 99% of the remaining 0.01% it will have length 1, so I guess its performance impact is negligible. I don't expect users to frequently use graphs where it is typical for a node to have hundreds of loop edges.
Anyway, in the vein of ""measure, don't guess"", this comment indicates that it would indeed be useful to have a comprehensive and representative set of benchmarks for igraph that touch most parts of the library so we could test whether a change like this has an impact or not. Right now we can only guess, and my opinion is no better than yours :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1652#issuecomment-774685395,Creating a PR to make review/commenting easier.,"We do not actually need to change igraph_neighbors and igraph_incident.
We can have an igraph_i_neighbors(graph, neis, node, mode, loops, multiple) just for the private use of igraph_adjlist_init. (If we want to reduce the risk, then igraph_neighbors doesn't even need to rely on igraph_i_neighbors at this point, but can stay unchanged for the moment.)
My point was not to change igraph_neighbors or its signature, but to simply not generate double-loops instead of first generating them, then removing them.
However, if you are still concerned about breaking stuff with this change, we can leave it for after 0.9. The behaviour would not change, only (potentially) the performance. It would also be a much simpler way to implement the same behaviour.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1652#issuecomment-774685822,Creating a PR to make review/commenting easier.,"Anyway, in the vein of ""measure, don't guess"",

Performance is not the only argument for solving the problem at the source. Another one is simplicity.
But once again, since this is a debate not about how the functions should behave, but about how they should be implemented, we could leave it for after 0.9.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1652#issuecomment-774692950,Creating a PR to make review/commenting easier.,"Just my two cents: I think it would be useful to have an unambiguous definition of igraph_neighbours and igraph_incident and for that reason I suggested to simply include each edge always exactly once.
I am now actually wondering whether we shouldn't simply always stick to this. We now introduce arguments to control what is being returned (multiple edges, number of loops, etc...), but it might now be more useful to simply always use all edges, also given the problems that emerge with other functions (e.g. degree/strength, weights for multigraphs).
If a user supplies a multigraph to a function that doesn't accept it, (s)he should simply first simplify the graph. There is a reason for counting loops once or twice, but we can debate whether we should have an option to ignore loops. Again, if a function does not work correctly with loops it is easier to state this clearly and require a user to first simplify the graph (or at least remove the self-loops).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1652#issuecomment-774724599,Creating a PR to make review/commenting easier.,"to simply include each edge always exactly once

I am not very keen on this. Before making such major changes to fundamental functions, there should be a very good justification.
In my experience, the most common use for finding neighbours is to implement algorithms. Usually is it necessary to have a degree which is consistent with the way neighbors was computed. With the standard definition of degree (which takes loops twice), that requires loop duplication in the adjlist/inclist as well. This is just one example that came to mind immediately.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1652#issuecomment-774758546,Creating a PR to make review/commenting easier.,"I am not very keen on this. Before making such major changes to fundamental functions, there should be a very good justification.

I agree. But I think it may be worth considering letting the interface be as simple as possible, and not see a proliferation of multiple/loop arguments everywhere. Whether there are always one or two self-loops is I think another question, as long as everything is simply always consistent with each other.
Anyway, this is probably something that ties in with other discussions about fundamental (graph) structure. So this probably goes beyond this particular PR, and we can discuss it in greater detail at some later time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/iosonofabio,12,https://github.com/igraph/igraph/pull/1652#issuecomment-774769910,Creating a PR to make review/commenting easier.,"I'm late to the party, but I can see it's a good case for a synchronous discussion via teams, perhaps after 0.9.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1652,2021-02-06T13:37:47Z,2021-02-08T09:32:47Z,2021-02-08T21:09:18Z,MERGED,True,2015,399,61,https://github.com/szhorvat,adjlist/inclist loop handling update,20,[],https://github.com/igraph/igraph/pull/1652,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1652#issuecomment-775007576,Creating a PR to make review/commenting easier.,"Merged this as is and then we can discuss the remaining issues about multiple / loop edge handling on Teams, after we've discussed the int type transition of course :)",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1653,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/guyroznb,2,https://github.com/igraph/igraph/pull/1653#issuecomment-777790102,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","I added the igraph_Calloc()  NULL check where I found it missing.
thanks @ntamas for the review",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/guyroznb,3,https://github.com/igraph/igraph/pull/1653#issuecomment-784457422,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","Hi, help is needed here. I don't know why all my tests fail (including programs which I didn't change).
thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1653#issuecomment-784462019,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","This seems to be a problem in the logs:
../src/paths/dijkstra.c:913:27: error: unused variable 'k' [-Werror,-Wunused-variable]
        long int j, node, k;

All warnings are turned into errors by default so the compiler will complain if some leaves unused variables around.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1653#issuecomment-787925062,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","I'm sorry, I didn't realize I was commenting on the test program, and not on the function implementation. I saw this problem a few days ago and I wanted to mention the issue before the PR is merged (I don't have a lot of time today and I was in a bit of a hurry).
I now see that the implementation does indeed sort correctly.
However, the way this is implemented is really a hack: We add the vertex IDs to the end of the edge ID vectors, then sort the list of edge ID vectors, finally remove the vertex IDs. The sorting is done entirely separately on list of edge-paths and vertex-paths, and this makes me uncomfortable. Note that there are multiple different path orderings which are all considered sorted here, as only the tail vertex is compared. There's a risk that something will go wrong in the future: maybe we end up using a non-deterministic sorting algorithm (unlikely), or due to some future modification of the code the vertex-path-sort ends up using a different sorting algorithm than the edge-path-sort.
In short: the sorting should ideally be done only once, and applied to both the edge-path list and the vertex-path list.
I would write a function that computes the permutation that sorts the paths, then apply that permutation to both the vertex-paths and the edge-paths. Create an igraph_vector_long_t order using igraph_vector_long_init_seq and sort it using a comparison function that compares i and j through igraph_vector_tail(VECTOR(vertices)[i]) and igraph_vector_tail(VECTOR(vertices)[j]).  Then apply the permutation to the result: create a new vector_ptr for vertices, and set its kth element to vertices[order[k]].  Finally copy it back into vertices. Since this only stores/copies pointers, it will not have a great memory overhead.
What do you think @ntamas ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1653#issuecomment-787948160,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","To illustrate that my concern is not so ""out there"", C++17 already has parallel sort in its standard library. Parallel sort is not deterministic. If the underlying sort implementation will ever become parallell in the future (maybe we start calling the system qsort again, which we have no control over), then there is a risk that the edge-paths and vertex-paths would end up being sorted differently.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1653#issuecomment-815904432,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","What do you think @ntamas ?

I agree. (Sorry, this mention has slipped through the cracks and I haven't noticed it until now when I started reviewing the state of PRs in our queue).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1653#issuecomment-817110490,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.",@guyroznb Can you please make the change I requested above? The vertex and edge vectors should be sorted together. Let us know if this isn't completely clear or if you need help merging the latest develop branch into this PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/guyroznb,9,https://github.com/igraph/igraph/pull/1653#issuecomment-817191882,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","Hi @szhorvat, you wrote that you would write a function that compute the permutation for sorting the path. I can write this function or maybe sort the vertices first and, find the permutation vector and sort the edges path accordingly.
@szhorvat what do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1653#issuecomment-817263270,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","It would be quite helpful if you could make this change.
You can use igraph_qsort_r with a comparison function to sort a vector of indices based on vertices, and effectively obtain the needed permutation. The extra argument to the comparison function can be the vector of vertex paths. Then apply this permutation to both the vertex paths and edge paths.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/guyroznb,11,https://github.com/igraph/igraph/pull/1653#issuecomment-818653849,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","hi @szhorvat  I don't understand the sorting function igraph_qsort_t and I don't see any reference to the function of the documentation. Can you please explain this function, what is the base and the thunk inputs",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1653#issuecomment-818672289,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","It is the same function as described here
The prototype is
void igraph_qsort_r(void *base, size_t nel, size_t width, void *thunk,
                                  int (*compar)(void *, const void *, const void *));

base is the raw array to be sorted. Since we are creating a permutation vector, this will be an array of longs.
nel is the number of elements in the array.
width is the size of a single element in the array, i.e. sizeof(long).
thunk will be passed as the 1st argument of the comparison function. We will pass a pointer to the vector_ptr of vertex paths here.
The comparison function will receive then, thunk (which is just a pointer to the list of vector paths) and two pointers to indices inside of the the permutation vector. It should use these indices to index into the list of vertex paths, and compare what it finds there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/apps/codecov,13,https://github.com/igraph/igraph/pull/1653#issuecomment-820376204,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.","Codecov Report

Merging #1653 (e15df83) into develop (d047b2f) will increase coverage by 0.09%.
The diff coverage is 95.04%.


@@             Coverage Diff             @@
##           develop    #1653      +/-   ##
===========================================
+ Coverage    72.15%   72.24%   +0.09%     
===========================================
  Files          291      291              
  Lines        56947    57151     +204     
===========================================
+ Hits         41090    41290     +200     
- Misses       15857    15861       +4     



Impacted Files
Coverage Δ





src/paths/all_shortest_paths.c
89.69% <88.33%> (-1.69%)
⬇️


src/paths/dijkstra.c
94.43% <96.72%> (+0.30%)
⬆️


src/core/vector_ptr.c
88.15% <97.56%> (+2.26%)
⬆️


src/core/vector.pmt
88.47% <100.00%> (+1.18%)
⬆️


src/paths/distances.c
99.66% <0.00%> (+<0.01%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d047b2f...e15df83. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1653#issuecomment-830041013,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.",Nearly done with this one; I still need to check the part at the end of igraph_get_all_shortest_paths_dijkstra() where the paths are permuted. I have a feeling that we could probably make use of a (not-yet-implemented) igraph_vector_ptr_qsort_ind() function that would be similar to igraph_vector_qsort_ind() but for pointer vectors. The rest seems okay now.,True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/guyroznb']}"
igraph/igraph,https://github.com/igraph/igraph,1653,2021-02-07T11:13:24Z,2021-05-07T13:11:07Z,2021-05-08T02:09:28Z,MERGED,True,840,130,19,https://github.com/guyroznb,Add edges to shortest path,72,[],https://github.com/igraph/igraph/pull/1653,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1653#issuecomment-834370277,"This PR answers Issue number #1515, returning the shortest paths both in terms of edges and in vertices.
This PR affects the functions igraph_get_all_shortest_paths and   igraph_get_all_shortest_paths_dijkstra.
thanks.",Finally! 🎉 Sorry it took so long and thanks for your hard work on this!,True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1655,2021-02-09T11:12:20Z,2021-02-10T11:32:15Z,2021-02-10T11:32:15Z,MERGED,True,288,9,7,https://github.com/GroteGnoom,"Add selector unit tests, add docs",2,[],https://github.com/igraph/igraph/pull/1655,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1655,"Part of #1592
There is still an unfreed calloc that needs to be fixed (https://igraph.discourse.group/t/the-unit-tests-thread/597/20)","Part of #1592
There is still an unfreed calloc that needs to be fixed (https://igraph.discourse.group/t/the-unit-tests-thread/597/20)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1656,2021-02-09T18:53:04Z,2021-02-10T12:30:06Z,2021-02-10T19:43:04Z,MERGED,True,156,15,5,https://github.com/GroteGnoom,Add lapack_dgetrf unit tests,3,[],https://github.com/igraph/igraph/pull/1656,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1656,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1656,2021-02-09T18:53:04Z,2021-02-10T12:30:06Z,2021-02-10T19:43:04Z,MERGED,True,156,15,5,https://github.com/GroteGnoom,Add lapack_dgetrf unit tests,3,[],https://github.com/igraph/igraph/pull/1656,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1656#issuecomment-776211303,Part of #1592,@szhorvat Does c218f4b cause 0.00000 to be printed out as 0.000000 on windows?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1656,2021-02-09T18:53:04Z,2021-02-10T12:30:06Z,2021-02-10T19:43:04Z,MERGED,True,156,15,5,https://github.com/GroteGnoom,Add lapack_dgetrf unit tests,3,[],https://github.com/igraph/igraph/pull/1656,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1656#issuecomment-776213041,Part of #1592,"Yes, MSVC bug. https://stackoverflow.com/q/65900619/695132
I noticed it a while ago (#1634), but for some reason (that I still don't understand) it didn't affect the CI until I changed to use the Ninja generator today. It might be a Release vs Debug mode thing, not sure.
I'll fix this in some way tonight.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1656,2021-02-09T18:53:04Z,2021-02-10T12:30:06Z,2021-02-10T19:43:04Z,MERGED,True,156,15,5,https://github.com/GroteGnoom,Add lapack_dgetrf unit tests,3,[],https://github.com/igraph/igraph/pull/1656,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1656#issuecomment-776231796,Part of #1592,You can now merge develop into this branch (or rebase it) to get rid of the test failures,True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1656,2021-02-09T18:53:04Z,2021-02-10T12:30:06Z,2021-02-10T19:43:04Z,MERGED,True,156,15,5,https://github.com/GroteGnoom,Add lapack_dgetrf unit tests,3,[],https://github.com/igraph/igraph/pull/1656,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1656#issuecomment-776967578,Part of #1592,"@GroteGnoom When you fix a bug (as here—the function didn't allocate the proper memory for the ipiv vector), please do add a note to the PR, to make it easier to write the changelog later.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1657,2021-02-10T14:23:51Z,2021-02-12T20:12:33Z,2021-02-12T20:12:33Z,MERGED,True,251,17,5,https://github.com/GroteGnoom,Add lapack_dgetrs unit tests,6,[],https://github.com/igraph/igraph/pull/1657,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1657,"Part of #1592
Bugfix: No more invalid memory reads on invalid pivot vector.
Slightly problematic end results: A singular matrix seems to result in random output. Since you would be warned for this in dgetrf, and it's seems like a lot of work to check if the matrix is singular, there are no warnings or errors given for this case.","Part of #1592
Bugfix: No more invalid memory reads on invalid pivot vector.
Slightly problematic end results: A singular matrix seems to result in random output. Since you would be warned for this in dgetrf, and it's seems like a lot of work to check if the matrix is singular, there are no warnings or errors given for this case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1657,2021-02-10T14:23:51Z,2021-02-12T20:12:33Z,2021-02-12T20:12:33Z,MERGED,True,251,17,5,https://github.com/GroteGnoom,Add lapack_dgetrs unit tests,6,[],https://github.com/igraph/igraph/pull/1657,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1657#issuecomment-778418643,"Part of #1592
Bugfix: No more invalid memory reads on invalid pivot vector.
Slightly problematic end results: A singular matrix seems to result in random output. Since you would be warned for this in dgetrf, and it's seems like a lot of work to check if the matrix is singular, there are no warnings or errors given for this case.",I'll make the changed from my comments (just a heads up so we don't step on each other's toes),True,{}
igraph/igraph,https://github.com/igraph/igraph,1657,2021-02-10T14:23:51Z,2021-02-12T20:12:33Z,2021-02-12T20:12:33Z,MERGED,True,251,17,5,https://github.com/GroteGnoom,Add lapack_dgetrs unit tests,6,[],https://github.com/igraph/igraph/pull/1657,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1657#issuecomment-778420297,"Part of #1592
Bugfix: No more invalid memory reads on invalid pivot vector.
Slightly problematic end results: A singular matrix seems to result in random output. Since you would be warned for this in dgetrf, and it's seems like a lot of work to check if the matrix is singular, there are no warnings or errors given for this case.","Allright! I almost got started 🙂
Also, the merge broke test_utilities.inc.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1658,2021-02-11T17:42:15Z,2021-02-13T09:26:31Z,2021-02-13T09:42:24Z,MERGED,True,131,9,2,https://github.com/RamySaied1,Add igraph_heap_ functions unit tests,6,[],https://github.com/igraph/igraph/pull/1658,https://github.com/RamySaied1,1,https://github.com/igraph/igraph/pull/1658,issue #1577,issue #1577,True,{}
igraph/igraph,https://github.com/igraph/igraph,1658,2021-02-11T17:42:15Z,2021-02-13T09:26:31Z,2021-02-13T09:42:24Z,MERGED,True,131,9,2,https://github.com/RamySaied1,Add igraph_heap_ functions unit tests,6,[],https://github.com/igraph/igraph/pull/1658,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1658#issuecomment-778424594,issue #1577,Thanks for the fixes! Be sure to comment here when you feel it's ready so we don't step on each others toes trying to edit the same files.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1658,2021-02-11T17:42:15Z,2021-02-13T09:26:31Z,2021-02-13T09:42:24Z,MERGED,True,131,9,2,https://github.com/RamySaied1,Add igraph_heap_ functions unit tests,6,[],https://github.com/igraph/igraph/pull/1658,https://github.com/RamySaied1,3,https://github.com/igraph/igraph/pull/1658#issuecomment-778587061,issue #1577,"Thanks for the fixes! Be sure to comment here when you feel it's ready so we don't step on each others toes trying to edit the same files.

it's done now",True,{}
igraph/igraph,https://github.com/igraph/igraph,1658,2021-02-11T17:42:15Z,2021-02-13T09:26:31Z,2021-02-13T09:42:24Z,MERGED,True,131,9,2,https://github.com/RamySaied1,Add igraph_heap_ functions unit tests,6,[],https://github.com/igraph/igraph/pull/1658,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1658#issuecomment-778589556,issue #1577,"Thanks for your contribution, it looks great!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1659,2021-02-12T09:33:20Z,2021-02-12T19:44:50Z,2021-02-12T19:44:50Z,MERGED,True,106,3,5,https://github.com/GroteGnoom,Add layout_star unit tests,2,[],https://github.com/igraph/igraph/pull/1659,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1659,"Part of #1592
Caution: For this function the error checking time for out of range
order indices can be close to the total running time, so I'm not
100% sure about it.","Part of #1592
Caution: For this function the error checking time for out of range
order indices can be close to the total running time, so I'm not
100% sure about it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1659,2021-02-12T09:33:20Z,2021-02-12T19:44:50Z,2021-02-12T19:44:50Z,MERGED,True,106,3,5,https://github.com/GroteGnoom,Add layout_star unit tests,2,[],https://github.com/igraph/igraph/pull/1659,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1659#issuecomment-778413120,"Part of #1592
Caution: For this function the error checking time for out of range
order indices can be close to the total running time, so I'm not
100% sure about it.",I think it's alright. This function is nor performance critical. It's running time would be impercetible for any graph that is small enough to be visualized. The error checking is more valuable than speed here.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1660,2021-02-12T16:55:47Z,2021-02-15T21:21:43Z,2021-02-15T21:21:48Z,MERGED,True,268,49,4,https://github.com/GroteGnoom,Add arpack unpack complex unit tests,7,[],https://github.com/igraph/igraph/pull/1660,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1660,"There were a few bugs:
The first output vector was conjugated, even though it should be the unconjugated version (https://igraph.discourse.group/t/the-unit-tests-thread/597/23)
Memory was accessed out of bounds on normal input, and values were incorrect.
I rewrote the code. The new version has the bugs fixed, but does use more memory. I hope this is ok, but I can easily revert it. But then I would have to find a way to fix the old code.
If people were using this and it was working then I probably misunderstood something.
This requires matrix_init_real_row_major from #1657.","There were a few bugs:
The first output vector was conjugated, even though it should be the unconjugated version (https://igraph.discourse.group/t/the-unit-tests-thread/597/23)
Memory was accessed out of bounds on normal input, and values were incorrect.
I rewrote the code. The new version has the bugs fixed, but does use more memory. I hope this is ok, but I can easily revert it. But then I would have to find a way to fix the old code.
If people were using this and it was working then I probably misunderstood something.
This requires matrix_init_real_row_major from #1657.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1660,2021-02-12T16:55:47Z,2021-02-15T21:21:43Z,2021-02-15T21:21:48Z,MERGED,True,268,49,4,https://github.com/GroteGnoom,Add arpack unpack complex unit tests,7,[],https://github.com/igraph/igraph/pull/1660,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1660#issuecomment-779188788,"There were a few bugs:
The first output vector was conjugated, even though it should be the unconjugated version (https://igraph.discourse.group/t/the-unit-tests-thread/597/23)
Memory was accessed out of bounds on normal input, and values were incorrect.
I rewrote the code. The new version has the bugs fixed, but does use more memory. I hope this is ok, but I can easily revert it. But then I would have to find a way to fix the old code.
If people were using this and it was working then I probably misunderstood something.
This requires matrix_init_real_row_major from #1657.","Thanks, looks good to me, a few minor comments are above.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1660,2021-02-12T16:55:47Z,2021-02-15T21:21:43Z,2021-02-15T21:21:48Z,MERGED,True,268,49,4,https://github.com/GroteGnoom,Add arpack unpack complex unit tests,7,[],https://github.com/igraph/igraph/pull/1660,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1660#issuecomment-779453307,"There were a few bugs:
The first output vector was conjugated, even though it should be the unconjugated version (https://igraph.discourse.group/t/the-unit-tests-thread/597/23)
Memory was accessed out of bounds on normal input, and values were incorrect.
I rewrote the code. The new version has the bugs fixed, but does use more memory. I hope this is ok, but I can easily revert it. But then I would have to find a way to fix the old code.
If people were using this and it was working then I probably misunderstood something.
This requires matrix_init_real_row_major from #1657.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1661,2021-02-12T19:31:02Z,2021-02-17T19:00:28Z,2021-02-17T19:00:28Z,CLOSED,False,5331,2078,124,https://github.com/guyroznb,Diameter with edges,98,[],https://github.com/igraph/igraph/pull/1661,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1661,"answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks","answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,1662,2021-02-13T18:00:34Z,2021-02-13T19:54:49Z,2021-02-13T19:55:01Z,MERGED,True,21,0,1,https://github.com/szhorvat,igraph_abort() now prints a stack trace when using AddressSanitizer,4,[],https://github.com/igraph/igraph/pull/1662,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1662,"This PR adds printing a stack trace to igraph_abort() when using AddressSanitizer. All ways to abort igraph go through igraph_abort, including errors (with the default handler, used by tests), IGRAPH_ASSERT and fatal errors.

Potential problem: This sanitizer API is likely not stable. See also https://stackoverflow.com/q/66184498/695132

Example:
I added an IGRAPH_ERROR call to igraph_strength(), and ran the example::igraph_knn test.
Error at src/properties/degrees.c:380 : Booyaa! - Failed.

Stack trace:
    #0 0x10d1fcd0f in __sanitizer_print_stack_trace (libasan.6.dylib:x86_64+0x3dd0f)
    #1 0x10c7205f9 in igraph_abort error.c:65
    #2 0x10c72095f in igraph_error_handler_abort error.c:194
    #3 0x10c7206d1 in igraph_error error.c:167
    #4 0x10cb08fc3 in igraph_strength degrees.c:380
    #5 0x10cb06d1f in igraph_i_avg_nearest_neighbor_degree_weighted degrees.c:112
    #6 0x10cb07f5e in igraph_avg_nearest_neighbor_degree degrees.c:271
    #7 0x10c646c78 in main igraph_knn.c:50
    #8 0x7fff776b93d4 in start (libdyld.dylib:x86_64+0x163d4)","This PR adds printing a stack trace to igraph_abort() when using AddressSanitizer. All ways to abort igraph go through igraph_abort, including errors (with the default handler, used by tests), IGRAPH_ASSERT and fatal errors.

Potential problem: This sanitizer API is likely not stable. See also https://stackoverflow.com/q/66184498/695132

Example:
I added an IGRAPH_ERROR call to igraph_strength(), and ran the example::igraph_knn test.
Error at src/properties/degrees.c:380 : Booyaa! - Failed.

Stack trace:
    #0 0x10d1fcd0f in __sanitizer_print_stack_trace (libasan.6.dylib:x86_64+0x3dd0f)
    #1 0x10c7205f9 in igraph_abort error.c:65
    #2 0x10c72095f in igraph_error_handler_abort error.c:194
    #3 0x10c7206d1 in igraph_error error.c:167
    #4 0x10cb08fc3 in igraph_strength degrees.c:380
    #5 0x10cb06d1f in igraph_i_avg_nearest_neighbor_degree_weighted degrees.c:112
    #6 0x10cb07f5e in igraph_avg_nearest_neighbor_degree degrees.c:271
    #7 0x10c646c78 in main igraph_knn.c:50
    #8 0x7fff776b93d4 in start (libdyld.dylib:x86_64+0x163d4)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1662,2021-02-13T18:00:34Z,2021-02-13T19:54:49Z,2021-02-13T19:55:01Z,MERGED,True,21,0,1,https://github.com/szhorvat,igraph_abort() now prints a stack trace when using AddressSanitizer,4,[],https://github.com/igraph/igraph/pull/1662,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1662#issuecomment-778661960,"This PR adds printing a stack trace to igraph_abort() when using AddressSanitizer. All ways to abort igraph go through igraph_abort, including errors (with the default handler, used by tests), IGRAPH_ASSERT and fatal errors.

Potential problem: This sanitizer API is likely not stable. See also https://stackoverflow.com/q/66184498/695132

Example:
I added an IGRAPH_ERROR call to igraph_strength(), and ran the example::igraph_knn test.
Error at src/properties/degrees.c:380 : Booyaa! - Failed.

Stack trace:
    #0 0x10d1fcd0f in __sanitizer_print_stack_trace (libasan.6.dylib:x86_64+0x3dd0f)
    #1 0x10c7205f9 in igraph_abort error.c:65
    #2 0x10c72095f in igraph_error_handler_abort error.c:194
    #3 0x10c7206d1 in igraph_error error.c:167
    #4 0x10cb08fc3 in igraph_strength degrees.c:380
    #5 0x10cb06d1f in igraph_i_avg_nearest_neighbor_degree_weighted degrees.c:112
    #6 0x10cb07f5e in igraph_avg_nearest_neighbor_degree degrees.c:271
    #7 0x10c646c78 in main igraph_knn.c:50
    #8 0x7fff776b93d4 in start (libdyld.dylib:x86_64+0x163d4)","I introduced an error on purpose to show how it works. I'll undo it now.
https://dev.azure.com/igraph-team/igraph/_build/results?buildId=547&view=logs&j=4c3a8381-b9de-5463-904f-918810769be8&t=a906eab8-d2a3-5e54-d199-606dbbfb0805&l=631",True,{}
igraph/igraph,https://github.com/igraph/igraph,1662,2021-02-13T18:00:34Z,2021-02-13T19:54:49Z,2021-02-13T19:55:01Z,MERGED,True,21,0,1,https://github.com/szhorvat,igraph_abort() now prints a stack trace when using AddressSanitizer,4,[],https://github.com/igraph/igraph/pull/1662,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1662#issuecomment-778669626,"This PR adds printing a stack trace to igraph_abort() when using AddressSanitizer. All ways to abort igraph go through igraph_abort, including errors (with the default handler, used by tests), IGRAPH_ASSERT and fatal errors.

Potential problem: This sanitizer API is likely not stable. See also https://stackoverflow.com/q/66184498/695132

Example:
I added an IGRAPH_ERROR call to igraph_strength(), and ran the example::igraph_knn test.
Error at src/properties/degrees.c:380 : Booyaa! - Failed.

Stack trace:
    #0 0x10d1fcd0f in __sanitizer_print_stack_trace (libasan.6.dylib:x86_64+0x3dd0f)
    #1 0x10c7205f9 in igraph_abort error.c:65
    #2 0x10c72095f in igraph_error_handler_abort error.c:194
    #3 0x10c7206d1 in igraph_error error.c:167
    #4 0x10cb08fc3 in igraph_strength degrees.c:380
    #5 0x10cb06d1f in igraph_i_avg_nearest_neighbor_degree_weighted degrees.c:112
    #6 0x10cb07f5e in igraph_avg_nearest_neighbor_degree degrees.c:271
    #7 0x10c646c78 in main igraph_knn.c:50
    #8 0x7fff776b93d4 in start (libdyld.dylib:x86_64+0x163d4)","LGTM, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1663,2021-02-13T19:42:37Z,2021-02-13T19:44:55Z,2021-04-21T09:53:18Z,CLOSED,False,133,9,4,https://github.com/GroteGnoom,add fruchterman reingold unit tests,1,[],https://github.com/igraph/igraph/pull/1663,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1663,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1663,2021-02-13T19:42:37Z,2021-02-13T19:44:55Z,2021-04-21T09:53:18Z,CLOSED,False,133,9,4,https://github.com/GroteGnoom,add fruchterman reingold unit tests,1,[],https://github.com/igraph/igraph/pull/1663,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1663#issuecomment-778668373,,"Sorry, I tried using the github command line, and it didn't exactly do what I expected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1664,2021-02-13T19:46:55Z,2021-02-16T10:28:28Z,2021-02-16T10:28:28Z,MERGED,True,186,9,6,https://github.com/GroteGnoom,Add layout_fruchterman_reingold unit tests,5,[],https://github.com/igraph/igraph/pull/1664,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1664,"Part of #1592
This one is hard to test. I mainly put in some values to see of they
looked plausible. It also just seems very well guarded against memory
problems, which is great :)
It is easy to get into obviously suboptimal results by for example
turning the temperature up to ridiculously high values, but that seems
reasonable.
If there are suggestions for different kinds of tests I will of course
gladly add them.

The tests are failing because seeding didn't solve all the randomness problems.","Part of #1592
This one is hard to test. I mainly put in some values to see of they
looked plausible. It also just seems very well guarded against memory
problems, which is great :)
It is easy to get into obviously suboptimal results by for example
turning the temperature up to ridiculously high values, but that seems
reasonable.
If there are suggestions for different kinds of tests I will of course
gladly add them.

The tests are failing because seeding didn't solve all the randomness problems.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1664,2021-02-13T19:46:55Z,2021-02-16T10:28:28Z,2021-02-16T10:28:28Z,MERGED,True,186,9,6,https://github.com/GroteGnoom,Add layout_fruchterman_reingold unit tests,5,[],https://github.com/igraph/igraph/pull/1664,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1664#issuecomment-778807776,"Part of #1592
This one is hard to test. I mainly put in some values to see of they
looked plausible. It also just seems very well guarded against memory
problems, which is great :)
It is easy to get into obviously suboptimal results by for example
turning the temperature up to ridiculously high values, but that seems
reasonable.
If there are suggestions for different kinds of tests I will of course
gladly add them.

The tests are failing because seeding didn't solve all the randomness problems.","This function is likely to be sensitive to small numerical errors, so I'd say it's not really possible to test the output values. The purpose of the x87 configuration in the CI is to catch such over-sensitive tests. While x87 itself is not important, if the result is very sensitive to small perturbations, then the test is likely to give different results (thus ""fail"") on some non-Intel architectures as well. Linux distros like Debian do test their packages on a multitude of architectures, so this would be a problem.
This makes it difficult to test layout algorithms extensively.
I would say that the goal when testing layout algorithms should be (in order of decreasing priority):

Exercise most code paths (in this case: both GRID and NOGRID). Then AddressSanitizer has a chance to catch errors.
Test edge cases (null graph, singleton graph, etc.)
If the output is expected to satisfy some conditions, perhaps test those.  In this case: are the vertices within the bounds? IMO this is less important.

A tip for layout algorithms: pay attention to the case of disconnected graphs. Some algorithms may not handle disconnected graphs very well, and this may not be documented in all cases. I remember that DrL does not like disconnected graphs. If you pass a disconnected graph to DrL, some vertices may fly out to infinity (which is why checking if everything is within some reasonable coordinate bounds may be a good idea).

The Windows test failure is fixed now, just merge the latest develop branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1664,2021-02-13T19:46:55Z,2021-02-16T10:28:28Z,2021-02-16T10:28:28Z,MERGED,True,186,9,6,https://github.com/GroteGnoom,Add layout_fruchterman_reingold unit tests,5,[],https://github.com/igraph/igraph/pull/1664,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1664#issuecomment-779120483,"Part of #1592
This one is hard to test. I mainly put in some values to see of they
looked plausible. It also just seems very well guarded against memory
problems, which is great :)
It is easy to get into obviously suboptimal results by for example
turning the temperature up to ridiculously high values, but that seems
reasonable.
If there are suggestions for different kinds of tests I will of course
gladly add them.

The tests are failing because seeding didn't solve all the randomness problems.",Thanks for the clear and thorough explanation of the whole situation :),True,{}
igraph/igraph,https://github.com/igraph/igraph,1665,2021-02-15T14:24:55Z,2021-02-16T10:50:52Z,2021-02-16T10:50:52Z,MERGED,True,157,5,4,https://github.com/GroteGnoom,Add layout_reingold_tilford_circular unit tests,1,[],https://github.com/igraph/igraph/pull/1665,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1665,"Part of #1592
Removed a comment in the docs which assumed that y=0 for roots of separate trees in reingold_tilford. For two separate trees y=1 which means the roots are also separated for the circular version.","Part of #1592
Removed a comment in the docs which assumed that y=0 for roots of separate trees in reingold_tilford. For two separate trees y=1 which means the roots are also separated for the circular version.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1667,2021-02-16T09:53:39Z,2021-02-16T14:57:06Z,2021-02-16T14:57:09Z,MERGED,True,75,2,4,https://github.com/GroteGnoom,Add layout_random_3d unit tests,3,[],https://github.com/igraph/igraph/pull/1667,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1667,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1667,2021-02-16T09:53:39Z,2021-02-16T14:57:06Z,2021-02-16T14:57:09Z,MERGED,True,75,2,4,https://github.com/GroteGnoom,Add layout_random_3d unit tests,3,[],https://github.com/igraph/igraph/pull/1667,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1667#issuecomment-779767744,Part of #1592,"@ntamas Are we sure we want to output the actual coordinates, which effectively just test the consistency of the default random number generator? It will be some work to update this if we change the default RNG.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1667,2021-02-16T09:53:39Z,2021-02-16T14:57:06Z,2021-02-16T14:57:09Z,MERGED,True,75,2,4,https://github.com/GroteGnoom,Add layout_random_3d unit tests,3,[],https://github.com/igraph/igraph/pull/1667,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1667#issuecomment-779776136,Part of #1592,"It will be some work to update this if we change the default RNG.

The same goes for a lot of other tests. If this is a possibility in the future I should change the way I test these things in general.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1667,2021-02-16T09:53:39Z,2021-02-16T14:57:06Z,2021-02-16T14:57:09Z,MERGED,True,75,2,4,https://github.com/GroteGnoom,Add layout_random_3d unit tests,3,[],https://github.com/igraph/igraph/pull/1667,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1667#issuecomment-779788198,Part of #1592,"@szhorvat Testing consistency is good anyway; users probably expect the default RNG to be consistent and reproducible with the same seed across different platforms. If we change the RNG, that's a breaking change and we should take time to update the tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1667,2021-02-16T09:53:39Z,2021-02-16T14:57:06Z,2021-02-16T14:57:09Z,MERGED,True,75,2,4,https://github.com/GroteGnoom,Add layout_random_3d unit tests,3,[],https://github.com/igraph/igraph/pull/1667,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1667#issuecomment-779890880,Part of #1592,Just in time to make it to 0.9.0 :),True,{'HOORAY': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1668,2021-02-16T13:18:39Z,2021-02-17T10:23:48Z,2021-02-17T10:23:48Z,MERGED,True,127,13,4,https://github.com/GroteGnoom,Add layout graphopt unit tests,4,[],https://github.com/igraph/igraph/pull/1668,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1668,"I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).","I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1668,2021-02-16T13:18:39Z,2021-02-17T10:23:48Z,2021-02-17T10:23:48Z,MERGED,True,127,13,4,https://github.com/GroteGnoom,Add layout graphopt unit tests,4,[],https://github.com/igraph/igraph/pull/1668,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1668#issuecomment-779860431,"I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).","It is very strange that the spring length is treated as an integer internally. As any physical length, it should be a real number. @gaborcsardi do you recall why it was an integer?
Here is the original graphopt: http://www.schmuhl.org/graphopt/  From a quick (and not very careful) look, my best guess is that this was made an integer so that it would be easy to adjust through a spinbox GUI.
I would propose the opposite: keep the interface as is and change all internal spring_length variables to real numbers.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1668,2021-02-16T13:18:39Z,2021-02-17T10:23:48Z,2021-02-17T10:23:48Z,MERGED,True,127,13,4,https://github.com/GroteGnoom,Add layout graphopt unit tests,4,[],https://github.com/igraph/igraph/pull/1668,https://github.com/gaborcsardi,3,https://github.com/igraph/igraph/pull/1668#issuecomment-779865385,"I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).","I don't remember, sounds good to me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1668,2021-02-16T13:18:39Z,2021-02-17T10:23:48Z,2021-02-17T10:23:48Z,MERGED,True,127,13,4,https://github.com/GroteGnoom,Add layout graphopt unit tests,4,[],https://github.com/igraph/igraph/pull/1668,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1668#issuecomment-780437393,"I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).","I would propose the opposite: keep the interface as is and change all internal spring_length variables to real numbers.

What's the status of this? In the PR it is still an igraph_real_t but now we have a stamp of approval :) I don't mind either way, there will be API breakages in 0.10 anyway.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1668,2021-02-16T13:18:39Z,2021-02-17T10:23:48Z,2021-02-17T10:23:48Z,MERGED,True,127,13,4,https://github.com/GroteGnoom,Add layout graphopt unit tests,4,[],https://github.com/igraph/igraph/pull/1668,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1668#issuecomment-780448858,"I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).","@ntamas Previsouly it was a real in the API, but it was an int internally. Now it is a real internally as well. I looked through the code and I could see no reason to avoid a real. I think the original code used an int because the parameter was tied to a GUI control that can only set integers.
I approved but didn't merge because I thought we might want to merge most of the new tests into master now (unless the API had to be changed or the behaviour was changed significantly). It's very easy to rebase right here on GitHub.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1668,2021-02-16T13:18:39Z,2021-02-17T10:23:48Z,2021-02-17T10:23:48Z,MERGED,True,127,13,4,https://github.com/GroteGnoom,Add layout graphopt unit tests,4,[],https://github.com/igraph/igraph/pull/1668,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1668#issuecomment-780454711,"I changed the interface of graphopt, because I though it would be clearer and would not lead to any actual interface changes. As far as I can tell the same thing should happen for the same arguments (except maybe less overflows if igraph_integer_t is bigger than int).","Okay, let's merge this into master then! Can you do the rebase and merge?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1669,2021-02-16T17:50:33Z,2021-02-17T13:52:57Z,2021-02-17T13:52:58Z,MERGED,True,160,4,4,https://github.com/GroteGnoom,Add layout_bipartite unit_tests,5,[],https://github.com/igraph/igraph/pull/1669,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1669,"Part of #1592
Fix: The implementation assumed bools were either 1 or 0.
New error: negative horizontal gaps resulted in x-coordinates that were all zero, so that is excluded.","Part of #1592
Fix: The implementation assumed bools were either 1 or 0.
New error: negative horizontal gaps resulted in x-coordinates that were all zero, so that is excluded.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1670,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1670#issuecomment-780866119,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","The DrL layout is designed for very large graphs and I suspect that it simply fails to converge for small(ish) graphs -- it just keeps on iterating forever. Also, the entire algorithm is black magic and I have no idea how to test the output or what the acceptable range of X-Y values is.
I would suggest that we test the branches in the code that verify the input arguments and bail out if the input argument is invalid. Besides that, let's just have one invocation of the DrL layout that tests the ""normal"" code path for a simple graph (say, the Zachary karate club graph from igraph_famous()), with a small number of iterations to make the test finish faster.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1670#issuecomment-780879735,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","Here's some more info on DrL: https://github.com/gephi/gephi/wiki/OpenOrd
It says the same thing as @ntamas ,

It is one of the few force-directed layout algorithms that can scale to over 1 million nodes, making it ideal for large graphs. However, small graphs (hundreds or less) do not always end up looking so good.

DrL was at some point renamed to OpenOrd. The original sources are no longer available from Sandia, though it's possible to find some (perhaps modified?) copies on GitHub.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1670#issuecomment-780880866,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","Also, I recall DrL had problems with disconnected graphs, see #881 .
This is not unusual: many layouts are designed specifically for connected graphs, with the expectations that connected components would be laid out separate, then the results arranged nicely. igraph has some limited facilities to do this, see the layout_merge functions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1670#issuecomment-780882672,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","Hm, actually I found the original sources, dated 2009. They look similar enough that at some point an update of igraph's version might even be feasible. I don't know if it's worth it though ...
https://www.sandia.gov/smartin/software.html",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1670#issuecomment-781112572,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","With layout functions that use the random number generator, we should set a seed at the beginning of the set.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1670#issuecomment-781258388,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","Thanks for all the information :) I made things simpler and faster and it seems to give normal results. It's still pretty slow for very few iterations, for small graphs it seems to do most of the work up front.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1670#issuecomment-781381033,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","FWIW, the test takes about 4 seconds in the CI env, which is slower than most of the unit tests but still not one of the slowest ones. Plus, since the tests are parallelized, it probably doesn't make much of a difference. I'm okay with leaving it as is for the time being.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1670#issuecomment-781458310,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","@ntamas The DrL test didn't seem slow on my machine, so I digged in a bit. It turns out that when I compile it with GCC 10.2, it takes 1.0 seconds. When I compile with Apple Clang 11, it takes 0.06 seconds. Both tested on macOS 10.14. That's a 20x difference, which is at least worrying. This sort of thing can't be explained by one compiler doing better.
I used RelWithDebInfo configuration in both cases.
Note that on the CI you can't judge the performance on macOS as after macOS 10.15, Apple does extra checks on executables when they're first started, so all tests take at least 0.35 s or so. But you can see that the DrL one does not stand out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1670#issuecomment-781465624,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.",It's not GCC vs Clang. It's a libstdc++ vs libc++ thing. I see the bad performance with libstdc++ and Clang 11 as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1670#issuecomment-781472162,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","I believe it's the creation of a million deques that's responsible for this. In particular this line:
https://github.com/igraph/igraph/blob/master/src/layout/drl/DensityGrid.cpp#L71
Almost all time is spent in the constructor and destructor of drl::graph because of this (and comparatively no time is spent in the actual layout computation).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1670#issuecomment-781476581,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","I came to the same conclusion with my own investigations that I did today. It may be the case that libc++ defers the actual creation of the queues until something is placed in the queue, while libstdc++ does not. We could potentially work around it by constructing the queues lazily, although I'm not sure whether it's worth the fuss.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1670,2021-02-17T12:20:57Z,2021-02-18T14:27:11Z,2021-02-18T17:13:05Z,MERGED,True,120,2,3,https://github.com/GroteGnoom,Add drl_layout unit tests,4,[],https://github.com/igraph/igraph/pull/1670,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1670#issuecomment-781498935,"Part of #1592
Some issues with this commit:
I don't know which x and y values should be acceptable. There seems to
be a continuous range of possible end results with different parameters,
instead of things being suddenly obviously out of range.
Negative damping coefficients seem to have a propensity to cause
segfaults. I know where the segfault takes place, but I haven't done
the research to figure out when exactly problems occur. If negative
damping should be allowed I can investigate further.
These tests are way slower than average tests.","It seems that this is a constant (i.e. graph size independent) overhead of 1 second for any call of DrL when using GCC. That's not nice at all, but considering that DrL is meant for huge graphs that will take much longer than a second to lay out, and doesn't produce very nice results for small graphs, it's not a big deal in the end.
The newer version of DrL, OpenOrd, has the exact same code, so upgrading won't help.
What about slower computers? On the RPi 4 it takes 2 seconds and 600 MB of memory. My RPi 1 does not have enough memory to try.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1671,2021-02-17T13:47:03Z,2021-02-17T13:51:52Z,2021-02-17T13:51:57Z,MERGED,True,78,2,4,https://github.com/GroteGnoom,Add running_mean unit tests,2,[],https://github.com/igraph/igraph/pull/1671,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1671,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1671,2021-02-17T13:47:03Z,2021-02-17T13:51:52Z,2021-02-17T13:51:57Z,MERGED,True,78,2,4,https://github.com/GroteGnoom,Add running_mean unit tests,2,[],https://github.com/igraph/igraph/pull/1671,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1671#issuecomment-780569823,Part of #1592,Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1673,2021-02-17T19:30:54Z,2021-02-23T15:22:47Z,2021-02-23T17:40:25Z,MERGED,True,191,69,9,https://github.com/guyroznb,diameter path of edges,29,[],https://github.com/igraph/igraph/pull/1673,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1673,"answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks","answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,1673,2021-02-17T19:30:54Z,2021-02-23T15:22:47Z,2021-02-23T17:40:25Z,MERGED,True,191,69,9,https://github.com/guyroznb,diameter path of edges,29,[],https://github.com/igraph/igraph/pull/1673,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1673#issuecomment-780885807,"answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks","I changed the base to develop again. Since this PR changes the API, it's going to be merged into develop, and will become part of the next version, 0.10.  This change should not affect you in any way.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1673,2021-02-17T19:30:54Z,2021-02-23T15:22:47Z,2021-02-23T17:40:25Z,MERGED,True,191,69,9,https://github.com/guyroznb,diameter path of edges,29,[],https://github.com/igraph/igraph/pull/1673,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1673#issuecomment-782062698,"answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks","Looks like there are some genuine test failures so I'm putting this into draft state until these are resolved.
@guyroznb Feel free to mark it as ""ready for review"" when the test failures are fixed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1673,2021-02-17T19:30:54Z,2021-02-23T15:22:47Z,2021-02-23T17:40:25Z,MERGED,True,191,69,9,https://github.com/guyroznb,diameter path of edges,29,[],https://github.com/igraph/igraph/pull/1673,https://github.com/guyroznb,4,https://github.com/igraph/igraph/pull/1673#issuecomment-782926125,"answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks",thanks @szhorvat and @ntamas for the review!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1673,2021-02-17T19:30:54Z,2021-02-23T15:22:47Z,2021-02-23T17:40:25Z,MERGED,True,191,69,9,https://github.com/guyroznb,diameter path of edges,29,[],https://github.com/igraph/igraph/pull/1673,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1673#issuecomment-784279387,"answers issue #1542 - returning the path of the diameter in terms of edges and / or vertices.
thanks","Thanks a lot for the PR, much appreciated!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1674,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1674#issuecomment-781427145,Part of #1592,"Is there a proper way to check stderr? The seem to be some platform-dependent ways to redirect it to stdout, but that's probably not the way to go. Should we also have .err files instead of only .out?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1674#issuecomment-781985844,Part of #1592,"Is there a proper way to check stderr?

No, not in the current testing framework. But since testing stderr is rare, I would say the easiest way to proceed is like this:
--- a/etc/cmake/run_legacy_test.cmake
+++ b/etc/cmake/run_legacy_test.cmake
@@ -33,6 +33,7 @@ execute_process(
   WORKING_DIRECTORY ${WORK_DIR}
   RESULT_VARIABLE ERROR_CODE
   OUTPUT_VARIABLE OBSERVED_OUTPUT
+  ERROR_VARIABLE OBSERVED_OUTPUT
 )

 if(ERROR_CODE EQUAL 77)
This essentially merges stdout and stderr into the same variable in CMake, which we then compare with the expected output file in some_test_name.out.
If we stick to the convention that a test case writes expected output either to stdout or to stderr but never both, then the only issue that we won't catch with this is when the expected output appears on the wrong stream.
Can you test whether this solution works for you?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1674#issuecomment-781985953,Part of #1592,"Please add IGRAPH_EXPORT to this declaration in the header:
extern igraph_progress_handler_t igraph_progress_handler_stderr;",True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1674#issuecomment-781986280,Part of #1592,"Note that CMake's documentation says this about using the same variable for catching stdout and stderr:

OUTPUT_VARIABLE, ERROR_VARIABLE
The variable named will be set with the contents of the standard output and standard error pipes, respectively. If the same variable is named for both pipes their output will be merged in the order produced.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1674#issuecomment-781987524,Part of #1592,"This essentially merges stdout and stderr into the same variable in CMake, which we then compare with the expected output file in some_test_name.out.

I'm not sure I'm happy to start merging stdout and stderr output and comparing to the .out files. There is value in keeping the two separate. All errors e.g. from ASan go to stderr. Sometimes a wrong output and some ASan failure come together and this will make it harder to disentangle them.
I would simply skip testing what this function outputs to stderr and instead just let the test exercise the function. That is still a useful test: it just exposed a bug we had. The function was not exported from the shared library and therefore didn't work at all with shared builds. Thanks to this test we detected the problem.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1674#issuecomment-782041551,Part of #1592,"There is value in keeping the two separate.

Sure it is, but the code in run_legacy_tests.cmake would be much more convoluted if we could have an .out file, an .err file or both. If ASAN routinely writes its output to stderr, then this obviously changes things -- in that case, let's just validate that the test compiles and runs but let's not check what it writes to stderr.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1674,2021-02-18T13:34:14Z,2021-02-19T16:33:51Z,2021-02-19T16:33:51Z,MERGED,True,89,7,6,https://github.com/GroteGnoom,Add progress_handler_stderr unit tests,4,[],https://github.com/igraph/igraph/pull/1674,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1674#issuecomment-782049883,Part of #1592,"let's just validate that the test compiles and runs but let's not check what it writes to stderr.

Yes, that is what I meant.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1675,2021-02-19T10:03:30Z,2021-02-19T10:55:21Z,2021-02-19T10:55:21Z,MERGED,True,135,31,5,https://github.com/GroteGnoom,Add rng unit tests,6,[],https://github.com/igraph/igraph/pull/1675,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1675,"Part of #1592
It all seems to work fine. I added some doc improvements, and changed 0 error codes to IGRAPH_SUCCESS in general.","Part of #1592
It all seems to work fine. I added some doc improvements, and changed 0 error codes to IGRAPH_SUCCESS in general.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1675,2021-02-19T10:03:30Z,2021-02-19T10:55:21Z,2021-02-19T10:55:21Z,MERGED,True,135,31,5,https://github.com/GroteGnoom,Add rng unit tests,6,[],https://github.com/igraph/igraph/pull/1675,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1675#issuecomment-781981853,"Part of #1592
It all seems to work fine. I added some doc improvements, and changed 0 error codes to IGRAPH_SUCCESS in general.","Can you please try to add an IGRAPH_EXPORT to these lines in the header?
extern const igraph_rng_type_t igraph_rngtype_glibc2;
extern const igraph_rng_type_t igraph_rngtype_rand;
extern const igraph_rng_type_t igraph_rngtype_mt19937;",True,{}
igraph/igraph,https://github.com/igraph/igraph,1675,2021-02-19T10:03:30Z,2021-02-19T10:55:21Z,2021-02-19T10:55:21Z,MERGED,True,135,31,5,https://github.com/GroteGnoom,Add rng unit tests,6,[],https://github.com/igraph/igraph/pull/1675,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1675#issuecomment-781983948,"Part of #1592
It all seems to work fine. I added some doc improvements, and changed 0 error codes to IGRAPH_SUCCESS in general.","Can you please fix the description of igraph_rngtype_rand? It says rand/stand, should be rand/srand.
For igraph_rngtype_glibc2, please clarify in the docs that this is a (re)implementation of this generator. It does not actually call the one in glibc on the system.
I'd do these, but then we might edit the same file and the same time and create conflicts.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1678,2021-02-19T14:22:35Z,2021-02-21T17:49:54Z,2021-02-21T17:49:54Z,MERGED,True,103,3,4,https://github.com/GroteGnoom,Add sparsemat_fkeep unit tests,5,[],https://github.com/igraph/igraph/pull/1678,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1678,"Part of #1592
Fix: Error checking assumed a non-zero return value meant success, but
-1 is the returned on errors.
All error checking is now done in the igraph_sparsemat_fkeep function,
so we have more information about what went wrong.","Part of #1592
Fix: Error checking assumed a non-zero return value meant success, but
-1 is the returned on errors.
All error checking is now done in the igraph_sparsemat_fkeep function,
so we have more information about what went wrong.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1678,2021-02-19T14:22:35Z,2021-02-21T17:49:54Z,2021-02-21T17:49:54Z,MERGED,True,103,3,4,https://github.com/GroteGnoom,Add sparsemat_fkeep unit tests,5,[],https://github.com/igraph/igraph/pull/1678,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1678#issuecomment-782854291,"Part of #1592
Fix: Error checking assumed a non-zero return value meant success, but
-1 is the returned on errors.
All error checking is now done in the igraph_sparsemat_fkeep function,
so we have more information about what went wrong.","Could you please add another short test that removes all elements from a non-zero-size matrix (i.e. the fkeep function returns true for everything)? This would have failed previsouly, as the 0 return was wrongly interpreted as failure.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1680,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1680#issuecomment-782264598,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","It is unfortunate that igraph_sparsemat_nonzero_storage, igraph_sparsemat_nzmax, igraph_sparsemat_iterator_row, igraph_sparsemat_iterator_col, igraph_sparsemat_iterator_next, igraph_sparsemat_iterator_idx return an int. When I see int, I assume error code.
I would like to cautiously suggest making these return an igraph_integer_t for clarity. Currently an igraph_integer_t is an int, so this would not break API and we can have it in 0.9.1. It would be a cosmetic change for now.
If in the future we change igraph_integer_t, CXSparse has the flexibility to adapt (it comes with several versions, some of which use longer values).
@ntamas Any objections to making these functions return igraph_integer_t?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1680#issuecomment-782271970,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","Maybe it's not a quick practical solution, but shouldn't all the other functions actually return igraph_error_type_t?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1680#issuecomment-782312100,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","There was a proposal earlier (from Vincent or me, can't remember) that we introduce igraph_error_t as a typedef to int, and then we can make it explicit which functions return an error code. This would be my preferred direction instead of replacing genuine ints with igraph_integer_t.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1680#issuecomment-782313209,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","FYI, doxrox include bug is fixed in 4cd9dad",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1680#issuecomment-782318383,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","There was a proposal earlier (from Vincent or me, can't remember) that we introduce igraph_error_t as a typedef to int, and then we can make it explicit which functions return an error code. This would be my preferred direction instead of replacing genuine ints with igraph_integer_t.

Why doesn't igraph_error_type_t suffice?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1680#issuecomment-782321192,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","Vincent's proposal was to use igraph_error_type_t, but that was trouble to use last time I tried. I don't recall all the reasons but one reason was that C++ doesn't allow freely mixing integer values with enums, so it was very cumbersome to change it everywhere. igraph needs to stay usable from C++. The main argument against was that it appears to be a lot of work to make all the changes, for relatively little gain—but it's doable.
That's when Tamás suggested the typedef.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1680,2021-02-19T18:19:42Z,2021-02-19T20:12:58Z,2021-02-19T21:51:36Z,MERGED,True,97,8,4,https://github.com/GroteGnoom,Add sparsemat_nonzero_storage unit tests,1,[],https://github.com/igraph/igraph/pull/1680,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1680#issuecomment-782322185,"Part of #1592
Also added some documentation.
Biggest change: Documentation with one space missing in doxrox were
silently ignored. Fixed the spaces, not the silent
ignoring.","Regarding those ints: when we transition to a wide igraph_integer_t, I would at the same time transition to a version of CXSparse that can be matched with its integer type. CXSparse supports different integer type widths. Thus at least at that point I would still argue for using igraph_integer_t (at least so that we can store more than 2^31-1 elements in a sparse array, i.e. more than that many edges in a graph).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1681,2021-02-20T11:28:56Z,2021-02-21T17:45:43Z,2021-02-21T17:45:43Z,MERGED,True,130,1,5,https://github.com/GroteGnoom,Add sparsemat_getelements_sorted unit tests,2,[],https://github.com/igraph/igraph/pull/1681,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1681,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1685,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1685#issuecomment-782906741,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","The purpose of this function is similar to that of igraph_vector_view: take existing raw data, and create a ""view"" to it. The compressed sparse column (or row) format is quite common, other systems use it extensively. This function provides a chance to directly access such data from another library without copying it.
With igraph_vector_view and igraph_matrix_view there is no need to have a special destructor, as the only dynamically allocated part of an igraph_vector_t or igraph_matrix_t is the raw data array. As you say, igraph_sparsemat_t is different, as it does not embed a cs_di_sparse, instead it points to one. I am not sure why. Do you know @ntamas ? Life would certainly be easier if it embedded the cs_di_sparse, but we can't make that change for 0.9 anymore, as all 0.9.x releases should be binary-compatible with each other.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1685#issuecomment-784113987,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.",Can you please point me to where the internal representation of the triplet format is described?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1685#issuecomment-784147993,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","Can you please point me to where the internal representation of the triplet format is described?

I haven't found anything like that. CXSparse is quite concise in its documentation. Since our documentation was also not available I just tried to figure things out by running functions and looking at code. This is why some of my descriptions are a little clumsy because I don't fully understand the intent.
The best I have is the struct. 
  
    
      igraph/vendor/cs/cs.h
    
    
         Line 61
      in
      97c96f6
    
  
  
    

        
          
           typedef struct cs_di_sparse  /* matrix in compressed-column or triplet form */",True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1685#issuecomment-784242728,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","I made some changes to the docs. Could you please update the tests and plug in some data, convert to dense with igraph_sparsemat_as_matrix and print it?
For example, here's a dense matrix:
0	5
1	0
0	2

Here's the sparse representation as compressed format:
int p[] = {0, 1, 3};
int i[]  = {1, 0, 2};
double x[] = {1, 5, 2};

Hope I didn't make a mistake.
I change the cs_malloc to igraph_Calloc. Please change the free to igraph_free as well.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1685#issuecomment-784243584,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","Oops, it seems we also need the igraph_memory.h header at the top for the igraph_Calloc, which I just added.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1685#issuecomment-784266157,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","Oops, it seems we also need the igraph_memory.h header at the top for the igraph_Calloc, which I just added.

I think the errors were because igraph_Calloc takes in a type, not a size.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1685#issuecomment-784273534,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.","Thanks for finalizing it! I was using the web interface on GitHub to edit the docs, so it was a but cumbersome to make all changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1685,2021-02-21T13:25:25Z,2021-02-23T15:16:05Z,2021-02-23T15:18:23Z,MERGED,True,106,2,5,https://github.com/GroteGnoom,Add sparsemat_view unit tests and doc,4,[],https://github.com/igraph/igraph/pull/1685,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1685#issuecomment-784275961,"Part of #1592
This init function does not seem to have a corresponding destroy
function. sparsemat_view calls cs_calloc directly for the struct, but
doesn't allocate the index and element vectors. igraph users don't have
direct access to cs_malloc to allocate their own through the cs
interface. They also don't have access to cs_free through igraph. So
currently there's no proper destruction without assuming cs_free and
cs_malloc use free and malloc as they do now.",No problem 🙂 Programming is much nicer with a compiler by your side.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1687,2021-02-22T11:27:25Z,2021-02-23T15:29:08Z,2021-02-23T15:29:08Z,MERGED,True,154,4,4,https://github.com/GroteGnoom,"Add sparsemat_iterator_dix unit tests, add docs",1,[],https://github.com/igraph/igraph/pull/1687,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1687,"Part of #1592
Bugfix: sparsemat_iterator_reset didn't set the column for triplet
matrices.","Part of #1592
Bugfix: sparsemat_iterator_reset didn't set the column for triplet
matrices.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1688,2021-02-22T13:23:32Z,2021-02-25T15:10:27Z,2021-02-25T15:10:33Z,MERGED,True,129,59,7,https://github.com/GroteGnoom,Add spmatrix_add_col_values unit tests,2,[],https://github.com/igraph/igraph/pull/1688,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1688,"Part of #1592
There's an igraph_spmatrix_fprint, that one seems better if you want to conserve space, this one (print_spmatrix) prints the matrix like a normal matrix.","Part of #1592
There's an igraph_spmatrix_fprint, that one seems better if you want to conserve space, this one (print_spmatrix) prints the matrix like a normal matrix.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1688,2021-02-22T13:23:32Z,2021-02-25T15:10:27Z,2021-02-25T15:10:33Z,MERGED,True,129,59,7,https://github.com/GroteGnoom,Add spmatrix_add_col_values unit tests,2,[],https://github.com/igraph/igraph/pull/1688,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1688#issuecomment-785973418,"Part of #1592
There's an igraph_spmatrix_fprint, that one seems better if you want to conserve space, this one (print_spmatrix) prints the matrix like a normal matrix.",Thank you!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1689,2021-02-23T10:29:50Z,2021-02-23T19:46:02Z,2021-02-23T19:46:10Z,MERGED,True,70,2,3,https://github.com/GroteGnoom,Add igraph_subisomorphic unit tests,3,[],https://github.com/igraph/igraph/pull/1689,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1689,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1689,2021-02-23T10:29:50Z,2021-02-23T19:46:02Z,2021-02-23T19:46:10Z,MERGED,True,70,2,3,https://github.com/GroteGnoom,Add igraph_subisomorphic unit tests,3,[],https://github.com/igraph/igraph/pull/1689,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1689#issuecomment-784464318,Part of #1592,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1690,2021-02-23T12:40:00Z,2021-02-24T12:57:39Z,2021-02-24T12:57:39Z,MERGED,True,87,5,4,https://github.com/GroteGnoom,Add sparsemat_droptol unit tests,2,[],https://github.com/igraph/igraph/pull/1690,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1690,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1691,2021-02-23T13:57:26Z,2021-02-25T10:05:03Z,2021-02-25T10:05:03Z,MERGED,True,85,5,4,https://github.com/GroteGnoom,"Add strvector set2, remove, print unit tests",2,[],https://github.com/igraph/igraph/pull/1691,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1691,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1692,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.","When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1692#issuecomment-784495413,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.","Why don't you use TO_NATIVE_PATH instead of the string(REPLACE ""/"" ""\\"" IGRAPH_LIBDIR ${IGRAPH_LIBDIR}) too?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1692#issuecomment-784497187,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.",That does not work because the native path is different from the path in which the test command is being run. That was at least the outcome of the previous debugging session on MSYS. I'd be happy to give that another try though.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1692#issuecomment-784497506,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.","However, for some reason the msys GH actions don't seem to be triggered. Any idea why not?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1692#issuecomment-784499393,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.","Not too familiar with GH Actions, but I suspect this:
https://github.com/igraph/igraph/blob/master/.github/workflows/build-cmake.yml#L10",True,{}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1692#issuecomment-784501905,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.","I removed that restriction, can you pull from master now?",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1692,2021-02-23T20:23:45Z,2021-02-23T21:50:15Z,2021-02-23T21:50:15Z,MERGED,True,17,5,1,https://github.com/vtraag,Made paths for testing in Windows more robust,3,[],https://github.com/igraph/igraph/pull/1692,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1692#issuecomment-784526309,"When building a shared library on Windows, we automatically add the necessary paths to ensure the shared libraries are found when running ctest. This does not work well when there are paths included that end with a backslash, because the trailing backslash is then incorrectly interpreted as an escape character. This problem was raised in #1686, and this PR should fix this.
This PR changes the way that the path is constructed to ensure that each path is correctly included in a semi-colon separated string. Presumably, when 3.20 comes out, this can be replaced by a TO_NATIVE_PATH_LIST construct. Of course, we may want to wait until this version of cmake is sufficiently well available. Anyway, as a reminder, I also mentioned this possibility in the comments.
Hopefully, this also still works well with msys. Let's see how the CI does.","It now seems to work well. Perhaps there are still other situations in which ctest can be invoked that may lead to a potential problem, but at least not in this current setup. As far as I'm concerned we can merge it. I left most of the comment in, to remind us of potential problems should it ever turn out to be a problem still.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1693,2021-02-23T21:12:20Z,2021-03-09T14:08:20Z,2021-03-09T14:08:20Z,CLOSED,False,18,1,1,https://github.com/szhorvat,gh actions: enable cache,16,[],https://github.com/igraph/igraph/pull/1693,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1693,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1693,2021-02-23T21:12:20Z,2021-03-09T14:08:20Z,2021-03-09T14:08:20Z,CLOSED,False,18,1,1,https://github.com/szhorvat,gh actions: enable cache,16,[],https://github.com/igraph/igraph/pull/1693,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1693#issuecomment-784877664,,"@iosonofabio Can you help set up caching and ccache for GitHub Actions?
The caching concept they use is very different from all other CI systems we used in the path. It seems to be focused on ""dependencies that don't change often"" and restoring is done based on keys. (In this PR, caches are not uploaded, ""Cache hit occurred on the primary key Windows-i686-ccache, not saving cache."") I'm not sure how to employ this for ccache where file changes practically after every run.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1693,2021-02-23T21:12:20Z,2021-03-09T14:08:20Z,2021-03-09T14:08:20Z,CLOSED,False,18,1,1,https://github.com/szhorvat,gh actions: enable cache,16,[],https://github.com/igraph/igraph/pull/1693,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1693#issuecomment-784962512,,"For lack of a better idea, I included the git hash in the cache key, triggering a cache save on every commit. It seems to work now, though the speedup is disappointingly small. EDIT: In fact I don't think ccache is working at all.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1693,2021-02-23T21:12:20Z,2021-03-09T14:08:20Z,2021-03-09T14:08:20Z,CLOSED,False,18,1,1,https://github.com/szhorvat,gh actions: enable cache,16,[],https://github.com/igraph/igraph/pull/1693,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1693#issuecomment-785073486,,"CCache does appear to be working, but, strangely, it does not seem to lead to any speedup. Maybe file access is just slow with MSYS2? Perhaps it's not worth bothering.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1695,2021-02-24T11:28:31Z,2021-02-24T12:56:10Z,2021-02-24T12:56:10Z,MERGED,True,208,7,4,https://github.com/GroteGnoom,Add get_isomorphisms_vf2 unit tests,1,[],https://github.com/igraph/igraph/pull/1695,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1695,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1696,Fixes #1633,Fixes #1633,True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1696#issuecomment-785117060,Fixes #1633,Thanks for taking this up! It all looks good to me. Perhaps we can add to the documentation a small explanation that the node order is randomized?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1696#issuecomment-785121023,Fixes #1633,"You're welcome 🙂. I was a little bit unsure about the RNG_BEGIN() things, so I asked about it here: https://igraph.discourse.group/t/the-unit-tests-thread/597/40
I will continue to work on it tomorrow, and fix the docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1696#issuecomment-785124822,Fixes #1633,"I believe that because igraph_vector_shuffle calls RNG_BEGIN() and RNG_END() separately, they do not need to be included again, but let me double check that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1696#issuecomment-785125272,Fixes #1633,@vtraag Do we want this on master for 0.9.1 or should this be delayed for the next version?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1696#issuecomment-785129222,Fixes #1633,"As far as I am concerned, we can leave it for later versions 0.9.2 if we want to release 0.9.1 somewhere soonish. If it happens that this already gets merged before releasing 0.9.1, that would also be perfectly fine!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1696#issuecomment-1087965718,Fixes #1633,"I notice that this chooses a random order once and then uses it for all passes. Wasn't the intention to use a different random order for each pass, @vtraag ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1696,2021-02-24T14:23:17Z,2021-02-25T13:30:03Z,2022-04-04T23:09:37Z,MERGED,True,33,22,3,https://github.com/GroteGnoom,Randomize the Louvain algorithm,2,[],https://github.com/igraph/igraph/pull/1696,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1696#issuecomment-1088101706,Fixes #1633,"You could, but it would increase the running time, and it is not clear directly whether it would improve the results. That is, it's a choice,  either one could be good, and I don't directly know of any analysis suggesting either the one or the other is better...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1697,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1697#issuecomment-786286537,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","This is now done. The build now uses vcpkg instead of conda. This is necessary because we want to be able to provide a static build. Unfortunately that does increase the build time, and even with caching enabled, this still takes about 2 minutes.
It seems that CMake by default uses dynamic linking to the runtime (/MD), also for static libraries. By default, for static libraries, vcpkg statically links to the runtime (/MT), and the alternative triplet x64-windows-static-md was recently suggested to allow static libraries with dynamic runtime linking. Some potential problems are mentioned, although it is not exactly clear what the exact implications and limitations are. I think this should be fine and the build now uses x64-windows-static-md to build the libxml2 library.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/aggieNick02,3,https://github.com/igraph/igraph/pull/1697#issuecomment-786437125,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","Just FYI, the discussion on possible static library dynamic runtime issues has been moved to a new issue, in case you want to link to it, since the previous issue ended up, in the end, being resolved by adding CI support for the triplet. Here's the new issue: microsoft/vcpkg#16387",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1697#issuecomment-786537267,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.",Appveyor seems to suggest caching only the vcpkg\installed directory.  Do you think there is an opportunity for speedup here?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1697#issuecomment-786904170,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","Yes, we might try that, it should at least shave off something probably.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1697#issuecomment-788277139,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","The cache is now only 46 MB, this should massively improve the cache restore times.
However, when I changed the cache directory, at first it still tried to restore all the 500+ MB of old cached data into the new directory. I don't know how to clear the cache, so I just changes the cache key.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1697#issuecomment-788278627,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","Great, thanks! That should definitely save some build time!

I don't know how to clear the cache, so I just changes the cache key.

This is also the ""recommend"" way, I understood, I did it also in this way.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1697#issuecomment-788281774,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","Started a second run, cache restore time is now ~5 seconds instead of 2 minutes.
Shall we merge this?",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1697#issuecomment-788283453,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","There's just this annoying thing that Chocolatey often hangs for up to 3 minutes on startup. Sometimes it happens, sometimes it doesn't. It's been like this since the beginning, and unrelated to this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1697#issuecomment-788284341,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","We could also cache the parts of chocolatey that we need (it install things everywhere across the system, but the things we need are located in a single location I believe).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1697#issuecomment-788286463,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.","It seemed that it was not the download that was slow, but simply the startup. I'm not sure.
I'll leave it to you to squash-and-merge this. I'm very happy with it, finally everything is tested on all platforms :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1697,2021-02-25T09:13:05Z,2021-03-01T21:12:20Z,2021-03-01T21:12:25Z,MERGED,True,37,3,2,https://github.com/vtraag,Added libxml dependency on Windows on Azure pipelines,19,[],https://github.com/igraph/igraph/pull/1697,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1697#issuecomment-788289505,"This PR adds thelibxml2 dependency on Windows, hence building with GraphML support. I use conda for installing the libxml2 dependency, as this should enable a faster install than vcpkg. Perhaps the conda environment can also be cached, that would be a next step to consider. Let's first see how this builds.",Let's just leave it as is then. I'll merge it now then.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1698,2021-02-25T10:30:51Z,2021-03-01T12:13:33Z,2021-03-01T12:13:33Z,MERGED,True,221,6,4,https://github.com/GroteGnoom,Add get_subisomorphisms_vf2 unit tests,2,[],https://github.com/igraph/igraph/pull/1698,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1698,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1698,2021-02-25T10:30:51Z,2021-03-01T12:13:33Z,2021-03-01T12:13:33Z,MERGED,True,221,6,4,https://github.com/GroteGnoom,Add get_subisomorphisms_vf2 unit tests,2,[],https://github.com/igraph/igraph/pull/1698,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1698#issuecomment-785952342,Part of #1592,"Looks good to me, but I'm not sure I was able to follow all the test cases and guarantee the correctness of the expected output. @szhorvat how do you do this usually? Do you validate it with Mathematica?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1698,2021-02-25T10:30:51Z,2021-03-01T12:13:33Z,2021-03-01T12:13:33Z,MERGED,True,221,6,4,https://github.com/GroteGnoom,Add get_subisomorphisms_vf2 unit tests,2,[],https://github.com/igraph/igraph/pull/1698,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1698#issuecomment-786202271,Part of #1592,"It is relatively easy to check that each result is correct. Loop through the edges of the small graph, and check through the mapping that each is present in the large graph.
To check that the list is exhaustive, the only option is to compare with another subgraph finder. Luckily, we have one: LAD.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1698,2021-02-25T10:30:51Z,2021-03-01T12:13:33Z,2021-03-01T12:13:33Z,MERGED,True,221,6,4,https://github.com/GroteGnoom,Add get_subisomorphisms_vf2 unit tests,2,[],https://github.com/igraph/igraph/pull/1698,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1698#issuecomment-786202485,Part of #1592,Mathematica does not have built-in subgraph finding functionality. It is one of the major features that IGraph/M brings to it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1699,2021-02-25T11:39:32Z,2021-02-25T12:31:28Z,2021-02-25T12:31:33Z,MERGED,True,87,0,2,https://github.com/GroteGnoom,Add establishment game unit test,1,[],https://github.com/igraph/igraph/pull/1699,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1699,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1699,2021-02-25T11:39:32Z,2021-02-25T12:31:28Z,2021-02-25T12:31:33Z,MERGED,True,87,0,2,https://github.com/GroteGnoom,Add establishment game unit test,1,[],https://github.com/igraph/igraph/pull/1699,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1699#issuecomment-785861827,Part of #1592,Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1700,2021-02-25T14:06:32Z,2021-02-26T10:15:46Z,2021-02-26T10:15:46Z,MERGED,True,139,20,4,https://github.com/GroteGnoom,Add igraph_citing_cited_type_game unit tests,3,[],https://github.com/igraph/igraph/pull/1700,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1700,"Part of #1592
Fix: the sumtree array itself was not freed.
Fix: sums was not destroyed","Part of #1592
Fix: the sumtree array itself was not freed.
Fix: sums was not destroyed",True,{}
igraph/igraph,https://github.com/igraph/igraph,1701,2021-02-25T15:25:53Z,2021-02-25T21:27:19Z,2021-02-25T21:27:20Z,MERGED,True,101,6,4,https://github.com/GroteGnoom,Add forest_fire_game unit tests,1,[],https://github.com/igraph/igraph/pull/1701,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1701,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1703,2021-02-26T09:29:11Z,2021-02-26T10:11:21Z,2021-02-26T10:11:21Z,MERGED,True,136,11,4,https://github.com/GroteGnoom,Add simple_interconnected_islands_game unit tests,1,[],https://github.com/igraph/igraph/pull/1703,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1703,"Part of #1592
Fix: removed limit on interconnections, wasn't necessary
Fix: random connections between islands used floats instead of ints,
which caused some nodes to never be linked with other islands.","Part of #1592
Fix: removed limit on interconnections, wasn't necessary
Fix: random connections between islands used floats instead of ints,
which caused some nodes to never be linked with other islands.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1704,2021-02-26T10:41:14Z,2021-02-26T11:37:04Z,2021-02-26T11:37:04Z,MERGED,True,98,4,4,https://github.com/GroteGnoom,Add static_power_law_game unit tests,2,[],https://github.com/igraph/igraph/pull/1704,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1704,"Part of #1592
This mainly checks for memory corruption, but not much more.","Part of #1592
This mainly checks for memory corruption, but not much more.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1705,2021-02-26T11:00:24Z,2021-02-26T11:19:13Z,2021-02-26T19:02:41Z,MERGED,True,1,0,1,https://github.com/antonio-rojas,Add missing include,1,[],https://github.com/igraph/igraph/pull/1705,https://github.com/antonio-rojas,1,https://github.com/igraph/igraph/pull/1705,"Add a missing include for igraph_structural.h, where the function igraph_subcomponent is declared. Otherwise, the symbol igraph_subcomponent is not exported when building a shared library","Add a missing include for igraph_structural.h, where the function igraph_subcomponent is declared. Otherwise, the symbol igraph_subcomponent is not exported when building a shared library",True,{}
igraph/igraph,https://github.com/igraph/igraph,1705,2021-02-26T11:00:24Z,2021-02-26T11:19:13Z,2021-02-26T19:02:41Z,MERGED,True,1,0,1,https://github.com/antonio-rojas,Add missing include,1,[],https://github.com/igraph/igraph/pull/1705,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1705#issuecomment-786586011,"Add a missing include for igraph_structural.h, where the function igraph_subcomponent is declared. Otherwise, the symbol igraph_subcomponent is not exported when building a shared library",Thank a lot! The fix will be in the soon-to-be-released version 0.9.1.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1707,2021-02-26T13:28:01Z,2021-02-26T16:34:58Z,2021-02-26T16:34:58Z,MERGED,True,55,247,2,https://github.com/vtraag,Build correctly with external suitesparse on Windows in Debug mode,3,[],https://github.com/igraph/igraph/pull/1707,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1707,"This PR addressed the problem of building with an external suitesparse from vcpkg on Windows (#1492) This was due to the fact that the debug library is being built with a trailing d, which is not picked up by the FindCXSParse.cmake that we vendor. The FindCXSParse.cmake that was bundled with vcpkg seemed more modern and makes use of more possibilities of cmake, and also allows for such an alternative debug name.
I have tested this solution on both Windows and Linux, and both work perfectly fine, in both Debug and Release mode. In short, this fixes #1492.
In the previous FindCXSParse.cmake there were special provision for dealing with Homebrew. I am not sure if this is still necessary, let's see how the CI does.","This PR addressed the problem of building with an external suitesparse from vcpkg on Windows (#1492) This was due to the fact that the debug library is being built with a trailing d, which is not picked up by the FindCXSParse.cmake that we vendor. The FindCXSParse.cmake that was bundled with vcpkg seemed more modern and makes use of more possibilities of cmake, and also allows for such an alternative debug name.
I have tested this solution on both Windows and Linux, and both work perfectly fine, in both Debug and Release mode. In short, this fixes #1492.
In the previous FindCXSParse.cmake there were special provision for dealing with Homebrew. I am not sure if this is still necessary, let's see how the CI does.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1708,2021-02-26T14:06:24Z,2021-02-28T15:32:50Z,2021-02-28T15:32:50Z,MERGED,True,115,8,4,https://github.com/GroteGnoom,Add igraph_neighborhood_size unit tests,3,[],https://github.com/igraph/igraph/pull/1708,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1708,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1709,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1709#issuecomment-786924054,Part of #1592,"I would go with zero for the null graph. Good catch that we had an assertion failure in that case!

I also chose 0 for igraph_average_local_efficiency, which is a similar measure in the sense that we deal with ""pairs of neighbors"" during computation.
Here's the reasoning:
The local clustering coefficient of a vertex is the fraction of its neighbour-pairs that are connected, i.e. (connected neighbour-pairs) / (all neighbour-pairs). That is technically meaningless for any vertex that does not have at least degree 2 (two neighbours). One might argue to return 0/0 = NaN for such vertices.
But when it comes to the computation of the average local clustering, a single NaN (a single degree-1 vertex) throws a wrench into the calculation. Thus, conventionally, people have been using 0 for the local clustering of degree-0 and degree-1 vertices. That means that the average local clustering would be 0 for 2-vertex and 1-vertex graphs, which don't make a lot more sense for this calculation than the zero-vertex graph. Thus for simplicity we can return 0 for the null graph as well.

In the end it doesn't matter much what we return, however, I would prefer to return a numeric result instead of throwing an error. Zero is just the simplest choice that avoids having to explain why we return something different from the also meaningless cases of 1- and 2-vertex graphs.
Plus, I'd like to stay consistent with igraph_average_local_efficiency.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1709#issuecomment-787040370,Part of #1592,"Handling unimportant looking edge cases gracefully (instead of erroring out) if generally useful. It often allows simply programs, written by the end user, to generalize nicely without having to handle edge cases specially.
With a graph measure m that is an average of some vertex measure, one would expect the following to hold:
m( DisjointUnion(g1, g1) ) = 
        ( m(g1) * VertexCount(g1) + m(g2) * VertexCount(g2) ) / (VertexCount(g1) + VertexCount(g2))

If VertexCount(g2) == 0 and VertexCount(g1) > 0, this will hold for whatever finite value we return for m(g2), but it would break things if we return NaN.  This is an argument for returning 0 instead of NaN.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1709#issuecomment-787045358,Part of #1592,"Zero is just the simplest choice that avoids having to explain why we return something different from the also meaningless cases of 1- and 2-vertex graphs.

But those return a value based on the mode argument. For example, in the 1-vertex case, if you specify IGRAPH_TRANSITIVITY_NAN, you get a NaN back. Should the 0-vertex case also do this? I think giving a zero in NAN-mode will still have the 'disjoint union problem', and a NaN will at least indicate that things went wrong. So I think we should return the value based on the mode.
(The disjoint union example is great by the way. This shows that the problem with NaNs in this case is that internally they mean 'this vertex should not be considered when calculating the average', but it doesn't mean that in other functions.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1709#issuecomment-787075263,Part of #1592,"I'm sorry, I was looking at the function in a high-level interface and forgot that it has an option to exclude degree-0 and degree-1 vertices.
When we are excluding them, I would return NaN for the null graph. This is already what is returned for graph which do not have any vertices with degree > 1.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1709#issuecomment-787075544,Part of #1592,This NaN could then serve to distinguish a graph in which every vertex had to be excluded from a graph where some vertices truly have 0 local clustering (such as a cycle graph).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1709,2021-02-26T16:21:51Z,2021-02-27T14:44:58Z,2021-02-27T14:44:58Z,MERGED,True,104,3,4,https://github.com/GroteGnoom,Add transitivity_avglocal_undirected unit tests,3,[],https://github.com/igraph/igraph/pull/1709,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1709#issuecomment-787077752,Part of #1592,Just a heads up that the global clustering calculation also triggers an assertion failure when using the null graph. I will fix this now.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1710,2021-02-28T16:36:33Z,2021-02-28T17:07:11Z,2021-02-28T17:07:15Z,MERGED,True,199,7,4,https://github.com/GroteGnoom,Add transitivity barrat unit tests,3,[],https://github.com/igraph/igraph/pull/1710,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1710,"Part of #1592
No longer warns for no edges and no weights.","Part of #1592
No longer warns for no edges and no weights.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1710,2021-02-28T16:36:33Z,2021-02-28T17:07:11Z,2021-02-28T17:07:15Z,MERGED,True,199,7,4,https://github.com/GroteGnoom,Add transitivity barrat unit tests,3,[],https://github.com/igraph/igraph/pull/1710,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1710#issuecomment-787484786,"Part of #1592
No longer warns for no edges and no weights.",Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1711,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1711#issuecomment-788763666,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Before continuing with a full review, I would like to request some changes:
Targets and sources:

It would be great if we could have a separate subset for source and for target vertices. This should ideally be done now, so we don't have to break API again at a later stage.

Tests:

Please separate the tests for the subset betweenness into a new test program The original betweenness tests are already overloaded.
Include both an undirected and a directed non-trivial example graph for which it is possible to verify the results manually. This should be more complex than simply a path graph.
Print headers before each test output, so one can easily see what result belongs came from which part of the code.

Duplicate vertices:

It seems that you are trying to handle the case when some vertices appear more than once in the subset. If you want to handle this case, it should be tested. However, I think it would be easier to disallow duplicates.

Function signature:

The argument list of igraph_betweenness_subset is now literally identical to that of igraph_betweenness, but the meaning of vids is entirely different. This is very confusing. I suggest using this argument list instead:
int igraph_betweenness_subset(
                                         const igraph_t *graph, igraph_vector_t *res,
                                         igraph_vs_t vids, igraph_bool_t directed,
                                         igraph_vs_t sources, igraph_vs_t targets,
                                         const igraph_vector_t *weights);

vids will control which vertices the betweenness is calculated for. It is fine to calculate it for all of them, then retain only those values which were requested, just like igraph_betweenness does.  sources and targets specify the subsets.

Readability:

Please separate the weighted and unweighted parts into two internal functions, then call them from a top-level function, similar to how this is done for the harmonic centrality: https://github.com/igraph/igraph/blob/master/src/centrality/closeness.c#L798



It would be nice to eventually think about whether some code duplication can be avoided. But this is low priority. Let us first make sure that the current implementation is correct.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/guyroznb,3,https://github.com/igraph/igraph/pull/1711#issuecomment-791415914,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Hi,
I changed the betweenness.c library, by adding two sub function which calculate the single SSPF for the weighted and the unweighted  cases. By doing so I can merge the betweenness function for the weighted and the unweighted cases and avoid duplication in the SSPF and betweenness calculation.
I also added a new test function for the betweenness subset.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1711#issuecomment-791900049,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",Thanks for all your work on this @guyroznb! I'll try to go through it next week (as it'll take a bit more time to review).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/guyroznb,5,https://github.com/igraph/igraph/pull/1711#issuecomment-795187236,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",I merge this branch with updated develop branch and re-formatted the src and tests.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1711#issuecomment-800410408,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","@guyroznb Just a heads up that we have not forgotten about this PR (or the shortest paths one). This week is exceptionally busy for all of us, so it will take a bit more time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/apps/codecov,7,https://github.com/igraph/igraph/pull/1711#issuecomment-816480369,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Codecov Report

Merging #1711 (467bc88) into develop (0fb1ace) will increase coverage by 0.06%.
The diff coverage is 96.08%.


@@             Coverage Diff             @@
##           develop    #1711      +/-   ##
===========================================
+ Coverage    72.49%   72.56%   +0.06%     
===========================================
  Files          292      292              
  Lines        57329    57370      +41     
===========================================
+ Hits         41560    41628      +68     
+ Misses       15769    15742      -27     



Impacted Files
Coverage Δ





src/centrality/betweenness.c
92.97% <96.08%> (+5.98%)
⬆️


src/isomorphism/vf2.c
94.97% <0.00%> (-0.02%)
⬇️


src/community/leading_eigenvector.c
82.81% <0.00%> (ø)



src/misc/motifs.c
94.82% <0.00%> (+0.01%)
⬆️


src/graph/visitors.c
85.24% <0.00%> (+1.37%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 0fb1ace...467bc88. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1711#issuecomment-818874404,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","This PR seems to have a negative impact on the performance of the plain betweenness function according to the results of make benchmark.
Results in the develop branch without this PR:
 1 Betweenness, Kautz(4,5), directed                                             0.752s  0.749s  0.001s
 2 Betweenness, Kautz(4,5), undirected                                            1.91s    1.9s  0.006s
 3 Betweenness, DeBruijn(6,5), directed                                            1.9s   1.89s  0.004s
 4 Betweenness, Grid(8,8,8,8), undirected                                         1.21s   1.21s  0.002s
 5 Betweenness, Grid(10,10,10,10), cutoff 5                                      0.336s  0.335s  0.001s
 6 Betweenness, Grid(10,10,10,10), cutoff 8                                       1.38s   1.38s  0.003s
 7 Betweenness, Barabasi n=8000 m=1, undirected                                    3.3s   3.29s  0.006s
 8 Betweenness, Barabasi n=8000 m=1, undirected, cutoff 6                        0.895s   0.89s  0.003s
 9 Betweenness, Barabasi n=30000 m=5, directed                                    1.54s   1.53s  0.008s
10 Betweenness, Barabasi n=30000 m=5, directed, cutoff 5                         0.881s  0.877s  0.002s

Results in the branch of this PR:
 1 Betweenness, Kautz(4,5), directed                                              1.11s   1.09s  0.007s
 2 Betweenness, Kautz(4,5), undirected                                            4.03s    3.8s  0.043s
 3 Betweenness, DeBruijn(6,5), directed                                           2.73s   2.71s  0.012s
 4 Betweenness, Grid(8,8,8,8), undirected                                         1.92s   1.89s  0.014s
 5 Betweenness, Grid(10,10,10,10), cutoff 5                                      0.528s  0.517s  0.004s
 6 Betweenness, Grid(10,10,10,10), cutoff 8                                       2.05s   2.04s  0.005s
 7 Betweenness, Barabasi n=8000 m=1, undirected                                   4.53s    4.5s  0.016s
 8 Betweenness, Barabasi n=8000 m=1, undirected, cutoff 6                         1.16s   1.16s  0.003s
 9 Betweenness, Barabasi n=30000 m=5, directed                                    2.19s   2.17s  0.008s
10 Betweenness, Barabasi n=30000 m=5, directed, cutoff 5                          1.25s   1.24s  0.004s

We need to investigate why this happens and whether we can do something to avoid the performance hit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1711#issuecomment-818897990,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","It looks like the overhead of using incidence lists even for the node betweenness case has quite a bit of overhead; according to Instruments.app, 23.5% of the time spent in igraph_i_sspf() is spent in this line:
long int neighbor = IGRAPH_OTHER(graph, edge, actnode);

Attached is a side-by-side comparison of the two loops; left side is this PR, right side is the original version.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1711#issuecomment-818899749,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Putting an unpredictable conditional in a tight loop can do that ...
I think if there is a performance cost of this magnitude, we should avoid the refactoring that is responsible for it. Performance is supposed to be a selling point for igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/guyroznb,11,https://github.com/igraph/igraph/pull/1711#issuecomment-821304443,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","@ntamas I don't know which graph did you used in the benchmark (weighted or unweighted). In my opinion there are four different types of betweenness when talking about adjacent vs. incident list in the SSPF phase of the betweenness algorithm:

edge betweenness (weighted or unweighted) - using incident list.
vertex betweenness weighted - using incident list. This is also done in the develop branch.
vertex betweenness unweighted - I believe that in order to remain consistent with the other types of betweenness we should use incident list. But if there is a large degradation in the running time maybe I should write a new internal SSPF function using the adjacent list instead?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1711#issuecomment-821526474,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","I used the standard igraph benchmarks that you can also run yourself with make benchmark (or ninja benchmark). @szhorvat has recently added a benchmark for weighted betweenness (I was using the unweighted variants only); I have merged these into develop now so if you merge develop into this PR, you can easily run the benchmarks yourself (both with the unweighted and the weighted variant).
(Note: when benchmarking, make sure to use a Release build and if possible, turn on link-time optimization (set IGRAPH_ENABLE_LTO to ON in the CMake config). This is the setup that we advocate for package maintainers as well, so this configuration is the one that is most likely to end up in OS distributions).
I agree that one probably cannot avoid using IGRAPH_OTHER() and incidence lists if the graph is weighted or if you need any other edge properties - there is no debate for that. I would happily go for incidence lists for sake of consistency, as long as it does not cause a performance hit. If it does, then it's better to stick to adjacency lists.
Also, I think that it's not the incidence lists themselves that cause the slowdown but the presence of the IGRAPH_OTHER() macro; the result of the condition this macro is unpredictable so branch prediction optimizations will perform poorly.
Anyhow, I'm going to re-run the benchmarks and post the results there. @szhorvat 's benchmarks use a good mixture of all sorts of different graphs ranging from regular grids to Barabasi-Albert scale-free networks of all sizes that I believe they cover most use-cases that we wish to optimize for.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/guyroznb,13,https://github.com/igraph/igraph/pull/1711#issuecomment-821976376,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Hi, I create 4 different SSPF for every scenario in order to improve the running time. In both vertex betweenness (weighted and unweighted) I used adjacent list to represent the father of each vertex to the source. In edge betweenness I used incident list to represent edges leading to the source. unweighted vertex betweenness is the only scenario in which the input is adjacent list.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1711#issuecomment-829423090,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","This is great, now the benchmark results actually improved over the version that we currently have in the develop branch:
 1 Betweenness, Kautz(4,5), directed                                             0.579s  0.577s  0.001s
 2 Betweenness, Kautz(4,5), undirected                                            1.62s   1.62s  0.001s
 3 Betweenness, DeBruijn(6,5), directed                                           1.51s   1.51s  0.001s
 4 Betweenness, Grid(8,8,8,8), undirected                                         1.07s   1.06s  0.002s
 5 Betweenness, Grid(10,10,10,10), cutoff 5                                      0.306s  0.305s  0.001s
 6 Betweenness, Grid(10,10,10,10), cutoff 8                                       1.21s   1.21s  0.001s
 7 Betweenness, Barabasi n=8000 m=1, undirected                                   2.68s   2.67s  0.005s
 8 Betweenness, Barabasi n=8000 m=1, undirected, cutoff 6                         0.72s   0.72s      0s
 9 Betweenness, Barabasi n=30000 m=5, directed                                    1.19s   1.19s  0.002s
10 Betweenness, Barabasi n=30000 m=5, directed, cutoff 5                         0.734s  0.733s  0.001s

I'd like to check the implementations once again for correctness so please give me some more time, but it is looking much better now.",True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/1711#issuecomment-843363504,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",Note to ourselves: the new version does not include any progress reporting. This should be restored before merging this branch.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1711#issuecomment-845095684,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","@ntamas It appears that node betweenness (igraph_betweenness, not just igraph_betweenness_subset) now ignores multi-edges.
Example:

What is the betweenness of 2 and 4?  The only shortest paths going through them are between 1 and 3. There are not two, but three such paths. Two pass through 2 and one passes through 4. Therefore, the betweenness of 2 should be 2/3 and the betweenness of 4 is 1/3.
This is what the old version gives. The new version (from this PR) appears to ignore multi-edges and gives 1/2 for both of them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1711#issuecomment-845097266,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","I tested the subset node betweenness on the karate club graph, as well as random directed and undirected simple graphs using random subsets. The implementation appears to be correct.
The direct implementation I used (through exhaustive enumeration of shortest path) does not handle multigraphs though.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1711#issuecomment-845097827,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","For future reference, I used this implementation in Mathematica to test against:
findAllShortestPaths[g_, s_, t_] :=
 With[{d = GraphDistance[g, s, t]},
  FindPath[g, s, t, {d}, All]
  ]

betweenness[g_, startSet_, endSet_] :=
 Module[{paths, counts, res},
  counts = Catenate@Catenate@Table[
      paths = findAllShortestPaths[g, s, t];
      {#, 1/Length[paths]} & /@ Join @@ paths[[All, 2 ;; -2]],
      {s, startSet}, {t, endSet}
      ];
  res = Lookup[
    Total /@ GroupBy[counts, First -> Last],
    VertexList[g],
    0
    ];
  If[UndirectedGraphQ[g], res/2, res]
  ]",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1711#issuecomment-845147007,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","I have now also tested edge betweenness on simple graphs (both directed and undirected, but not weighted). That is also fine.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1711#issuecomment-845230398,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Let us now look at the edge betweenness of the same multigraph.

Consider edge 1-2.
There are 3 paths between 1,3, two of which pass through it, giving 2/3. There are 3 paths between 2,4, one of which passes through it, giving 1/3. There is 1 path between 1,2, passing through it, giving 1. In total, 2/3+1/3+1 = 2.
Same for 3-4.
For 1-4 we get 1/3 + 1/3 + 1 = 5/3.
Same for both edges between 2-3.
This is exactly the result I get from igraph_edge_betweenness_(subset). It is correct. Only the node betweenness is wrong for multigraphs, not the edge betweenness.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1711#issuecomment-845418096,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",I'll add these as unit tests and attempt to fix the node betweenness case again so it works properly for multigraphs. Thanks a lot for the tests!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,22,https://github.com/igraph/igraph/pull/1711#issuecomment-845443043,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","FWIW, edge betweenness on your example graph from python-igraph 0.9.3 gives me 7/6 for the edge betweenness scores of the mutal edge pair.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1711#issuecomment-845448175,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","FWIW, edge betweenness on your example graph from python-igraph 0.9.3 gives me 7/6 for the edge betweenness scores of the mutal edge pair.

You are right, I also get 7/6.
It turns out I cannot read and did not notice the difference between 1.66666667 and 1.16666667.
7/6 is actually correct. The relevant paths are between 1-3 (1 of 3), 2-3 (1 of 3) and 2-3 (1 of 2). That gives 1/3 + 1/3 + 1/2 = 7/6.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/ntamas,24,https://github.com/igraph/igraph/pull/1711#issuecomment-845486110,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",Looks good to me now! I'll merge when the CI tests pass. Thank you @guyroznb and @szhorvat !,True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1711#issuecomment-845487301,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","The betweenness parts of the IGraph/M test suite pass now (other parts fail, probably because of the callback function changes, but that's something else). I didn't re-test the subset betweenness yet.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,26,https://github.com/igraph/igraph/pull/1711#issuecomment-845487894,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.",Neither did I do any tests on weighted graphs. I didn't look at the tests you wrote for this. Did you test with units weights and check that the result is always the same as the unweighted one?,True,"{'THUMBS_UP': ['https://github.com/ntamas', 'https://github.com/guyroznb']}"
igraph/igraph,https://github.com/igraph/igraph,1711,2021-02-28T18:20:42Z,2021-05-20T21:38:14Z,2021-05-21T04:03:06Z,MERGED,True,1917,730,13,https://github.com/guyroznb,Subset betweenness,42,[],https://github.com/igraph/igraph/pull/1711,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1711#issuecomment-845488147,"This PR answers the issue #1237, adding two functions which allow the calculation of betweenness centrality (of edges and vertices) using shortest paths between s subset of vertices.","Also, awesome addition! I wanted this functionality for  long time. Thanks for all your hard work on this @ntamas and @guyroznb !",True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1713,2021-03-01T09:16:32Z,2021-03-01T16:33:30Z,2021-03-01T16:33:32Z,MERGED,True,433,10,6,https://github.com/GroteGnoom,Add neighborhood and neighborhood_graphs unit test,1,[],https://github.com/igraph/igraph/pull/1713,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1713,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1713,2021-03-01T09:16:32Z,2021-03-01T16:33:30Z,2021-03-01T16:33:32Z,MERGED,True,433,10,6,https://github.com/GroteGnoom,Add neighborhood and neighborhood_graphs unit test,1,[],https://github.com/igraph/igraph/pull/1713,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1713#issuecomment-788088079,Part of #1592,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1714,2021-03-01T12:15:33Z,2021-03-09T17:23:51Z,2021-03-09T17:23:51Z,MERGED,True,128,24,7,https://github.com/GroteGnoom,Add igraph_shortest_paths_johnson unit tests,4,[],https://github.com/igraph/igraph/pull/1714,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1714,"Part of #1592
I changed the output of NaN's and Infs when they're printed with %8g,
for better alignment. This also required fixing modularity_matrix
output.
Bugfix: If there are no edges, there are no negative weights. This
check was not correct before.
Bugfix: When selecting a subset of to and from vertices, the to
indices were incorrect when reweighting the results. It used the indices
of the matrix for the whole graph instead of the vertex subset.","Part of #1592
I changed the output of NaN's and Infs when they're printed with %8g,
for better alignment. This also required fixing modularity_matrix
output.
Bugfix: If there are no edges, there are no negative weights. This
check was not correct before.
Bugfix: When selecting a subset of to and from vertices, the to
indices were incorrect when reweighting the results. It used the indices
of the matrix for the whole graph instead of the vertex subset.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1715,2021-03-01T15:53:20Z,2021-03-02T11:38:42Z,2021-03-02T11:38:57Z,MERGED,True,191,38,6,https://github.com/GroteGnoom,Add some diameter_dijkstra unit tests,3,[],https://github.com/igraph/igraph/pull/1715,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1715,"Part of #1592
Split up diameter and diameter_dijkstra tests.","Part of #1592
Split up diameter and diameter_dijkstra tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1715,2021-03-01T15:53:20Z,2021-03-02T11:38:42Z,2021-03-02T11:38:57Z,MERGED,True,191,38,6,https://github.com/GroteGnoom,Add some diameter_dijkstra unit tests,3,[],https://github.com/igraph/igraph/pull/1715,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1715#issuecomment-788844916,"Part of #1592
Split up diameter and diameter_dijkstra tests.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1716,2021-03-02T10:48:21Z,2021-03-02T11:35:08Z,2021-03-02T11:35:13Z,MERGED,True,135,10,4,https://github.com/GroteGnoom,Add igraph_average_path_length_dijkstra unit tests,2,[],https://github.com/igraph/igraph/pull/1716,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1716,"Part of #1592
Micro bugfix: Now returns 0 instead of -0 unconnected pairs for null graph.","Part of #1592
Micro bugfix: Now returns 0 instead of -0 unconnected pairs for null graph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1716,2021-03-02T10:48:21Z,2021-03-02T11:35:08Z,2021-03-02T11:35:13Z,MERGED,True,135,10,4,https://github.com/GroteGnoom,Add igraph_average_path_length_dijkstra unit tests,2,[],https://github.com/igraph/igraph/pull/1716,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1716#issuecomment-788842951,"Part of #1592
Micro bugfix: Now returns 0 instead of -0 unconnected pairs for null graph.",Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1717,2021-03-02T13:42:36Z,2021-03-02T14:49:20Z,2021-03-02T14:49:20Z,MERGED,True,83,5,4,https://github.com/GroteGnoom,Add spmatrix clear col unit tests,5,[],https://github.com/igraph/igraph/pull/1717,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1717,"Part of #1592
(I still had this one lying around.)","Part of #1592
(I still had this one lying around.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1717,2021-03-02T13:42:36Z,2021-03-02T14:49:20Z,2021-03-02T14:49:20Z,MERGED,True,83,5,4,https://github.com/GroteGnoom,Add spmatrix clear col unit tests,5,[],https://github.com/igraph/igraph/pull/1717,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1717#issuecomment-788960029,"Part of #1592
(I still had this one lying around.)",Minor doc issues; I'm gonna fix these and merge.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1718,Fixes #1706,Fixes #1706,True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1718#issuecomment-789209355,Fixes #1706,"@ntamas Do we want this function to be named _rev_cmp instead of _cmp_rev? As I recall, most (if not all) comparison functions in igraph are named as cmp.  Personally, I don't have strong feeling about this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1718#issuecomment-789568861,Fixes #1706,"@ntamas Do we want this function to be named _rev_cmp instead of _cmp_rev? As I recall, most (if not all) comparison functions in igraph are named as cmp. Personally, I don't have strong feeling about this.

Well, you could also argue that all comparison functions in igraph that return things in reverse order are named as cmp_rev ;) (It just happens to be the case that there are no such functions yet). So, I don't mind either way. cmp_rev (as it is now) is okay for me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1718#issuecomment-789607899,Fixes #1706,"all comparison functions in igraph that return things in reverse order

This does not sort in reverse order. It sorts lexicographically based on reverse vectors :-)
Let's pause here for a minute and before merging, let us do some research on the various orderings, their namings (are the namings consistent?) and their applications.
Here is one reference:
https://oeis.org/wiki/Orderings#Types_of_orderings",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1718#issuecomment-789785656,Fixes #1706,"If we call it colexicographic ordering, then at least it doesn't seem like it just reverses the order. That's also the name used on wikipedia.
Good point btw, I didn't think about any official naming, and it can be really confusing to use a different definition than other people.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1718#issuecomment-789801579,Fixes #1706,"I changed the example slightly to make it clear that shorter vectors come first only if all elements match, but not otherwise. In some orderings, shorter always comes first.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1718#issuecomment-789801834,Fixes #1706,Let's call if igraph_vector_colex_cmp then.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1718#issuecomment-790674508,Fixes #1706,"Just my two cents, after the comment from @szhorvat in #1706 (comment): I think it would be OK if this is targeted at the master branch. The more limited semantic versioning that we agreed we would support is that minor release versions are API backwards-compatible, i.e. they can add, but not break API. We documented this explicitly in the Contributing guidelines",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1718#issuecomment-791403531,Fixes #1706,"Hmm, I have tried to change the base branch but it seems to have added lots of stuff to master that I definitely do not want to be there (like the API-breaking changes in igraph_diameter). @GroteGnoom would you mind sending another PR that targets the master branch cleanly? I don't know how to sort this out using the web UI of Github.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1718#issuecomment-791677125,Fixes #1706,@ntamas How about squash-and-merge to develop then cherry pick the commit?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1718,2021-03-02T20:33:01Z,2021-03-05T21:17:20Z,2021-03-05T21:17:20Z,MERGED,True,697,82,30,https://github.com/GroteGnoom,Add lexicographical comparison of vectors,32,[],https://github.com/igraph/igraph/pull/1718,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1718#issuecomment-791715164,Fixes #1706,"Hmmm okay, let's try and see",True,{}
igraph/igraph,https://github.com/igraph/igraph,1719,2021-03-02T22:50:54Z,2021-03-03T09:55:12Z,2021-03-03T09:55:12Z,MERGED,True,2,1,1,https://github.com/szhorvat,fix out-of-bounds access with multigraph in minimum_size_separators,1,[],https://github.com/igraph/igraph/pull/1719,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1719,"Fixes #1031
See #1031 (comment)","Fixes #1031
See #1031 (comment)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1719,2021-03-02T22:50:54Z,2021-03-03T09:55:12Z,2021-03-03T09:55:12Z,MERGED,True,2,1,1,https://github.com/szhorvat,fix out-of-bounds access with multigraph in minimum_size_separators,1,[],https://github.com/igraph/igraph/pull/1719,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1719#issuecomment-789288232,"Fixes #1031
See #1031 (comment)",LGTM. @vtraag feel free to merge if you are okay with this as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1720,2021-03-03T14:15:50Z,2021-03-09T20:47:45Z,2021-03-09T20:47:50Z,MERGED,True,192,5,6,https://github.com/GroteGnoom,"Add attribute_combination_remove unit tests, docs",4,[],https://github.com/igraph/igraph/pull/1720,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1720,"Part of #1592
There were no docs, so I added some. They're not amazingly thorough, but can be used as a start.","Part of #1592
There were no docs, so I added some. They're not amazingly thorough, but can be used as a start.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1720,2021-03-03T14:15:50Z,2021-03-09T20:47:45Z,2021-03-09T20:47:50Z,MERGED,True,192,5,6,https://github.com/GroteGnoom,"Add attribute_combination_remove unit tests, docs",4,[],https://github.com/igraph/igraph/pull/1720,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1720#issuecomment-794433936,"Part of #1592
There were no docs, so I added some. They're not amazingly thorough, but can be used as a start.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1723,2021-03-04T13:02:04Z,2021-03-05T16:51:00Z,2021-03-05T16:51:00Z,MERGED,True,158,99,5,https://github.com/GroteGnoom,Add maximal cliques file unit tests,2,[],https://github.com/igraph/igraph/pull/1723,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1723,"Part of #1592
I also fixed the indentation of the template by moving a curly brace and reindenting.","Part of #1592
I also fixed the indentation of the template by moving a curly brace and reindenting.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1724,2021-03-04T14:08:54Z,2021-03-08T09:29:34Z,2021-03-08T09:29:35Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add clique_size_hist unit tests,3,[],https://github.com/igraph/igraph/pull/1724,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1724,"Part of #1592
Bugfix: igraph_vector_resize_min used a Realloc, which returns NULL
when called with 0 size, which was then interpreted as an error.
A free and a calloc does not have the same problem, because calloc
can return a pointer which can be properly freed, even when called
with size 0. Calloc can also return NULL when called with size 0, but
apparently doesn't do this, because else every vector_init with 0
members would also have problems.","Part of #1592
Bugfix: igraph_vector_resize_min used a Realloc, which returns NULL
when called with 0 size, which was then interpreted as an error.
A free and a calloc does not have the same problem, because calloc
can return a pointer which can be properly freed, even when called
with size 0. Calloc can also return NULL when called with size 0, but
apparently doesn't do this, because else every vector_init with 0
members would also have problems.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1724,2021-03-04T14:08:54Z,2021-03-08T09:29:34Z,2021-03-08T09:29:35Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add clique_size_hist unit tests,3,[],https://github.com/igraph/igraph/pull/1724,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1724#issuecomment-790664449,"Part of #1592
Bugfix: igraph_vector_resize_min used a Realloc, which returns NULL
when called with 0 size, which was then interpreted as an error.
A free and a calloc does not have the same problem, because calloc
can return a pointer which can be properly freed, even when called
with size 0. Calloc can also return NULL when called with size 0, but
apparently doesn't do this, because else every vector_init with 0
members would also have problems.","This actually touches on a broader issue discussed in #1479, where it is noted that having arrays of size 0 are not always necessarily well-supported. We there discussed the possibility of fixing this in the igraph_Calloc and friends by ensuring a minimum allocation size of 1 (even though this need not be used in practice). Perhaps you could take a look at that problem?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1724,2021-03-04T14:08:54Z,2021-03-08T09:29:34Z,2021-03-08T09:29:35Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add clique_size_hist unit tests,3,[],https://github.com/igraph/igraph/pull/1724,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1724#issuecomment-790665051,"Part of #1592
Bugfix: igraph_vector_resize_min used a Realloc, which returns NULL
when called with 0 size, which was then interpreted as an error.
A free and a calloc does not have the same problem, because calloc
can return a pointer which can be properly freed, even when called
with size 0. Calloc can also return NULL when called with size 0, but
apparently doesn't do this, because else every vector_init with 0
members would also have problems.","@vtraag I was just going to summon you with a link to #1479 :-)
@GroteGnoom For all of malloc/calloc/realloc, the behaviour with a zero size is implementation defined, and cannot be relied on.",True,{'LAUGH': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1724,2021-03-04T14:08:54Z,2021-03-08T09:29:34Z,2021-03-08T09:29:35Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add clique_size_hist unit tests,3,[],https://github.com/igraph/igraph/pull/1724,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1724#issuecomment-790667398,"Part of #1592
Bugfix: igraph_vector_resize_min used a Realloc, which returns NULL
when called with 0 size, which was then interpreted as an error.
A free and a calloc does not have the same problem, because calloc
can return a pointer which can be properly freed, even when called
with size 0. Calloc can also return NULL when called with size 0, but
apparently doesn't do this, because else every vector_init with 0
members would also have problems.","Another note: free() is always safe to use on NULL. We do rely on this in several cases, for example when freeing a vector_ptr when not all of its elements have been allocated yet (e.g. because we're aborting due to an error). This is why igraph_Free not only calls free() but also sets the pointer to NULL",True,"{'THUMBS_UP': ['https://github.com/vtraag', 'https://github.com/GroteGnoom']}"
igraph/igraph,https://github.com/igraph/igraph,1724,2021-03-04T14:08:54Z,2021-03-08T09:29:34Z,2021-03-08T09:29:35Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add clique_size_hist unit tests,3,[],https://github.com/igraph/igraph/pull/1724,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1724#issuecomment-790674998,"Part of #1592
Bugfix: igraph_vector_resize_min used a Realloc, which returns NULL
when called with 0 size, which was then interpreted as an error.
A free and a calloc does not have the same problem, because calloc
can return a pointer which can be properly freed, even when called
with size 0. Calloc can also return NULL when called with size 0, but
apparently doesn't do this, because else every vector_init with 0
members would also have problems.","Allright, I'll first fix #1479, and then revert a bit here.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1725,2021-03-04T18:39:27Z,2021-03-05T13:04:26Z,2021-03-05T13:04:26Z,MERGED,True,108,5,4,https://github.com/GroteGnoom,Add get_adjacency_sparse unit tests,1,[],https://github.com/igraph/igraph/pull/1725,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1725,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1726,2021-03-07T09:52:28Z,2021-03-07T21:15:15Z,2021-03-07T21:15:15Z,MERGED,True,744,699,99,https://github.com/GroteGnoom,Make zero allocs consistent,10,[],https://github.com/igraph/igraph/pull/1726,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1726,"Fixes #1479

I did check for code where size checks were now superfluous, and
There are more places that check for size, like this:
if (alloc_size <= 0) {
    alloc_size = 1;
}

But I didn't remove them when they also used alloc size in other
places, like:
g->stor_end = h_str_begin + alloc_size;


Avoiding double evaluation can still be combined with macro usage like this:
static void *igraph_i_calloc(size_t nitems, size_t size) {
    return calloc (nitems > 0 ? nitems : 1, size);
}

#define IGRAPH_CALLOC(n,t)    igraph_i_calloc( n, sizeof(t) )

So that's still an option, but I also wanted to you to be able to merge this if you don't want that.

#1479 (comment):

Could we then also remove IGRAPH_FREE and IGRAPH_CALLOC from the public headers and move them to an internal header?

Should this still be done? It makes sense to me, but I'm not sure how igraph internal headers work.","Fixes #1479

I did check for code where size checks were now superfluous, and
There are more places that check for size, like this:
if (alloc_size <= 0) {
    alloc_size = 1;
}

But I didn't remove them when they also used alloc size in other
places, like:
g->stor_end = h_str_begin + alloc_size;


Avoiding double evaluation can still be combined with macro usage like this:
static void *igraph_i_calloc(size_t nitems, size_t size) {
    return calloc (nitems > 0 ? nitems : 1, size);
}

#define IGRAPH_CALLOC(n,t)    igraph_i_calloc( n, sizeof(t) )

So that's still an option, but I also wanted to you to be able to merge this if you don't want that.

#1479 (comment):

Could we then also remove IGRAPH_FREE and IGRAPH_CALLOC from the public headers and move them to an internal header?

Should this still be done? It makes sense to me, but I'm not sure how igraph internal headers work.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1726,2021-03-07T09:52:28Z,2021-03-07T21:15:15Z,2021-03-07T21:15:15Z,MERGED,True,744,699,99,https://github.com/GroteGnoom,Make zero allocs consistent,10,[],https://github.com/igraph/igraph/pull/1726,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1726#issuecomment-792337180,"Fixes #1479

I did check for code where size checks were now superfluous, and
There are more places that check for size, like this:
if (alloc_size <= 0) {
    alloc_size = 1;
}

But I didn't remove them when they also used alloc size in other
places, like:
g->stor_end = h_str_begin + alloc_size;


Avoiding double evaluation can still be combined with macro usage like this:
static void *igraph_i_calloc(size_t nitems, size_t size) {
    return calloc (nitems > 0 ? nitems : 1, size);
}

#define IGRAPH_CALLOC(n,t)    igraph_i_calloc( n, sizeof(t) )

So that's still an option, but I also wanted to you to be able to merge this if you don't want that.

#1479 (comment):

Could we then also remove IGRAPH_FREE and IGRAPH_CALLOC from the public headers and move them to an internal header?

Should this still be done? It makes sense to me, but I'm not sure how igraph internal headers work.","@szhorvat argued here that IGRAPH_FREE and IGRAPH_CALLOC should be kept public so I think we don't need to hide them now.
Nevertheless, internal headers are no big deal; basically all the headers in include eventually get installed on the end user's system so everything you put in there is public. Headers in subdirectories of src are not installed so they can be used for private stuff that we do not want to expose as part of the public API.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1726,2021-03-07T09:52:28Z,2021-03-07T21:15:15Z,2021-03-07T21:15:15Z,MERGED,True,744,699,99,https://github.com/GroteGnoom,Make zero allocs consistent,10,[],https://github.com/igraph/igraph/pull/1726,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1726#issuecomment-792340349,"Fixes #1479

I did check for code where size checks were now superfluous, and
There are more places that check for size, like this:
if (alloc_size <= 0) {
    alloc_size = 1;
}

But I didn't remove them when they also used alloc size in other
places, like:
g->stor_end = h_str_begin + alloc_size;


Avoiding double evaluation can still be combined with macro usage like this:
static void *igraph_i_calloc(size_t nitems, size_t size) {
    return calloc (nitems > 0 ? nitems : 1, size);
}

#define IGRAPH_CALLOC(n,t)    igraph_i_calloc( n, sizeof(t) )

So that's still an option, but I also wanted to you to be able to merge this if you don't want that.

#1479 (comment):

Could we then also remove IGRAPH_FREE and IGRAPH_CALLOC from the public headers and move them to an internal header?

Should this still be done? It makes sense to me, but I'm not sure how igraph internal headers work.","We might also add #define igraph_Calloc IGRAPH_CALLOC and #define igraph_Free IGRAPH_FREE just in case someone was using these ... (the Py and R interfaces certainly do, and some Linux distros still want to compile py-igraph with their version of the igraph library—so let's not break compatibility between 0.9.0 and 0.9.1)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1726,2021-03-07T09:52:28Z,2021-03-07T21:15:15Z,2021-03-07T21:15:15Z,MERGED,True,744,699,99,https://github.com/GroteGnoom,Make zero allocs consistent,10,[],https://github.com/igraph/igraph/pull/1726,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1726#issuecomment-792345855,"Fixes #1479

I did check for code where size checks were now superfluous, and
There are more places that check for size, like this:
if (alloc_size <= 0) {
    alloc_size = 1;
}

But I didn't remove them when they also used alloc size in other
places, like:
g->stor_end = h_str_begin + alloc_size;


Avoiding double evaluation can still be combined with macro usage like this:
static void *igraph_i_calloc(size_t nitems, size_t size) {
    return calloc (nitems > 0 ? nitems : 1, size);
}

#define IGRAPH_CALLOC(n,t)    igraph_i_calloc( n, sizeof(t) )

So that's still an option, but I also wanted to you to be able to merge this if you don't want that.

#1479 (comment):

Could we then also remove IGRAPH_FREE and IGRAPH_CALLOC from the public headers and move them to an internal header?

Should this still be done? It makes sense to me, but I'm not sure how igraph internal headers work.","Looks good to me, let's see what @szhorvat says about that single comment above.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1728,Fixes #1223,Fixes #1223,True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1728#issuecomment-792360381,Fixes #1223,"It would be nice to think about whether it is possible to implement a directed generalization.
We could perhaps use the same general approach, but from each vertex, look for both the outgoing and incoming longest shortest path. Then take the endpoint of the longer one of the two as the next vertex. A bit of care will be needed to correctly assign the to and from endpoints of the result.
This approach will correctly recover the diameter of a directed path graph or cycle graph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1728#issuecomment-792362619,Fixes #1223,"A second generalization that I would love to see implemented is support for weights. Perhaps this can be a separate function, for consistency with igraph_diameter_dijkstra. We might also want to look for ways to reduce code duplication and re-use parts of the existing diameter calculation code, and perhaps even share it with eccentricity. The basic building block is the single-source shortest path calculation, which should be re-usable between these, and perhaps between other functions as well.
I would not go as far as to share it with the shortest path functions, as that might overload the basic building block too much. Also, a feature I'd like to see for shortest path calculations is the addition of a range limit. This means that it may be useful to keep the building block of those functions separate.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1728#issuecomment-792628897,Fixes #1223,"We might also want to look for ways to reduce code duplication and re-use parts of the existing diameter calculation code, and perhaps even share it with eccentricity. The basic building block is the single-source shortest path calculation, which should be re-usable between these, and perhaps between other functions as well.

I can let igraph_i_eccentricity return a vector of ecc_vids, which will contain the endpoints of the paths furthest from the starting point, with the vertex with lowest degree selected if there are multiple endpoints which are furthest. This can then be used in both igraph_pseudo_diameter and igraph_diameter. Is that what you had in mind? Most of igraph_diameter can then be replaced by a call to igraph_i_eccentricity. igraph_i_eccentricity then also needs to return if it's disconnected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1728#issuecomment-792672915,Fixes #1223,"Let's get it working correctly first for all cases (directed/undirected, weighted/unweighted) and we can see about sharing code between the implementations later.
I'd suggest to update this implementation to handle directed graphs, then do a separate PR for weighted (separate function), then finally think about reducing code duplication.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1728#issuecomment-792675280,Fixes #1223,"Within this PR, I would also add an unconn argument, just like in igraph_diameter(). If it has ever happened that we could not reach all vertices, then we know that the graph is unconnected. Then if unconn == false, we return IGRAPH_INFINITY. We can note in the documentation that in the directed case, this function may not detect that the graph is disconnected, thus the result is still to be taken merely as a lower bound for the true diameter.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1728#issuecomment-793000567,Fixes #1223,"For the directed case, because I'm checking shortest in and out eccentricities, I think a non-strongly connected graph is always detected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1728#issuecomment-793611149,Fixes #1223,"Looks good to me now, let's wait for @szhorvat to see if he is okay with it as well",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1728#issuecomment-794236097,Fixes #1223,"In case you were wondering why the output changed: When calculating degrees before, I ignored loops. Now loops are not ignored.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1728#issuecomment-794267235,Fixes #1223,"I keep looking at this use of igraph_neighbors and I find it a bit unusual. I don't understand its purpose.  It seems to be an attempted optimization for the case when the eccentricity is computed only for part of the vertices.
But to compute the eccentricity of just one vertex, we must do a BFS from that vertex. That involves traversing all vertices, thus retrieving the neighbours of all vertices. Therefore, nothing would be saved by not using a complete adjlist (passed to the function as an argument, just like it is now, in order to avoid creating a new adjlist for each invocation).
Am I missing something?
If I am, even then the better solution would be to allow a lazy adjlist (which perhaps didn't exist when this function was originally written).
@ntamas @GroteGnoom what do you think?

In case you were wondering why the output changed: When calculating degrees before, I ignored loops. Now loops are not ignored.

That is not nice indeed. If we were to go with the full adjlist solution, this could easily be taken care of with the IGRAPH_NO_LOOPS setting in the adjlist_init.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1728#issuecomment-794270717,Fixes #1223,"Can you pls update the copyright header with the new version and ""2011-2021""?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/GroteGnoom,12,https://github.com/igraph/igraph/pull/1728#issuecomment-794310038,Fixes #1223,"But to compute the eccentricity of just one vertex, we must do a BFS from that vertex. That involves traversing all vertices, thus retrieving the neighbours of all vertices.

This does not hold for disconnected or not strongly connected graphs. That's when the amount of igraph_neighbours calls is less than the amount of nodes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1728#issuecomment-794313687,Fixes #1223,"I changed the eccentricity function to use a full adjlist, like this (on master):
int igraph_eccentricity(const igraph_t *graph,
                        igraph_vector_t *res,
                        igraph_vs_t vids,
                        igraph_neimode_t mode) {

    igraph_adjlist_t adjlist;

    IGRAPH_CHECK(igraph_adjlist_init(graph, &adjlist, mode, IGRAPH_NO_LOOPS, IGRAPH_MULTIPLE));
    IGRAPH_FINALLY(igraph_adjlist_destroy, &adjlist);

    IGRAPH_CHECK(igraph_i_eccentricity(graph, res, vids, mode, /*adjlist=*/ &adjlist));

    igraph_adjlist_destroy(&adjlist);
    IGRAPH_FINALLY_CLEAN(1);

    return IGRAPH_SUCCESS;
}

Then I did some benchmarking with the Mathematica interface. Note that there's a high overhead from converting the graph from Mathematica format to igraph format, and that the shortest timings may not be reliable. The graph was connected.
Old implementation timings:

Timings with a full adjlist:

It seems that there's a noticeable gain from using the full adjlist, except maybe when calculating for a single vertex. In that case it's unclear if the difference is real, and whether the extra-short timings are reliable.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1728#issuecomment-794319024,Fixes #1223,"This does not hold for disconnected or not strongly connected graphs. That's when the amount of igraph_neighbours calls is less than the amount of nodes.

I would go for the lazy adjlist solution then.
The adjlist argument was only used in igraph_radius. There is probably no noticeable gain in using an adjlist_t instead of a lazy_adjlist_t (though we really need robust benchmarks ...)
Therefore I would have igraph_i_eccentricity take a lazy_adjlist_t argument and make it mandatory (cannot be NULL). Then we can get rid of igraph_neighbors.

When initializing the adjlist, note that IGRAPH_NO_MULTIPLE currently is slower than IGRAPH_MULTIPLE, but whether this is a performance gain or loss in the end I have no idea.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1728#issuecomment-794526350,Fixes #1223,"I made a few small changes.
The final thing to think about is which degree (in? out? total?) to use to choose one of several max eccentricity vertices in the directed case. This is a minor part of the heuristic and it probably does not matter much, but I would like to understand the implications a bit better (tomorrow, with a clearer mind).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1728#issuecomment-794534756,Fixes #1223,"One more comment is that when setting the error handler to ignore errors, it is best to immediately restore it when the function exits. When want the program to be aborted (and the test to fail) when an unexpected error comes up. See last commit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/apps/codecov,17,https://github.com/igraph/igraph/pull/1728#issuecomment-795374365,Fixes #1223,"Codecov Report

Merging #1728 (3442ca2) into develop (8e73d0d) will increase coverage by 0.04%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #1728      +/-   ##
===========================================
+ Coverage    70.10%   70.14%   +0.04%     
===========================================
  Files          305      305              
  Lines        58236    58323      +87     
===========================================
+ Hits         40825    40912      +87     
  Misses       17411    17411              



Impacted Files
Coverage Δ





src/paths/distances.c
99.34% <100.00%> (+0.86%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8e73d0d...b84a363. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/1728#issuecomment-795422589,Fixes #1223,"Merging #1728 (3442ca2) into develop (8e73d0d) will increase coverage by 0.04%.

Isn't this a bit demotivating? :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1728#issuecomment-795430749,Fixes #1223,"We can turn off the automated comments (this was the first one, and a bit of a surprise).
https://docs.codecov.io/docs/pull-request-comments
What's nice is that now we can see whether all newly introduced functionality is covered by tests. This is especially relevant for functions which have many branches, such as igraph_is_perfect.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1728#issuecomment-795434185,Fixes #1223,"The igraph_sir PR led to a whopping 0.17% increase. There's a lot of code, so it's slow. https://codecov.io/gh/igraph/igraph/commit/02fd620c4d419dae3f76c7b79fdfd1cde8a0e007/
We should avoid the temptation to read too much into the numbers. E.g. most of the gengraph (degseq_vl) code is unused, therefore untested. It's pointless to bother with it.  It's just a tool to find what is actually worth testing better, but increasing the numbers for the number's sake should be avoided.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1728,2021-03-07T16:00:39Z,2021-03-11T10:28:45Z,2021-03-11T10:28:45Z,MERGED,True,491,55,7,https://github.com/GroteGnoom,Add pseudo_diameter function,19,[],https://github.com/igraph/igraph/pull/1728,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1728#issuecomment-795700025,Fixes #1223,"If everyone is happy with this, and there are no comments on the tie-breaking in the directed case, I'll merge this later tonight.",True,"{'THUMBS_UP': ['https://github.com/ntamas', 'https://github.com/GroteGnoom']}"
igraph/igraph,https://github.com/igraph/igraph,1729,2021-03-07T16:37:36Z,2021-03-09T13:55:58Z,2021-03-09T13:55:58Z,MERGED,True,276,35,10,https://github.com/szhorvat,Full interruption support for GLPK,10,[],https://github.com/igraph/igraph/pull/1729,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1729,"This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.","This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1729,2021-03-07T16:37:36Z,2021-03-09T13:55:58Z,2021-03-09T13:55:58Z,MERGED,True,276,35,10,https://github.com/szhorvat,Full interruption support for GLPK,10,[],https://github.com/igraph/igraph/pull/1729,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1729#issuecomment-792310272,"This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.","OK, I found it. Now interruption works even with the vendored GLPK, but it's a bit slow. Unfortunately, interruption is tied to output printing, so there is an opportunity to interruption only as often as there is terminal output. I might have missed some places where output was disabled, which may be slowing down interruption. It is definitely slower with the vendored GLPK than an external GLPK 5.0.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1729,2021-03-07T16:37:36Z,2021-03-09T13:55:58Z,2021-03-09T13:55:58Z,MERGED,True,276,35,10,https://github.com/szhorvat,Full interruption support for GLPK,10,[],https://github.com/igraph/igraph/pull/1729,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1729#issuecomment-792321279,"This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.","This is not going to work as-is. It is leaking memory horribly on every interruption (hundreds of megabytes for a graph with only 100 vertices and 200 edges).
Interruption is not always interactive. A realistic use case is to compute the feedback arc set of a bunch of graph, with a time limit set on each (interruption when reaching the time limit). In fact, I have done precisely this with SageMath.
I need to understand what glp_free_env() does precisely and when it is safe to call it. If we do call it, we must avoid calling glp_delete_prob() after it, as it would lead to an abort/crash due to GLPK's overzealous error checking (see the checks in glp_free). Normally, glp_delete_prob would be called by IGRAPH_FINALLY_FREE.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1729,2021-03-07T16:37:36Z,2021-03-09T13:55:58Z,2021-03-09T13:55:58Z,MERGED,True,276,35,10,https://github.com/szhorvat,Full interruption support for GLPK,10,[],https://github.com/igraph/igraph/pull/1729,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1729#issuecomment-792335922,"This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.","Now we call glp_free_env(), no more memory leak on interruption.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1729,2021-03-07T16:37:36Z,2021-03-09T13:55:58Z,2021-03-09T13:55:58Z,MERGED,True,276,35,10,https://github.com/szhorvat,Full interruption support for GLPK,10,[],https://github.com/igraph/igraph/pull/1729,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1729#issuecomment-793798425,"This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.","I needed to do another hack and add glp_at_error() to our vendored GLPK to be able to determine which messages are error messages, and therefore should be collected for reporting.
Once we update the vendored GLPK, this hack will no longer be needed. New GLPK have this function.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1729,2021-03-07T16:37:36Z,2021-03-09T13:55:58Z,2021-03-09T13:55:58Z,MERGED,True,276,35,10,https://github.com/szhorvat,Full interruption support for GLPK,10,[],https://github.com/igraph/igraph/pull/1729,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1729#issuecomment-793798559,"This fixes #897 and #1382
Interruption does not work yet with the vendored GLPK, and I have not yet had time to figure out if this is because this old GLPK does not properly support it, or because changes were made to it. I have already undone some changes which would have prevented it from working but it still does not work.
Nevertheless, comments are already welcome.
I am not totally happy with putting igraph_abort() into an internal error.h, as it is not easy to include in vendored sources.",I plan to merge this later today.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1730,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1730#issuecomment-792346313,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"There are a few more issues that I did not originally notice. The IGraph/M implementation has a note at the top that:

this function assumes the input to be undirected, simple, connected

The Mathematica code makes sure not to call the C++ code with any graph that violates these assumptions. These need to be checked in this version.


This implementation does not in fact ignore edge directions. It would fail to work correctly for directed graphs as igraph_subisomorphic_lad does consider edge directions and would error when trying to find an undirected subgraph in a  directed graph.  Thus: Check if the graph is directed and throw an error if it is.


Multi-edges: Similarly, these are not ignored, but cause an error. If the graph is not simple, the function should throw an error.


Connectedness: I do not recall why I required this. The Mathematica code decomponses the graph into connected components and tests each one separately. Possibly I did this for performance (avoid creating huge complement graphs), but we need to think it through if connected graphs can be admitted.


Please also add the usual edge cases to the tests: null graph, singleton graph, graph with at least two vertices but no edges.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1730#issuecomment-792354257,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Regarding code formatting: the root of the repository contains an .astylerc file, which can be used in conjunction with astyle to format a file in a way that is mostly consistent with the rest of the codebase. Since this PR contains a new file, the easiest way to fix its formatting would be to pipe it through astyle with the .astylerc configuration file:
$ astyle --project=.astylerc src/properties/perfect.c",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/guyroznb,4,https://github.com/igraph/igraph/pull/1730#issuecomment-792905378,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Thanks for the review.
@szhorvat The igraph_subisomorphic_lad through an error if the graph has multi edges. Is that enough?
About the Connectedness I don't think this is an issue to address. The subisomorphic works with unconnected graph. What do you think?
@ntamas when I execute the line you suggested at the igraph directory I get the following error:

Cannot open project option file .astylerc

Do you know what is the problem?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1730#issuecomment-793561660,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"@szhorvat The igraph_subisomorphic_lad through an error if the graph has multi edges. Is that enough?

I would prefer to have a check for non-simple graphs, so that the function behaves consistently and rejects all (not just some) non-simple graphs. First do a check for directed graphs (igraph_is_directed) and throw an error if the graph is directed. Then use igraph_is_simple to check for non-simple graphs.

@ntamas when I execute the line you suggested at the igraph directory I get the following error:

Do you see a file named .astylerc in the root directory of the repository?  Note that it is a hidden file. Which operating system are you using?
I can help you with this re-formatting if for some reason it does not work. Just let me know when I should do it, so we do not edit the code at the same time and create conflicts.

About the Connectedness I don't think this is an issue to address.

Yes, it seems that this is mainly a performance issue (avoiding creating a complement that is too large) that we can ignore for now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/guyroznb,6,https://github.com/igraph/igraph/pull/1730#issuecomment-793946901,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"@szhorvat & @ntamas thanks for the review.
I am using linux (WSL) with ubuntu distribution. @szhorvat it would be helpfull if could do the  re-formatting.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1730#issuecomment-794150575,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"@szhorvat it would be helpfull if could do the re-formatting.

I did the reformatting now. Is it possible that you did not run the command suggested by Tamás from the root directory?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1730#issuecomment-794157373,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Here are a few issues I noticed and corrected, which I am mentioning for future PRs you might submit:

Always base your PRs on the latest develop branch. This one was based on a rather old version of that branch.
IGRAPH_ALLOW_INTERRUPTION() checks if an interruption was requested. It makes sense in a loop, not at the end of the function (where it would serve no purpose). It should be called at a point where a return from the function is not harmful and will not lead to memory leaks.
When changing the error handler in order to test invalid input, always set it back immediately after the function was called. This way, if any later functions fail in the test program, we can notice. Do this even if the error test is the last one. Someone may add more tests later.
The guidelines for error messages are here. We would like to have all of them have the same style, i.e. use sentence case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1730#issuecomment-794182749,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"@guyroznb Please check the very last commit above. There was a bug.
The idea is to look for cycles of odd length in the graph and its complement.  We look for larger and larger cycles.  We already checked the girth: we can thus skip anything that is smaller than or equal to the girth of the respective graph.
The original code in IGraph/M was using the short-circuiting property of && to avoid running the subisomorphism tests unnecessarily.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1730#issuecomment-794342649,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,I just noticed it's not included in the docs. Can you please include it in coloring.xxml @guyroznb ?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/guyroznb,11,https://github.com/igraph/igraph/pull/1730#issuecomment-794358568,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Thanks for this @szhorvat.
I will add the docs.
I ran the command from the root directory i don't know why it didn't work...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1730#issuecomment-795127091,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"I went through the code as well. I am not too familiar with perfect graphs, so it might not make sense (complexity-wise, or readability-wise), but how about reorganizing the code such that first we check things that we could check without creating the complementer (bipartiteness, chordality and girth of the original graph) in the hope that we can bail out early, and then create the complementer only if we could not reach a conclusion just by looking at the original graph?
I'm just a bit worried about the case when the user throws a graph with 1000 vertices and only a few edges at the function; if the graph itself matches one of the easy branches, there is no need to create the complementer with tons of edges.
@szhorvat you are the expert on this, so I leave this decision up to you.
I would probably also create a helper function that takes a graph and checks the ""easy routes"" without creating the complementer, and returns true/false/inconclusive (and also the girth in an additional output argument). You could then just call this helper function first on the original graph, then on the complementer, and bail out early if any of the tests was conclusive. If neither are conclusive, you have the girth of both graphs and then you could proceed with the more complex subisomorphism tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1730#issuecomment-795146341,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"but how about reorganizing the code such that first we check things that we could check without creating the complementer (bipartiteness, chordality and girth of the original graph) in the hope that we can bail out early, and then create the complementer only if we could not reach a conclusion just by looking at the original graph?

Yes, let's do this.

I'm just a bit worried about the case when the user throws a graph with 1000 vertices and only a few edges at the function; if the graph itself matches one of the easy branches, there is no need to create the complementer with tons of edges.

Yes, this is a concern. In fact, the original version of this function in IGraph/M first decomposes the graph into connected components, and runs the test separately on each component. I believe one might even use bi-connected components instead. This is to avoid creating the complement of a large sparse graph.
Doing this and creating a large number of igraph_t objects (even one-by-one) might be a bit messy though ... However, given how slow igraph_subisomorphic_lad is, it might be worth it, at least for graphs above a certain size.  If we go this route, it will be worthwhile doing some benchmarking. We would need to answer questions like:

Above what size is decomposition into connected components worth it?
Is biconnected components worth it?
etc.


Yet another early optimization we can add is checking the size of the graph: any graph with <= 4 vertices is perfect.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1730#issuecomment-795380012,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,@guyroznb Can you please merge develop into this branch once more? I did not do it myself to avoid any conflicts with new edits you may have on your side.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/guyroznb,15,https://github.com/igraph/igraph/pull/1730#issuecomment-795929187,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"I think that even if the graph is very sparse, we should first find if the complementary graph is bipartite or chordal and then find if a cycle is  sub - isomorphic to the graph (or its complementary). The reason is that the running time of the function igraph_is_bipartite is O(|V|+|E|) and the function igraph_is_chordal  is O(V), while the running time of igraph_subisomorphic_lad is exponential.
Let say that we have a large graph G = (V,E) (which isn't bipartite or chordal) that has a complementary G' with O(|V|^2) edges. The running time of executing igraph_is_chordal  on G' isn't affected by the number of edges the input graph has, while the running time of executing igraph_is_bipartite of G' would increase by a factor |V| = n relative to the running time of igraph_is_bipartite(G) (O(n+n^2) = o(n^2)). This is still preferable to running an exponential function (especially on large graphs) on the sparse graph G.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/apps/codecov,16,https://github.com/igraph/igraph/pull/1730#issuecomment-795956133,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Codecov Report

Merging #1730 (8ec7d7e) into develop (8e73d0d) will increase coverage by 0.31%.
The diff coverage is 89.70%.


@@             Coverage Diff             @@
##           develop    #1730      +/-   ##
===========================================
+ Coverage    70.10%   70.41%   +0.31%     
===========================================
  Files          305      306       +1     
  Lines        58236    58391     +155     
===========================================
+ Hits         40825    41115     +290     
+ Misses       17411    17276     -135     



Impacted Files
Coverage Δ





src/properties/perfect.c
89.70% <89.70%> (ø)



src/isomorphism/lad.c
95.47% <0.00%> (+0.12%)
⬆️


src/paths/distances.c
99.34% <0.00%> (+0.86%)
⬆️


src/properties/girth.c
69.51% <0.00%> (+1.21%)
⬆️


src/misc/bipartite.c
65.33% <0.00%> (+2.10%)
⬆️


src/constructors/famous.c
70.66% <0.00%> (+2.66%)
⬆️


src/operators/complementer.c
100.00% <0.00%> (+3.33%)
⬆️


src/misc/chordality.c
79.01% <0.00%> (+79.01%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8e73d0d...8ec7d7e. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/1730#issuecomment-795975495,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"I think that even if the graph is very sparse, we should first find if the complementary graph is bipartite or chordal and then find if a cycle is sub - isomorphic to the graph (or its complementary).

Yes, absolutely, there's no debate about that. My preferred order for the checks would be:

check vertex count < 4 (as proposed by @szhorvat)
check bipartiteness
check chordality
check girth
check bipartiteness of complementer
check chordality of complementer
check girth of complementer
do all sorts of subisomorphism tests as a last resort

So we are essentially deferring the creation of the complementer graph to after the bipartiteness, chordality and girth tests, but before we start doing subisomorphism tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1730#issuecomment-795996329,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Can you please add a few more tests, to make sure we cover all branches? The coverage tool is nice to verify this
Some ideas:

A random tree (igraph_tree_game()) — perfect
The complement of the 7-cycle — not perfect
4x4 grid graph — perfect
A couple more from igraph_famous, e.g. the Chvatal graph is not perfect",True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1730#issuecomment-796000146,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"Note: it's <= 4, not < 4.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/guyroznb,20,https://github.com/igraph/igraph/pull/1730#issuecomment-796001306,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"right now the order is:

check vertex count < 5
check bipartiteness
check chordality
check bipartiteness of complementer
check chordality of complementer
check girth
check girth of complementer
subisomorphism tests

This is because the running time of finding the girth (at worst case) is O((|V|+|E|)^2). So I think that this order is better. What do you think?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1730#issuecomment-796026946,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"One more thing I'd do is to have the opportunity to return from the function after each check.
E.g., now both the bipartite and chordality checks are run in full before checking their results.
Doing many checks will create a lot of repetitive code that frees data structures. The usual way I deal with this is to create multiple return points at the end of the function and jump to them with goto, e.g.
clean1:
        igraph_destroy(&comp_graph);
        IGRAPH_FINALLY_CLEAN(1);
        return IGRAPH_SUCCESS;

clean2:
        igraph_destroy(&cycle);
        igraph_destroy(&comp_graph);
        IGRAPH_FINALLY_CLEAN(2);
        return IGRAPH_SUCCESS;

then you just goto clean1 or goto clean2 as needed.",True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1730#issuecomment-796645345,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,I am happy to merge this if there are no additional comments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1730#issuecomment-796645745,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,It is nice to see that Covecov will edit the original report (above) with the new data instead of posting more comments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1730#issuecomment-797677815,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,"It seems like you accidentally checked the vertex count, not the edge count, at the beginning of the function. I fixed this and retained an edge count check as well.
I will merge once the tests pass. Azure Pipelines is having problems today.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1730,2021-03-07T19:19:59Z,2021-03-12T19:56:35Z,2021-03-12T20:23:52Z,MERGED,True,331,0,7,https://github.com/guyroznb,Perfect graph,31,[],https://github.com/igraph/igraph/pull/1730,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1730#issuecomment-797719447,This PR answers the issue #1122 adding the function igraph_perfect (which is implemented in IGraph/M).,Thanks for the contribution!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1732,2021-03-10T12:32:34Z,2021-03-10T13:05:30Z,2021-03-10T13:05:39Z,MERGED,True,155,9,4,https://github.com/GroteGnoom,Add igraph_sir unit tests,1,[],https://github.com/igraph/igraph/pull/1732,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1732,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1732,2021-03-10T12:32:34Z,2021-03-10T13:05:30Z,2021-03-10T13:05:39Z,MERGED,True,155,9,4,https://github.com/GroteGnoom,Add igraph_sir unit tests,1,[],https://github.com/igraph/igraph/pull/1732,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1732#issuecomment-795358286,Part of #1592,I tried to enable Codecov for PRs. Can you please rebase on top of latest master (or just merge master)?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1732,2021-03-10T12:32:34Z,2021-03-10T13:05:30Z,2021-03-10T13:05:39Z,MERGED,True,155,9,4,https://github.com/GroteGnoom,Add igraph_sir unit tests,1,[],https://github.com/igraph/igraph/pull/1732,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1732#issuecomment-795383269,Part of #1592,PR seems OK for me FWIW.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1732,2021-03-10T12:32:34Z,2021-03-10T13:05:30Z,2021-03-10T13:05:39Z,MERGED,True,155,9,4,https://github.com/GroteGnoom,Add igraph_sir unit tests,1,[],https://github.com/igraph/igraph/pull/1732,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1732#issuecomment-795385310,Part of #1592,"Thanks, merged.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1734,2021-03-11T10:35:43Z,2021-03-11T11:19:28Z,2021-03-11T11:30:47Z,MERGED,True,118,1,4,https://github.com/GroteGnoom,Add solve_lsap unit tests,2,[],https://github.com/igraph/igraph/pull/1734,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1734,"Part of #1592
I only noticed this was in /src/internal after adding tests.
It is not used internally. I therefore only did the minimal amount
of work to check that this works correctly in some cases, and disallow other
cases. If we want this to be part of public igraph, I can fix some
more things, like missing IGRAPH_CHECK calls, the malloc and calloc
calls, and the superfluous n parameter which can be taken from the matrix.
I think it's useful, and as it can be seen as a bipartite weighted graph problem I think it fits igraph, and it's worth the work to clean it up a bit.","Part of #1592
I only noticed this was in /src/internal after adding tests.
It is not used internally. I therefore only did the minimal amount
of work to check that this works correctly in some cases, and disallow other
cases. If we want this to be part of public igraph, I can fix some
more things, like missing IGRAPH_CHECK calls, the malloc and calloc
calls, and the superfluous n parameter which can be taken from the matrix.
I think it's useful, and as it can be seen as a bipartite weighted graph problem I think it fits igraph, and it's worth the work to clean it up a bit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1734,2021-03-11T10:35:43Z,2021-03-11T11:19:28Z,2021-03-11T11:30:47Z,MERGED,True,118,1,4,https://github.com/GroteGnoom,Add solve_lsap unit tests,2,[],https://github.com/igraph/igraph/pull/1734,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1734#issuecomment-796641312,"Part of #1592
I only noticed this was in /src/internal after adding tests.
It is not used internally. I therefore only did the minimal amount
of work to check that this works correctly in some cases, and disallow other
cases. If we want this to be part of public igraph, I can fix some
more things, like missing IGRAPH_CHECK calls, the malloc and calloc
calls, and the superfluous n parameter which can be taken from the matrix.
I think it's useful, and as it can be seen as a bipartite weighted graph problem I think it fits igraph, and it's worth the work to clean it up a bit.","Codecov Report

Merging #1734 (78f6faf) into master (36a866a) will increase coverage by 0.41%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1734      +/-   ##
==========================================
+ Coverage   70.09%   70.51%   +0.41%     
==========================================
  Files         305      305              
  Lines       58236    58234       -2     
==========================================
+ Hits        40821    41062     +241     
+ Misses      17415    17172     -243     



Impacted Files
Coverage Δ





src/internal/lsap.c
71.20% <100.00%> (+71.20%)
⬆️


src/centrality/centrality_other.c
51.15% <0.00%> (-0.17%)
⬇️


src/misc/bipartite.c
63.23% <0.00%> (ø)



src/games/degree_sequence.c
97.31% <0.00%> (+2.38%)
⬆️


src/core/psumtree.c
100.00% <0.00%> (+4.76%)
⬆️


src/misc/sir.c
90.00% <0.00%> (+90.00%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 36a866a...78f6faf. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1734,2021-03-11T10:35:43Z,2021-03-11T11:19:28Z,2021-03-11T11:30:47Z,MERGED,True,118,1,4,https://github.com/GroteGnoom,Add solve_lsap unit tests,2,[],https://github.com/igraph/igraph/pull/1734,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1734#issuecomment-796646922,"Part of #1592
I only noticed this was in /src/internal after adding tests.
It is not used internally. I therefore only did the minimal amount
of work to check that this works correctly in some cases, and disallow other
cases. If we want this to be part of public igraph, I can fix some
more things, like missing IGRAPH_CHECK calls, the malloc and calloc
calls, and the superfluous n parameter which can be taken from the matrix.
I think it's useful, and as it can be seen as a bipartite weighted graph problem I think it fits igraph, and it's worth the work to clean it up a bit.","This function is used by the R interface to implement match_vertices which is a sort of ""approximate isomorphism"".  I would have liked to see this ported to the C core for a long time, but I have not had time to even review the math behind it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1734,2021-03-11T10:35:43Z,2021-03-11T11:19:28Z,2021-03-11T11:30:47Z,MERGED,True,118,1,4,https://github.com/GroteGnoom,Add solve_lsap unit tests,2,[],https://github.com/igraph/igraph/pull/1734,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1734#issuecomment-796663855,"Part of #1592
I only noticed this was in /src/internal after adding tests.
It is not used internally. I therefore only did the minimal amount
of work to check that this works correctly in some cases, and disallow other
cases. If we want this to be part of public igraph, I can fix some
more things, like missing IGRAPH_CHECK calls, the malloc and calloc
calls, and the superfluous n parameter which can be taken from the matrix.
I think it's useful, and as it can be seen as a bipartite weighted graph problem I think it fits igraph, and it's worth the work to clean it up a bit.","It seems like we have two implementations of the Hungarian algorithm now in igraph. One is in internal/lsap.c, and the other one is implicitly used by igraph_maximum_bipartite_matching(). I didn't know about this one. It seems like most of the code in lsap.c came from elsewhere; I tried to find the original implementation on the Internet by searching for stuff like ap_hungarian() but nothing useful came up. It would be great to know where the original code came from and whether there are unit tests for the original code that we could use. (But all of this is not urgent now).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1734,2021-03-11T10:35:43Z,2021-03-11T11:19:28Z,2021-03-11T11:30:47Z,MERGED,True,118,1,4,https://github.com/GroteGnoom,Add solve_lsap unit tests,2,[],https://github.com/igraph/igraph/pull/1734,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1734#issuecomment-796670170,"Part of #1592
I only noticed this was in /src/internal after adding tests.
It is not used internally. I therefore only did the minimal amount
of work to check that this works correctly in some cases, and disallow other
cases. If we want this to be part of public igraph, I can fix some
more things, like missing IGRAPH_CHECK calls, the malloc and calloc
calls, and the superfluous n parameter which can be taken from the matrix.
I think it's useful, and as it can be seen as a bipartite weighted graph problem I think it fits igraph, and it's worth the work to clean it up a bit.",Earlier versions of the ap_assignment() function appear in the Github history of the clue R package (see here) so this is probably the original source.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1736,fixes #1733,fixes #1733,True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1736#issuecomment-797567908,fixes #1733,"Codecov Report

Merging #1736 (ee055a9) into develop (4057bab) will increase coverage by 0.06%.
The diff coverage is 98.13%.


@@             Coverage Diff             @@
##           develop    #1736      +/-   ##
===========================================
+ Coverage    72.09%   72.15%   +0.06%     
===========================================
  Files          291      291              
  Lines        56805    56946     +141     
===========================================
+ Hits         40951    41092     +141     
  Misses       15854    15854              



Impacted Files
Coverage Δ





src/graph/type_indexededgelist.c
82.33% <ø> (ø)



src/paths/dijkstra.c
94.13% <0.00%> (ø)



src/paths/distances.c
99.65% <100.00%> (+0.31%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4057bab...ee055a9. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1736#issuecomment-797613511,fixes #1733,"@vtraag @ntamas Since this PR already includes igraph_i_eccentricity_dijkstra anyway, would it be overkill to add a public weighted eccentricity function as well? It would be minimal work. I would vote to do it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1736#issuecomment-799314066,fixes #1733,"The inclist does not have an option to ignore multiple edges, should I add an inclist function that removes them?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1736#issuecomment-799496682,fixes #1733,"The inclist does not have an option to ignore multiple edges, should I add an inclist function that removes them?

I would say no.


The degree is used as a tie-breaker heuristic when there is more than one vertex at the same maximal distance. It seems to me that this is not a critical algorithm. Result would likely be good even if ties are broken randomly.


Especially in the weighted case, in most practical use (which I assume would use real-values weights), there are unlikely to be ties. Ties are much more likely with small integer weights or unit weights (i.e. unweighted).


There are currently no guarantees about the ordering of edges in an inclist, and we don't want to add guarantees so that we can experiment with different graph storage formats in the future. Removing parallel edges is not simple, and without guarantees on edge ordering, it is computationally expensive. Furthermore, if the edges have their own identities (as is the case in an inclist: two parallel edges have different IDs), they can have different properties, such as different weights. Thus, removing them is not something one should normally do. I would therefore not want to have such a function.



I did a brief search trying to find out the motivation behind the degree-based tie-breaking heuristic. I did not find anything. If you do, let us know. While it seems intuitive, it also seems of minor importance. I propose that we accept the small imperfection of not ignoring multi-edges when computing degrees.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1736#issuecomment-799497481,fixes #1733,"Just a heads up that this week is going to be super busy for all of us (I'm attending a conference). Reviews are likely to be slow, and some of us might not show up every day.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1736#issuecomment-825510570,fixes #1733,"I requested a review, not because I'm in a hurry, but I thought maybe this would remove the 'Changes requested', but that didn't work.
Apparently I can resolve inline comments, but can't resolve requested changes.
I just wanted to indicate that I think I made the requested changes 🙂",True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1736#issuecomment-833650311,fixes #1733,"I'm sorry, I am being stupid. I need more sleep.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1736#issuecomment-833654395,fixes #1733,There is a minor problem in that there may be a null-pointer dereference if from is given but to isn't. That is a ridiculous situation that's probably not worth bothering with ...,True,{}
igraph/igraph,https://github.com/igraph/igraph,1736,2021-03-12T15:33:47Z,2021-05-07T07:38:45Z,2021-05-07T07:38:45Z,MERGED,True,703,48,9,https://github.com/GroteGnoom,Add pseudo_diameter_dijkstra,9,[],https://github.com/igraph/igraph/pull/1736,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1736#issuecomment-833712863,fixes #1733,"Looks good to me.
The unweighted and weighted versions will not give the same result for the same starting vertex, and I didn't take the time to understand where the difference is. But I do not think that this is a problem, and I do not think that users should expect them to return the same result.
I'm feeling a bit foggy today, so I will leave merging to you @GroteGnoom @ntamas",True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1739,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1739#issuecomment-799390661,Part of #1592,"Codecov Report

Merging #1739 (a6ee4fa) into master (4a2f6f0) will increase coverage by 0.30%.
The diff coverage is 73.91%.


@@            Coverage Diff             @@
##           master    #1739      +/-   ##
==========================================
+ Coverage   70.58%   70.89%   +0.30%     
==========================================
  Files         305      305              
  Lines       58172    58190      +18     
==========================================
+ Hits        41062    41253     +191     
+ Misses      17110    16937     -173     



Impacted Files
Coverage Δ





src/misc/motifs.c
87.19% <73.91%> (+37.50%)
⬆️


src/core/error.c
78.31% <0.00%> (-3.17%)
⬇️


src/misc/microscopic_update.c
94.53% <0.00%> (+0.02%)
⬆️


src/cliques/maximal_cliques_template.h
85.60% <0.00%> (+0.10%)
⬆️


src/misc/graphicality.c
91.22% <0.00%> (+0.38%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update f2dcb25...a6ee4fa. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1739#issuecomment-799528689,Part of #1592,"Thanks again! Just a few comments, I'll fix these myself and merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1739#issuecomment-799537657,Part of #1592,"I noticed two more things:

The vertex ID check must not allow v == no_of_nodes
The cut probability vector size must be exactly the same as the motif size, according to my understanding of the original Wernicke paper.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1739#issuecomment-799568369,Part of #1592,"@GroteGnoom Unfortunately I need to leave for today. If you have time, can you please update both this function, as well as other motif functions, and corresponding tests, to check that the cut probability vector size is the same as the motif size? If not, I'll do it in a couple of days.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1739#issuecomment-800072721,Part of #1592,"Allright, I will fix that, and I will also add the motifs_randesu_no tests in this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1739,2021-03-15T12:42:33Z,2021-03-16T11:48:38Z,2021-03-16T11:49:10Z,MERGED,True,281,23,7,https://github.com/GroteGnoom,Add motifs_randesu_estimate unit tests,4,[],https://github.com/igraph/igraph/pull/1739,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1739#issuecomment-800191461,Part of #1592,Thank you for fixing this!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1740,2021-03-16T09:49:25Z,2021-03-16T11:51:30Z,2021-03-16T11:51:30Z,MERGED,True,77,2,4,https://github.com/GroteGnoom,Add list_triangles unit tests,3,[],https://github.com/igraph/igraph/pull/1740,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1740,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1740,2021-03-16T09:49:25Z,2021-03-16T11:51:30Z,2021-03-16T11:51:30Z,MERGED,True,77,2,4,https://github.com/GroteGnoom,Add list_triangles unit tests,3,[],https://github.com/igraph/igraph/pull/1740,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1740#issuecomment-800114922,Part of #1592,"Codecov Report

Merging #1740 (f45b46b) into master (6aa0334) will increase coverage by 0.01%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1740      +/-   ##
==========================================
+ Coverage   70.58%   70.59%   +0.01%     
==========================================
  Files         305      305              
  Lines       58177    58177              
==========================================
+ Hits        41065    41072       +7     
+ Misses      17112    17105       -7     



Impacted Files
Coverage Δ





src/properties/triangles.c
88.85% <100.00%> (+0.53%)
⬆️


src/properties/triangles_template.h
96.42% <0.00%> (+8.92%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 6aa0334...f45b46b. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1745,2021-03-26T09:20:53Z,2021-03-26T09:42:13Z,2021-03-28T17:31:22Z,MERGED,True,2,4,1,https://github.com/dotlambda,use CMAKE_INSTALL_FULL_<dir> in igraph.pc,1,[],https://github.com/igraph/igraph/pull/1745,https://github.com/dotlambda,1,https://github.com/igraph/igraph/pull/1745,"CMAKE_INSTALL_<dir> cannot be assumed to be relative to CMAKE_INSTALL_PREFIX.
See NixOS/nixpkgs#117512 (comment).","CMAKE_INSTALL_<dir> cannot be assumed to be relative to CMAKE_INSTALL_PREFIX.
See NixOS/nixpkgs#117512 (comment).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1745,2021-03-26T09:20:53Z,2021-03-26T09:42:13Z,2021-03-28T17:31:22Z,MERGED,True,2,4,1,https://github.com/dotlambda,use CMAKE_INSTALL_FULL_<dir> in igraph.pc,1,[],https://github.com/igraph/igraph/pull/1745,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1745#issuecomment-808066250,"CMAKE_INSTALL_<dir> cannot be assumed to be relative to CMAKE_INSTALL_PREFIX.
See NixOS/nixpkgs#117512 (comment).","Codecov Report

Merging #1745 (a53d1e7) into master (ad9945c) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1745   +/-   ##
=======================================
  Coverage   70.90%   70.90%           
=======================================
  Files         305      305           
  Lines       58183    58183           
=======================================
  Hits        41253    41253           
  Misses      16930    16930           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 213abc8...a53d1e7. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1745,2021-03-26T09:20:53Z,2021-03-26T09:42:13Z,2021-03-28T17:31:22Z,MERGED,True,2,4,1,https://github.com/dotlambda,use CMAKE_INSTALL_FULL_<dir> in igraph.pc,1,[],https://github.com/igraph/igraph/pull/1745,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1745#issuecomment-808076494,"CMAKE_INSTALL_<dir> cannot be assumed to be relative to CMAKE_INSTALL_PREFIX.
See NixOS/nixpkgs#117512 (comment).",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1745,2021-03-26T09:20:53Z,2021-03-26T09:42:13Z,2021-03-28T17:31:22Z,MERGED,True,2,4,1,https://github.com/dotlambda,use CMAKE_INSTALL_FULL_<dir> in igraph.pc,1,[],https://github.com/igraph/igraph/pull/1745,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1745#issuecomment-808103001,"CMAKE_INSTALL_<dir> cannot be assumed to be relative to CMAKE_INSTALL_PREFIX.
See NixOS/nixpkgs#117512 (comment).","Just as an aside, following up from https://github.com/jtojnar/cmake-snips#assuming-cmake_install_dir-is-relative-path, the fix that @jtojnar explicitly refers to in fmtlib/fmt#1657 leaves in the prefix and exec_prefix.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1745,2021-03-26T09:20:53Z,2021-03-26T09:42:13Z,2021-03-28T17:31:22Z,MERGED,True,2,4,1,https://github.com/dotlambda,use CMAKE_INSTALL_FULL_<dir> in igraph.pc,1,[],https://github.com/igraph/igraph/pull/1745,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1745#issuecomment-808929031,"CMAKE_INSTALL_<dir> cannot be assumed to be relative to CMAKE_INSTALL_PREFIX.
See NixOS/nixpkgs#117512 (comment).","I have implemented the full solution from https://github.com/jtojnar/cmake-snips#assuming-cmake_install_dir-is-relative-path; seems to work fine with both absolute and relative paths now, and relative paths keep the ${prefix} and ${exec_prefix} variables in igraph.pc correctly.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1750,2021-04-06T12:04:24Z,2021-04-06T12:26:14Z,2021-04-06T12:26:15Z,MERGED,True,85,2,4,https://github.com/GroteGnoom,Add is_mutual unit tests,2,[],https://github.com/igraph/igraph/pull/1750,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1750,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1750,2021-04-06T12:04:24Z,2021-04-06T12:26:14Z,2021-04-06T12:26:15Z,MERGED,True,85,2,4,https://github.com/GroteGnoom,Add is_mutual unit tests,2,[],https://github.com/igraph/igraph/pull/1750,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1750#issuecomment-814068007,Part of #1592,"Codecov Report

Merging #1750 (2a745ce) into master (8c68698) will increase coverage by 0.04%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1750      +/-   ##
==========================================
+ Coverage   70.90%   70.94%   +0.04%     
==========================================
  Files         305      305              
  Lines       58186    58186              
==========================================
+ Hits        41256    41280      +24     
+ Misses      16930    16906      -24     



Impacted Files
Coverage Δ





src/properties/multiplicity.c
98.26% <100.00%> (+20.00%)
⬆️


src/graph/iterators.c
75.98% <0.00%> (+0.14%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8c68698...2a745ce. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1750,2021-04-06T12:04:24Z,2021-04-06T12:26:14Z,2021-04-06T12:26:15Z,MERGED,True,85,2,4,https://github.com/GroteGnoom,Add is_mutual unit tests,2,[],https://github.com/igraph/igraph/pull/1750,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1750#issuecomment-814071783,Part of #1592,Good to go if it passes CI.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1751,2021-04-07T13:18:40Z,2021-04-07T15:34:19Z,2021-04-07T15:34:25Z,MERGED,True,153,1,4,https://github.com/GroteGnoom,Add is_chordal unit tests,1,[],https://github.com/igraph/igraph/pull/1751,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1751,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1751,2021-04-07T13:18:40Z,2021-04-07T15:34:19Z,2021-04-07T15:34:25Z,MERGED,True,153,1,4,https://github.com/GroteGnoom,Add is_chordal unit tests,1,[],https://github.com/igraph/igraph/pull/1751,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1751#issuecomment-814910026,Part of #1592,"Codecov Report

Merging #1751 (c121b2c) into master (dfee01f) will increase coverage by 0.24%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1751      +/-   ##
==========================================
+ Coverage   70.94%   71.19%   +0.24%     
==========================================
  Files         305      305              
  Lines       58195    58199       +4     
==========================================
+ Hits        41289    41432     +143     
+ Misses      16906    16767     -139     



Impacted Files
Coverage Δ





src/misc/chordality.c
86.14% <100.00%> (+86.14%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update dfee01f...c121b2c. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1751,2021-04-07T13:18:40Z,2021-04-07T15:34:19Z,2021-04-07T15:34:25Z,MERGED,True,153,1,4,https://github.com/GroteGnoom,Add is_chordal unit tests,1,[],https://github.com/igraph/igraph/pull/1751,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1751#issuecomment-815012365,Part of #1592,Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/guyroznb,1,https://github.com/igraph/igraph/pull/1752,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1752#issuecomment-814922050,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","Codecov Report

Merging #1752 (36577f5) into develop (dd15fd9) will increase coverage by 0.06%.
The diff coverage is 94.93%.


@@             Coverage Diff             @@
##           develop    #1752      +/-   ##
===========================================
+ Coverage    72.43%   72.49%   +0.06%     
===========================================
  Files          291      292       +1     
  Lines        57171    57329     +158     
===========================================
+ Hits         41410    41560     +150     
- Misses       15761    15769       +8     



Impacted Files
Coverage Δ





src/core/heap.pmt
89.90% <0.00%> (-4.33%)
⬇️


src/paths/sparsifier.c
98.03% <98.03%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update dd15fd9...36577f5. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/guyroznb,3,https://github.com/igraph/igraph/pull/1752#issuecomment-814943485,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...",I don't know why the documentation test failed. Can someone point me to the reason?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1752#issuecomment-815009165,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","Hopefully this paper is the same as the one cited in the PR description, but it is not behind a paywall.",True,{'THUMBS_UP': ['https://github.com/guyroznb']}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1752#issuecomment-815009194,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","I added a comment, but don't worry about the documentation, that can be fixed at the end.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1752#issuecomment-817338628,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","Before we get started, a few small things:

Please do not use a private random number generator and remove the seed argument. Use the default RNG.  To generate a real, you can use RNG_UNIF(min, max). There are several other similar RNG_ functions. Sections of code that use the RNG_ macros should be fenced in RNG_BEGIN(); and RNG_END();. You will find many examples in the games directory, e.g. in callaway_traits.c.
I notice that the stretch argument is an int. In the public API, let us always use igraph-specific types, i.e. igraph_integer_t, igraph_real_t, etc. Can you explain why this needs to be an integer? Does this specific algorithm work only for integer stretch factors?
Do not use function names starting with _ (such names are reserved in C). Functions that are private to a certain file should be marked static, and can be named anything (but don't start with _). Functions that are internal, but not private to a file, should be named similarly to igraph_i_myfun.
Make tests deterministic: don't seed the RNG from time(0). Is there any special reason you created a new RNG instead of using the default one?

These are just a few starting comments, not a real review. I need to hook the function up to IGraph/M and test it before starting a proper review.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1752#issuecomment-817618166,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...",I see you changed the type of the stretch factor to real. Can you confirm then that the algorithm works for arbitrary non-integer values? I have not yet looked at the paper in detail. Does it say anything about this value being integer or real?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/guyroznb,8,https://github.com/igraph/igraph/pull/1752#issuecomment-817753246,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...",No that was my mistake. In the paper the stretch factor t is defined by for any t ≥ 1,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1752#issuecomment-836933988,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","In the paper the stretch factor t is defined by for any t ≥ 1

I have read and understood the gist of the paper now, but for me it seems that even though the definition of spanners works for any t ≥ 1, but the concrete algorithm can produce only 3-spanners, 5-spanners, 7-spanners and so on. (In other words, (2k-1)-spanners where k > 1 is an integer). Is that correct @guyroznb or did I miss something?
If this is correct, then we basically need to round the spanning factor provided by the user down to the nearest odd integer. For instance, if the user asks for a 6-spanner, we cannot achieve that with this algorithm so we effectively need to produce a 5-spanner instead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1752#issuecomment-837072693,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","Unfortunately the current implementation is at least O(n^2) due to the igraph_vector_fill() calls on vectors of length no_of_nodes (e.g., lightest_neighbor and lightest_weight) that are called in a loop that also has no_of_nodes iterations. We need to work on this to achieve the linear time complexity claimed by the original paper.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1752#issuecomment-839751920,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","I am going through the paper and correlating the steps of the algorithm in the paper with the steps of the algorithm in the implementation. I have found no traces of an absolute upper bound on the number of edges added per iteration, only a few lemmas that estimate the number of edges added in terms of expected value, so I have removed the size limit. Let me know if anyone disagrees with it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1752#issuecomment-841146075,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","Okay, I think it's good to go now. I'll wait for the CI tests to pass and then I'll merge. Thanks for your contribution!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1752,2021-04-07T13:35:53Z,2021-05-14T14:18:12Z,2021-05-14T14:18:12Z,MERGED,True,695,0,10,https://github.com/guyroznb,Graph spanner,30,[],https://github.com/igraph/igraph/pull/1752,https://github.com/guyroznb,13,https://github.com/igraph/igraph/pull/1752#issuecomment-841174319,"This PR adds an algorithm for finding graph spanners. A spanner of a graph G = (V,E) with a stretch t is a subgraph H = (V,Es) such that Es is a subset of E and the distance between any pair of nodes in H is at most t times the distance is G. The returned graph is always a spanner of the given graph with the specified stretch.
The algorithm is based on the one introduced by baswana et al. : ""A Simple and Linear Time Randomized Algorithm for Computing Sparse Spanners in Weighted Graphs"".
https://onlinelibrary.wiley.com/doi/pdf/10.1002/rsa.20130?casa_token=Fesd03rNu1MAAAAA:9Aty-TF0vlQ4hFT3O3Bk-KU2NkdIKM7-dQ9qsxaNTxqH9JazjCtWAhqOTeqA9JwOr0_hyy6gjyDMag.
Thanks...","Hi, thanks @ntamas  for the review. I didn't have that much time recently so I wasn't able to do this myself",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1753,2021-04-08T11:39:55Z,2021-04-08T16:10:16Z,2021-04-08T16:10:20Z,MERGED,True,67,1,5,https://github.com/GroteGnoom,Add vector_floor unit tests and docs,1,[],https://github.com/igraph/igraph/pull/1753,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1753,"Also included the docs of other functions which were not in the doxrox.
Part of #1592","Also included the docs of other functions which were not in the doxrox.
Part of #1592",True,{}
igraph/igraph,https://github.com/igraph/igraph,1753,2021-04-08T11:39:55Z,2021-04-08T16:10:16Z,2021-04-08T16:10:20Z,MERGED,True,67,1,5,https://github.com/GroteGnoom,Add vector_floor unit tests and docs,1,[],https://github.com/igraph/igraph/pull/1753,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1753#issuecomment-815696053,"Also included the docs of other functions which were not in the doxrox.
Part of #1592","Codecov Report

Merging #1753 (cc5d46b) into master (44885b7) will increase coverage by 0.01%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1753      +/-   ##
==========================================
+ Coverage   71.19%   71.20%   +0.01%     
==========================================
  Files         305      305              
  Lines       58199    58199              
==========================================
+ Hits        41432    41438       +6     
+ Misses      16767    16761       -6     



Impacted Files
Coverage Δ





src/core/vector.c
74.45% <100.00%> (+2.59%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 44885b7...cc5d46b. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1753,2021-04-08T11:39:55Z,2021-04-08T16:10:16Z,2021-04-08T16:10:20Z,MERGED,True,67,1,5,https://github.com/GroteGnoom,Add vector_floor unit tests and docs,1,[],https://github.com/igraph/igraph/pull/1753,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1753#issuecomment-815952903,"Also included the docs of other functions which were not in the doxrox.
Part of #1592",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1756,2021-04-10T13:26:31Z,2021-04-10T13:47:19Z,2021-04-10T13:47:26Z,MERGED,True,1,1,1,https://github.com/jgmbenoit,fix: source typo,1,[],https://github.com/igraph/igraph/pull/1756,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1756,"Description: source typo
Correct a spelling error as reported by lintian in a binary.
Origin: debian
Comment: spelling-error-in-binary
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2021-04-09","Description: source typo
Correct a spelling error as reported by lintian in a binary.
Origin: debian
Comment: spelling-error-in-binary
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2021-04-09",True,{}
igraph/igraph,https://github.com/igraph/igraph,1756,2021-04-10T13:26:31Z,2021-04-10T13:47:19Z,2021-04-10T13:47:26Z,MERGED,True,1,1,1,https://github.com/jgmbenoit,fix: source typo,1,[],https://github.com/igraph/igraph/pull/1756,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1756#issuecomment-817137181,"Description: source typo
Correct a spelling error as reported by lintian in a binary.
Origin: debian
Comment: spelling-error-in-binary
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2021-04-09","Codecov Report

Merging #1756 (0efc3ae) into master (8dff206) will not change coverage.
The diff coverage is 100.00%.


@@           Coverage Diff           @@
##           master    #1756   +/-   ##
=======================================
  Coverage   71.20%   71.20%           
=======================================
  Files         305      305           
  Lines       58205    58205           
=======================================
  Hits        41444    41444           
  Misses      16761    16761           



Impacted Files
Coverage Δ





src/games/citations.c
89.17% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8dff206...0efc3ae. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1756,2021-04-10T13:26:31Z,2021-04-10T13:47:19Z,2021-04-10T13:47:26Z,MERGED,True,1,1,1,https://github.com/jgmbenoit,fix: source typo,1,[],https://github.com/igraph/igraph/pull/1756,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1756#issuecomment-817139427,"Description: source typo
Correct a spelling error as reported by lintian in a binary.
Origin: debian
Comment: spelling-error-in-binary
Author: Jerome Benoit calculus@rezozer.net
Last-Update: 2021-04-09",Thank you!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1758,2021-04-12T18:41:45Z,2021-04-12T19:17:41Z,2021-04-12T19:17:41Z,MERGED,True,0,0,23,https://github.com/jgmbenoit,fix: improper executable bit,1,[],https://github.com/igraph/igraph/pull/1758,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1758,"Make non executable some source files, some data files, and some pictures.","Make non executable some source files, some data files, and some pictures.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1758,2021-04-12T18:41:45Z,2021-04-12T19:17:41Z,2021-04-12T19:17:41Z,MERGED,True,0,0,23,https://github.com/jgmbenoit,fix: improper executable bit,1,[],https://github.com/igraph/igraph/pull/1758,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1758#issuecomment-818045286,"Make non executable some source files, some data files, and some pictures.","Codecov Report

Merging #1758 (e8d3ede) into master (a951b9e) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1758   +/-   ##
=======================================
  Coverage   71.20%   71.20%           
=======================================
  Files         305      305           
  Lines       58205    58205           
=======================================
  Hits        41444    41444           
  Misses      16761    16761           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update a951b9e...e8d3ede. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1759,2021-04-12T18:58:03Z,2021-04-12T19:16:53Z,2021-04-12T19:16:53Z,MERGED,True,3,1,1,https://github.com/szhorvat,ci: update homebrew formulae,1,[],https://github.com/igraph/igraph/pull/1759,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1759,"This is to deal with the failing macOS tests, but it has a cost of 2+ minutes.
Alternatively, we can wait until Azure Pipelines updates their macOS images.
See actions/virtual-environments#3165","This is to deal with the failing macOS tests, but it has a cost of 2+ minutes.
Alternatively, we can wait until Azure Pipelines updates their macOS images.
See actions/virtual-environments#3165",True,{}
igraph/igraph,https://github.com/igraph/igraph,1759,2021-04-12T18:58:03Z,2021-04-12T19:16:53Z,2021-04-12T19:16:53Z,MERGED,True,3,1,1,https://github.com/szhorvat,ci: update homebrew formulae,1,[],https://github.com/igraph/igraph/pull/1759,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1759#issuecomment-818058487,"This is to deal with the failing macOS tests, but it has a cost of 2+ minutes.
Alternatively, we can wait until Azure Pipelines updates their macOS images.
See actions/virtual-environments#3165","Codecov Report

Merging #1759 (b2af4ed) into master (a951b9e) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1759   +/-   ##
=======================================
  Coverage   71.20%   71.20%           
=======================================
  Files         305      305           
  Lines       58205    58205           
=======================================
  Hits        41444    41444           
  Misses      16761    16761           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update a951b9e...b2af4ed. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/kloczek,1,https://github.com/igraph/igraph/pull/1762,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com","cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1762#issuecomment-819571962,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com","Codecov Report

Merging #1762 (4d63f5d) into master (d5e9519) will decrease coverage by 0.00%.
The diff coverage is n/a.


@@            Coverage Diff             @@
##           master    #1762      +/-   ##
==========================================
- Coverage   71.18%   71.18%   -0.01%     
==========================================
  Files         295      295              
  Lines       57579    57582       +3     
==========================================
  Hits        40988    40988              
- Misses      16591    16594       +3     



Impacted Files
Coverage Δ





src/centrality/prpack/prpack_solver.cpp
35.18% <0.00%> (-0.27%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 0a35212...4d63f5d. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/kloczek,3,https://github.com/igraph/igraph/pull/1762#issuecomment-819581133,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com","Path is not fixing all install cmake fiels entries.
Will fix that patch later",True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1762#issuecomment-819594973,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",@kloczek Try to make the change on line 499 as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1762#issuecomment-819597594,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com","Makes sense to me; indeed, I should have used ${CMAKE_INSTALL_LIBDIR}. Once the PR fixes all such occurrences I'll happily merge it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1762#issuecomment-820460580,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",@kloczek Can you please report back about whether this resolves your issue after fixing line 499?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/kloczek,7,https://github.com/igraph/igraph/pull/1762#issuecomment-820464563,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",On sec :),True,{}
igraph/igraph,https://github.com/igraph/igraph,1762,2021-04-14T14:38:17Z,2021-04-15T14:33:28Z,2021-04-15T14:33:28Z,CLOSED,False,2,2,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1762,https://github.com/kloczek,8,https://github.com/igraph/igraph/pull/1762#issuecomment-820469453,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",Closing. Correct patch is in #1767,True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1763,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1763#issuecomment-820210314,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Codecov Report

Merging #1763 (8725135) into develop (caa7e1f) will increase coverage by 0.05%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #1763      +/-   ##
===========================================
+ Coverage    79.67%   79.72%   +0.05%     
===========================================
  Files          364      364              
  Lines        59448    59580     +132     
===========================================
+ Hits         47364    47499     +135     
+ Misses       12084    12081       -3     



Impacted Files
Coverage Δ





src/paths/shortest_paths.c
79.78% <100.00%> (+6.10%)
⬆️


src/graph/adjlist.c
92.11% <0.00%> (+0.27%)
⬆️


src/paths/dijkstra.c
96.72% <0.00%> (+0.46%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update caa7e1f...8725135. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1763#issuecomment-836971770,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","I'm going to add some comments on this, but for now they are mostly self-reminders. No need to act on them yet.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/apps/stale,4,https://github.com/igraph/igraph/pull/1763#issuecomment-882741026,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1763#issuecomment-1032989989,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Resolved merge conflicts after the recent merge of feat/typed-vector-lists into develop.
The PR should be updated so that the new function uses igraph_vector_int_list_t to return the paths instead of an igraph_vector_ptr_t. I'll do this in a separate round once I'm done with checking the other PRs for merge conflicts.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1763#issuecomment-1033133612,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","PR updated. One thing that I don't like about the current implementation is the fact that we are actively modifying the weights vector so it cannot be passed as a const igraph_vector_t* to the function, it must be non-const. The consequence is that I have to declare the parameter as INOUT in functions.yaml. Note that the function attempts to restore weights to its original state if it exist normally and not with an error code.
The alternative would be to copy the weights vector before modifying it, and then working on the copy. In theory, the copying is O(m) so it does not affect the overall time complexity of the function, but it can still be problematic if the graph is large but the part actively modified during the traversal is small.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1763#issuecomment-1126056183,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Conflicts resolved with develop. I guess that this function should be called igraph_get_k_shortest_paths() now that we have removed igraph_shortest_paths() to igraph_distances(), right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1763#issuecomment-1126405272,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.",I think this is now ready to merge if the CI passes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1763#issuecomment-1126461679,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Are the paths returned in reverse? I am looking a the undirected Wikipedia example. The first result is 7, 4, 1. But this is the path from 5 to 0, not from 0 to 5. It is reversed.
For reference, the graph is the following, with edge and vertex IDs marked (0-based):",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1763#issuecomment-1126477787,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Sorry, the function call was indeed from 5 to 0, so it's fine.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1763#issuecomment-1126487208,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Could we add some non-simple graphs to the tests?


Self-loops should always be ignored, since vertices can't repeat in the path, right?  But multi-edges should lead to multiple paths in the results.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1763,2021-04-15T07:56:43Z,2022-05-14T12:01:58Z,2022-05-14T12:01:58Z,MERGED,True,558,2,8,https://github.com/GroteGnoom,Add k shortest paths,39,['todo'],https://github.com/igraph/igraph/pull/1763,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1763#issuecomment-1126537052,"Fixes #1397
Non-obvious things:
I use infinite weights to remove edges. This way I can use get_shortest_path_dijkstra directly.
I only give the path in edges. Vertices can be inferred from this afterwards.","Are we sure we don't want to add an output argument to return the vertex paths? All other path functions have this, except igraph_get_all_simple_paths, which needs a complete refactoring anyway.
Note that the vertex paths can't be computed from the edge paths without also having at least the start vertex.
It would be a useful convenience to be able to return the vertex paths.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1767,2021-04-15T14:32:46Z,2021-04-15T15:16:43Z,2021-04-15T15:16:43Z,MERGED,True,3,3,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1767,https://github.com/kloczek,1,https://github.com/igraph/igraph/pull/1767,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com","cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",True,{}
igraph/igraph,https://github.com/igraph/igraph,1767,2021-04-15T14:32:46Z,2021-04-15T15:16:43Z,2021-04-15T15:16:43Z,MERGED,True,3,3,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1767,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1767#issuecomment-820476266,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com","Codecov Report

Merging #1767 (d5f919c) into master (a8b7531) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1767   +/-   ##
=======================================
  Coverage   71.22%   71.22%           
=======================================
  Files         295      295           
  Lines       57544    57544           
=======================================
  Hits        40988    40988           
  Misses      16556    16556           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update a8b7531...d5f919c. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1767,2021-04-15T14:32:46Z,2021-04-15T15:16:43Z,2021-04-15T15:16:43Z,MERGED,True,3,3,1,https://github.com/kloczek,install cmake files in ${CMAKE_INSTALL_LIBDIR},1,[],https://github.com/igraph/igraph/pull/1767,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1767#issuecomment-820510993,"cmake files shoud be installed in ${CMAKE_INSTALL_LIBDIR}/cmake/
Signed-off-by: Your Name you@example.com",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1768,2021-04-18T16:34:30Z,2021-04-24T12:17:58Z,2021-04-24T12:17:58Z,CLOSED,False,10,4,1,https://github.com/szhorvat,Experiments with aarch64,2,[],https://github.com/igraph/igraph/pull/1768,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1768,This is so I can experiment with aarch64 on Travis without messing with the master branch.,This is so I can experiment with aarch64 on Travis without messing with the master branch.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1768,2021-04-18T16:34:30Z,2021-04-24T12:17:58Z,2021-04-24T12:17:58Z,CLOSED,False,10,4,1,https://github.com/szhorvat,Experiments with aarch64,2,[],https://github.com/igraph/igraph/pull/1768,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1768#issuecomment-822020562,This is so I can experiment with aarch64 on Travis without messing with the master branch.,"Codecov Report

Merging #1768 (b075090) into master (0dee99e) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1768   +/-   ##
=======================================
  Coverage   71.31%   71.31%           
=======================================
  Files         295      295           
  Lines       57555    57555           
=======================================
  Hits        41046    41046           
  Misses      16509    16509           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 0dee99e...b075090. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1771,2021-04-21T10:36:20Z,2021-04-21T12:58:27Z,2021-04-21T13:33:52Z,MERGED,True,2,0,1,https://github.com/GroteGnoom,Fix triangles_template1.h cleanup,1,[],https://github.com/igraph/igraph/pull/1771,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1771,"This caused igraph_transitivity_barrat to sometimes reference undefined
memory during an IGRAPH_FINALLY_FREE.","This caused igraph_transitivity_barrat to sometimes reference undefined
memory during an IGRAPH_FINALLY_FREE.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1771,2021-04-21T10:36:20Z,2021-04-21T12:58:27Z,2021-04-21T13:33:52Z,MERGED,True,2,0,1,https://github.com/GroteGnoom,Fix triangles_template1.h cleanup,1,[],https://github.com/igraph/igraph/pull/1771,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1771#issuecomment-823962653,"This caused igraph_transitivity_barrat to sometimes reference undefined
memory during an IGRAPH_FINALLY_FREE.","Codecov Report

Merging #1771 (541cfa6) into master (298c0ac) will decrease coverage by 0.00%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1771      +/-   ##
==========================================
- Coverage   71.31%   71.31%   -0.01%     
==========================================
  Files         295      295              
  Lines       57555    57557       +2     
==========================================
  Hits        41046    41046              
- Misses      16509    16511       +2     



Impacted Files
Coverage Δ





src/properties/triangles_template1.h
75.00% <100.00%> (+1.31%)
⬆️


src/graph/iterators.c
75.70% <0.00%> (-0.29%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 298c0ac...541cfa6. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1771,2021-04-21T10:36:20Z,2021-04-21T12:58:27Z,2021-04-21T13:33:52Z,MERGED,True,2,0,1,https://github.com/GroteGnoom,Fix triangles_template1.h cleanup,1,[],https://github.com/igraph/igraph/pull/1771,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1771#issuecomment-824061948,"This caused igraph_transitivity_barrat to sometimes reference undefined
memory during an IGRAPH_FINALLY_FREE.","Nice catch, thanks!

Thanks! This was one of the most confusing bugs I ever encountered.
I wonder why VERIFY_FINALLY_STACK didn't catch it, but did catch it when calling it after each igraph_transitivity_barrat function call. Maybe because when ERRORF is called, this eventually calls IGRAPH_FINALLY_FREE? If that's the case, VERIFY_FINALLY_STACK should be called before any errors in tests.
Also: can I always merge master into develop?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1771,2021-04-21T10:36:20Z,2021-04-21T12:58:27Z,2021-04-21T13:33:52Z,MERGED,True,2,0,1,https://github.com/GroteGnoom,Fix triangles_template1.h cleanup,1,[],https://github.com/igraph/igraph/pull/1771,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1771#issuecomment-824065114,"This caused igraph_transitivity_barrat to sometimes reference undefined
memory during an IGRAPH_FINALLY_FREE.","Maybe because when ERRORF is called, this eventually calls IGRAPH_FINALLY_FREE?

Exactly, IGRAPH_ERRORF frees everything that is in the ""finally"" stack and then clears the stack. It does not care (it does not even notice) if it frees something that should have been freed by something else earlier.

Can I always merge master into develop?

Yes, that should be safe. Only bugfixes, documentation improvements and other non-breaking stuff go into master, and sooner or later it will always get merged into develop so feel free to do it any time the develop branch is behind master. Note that eventually it might become harder to keep on doing it regularly; currently the develop  branch does not include too many breaking changes yet, but in the near future we want to replace int  return values with igraph_error_t (which will be a typedef to int), which will probably result in merge conflicts all the time even though semantically the two types will be the same.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1773,2021-04-21T19:58:47Z,2021-04-21T20:09:07Z,2021-04-21T20:09:17Z,MERGED,True,8,8,1,https://github.com/eriknw,Fix `IGARPH` typo,1,[],https://github.com/igraph/igraph/pull/1773,https://github.com/eriknw,1,https://github.com/igraph/igraph/pull/1773,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1773,2021-04-21T19:58:47Z,2021-04-21T20:09:07Z,2021-04-21T20:09:17Z,MERGED,True,8,8,1,https://github.com/eriknw,Fix `IGARPH` typo,1,[],https://github.com/igraph/igraph/pull/1773,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1773#issuecomment-824322021,,"Codecov Report

Merging #1773 (4c29bbe) into master (0121db8) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1773   +/-   ##
=======================================
  Coverage   71.31%   71.31%           
=======================================
  Files         295      295           
  Lines       57557    57557           
=======================================
  Hits        41046    41046           
  Misses      16511    16511           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 0121db8...4c29bbe. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1773,2021-04-21T19:58:47Z,2021-04-21T20:09:07Z,2021-04-21T20:09:17Z,MERGED,True,8,8,1,https://github.com/eriknw,Fix `IGARPH` typo,1,[],https://github.com/igraph/igraph/pull/1773,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1773#issuecomment-824326007,,Thanks for the fix!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1774,2021-04-22T08:42:08Z,2021-04-26T22:33:57Z,2021-04-26T22:34:04Z,MERGED,True,516,34,7,https://github.com/GroteGnoom,Add i neighbors,16,[],https://github.com/igraph/igraph/pull/1774,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1774,"Fixes #1737
Some code is copied to not slow down the original code: First it is checked if the original situation is used, and if not we go to a different loop with internal branches. I haven't checked if compilers can optimize this all out by themselves.","Fixes #1737
Some code is copied to not slow down the original code: First it is checked if the original situation is used, and if not we go to a different loop with internal branches. I haven't checked if compilers can optimize this all out by themselves.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1774,2021-04-22T08:42:08Z,2021-04-26T22:33:57Z,2021-04-26T22:34:04Z,MERGED,True,516,34,7,https://github.com/GroteGnoom,Add i neighbors,16,[],https://github.com/igraph/igraph/pull/1774,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1774#issuecomment-824660044,"Fixes #1737
Some code is copied to not slow down the original code: First it is checked if the original situation is used, and if not we go to a different loop with internal branches. I haven't checked if compilers can optimize this all out by themselves.","Codecov Report

Merging #1774 (3d3b3c2) into develop (1729eb9) will increase coverage by 0.02%.
The diff coverage is 97.56%.


@@             Coverage Diff             @@
##           develop    #1774      +/-   ##
===========================================
+ Coverage    71.31%   71.34%   +0.02%     
===========================================
  Files          290      290              
  Lines        56682    56740      +58     
===========================================
+ Hits         40421    40479      +58     
  Misses       16261    16261              



Impacted Files
Coverage Δ





src/graph/type_indexededgelist.c
82.33% <97.56%> (+1.63%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1729eb9...3d3b3c2. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1774,2021-04-22T08:42:08Z,2021-04-26T22:33:57Z,2021-04-26T22:34:04Z,MERGED,True,516,34,7,https://github.com/GroteGnoom,Add i neighbors,16,[],https://github.com/igraph/igraph/pull/1774,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1774#issuecomment-824790488,"Fixes #1737
Some code is copied to not slow down the original code: First it is checked if the original situation is used, and if not we go to a different loop with internal branches. I haven't checked if compilers can optimize this all out by themselves.","you can check the coverage here (let me know if you don't have access to this).

I think you need to log in to Codecov with your Github account.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1774,2021-04-22T08:42:08Z,2021-04-26T22:33:57Z,2021-04-26T22:34:04Z,MERGED,True,516,34,7,https://github.com/GroteGnoom,Add i neighbors,16,[],https://github.com/igraph/igraph/pull/1774,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1774#issuecomment-827185469,"Fixes #1737
Some code is copied to not slow down the original code: First it is checked if the original situation is used, and if not we go to a different loop with internal branches. I haven't checked if compilers can optimize this all out by themselves.",Thanks again!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1777,2021-04-27T08:44:10Z,2021-04-28T07:51:31Z,2021-04-28T07:51:31Z,MERGED,True,143,4,4,https://github.com/GroteGnoom,Add igraph_subcomponent unit tests,2,[],https://github.com/igraph/igraph/pull/1777,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1777,"Part of #1592
Everything seems to be in order.","Part of #1592
Everything seems to be in order.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1777,2021-04-27T08:44:10Z,2021-04-28T07:51:31Z,2021-04-28T07:51:31Z,MERGED,True,143,4,4,https://github.com/GroteGnoom,Add igraph_subcomponent unit tests,2,[],https://github.com/igraph/igraph/pull/1777,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1777#issuecomment-827434488,"Part of #1592
Everything seems to be in order.","Codecov Report

Merging #1777 (9e5c602) into master (8f20cab) will increase coverage by 0.09%.
The diff coverage is 75.00%.


@@            Coverage Diff             @@
##           master    #1777      +/-   ##
==========================================
+ Coverage   71.84%   71.93%   +0.09%     
==========================================
  Files         295      295              
  Lines       57528    57584      +56     
==========================================
+ Hits        41330    41423      +93     
+ Misses      16198    16161      -37     



Impacted Files
Coverage Δ





src/connectivity/components.c
94.20% <75.00%> (+0.35%)
⬆️


src/graph/type_indexededgelist.c
82.33% <0.00%> (+1.63%)
⬆️


src/misc/motifs.c
94.81% <0.00%> (+7.20%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8f20cab...9e5c602. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1777,2021-04-27T08:44:10Z,2021-04-28T07:51:31Z,2021-04-28T07:51:31Z,MERGED,True,143,4,4,https://github.com/GroteGnoom,Add igraph_subcomponent unit tests,2,[],https://github.com/igraph/igraph/pull/1777,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1777#issuecomment-827948621,"Part of #1592
Everything seems to be in order.","Can you sort the vectors before being printed to stdout? The order of traversal in igraph_subcomponent() is entirely implementation-dependent, and I don't want the test case to break in the future if we change the implementation. All that matters is that all the nodes in the same component as the seed vertex should be in the output, it does not matter what the order is.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1777,2021-04-27T08:44:10Z,2021-04-28T07:51:31Z,2021-04-28T07:51:31Z,MERGED,True,143,4,4,https://github.com/GroteGnoom,Add igraph_subcomponent unit tests,2,[],https://github.com/igraph/igraph/pull/1777,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1777#issuecomment-828225363,"Part of #1592
Everything seems to be in order.",Of course! I missed that. It's fixed now.,True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1778,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1778#issuecomment-827512922,Part of #1592,"Codecov Report

Merging #1778 (051912d) into develop (4b5f9e7) will increase coverage by 0.10%.
The diff coverage is 80.00%.


@@             Coverage Diff             @@
##           develop    #1778      +/-   ##
===========================================
+ Coverage    71.87%   71.98%   +0.10%     
===========================================
  Files          290      291       +1     
  Lines        56711    56801      +90     
===========================================
+ Hits         40763    40888     +125     
+ Misses       15948    15913      -35     



Impacted Files
Coverage Δ





src/misc/motifs.c
94.81% <80.00%> (+7.20%)
⬆️


src/centrality/truss.cpp
100.00% <0.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4b5f9e7...051912d. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1778#issuecomment-827671760,Part of #1592,"This is a fix that would be nice to have on master. It relies on igraph_i_neighbors, which is only on develop. Do we want to backport that function to master @ntamas ? Too risky?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1778#issuecomment-827679279,Part of #1592,"Since it's internal, provides no visible changes in the public API, and it is well-tested, I'm totally fine with backporting it. I can do it later this evening, or feel free to go ahead (just let me know so we don't duplicate work).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1778#issuecomment-827690563,Part of #1592,I won't touch it today.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1778#issuecomment-827943067,Part of #1592,There was a hiccup while rebasing this PR against master; Github seems to have merged the entire develop branch back into master instead. I'll fix this manually on the master branch.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1778#issuecomment-827948879,Part of #1592,All clear now.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1778#issuecomment-831479150,Part of #1592,"Something's wrong, for a 2-vertex graph I always get Integer overflow, returning -1",True,{}
igraph/igraph,https://github.com/igraph/igraph,1778,2021-04-27T10:51:53Z,2021-04-27T20:42:52Z,2021-05-03T21:01:22Z,MERGED,True,2007,5503,70,https://github.com/GroteGnoom,Add dyad_census unit tests,49,[],https://github.com/igraph/igraph/pull/1778,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1778#issuecomment-831531351,Part of #1592,"This should fix it, c505cba",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1782,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1782#issuecomment-829096120,Part of #1592,"Codecov Report

Merging #1782 (b574a33) into master (a636b68) will increase coverage by 0.06%.
The diff coverage is 100.00%.


❗ Current head b574a33 differs from pull request most recent head 88f7fa7. Consider uploading reports for the commit 88f7fa7 to get more accurate results


@@            Coverage Diff             @@
##           master    #1782      +/-   ##
==========================================
+ Coverage   71.97%   72.04%   +0.06%     
==========================================
  Files         295      295              
  Lines       57584    57589       +5     
==========================================
+ Hits        41445    41488      +43     
+ Misses      16139    16101      -38     



Impacted Files
Coverage Δ





src/misc/bipartite.c
72.45% <100.00%> (+9.22%)
⬆️


src/core/vector.pmt
87.29% <0.00%> (ø)



src/core/vector_ptr.c
85.88% <0.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update a636b68...88f7fa7. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1782#issuecomment-829104637,Part of #1592,"I would opt for issuing a warning instead of an error, and simply ignoring edges that connect vertices within the same partition.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1782#issuecomment-829104846,Part of #1592,(I fixed the doc failure on master now.),True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1782#issuecomment-829186607,Part of #1592,"I would opt for issuing a warning instead of an error

In that case, we should probably count how many such edges there are, and just report one warning at the end of the routine with the number of non-bipartite edges.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1782#issuecomment-829190559,Part of #1592,"Yes, that, or if we want to keep it simple, then we can also omit the number, and just use a flag to determine if the warning was already reported. Let's get this in before 0.9.3. Your choice @GroteGnoom",True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1782#issuecomment-829191616,Part of #1592,"Another thought: do not say ""not bipartite"", but say ""n edges running within partitions were ignored"" or something similar.  The graph may be bipartite, but the supplied types vector may not be consistent with the two partitions.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1782#issuecomment-829351221,Part of #1592,"Fixed wording; ""independent sets"" has another meaning in graph theory so I've removed that part.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1782#issuecomment-829377198,Part of #1592,I thought I was using this definition: https://en.wikipedia.org/wiki/Independent_set_(graph_theory),True,{}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1782#issuecomment-829379820,Part of #1592,"Indeed that's the definition I was thinking about, you are right. I can't quite put my finger on what bothered me with the original message; somehow it felt confusing. Sorry :)",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1782,2021-04-29T09:48:33Z,2021-04-29T15:46:10Z,2021-04-29T16:29:10Z,MERGED,True,144,6,5,https://github.com/GroteGnoom,Add igraph_get_incidence unit tests,3,[],https://github.com/igraph/igraph/pull/1782,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1782#issuecomment-829390762,Part of #1592,"I was slightly confused too at first, but the usage was perfectly correct.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1783,2021-05-02T12:22:40Z,2021-05-02T13:10:45Z,2021-05-03T18:29:25Z,CLOSED,False,5,26,6,https://github.com/szhorvat,Remove unistd replacement for MSVC,3,[],https://github.com/igraph/igraph/pull/1783,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1783,This was an attempt to get rid of msvc/include/unistd.h and avoid the MSVC warnings about missing isatty(),This was an attempt to get rid of msvc/include/unistd.h and avoid the MSVC warnings about missing isatty(),True,{}
igraph/igraph,https://github.com/igraph/igraph,1783,2021-05-02T12:22:40Z,2021-05-02T13:10:45Z,2021-05-03T18:29:25Z,CLOSED,False,5,26,6,https://github.com/szhorvat,Remove unistd replacement for MSVC,3,[],https://github.com/igraph/igraph/pull/1783,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1783#issuecomment-830801880,This was an attempt to get rid of msvc/include/unistd.h and avoid the MSVC warnings about missing isatty(),"Codecov Report

Merging #1783 (332ddab) into master (9fdd510) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1783   +/-   ##
=======================================
  Coverage   72.04%   72.04%           
=======================================
  Files         295      295           
  Lines       57589    57589           
=======================================
  Hits        41488    41488           
  Misses      16101    16101           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 9fdd510...332ddab. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1783,2021-05-02T12:22:40Z,2021-05-02T13:10:45Z,2021-05-03T18:29:25Z,CLOSED,False,5,26,6,https://github.com/szhorvat,Remove unistd replacement for MSVC,3,[],https://github.com/igraph/igraph/pull/1783,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1783#issuecomment-830805375,This was an attempt to get rid of msvc/include/unistd.h and avoid the MSVC warnings about missing isatty(),"This was an experiment to get rid of the empty msvc/include/unistd.h.  On Windows, flex can take the --wincompat option to avoid using unistd.h.  But now I realize that the parser sources are usually generated on some Unix-like system, so release tarball would still need unistd.h.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1783,2021-05-02T12:22:40Z,2021-05-02T13:10:45Z,2021-05-03T18:29:25Z,CLOSED,False,5,26,6,https://github.com/szhorvat,Remove unistd replacement for MSVC,3,[],https://github.com/igraph/igraph/pull/1783,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1783#issuecomment-830807492,This was an attempt to get rid of msvc/include/unistd.h and avoid the MSVC warnings about missing isatty(),See #1784 for an alternative solution.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1784,2021-05-02T12:58:58Z,2021-05-02T13:18:44Z,2021-05-03T18:29:36Z,MERGED,True,11,0,1,https://github.com/szhorvat,fix: avoid warnings about missing isatty with MSVC,1,[],https://github.com/igraph/igraph/pull/1784,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1784,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1784,2021-05-02T12:58:58Z,2021-05-02T13:18:44Z,2021-05-03T18:29:36Z,MERGED,True,11,0,1,https://github.com/szhorvat,fix: avoid warnings about missing isatty with MSVC,1,[],https://github.com/igraph/igraph/pull/1784,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1784#issuecomment-830806361,,"Codecov Report

Merging #1784 (320b9d2) into master (9fdd510) will not change coverage.
The diff coverage is n/a.


❗ Current head 320b9d2 differs from pull request most recent head 9205c62. Consider uploading reports for the commit 9205c62 to get more accurate results


@@           Coverage Diff           @@
##           master    #1784   +/-   ##
=======================================
  Coverage   72.04%   72.04%           
=======================================
  Files         295      295           
  Lines       57589    57589           
=======================================
  Hits        41488    41488           
  Misses      16101    16101           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 9fdd510...9205c62. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1785,2021-05-03T17:43:31Z,2021-05-03T18:02:25Z,2021-05-03T18:29:09Z,MERGED,True,7,11,1,https://github.com/szhorvat,Attempting to fix build in s390x on Travis,3,[],https://github.com/igraph/igraph/pull/1785,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1785,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1785,2021-05-03T17:43:31Z,2021-05-03T18:02:25Z,2021-05-03T18:29:09Z,MERGED,True,7,11,1,https://github.com/szhorvat,Attempting to fix build in s390x on Travis,3,[],https://github.com/igraph/igraph/pull/1785,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1785#issuecomment-831421238,,"Codecov Report

Merging #1785 (b82fbea) into master (65c78c3) will not change coverage.
The diff coverage is n/a.


❗ Current head b82fbea differs from pull request most recent head 917b3de. Consider uploading reports for the commit 917b3de to get more accurate results


@@           Coverage Diff           @@
##           master    #1785   +/-   ##
=======================================
  Coverage   72.04%   72.04%           
=======================================
  Files         295      295           
  Lines       57589    57589           
=======================================
  Hits        41488    41488           
  Misses      16101    16101           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 65c78c3...917b3de. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1786,Fixes #1252,Fixes #1252,True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1786#issuecomment-831452521,Fixes #1252,"Codecov Report

Merging #1786 (7c48a3a) into develop (3a69e7f) will increase coverage by 0.34%.
The diff coverage is 88.38%.


@@             Coverage Diff             @@
##           develop    #1786      +/-   ##
===========================================
+ Coverage    72.21%   72.56%   +0.34%     
===========================================
  Files          295      293       -2     
  Lines        57590    57570      -20     
===========================================
+ Hits         41587    41773     +186     
+ Misses       16003    15797     -206     



Impacted Files
Coverage Δ





src/misc/cycle_bases.c
88.38% <88.38%> (ø)



src/core/matrix.c
27.45% <0.00%> (-11.77%)
⬇️


src/core/heap.pmt
89.90% <0.00%> (-4.33%)
⬇️


src/core/sparsemat.c
80.97% <0.00%> (-3.61%)
⬇️


src/core/vector.c
71.86% <0.00%> (-2.60%)
⬇️


src/linalg/eigen.c
73.42% <0.00%> (-2.06%)
⬇️


src/paths/all_shortest_paths.c
89.69% <0.00%> (-1.69%)
⬇️


src/misc/conversion.c
76.21% <0.00%> (-1.18%)
⬇️


src/paths/shortest_paths.c
73.05% <0.00%> (-1.15%)
⬇️


src/version.c
100.00% <0.00%> (ø)



... and 23 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 3a69e7f...7c48a3a. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/apps/stale,3,https://github.com/igraph/igraph/pull/1786#issuecomment-882134158,Fixes #1252,This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1786#issuecomment-882323940,Fixes #1252,I am still working on this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/apps/stale,5,https://github.com/igraph/igraph/pull/1786#issuecomment-922401119,Fixes #1252,This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1786#issuecomment-1032990997,Fixes #1252,This PR should eventually be updated to use igraph_vector_int_list_t to return cycles; I'm not touching this at the moment as it's still a draft and Github won't let me check for merge conflicts until I mark this as ready for review.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1786#issuecomment-1032992005,Fixes #1252,"It's okay, I'll deal with this one.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1786,2021-05-03T18:36:13Z,2022-02-10T11:56:06Z,2022-02-10T11:56:07Z,CLOSED,False,709,0,6,https://github.com/szhorvat,Cycle basis calculations,6,['todo'],https://github.com/igraph/igraph/pull/1786,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1786#issuecomment-1034834988,Fixes #1252,Closing in favour of #1957,True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1788,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1788#issuecomment-836469893,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","Codecov Report

Merging #1788 (8bc61e8) into master (ecab537) will increase coverage by 0.23%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1788      +/-   ##
==========================================
+ Coverage   71.97%   72.21%   +0.23%     
==========================================
  Files         295      295              
  Lines       57584    57590       +6     
==========================================
+ Hits        41445    41587     +142     
+ Misses      16139    16003     -136     



Impacted Files
Coverage Δ





src/games/sbm.c
32.16% <100.00%> (+32.16%)
⬆️


src/random/random.c
60.39% <0.00%> (-0.43%)
⬇️


src/misc/motifs.c
94.81% <0.00%> (ø)



src/core/vector.pmt
87.29% <0.00%> (ø)



src/properties/basic.c




src/layout/random.c




src/constructors/basic.c




vendor/plfit/error.c




src/layout/lgl.c




src/isomorphism/misc.c




... and 17 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update ecab537...8bc61e8. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1788#issuecomment-836497098,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.

For graph constructors, this is actually the standard behaviour.
When a function returns a result through a vector or other similar data structure, it requires an already initialized vector as input. This is for re-usability: it makes it possible to repeatedly use a vector without re-allocating it, a common use case.
However, igraph_sbm_game is a constructor: it creates an entirely new graph. It is comparable not to function that return a vector, but to functions like vector_init.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1788#issuecomment-836530507,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","For graph constructors, this is actually the standard behaviour.

Aha, all right. I didn't realize that. I don't really see the difference between output graphs and output vectors, but that's probably because I'm unfamiliar with the common use cases 🙂
I guess you would usually use output vectors as a piece of information to be read, instead of a new thing to be used, which is of course the constructor part you mention.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1788#issuecomment-836545858,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","This looks perfectly fine to me, but I am feeling a bit tired today so I would like to leave it to others to merge.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1788#issuecomment-836554378,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","I am not sure why this function takes the number of vertices, since that it always the same as the sum of block sizes. It seems completely pointless to me, even after looking at sample_sbm in R ...

I guess you would usually use output vectors as a piece of information to be read, instead of a new thing to be used, which is of course the constructor part you mention.

Yes. Conceptually, the difference is as between a ""constructor"" (in OO languages) and a return value. In this section of the docs all graph generators take an uninitialized graph.  In this section, all functions create a new vector instead of using an already initialized one. But yes: you are right. The line between the two concepts is somewhat blurry, especially in a language like C which doesn't have constructors as a language feature.
More practically, re-using an existing graph wouldn't improve performance as changing the graph usually involves complete re-allocation anyway. This is not true for vectors. Consider e.g. a BFS or similar algorithm. It needs the neighbour list of each node, and we can generate that dynamically as the algorithm proceeds, with igraph_neighbors. There is a real performance benefit from not re-allocating a new memory block inside of the loop, but re-using an existing one. I don't recall where it was that I saw this in benchmarks, but I'm certain I did.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1788#issuecomment-836558241,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","Continuing the line of thought about functions that construct new things vs functions which update existing things vs functions that return results, personally I do find it irritating that some of the vector constructors are not available as updating functions.
https://igraph.org/c/doc/igraph-Data-structures.html#vector-constructors-and-destructors
In particular, I always wanted vector_init_seq to work on an already created vector.
I also find it irritating that it is sometimes not completely obvious which functions is a constructor and which is an updater. Most vector constructors have init in their names, but not all. Consider vector_init_copy  vs vector_copy: the difference couldn't be guessed from the naming. Both are constructors, but the first one takes a raw array and the second one an existing vector. I was confused by this in the past, assuming that vector_copy is not a constructor.
I think it would be nice to make naming more consistent for 1.0, or at least consider it ... all data structure constructors (except for graphs) could have init in the name. I wonder what others think.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1788#issuecomment-836561387,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","A final comment @GroteGnoom : For a while I wanted to have a function which is just like sbm_game, but asymmetric. This would be completely analogous to igraph_asymmetric_preference_game, but the out- and in-types of each node would be given by the user instead of generated randomly (as igraph_asymmetric_preference_game does).  Do you want to implement this? It's not a big deal really and I would do it at some point myself. I am mentioning it only in case you are interested.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1788#issuecomment-836684737,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","I think it would be nice to make naming more consistent for 1.0, or at least consider it ... all data structure constructors (except for graphs) could have init in the name. I wonder what others think.

That would be great and it's probably worth collecting all sorts of these API-breaking things somewhere that would improve consistency throughout the library so we can break all of them at  the same time (and hopefully never touch them again). Yes, _copy() is a constructor so it would be phrased better as_init_with_copy(). I think _copyto() or _update() are the ones that work on existing vectors, and the only difference between them is the order of arguments (_copyto() works by copying the first arg to the second, _update() updates the first from the second).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1788#issuecomment-836692492,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1788,2021-05-10T09:32:30Z,2021-05-10T13:21:41Z,2021-05-11T06:58:25Z,MERGED,True,214,16,4,https://github.com/GroteGnoom,Add igraph_sbm_game unit tests,2,[],https://github.com/igraph/igraph/pull/1788,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1788#issuecomment-837950709,"Part of #1592
The output graph should be uninitialized, which is unusual, but not
necessarily wrong, and changing it would change the interface.","A final comment @GroteGnoom : For a while I wanted to have a function which is just like sbm_game, but asymmetric. This would be completely analogous to igraph_asymmetric_preference_game, but the out- and in-types of each node would be given by the user instead of generated randomly (as igraph_asymmetric_preference_game does). Do you want to implement this? It's not a big deal really and I would do it at some point myself. I am mentioning it only in case you are interested.

We can just add it as an issue for now, and maybe I'll look into it later 🙂",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1790,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1790#issuecomment-836806144,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","Codecov Report

Merging #1790 (6bbd678) into master (2932eb7) will increase coverage by 0.03%.
The diff coverage is 75.00%.


@@            Coverage Diff             @@
##           master    #1790      +/-   ##
==========================================
+ Coverage   72.21%   72.24%   +0.03%     
==========================================
  Files         295      295              
  Lines       57590    57586       -4     
==========================================
+ Hits        41587    41604      +17     
+ Misses      16003    15982      -21     



Impacted Files
Coverage Δ





src/properties/triangles.c
91.93% <50.00%> (+3.07%)
⬆️


src/properties/triangles_template.h
96.49% <100.00%> (+0.06%)
⬆️


src/properties/triangles_template1.h
97.50% <0.00%> (+22.50%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 2932eb7...6bbd678. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1790#issuecomment-836857365,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","I expanded the benchmarks, but something is strange. Notice how computing the average local transitivity is much slower than computing it individually for each vertex.
|> Benchmark file: ../tests/benchmarks/igraph_transitivity.c
|  1 Local transitivity, all vertices method, GNM                                  0.834s  0.824s  0.009s
|  2 Local transitivity, subset method, GNM                                         6.98s   6.96s  0.014s
|  3 Average local transitivity GNM                                                 4.75s   4.73s  0.011s
|  4 Global transitivity GNM                                                        2.16s   2.15s  0.005s

|  5 Local transitivity, all vertices method, Barabasi                              1.57s   1.56s  0.003s
|  6 Local transitivity, subset method, Barabasi                                    3.13s   3.12s  0.004s
|  7 Average local transitivity, Barabasi                                           2.54s   2.53s  0.003s
|  8 Global transitivity, Barabasi                                                  2.94s   2.93s  0.005s

|  9 Local transitivity, all vertices method, small GNM                             0.18s   0.18s      0s
| 10 Local transitivity, subset method, small GNM                                  0.314s  0.313s      0s
| 11 Average local transitivity, small GNM                                         0.212s  0.212s      0s
| 12 Global transitivity, small GNM                                                 0.17s   0.17s      0s

| 13 Local transitivity, all vertices method, tiny GNM                             0.159s  0.158s      0s
| 14 Local transitivity, subset method, tiny GNM                                   0.323s  0.322s      0s
| 15 Average local transitivity, tiny GNM                                           0.19s  0.189s      0s
| 16 Global transitivity, tiny GNM                                                 0.147s  0.147s      0s",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1790#issuecomment-836955919,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","If I disable ordering vertices by degree in the average local transitivity and the global transitivity calculation, simply by constructing order using vector_init_seq, then I get:
|> Benchmark file: ../tests/benchmarks/igraph_transitivity.c
|  1 Local transitivity, all vertices method, GNM                                  0.889s  0.878s   0.01s
|  2 Local transitivity, subset method, GNM                                         6.77s   6.75s  0.011s
|  3 Average local transitivity GNM                                                  1.9s   1.89s  0.005s
|  4 Global transitivity GNM                                                        2.31s   2.29s   0.01s

|  5 Local transitivity, all vertices method, Barabasi                              1.64s   1.63s  0.003s
|  6 Local transitivity, subset method, Barabasi                                    2.91s    2.9s  0.005s
|  7 Average local transitivity, Barabasi                                           3.01s      3s  0.004s
|  8 Global transitivity, Barabasi                                                  4.07s   4.06s  0.005s

|  9 Local transitivity, all vertices method, small GNM                            0.174s  0.173s      0s
| 10 Local transitivity, subset method, small GNM                                  0.312s  0.312s      0s
| 11 Average local transitivity, small GNM                                         0.176s  0.175s      0s
| 12 Global transitivity, small GNM                                                0.155s  0.155s      0s

| 13 Local transitivity, all vertices method, tiny GNM                             0.147s  0.147s      0s
| 14 Local transitivity, subset method, tiny GNM                                   0.305s  0.304s      0s
| 15 Average local transitivity, tiny GNM                                          0.153s  0.153s      0s
| 16 Global transitivity, tiny GNM                                                 0.142s  0.142s      0s

The most striking differences are in benchmark 3, where avoiding ordering provided a large speeding, and in benchmarks 7 and 8, where it caused a smaller slowdown. Maybe this is some data locality effect?

Here is a second run with ordering for comparison with the previous post:
|> Benchmark file: ../tests/benchmarks/igraph_transitivity.c
|  1 Local transitivity, all vertices method, GNM                                  0.858s  0.849s  0.007s
|  2 Local transitivity, subset method, GNM                                         6.93s   6.91s   0.01s
|  3 Average local transitivity GNM                                                 4.51s    4.5s  0.008s
|  4 Global transitivity GNM                                                        2.11s    2.1s  0.006s

|  5 Local transitivity, all vertices method, Barabasi                              1.52s   1.51s  0.006s
|  6 Local transitivity, subset method, Barabasi                                    3.07s   3.06s  0.007s
|  7 Average local transitivity, Barabasi                                           2.48s   2.48s  0.004s
|  8 Global transitivity, Barabasi                                                  3.14s   3.12s  0.009s

|  9 Local transitivity, all vertices method, small GNM                            0.179s  0.178s  0.001s
| 10 Local transitivity, subset method, small GNM                                  0.308s  0.307s      0s
| 11 Average local transitivity, small GNM                                           0.2s    0.2s      0s
| 12 Global transitivity, small GNM                                                0.164s  0.164s      0s

| 13 Local transitivity, all vertices method, tiny GNM                             0.147s  0.147s      0s
| 14 Local transitivity, subset method, tiny GNM                                   0.304s  0.303s      0s
| 15 Average local transitivity, tiny GNM                                          0.179s  0.179s      0s
| 16 Global transitivity, tiny GNM                                                 0.143s  0.142s      0s",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1790#issuecomment-838020808,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7",So a hasty conclusion would be that we should replace igraph_transitivity_avglocal_undirected by a call to igraph_transitivity_local_undirected and then calculating the average from the resulting vector? This would make things clearer and faster (if taking the average doesn't take ages).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1790#issuecomment-838109059,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","@ntamas A review is very welcome, but please don't merge yet. I want to understand the performance better first.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1790#issuecomment-845197760,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","So a hasty conclusion would be that we should replace igraph_transitivity_avglocal_undirected by a call to igraph_transitivity_local_undirected and then calculating the average from the resulting vector? This would make things clearer and faster (if taking the average doesn't take ages).

Yes, let's do this for the moment. I recall that in the past I have avoided igraph_transitivity_avglocal_undirected in favour of igraph_transitivity_local_undirected when doing performance-sensitive calculations for my own research.  That is ridiculous.
We can look into improving this after the integer transition.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1790#issuecomment-845810034,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7",I'll change igraph_transitivity_avglocal_undirected() to use igraph_transitivity_local_undirected() behind the scenes. This will come in a separate commit.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1790#issuecomment-845814578,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","I'll change igraph_transitivity_avglocal_undirected() to use igraph_transitivity_local_undirected() behind the scenes. This will come in a separate commit.

Some things to pay attention to:

Do not change the behaviour with the null graph
Correct handling of NaNs based on igraph_transitivity_mode_t mode
Is there any other way we can get a NaN in the result from igraph_transitivity_local_undirected() than through mode?  That should not be the case, so it should be sufficient to ignore NaNs during the averaging.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1790,2021-05-10T14:56:17Z,2021-05-21T09:14:29Z,2021-05-21T09:32:18Z,MERGED,True,544,49,10,https://github.com/szhorvat,Support multigraphs in transitivity calculations,6,[],https://github.com/igraph/igraph/pull/1790,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1790#issuecomment-845820768,"This PR ensures that non-weighted transitivity calculations work consistently. Multi-edges and self-loops are simply ignored.
The source of the problem was that in triangles_template the degree vector and the adjacency list were inconsistent: one ignored self-loops/multi-edges and the other did not.
The original quick-fix was to disallow multigraphs and directed graphs. The problem with directed graphs is that reciprocal edges are effectively parallel edges once directions are ignored, however, we do not have a function to test for such graphs and disallow them selectively. See #907. The original quick-fix did not fully update the documentation, which still claimed that edge directions are ignored.
I need a review on this because:


The affected functions have multiple code paths, apparently used for improved performance. Please double check that I didn't miss any.


triangle_template is used by many functions. Hopefully I didn't break any. The only suspect one is igraph_local_scan_1_ecount. However, local scan statistics were never put in order for multigraphs anyway? See #782


igraph_transitivity_undirected and igraph_transitivity_avglocal_undirected still use inconsistent degree vectors. However, the only use seems to be to process nodes in order of decreasing degree. I do not see how the order makes a difference. Am I missing something? One guess is that it is for performance, but I cannot measure it using benchmark_igraph_transitivity. See https://igraph.discourse.group/t/transitivity-calculation-and-node-ordering/749/2


This work was motivated by: https://igraph.discourse.group/t/local-transitivity-and-barrat-transitivity-for-directed-graph/747/7","Do not change the behaviour with the null graph

I'll add a unit test for that

Correct handling of NaNs based on igraph_transitivity_mode_t mode

I think we can safely forward mode to igraph_transitivity_local_undirected() as is, and ignore NaNs in the result vector when taking the average. This also answers your third point.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1793,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.","Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1793#issuecomment-843972768,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.","Codecov Report

Merging #1793 (986d78c) into master (3a69e7f) will increase coverage by 0.15%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1793      +/-   ##
==========================================
+ Coverage   72.21%   72.36%   +0.15%     
==========================================
  Files         295      295              
  Lines       57590    57591       +1     
==========================================
+ Hits        41587    41677      +90     
+ Misses      16003    15914      -89     



Impacted Files
Coverage Δ





src/properties/triangles_template.h
98.18% <ø> (+1.75%)
⬆️


src/misc/scan.c
23.37% <100.00%> (+23.37%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 3a69e7f...986d78c. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1793#issuecomment-844043272,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.",I will add some tests to improve coverage.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1793#issuecomment-845192747,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.",Would it handle loops incorrectly with the changes in #1790 as well?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1793#issuecomment-845238001,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.","Yes, I think so, but in a different way. Instead of IGRAPH_NO_LOOPS, I'd want a IGRAPH_LOOPS_ONCE, but I think even that wouldn't solve both problems I saw.
Problem 1 was that a loop at the starting vertex was counted twice.
Problem 2 was that a loop at an adjacent vertex was not counted at all.
I will try to test with #1790 anyway, to check.
For this graph, with 6 vertices:
0,1, 0,2, 1,1, 1,3, 2,0, 2,3, 3,4, 3,4

the old version did this:
Same graph with loop, k=1, undirected:
( 3 4 3 4 2 0 )

The #1790 version does this:
Same graph with loop, k=1, undirected:
( 2 2 2 3 1 0 )

This PR does this:
Same graph with loop, k=1, undirected:
( 4 3 3 5 2 0 )

which I think is the only correct option.
The result from #1790 is what you would get if loops and multi-edges are ignored, which is not what the documentation implies. I haven't checked against the original definition from the article mentioned in scan.c, and also don't know what it's used for.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1793#issuecomment-845729204,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.","TRIEDGES is only used by this single function, so it seems safe to completely remove from triangles_template.h as well.
I have never looked a the local scan statistics carefully, and don't have the time to do so now. @GroteGnoom, if you are confident about the change, I suggest we go ahead. @ntamas any comments, have you ever looked into this functionality area?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1793#issuecomment-845742609,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.","I have never looked a the local scan statistics carefully, and don't have the time to do so now. @GroteGnoom, if you are confident about the change, I suggest we go ahead. @ntamas any comments, have you ever looked into this functionality area?

It now does what the documentation says, and the k=1 case is now consistent with the k=2 case, so it also seems to do what was intended when the general case was implemented. So I think it's correct. Else the documentation would be wrong and the k>1 case would accidentally implement this incorrect idea.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1793,2021-05-19T10:30:42Z,2021-05-21T08:08:41Z,2021-05-21T08:08:42Z,MERGED,True,141,20,6,https://github.com/GroteGnoom,Add igraph_local_scan_k_ecount unit tests,2,[],https://github.com/igraph/igraph/pull/1793,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1793#issuecomment-845749694,"Part of #1592
Stopped using the trangles_template with TRIEDGES, because it handled
loops incorrectly. Maybe it was faster for graphs without loops than the
general function which is now used. If that's an important issue we could
benchmark it, and handle k=1 undirected as a special case again.",I have checked the results manually and I think they are logical the way they are now with this PR.  Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1794,"Part of #1592
This just lets the memory checker do all the work.","Part of #1592
This just lets the memory checker do all the work.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1794#issuecomment-844113704,"Part of #1592
This just lets the memory checker do all the work.","Codecov Report

Merging #1794 (c7fe7f5) into master (3a69e7f) will increase coverage by 0.01%.
The diff coverage is n/a.


@@            Coverage Diff             @@
##           master    #1794      +/-   ##
==========================================
+ Coverage   72.21%   72.22%   +0.01%     
==========================================
  Files         295      295              
  Lines       57590    57590              
==========================================
+ Hits        41587    41597      +10     
+ Misses      16003    15993      -10     



Impacted Files
Coverage Δ





src/core/stack.c
100.00% <0.00%> (+100.00%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 3a69e7f...c7fe7f5. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1794#issuecomment-844165174,"Part of #1592
This just lets the memory checker do all the work.","I would wait with this a bit, as the whole item destructor implementation is a bit of a mess. It'd take a while to write up how I wanted to go forward with it, and unfortunately I can't do it right now, so I ask for a bit of time.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/apps/stale,4,https://github.com/igraph/igraph/pull/1794#issuecomment-882134156,"Part of #1592
This just lets the memory checker do all the work.",This issue has been automatically marked as stale because it has not had recent activity. It will be closed in 14 days if no further activity occurs. Thank you for your contributions.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1794#issuecomment-1026633756,"Part of #1592
This just lets the memory checker do all the work.","@GroteGnoom @ntamas @vtraag What do we do with these functions, and with igraph_stack_ptr_t in general? It seems to me that igraph_stack_ptr_t is not used anywhere at the moment. I suggest completely removing support for this type.
It seems to me that more generally, stack_t objects don't do anything different than vector_t objects, they just happen to have a name that communicates intent better. Thus, should we ever need something like a stack_ptr_t, we can use a vector_ptr_t or a vector_list_t instead.

We should also re-examine the non-ptr version of stacks (such as igraph_stack_t, igraph_stack_int_t, etc.). Technically, these can be removed as well.
Arguments for keeping them:

Personally, I find value in the naming of these types. If they are called ""stack"", then it is clear that they are used for.
If we keep stacks and vectors separate, we keep the door open for optimizing stacks for their specific use case in the future.

Arguments for removing them, or for aliasing them to vectors:

Currently, the stack_t implementation duplicates the vector_t implementation. vector_t has received a number of fixes recently, ranging from overflow-protection to making sure that reserve never shrinks the capacity. Now these fixes have to be ported over to stacks, which is extra work. If stacks and vectors shared implementation, this would not be a problem anymore.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1794#issuecomment-1026637965,"Part of #1592
This just lets the memory checker do all the work.","Personally, I would do this:

Remove igraph_stack_ptr_t completely.
Keep igraph_stack_t and make the necessary fixes. There are not that many of them. While aliasing stacks to vectors would make some things easier, it prevents us from optimizing each to a specific use case without breaking ABI.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1794#issuecomment-1026810832,"Part of #1592
This just lets the memory checker do all the work.","Agreed. igraph_stack_ptr_t is not needed at the moment. For the remaining stack types, let's keep the implementation and port the fixes over from the vector type.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1794#issuecomment-1027047731,"Part of #1592
This just lets the memory checker do all the work.","Fixes have now been ported to stack.pmt.
I have not yet removed stack_ptr_t, waiting for feedback from others as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1794#issuecomment-1027138485,"Part of #1592
This just lets the memory checker do all the work.","I would remove igraph_stack_t (after deprecation maybe?) It's not used at all, right? I don't like keeping things around just in case it would make sense to have it in the future, especially if it's just a vector.
Ah, I see, igraph_stack_int_t is used. And there's an extra function igraph_stack_top, which is actually used? All right.
I'd still just let it be an actual vector for maintainability. If we need to make changes to it in the future, then we'll do it then, and copy what's needed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1794#issuecomment-1027160892,"Part of #1592
This just lets the memory checker do all the work.","I removed igraph_stack_ptr_t now. It was not used anywhere.
igraph_stack_t (with all typed versions) is still there, and updated to match vector_t. I added igraph_stack_capacity() to make it easier to mirror igraph_vector_t's implementations.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1794,2021-05-19T13:33:15Z,2022-02-01T18:34:34Z,2022-02-01T18:34:34Z,CLOSED,False,34,0,2,https://github.com/GroteGnoom,Add stack_ptr_destroy_all unit tests,1,['todo'],https://github.com/igraph/igraph/pull/1794,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1794#issuecomment-1027161361,"Part of #1592
This just lets the memory checker do all the work.",Closing this PR then (we can continue the discussion though).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1798,2021-06-01T17:40:49Z,2021-06-03T13:03:38Z,2021-06-03T13:15:22Z,MERGED,True,24,1,2,https://github.com/GroteGnoom,fix: build 32-bits CXSparse properly,1,[],https://github.com/igraph/igraph/pull/1798,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1798,"I know very little about CXParse, so I just checked what was needed to pass the tests, and if there were any other cs_dl's present in sparsemat.c. I'm also not sure about the right place for every macro.","I know very little about CXParse, so I just checked what was needed to pass the tests, and if there were any other cs_dl's present in sparsemat.c. I'm also not sure about the right place for every macro.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1798,2021-06-01T17:40:49Z,2021-06-03T13:03:38Z,2021-06-03T13:15:22Z,MERGED,True,24,1,2,https://github.com/GroteGnoom,fix: build 32-bits CXSparse properly,1,[],https://github.com/igraph/igraph/pull/1798,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1798#issuecomment-852323277,"I know very little about CXParse, so I just checked what was needed to pass the tests, and if there were any other cs_dl's present in sparsemat.c. I'm also not sure about the right place for every macro.","Codecov Report

Merging #1798 (aa7f60b) into feature/int-size-64-bit (70e1abd) will not change coverage.
The diff coverage is n/a.


@@                   Coverage Diff                    @@
##           feature/int-size-64-bit    #1798   +/-   ##
========================================================
  Coverage                    72.50%   72.50%           
========================================================
  Files                          292      292           
  Lines                        57328    57328           
========================================================
  Hits                         41564    41564           
  Misses                       15764    15764           



Impacted Files
Coverage Δ





src/core/sparsemat.c
81.20% <ø> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 70e1abd...aa7f60b. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1798,2021-06-01T17:40:49Z,2021-06-03T13:03:38Z,2021-06-03T13:15:22Z,MERGED,True,24,1,2,https://github.com/GroteGnoom,fix: build 32-bits CXSparse properly,1,[],https://github.com/igraph/igraph/pull/1798,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1798#issuecomment-852927674,"I know very little about CXParse, so I just checked what was needed to pass the tests, and if there were any other cs_dl's present in sparsemat.c. I'm also not sure about the right place for every macro.","My preference in dealing with CXSparse would be to:

Bundle a modified CXSparse with igraph (this is not a lot of work at all)
Always use the dl API and define cs_long_t to be igraph_integer_t. This modification of cs_long_t would be the only thing changed in CXSparse, thus updates to new versions would be easy. This can either be done to cs_long_t directly, or to SuiteSparse_long in SuiteSparse_config.h. I vote for the latter, as this will make it possible to keep the CXSparse files 100% unmodified compared to upstream. Only the SuiteSparse configuration would be modified.

But I have not been able to follow the int64 transition closely enough in the past couple of weeks, so I may have missed something.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1798,2021-06-01T17:40:49Z,2021-06-03T13:03:38Z,2021-06-03T13:15:22Z,MERGED,True,24,1,2,https://github.com/GroteGnoom,fix: build 32-bits CXSparse properly,1,[],https://github.com/igraph/igraph/pull/1798,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1798#issuecomment-853851512,"I know very little about CXParse, so I just checked what was needed to pass the tests, and if there were any other cs_dl's present in sparsemat.c. I'm also not sure about the right place for every macro.",I'll merge this and use this as a starting point for further development along the plan outlined by @szhorvat,True,{}
igraph/igraph,https://github.com/igraph/igraph,1799,2021-06-05T11:09:18Z,2021-06-07T09:28:54Z,2021-06-07T09:28:54Z,MERGED,True,69,57,2,https://github.com/GroteGnoom,refactor: spmatrix -> sparsemat for community_misc,1,[],https://github.com/igraph/igraph/pull/1799,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1799,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1801,2021-06-25T09:04:11Z,2021-06-27T17:11:13Z,2021-06-27T17:11:13Z,MERGED,True,708,679,50,https://github.com/GroteGnoom,Change community membership and csize to int vecs,2,[],https://github.com/igraph/igraph/pull/1801,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1801,"I was working on changing long ints in flow to igraph_integer_t when i noticed some casts which seemed unnecessary. They were caused by membership and community size vectors using doubles instead of integers. So I changed them to integer vectors.
I didn't check all of the documentation, or the interface with R, but I wanted to see if people agree with the general plan. If so, I will continue working on this and fix the errors.","I was working on changing long ints in flow to igraph_integer_t when i noticed some casts which seemed unnecessary. They were caused by membership and community size vectors using doubles instead of integers. So I changed them to integer vectors.
I didn't check all of the documentation, or the interface with R, but I wanted to see if people agree with the general plan. If so, I will continue working on this and fix the errors.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1801,2021-06-25T09:04:11Z,2021-06-27T17:11:13Z,2021-06-27T17:11:13Z,MERGED,True,708,679,50,https://github.com/GroteGnoom,Change community membership and csize to int vecs,2,[],https://github.com/igraph/igraph/pull/1801,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1801#issuecomment-868353971,"I was working on changing long ints in flow to igraph_integer_t when i noticed some casts which seemed unnecessary. They were caused by membership and community size vectors using doubles instead of integers. So I changed them to integer vectors.
I didn't check all of the documentation, or the interface with R, but I wanted to see if people agree with the general plan. If so, I will continue working on this and fix the errors.","Codecov Report

Merging #1801 (20db924) into feature/int-size-64-bit (4adb720) will decrease coverage by 0.00%.
The diff coverage is 87.71%.


@@                     Coverage Diff                     @@
##           feature/int-size-64-bit    #1801      +/-   ##
===========================================================
- Coverage                    73.20%   73.19%   -0.01%     
===========================================================
  Files                          337      337              
  Lines                        57624    57622       -2     
===========================================================
- Hits                         42181    42179       -2     
  Misses                       15443    15443              



Impacted Files
Coverage Δ





src/community/edge_betweenness.c
59.51% <0.00%> (ø)



src/community/fast_modularity.c
92.07% <ø> (ø)



src/community/spinglass/clustertool.cpp
63.12% <0.00%> (ø)



src/community/spinglass/pottsmodel_2.h
100.00% <ø> (ø)



src/community/walktrap/walktrap.cpp
82.60% <ø> (ø)



src/community/optimal_modularity.c
85.84% <20.00%> (ø)



src/connectivity/components.c
94.20% <77.77%> (ø)



src/community/leading_eigenvector.c
82.68% <78.57%> (ø)



src/paths/eulerian.c
96.87% <87.50%> (ø)



src/community/community_misc.c
91.69% <89.47%> (ø)



... and 18 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4adb720...20db924. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1801,2021-06-25T09:04:11Z,2021-06-27T17:11:13Z,2021-06-27T17:11:13Z,MERGED,True,708,679,50,https://github.com/GroteGnoom,Change community membership and csize to int vecs,2,[],https://github.com/igraph/igraph/pull/1801,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1801#issuecomment-868422738,"I was working on changing long ints in flow to igraph_integer_t when i noticed some casts which seemed unnecessary. They were caused by membership and community size vectors using doubles instead of integers. So I changed them to integer vectors.
I didn't check all of the documentation, or the interface with R, but I wanted to see if people agree with the general plan. If so, I will continue working on this and fix the errors.","VECTOR_INT_OR_0 does not seem to exist in interfaces. Should I create it in interfaces/shell/types.def? The R interface is not my strong suit.
I'm trying to convert from VECTOR_OR_0.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1801,2021-06-25T09:04:11Z,2021-06-27T17:11:13Z,2021-06-27T17:11:13Z,MERGED,True,708,679,50,https://github.com/GroteGnoom,Change community membership and csize to int vecs,2,[],https://github.com/igraph/igraph/pull/1801,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1801#issuecomment-868728671,"I was working on changing long ints in flow to igraph_integer_t when i noticed some casts which seemed unnecessary. They were caused by membership and community size vectors using doubles instead of integers. So I changed them to integer vectors.
I didn't check all of the documentation, or the interface with R, but I wanted to see if people agree with the general plan. If so, I will continue working on this and fix the errors.","VECTOR_INT_OR_0 does not seem to exist in interfaces. Should I create it in interfaces/shell/types.def?

No, just start using VECTOR_INT_OR_0 in interfaces/functions.def.
To put things in context:

interfaces/functions.def is a sort-of-machine-readable specification of the types of arguments that igraph functions accept, with suggested default values. Right now it is only used by the R interface to generate parts of the glue code between igraph and R. Its syntax is quite ad-hoc; it is meant to be parsed with tools/stimulus.py, which then generates code for the R interface.
interfaces/shell is sort-of-defunct; it used to be an experiment to provide some kind of a command-line interface to igraph. I'm keeping it around because it could be a useful testbed if we ever decide to resurrect the code generation approach.

In fact, there are plans to update the Python interface in the future so that we could generate most of its code using either tools/stimulus.py, or pybind11, or SWIG, or Cython. At some point (if we obtain funding for it), we will need to evaluate which of these solutions would be best for the Python interface. Until then I don't think we should put too much effort in maintaining interfaces/functions.def -- I think it's out-of-sync with parts of the library already, and we would know it soon enough once we start working with it.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1801,2021-06-25T09:04:11Z,2021-06-27T17:11:13Z,2021-06-27T17:11:13Z,MERGED,True,708,679,50,https://github.com/GroteGnoom,Change community membership and csize to int vecs,2,[],https://github.com/igraph/igraph/pull/1801,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1801#issuecomment-869049840,"I was working on changing long ints in flow to igraph_integer_t when i noticed some casts which seemed unnecessary. They were caused by membership and community size vectors using doubles instead of integers. So I changed them to integer vectors.
I didn't check all of the documentation, or the interface with R, but I wanted to see if people agree with the general plan. If so, I will continue working on this and fix the errors.","For a brief introduction to Stimulus, see https://github.com/igraph/igraph/wiki/Code-generation-using-Stimulus. That document should still be finished and expanded, I hadn't yet gotten around to do that.

just start using VECTOR_INT_OR_0 in interfaces/functions.def.

Yep, that would be easiest. It would mean that we would have to implement that type in the R interface, but we'll have to do that when we come to that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1802,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.","I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1802#issuecomment-873434072,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.","I'm working on this now, FYI.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1802#issuecomment-873446972,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.",Fixed a few test failures; 20/46 files reviewed. I'll take a break now and maybe return to this PR in a few hours.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1802#issuecomment-873473167,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.","35/46 files reviewed and the tests should be fixed by now. It's probably worth going through the changed files again to see if there are any places where we could get rid of the copying of the degrees from an igraph_vector_int_t to an igraph_vector_t; most of the time the same thing could be achieved with just calling igraph_strength() with a null weight vector (I just came to realize this today). That's all for me today, feel free to pick it up later. I'll ping if I start working on it again.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/apps/codecov,5,https://github.com/igraph/igraph/pull/1802#issuecomment-873474114,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.","Codecov Report

Merging #1802 (f6fc757) into feature/int-size-64-bit (cc4cfdf) will increase coverage by 0.02%.
The diff coverage is 89.18%.


@@                     Coverage Diff                     @@
##           feature/int-size-64-bit    #1802      +/-   ##
===========================================================
+ Coverage                    73.19%   73.22%   +0.02%     
===========================================================
  Files                          337      337              
  Lines                        57643    57715      +72     
===========================================================
+ Hits                         42193    42261      +68     
- Misses                       15450    15454       +4     



Impacted Files
Coverage Δ





src/hrg/hrg.cc
59.70% <0.00%> (ø)



src/layout/gem.c
0.00% <0.00%> (ø)



src/properties/constraint.c
0.00% <0.00%> (ø)



src/misc/scan.c
24.24% <38.88%> (+0.86%)
⬆️


src/games/barabasi.c
80.20% <60.00%> (ø)



src/centrality/centrality_other.c
51.29% <73.33%> (+0.59%)
⬆️


src/flow/flow.c
87.61% <80.00%> (ø)



src/properties/degrees.c
87.09% <96.15%> (+0.50%)
⬆️


src/centrality/centralization.c
91.26% <100.00%> (ø)



src/centrality/coreness.c
89.39% <100.00%> (-0.75%)
⬇️


... and 19 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update cc4cfdf...f6fc757. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1802#issuecomment-873552767,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.",I'll work again on this a bit now.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1802,2021-07-03T09:17:58Z,2021-07-04T10:44:36Z,2021-07-04T10:44:52Z,MERGED,True,577,458,46,https://github.com/GroteGnoom,refactor: working to use integers for degrees,22,[],https://github.com/igraph/igraph/pull/1802,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1802#issuecomment-873563678,"I did some crude changes to try to make everything work. Mostly copying vectors from one type to another. Tests are compiling but failing. I'll stop working on this for today, so please feel free to edit, but comment first if you're starting so we won't interfere with each other.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1804,2021-07-20T08:09:11Z,2021-07-20T08:48:24Z,2021-07-20T08:48:33Z,MERGED,True,46,34,2,https://github.com/GroteGnoom,refactor: use enums for iterator types,2,[],https://github.com/igraph/igraph/pull/1804,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1804,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1804,2021-07-20T08:09:11Z,2021-07-20T08:48:24Z,2021-07-20T08:48:33Z,MERGED,True,46,34,2,https://github.com/GroteGnoom,refactor: use enums for iterator types,2,[],https://github.com/igraph/igraph/pull/1804,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1804#issuecomment-883193866,,"Codecov Report

Merging #1804 (4af7703) into feature/int-size-64-bit (8f87753) will decrease coverage by 0.00%.
The diff coverage is 33.33%.


@@                     Coverage Diff                     @@
##           feature/int-size-64-bit    #1804      +/-   ##
===========================================================
- Coverage                    73.23%   73.22%   -0.01%     
===========================================================
  Files                          337      337              
  Lines                        57764    57768       +4     
===========================================================
  Hits                         42303    42303              
- Misses                       15461    15465       +4     



Impacted Files
Coverage Δ





src/graph/iterators.c
75.67% <33.33%> (-0.41%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8f87753...4af7703. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1804,2021-07-20T08:09:11Z,2021-07-20T08:48:24Z,2021-07-20T08:48:33Z,MERGED,True,46,34,2,https://github.com/GroteGnoom,refactor: use enums for iterator types,2,[],https://github.com/igraph/igraph/pull/1804,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1804#issuecomment-883217977,,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,1,https://github.com/igraph/igraph/pull/1809,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1809#issuecomment-904436870,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Codecov Report

Merging #1809 (0c369ef) into develop (941fb96) will increase coverage by 0.22%.
The diff coverage is 90.90%.


❗ Current head 0c369ef differs from pull request most recent head f95a0c1. Consider uploading reports for the commit f95a0c1 to get more accurate results


@@             Coverage Diff             @@
##           develop    #1809      +/-   ##
===========================================
+ Coverage    72.15%   72.38%   +0.22%     
===========================================
  Files          342      295      -47     
  Lines        58596    57545    -1051     
===========================================
- Hits         42281    41653     -628     
+ Misses       16315    15892     -423     



Impacted Files
Coverage Δ





src/constructors/famous.c
68.00% <0.00%> (-2.67%)
⬇️


src/properties/triangles.c
91.04% <90.62%> (+2.18%)
⬆️


src/misc/scan.c
23.37% <100.00%> (+23.37%)
⬆️


src/properties/triangles_template.h
98.21% <100.00%> (+1.78%)
⬆️


src/core/strvector.c
75.00% <0.00%> (-4.69%)
⬇️


src/operators/complementer.c
96.66% <0.00%> (-3.34%)
⬇️


src/core/vector_ptr.c
85.88% <0.00%> (-2.27%)
⬇️


src/misc/bipartite.c
72.45% <0.00%> (-2.03%)
⬇️


src/graph/visitors.c
83.87% <0.00%> (-1.38%)
⬇️


... and 112 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 59fb22b...f95a0c1. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1809#issuecomment-904453067,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","I won't have time to look at this for at least a couple of weeks (moving house and other things), so I'll just add a few notes:

At this point, you should start basing the PR on the develop branch. We made several breaking changes on the develop branch, mainly having to do with consistently using igraph_integer_t instead of igraph_real_t for all indices and igraph_error_t instead of int for error codes.
Add the new file to the build system so that it can start to be tested by CI. Take a look at this wiki page if you have not yet seen it: https://github.com/igraph/igraph/wiki/Contributing-your-first-function-to-igraph Basically, you need to add it to src/CMakeLists.txt. Then make sure the build completes.
First make sure your code builds correctly (even if it doesn't work correctly). Hint: As it currently stands, it won't build because you used the .c extension for C++ code. Use .cpp.
You may want to add a skeleton test soon. See the wiki again.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1809#issuecomment-914924014,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Don't forget to add the new files to the build system, so that the CI tests can run!
I'm travelling for a while, and could take a first look next week.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1809#issuecomment-918168471,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Can you please add the new files to the build system (the CMakeLists.txt file), just to see if everything compiles as is?
The first step would be to make sure the code compiles. Second, write basic tests and make sure they pass. We can worry about memory management later.
The reason for the test failures (even without adding the new code) is that the function prototypes added to the headers lack semicolons.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,6,https://github.com/igraph/igraph/pull/1809#issuecomment-918175710,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","function prototypes

Thanks for pointing in correct direction.
Can you please add the new files to the build system (the CMakeLists.txt file), just to see if everything compiles as is?
-- I will do this today
The first step would be to make sure the code compiles. Second, write basic tests and make sure they pass. We can worry about memory management later.
-- Sure.
The reason for the test failures (even without adding the new code) is that the function prototypes added to the headers lack semicolons.
-- I corrected that part",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1809#issuecomment-918546924,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Very good. The next step, before any other changes, is to make sure that the code compiles.
The first problem is what I mentioned earlier: a file containing C++ code has the .c extension. It should be .cpp.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1809#issuecomment-919822907,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Here's my suggestion for going forward with this PR:
The key is to go in small steps, and ask questions often, so we can follow what you are doing, and avoid spending too much time in an unproductive side alley.
Let us make the first goal just to get the Floyd-Warshall implementation right, and break it down like this:

Ensure that the code compiles. Obviously, one can't test code that doesn't compile, so we can't work on it. Given that you already have a lot of code written, I am wondering if you compiled it in a different manner (separately from igraph's build system) on your computer, so you could test it? If so, avoid working on two parallel versions of the project: let's make sure it compiles within igraph's build system.
Write a small test program, and make sure that your function produces the expected result. This will be easy since igraph already contains other shortest path algorithms that you can compare to.
At this point, ask us to have a look at the code, and we will agree on next steps. These next steps will include making sure that the code plays well with the rest of igraph, does memory management correctly, handles edge cases, etc. We will look at this list as well.

In short:
First do just the Floyd-Warshall (leave the Steiner tree for later). It will be the vehicle to help you get comfortable with igraph. It is important that you should ask for feedback (and have a discussion with someone on the igraph team) as soon as it is producing the correct result, even before the code is perfect. It will be helpful if you also include a list of necessary improvements (e.g. ""memory management needs to be finalized"") before having this discussion, but let's talk as soon as the function is working and you have a test program to verify that it produces the correct results.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,9,https://github.com/igraph/igraph/pull/1809#issuecomment-920143614,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Here's my suggestion for going forward with this PR:
The key is to go in small steps, and ask questions often, so we can follow what you are doing, and avoid spending too much time in an unproductive side alley.
Let us make the first goal just to get the Floyd-Warshall implementation right, and break it down like this:

Ensure that the code compiles. Obviously, one can't test code that doesn't compile, so we can't work on it. Given that you already have a lot of code written, I am wondering if you compiled it in a different manner (separately from igraph's build system) on your computer, so you could test it? If so, avoid working on two parallel versions of the project: let's make sure it compiles within igraph's build system.
Write a small test program, and make sure that your function produces the expected result. This will be easy since igraph already contains other shortest path algorithms that you can compare to.
At this point, ask us to have a look at the code, and we will agree on next steps. These next steps will include making sure that the code plays well with the rest of igraph, does memory management correctly, handles edge cases, etc. We will look at this list as well.

In short:
First do just the Floyd-Warshall (leave the Steiner tree for later). It will be the vehicle to help you get comfortable with igraph. It is important that you should ask for feedback (and have a discussion with someone on the igraph team) as soon as it is producing the correct result, even before the code is perfect. It will be helpful if you also include a list of necessary improvements (e.g. ""memory management needs to be finalized"") before having this discussion, but let's talk as soon as the function is working and you have a test program to verify that it produces the correct results.

Thanks for this and I will follow this to the t. I will start discussion with my collaborator Yash and start working on test cases for Floyd-Warshall algorithm today itself.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1809#issuecomment-924056918,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Unit tests should be added to tests/unit instead of examples/simple; also consider validating the results in the test instead of simply printing them to stdout. The IGRAPH_ASSERT() macro is the preferred way of doing this. test_utilities.inc contains handy helper functions that are typically used in unit tests; take a look at, e.g., tests/unit/vector.c for an example.
If you print stuff to stdout during the test, you should also provide an expected output next to your test in a file whose name is identical to the test, except its extension, which should be .out. Also, add your unit test to the appropriate part of tests/CMakeLists.txt so it gets executed as part of the normal igraph test cycle.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,11,https://github.com/igraph/igraph/pull/1809#issuecomment-951215951,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","In tests/ unit we have placed a file named ""igraph_all_pairs_shortest_path.c"". But when compiling the project, the .out file corresponding to this is not getting generated.
Could you help us with the appropriate process for testing? We incorporated the suggestions in your previous comment. PS. I have not pushed the changes as .out file was not getting generated.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1809#issuecomment-951244516,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","There is a wiki page about writing unit tests: https://github.com/igraph/igraph/wiki/How-to-write-unit-tests%3F  Let me know if you have any questions about the material within the wiki.
Generally, tests are complete C programs (with main()). During testing, they are compiled and run. If the exit code is not 0, the test is considered to have failed.
Optionally, there may be an .out file that you must provide yourself. If this file exists, the output of the test program is compared to it. If there is a difference, the test is considered to have failed.
In short:  The .out file is not generated. It must be provided by you. The output of the test program must match the .out file.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1809#issuecomment-962449811,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Since you already put quite a bit of work into this, it would be great to see it finished! 🙂",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,14,https://github.com/igraph/igraph/pull/1809#issuecomment-962528197,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302",Yes. I'm trying to connect with my collaborator and get things moving. I'm also interested in this project and want tom to implement the approximation algorithm as well. I have scheduled a few hours for tomorrow and will try to get an update by mid-next week.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1809#issuecomment-987657381,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","If you feel overwhelmed by some of the technical peculiarities of igraph, consider just contributing the all-pairs shortest path function you already have in here. You can do that in a separate PR. This will let you familiarize with the process a contribution without having to also focus on a complicated algorithm. Once that is done, you can come back to the Steiner tree.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,16,https://github.com/igraph/igraph/pull/1809#issuecomment-989445979,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","@szhorvat Thanks for the suggestion and yes, although we progressed with creating .out files testing in igraph is causing little issue for us. So the semester finals are this week and would end next Wednesday, Post that in winter break we have decided to provide dedicated time for this project to complete. I will keep you updated on weekly basis in winter break on the progress of the work.
Sorry to keep you and other maintainers waiting for this pull request.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,17,https://github.com/igraph/igraph/pull/1809#issuecomment-1004755581,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Here are the few updates -

There was some unexpected delay with my collaborator so I decided to use the Johnson's algorithm for all pairs shortest path instead of Floyd-warshall implementation to speed up the process.
I was able to resolve several compiler time issues for steiner.cpp code but one major issue remains. The issue is appearing in in the function fetchIndexofMapofSets where were are trying to iterate over a map <igraph_vector_t , int > variable and compare the key with one coming as input the get it's value which is integer. (This is necessary because we are creating subsets of vertices and capturing the distance value in dynamic programming table. So the subsets are mapped to an integer and stored in the dynamic programming table). I would need thoughts about how to handle this issue. Should I implement the comparison feature for <igraph_vector_t , int > or any other better approach is to be followed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1809#issuecomment-1006493359,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Do your subsets ever overlap with each other? If not, you can use the suggestion here:
#1803 (comment)
Otherwise, it might be simplest to use an std::vector for the internals of this function.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1809#issuecomment-1006495587,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","At this point, I very strongly suggest that you rebase the PR onto the develop branch, or for simplicity, start a new PR where you manually move over the changes to a branch based on develop. A lot of changes have happened since this PR was proposed. The develop branch now consistently uses integers for vertex and edge IDs, as well as for all kinds of indexing. We no longer use long int. Instead, all integers are consistently igraph_integer_t, which may be 32- or 64-bit depending on the platform and configuration.
Since this PR won't be merged into master, and will need to be ported to develop anyway, it's better to start doing that now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,20,https://github.com/igraph/igraph/pull/1809#issuecomment-1017720727,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302",Thanks. The subsets are overlapping so I used std::set for subsets and rectified all the compile time errors and added a test case for the function that was developed.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1809#issuecomment-1017976532,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","@Nachiket18 Can you please merge the latest develop branch into this branch, and resolve all merge conflicts?
@ntamas Do you see a reason for why CI is not running for this PR?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/ntamas,22,https://github.com/igraph/igraph/pull/1809#issuecomment-1018031847,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302",Idk; let's try to resolve the conflicts and see if that changes things.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1809#issuecomment-1018409897,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","It might be easier for @Nachiket18 to create a new PR which branches off directly from develop, and manually transfer the changes that are present here. It would be great to finish this, since a lot of work went into it already.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1809,2021-08-24T07:35:25Z,2022-01-22T08:10:20Z,2022-01-22T08:10:20Z,CLOSED,False,693,0,9,https://github.com/Nachiket18,Steiner Tree calculation,19,[],https://github.com/igraph/igraph/pull/1809,https://github.com/Nachiket18,24,https://github.com/igraph/igraph/pull/1809#issuecomment-1019077718,"The functionality that is being developed is calculating the steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302",@szhorvat Thanks. I have created a new PR  #1939 based on develop branch. Should I close this PR with comments?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1811,2021-09-14T08:57:16Z,2021-09-14T10:10:58Z,2021-09-14T14:17:42Z,MERGED,True,44,9,4,https://github.com/GroteGnoom,Let rewire_directed_edges generate multi-edges for undirected graphs,2,[],https://github.com/igraph/igraph/pull/1811,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1811,Fixes #1527,Fixes #1527,True,{}
igraph/igraph,https://github.com/igraph/igraph,1811,2021-09-14T08:57:16Z,2021-09-14T10:10:58Z,2021-09-14T14:17:42Z,MERGED,True,44,9,4,https://github.com/GroteGnoom,Let rewire_directed_edges generate multi-edges for undirected graphs,2,[],https://github.com/igraph/igraph/pull/1811,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1811#issuecomment-918954157,Fixes #1527,"Codecov Report

Merging #1811 (394c8fd) into develop (6f154c7) will not change coverage.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #1811   +/-   ##
========================================
  Coverage    73.25%   73.25%           
========================================
  Files          337      337           
  Lines        57705    57705           
========================================
  Hits         42269    42269           
  Misses       15436    15436           



Impacted Files
Coverage Δ





src/operators/rewire_edges.c
94.26% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 6f154c7...394c8fd. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1811,2021-09-14T08:57:16Z,2021-09-14T10:10:58Z,2021-09-14T14:17:42Z,MERGED,True,44,9,4,https://github.com/GroteGnoom,Let rewire_directed_edges generate multi-edges for undirected graphs,2,[],https://github.com/igraph/igraph/pull/1811,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1811#issuecomment-919010732,Fixes #1527,"This is great, thanks! The only problem is that it is based on develop and we want to get it into 0.9.5 so it should be based on master. Rebasing (as above) didn't work so I'll just squash & merge it into develop and then cherry-pick the commit back to master.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1811,2021-09-14T08:57:16Z,2021-09-14T10:10:58Z,2021-09-14T14:17:42Z,MERGED,True,44,9,4,https://github.com/GroteGnoom,Let rewire_directed_edges generate multi-edges for undirected graphs,2,[],https://github.com/igraph/igraph/pull/1811,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1811#issuecomment-919191583,Fixes #1527,I would not mess with this in 0.9.5.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1811,2021-09-14T08:57:16Z,2021-09-14T10:10:58Z,2021-09-14T14:17:42Z,MERGED,True,44,9,4,https://github.com/GroteGnoom,Let rewire_directed_edges generate multi-edges for undirected graphs,2,[],https://github.com/igraph/igraph/pull/1811,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1811#issuecomment-919194176,Fixes #1527,Why not? It seems like a bugfix to me.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1811,2021-09-14T08:57:16Z,2021-09-14T10:10:58Z,2021-09-14T14:17:42Z,MERGED,True,44,9,4,https://github.com/GroteGnoom,Let rewire_directed_edges generate multi-edges for undirected graphs,2,[],https://github.com/igraph/igraph/pull/1811,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1811#issuecomment-919195922,Fixes #1527,"OK, I looked at it, and it's fine as it is.
The real solution is not to allow multi-edges for the undirected case, but to make it possible (through an option) to disallow multi-edges in the directed case. That is something to tackle later, probably for post-0.10 (0.11 or 1.0).",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1813,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1813#issuecomment-924899513,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","A comment and some questions on:


igraph_hub_and_authority_scores() calculates the hub and authority scores of a graph as a matching pair.


Is this achieved with the following line?
igraph_vector_fill(vector, 1.0 / no_of_nodes);


In most cases, ARPACK appears to return eigenvectors which are normalized so that their Euclidean norm is 1. A vector consisting of 1.0 / no_of_nodes is not normalized this way. For that we need 1.0 / sqrt(no_of_nodes).
However, I believe (have to check!) that ARPACK does not guarantee returning normalized results. Therefore, igraph should not guaratee this either. The hub and authority scores functions have the scale feature, which is a kind of normalization: it normalizes so that the largest value is 1. When scale=false, we should make no promises about normalization.
In fact, there is a test which tends to fail on Windows when using external BLAS/LAPACK (discussed in #1491, I think). The result is not in fact incorrect, just not normalized as usual. It was never clear if this should be considered a bug or not.
My suggestion is:

We can include the normalization fix if you like, but use 1.0 / sqrt(no_of_nodes).
Do not mention the fix in the changelog. Mentioning it makes it look like igraph makes guarantees about the normalization, but it does not.
Make it explicit in the docs that nothing is guaranteed about normalization.

@GroteGnoom Am I misunderstanding anything?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1813#issuecomment-924951606,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","I'll have to look carefully at the matrix multiplication you do to obtain one score from the other. I just wanted to note that I have the impression that it will not work correctly for an undirected graph because of the use of IGRAPH_TO.
Could we not just re-use the same igraph_i_kleinberg_unweighted and igraph_i_kleinberg_weighted functions to do the multiplication? That's what these functions do.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1813#issuecomment-924952620,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","Sorry, to be clear: these scores make little sense for undirected graphs, but currently they do work and should return the same result as for a directed graph with all-reciprocal edges. We should not break this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1813#issuecomment-924962271,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","@GroteGnoom Am I misunderstanding anything?

No, I forgot the sqrt, and didn't realize normalization isn't guaranteed. I don't want to change things without a changelog, even if we didn't guarantee a specific outcome. If the vectors returned by ARPACK are not always normalized in practice, then it seems better to just keep the old behavior.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1813#issuecomment-924963333,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","Could we not just re-use the same igraph_i_kleinberg_unweighted and igraph_i_kleinberg_weighted functions to do the multiplication? That's what these functions do.

Yes, that functionality should be reused.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/apps/codecov,7,https://github.com/igraph/igraph/pull/1813#issuecomment-925854248,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","Codecov Report

Merging #1813 (38287d0) into develop (9b636bc) will increase coverage by 0.21%.
The diff coverage is 82.92%.


❗ Current head 38287d0 differs from pull request most recent head b352083. Consider uploading reports for the commit b352083 to get more accurate results


@@             Coverage Diff             @@
##           develop    #1813      +/-   ##
===========================================
+ Coverage    73.25%   73.47%   +0.21%     
===========================================
  Files          340      340              
  Lines        57711    57728      +17     
===========================================
+ Hits         42275    42413     +138     
+ Misses       15436    15315     -121     



Impacted Files
Coverage Δ





src/centrality/hub_authority.c
86.16% <82.92%> (+86.16%)
⬆️


src/centrality/centrality_other.c
80.00% <0.00%> (+10.00%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 9b636bc...b352083. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1813#issuecomment-926085861,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.",Is it ready / shall I take another look?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1813#issuecomment-926089455,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","Oh, I completely forgot about it after sending it through the CI, yes please, I'm definitely interested in your comments for this new version.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1813#issuecomment-926094615,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","One small comment:
I was thinking about the long name hub_and_authority_scores and noticed that both networkx and Mathematica call it ""HITS"", which is more concise. I was wondering if we should consider this as well. However, both Wikipedia and Newman's book seem to use ""HITS"" to refer not to the scores, but to the iterative algorithm to compute them. We don't use this algorithm, so perhaps we should not use the name ""HITS"" either.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1813#issuecomment-926107907,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","Maybe we should just remove the ""scores"" from the name / names. That should help, and I don't think it makes it any less clear.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1813,2021-09-22T11:59:32Z,2021-09-24T09:33:44Z,2021-09-24T09:37:00Z,MERGED,True,391,81,7,https://github.com/GroteGnoom,Use matching vectors for hub and authority,6,[],https://github.com/igraph/igraph/pull/1813,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1813#issuecomment-926114414,"Also adds tests.
Fixes #1424
Fixes #1591
This implementation is not the most efficient, but I tried to produce something correct to see if this produces the expected results.
I changed the Kleinberg functionality for edgeless graphs to be consistent with other results, because I was surprised by it.
In practice the hub and authority eigenvalues seem to be the same, I can prove it for a 2x2 matrix, but I didn't prove it for larger matrices. I guess the proof could be one-liner, so I hope someone who is a bit better at linear algebra can confirm this.
Edit: Thinking that the degenerate example would work consistently on different systems was a bit too optimistic.","I think it's fine as it is, was just thinking aloud.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1815,2021-10-10T09:44:28Z,2021-10-13T14:14:02Z,2021-10-13T14:14:02Z,MERGED,True,153,43,5,https://github.com/GroteGnoom,Add random walk unit tests,3,[],https://github.com/igraph/igraph/pull/1815,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1815,"Part of #1592
Look at the separate commits to clear up the test files. There was already a test called igraph_random_walk, but it actually tested random_edge_walk.
It would be nice to cover everything, but https://app.codecov.io/gh/igraph/igraph/blob/develop/src/paths/random_walk.c
gives me:
""Well this is embarassing, looks like we had an error.""","Part of #1592
Look at the separate commits to clear up the test files. There was already a test called igraph_random_walk, but it actually tested random_edge_walk.
It would be nice to cover everything, but https://app.codecov.io/gh/igraph/igraph/blob/develop/src/paths/random_walk.c
gives me:
""Well this is embarassing, looks like we had an error.""",True,{}
igraph/igraph,https://github.com/igraph/igraph,1815,2021-10-10T09:44:28Z,2021-10-13T14:14:02Z,2021-10-13T14:14:02Z,MERGED,True,153,43,5,https://github.com/GroteGnoom,Add random walk unit tests,3,[],https://github.com/igraph/igraph/pull/1815,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1815#issuecomment-939443095,"Part of #1592
Look at the separate commits to clear up the test files. There was already a test called igraph_random_walk, but it actually tested random_edge_walk.
It would be nice to cover everything, but https://app.codecov.io/gh/igraph/igraph/blob/develop/src/paths/random_walk.c
gives me:
""Well this is embarassing, looks like we had an error.""","Codecov Report

Merging #1815 (9e24e60) into develop (65e6c85) will increase coverage by 0.03%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #1815      +/-   ##
===========================================
+ Coverage    73.47%   73.51%   +0.03%     
===========================================
  Files          340      340              
  Lines        57728    57728              
===========================================
+ Hits         42413    42436      +23     
+ Misses       15315    15292      -23     



Impacted Files
Coverage Δ





src/paths/random_walk.c
88.54% <100.00%> (+23.95%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 65e6c85...9e24e60. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1815,2021-10-10T09:44:28Z,2021-10-13T14:14:02Z,2021-10-13T14:14:02Z,MERGED,True,153,43,5,https://github.com/GroteGnoom,Add random walk unit tests,3,[],https://github.com/igraph/igraph/pull/1815,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1815#issuecomment-939465584,"Part of #1592
Look at the separate commits to clear up the test files. There was already a test called igraph_random_walk, but it actually tested random_edge_walk.
It would be nice to cover everything, but https://app.codecov.io/gh/igraph/igraph/blob/develop/src/paths/random_walk.c
gives me:
""Well this is embarassing, looks like we had an error.""","""Well this is embarassing, looks like we had an error.""

Do you mean that this is an error message from CodeCov?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1815,2021-10-10T09:44:28Z,2021-10-13T14:14:02Z,2021-10-13T14:14:02Z,MERGED,True,153,43,5,https://github.com/GroteGnoom,Add random walk unit tests,3,[],https://github.com/igraph/igraph/pull/1815,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1815#issuecomment-939480806,"Part of #1592
Look at the separate commits to clear up the test files. There was already a test called igraph_random_walk, but it actually tested random_edge_walk.
It would be nice to cover everything, but https://app.codecov.io/gh/igraph/igraph/blob/develop/src/paths/random_walk.c
gives me:
""Well this is embarassing, looks like we had an error.""","""Well this is embarassing, looks like we had an error.""

Do you mean that this is an error message from CodeCov?

Yes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1815,2021-10-10T09:44:28Z,2021-10-13T14:14:02Z,2021-10-13T14:14:02Z,MERGED,True,153,43,5,https://github.com/GroteGnoom,Add random walk unit tests,3,[],https://github.com/igraph/igraph/pull/1815,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1815#issuecomment-942348218,"Part of #1592
Look at the separate commits to clear up the test files. There was already a test called igraph_random_walk, but it actually tested random_edge_walk.
It would be nice to cover everything, but https://app.codecov.io/gh/igraph/igraph/blob/develop/src/paths/random_walk.c
gives me:
""Well this is embarassing, looks like we had an error.""",The Codecov link that used to give an error now works (at least for me).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1816,2021-10-16T11:03:45Z,2021-10-16T23:41:53Z,2021-10-16T23:42:00Z,MERGED,True,194,6,4,https://github.com/GroteGnoom,Add local_scan_k_ecount_them unit tests,4,[],https://github.com/igraph/igraph/pull/1816,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1816,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1816,2021-10-16T11:03:45Z,2021-10-16T23:41:53Z,2021-10-16T23:42:00Z,MERGED,True,194,6,4,https://github.com/GroteGnoom,Add local_scan_k_ecount_them unit tests,4,[],https://github.com/igraph/igraph/pull/1816,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1816#issuecomment-944898758,Part of #1592,"Codecov Report

Merging #1816 (9810720) into develop (a85bec8) will increase coverage by 0.20%.
The diff coverage is 83.33%.


❗ Current head 9810720 differs from pull request most recent head 87dc878. Consider uploading reports for the commit 87dc878 to get more accurate results


@@             Coverage Diff             @@
##           develop    #1816      +/-   ##
===========================================
+ Coverage    73.51%   73.71%   +0.20%     
===========================================
  Files          340      340              
  Lines        57728    57730       +2     
===========================================
+ Hits         42436    42555     +119     
+ Misses       15292    15175     -117     



Impacted Files
Coverage Δ





src/cliques/cliquer/cliquer.c
69.76% <ø> (ø)



src/community/spinglass/pottsmodel_2.cpp
71.42% <ø> (ø)



src/connectivity/cohesive_blocks.c
95.47% <ø> (ø)



src/misc/bipartite.c
74.94% <ø> (ø)



src/misc/sir.c
90.00% <ø> (ø)



src/community/community_misc.c
91.39% <50.00%> (-0.30%)
⬇️


src/misc/scan.c
54.40% <100.00%> (+31.46%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 7136389...87dc878. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1816,2021-10-16T11:03:45Z,2021-10-16T23:41:53Z,2021-10-16T23:42:00Z,MERGED,True,194,6,4,https://github.com/GroteGnoom,Add local_scan_k_ecount_them unit tests,4,[],https://github.com/igraph/igraph/pull/1816,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1816#issuecomment-944913511,Part of #1592,"The following tests FAILED:
809
	392 - test::glpk_error (SEGFAULT)

So it's that intermittent error again.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1816,2021-10-16T11:03:45Z,2021-10-16T23:41:53Z,2021-10-16T23:42:00Z,MERGED,True,194,6,4,https://github.com/GroteGnoom,Add local_scan_k_ecount_them unit tests,4,[],https://github.com/igraph/igraph/pull/1816,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1816#issuecomment-945021967,Part of #1592,Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1822,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1822#issuecomment-950882523,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","Codecov Report

Merging #1822 (a3717bb) into master (39b65f9) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1822   +/-   ##
=======================================
  Coverage   72.42%   72.42%           
=======================================
  Files         295      295           
  Lines       57396    57396           
=======================================
  Hits        41571    41571           
  Misses      15825    15825           



Impacted Files
Coverage Δ





src/community/spinglass/pottsmodel_2.cpp
71.42% <ø> (ø)



src/internal/qsort.c
100.00% <ø> (ø)



src/misc/matching.c
94.72% <ø> (ø)



src/misc/motifs.c
94.81% <ø> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 39b65f9...a3717bb. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1822#issuecomment-950891980,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","Apparently clang from macOS doesn't recognise the -Wunused-but-set-variable option:
src/misc/matching.c:525:34: error: unknown warning group '-Wunused-but-set-variable', ignored [-Werror,-Wunknown-warning-option]
#pragma clang diagnostic ignored ""-Wunused-but-set-variable""

We should probably make it dependent on some version number.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1822#issuecomment-951000790,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","Yes, I've hit this in other projects as well; it looks like Clang will have it from version 13 onwards, judging from the place of this commit in the Clang timeline.
OTOH it would probably be better to check explicitly whether the compiler supports this flag or not (see this). ShallI do this or will you take care of this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1822#issuecomment-951007827,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","Also, please separate the .gitignore update from this PR.
Re the pragma in misc/matching.c: sure, it works now but we will have to deal with other compilers at some point in the future; gcc also has this warning as far as I know, and eventually the Intel compiler and MSVC might also follow suit. Isn't there any clever trick to make the compiler ""think"" that the variable is used even when it is not? We have the IGRAPH_UNUSED() macro that works for parameters - maybe it works for variables as well?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1822#issuecomment-951024538,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","OTOH it would probably be better to check explicitly whether the compiler supports this flag or not (see this). ShallI do this or will you take care of this?

Ah, yes, that's perfectly suited for it. It's a bit annoying also to do these type of things in the actual source code. It clutters it, and doesn't make it really readable. But I guess there's no way around that. If won't get around to this today anymore.

We have the IGRAPH_UNUSED() macro that works for parameters - maybe it works for variables as well?

I doubt it, or at least not how it's now defined I think. The problem is that the variable is never used in an assignment (or in any logical flow). Perhaps you could include a statement like
#define IGRAPH_UNUSED(x) (void)(x = x)

But I'm not sure whether this will make some things really problematic, and then again, perhaps the compiler is smart enough to first optimize this away, and then yield a warning.

Also, please separate the .gitignore update from this PR.

Sure, no problem.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1822#issuecomment-951033511,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","Using (void) to ignore an unused variable works on my clang 11.
Tested with
int main ()
{
    int a;
    (void) a;
}

Without it I get:
testvoid.c:3:9: warning: unused variable 'a' [-Wunused-variable]
    int a;",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1822#issuecomment-951046773,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","That's a different warning; Clang 13 also checks for variables that are set and modified, but not read later. E.g., something like this would trigger a warning on Clang 13. Try this on https://godbolt.org with x86-64 clang 13.0.0 after adding -Werror -Wall to the compiler flags:
int main(int argc, char* argv[]) {
    int c = 42;
    c *= 2;
    return 0;
}

However, it seems like (void)(c) silences this warning as well, which is good news because it seems we can get away without any #pragma directives in src/misc/matching.c.
@vtraag Can you test what happens if you remove the pragmas and just use IGRAPH_UNUSED(dual) in src/misc/matching.c - does it indeed fix the problem for Clang 13?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1822#issuecomment-951049490,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","I'm sorry, I should have paid more attention. I only read the

We have the IGRAPH_UNUSED() macro that works for parameters - maybe it works for variables as well?

But I'm glad it accidentally does work :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1822#issuecomment-952962882,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","IGRAPH_UNUSED indeed works, so that's nice. I've now changed disabling those errors to use IGRAPH_UNUSED. I do ignore the null-pointer-subtraction warning in qsort.c still.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1822#issuecomment-955665148,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.",-Wno-unknown-warning-option is not supported by the Intel compiler. I'll try to fix this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1822,2021-10-25T12:34:19Z,2021-10-27T17:30:38Z,2021-10-31T09:52:03Z,MERGED,True,22,1,5,https://github.com/vtraag,fix: correct/ignore some warnings when building with clang-13.,4,[],https://github.com/igraph/igraph/pull/1822,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1822#issuecomment-955669052,"This fixes #1821. It ignores some warnings explicitly for clang, and simply removes/comments out some unused variables.","Before fixing this minor issue for the Intel compiler, let's deal with #1824. Compilation doesn't fail with Intel, it just outputs a large number of complaints about the unknown option. So it's not a big deal if it doesn't get fixed for 0.9.5.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1823,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1823#issuecomment-955174662,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Codecov Report

Merging #1823 (7c3f7f3) into develop (4fc6add) will increase coverage by 0.93%.
The diff coverage is n/a.


@@             Coverage Diff             @@
##           develop    #1823      +/-   ##
===========================================
+ Coverage    74.00%   74.94%   +0.93%     
===========================================
  Files          344      347       +3     
  Lines        58083    57898     -185     
===========================================
+ Hits         42987    43392     +405     
+ Misses       15096    14506     -590     



Impacted Files
Coverage Δ





src/constructors/kautz.c
95.12% <0.00%> (-2.18%)
⬇️


src/graph/adjlist.c
63.88% <0.00%> (-2.04%)
⬇️


src/constructors/de_bruijn.c
84.00% <0.00%> (-1.72%)
⬇️


src/constructors/full.c
96.42% <0.00%> (-1.40%)
⬇️


src/constructors/famous.c
70.66% <0.00%> (-1.34%)
⬇️


src/core/stack.pmt
77.01% <0.00%> (-1.25%)
⬇️


src/games/preference.c
81.43% <0.00%> (-0.94%)
⬇️


src/connectivity/components.c
94.45% <0.00%> (-0.80%)
⬇️


src/core/error.c
75.90% <0.00%> (-0.57%)
⬇️


src/operators/misc_internal.c
94.16% <0.00%> (-0.33%)
⬇️


... and 70 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4fc6add...7c3f7f3. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1823#issuecomment-955183105,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","| 3 go over vertices (multiple times) using adjlist 0.046s 0.046s 0s
| 4 go over vertices (multiple times) using inclist 0.414s 0.414s 0s

Well, now that's dramatic!",True,{'LAUGH': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1823#issuecomment-955193078,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","This is very interesting to see!
However, the two don't do comparable things: the one loops over both edge indices and node indices, and the other only over node indices. The real comparison is: can we iterate over both edges and nodes faster using adjlist and inclist combined, or by using IGRAPH_OTHER?
One thing that would also be interesting is to profile this benchmark code. Presumably,  most time is spent indeed in IGRAPH_OTHER, but it would be interesting to see how much.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1823#issuecomment-955195422,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","The real comparison is: can we iterate over both edges and nodes faster using adjlist and inclist combined, or by using IGRAPH_OTHER?

In this case the initialization of the adjlist takes longer than looping over the vertices with an inclist, so it seems to be impossible to speed up the process by also generating an adjlist. But because betweenness scales with |V||E|, and initialization with |V| + |E|, there should be some point where it is useful to also use an adjlist, even when you've already initialized an inclist. I'm not sure what to benchmark next to check this in realistic cases.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1823#issuecomment-955196631,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","However, the two don't do comparable things: the one loops over both edge indices and node indices, and the other only over node indices.

I would call these comparable. Conceptually, both iterate over all neighbours of all nodes. The number of iterations is the same in both cases, except one looks at (node_id) while the other at (edge_id, node_id) pairs. That does not explain a 10x performance difference.
In order to keep benchmarked things as separate as possible, we could add a third program, which iterates only over edges, but skips retrieving the node at the other end of the edge.  I would expect this to run in time comparable to ""3 go over vertices (multiple times) using adjlist""
I do wonder if the time spent in IGRAPH_OTHER can really be accurately measured by a profiler, if the cause of the slowdown is indeed a failure of branch prediction (i.e. inner workings of the CPU). If there are still doubts, we could add yet another test where IGRAPH_OTHER is replaced by IGRAPH_FROM or IGRAPH_TO (whichever). This will eliminate the conditional (which is contained in IGRAPH_OTHER) and can tell us whether the problem is indeed with branch prediction.  It is also a useful benchmark because it's what's being done in the directed case (we usually use IGRAPH_TO for directed and IGRAPH_OTHER for undirected).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1823#issuecomment-955196733,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Another note is that this is not just about betweenness. The same kind of iteration over adjlist/inclist happens in all sort of graph traversals, including: DFS/BFS, shortest paths, closeness, betweenness, random walks, etc.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1823#issuecomment-955197109,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","In this case the initialization of the adjlist takes longer

And yes, this is a good point. Using both an adlist and inclist is probably not going to help. But we can think about ways to encode which is the ""other"" end of edges in the inclist, in some way. First let's figure out where the problem is, though.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1823#issuecomment-955199901,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","So IGRAPH_TO is not actually faster. This is not what I expected. Could it be a non-locality issue, i.e. that determining the vertex requires fetching data from a far-away memory location?
I would do the following now, even if some of it looks redundant:

Add a benchmark that iterates over incident edges only, but does not get the vertex. Is it still slow? I see no reason why it would be.
What Vincent requested: iterate both over vertices and edges, but get the vertex from the adjlist instead of the inclist. This would be fully comparable with benchmarks 4-5.

Something not quite related, but still interesting:

Does the adjlist/inclist initialization performance change at all when NOT removing self-loops and multi-edges? I.e. use LOOPS_TWICE and MULTIPLE.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/vtraag,10,https://github.com/igraph/igraph/pull/1823#issuecomment-955574031,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","It is very interesting to see these results for such a fundamental part of the library!

Could it be a non-locality issue, i.e. that determining the vertex requires fetching data from a far-away memory location?

I was wondering the same indeed. Could we perhaps test with a graph that has edges ordered in exactly the same way as the order in which the inclist iterates over? That might make caching much more efficient. Or is this already the case here?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1823#issuecomment-955661826,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","The speedup when not excluding loops for the inclist is pretty amazing. This also happens when I test that first, so I don't think it's caching related.
I'm not sure yet how to improve caching on vertex retrieval from an edge. Maybe I can make it worse to check if that has an effect.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1823#issuecomment-955662768,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","This is getting quite interesting.
It would be interesting to have two other cases to compare to:

A random graph of similar size. The difference compared to the complete graph is that edges are ordered unpredictably.
A small graph (either random or complete). In the igraph_pagerank.c benchmark I used a helper macro called REPEAT to run the same operation many times, and thus be able to benchmark things that take a short amount of time. Performance is usually different on small graphs compared to large ones because of cache effects.

Maybe come up with another (even empty) benchmark for number 10, then add the other two cases (random graph, small graph) afterwards? This way the numberings will match between the three cases, making comparisons easy.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1823#issuecomment-955664062,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","The speedup when not excluding loops for the inclist is pretty amazing.

At present, loop removal performs the same type of iteration over the inclist that we are benchmarking here. Notably, it looks back into the igraph_t using an IGRAPH_TO and IGRAPH_FROM. It may actually be the same effect.

This also happens when I test that first, so I don't think it's caching related.

Regarding the timings of the first benchmark:
I forgot to warn you to build igraph with the vendored LAPACK/BLAS/ARPACK whenever benchmarking. I noticed that when linking to these external libraries, the timings of the first benchmark are sometimes off. I think this is because the external versions of these libraries are often multithreaded, and will execute some initialization code that spins up some threads. The timing from that shows up in the benchmark.  Whatever the reason, I suggest using the vendored LAPACK/BLAS/ARPACK and disabling OpenMP, whenever benchmarking things that do not depend on these.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,14,https://github.com/igraph/igraph/pull/1823#issuecomment-955667218,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Maybe come up with another (even empty) benchmark for number 10, then add the other two cases (random graph, small graph) afterwards? This way the numberings will match between the three cases, making comparisons easy.

Is that numbering system required? Or can I just call them 1-1 and 2-1 for example?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1823#issuecomment-955668629,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Is that numbering system required? Or can I just call them 1-1 and 2-1 for example?

Whatever you prefer!
The motivation for a semi-consistent numbering was so that eventually we can parse all benchmark output with a script and summarize it. This is not a major concern for me at this moment. We'll deal with it when we get there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1823#issuecomment-955671211,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","So here the ""random graph"" is actually a complete graph as well, just with randomized edge ordering. This is not what I was thinking of, but this may actually be good (as it's more comparable).
It looks like all the timings are essentially the same, except for 4, which you mention is very unpredictable. I'll venture a guess that what we see here is now really a failure of branch prediction (due to the randomization). So IGRAPH_OTHER is in fact more costly than IGRAPH_TO, but still: both are pretty slow to use.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,17,https://github.com/igraph/igraph/pull/1823#issuecomment-955672601,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","It looks like all the timings are essentially the same, except for 4,

rg - 3 is also way slower (and more varying) than fg-3. This is only using the adjlist.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/vtraag,18,https://github.com/igraph/igraph/pull/1823#issuecomment-964169467,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","I have been thinking about this a bit.
Ideally, we wouldn't even need an adjlist or inclist because the information is essentially already contained in igraph_t. However, iteration over igraph_t is slow, in part because it needs to get information from the igraph_t->from and igraph_t->to vectors based on the igraph_t->oi and igraph_t->ii vectors. This requires to get non-local information from the from and to vector, preventing the CPU to use the cache efficiently, as it essentially may need to get information from pretty random parts across these vectors. One of the most typical operations across igraph is to iterate over the neighbours and/or incident edges of a node. If somehow, the igraph_t->from and igraph_t->to vectors are aligned with the igraph_t->oi and igraph_t->ii orders, this would greatly benefit the use of caching and should make it quite a bit faster, in line with what we observe here. Unfortunately, we of course cannot align them both, since the sorting order will inherently always be different for incoming and outgoing edges.
Here's one possible approach to deal with this. How about we simply keep track of the ""other"" node in a separate vector? That is, we would essentially add two vectors for the ""other"" incoming nodes and the ""other"" outgoing nodes, i.e. the neighbours. This of course adds additional memory storage of 2m, with m being the number of edges, at the benefit of running faster. If we want to save on memory, we could in principle get rid of the from and to vectors, since they are then in principle redundant. However, this would make it impossible to quickly retrieve the endpoints for a certain edge id.
A less invasive proposal, just to deal with the simultaneous iteration over incident edges and neigbhours: should we perhaps simply introduce an igraph_adjinclist_t type that contains both vectors of neighbours and of incident edges?

This also happens when I test that first, so I don't think it's caching related.

I would just like to clarify something here about the caching to make sure that we are on the same page here. The point about caching is that memory gets read into the CPU cache. Whenever a piece of memory is required it fetches a larger part of the memory, not just the single index that is accessed. That means that if we access first to[30] and then to[31] it will be faster than if we first access to[30] and then to[3944]: accessing 30 and 31 requires only a single fetch from main memory (or higher level caches), while accessing 30 and 3944 requires two fetches from main memory (or higher level caches), which is slower. For example, this is also why looping in the ""incorrect"" order of a matrix you a take performance hit: https://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra The graphs tested here are too large to fit into any reasonable cache, so probably there will often be fetches from main memory.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/ntamas,19,https://github.com/igraph/igraph/pull/1823#issuecomment-964943184,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Here's one possible approach to deal with this. How about we simply keep track of the ""other"" node in a separate vector?

Do you mean that we should do this ""locally"" in the weighted betweenness algorithm only, or that we should change igraph_t to have this information permanently?

should we perhaps simply introduce an igraph_adjinclist_t type that contains both vectors of neighbours and of incident edges?

That's an easy thing to try and it would be interesting to see whether it improves things.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1823#issuecomment-964972113,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","should we perhaps simply introduce an igraph_adjinclist_t type that contains both vectors of neighbours and of incident edges?

That's an easy thing to try and it would be interesting to see whether it improves things.

The concern here is memory usage (which would be doubled). Would we ever want to use a plain inclist instead of an incadjlist? I don't think so, because the performance issues apply in almost every case, not just for betweeness. Therefore, it would be nice to think about a solution that is more memory friendly.
A possible alternative to an ""incadjlist"" would be a augmented inclist where for each edge we store a boolean value indicating which end of the edge is the ""other"" one. We can store the booleans as a char, which takes 1/8th of the memory of an igraph_integer_t on the most common platforms (64-bit). On 32-bit it's still only a 25% increase in memory use instead of a 100% one.
From the benchmarking, it appears that there may be two reasons for the performance problems:

Non-locality. This would be resolved by such an augmented inclist. So far, it appears that this is by far the biggest issue.
Branch prediction failure. This would NOT be resolved by the augmented inclist, as we'd still have conditionals, but so far it appears that this is a minor effect anyway.

It would be nice to benchmark an ""incadjlist"" vs an ""augmented inclist"" and confirm that there is minimal performance difference.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/vtraag,21,https://github.com/igraph/igraph/pull/1823#issuecomment-964991698,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Here's one possible approach to deal with this. How about we simply keep track of the ""other"" node in a separate vector?

Do you mean that we should do this ""locally"" in the weighted betweenness algorithm only, or that we should change igraph_t to have this information permanently?

I was thinking of doing this more permanently. We now translate all the time the actual igraph_t into an adjlist or inclist, which wastes resources, both computationally and memory wise. If we can find a representation in which we can avoid doing this, that would be great.
Of course, in the meantime, it might be worthwhile to do this locally for some algorithm, but I think it would then be better to do this in the form an explicit structure, such as the adjinclist.

A possible alternative to an ""incadjlist"" would be a augmented inclist where for each edge we store a boolean value indicating which end of the edge is the ""other"" one. We can store the booleans as a char, which takes 1/8th of the memory of an igraph_integer_t on the most common platforms (64-bit). On 32-bit it's still only a 25% increase in memory use instead of a 100% one.

I am not sure if this is actually solves the non-locality problem. The problem is that we need to fetch the actual endpoints of an edge from the vectors from and to. Storing such a boolean improves things in the sense that we only need to access either the from or the to vectors, and not both. That is, we still need to access something like to[30] and to[3944] instead of to[30] and to[31]. Or am I perhaps misunderstanding your proposal?

The concern here is memory usage (which would be doubled). Would we ever want to use a plain inclist instead of an incadjlist? I don't think so, because the performance issues apply in almost every case, not just for betweeness. Therefore, it would be nice to think about a solution that is more memory friendly.

Yes, I agree, it takes up more memory. However, don't forget we are already taking up more memory because the inclist is basically a copy of the igraph_t, although inclist is only about 25-50% of the memory of igraph_t (depending on how it is constructed). Suppose we add the ""other"" vectors that I proposed to igraph_t, but we no longer construct an inclist. I believe the memory requirements would then be roughly comparable. Of course, avoiding the use of an inclist all together would require a major overhaul of the whole library, which is a bit much at the moment. At any rate, I think we should not be concerned too much with memory specifically of such an adjinclist or inclist, but look at it in combination with igraph_t. Finally, although memory concerns are obviously valid, I think that memory is less and less of a problem.
One practical way to go about this is to see if we can test a few solutions in practice for betweenness, and then try to see which one fits best and can potentially be easily generalised to the rest of the library.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1823#issuecomment-964997075,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Or am I perhaps misunderstanding your proposal?

No, it was my mistake.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,23,https://github.com/igraph/igraph/pull/1823#issuecomment-968051913,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","It seems like an incadjlist could be useful compared to an inclist when looping over vertices and their edges.
The quickest way is to skip the lists altogether and use graph_t internals.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/vtraag,24,https://github.com/igraph/igraph/pull/1823#issuecomment-970408167,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Great, thanks for the implementation @GroteGnoom !
I think that we might think about using incadjlist, using the igraph_t internal directly would not be a good design if we want to make it possible to think about alternative graph structures at one point. The current implementation that you made uses interleaved edge indices and vertex indices. Perhaps it would be easier to use simply two separate vectors, which might make the function easier to use in practice?
Perhaps we could think about making just a single type instead of having three types inclist, adjlist and incadjlist and their lazy alternatives? Upon construction of the type, a caller could then indicate whether you want neighbours, incident edges, or both. That way, we can keep only a single type and get rid of the two separate adjlist and inclist types. The API would then be something like:
igraph_adjlist(igraph_t *graph, const igraph_adjlist_t *adjlist,
               igraph_neimode_t mode, igraph_bool_t duplicate,
               igraph_bool_t list_neighbors, igraph_bool_t list_incident_edges);

igraph_adjlist_get_neighbors(igraph_adjlist_t *adjlist);
igraph_adjlist_get_incident_edges(igraph_adjlist_t *adjlist);
I'm not sure however whether it wouldn't be a better idea to think about this in the context of iterators. Instead of coming up with some special type that allows fast iteration over neighbours / incident edges, we might think about how such iterators could be best implemented, where this type of iterator would be only one of such type of iterators.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1823#issuecomment-985997264,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.",Can we merge this? It's still possible to keep adding to it later.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/GroteGnoom,26,https://github.com/igraph/igraph/pull/1823#issuecomment-986000615,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.",Sure!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1823,2021-10-30T08:41:09Z,2022-02-18T19:52:20Z,2022-02-18T19:52:20Z,MERGED,True,370,0,2,https://github.com/GroteGnoom,Add benchmarks to optimize weighted betweenness,10,[],https://github.com/igraph/igraph/pull/1823,https://github.com/vtraag,27,https://github.com/igraph/igraph/pull/1823#issuecomment-986088180,"A discussion on weighted betweenness optimizations started from here:
https://igraph.discourse.group/t/calculation-too-slow/920
This PR tries to figure out if we can optimize weighted betweenness.
The first commit adds an inclist vs adjlist benchmark.
This is a benchmark of low-level functionality that is often used.
It is used in betweenness calculations in particular, and could be the major contribution
to the runtime difference between weighted and unweighted betweenness calculations.
This draft is supposed to be a starting point to check for other points of optimization.
results:
 fg - | 1 initialize adjlist.                                                            0.954s  0.737s  0.215s
 fg - | 2 initialize inclist.                                                              1.6s   1.11s  0.273s
 fg - | 3 go over vertices (multiple times) using adjlist.                               0.084s  0.084s      0s
 fg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.521s  0.516s  0.003s
 fg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.445s  0.442s  0.002s
 fg - | 6 go over edges using inclist, don't retrieve vertex.                            0.054s  0.054s      0s
 fg - | 7 go over edges and vertices using adjlist and inclist.                          0.106s  0.105s      0s
 fg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.859s  0.623s  0.235s
 fg - | 9 initialize inclist, include loops (which aren't present).                      0.514s  0.255s  0.237s
 fg - | 10 go over edges and vertices using graph internals directly.                    0.799s  0.798s  0.001s
 fg - | 11 initialize interleaved incadjlist.                                             1.18s  0.783s  0.389s
 fg - | 12 go over edges and vertices using interleaved incadjlist.                      0.145s  0.145s      0s
 fg - | 13 initialize incadjlist with two vectors.                                        2.14s  0.936s  0.566s
 fg - | 14 go over edges and vertices using incadjlist.                                  0.995s  0.246s  0.715s

Random graph tests:
 rg - | 1 initialize adjlist.                                                            0.883s   0.68s    0.2s
 rg - | 2 initialize inclist.                                                             1.54s   1.18s  0.324s
 rg - | 3 go over vertices (multiple times) using adjlist.                               0.082s   0.08s      0s
 rg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.814s  0.808s  0.004s
 rg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.429s  0.425s  0.004s
 rg - | 6 go over edges using inclist, don't retrieve vertex.                            0.044s  0.044s      0s
 rg - | 7 go over edges and vertices using adjlist and inclist.                           0.08s   0.08s      0s
 rg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.762s  0.571s  0.192s
 rg - | 9 initialize inclist, include loops (which aren't present).                      0.427s  0.221s  0.205s
 rg - | 10 go over edges and vertices using graph internals directly.                    0.767s  0.766s      0s
 rg - | 11 initialize interleaved incadjlist.                                             1.45s   1.07s  0.376s
 rg - | 12 go over edges and vertices using interleaved incadjlist.                      0.133s  0.132s      0s
 rg - | 13 initialize incadjlist with two vectors.                                        2.07s   1.37s  0.673s
 rg - | 14 go over edges and vertices using incadjlist.                                  0.958s  0.234s  0.686s

Small graph tests:
 sg - | 1 initialize adjlist.                                                            0.629s  0.466s  0.159s
 sg - | 2 initialize inclist.                                                            0.679s  0.485s  0.191s
 sg - | 3 go over vertices (multiple times) using adjlist.                               0.044s  0.042s  0.001s
 sg - | 4 go over vertices (multiple times) using inclist, IGRAPH_OTHER.                 0.175s  0.174s  0.001s
 sg - | 5 go over vertices (multiple times) using inclist, IGRAPH_TO.                    0.136s  0.136s  0.001s
 sg - | 6 go over edges using inclist, don't retrieve vertex.                            0.035s  0.035s      0s
 sg - | 7 go over edges and vertices using adjlist and inclist.                          0.071s  0.071s      0s
 sg - | 8 initialize adjlist, include loops and multiple (which aren't present).         0.878s  0.494s  0.289s
 sg - | 9 initialize inclist, include loops (which aren't present).                      0.781s  0.311s  0.315s
 sg - | 10 go over edges and vertices using graph internals directly.                    0.288s  0.267s  0.008s
 sg - | 11 initialize interleaved incadjlist.                                              1.7s  0.774s  0.619s
 sg - | 12 go over edges and vertices using interleaved incadjlist.                      0.105s  0.102s  0.002s
 sg - | 13 initialize incadjlist with two vectors.                                        1.61s  0.836s   0.61s
 sg - | 14 go over edges and vertices using incadjlist.                                  0.147s  0.134s  0.011s

The results of rg-4 seem to vary wildly (0.5 s - 3 s) with random seed.","Is it possible to merge and continue the conversation here and merge again later with additional commits? I think we then have to open a new PR, don't we?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1825,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1825#issuecomment-957618586,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","Codecov Report

Merging #1825 (0484322) into master (8474ca4) will increase coverage by 0.00%.
The diff coverage is 100.00%.


@@           Coverage Diff           @@
##           master    #1825   +/-   ##
=======================================
  Coverage   72.42%   72.43%           
=======================================
  Files         295      295           
  Lines       57397    57408   +11     
=======================================
+ Hits        41572    41583   +11     
  Misses      15825    15825           



Impacted Files
Coverage Δ





src/internal/qsort.c
100.00% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8474ca4...0484322. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1825#issuecomment-957674113,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","I suggest not using the latest commit, but the one before that. The latest commit added qsort_s, which we don't have (or need?) in igraph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1825#issuecomment-957682199,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","@ntamas Instead of providing the non-standard ssize_t, would it not be better to just use the standard and essentially equivalent ptrdiff_t?
Also, please don't make the totally unnecessary qsort_s stuff. If you decide to include this code, at least it should be included in its entirety, not just partially, as it is now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1825#issuecomment-957687157,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","Also, please don't make the totally unnecessary qsort_s stuff. If you decide to include this code, at least it should be included in its entirety, not just partially, as it is now.

I would preferably make minimal changes. We can pull in the additional qsort_s stuff, but why do you have a problem keeping this stuff be in qsort.c? It's all conditional anyway, so there's no harm in letting it be in there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1825#issuecomment-957691775,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","Instead of providing the non-standard ssize_t, would it not be better to just use the standard and essentially equivalent ptrdiff_t?

Some arcane magic seems to be going on at the point where ssize_t is used so I thought it's easier to leave that alone and just work around it on Windows. I mean, there must be a reason why they did not use the standard ptrdiff_t type and opted for the non-standard (POSIX-only) ssize_t.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1825#issuecomment-957693810,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","To avoid confusion, I wanted to note that originally I was looking here, at their SVN:
https://svnweb.freebsd.org/base/head/lib/libc/stdlib/qsort.c
Their git repo has newer code, with two more commits. The last commit introduced a use of ssize_t:
https://cgit.freebsd.org/src/log/lib/libc/stdlib/qsort.c (click ""tree"" to see the file)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1825#issuecomment-957711972,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","To avoid confusion, I wanted to note that originally I was looking here, at their SVN:
https://svnweb.freebsd.org/base/head/lib/libc/stdlib/qsort.c

Yes, I understood you were looking here.

Their git repo has newer code, with two more commits. The last commit introduced a use of ssize_t:
https://cgit.freebsd.org/src/log/lib/libc/stdlib/qsort.c (click ""tree"" to see the file)

Yes, I thought it would be best to use the most recently available version.
The reasoning that is provided in those latest commits indeed suggest that it makes sense to use ptrdiff_t instead of ssize_t and keep it clean. I'm not sure why they would opt to use ssize_t instead, possibly because SSIZE_MAX could (theoretically) be larger than PTRDIFF_MAX because it only needs to support -1 instead of the whole negative range. I'm not sure how they would do this in practice though.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1825#issuecomment-957731461,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","@szhorvat now that CI has passed, are you okay with keeping things this way and merging it (with ssize_t hacks and the part that relates to qsort_c and that is protected by a #define now, or do you insist on removing the unused parts? I'm in favour of keeping it as it is easier to diff this against the FreeBSD commit to see what we've changed if we need to update it again later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1825#issuecomment-957738364,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","I don't have a confident answer about ssize_t vs prtdiff_t, but I am a bit uncomfortable with the reasoning that we should not change this because we don't fully understand it (""magic""), because:

Do we understand how SSIZE_T on Windows relates to the POSIX ssize_t? This discussion suggests that there's both ssize_t and SSIZE_T on Windows and they may differ (I guess this is where Tamás got the code included in the last commit). It's a mess.
FreeBSD code may be assuming that types/ranges have certain properties that standards don't guarantee. They only need to care about one system: FreeBSD.
According to this, ssize_t is only required to hold -1, but not any other negative values. Could this be a problem on some other, more exotic system?
The ssize_t value is being operated together with ptrdiff_t values. What is the result? It appears to me that the assumption is that the result is also a ptrdiff_t, so is there any reason not to just stick to that single standard type?
Here's an example where ptrdiff_t and ssize_t differ, but ptrdiff_t is the larger type—so it seems that ptrdiff_t should be safe there? Is there a case when ptdiff_t is smaller? That shouldn't be possible.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1825#issuecomment-957743104,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","I'm in favour of keeping it as it is easier to diff this against the FreeBSD commit

OK, we can keep it. But then there should be a comment in the file about the origin of the source code, so we know where to go for updates. This PR was phrased as updating ""the"" qsort function, but there is no one true qsort. OpenBSD has a different qsort, clearly derived from the same original code, but modified over time. See e.g. here (not directly in OpenBSD but lifted from there).
EDIT: It would be nice to also add a comment about qsort_s, namely that it's unused and that's why we don't have the missing file.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/vtraag,12,https://github.com/igraph/igraph/pull/1825#issuecomment-957772548,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","In principle, I'm in favour of keeping changes to a minimum, so that it's indeed easier to update. However, since ssize_t is used in only a single location, I don't think it's a problem to change that to ptrdiff_t instead. I would be in favour of doing so, especially with an eye on Windows support.
Providing comments in the file itself should also be fine. I provided the exact reference to the source in the commit message, which I thought should be sufficient. But if you prefer in the file, that's also OK with me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1825#issuecomment-957880589,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","@ntamas I forgot to say, we can now remove -Wno-unknown-warning-option from compilers.cmake, as after this change it's no longer needed.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1825#issuecomment-957902017,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","I think we can keep it -- it would allow us to add new warning options later to the compiler definitions without worrying about versions of the compiler that do not support the option; as long as the compiler supports -Wno-unknown-warning-option, it will not warn about the new warning options that it does not know and will not turn them into errors. Any objections?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1825,2021-11-02T13:46:25Z,2021-11-02T15:53:53Z,2021-11-02T16:24:04Z,MERGED,True,197,157,1,https://github.com/vtraag,Updates `qsort` to a more recent version,4,[],https://github.com/igraph/igraph/pull/1825,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1825#issuecomment-957912336,"As suggested by @szhorvat in #1824 we should update qsort. This PR addresses this and updates qsort to a more recent version as available from FreeBSD. To be specific, the source was pulled from  the most recent commit https://cgit.freebsd.org/src/commit/a670e1c13a522df4fb8c63bb023b88b1d65de797.
I have made the minimal necessary changes to make it easier to include any possible subsequent updates of qsort.c. At the moment, the code already works with a ""local"" version of qsort making it easy to do the necessary changes. For future reference and to be complete: these are the changes with respect to the original file from FreeBSD:
31a32,43
> #include ""igraph_qsort.h""
> 
> #ifdef _MSC_VER
>     /* MSVC does not have inline when compiling C source files */
>     #define inline __inline
>     #define __unused
> #endif
> 
> #ifndef __unused
>   #define __unused    __attribute__ ((unused))
> #endif
> 
35,36d46
< #include <sys/cdefs.h>
< __FBSDID(""$FreeBSD$"");
38,39d47
< #include <errno.h>
< #include <stdint.h>
41,42d48
< #include <string.h>
< #include ""libc_private.h""
212c218
< qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
---
> igraph_qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
218c224
< qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
---
> igraph_qsort_s(void *a, rsize_t n, rsize_t es, cmp_t *cmp, void *thunk)
244c250
< qsort(void *a, size_t n, size_t es, cmp_t *cmp)
---
> igraph_qsort(void *a, size_t n, size_t es, cmp_t *cmp)","No objections, but then I'm wondering if we still need to make -Wno-varargs conditional:
https://github.com/igraph/igraph/blob/master/etc/cmake/compilers.cmake#L38
EDIT: Anyway, let's keep it as is. It's not worth spending time on figuring out whether it's safe to remove the conditional.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1832,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.","As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1832#issuecomment-961831097,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.","Codecov Report

Merging #1832 (52f00a3) into master (9ba7548) will increase coverage by 0.09%.
The diff coverage is n/a.


@@            Coverage Diff             @@
##           master    #1832      +/-   ##
==========================================
+ Coverage   72.43%   72.52%   +0.09%     
==========================================
  Files         295      295              
  Lines       57408    57698     +290     
==========================================
+ Hits        41583    41848     +265     
- Misses      15825    15850      +25     



Impacted Files
Coverage Δ





src/layout/reingold_tilford.c
96.33% <0.00%> (-0.13%)
⬇️


src/operators/simplify.c
97.22% <0.00%> (-0.04%)
⬇️


src/misc/conversion.c
85.99% <0.00%> (+1.64%)
⬆️


src/operators/contract.c
52.08% <0.00%> (+4.39%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 9ba7548...52f00a3. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1832#issuecomment-965394682,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.","Thanks @szhorvat! In general, it looks good to me. Perhaps we can slightly expand the text, and I'd like to make a few edits. Is it OK if I push to this PR directly?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1832#issuecomment-965404248,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.","Sure, just go ahead and push changes.
I would like to suggest keeping the main part very concise, otherwise people may not read it. We can perhaps go for a two-part structure, the first is concise, the second details? Or a headline structure, where bolded headlines confer the important message, while the rest of the text expands on it?  Whatever you think works for short-attention-span reader will be fine with me ;-)",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1832#issuecomment-965496671,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.","I've tried to keep it concise, but provide just a little bit more text.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1832#issuecomment-965671957,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.",LGTM.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1832#issuecomment-965721046,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.",LGTM then if @szhorvat  also agrees. :) And delete the support-md branch.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1832#issuecomment-965730885,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.","I see that Vincent likes to say ""please"" :-) LGTM, feel free to merge.",True,{'LAUGH': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1832,2021-11-05T11:44:53Z,2021-11-11T10:16:41Z,2021-11-11T10:16:48Z,MERGED,True,13,0,1,https://github.com/szhorvat,Create SUPPORT.md,3,[],https://github.com/igraph/igraph/pull/1832,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1832#issuecomment-966178935,"As suggested, we should add a SUPPORT.md files to the repos of all igraph interfaces. Here's GitHub's descritption of this file:
https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-support-resources-to-your-project
It will be shown when people try to open a new issue. This should further reduce the number of support questions mistakenly posted in the issue tracker.
This PR is just a starting point in order to start a discussion.",Please :),True,{'LAUGH': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1833,2021-11-06T09:50:26Z,2021-11-06T22:02:39Z,2021-11-06T22:02:39Z,MERGED,True,45,4,4,https://github.com/GroteGnoom,Make igraph_random_sample_real internal,3,[],https://github.com/igraph/igraph/pull/1833,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1833,Fixes #1829,Fixes #1829,True,{}
igraph/igraph,https://github.com/igraph/igraph,1833,2021-11-06T09:50:26Z,2021-11-06T22:02:39Z,2021-11-06T22:02:39Z,MERGED,True,45,4,4,https://github.com/GroteGnoom,Make igraph_random_sample_real internal,3,[],https://github.com/igraph/igraph/pull/1833,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1833#issuecomment-962427095,Fixes #1829,"Codecov Report

Merging #1833 (2cf9cac) into develop (44c67dd) will not change coverage.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #1833   +/-   ##
========================================
  Coverage    73.77%   73.77%           
========================================
  Files          340      340           
  Lines        57588    57588           
========================================
  Hits         42483    42483           
  Misses       15105    15105           



Impacted Files
Coverage Δ





src/games/erdos_renyi.c
93.84% <ø> (ø)



src/random/random.c
61.07% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 44c67dd...2cf9cac. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1833,2021-11-06T09:50:26Z,2021-11-06T22:02:39Z,2021-11-06T22:02:39Z,MERGED,True,45,4,4,https://github.com/GroteGnoom,Make igraph_random_sample_real internal,3,[],https://github.com/igraph/igraph/pull/1833,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1833#issuecomment-962438506,Fixes #1829,"One more thing I just noticed: random_internal.h should be included in the file where igraph_random_sample_real() is defined. Why? Because if the definition and the prototype disagree (e.g. because we accidentally only updated one of them), the compiler will be able to show a warning.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1836,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1836#issuecomment-963009545,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","To illustrate why eccentricity is a nice way to choose roots, consider a Bethe lattice like this:

This is a nice drawing. But what drawing will igraph choose? Notice that all non-leaf-nodes have degree 3. Thus, if we select a maximum degree node, we might choose any of them, and we might end up with a drawing like this one:

Using eccentricity will select the ""central"" node and produce a nice drawing:",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1836#issuecomment-963011996,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","Final notes:


I separated root selection into its own function. I would like to make this a public function for version 0.10 (or even 0.9.5 if you prefer @ntamas?), with an explicit flag for using degree or eccentricity. Now this is a boolean flag, but we should make it an enum for the public version, to allow for future flexibility.


I would like to say in the documentation that the automatic root selection heuristic may change without notice. This will allow us to make improvements in the future. Those who want a consistent drawing should specify the roots explicitly. I'm a bt undecided about this. Opinions @ntamas ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1836#issuecomment-963024486,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","More example layouts

Input graph:

Output:

Notice how 5, 6, 7 are all on a vertical line. Without curved edges, edges would overlap. This shows why this layout is not really suitable for anything else than trees.

A bunch of undirected and directed trees:


Same trees as above in undirected mode:


A bunch of very sparse DAGs. Again, this shows why this layout is not ideal for anything but a tree, not even for DAGs. Use Sugiyama for DAGs.


A bunch of almost-trees (small trees with 1-4 random edges added).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1836#issuecomment-963032386,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","Very nice, thanks for your hard work on this! I'll go through the code changes soon, but in the meanwhile the answers to the two questions:

root selection can become public; let's do it for 0.10 with a proper enum. (I'd prefer to keep changes in 0.9.x to a minimum because it is becoming harder to maintain both 0.9.x and 0.10 with all the changes from long int et al to igraph_integer_t).
Yes, please mention it in the documentation that we reserve the right to change the heuristic without notice, even between patch releases.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1836#issuecomment-963038152,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","One question only after having reviewed the changes: could we use coreness instead of eccentricity as an approximation? In the case of the Bethe lattice it would give identical results, but coreness is O(m) only.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/apps/codecov,7,https://github.com/igraph/igraph/pull/1836#issuecomment-963043978,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","Codecov Report

Merging #1836 (8745727) into master (c96c1be) will increase coverage by 0.00%.
The diff coverage is 96.87%.


@@           Coverage Diff           @@
##           master    #1836   +/-   ##
=======================================
  Coverage   72.43%   72.43%           
=======================================
  Files         295      295           
  Lines       57408    57450   +42     
=======================================
+ Hits        41583    41615   +32     
- Misses      15825    15835   +10     



Impacted Files
Coverage Δ





src/layout/reingold_tilford.c
96.30% <96.87%> (-0.15%)
⬇️


src/properties/degrees.c
82.58% <0.00%> (-4.50%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update c96c1be...8745727. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1836#issuecomment-963047859,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","One question only after having reviewed the changes: could we use coreness instead of eccentricity as an approximation? In the case of the Bethe lattice it would give identical results, but coreness is O(m) only.

The coreness is actually 1 for each vertex of the Bethe lattice, so this does not allow for distinguishing between them.

In the meantime, I realized that there is a much simpler way to think about root selection. A ""good"" set of roots is a minimal set of vertices so that the entire graph is reachable from them. That's all that's needed: reachability.  The rest is all about prioritization.
I updated the docs and tests, and need to leave for a couple of hours now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1836#issuecomment-963051177,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","The coreness is actually 1 for each vertex of the Bethe lattice

Oh sure, right; I was thinking about the iterative algorithm used to calculate coreness (i.e. mark all vertices with degree = 1 as being in core 1, remove them, rinse and repeat), but I didn't realize that you need to keep on going until all the remaining vertices have at least degree 2. Okay, let's leave it as is then, seems okay to me.
I won't merge it yet in case you still want to work on it when you come back, so give me the green light to merge when you are back.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1836#issuecomment-963053674,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.",I think it's good to go if you didn't notice any problems (or documentation typos).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1836#issuecomment-963055058,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.","Ah, one more thing:
Can you please FIRST merge master into develop (if needed), and only THEN merge this into master?
Then the next master -> develop merge will be easier. It will require updting to the integer-related changes",True,{}
igraph/igraph,https://github.com/igraph/igraph,1836,2021-11-08T10:21:07Z,2021-11-08T11:50:56Z,2021-11-08T11:51:05Z,MERGED,True,191,65,2,https://github.com/szhorvat,Re-work automatic root selection for Reingold-Tilford layout,5,[],https://github.com/igraph/igraph/pull/1836,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1836#issuecomment-963075317,"This PR improved automatic root selection for the Reingold-Tilford layout. The documentation and tests are not updated yet, but I'd like a review before I proceed. One test fails because the root selection has changed.
This is how the previous version worked:

Undirected: Choose the largest degree node from each connected component
Directed: Do a topological sort (only works if the graph is a DAG) and choose the first node in topological order from each weakly connected component.

Problems with the directed root selection:

It fails if the graph is not a DAG.
Even for a DAG, the root list would only be complete if it includes all source vertices (zero in-degree vertices). There may be more than one source vertex per weakly connected component, thus not all were selected.

This is how the new version works:

Directed: We break the graph into strongly connected components and find those components that have no incoming connections. One root will be chosen from each such component based on some ""prioritization"". If the graph is a DAG, this will simply select source vertices, regardless of prioritization (as each source vertex is a strongly connected component on its own).
Undirected: Select one root from each connected component based on the ""prioritization"".

I implemented two choices for prioritization:

Take the maximum degree (or out-degree) vertex. This is as before, and very fast.
Take a lowest eccentricity vertex. This is also called the graph center. This minimizes the number of levels in the tree drawing, and often leads to nice outcomes. The drawback is that it is slower than the Reingold-Tilford layout itself.

To balance performance with quality, I use eccentricity for less than 500 vertices and max degree otherwise.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/alexsyou,1,https://github.com/igraph/igraph/pull/1844,This pull request completes #1819.,This pull request completes #1819.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1844#issuecomment-968614341,This pull request completes #1819.,"Codecov Report

Merging #1844 (4f635dc) into develop (543a506) will increase coverage by 0.12%.
The diff coverage is 66.66%.


@@             Coverage Diff             @@
##           develop    #1844      +/-   ##
===========================================
+ Coverage    73.78%   73.90%   +0.12%     
===========================================
  Files          340      341       +1     
  Lines        57644    57660      +16     
===========================================
+ Hits         42530    42615      +85     
+ Misses       15114    15045      -69     



Impacted Files
Coverage Δ





src/core/progress.c
70.58% <ø> (ø)



...ee_sequence_vl/gengraph_graph_molloy_optimized.cpp
30.80% <0.00%> (ø)



src/linalg/blas.c
85.71% <ø> (ø)



src/math/bfgs.c
0.00% <0.00%> (ø)



.../degree_sequence_vl/gengraph_graph_molloy_hash.cpp
41.97% <20.00%> (ø)



src/constructors/generalized_petersen.c
89.47% <89.47%> (ø)



src/constructors/famous.c
72.00% <0.00%> (+1.33%)
⬆️


src/isomorphism/bliss/graph.cc
71.98% <0.00%> (+2.15%)
⬆️


src/community/walktrap/walktrap_communities.cpp
61.73% <0.00%> (+2.95%)
⬆️


vendor/plfit/plfit_error.c
36.36% <0.00%> (+7.79%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 543a506...4f635dc. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1844#issuecomment-968622996,This pull request completes #1819.,"In case it helps with writing a first test, this is the edge list of G(5,2), as generated with Mathematica. You can paste this directly into an igraph_small in the test program, then use an igraph_isomorphic for comparison.
{0, 2, 0, 3, 0, 5, 1, 3, 1, 4, 1, 6, 2, 4, 2, 7, 3, 8, 4, 9, 5, 6, 5, 9, 6, 7, 7, 8, 8, 9}",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1844#issuecomment-969314208,This pull request completes #1819.,Thanks! You'll also need to add the new function to one of the headers in include/; include/igraph_constructors.h seems to be the most natural choice.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/alexsyou,5,https://github.com/igraph/igraph/pull/1844#issuecomment-969757188,This pull request completes #1819.,"In the wiki, Step 7 it describes adding the function name to interfaces/functions.def. I cannot find that particular file, so is there somewhere else the function name should be added?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1844#issuecomment-970041324,This pull request completes #1819.,"Sorry, this file is now called functions.yaml in the develop branch and it is a standard YAML-formatted file. I'll update the wiki page.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1844#issuecomment-970055221,This pull request completes #1819.,"Updating this file is a minor thing that does not affect the functionality of the C library, and I think we can leave it until the end.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1844#issuecomment-970615821,This pull request completes #1819.,Let us know when this is ready for review.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1844#issuecomment-970626997,This pull request completes #1819.,"Let me also suggest a few more test cases. G(10,2) should be isomorphic to igraph_famous(""Dodecahedral""). Since I forgot that 5,2 is in igraph_famous, let me give you another edge list for 4,2 instead:
{0, 2, 0, 4, 1, 3, 1, 5, 2, 6, 3, 7, 4, 5, 4, 7, 5, 6, 6, 7}

Why do we want to restrict k to at most (n-1)/2? For even n, k = n/2 also seems useful.
We can consider if we should have a limit on k at all. Perhaps it's good to have a limit because when k is a multiple of n, we would get self-loops, which is unexpected. Other large values of k are harmless but redundant. Because of the possibility of self-loops, I agree that it's good to have an upper limit.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/alexsyou,10,https://github.com/igraph/igraph/pull/1844#issuecomment-970688937,This pull request completes #1819.,"Thank you for the extra test cases, I was lacking in ideas for them!
k=(n-1)/2 was an accident, it should be k=n/2 for both even and odd n. The limit on k was placed solely because the sources I found (1, 2) placed constraints on k. However, looking at Watkins's original paper (3), k is constrained by 1 and n-1. I think we should constrain it by n-1.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/alexsyou,11,https://github.com/igraph/igraph/pull/1844#issuecomment-970833842,This pull request completes #1819.,"When I test isomorphism for igraph_famous(""dodecahedron""), I get an error that the Dodecahedron graph is a multigraph, and therefore I cannot check for isomorphism. However, the Dodecahedron graph is not a multigraph.
Error message: Error at src/isomorphism/queries.c:110 : Isomorphism testing is not implemented for multigraphs - Unimplemented function call.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1844#issuecomment-971324987,This pull request completes #1819.,I strongly suspect that the new igraph_generalized_petersen() graph constructed a multigraph somehow and that's why you ended up with the error. Check the edge list of the generated graph (you can use print_graph() from tests/unit/test_utilities.inc for that).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1844#issuecomment-971410529,This pull request completes #1819.,"Here's a tip:
When there's a test failure, look at the linux_static_vendored test on Azure. It will often show a stack trace.
https://dev.azure.com/igraph-team/igraph/_build/results?buildId=1713&view=logs&j=4c3a8381-b9de-5463-904f-918810769be8&t=a906eab8-d2a3-5e54-d199-606dbbfb0805&l=235
We should document this in the wiki. It tells us that it's the second test case that fails, not the third.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1844#issuecomment-971422805,This pull request completes #1819.,"So it looks like we discovered what is wrong with allowing k up to n-1: if 2k = n then we'll get multi edges from i -- (i+k) % nconnections. In fact, Watkins explicitly disallows 2k = n.
This was my mistake when giving you the example, as I just naively generated a graph with Mathematica and took the edge list, without looking carefully.
Now we need to decide whether it is worth allowing this special case for generality, or if it's better to exclude it to make sure that the resulting graph really has all the properties that are described in the literature for ""generalized Petersen graphs"".
I'll have a look at what other systems do with this case.",True,{'THUMBS_UP': ['https://github.com/alexsyou']}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1844#issuecomment-971434142,This pull request completes #1819.,"Maple: requires 0 < k < n/2
networkx: not available
Mathematica: requires n >= 3, k > 0, but has no upper limit on k. If n = 2k, it simplifies multi-edges. If k = m*n, it keeps self-loops. I don't like this.
Sage: limits to k < n/2
Magma: doesn't implement it

I would go with limiting to 0 < k < n/2
Sorry about the confusion.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1844#issuecomment-971437994,This pull request completes #1819.,"Here's a replacement test case for 9,3:
0, 3, 0, 6, 0, 9, 1, 4, 1, 7, 1, 10, 2, 5, 2, 8, 2, 11, 3, 6, 3, 12, 4, 7, 4, 13, 5, 8, 5, 14, 6, 15, 7, 16, 8, 17, 9, 10, 9, 17, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17

On a related note, in the docs you write that there is an inner ""star graph"". I see why, since it has the shape of a star. But ""star graph"" means something different: https://en.wikipedia.org/wiki/Star_(graph_theory)
The inner graph is in fact either a single cycle as well, or as many cycles as the greatest common divisor of n and k. In the above example that's 3.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1844#issuecomment-971447118,This pull request completes #1819.,Added more tips here: https://github.com/igraph/igraph/wiki/How-to-write-unit-tests%3F#debugging-tips,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/alexsyou,18,https://github.com/igraph/igraph/pull/1844#issuecomment-971636967,This pull request completes #1819.,"The debugging tips are very helpful, thanks! The function should be ready for review now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/ntamas,19,https://github.com/igraph/igraph/pull/1844#issuecomment-971646063,This pull request completes #1819.,"LGTM, but please rename generalized-petersen.c  to generalized_petersen.c (note the underscore) to be consistent with the naming of other files.
Let's wait for the green light from @szhorvat and then this can be merged. Thanks a lot!",True,{'THUMBS_UP': ['https://github.com/alexsyou']}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1844#issuecomment-971743154,This pull request completes #1819.,"I'll make a few small nitpick edits I and will merge this tomorrow.
Thanks for all your work on this @alexsyou !",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1844#issuecomment-972141201,This pull request completes #1819.,"Sorry, I had to leave right after I broke things. I want to clarify the docs a bit and will merge after that, probably tomorrow evening.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/alexsyou,22,https://github.com/igraph/igraph/pull/1844#issuecomment-972333270,This pull request completes #1819.,Thanks for guiding me through this process!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1844#issuecomment-972959559,This pull request completes #1819.,"Thanks for your help with this @alexsyou ! If you are looking to do something similar in the future, you can give circulant graphs a try:
https://mathworld.wolfram.com/CirculantGraph.html
https://en.wikipedia.org/wiki/Circulant_graph",True,"{'THUMBS_UP': ['https://github.com/vtraag', 'https://github.com/alexsyou']}"
igraph/igraph,https://github.com/igraph/igraph,1844,2021-11-15T03:41:53Z,2021-11-18T15:13:27Z,2021-11-25T11:15:39Z,MERGED,True,199,17,14,https://github.com/alexsyou,Generalized Petersen constructor,32,[],https://github.com/igraph/igraph/pull/1844,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1844#issuecomment-979105419,This pull request completes #1819.,"@alexsyou The circulant graphs work has been taken by another beginner contributor. If you are interested in further contributions, let us know, and we can find something more interesting for you. Simple tasks like the generalized Petersen and circulant constructors are good for learning the very basics of igraph. Now that you are past that, you are ready for more complex tasks.
I have several ideas for new features and improvements, but not everything has been written up as a feature request issue yet. If you'd like to contribute more, let us know what sorts of tasks you are interested in, and we can find something suitable.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1848,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1848#issuecomment-970657849,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","Codecov Report

Merging #1848 (454ad50) into master (c5e7cf9) will increase coverage by 0.00%.
The diff coverage is n/a.


❗ Current head 454ad50 differs from pull request most recent head 15bdbd1. Consider uploading reports for the commit 15bdbd1 to get more accurate results


@@           Coverage Diff           @@
##           master    #1848   +/-   ##
=======================================
  Coverage   72.43%   72.43%           
=======================================
  Files         295      295           
  Lines       57450    57450           
=======================================
+ Hits        41613    41615    +2     
+ Misses      15837    15835    -2     



Impacted Files
Coverage Δ





src/core/vector.pmt
86.81% <0.00%> (+0.23%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update c5e7cf9...15bdbd1. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/1848#issuecomment-970677439,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","Thanks @vtraag, overall in favour. Just suggested a few minor wording things.
I'd be happy with merging ""help welcome"" into ""PR welcome"". To me, that means that we think the issue is appropriate for an external user to touch - as opposed to core issues that we don't really want to delegate outside. We could have a ""core team"" label to signify the opposite: we don't want people to mess with it. We could also start something like an expected difficulty ladder, e.g. ""easy"", ""moderate"", ""hard""?
Shall we also migrate the wiki pages onto igraph.org? That's be a good excuse to improve the website and unify information.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1848#issuecomment-971347465,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem?

Yes, that's a good idea, we can do that.

We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined.

Sure, we can do that. Many of the labels are not used / obsolete now, in fact some of these labels were migrated from Launchpad when we've had igraph's bug tracker there, way before the Github days. (We even used GNU arch as the version control system at one point, after migrating from SVN, before migrating to Git).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1848#issuecomment-971349659,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","Shall we also migrate the wiki pages onto igraph.org?

Actually, I like it that we can easily edit the wiki without jumping through hoops with the igraph.org repo so I'd rather leave it there.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1848#issuecomment-971363366,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","I was already happy with it as it was, I just made a few small suggestions. Up to you if you act on them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1848,2021-11-16T20:32:09Z,2021-11-17T09:14:18Z,2021-11-18T09:13:27Z,MERGED,True,95,53,1,https://github.com/vtraag,Update CONTRIBUTING.md,5,[],https://github.com/igraph/igraph/pull/1848,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1848#issuecomment-972674309,"I went over our existing CONTRIBUTING.md, and I thought it could use some updating. In particular, I thought it would be good to mention that people can also contribute to the project in other ways than reporting bugs and opening pull request. In particular, I also wanted to clarify to people that help on the support forum and on improving the documentation is helpful.
One other suggestion that I now make is that people can go over existing issues to see if they can help out. Some issues on documentation may be good starting points if people want to contribute, but don't necessarily want to delve intro coding. Some other possibilities would be to just go over some open issues that are already open for a long time and see if they are still relevant.
I was thinking that it might perhaps be good to have a label for something like ""replication needed"", so that people can help out by trying to replicate some problem? In addition, we might perhaps clean up a bit our labelling. We now have ""help wanted"", ""PR welcome"", perhaps they can simply be combined. But I also wonder: do they actually signify something useful?
In addition, I made some of the language is bit friendlier (or what I would perceive as friendlier) and a bit more welcoming.
This may need some polishing still, feel free to make suggestions!","Thanks for the additional improvements! And, yes, better indeed to remove interactive rebasing.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1853,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1853#issuecomment-974682625,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Codecov Report

Merging #1853 (d15c9c6) into master (1eb9a0c) will increase coverage by 0.01%.
The diff coverage is 100.00%.


@@            Coverage Diff             @@
##           master    #1853      +/-   ##
==========================================
+ Coverage   72.44%   72.45%   +0.01%     
==========================================
  Files         295      295              
  Lines       57447    57471      +24     
==========================================
+ Hits        41615    41641      +26     
+ Misses      15832    15830       -2     



Impacted Files
Coverage Δ





src/community/label_propagation.c
92.94% <100.00%> (+2.79%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1eb9a0c...d15c9c6. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1853#issuecomment-974685539,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","@ntamas If you're happy with this, I'll also remove the At least one vertex must be labeled in the initial labeling. error, as with this fix it's not really needed. Also, it's not really meaningful. The true requirement is that ""all unlabelled vertices should be reachable from some labelled vertex"", which reduces to ""at least one vertex must be labelled in each connected component"" in the undirected case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1853#issuecomment-974789651,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Okay, I read #1852 first and then this one, and I noticed that the questions I raised in #1852 were decided one way or another in this PR, and that the case of directed graphs was also handled. I'll review this PR tomorrow and then get back to you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1853#issuecomment-974870101,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Let me answer here.

However, I wonder whether the vertices that remain unlabelled at the end may be of interest to anyone.

So the question is: should we fix this at all? Reasons to fix it:

It is fairly trivial which vertices remain unlabelled. It is those that are not reachable from labelled ones. This is almost easy to compute with subcomponent(). See also #1854. You already mention this yourself.
If we allow unlabelled vertices to pass through, then we should not call the output a ""membership vector"", otherwise the expectation is that it is usable wherever membership vectors are appropriate. See how calling modularity() failed here. People usually want a usable ""community/cluster object"" in high-level interfaces, and such an incomplete membership vector will be difficult to tack onto existing community representations without breaking stuff.



and this may potentially change a near-linear time algorithm to the complexity of the connected component search

Finding connected components is also linear time, but it may still have a measurable impact on the performance of this function. This is why in this PR I didn't run a full decomposition. I just traversed the unlabelled parts of the graph, to waste as little CPU time as possible.


So, the way I see it, we have three options:

I prefer option 1. It is nice because:

In the undirected case, it is equivalent to adding precisely one label to each connected component and re-running label propagation. The end result does not depend on which node gets labelled.
The function will return a standard community structure which is usable with all compatible functions (modularity, compare_communities, plotting functions, etc.)
There is no real performance penalty. I believe that with this PR, the performance will not be worse compared to as if each component had labelled nodes.

However, there is a problem: In the directed case, the behaviour is not as nice. Just adding a label to an unlabelled node and re-running the full label propagation would not necessarily give the same result as my PR does. Unlike in the undirected case, it does matter which node gets the label. On the other hand, the documentation already says that ""The input graph, should be undirected to make sense."" Does label propagation, as implemented here, make sense at all for the directed case? There are papers on this from as recently as 2019, which suggests that this is not a simple question. Do we have time to dig into this now? (I don't.)
Option 2:
I don't like this because it produces a result that is not usable as a standard community structure with other parts of the library. I don't know how I would tack this into the Mathematica interface ...
Option 3:
I don't like this because it is limiting possibilities for no good reason. I would rather use the current PR and issue a warning (not an error).


So maybe we should decompose the graph into connected components first, run the algorithm component-by-component, and then unify the result into a consistent membership vector in the end?

This is not necessary because the the algorithm already effectively handles components separately.

Summary
I think that the solution in this PR is very nice for undirected graphs.
But I worry about directed graphs. This solution is not well-founded for that case, but I also don't know what a well-founded solution would be, even ignoring performance implications. Even if we were to choose some nodes to auto-label, and re-run the whole algorithm, I don't know which nodes we should choose.
In fact, I don't know if this algorithm leads to meaningful results at all in the directed case.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1853#issuecomment-974876893,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Assuming that we go ahead with this PR, three questions:

Do we remove the error when no labels are given? (I propose yes.)
Do we add a warning for the directed case? (I propose yes, but I do think it's a bit strange to have a feature but also warn about using it ...)
Do we add a warning when unlabelled nodes remain?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1853#issuecomment-975489342,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Okay, read the PR and the discussions once again; I think we should:

go ahead with the PR
I wouldn't add a warning to the directed case, it's already in the docs and as you mentioned, it would be strange to print a warning explicitly
no warning for unlabeled nodes -- if I understand correctly, this PR will ensure that each node would get some label in the end (and it is also deterministic for the undirected case, which is what we are primarily interested in)

I'd probably expand the docs and explain that new labels may be created by the algorithm if there are unlabeled nodes at the end. We should ensure that these are easy to recognize; for instance, they should always be larger than max(initial_labels). End users who care about these labels should then check the membership vector and look for unexpectedly large values.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1853#issuecomment-975501488,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","When reading this PR, I realized that we do a re-labeling of nodes at the end such that there are no ""empty"" clusters. I don't know whether this is good or bad; I could argue for both

On one hand, this makes the results easier to interpret for the naked eye.
Also, if there are, say, 200 nodes in the graph but only two significant clusters, it is quite random which of the original labels end up dominating the graph; all that matters is that there are two labels in the end, so it makes sense to return a membership vector that looks like [lots-of-zeros, lots-of-ones] instead of [lots-of-X, lots-of-Y] where X and Y are arbitrary integers. This also helps in finding consensus clusterings when the algorithm is executed many times and the results are averaged.
On the other hand, this is problematic if there are initial labels and they have some kind of semantic meaning to the user who calls the function; e.g., the user may have six categories and decide to use categories 4, 5 and 6 as initial labels, intentionally leaving categories 1, 2 and 3 unused in the initial labeling. If this happens, we re-write the labels at the end so the final membership vector ends up containing labels 1, 2 and 3 instead of 4, 5 and 6, and the user needs to figure out which of the original labels that they assigned ended up at which final label.

We shouldn't do anything about this in this PR, but maybe it's a good candidate for an API-breaking change in 0.10 where we could introduce an additional argument that specifies whether to ""canonicalize"" the membership vector at the end? Or maybe we shouldn't canonicalize at all and just provide a function that reassigns items in an arbitrary membership vector such that there are no empty clusters any more?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1853#issuecomment-975504696,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.",Waiting for CI to pass and then I'll merge. Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1853#issuecomment-975531941,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","When reading this PR, I realized that we do a re-labeling of nodes at the end such that there are no ""empty"" clusters. I don't know whether this is good or bad; I could argue for both

I noticed the same and I also wondered if keeping the original labels would have been good ...
Do any membership-handling functions expect that cluster labelling is contiguous? Hopefully not.
Thanks for merging!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1853#issuecomment-975535514,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","where we could introduce an additional argument that specifies whether to ""canonicalize"" the membership vector at the end?

We could even have a separate function for canonicalizing membership vectors.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1853#issuecomment-975537765,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Do any membership-handling functions expect that cluster labelling is contiguous?

I don't think so; however, they could do something like allocating a vector whose length is equal to the maximum cluster index plus one, in which case one could run into problems if arbitrary integers are used. In such cases it would be advisable to canonicalize the membership vector first.
Actually, we do have such a function: igraph_reindex_membership().",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/lovre,13,https://github.com/igraph/igraph/pull/1853#issuecomment-976449485,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Regarding applying label propagation to directed networks, in our chapter, we have written:
""...there seem to be no straightforward extension to networks with directed arcs. The reason for this is that propagating the labels exclusively in the direction of arcs enables exchange of labels only between mutually reachable nodes forming a strongly connected component. Since any directed network is a directed acyclic graph on its strongly connected components, the labels can propagate between the nodes of different strongly connected components merely in one direction. Therefore, one usually disregards the directions of arcs when applying the label propagation method to directed networks except in the case when most arcs are reciprocal.""
As far as I know, there is no straightforward extension of label propagation to directed networks. Any such paper either changes the optimization function (e.g. to modularity) or the definition of community (e.g. flow communities).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/1853#issuecomment-976573771,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Thanks for sharing @lovre! Given what he writes, wouldn't it make more sense then perhaps to limit the label propagation to undirected graphs only, @ntamas and @szhorvat ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1853#issuecomment-976603084,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","I propose this:

In 0.9, there should be a warning when the input is directed. ""The result is not meaningful for directed input.""
In 0.10, we can ignore edge directions, and show a different warning: ""Edge directions are ignored."" We might remove that warning in some future version.

My only concern is that the functionality is already implemented, the mechanism is straightforward and easy to understand (even if its outcome isn't always useful). Why not let people experiment if they want to? @lovre, do you think there's value in keeping it in some form? Is there any reasonable application (even if not for standard community detection)?
@lovre Since you are deeply familiar with the method, I am wondering if you'd have the time to improve our documentation a bit. Ideally, there would be a bit of high-level guidance in the docs about when it is or isn't reasonable to use a given method. I like documentation that is also educational. If you could provide a short paragraph here on GitHub, I'd be grateful (and I'd integrate it into the docs). Of course, I understand if you don't have the time for this, and I am not really expecting anything.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1853#issuecomment-976607144,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Here's a small experiment where I generated a graph from an SBM and took the largest strongly connected component.  When ignoring edge directions, I typically get results like these:



When directions into account,",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/lovre,17,https://github.com/igraph/igraph/pull/1853#issuecomment-976671277,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","@szhorvat, it probably makes sense to allow the user to propagate the labels only in the direction of the edges. But, if I would be implementing this, I would only include this as an option/parameter that the user must set explicitly. Otherwise, I would ignore the directions and output a warning that the input graph is treated as undirected. This is how I have always implemented it in the past. In other words, I do not even understand what kind of clusters one should expect under ""directed"" propagation. I believe that the experiments above confirm this.
Let me keep this message in my inbox and I will try to get back to it in December. I am currently spending more than 15 hours per week in the classroom and I have very limited time for anything else. I expect that we will be in lockdown starting with December, when I will have more time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/1853#issuecomment-976697144,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","In 0.9, there should be a warning when the input is directed. ""The result is not meaningful for directed input.""

That's probably too harsh; I mean, if the graph is strongly connected, then the result could be meaningful, or at least it's not less meaningful than trying to apply any other community detection algorithm on a directed graph. In my head, the very notion of communities in a directed graph is not as clear-cut as in undirected graphs so some ambiguity is expected. It is the responsibility of the user to interpret the results, but it is nevertheless a good idea to provide a parameter that allows the user to decide whether edge directions should be taken into account or not. Most other igraph functions do this as well, either with an igraph_bool_t directed argument or an igraph_neimode_t mode argument (which also allows to consider the edges in reverse).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1853#issuecomment-976737640,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.","Writing from a train so I'm brief...

Let's do a mode argument for 0.10, and add a note to the docs that high
level interfaces are recommended to use ALL by default unless explicitly
setting IN or OUT.

Let's leave 0.9 as it is now on master.

Agreed?
…
--
sent from a phone
On Tue, 23 Nov 2021, 16:16 Tamás Nepusz, ***@***.***> wrote:
 In 0.9, there should be a warning when the input is directed. ""The result
 is not meaningful for directed input.""

 That's probably too harsh; I mean, if the graph is strongly connected,
 then the result *could* be meaningful, or at least it's not less
 meaningful than trying to apply any other community detection algorithm on
 a directed graph. In my head, the very notion of communities in a directed
 graph is not as clear-cut as in undirected graphs so some ambiguity is
 expected. It is the responsibility of the user to interpret the results,
 but it is nevertheless a good idea to provide a parameter that allows the
 user to decide whether edge directions should be taken into account or not.
 Most other igraph functions do this as well, either with an igraph_bool_t
 directed argument or an igraph_neimode_t mode argument (which also allows
 to consider the edges in reverse).

 —
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#1853 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJIDR4XQIK6MKPXLKXTE6LUNOV57ANCNFSM5IOFCRZA>
 .",True,"{'THUMBS_UP': ['https://github.com/vtraag', 'https://github.com/ntamas']}"
igraph/igraph,https://github.com/igraph/igraph,1853,2021-11-20T17:20:31Z,2021-11-22T13:25:13Z,2021-11-23T20:50:46Z,MERGED,True,132,6,4,https://github.com/szhorvat,fix: community_label_propagation should not return unlabelled nodes,2,[],https://github.com/igraph/igraph/pull/1853,https://github.com/ntamas,20,https://github.com/igraph/igraph/pull/1853#issuecomment-977158788,"Fixes #1852.
In summary, the problem was that if:

an initial labelling was given.
some nodes were unlabelled, and not reachable from any labelled nodes.
then -1 values (representing no labelling) were returned in the membership vector.

This causes trouble for the end user because it's unexpected, and causes trouble within the function because the -1 values are sent for modularity calculation, which then errors.
The fix used here is the following:
After label propagation is done, find the first unlabelled node. Assign a new label to it, and propagate the same label to all other unlabelled nodes reachable from it. In the directed case, this is a bit messy because the result depends on the node ordering. We randomize the node ordering to be consistent with what is done within the main label propagation algorithm. The undirected case is simpler: the only way we can end up with unlabelled nodes at the end is if an entire connected component was unlabelled from the beginning. Then we just label by connected components.",I'll do it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/Gomango999,1,https://github.com/igraph/igraph/pull/1856,"This pull request implements the circulant graph constructor, as requested in #1851.","This pull request implements the circulant graph constructor, as requested in #1851.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1856#issuecomment-977867957,"This pull request implements the circulant graph constructor, as requested in #1851.","Great stuff, there's a lot of little things you've done right which we now don't have to worry about anymore :)
Don't forget to add the function to doc/generators.xxml, then the documentation will be included.",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/1856#issuecomment-977872722,"This pull request implements the circulant graph constructor, as requested in #1851.","Codecov Report

Merging #1856 (3158a18) into develop (e2eb09d) will increase coverage by 0.01%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #1856      +/-   ##
===========================================
+ Coverage    73.92%   73.93%   +0.01%     
===========================================
  Files          341      342       +1     
  Lines        57693    57723      +30     
===========================================
+ Hits         42647    42677      +30     
  Misses       15046    15046              



Impacted Files
Coverage Δ





src/constructors/circulant.c
100.00% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update e2eb09d...3158a18. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/Gomango999,4,https://github.com/igraph/igraph/pull/1856#issuecomment-978895935,"This pull request implements the circulant graph constructor, as requested in #1851.","Just added some basic tests, planning to add some more when I get time. I was wondering whether it is possible to test for invalid inputs which call IGRAPH_ERRORF? For example, testing that my program correctly errors when a negative value for n is given.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1856#issuecomment-978950502,"This pull request implements the circulant graph constructor, as requested in #1851.","I was wondering whether it is possible to test for invalid inputs which call IGRAPH_ERRORF?

tests/unit/test_utilities.inc includes a handy helper macro called CHECK_ERROR; see, e.g., the igraph_sbm_game.c test case for usage hints.",True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1856#issuecomment-978968424,"This pull request implements the circulant graph constructor, as requested in #1851.",Don't worry about the CI failures; the one on Alpine Linux seems to be unrelated and the MINGW/ucrt-x86_64 test case sometimes fails randomly in the glpk_error test case (see #1850) and we haven't figured out yet why.,True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1856#issuecomment-979060689,"This pull request implements the circulant graph constructor, as requested in #1851.",You can now rebase the PR on develop to get the whitespace issue fixed.,True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/Gomango999,8,https://github.com/igraph/igraph/pull/1856#issuecomment-979169915,"This pull request implements the circulant graph constructor, as requested in #1851.","Ok I've both reverted the commit as well as rebased, so as to avoid any merge conflicts. I've also added some extra tests for invalid values of n, and made the corrections to style.  Please let me know if there's anything else!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1856#issuecomment-979783120,"This pull request implements the circulant graph constructor, as requested in #1851.",Alpine Linux build problems fixed on develop; I guess there's no need to rebase if the tests pass in all other environments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1856#issuecomment-979806321,"This pull request implements the circulant graph constructor, as requested in #1851.","Thanks @Gomango999, excellent work on this!",True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1856,2021-11-24T08:28:16Z,2021-11-26T09:07:48Z,2021-11-26T13:29:49Z,MERGED,True,286,0,6,https://github.com/Gomango999,Circulant Graph Constructor,15,[],https://github.com/igraph/igraph/pull/1856,https://github.com/Gomango999,11,https://github.com/igraph/igraph/pull/1856#issuecomment-979979655,"This pull request implements the circulant graph constructor, as requested in #1851.","And thanks for all the support and reviews from you and everyone else during the process! I have exams coming up soon so it might be a while, but I will definitely be returning :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1858,2021-11-28T14:17:40Z,2021-11-28T14:17:52Z,2021-11-28T14:17:52Z,CLOSED,False,84,0,5,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,1,[],https://github.com/igraph/igraph/pull/1858,https://github.com/YuliYudith,1,https://github.com/igraph/igraph/pull/1858,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,1,https://github.com/igraph/igraph/pull/1859,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1859#issuecomment-981094943,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Great to see your PR draft 🙂 I have a few remarks, but it's a good start!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,3,https://github.com/igraph/igraph/pull/1859#issuecomment-981097110,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Yes, please! What are your remarks?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1859#issuecomment-981137399,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,Did you see my review above?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,5,https://github.com/igraph/igraph/pull/1859#issuecomment-981137886,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"No. Where can I find it? I thought, I would be notified if someone reviewed the code but I got no notification.
Could you send me a link to the review?
Thanks for your support!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1859#issuecomment-981138675,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Did you see my review above?

I guess you need to submit the review explicitly when using the standard review mechanism on Github.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1859#issuecomment-981139570,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Did you see my review above?

I guess you need to submit the review explicitly when using the standard review mechanism on Github.

Aha! I'm still learning how github works 😬 I'm sorry for the confusion and delay, @YuliYudith, but now my review should be visible.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,8,https://github.com/igraph/igraph/pull/1859#issuecomment-981139827,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Thank you very much, will fix immediately.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1859#issuecomment-981582022,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"As you've probably noticed, your current approach to the algorithm seems to require an unbounded amount of for loops, which will be impossible to implement. Try to make it all work within a single loop over the 'branch_level' vector.
Maybe you can write what should happen for every level in pseudocode first.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,10,https://github.com/igraph/igraph/pull/1859#issuecomment-982430735,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"As you've probably noticed, your current approach to the algorithm seems to require an unbounded amount of for loops, which will be impossible to implement. Try to make it all work within a single loop over the 'branch_level' vector.

Yes, I wrote in the commit message that we are trying the shameless green approach. It's a purely test driven development. Since we started with only one test - the one from the ticket - we implemented the function in such a way that the test resolves as green - and ONLY this test.
We will - and already have - added other tests for which our implemented function will fail and we have to adapt the way of our implementation.
Using this open source project is our way to learn this way of implementation as we're fairly new to the concept. I hope, nobody minds.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1859#issuecomment-982474607,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Ah, yes I see it in your commit message. I think it can be a good way to explore the problem if you're prepared to rewrite everything.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/apps/codecov,12,https://github.com/igraph/igraph/pull/1859#issuecomment-985012365,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Codecov Report

Merging #1859 (84489cb) into develop (1d8f432) will decrease coverage by 0.05%.
The diff coverage is 96.55%.


@@             Coverage Diff             @@
##           develop    #1859      +/-   ##
===========================================
- Coverage    73.93%   73.87%   -0.06%     
===========================================
  Files          342      342              
  Lines        57723    57765      +42     
===========================================
- Hits         42677    42676       -1     
- Misses       15046    15089      +43     



Impacted Files
Coverage Δ





src/constructors/regular.c
86.31% <96.55%> (+1.84%)
⬆️


src/math/utils.c
23.68% <0.00%> (-50.00%)
⬇️


src/core/error.c
76.47% <0.00%> (-1.85%)
⬇️


src/random/random.c
60.78% <0.00%> (-0.29%)
⬇️


vendor/plfit/plfit.c
58.25% <0.00%> (-0.22%)
⬇️


src/games/tree.c
93.87% <0.00%> (ø)



src/connectivity/components.c
94.07% <0.00%> (ø)



src/layout/fruchterman_reingold.c
48.09% <0.00%> (+0.16%)
⬆️


src/community/label_propagation.c
93.10% <0.00%> (+1.12%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1d8f432...84489cb. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1859#issuecomment-985322881,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Tiny nitpick: the singular of ""vertices"" is ""vertex"".",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,14,https://github.com/igraph/igraph/pull/1859#issuecomment-985331752,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Since a review necessarily focuses on things that should be changed (and makes me sound grumpy), I just want to say you're doing great work, your algorithm is extremely elegant, and this stuff is all really hard to get right when working on a new project.",True,"{'THUMBS_UP': ['https://github.com/szhorvat'], 'HEART': ['https://github.com/YuliYudith']}"
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,15,https://github.com/igraph/igraph/pull/1859#issuecomment-988805478,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,I think you're almost done :) Do you want to set it as 'ready for review' so it's not a draft anymore?,True,"{'ROCKET': ['https://github.com/szhorvat'], 'THUMBS_UP': ['https://github.com/YuliYudith']}"
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1859#issuecomment-989805981,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"After this is done, would you like to contribute another function called igraph_regular_tree which produces a ""Bethe lattice"" with the same degree at every level, except at the leaves?
Possible prototype:
igraph_error_t igraph_regular_tree(igraph_integer_t levels, igraph_integer_t k);

levels is the number of level and k is the degree. You can add a tree mode argument too if you like. This would be a convenience wrapper function for igraph_symmetric_tree.",True,{'THUMBS_UP': ['https://github.com/YuliYudith']}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1859#issuecomment-989812557,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"For your entertainment, a degree-4 regular tree, laid out in 3D with igraph.",True,{'HEART': ['https://github.com/YuliYudith']}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,18,https://github.com/igraph/igraph/pull/1859#issuecomment-989830299,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,With which tool did you plot this? It looks very cool.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1859#issuecomment-989840562,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"With Mathematica. I maintain igraph's interface to Mathematica, called IGraph/M.  The layout is computed with igraph, but turning it into rotatable 3D graphics relies on Mathematica.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1859#issuecomment-989875783,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Careful with the find-and-replace: all instances of the word ""vertices"" was changed in the file.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1859#issuecomment-991967342,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Great job on this! The edits I made are mostly just renaming. The one thing to pa attention to is adding the function to the docs.
@GroteGnoom feel free to merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1859#issuecomment-991970625,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"@YuliYudith Would you like to add an igraph_regular_tree() function based on igraph_symmetric_tree(), as I outlined above?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/GroteGnoom,23,https://github.com/igraph/igraph/pull/1859#issuecomment-991971118,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"@YuliYudith Thanks for all you work :) Contributing on a new project is really hard, but you kept communicating and working on it so it kept going in the right direction.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1859#issuecomment-991971200,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"@YuliYudith Also, with what name would you like to be credited in the changelog? Let me know if you'd like me to use a different name than your GitHub username.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,25,https://github.com/igraph/igraph/pull/1859#issuecomment-991971999,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"@szhorvat Yes, I would like to write that function and will follow the same procedure as before and create a PR draft igraph_regular_tree().
My github name is fine as credit but as I didn't do it alone, I would ask if my partner could receive credit as well. I will ask for the github name and come back to you.
Edit: GitHub name of my partner is @DoruntinaM
@GroteGnoom Thank you very much for your on going support and helpful, timely feedback. It was a pleasure programming that function and I had a great time donig it. It was indeed a very good issue for starters. Thanks for making us feel so welcome in this community.",True,{'ROCKET': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,26,https://github.com/igraph/igraph/pull/1859#issuecomment-997065099,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"Add to the changelog now. I did not notice your edit with your partner's username until today, when I came to ask you about it. Looking forward to igraph_regular_tree()!
Since now you know the basics of igraphs, you can also try to tackle more involved tasks. If you don't find anything interesting in the issue tracker, we can devise a new task of suitable difficulty.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1859#issuecomment-1014234953,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"@YuliYudith Happy new year! I was just wondering if you are still interested in adding igraph_regular_tree().
If you are looking for a different sort of challenge, there are also issues for creating educational examples:

#1931
#1585

You may this more interesting, as it gives room for creativity and doing things your own way.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/YuliYudith,28,https://github.com/igraph/igraph/pull/1859#issuecomment-1017538134,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,@szhorvat I haven't forgotten at all and it's on my To Do list but I'm in my last pregnancy month and have to prepare a lot of stuff. I planned on doing it at the end of January.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1859,2021-11-28T14:18:06Z,2021-12-12T21:06:37Z,2022-01-20T22:38:29Z,MERGED,True,455,1,7,https://github.com/YuliYudith,Add skeleton for symmetric tree implementation and test files,16,[],https://github.com/igraph/igraph/pull/1859,https://github.com/szhorvat,29,https://github.com/igraph/igraph/pull/1859#issuecomment-1017988217,Created a skeleton to start implementing the symmetric tree feature request in ticket #1841,"@YuliYudith Congratulations! It sounds like exciting times, and very busy days are ahead of you.
Whether you want to do it yourself or not is entirely up to you. Thus, feel absolutely no pressure from us. I was asking only to know whether you would prefer that we reserve this task for you. If you want to do it, there is no rush. Just let us know. However, it seems like you have different priorities right now, so perhaps you don't want extra things on your todo list?
If you'd like to contribute more to igraph some months or a year later, you are very welcome to do so. There always tasks to do, at all experience levels. So don't worry, you won't lose any opportunities if you put this project aside right now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1860,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,2,https://github.com/igraph/igraph/pull/1860#issuecomment-983506831,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",Thank you!!! So excited to see this happening! Let me know if I can help!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1860#issuecomment-983836949,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Thanks for your comments @iosonofabio, I will look a bit more at them tomorrow :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/apps/codecov,4,https://github.com/igraph/igraph/pull/1860#issuecomment-987893744,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Codecov Report

Merging #1860 (efca584) into develop (aeef5ed) will increase coverage by 0.08%.
The diff coverage is 94.50%.


@@             Coverage Diff             @@
##           develop    #1860      +/-   ##
===========================================
+ Coverage    77.47%   77.55%   +0.08%     
===========================================
  Files          361      362       +1     
  Lines        58507    58798     +291     
===========================================
+ Hits         45328    45603     +275     
- Misses       13179    13195      +16     



Impacted Files
Coverage Δ





src/layout/fruchterman_reingold.c
48.09% <ø> (ø)



src/layout/umap.c
94.50% <94.50%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update aeef5ed...efca584. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1860#issuecomment-988586736,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","(I'm now reading the paper a bit more, which clears things up. )
They use spectral embedding to get an initial layout. Shall we use our spectral embedding or avoid it?
I first encountered some problems with it here: https://igraph.discourse.group/t/the-unit-tests-thread/597/48
Umap could be a reason to look a bit more at spectral embedding, test it, use it, and fix it. But right now I believe nobody is an expert on this, so it will be hard to fix and maintain.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,6,https://github.com/igraph/igraph/pull/1860#issuecomment-988588443,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","(I'm now reading the paper a bit more, which clears things up. ) They use spectral embedding to get an initial layout. Shall we use our spectral embedding or avoid it? I first encountered some problems with it here: https://igraph.discourse.group/t/the-unit-tests-thread/597/48 Umap could be a reason to look a bit more at spectral embedding, test it, use it, and fix it. But right now I believe nobody is an expert on this, so it will be hard to fix and maintain.

I'd be in favour of not caring about spectral embedding for now - as far as this PR is concerned. Sure, minimization will take a little longer, but we're not out for speed quite yet anyway.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1860#issuecomment-997168658,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","On page 19 of the paper (algorithm 3), they do a binary search for the σ parameter, which determines how fast the fuzziness of the fuzzy ball falls off with distance beyond the nearest neighbor. To me it seems like you should calculate this algebraically, not do a binary search. I don't even know what to search over. Does anybody have any idea why they do a binary search?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,8,https://github.com/igraph/igraph/pull/1860#issuecomment-997170888,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","On page 19 of the paper (algorithm 3), they do a binary search for the σ parameter, which determines how fast the fuzziness of the fuzzy ball falls off with distance beyond the nearest neighbor. To me it seems like you should calculate this algebraically, not do a binary search. I don't even know what to search over. Does anybody have any idea why they do a binary search?

Let me take a look. It sounds like a hack to me",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,9,https://github.com/igraph/igraph/pull/1860#issuecomment-997178031,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","At page 21, the paper does curve fitting. I think the fit depends on min-dist, and I guess some random points to fit the two curves at. I'm not sure I should implement some curve fitting myself for this situation. Has anybody got a little more experience with curve fitting? Does anybody understand at what points the curves should be fit for the formula at definition 11? From algorithm 5 it seems the fit should be only done once, and a and b are called hyper-parameters at page 16, so I think it shouldn't depend on the data, but maybe I'm missing something.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,10,https://github.com/igraph/igraph/pull/1860#issuecomment-1030844064,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Ah, I thought I could do a matrix inverse with LAPACK's dgetri, but apparently dgetri is not in vendor/lapack, so I probably shouldn't use it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/1860#issuecomment-1030911760,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Not all LAPACK functions have been vendored into igraph, only those that we actually needed. You can find the old scripts that we used to grab the LAPACK sources and translate them with f2c in tools/lapack/getlapack.sh. You need to get LAPACK 3.5.0, extract that function(s) that you need and feed them to f2c to get an equivalent C source. Let me know if you need help with this.
Also, don't try to run tools/lapack/getlapack.sh directly; it comes from the days when igraph was built with autotools and not CMake, so basically nothing that the script does would be useful with the current build system. You should look at the script only to get a rough idea about how a function from LAPACK should be integrated into the vendored source.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1860#issuecomment-1030914780,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","You should not use an inverse to repeatedly solve linear systems with the same coefficients. For that, look at e.g. dgetrf / dgetrs which are already exposed in igraph.
What did you mean to use the inverse for?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,13,https://github.com/igraph/igraph/pull/1860#issuecomment-1030916546,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Trying to see if I could do Gauss-Newton for a bit of curve fitting. It's only a small part of umap, but it seems like it shouldn't be hard once you have the basic matrix operations available of which only the inverse is missing now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1860#issuecomment-1030918882,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","While I am not familiar with the method, it seems to me that it essentially needs solving a linear equation. You do not need to compute and store the inverse to do that. Instead of thinking ""x = M^-1 y"", think ""solve M x = y"".
Matrix inversion can get unstable. Do not invert matrices unless you know why you need to.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1860#issuecomment-1030919013,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",https://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1860#issuecomment-1030919377,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","You should look at what's available in LAPACK (again, I'm not very familiar with it), but I think you simply need igraph_lapack_dgesv().",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,17,https://github.com/igraph/igraph/pull/1860#issuecomment-1035707356,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Alright, the matrix to be inverted is 2x2 😏 I'm sure we'll make it even with an explicit inversion... let me code it
edit: OMG I'm so confused, have not done math in a while! This might or might not be true",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1860#issuecomment-1035969891,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","If it's a 2 by 2, you might as well write down the formula:
In[]:= Inverse[{{a, b}, {c, d}}]
Out[]= {{d/(-b c + a d), -(b/(-b c + a d))}, {-(c/(-b c + a d)),  a/(-b c + a d)}}

But if you do so, why don't you just write down the formula for the solution of a linear equation directly instead of using dgemm?
In[]:= LinearSolve[{{a, b}, {c, d}}, {x, y}]
Out[]= {(d x - b y)/(-b c + a d), (c x - a y)/(b c - a d)}",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,19,https://github.com/igraph/igraph/pull/1860#issuecomment-1035973810,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I think the matrix is 2x2, so I just wrote out the formula. I think it should be fine",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,20,https://github.com/igraph/igraph/pull/1860#issuecomment-1035977813,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",So you're using only two residuals? Else it shouldn't be 2x2.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,21,https://github.com/igraph/igraph/pull/1860#issuecomment-1036002398,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Of course not, but it's the transpose if the Jacobian right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,22,https://github.com/igraph/igraph/pull/1860#issuecomment-1036061973,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Ah you're right, with m residuals and n variables, you get an m x n matrix, and its transpose times itself is n x n.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,23,https://github.com/igraph/igraph/pull/1860#issuecomment-1036146948,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I hope at least, the comments in the code betray my insecurity 😱",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,24,https://github.com/igraph/igraph/pull/1860#issuecomment-1036670029,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Alright, I transitioned to using LAPACK's solver like @szhorvat suggested instead of computing inverse matrix by hand. Makes no big difference, but since we have it, and the theoretical explanation in the code comments is a little more straightforward now. Also added some memory management and improved the line search.
Next thing would be either:

finish up the stochastic gradient thing, or
just use the full gradient for now and write the first unit test, so we can check if it works!

@GroteGnoom Up to you, I'll start doing them at some point anyway, no preference",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,25,https://github.com/igraph/igraph/pull/1860#issuecomment-1036883073,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Actually, fitting a/b is even simpler I think. Given sigma and dist_min, let (a,b) be a solution to the fit. Then if we double both sigma and dist_min, the new solution is obviously:
a^2b -> half
b -> unchanged

so we don't have to recompute them. In other words, you can reparametrize Phi as:
Phi(d) = 1 / ( 1 + (d/a)^2b )

which makes the scaling behaviour clear. So given a certain pair (sigma, dist_min) only their ""ratio"" matters, since the total scaling is trivially solved by rescaling a. So we can just find a solution for sigma -> 1, dist_min -> dist_min/sigma and rescale up a at the end. Let me finish figuring this out, but it seems likely that we could just store a table of solutions for say 100 ratios dist_min/sigma and be done with this... I'll think more about it, it's not central I guess
edit: closed and reopened by mistake",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,26,https://github.com/igraph/igraph/pull/1860#issuecomment-1037690564,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Alright, now igraph_fit_ab converges (there was a sign mistake, I think).
I've implemented a first draft of cross-entropy between graph weights (i.e. distance in the high-dimensional space) and it's embedded approximation (i.e. the distance in 2D). Hopefully that'll help us track down bugs (e.g. sign switches) in the gradient descent.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,27,https://github.com/igraph/igraph/pull/1860#issuecomment-1037986692,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","The ab starts out with an SSR of 1.124956 and later converges to 2.158813. That's not supposed to happen, right? In practice the end SSR should be the lowest you've ever seen.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,28,https://github.com/igraph/igraph/pull/1860#issuecomment-1038024518,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","hmm... not sure, here's what happens on my machine:
+start fit_ab
+start line search, SSR before delta: 1.124956, current SSR:, 1.790281
+during line search, k = 0, old SSR:, 1.124956, new SSR (half a,b):, 1.863988
+end of line search and iteration, squared_sum_res: 1.863988 
+
+start line search, SSR before delta: 1.790281, current SSR:, 79.240187
+during line search, k = 0, old SSR:, 1.790281, new SSR (half a,b):, 2.157009
+during line search, k = 1, old SSR:, 1.790281, new SSR (half a,b):, 7.304046
+end of line search and iteration, squared_sum_res: 7.304046 
+
+start line search, SSR before delta: 0.429805, current SSR:, 3.578511
+during line search, k = 0, old SSR:, 0.429805, new SSR (half a,b):, 1.204413
+during line search, k = 1, old SSR:, 0.429805, new SSR (half a,b):, 0.698009
+during line search, k = 2, old SSR:, 0.429805, new SSR (half a,b):, 0.540573
+during line search, k = 3, old SSR:, 0.429805, new SSR (half a,b):, 0.480010
+during line search, k = 4, old SSR:, 0.429805, new SSR (half a,b):, 0.453687
+during line search, k = 5, old SSR:, 0.429805, new SSR (half a,b):, 0.441450
+during line search, k = 6, old SSR:, 0.429805, new SSR (half a,b):, 0.435554
+during line search, k = 7, old SSR:, 0.429805, new SSR (half a,b):, 0.432661
+during line search, k = 8, old SSR:, 0.429805, new SSR (half a,b):, 0.431229
+during line search, k = 9, old SSR:, 0.429805, new SSR (half a,b):, 0.430516
+end of line search and iteration, squared_sum_res: 0.430516 
+
+no-change absolute convergence

It does look messy but the end is definitely lower then the beginning?
Anyway, both there and in the gradient there might be sign issues, let's double check the algebra. FWIW, Gauss-Newton is not guaranteed to decrease the objective function at each single iteration, just to converge in the long run I think.
edit: the line search stop condition can be improved too.
edit2: there was also a typo in the SSR that gets printed at the end of each iteration, now it's better",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,29,https://github.com/igraph/igraph/pull/1860#issuecomment-1038057633,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Hmm, that's interesting:
start fit_ab
start line search, SSR before delta: 1.124956, current SSR:, 1.790281
during line search, k = 0, old SSR:, 1.124956, new SSR (half a,b):, 1.863988
end of line search and iteration, squared_sum_res: 1.790281

start line search, SSR before delta: 1.790281, current SSR:, 79.240187
during line search, k = 0, old SSR:, 1.790281, new SSR (half a,b):, 2.157009
during line search, k = 1, old SSR:, 1.790281, new SSR (half a,b):, 7.304046
end of line search and iteration, squared_sum_res: 2.157009

start line search, SSR before delta: 2.157009, current SSR:, 4.689787
during line search, k = 0, old SSR:, 2.157009, new SSR (half a,b):, 3.249801
during line search, k = 1, old SSR:, 2.157009, new SSR (half a,b):, 2.660505
during line search, k = 2, old SSR:, 2.157009, new SSR (half a,b):, 2.398224
during line search, k = 3, old SSR:, 2.157009, new SSR (half a,b):, 2.275016
during line search, k = 4, old SSR:, 2.157009, new SSR (half a,b):, 2.215367
during line search, k = 5, old SSR:, 2.157009, new SSR (half a,b):, 2.186027
during line search, k = 6, old SSR:, 2.157009, new SSR (half a,b):, 2.171478
during line search, k = 7, old SSR:, 2.157009, new SSR (half a,b):, 2.164234
during line search, k = 8, old SSR:, 2.157009, new SSR (half a,b):, 2.160619
during line search, k = 9, old SSR:, 2.157009, new SSR (half a,b):, 2.158813
end of line search and iteration, squared_sum_res: 2.160619

no-change absolute convergence
a, b: 0.174450 -0.108241",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,30,https://github.com/igraph/igraph/pull/1860#issuecomment-1039641945,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Okay, things are moving well. Here a plot of the graph in the unit test after umap

I would say: not too shabby!
The entropy is still oscillating and sometimes jumps up, I'll have to check on that. Moreover, the sigma computation is still ignoring corner cases, so I'll check that too.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,31,https://github.com/igraph/igraph/pull/1860#issuecomment-1039866354,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",I improved the logic of sigma for corner cases (e.g. unweighted/undistanced input graph) and it works well I think:,True,{'HOORAY': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,32,https://github.com/igraph/igraph/pull/1860#issuecomment-1040134366,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Now I have added corner cases for sigma when all distances are rho, and cluttered the files with #ifdef UMAP_DEBUG. If the latter is poor practice, feel free to just change the code into whatever solution you like 😄,,,",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,33,https://github.com/igraph/igraph/pull/1860#issuecomment-1040144471,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I renamed the internal functions as igraph_i_... and changed the test output, which now should pass (locally, at least).
We need at least a unit test with an unweighted graph (distances should be NULL) and then a bit of stress testing in the next days. If all looks good we can merge next week?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,34,https://github.com/igraph/igraph/pull/1860#issuecomment-1040178132,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Assuming this works well, we can decide if we want to look into openMP for parallelizing the steps that are run independently on each vertex:

computing mu(a)

I'm not sure the stochastic gradient descent can be parallelized very well. We noticed that when you move too many vertices around before checking on the cross-entropy the system tends to become a little unstable. But I imagine this is where the bulk of the runtime is spent, so perhaps?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,35,https://github.com/igraph/igraph/pull/1860#issuecomment-1040798980,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","🙂  BTW, I think will never pass the tests on all systems if we output the exact layout, so we'll have to change the tests later, like only check for some general properties that should always hold.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,36,https://github.com/igraph/igraph/pull/1860#issuecomment-1040800784,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Agreed
…
On Wed, Feb 16, 2022, at 08:14, GroteGnoom wrote:
 🙂 BTW, I think will never pass the tests on all systems if we output
 the exact layout, so we'll have to have to change the tests later, like
 only check for some general properties that should always hold.

 —
 Reply to this email directly, view it on GitHub
 <#1860 (comment)>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEACQQECR2VBATXCG7U3U3K62TANCNFSM5JBM5LSQ>.
 Triage notifications on the go with GitHub Mobile for iOS
 <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
 or Android
 <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.
 You are receiving this because you modified the open/close
 state.Message ID: ***@***.***>",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,37,https://github.com/igraph/igraph/pull/1860#issuecomment-1041213375,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",I changed the unit test to be more tolerant and added a few more customization options. I think as soon as we get it to pass CI tests (it passes locally) we can ask for a first review from folks.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,38,https://github.com/igraph/igraph/pull/1860#issuecomment-1043689185,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Okay, a few tests fail but I think it's good enough for a first round of review from whoever has a bit of time.
Current CI failures relate to two things:

macOS: caching is broken I think. The compiler warns about two float variables that are not even float anymore, and fails to compile. We should tell it to ignore whatever cache it's using, anyone knows how?
Windows/a few other archs: one vertex can sometimes be shot into space and struggle to come back. I think this is a genuine bug with the repulsive force in the layouting, and needs to be fixed.

Thank you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,39,https://github.com/igraph/igraph/pull/1860#issuecomment-1044093410,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","You plan to remove the UMAP_DEBUG stuff from public headers and tests, right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,40,https://github.com/igraph/igraph/pull/1860#issuecomment-1044096278,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","There is no problem with caching on macOS. The error says:
/Users/runner/work/1/s/tests/unit/igraph_layout_umap.c:73:11: error: unused variable 'a' [-Werror,-Wunused-variable]
    float a, b;

You need to remove unused variables.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,41,https://github.com/igraph/igraph/pull/1860#issuecomment-1044096890,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I can do that, yes",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,42,https://github.com/igraph/igraph/pull/1860#issuecomment-1044098691,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Those

There is no problem with caching on macOS. The error says:
/Users/runner/work/1/s/tests/unit/igraph_layout_umap.c:73:11: error: unused variable 'a' [-Werror,-Wunused-variable]
    float a, b;

You need to remove unused variables.

Those variables have been removed 10 commits ago afaict",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,43,https://github.com/igraph/igraph/pull/1860#issuecomment-1044099408,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","No, they are there. Check carefully.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,44,https://github.com/igraph/igraph/pull/1860#issuecomment-1044099499,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Those

There is no problem with caching on macOS. The error says:
/Users/runner/work/1/s/tests/unit/igraph_layout_umap.c:73:11: error: unused variable 'a' [-Werror,-Wunused-variable]
    float a, b;

You need to remove unused variables.

Those variables have been removed 10 commits ago afaict

Oh I'm stupid... Sorry",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,45,https://github.com/igraph/igraph/pull/1860#issuecomment-1044108686,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Actually, I would keep the debug stuff. I would only remove it from the public header and the test.
I'll take a quick look at some formal things, but this is not going to be even close to a real review for now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,46,https://github.com/igraph/igraph/pull/1860#issuecomment-1044111173,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Ok I'll leave the debug stuff only in the umap.c.
You mean you have no time for a deep review?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,47,https://github.com/igraph/igraph/pull/1860#issuecomment-1044165761,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",Do you know what's happening on Windows? Is the method numerically unstable?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,48,https://github.com/igraph/igraph/pull/1860#issuecomment-1044203015,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","You mean to the nature paper? Actually that paper is about applications, not the algorithm itself, so I'd leave only the arXiv info with a hyperlink
…
On Fri, Feb 18, 2022, at 20:20, GroteGnoom wrote:
 ***@***.**** commented on this pull request.

 In src/misc/umap.c
 <#1860 (comment)>:

> + *    edge attribute and use a null pointer for the distances. If using similarity
 + *    weights instead of distances, make sure they do not exceed 1.
 + * 3. Feed the graph (and distances, if you have them) into this
 function.
 + *
 + * Note: Step 1 above involves deciding if two high-dimensional
 vectors ""look similar""
 + *       which, because of the curse of dimensionality, is in many
 cases a highly
 + *       subjective and potentially controversial operation: thread
 with care and at
 + *       your own risk. Two high-dimensional vectors might look
 similar or extremely
 + *       different depending on the point of view/angle, and there are
 a lot of
 + *       viewpoints when the dimensionality ramps up.
 + *
 + * </para><para>
 + * References:
 + *
 + * </para><para>
 + * Leland McInnes, John Healy, and James Melville, arXiv:1802.03426v3
 I added links, but I kept the arXiv, because that's one people like me
 can access 🙂

 —
 Reply to this email directly, view it on GitHub
 <#1860 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAEVBRRSEOSDKRIXFITU3YFOVANCNFSM5JBM5LSQ>.
 Triage notifications on the go with GitHub Mobile for iOS
 <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
 or Android
 <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.
 You are receiving this because you modified the open/close
 state.Message ID: ***@***.***>",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,49,https://github.com/igraph/igraph/pull/1860#issuecomment-1044258699,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","The algorithm is pretty numerically unstable in general now, the second test fails if I change the sampling probability of the first one.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,50,https://github.com/igraph/igraph/pull/1860#issuecomment-1045179145,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","The algorithm is pretty numerically unstable in general now, the second test fails if I change the sampling probability of the first one.

Correct, that's my current struggle to get it working on windows. The good thing is that that probability only factors in the last function, so there might be a bug there... I'll take a look",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,51,https://github.com/igraph/igraph/pull/1860#issuecomment-1045972040,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Please do not use names like igraph_attract(). It makes it look like this is a public function. It should be possible to tell at a glance what a function is.

Public functions should be named igraph_foo()
Internal functions that are not static should be named igraph_i_foo().
static functions can be named anything you like, as they will not conflict with others, but please don't make them look like public ones. attract() is fine. If I see that, I can tell at a glance that it is local to this compilation unit, therefore used only for UMAP. Some have preferred to use igraph_i_ even for static functions, although this is not technically necessary and IMO it again makes it difficult to tell if the function is specific to UMAP. So don't name it igraph_i_attract(). If you insist on the igraph_i_ prefix, then use igraph_i_umap_attract",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,52,https://github.com/igraph/igraph/pull/1860#issuecomment-1046361829,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Alright guys! 99 commits into this PR we have a passing CI, tests, corner cases, clean docs, and are almost ready to go! It would be sweet to have it by commit 100 to celebrate 😏
The only thing left is to decide whether we can trust the spectral layout as an initialization or, if we have a known bug in that algo, skip if for now and move to fix that bug in a separate PR.
I can see the light at the end of the tunnel!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,53,https://github.com/igraph/igraph/pull/1860#issuecomment-1046561031,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Commit 103, now we have a 2D and a 3D version... not sure if the double docs and stuff are a great idea?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,54,https://github.com/igraph/igraph/pull/1860#issuecomment-1046608213,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",Don't duplicate the docs. Just refer back to the 2D version. Document only the parameter list.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,55,https://github.com/igraph/igraph/pull/1860#issuecomment-1046680126,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",I've copied the spectral embedding problem to the issue tracker: #1971,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,56,https://github.com/igraph/igraph/pull/1860#issuecomment-1046799565,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Ok, given #1971 I propose we merge this as is and as part of the PR against that issue we also include spectral embedding as a umap starting condition.
Or would you like to let the user specify a certain starting layout manually (could be spectral, FR, random, circle, whatever)?
In that case we should have a flag argument about it (e.g. with an enum for initialize={RANDOM, SPECTRAL, CUSTOM}, in the last case do not touch the vector, just check that the dimensions are appropriate and start shifting vertices according to the cross-entropy minimization)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,57,https://github.com/igraph/igraph/pull/1860#issuecomment-1046805694,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Can we wait until someone can do a full review? I'll be out for the rest of this week. Otherwise, is it 100% ready as far as you're concerned @iosonofabio ? How did you fix the instability, was it about not choosing a random endpoint to move?
Can you build the docs on your machine and check that they look good? I see that many paragraph markers are missing, so everything will flow together.
P.S. As for the spectral stuff, I agree that it should not block merging this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,58,https://github.com/igraph/igraph/pull/1860#issuecomment-1046817512,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Good point, I now added paragraph breaks and the docs build and look good on my machine. I also added a doc link among the 3D layout algorithms.
This is not really urgent, it's more like I'll be a father any day now so I would like to have it out of my mind. AFAICT it's done, I'm sure @GroteGnoom can give it a few final touches if I become suddenly unavailable. So let's wait a few days to give people an opportunity to review.
PS: there were originally many sources of instabilities. The last one was due to the fact that altough the graph is undirected, in practice igraph stores the edges as directed, so we were always moving the ""from"" node and never the ""to"" node. So for instance if we have a graph with edges (1,2), (3,2), (4,2), if we always move the ""from"" node then vertex 2 is stuck in place. By choosing one of the vertices at random we ensure that all vertices move around.
With the current convention, even when the edge sampling probability is 1.0 it is conceivable that, with enough bad luck, not all vertices will be moved in a single epoch. That's not a big deal because:

the algo is supposed to run for many epochs
the chances of this happening for real-world graphs is small (e.g. for the graph above it's 12.5% per epoch, and that's a pathological example)
in practice the sampling probability should probably be something like 1/sqrt(no_of_nodes), i.e. should be distinctly sparser than the graph cardinality, so we don't really care about what happens for P>0.5 and especially P=1.0...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,59,https://github.com/igraph/igraph/pull/1860#issuecomment-1062222925,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Hey @ntamas , hope your holiday was good! Is that alright if I merge this one? Then I can make a python interface function for this",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,60,https://github.com/igraph/igraph/pull/1860#issuecomment-1062731925,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I just want to see this merged and a Python interface for it. My students will need it sooner rather than later.  It's complete but we my might tweak it a bit based on user feedback I'd say

Thank you
Fabio
…
On Wed, Mar 9, 2022, at 20:22, Szabolcs Horvát wrote:
 ***@***.**** requested changes on this pull request.

 I added a few more technical comments, but this is still not a proper review.

 Do you consider it done now, are you planning to keep working on it?
 Some of the comments suggest that it's not quite done yet. I would
 suggest merging only when you do consider it done. Don't worry about
 being absent for a while, @GroteGnoom <https://github.com/GroteGnoom>
 and the rest of us will be able to take care of it :-)

 I'll add a few more comments later, mostly with the aim to understand
 this well enough to be able to continue.

 In src/layout/umap.c
 <#1860 (comment)>:

> +
 +   This program is free software; you can redistribute it and/or modify
 +   it under the terms of the GNU General Public License as published by
 +   the Free Software Foundation; either version 2 of the License, or
 +   (at your option) any later version.
 +
 +   This program is distributed in the hope that it will be useful,
 +   but WITHOUT ANY WARRANTY; without even the implied warranty of
 +   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 +   GNU General Public License for more details.
 +
 +   You should have received a copy of the GNU General Public License
 +   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 +   */
 +
 +#include ""igraph_constructors.h""
 Is this include needed?

 In src/layout/umap.c
 <#1860 (comment)>:

> +    IGRAPH_CHECK(igraph_i_layout_umap(graph, distances, layout, min_dist, epochs, sampling_prob, 3));
 +    return IGRAPH_SUCCESS;
 In such cases you can directly return the error code of the function
 you call, `return igraph_i_layout_umap(...)`. This approach is fine too.

 In src/layout/umap.c
 <#1860 (comment)>:

> +    /* Explicit avoidance of neighbor repulsion, only useful in small graphs
 +     * which are never very sparse */
 I'm not sure what you mean here. Small graphs can of course be sparse,
 and often are. Umap was presented as a general layout algorithm here,
 so it should work for all graphs. Is this a problem?

 In src/layout/umap.c
 <#1860 (comment)>:

> +
 +    for (igraph_integer_t e = 0; e < epochs; e++) {
 +        /* Apply (stochastic) forces */
 +        igraph_i_umap_apply_forces(graph, umap_weights, layout, a, b,
 sampling_prob, learning_rate,
 +                avoid_neighbor_repulsion);
 +
 +#ifdef UMAP_DEBUG
 +        /* Recompute CE and check how it's going*/
 +        cross_entropy_old = cross_entropy;
 +        igraph_i_umap_compute_cross_entropy(graph, umap_weights,
 layout, a, b, &cross_entropy);
 +
 +        printf(""Cross-entropy before shift: %g, after shift: %g\n"",
 cross_entropy_old, cross_entropy);
 +#endif
 +
 +         /* Adjust learning rate */
 +        learning_rate = 1.0 - (float)(e + 1) / epochs;
 Why do you cast to `float` here (and not `igraph_real_t`)?

 In src/layout/umap.c
 <#1860 (comment)>:

> +    }
 +
 +    if ((ndim != 2) && (ndim != 3)) {
 +        IGRAPH_ERRORF(""Number of dimensions should be 2 or 3, found
 %d."",
 +                IGRAPH_EINVAL, (int)ndim);
 +
 +    }
 +
 +    /* UMAP is sometimes used on unweighted graphs, that means
 distances are always zero */
 +    IGRAPH_CHECK(igraph_i_umap_check_distances(distances,
 no_of_edges));
 +
 +    /* Trivial graphs (0 or 1 nodes) beget trivial - but valid -
 layouts */
 +    if (no_of_nodes <= 1) {
 +        IGRAPH_CHECK(igraph_matrix_resize(layout, no_of_nodes, ndim));
 +        if (no_of_nodes == 1) {
 +            for (int d = 0; d != ndim; d++) {
 Please do not use `int` anywhere in igraph code, unless there is a good
 reason. If there is a reason, document it. Any variable indexing into
 an igraph vector must be an `igraph_integer_t`. There are several uses
 of `int` elsewhere.

 In src/layout/umap.c
 <#1860 (comment)>:

> +   the Free Software Foundation; either version 2 of the License, or
 +   (at your option) any later version.
 +
 +   This program is distributed in the hope that it will be useful,
 +   but WITHOUT ANY WARRANTY; without even the implied warranty of
 +   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 +   GNU General Public License for more details.
 +
 +   You should have received a copy of the GNU General Public License
 +   along with this program.  If not, see
 <https://www.gnu.org/licenses/>.
 +   */
 +
 +#include ""igraph_constructors.h""
 +#include ""igraph_interface.h""
 +#include ""igraph_lapack.h""
 +#include ""igraph_layout.h""
 Put this header at the start, as I suggested last time. This is where
 the prototypes of functions defined in this file are.

 In src/layout/umap.c
 <#1860 (comment)>:

> +static igraph_error_t igraph_i_umap_find_sigma(const igraph_t *graph,
 +        const igraph_vector_t *distances, igraph_integer_t i, const
 igraph_vector_int_t *eids,
 +        igraph_real_t rho, igraph_real_t *sigma_p, igraph_real_t
 target) {
 `graph` and `i` arguments are unused, do you need them?

 In src/layout/umap.c
 <#1860 (comment)>:

> +        dist_max = rho;
 +        for (igraph_integer_t j = 1; j < no_of_neis; j++) {
 +            dist = VECTOR(*distances)[VECTOR(eids)[j]];
 +            rho = fmin(rho, dist);
 +            dist_max = fmax(dist_max, dist);
 +        }
 +
 +        /* If the maximal distance is rho, all neighbors are identical to
 +         * each other. */
 +        if (dist_max == rho) {
 +            /* This is a special flag for later on */
 +            sigma = -1;
 +
 +        /* Else, find sigma for this vertex, from its rho plus binary search */
 +        } else {
 +            sigma_target = log(no_of_neis) / log(2);
 Use `log2()`.

 In src/layout/umap.c
 <#1860 (comment)>:

> +         * continuous). So we smoothen it with:
 +         *
 +         *     Q(d) = ( 1 + a*d^2b )^-1
 +         *
 +         * which is quite similar throughout for appropriate a and b.
 Notice
 +         * that we do not need to smoothen the high-dimensional
 probability
 +         * function because the vertices are not moved in the
 high-dimensional
 +         * space, so there is no need for differentiating that
 function.
 +         *
 +         * The residual is of course:
 +         *
 +         *    Q(d) - P(d) = ( 1 + a*d^2b )^-1 - [ d < min_dist ? 1 :
 e^{-(d - min_dist)} ]
 +         *
 +         * This function also sets the auxiliary vector powb.
 +         * */
 +        VECTOR(*powb)[i] = powf(VECTOR(*x)[i], 2 * b);
 `powf` is for `float` arguments. We work with `double` (i.e.
 `igraph_real_t`). There are several other uses of `powf()`, please
 correct those as well.

 In src/layout/umap.c
 <#1860 (comment)>:

> +    igraph_integer_t seen_max = 0;
 +
 +    /* Binary search */
 +    for (igraph_integer_t iter = 0; iter < maxiter; iter++) {
 +        sum = 0;
 +        for (igraph_integer_t j = 0; j < no_of_neis; j++) {
 +            eid = VECTOR(*eids)[j];
 +            sum += exp(-(VECTOR(*distances)[eid] - rho) / sigma);
 +        }
 +
 +#ifdef UMAP_DEBUG
 +        printf(""SIGMA function (i = %"" IGRAPH_PRId "", no_of_neis = %""
 IGRAPH_PRId "")- sum: %g, ""
 +               ""target: %g, rho: %g, sigma: %g\n"", i, no_of_neis, sum,
 target, rho, sigma);
 +#endif
 +
 +        /* TODO: this seems fine, but is probably a little off for
 some corner cases */
 If someone other than you comes back to this in the future, they will
 not be able to tell what this comment is about.

 In src/layout/umap.c
 <#1860 (comment)>:

> +    if (igraph_vector_size(distances) != no_of_edges) {
 +        IGRAPH_ERROR(""Distances must be the same number as the edges
 in the graph."", IGRAPH_EINVAL);
 +    }
 +
 +    for (igraph_integer_t eid = 0; eid != no_of_edges; eid++) {
 +        if (VECTOR(*distances)[eid] < 0) {
 +            IGRAPH_ERROR(""Distances cannot be negative."",
 IGRAPH_EINVAL);
 +        }
 +    }
 +
 +    return IGRAPH_SUCCESS;
 +}
 +
 +
 +/* This is the main function that works for any dimensionality of the
 embedding (currently hard-constrained to 2 or 3 ONLY in the
 initialization) */
 +igraph_error_t igraph_i_layout_umap(const igraph_t *graph, const
 igraph_vector_t *distances,
 Shouldn't this be `static`?

 In src/layout/umap.c
 <#1860 (comment)>:

> +    for (igraph_integer_t eid = 0; eid != no_of_edges; eid++) {
 +        if (VECTOR(*distances)[eid] < 0) {
 +            IGRAPH_ERROR(""Distances cannot be negative."",
 IGRAPH_EINVAL);
 +        }
 +    }
 We normally use `vector_min` for such checks, but pay attention that it
 cannot be called on empty vectors. At the same time, check for NaN.
 Here's e.g. how it's done by `closeness()`:

     if (no_of_edges > 0) {
         igraph_real_t minweight = igraph_vector_min(weights);
         if (minweight <= 0) {
             IGRAPH_ERROR(""Weight vector must be positive."",
 IGRAPH_EINVAL);
         } else if (igraph_is_nan(minweight)) {
             IGRAPH_ERROR(""Weight vector must not contain NaN values."",
 IGRAPH_EINVAL);
         }
     }
 In src/layout/umap.c
 <#1860 (comment)>:

> +        if (no_of_nodes == 1) {
 +            for (int d = 0; d != ndim; d++) {
 +                MATRIX(*layout, 0, d) = 0;
 +            }
 +        }
 Use the `matrix_null()` function. Do not use `int` unless there is a reason.

 In src/layout/umap.c
 <#1860 (comment)>:

> +                MATRIX(*layout, 0, d) = 0;
 +            }
 +        }
 +        return IGRAPH_SUCCESS;
 +    }
 +
 +    RNG_BEGIN();
 +    IGRAPH_VECTOR_INIT_FINALLY(&umap_weights, no_of_edges);
 +
 +    /* Make combined graph with smoothed probabilities */
 +    IGRAPH_CHECK(igraph_i_umap_find_prob_graph(graph, distances,
 &umap_weights));
 +
 +    /* From now on everything lives in probability space, it does not
 matter whether
 +     * the original graph was weighted/distanced or unweighted */
 +
 +    /* Skip spectral embedding for now, initialize at random */
 Please clarify comment here in case someone else would be working on it
 in the future.

 In src/layout/umap.c
 <#1860 (comment)>:

> +    IGRAPH_VECTOR_INIT_FINALLY(&umap_weights, no_of_edges);
 +
 +    /* Make combined graph with smoothed probabilities */
 +    IGRAPH_CHECK(igraph_i_umap_find_prob_graph(graph, distances,
 &umap_weights));
 +
 +    /* From now on everything lives in probability space, it does not
 matter whether
 +     * the original graph was weighted/distanced or unweighted */
 +
 +    /* Skip spectral embedding for now, initialize at random */
 +    if (ndim == 2) {
 +        igraph_layout_random(graph, layout);
 +    } else {
 +        igraph_layout_random_3d(graph, layout);
 +    }
 +
 +    /* Definition 11 */
 There should be a comment somewhere making it clear that these refer to
 (a specific version of) the arXiv preprint.

 In src/layout/umap.c
 <#1860 (comment)>:

> +
 +    /* Initialize vectors */
 +    IGRAPH_VECTOR_INIT_FINALLY(&from_emb, ndim);
 +    IGRAPH_VECTOR_INIT_FINALLY(&to_emb, ndim);
 +    IGRAPH_VECTOR_INIT_FINALLY(&delta, ndim);
 +    IGRAPH_VECTOR_INIT_FINALLY(&forces, ndim);
 +
 +    if (avoid_neighbor_repulsion) {
 +        IGRAPH_VECTOR_INT_INIT_FINALLY(&neis, 0);
 +    }
 +    IGRAPH_VECTOR_INT_INIT_FINALLY(&negative_vertices, 0);
 +
 +    igraph_integer_t n_random_vertices = sqrt(no_of_nodes);
 +
 +    /* iterate over a random subsample of edges */
 +    for (igraph_integer_t eid = 0; eid < no_of_edges; eid++) {
 We have a function to select a random subset of integers (or edge IDs),
 see `igraph_random_sample()`. Can you use it here? That should be more
 efficient for small `prob`. What are typical values of `prob`?

 In src/layout/umap.c
 <#1860 (comment)>:

> +    for (igraph_integer_t eid = 0; eid < no_of_edges; eid++) {
 +        if (RNG_UNIF01() > prob) {
 +            continue;
 +        }
 +
 +        /* half the time, swap the from/to, otherwise some vertices
 are never moved */
 +        if (RNG_UNIF01() > 0.5) {
 +            from = IGRAPH_FROM(graph, eid);
 +            to = IGRAPH_TO(graph, eid);
 +        } else {
 +            to = IGRAPH_FROM(graph, eid);
 +            from = IGRAPH_TO(graph, eid);
 +        }
 +
 +        /* Current coordinates of both vertices */
 +        for (int d = 0; d != ndim; d++) {
 Do not use `int`.

 In src/layout/umap.c
 <#1860 (comment)>:

> +            to = IGRAPH_TO(graph, eid);
 +        } else {
 +            to = IGRAPH_FROM(graph, eid);
 +            from = IGRAPH_TO(graph, eid);
 +        }
 +
 +        /* Current coordinates of both vertices */
 +        for (int d = 0; d != ndim; d++) {
 +            VECTOR(from_emb)[d] = MATRIX(*layout, from, d);
 +            VECTOR(to_emb)[d] = MATRIX(*layout, to, d);
 +            VECTOR(delta)[d] = MATRIX(*layout, from, d) -
 MATRIX(*layout, to, d);
 +        }
 +
 +        /* Apply attractive force since they are neighbors */
 +        IGRAPH_CHECK(igraph_i_umap_attract(&delta,
 VECTOR(*umap_weights)[eid], a, b, &forces));
 +        for (int d = 0; d != ndim; d++) {
 Do not use `int`.

 In src/layout/umap.c
 <#1860 (comment)>:

> +                /* FIXME: This algo terribly inefficient, try to improve using
 +                 * adjacency lists or something but just for testing anyway */
 Should this be done before merging?

 In src/layout/umap.c
 <#1860 (comment)>:

> +        IGRAPH_CHECK(igraph_random_sample(&negative_vertices, 0, no_of_nodes - 2, n_random_vertices));
 +        for (igraph_integer_t j = 0; j < n_random_vertices; j++) {
 +            /* Get random neighbor */
 +            to = VECTOR(negative_vertices)[j];
 +            /* obviously you cannot repel yourself */
 +            if (to >= from) {
 +                to++;
 +            }
 +            /* do not repel neighbors for small graphs, for big graphs
 this
 +             * does not matter as long as the k in knn << number of
 vertices */
 +            if (avoid_neighbor_repulsion) {
 +                /* FIXME: This algo terribly inefficient, try to
 improve using
 +                 * adjacency lists or something but just for testing
 anyway */
 +                igraph_bool_t skip = 0;
 +                igraph_incident(graph, &neis, from, IGRAPH_ALL);
 +                for (igraph_integer_t k = 0; k <
 igraph_vector_int_size(&neis); k++) {
 Please do not use `_size` functions in `for` loops. Save the size in
 advance and use that.

 In src/layout/umap.c
 <#1860 (comment)>:

> +                    igraph_integer_t eid2 = VECTOR(neis)[k];
 +                    igraph_integer_t from2, to2;
 +                    from2 = IGRAPH_FROM(graph, eid2);
 +                    to2 = IGRAPH_TO(graph, eid2);
 +                    if (((from2 == from) && (to2 == to)) || ((from2 ==
 to) && (from == to2))) {
 +                        skip = 1;
 +                        break;
 +                    }
 +                }
 +                if (skip == 1) {
 +                    continue;
 +                }
 +            }
 +
 +            /* Get layout of random neighbor and gradient in embedding
 */
 +            for (int d = 0; d != ndim; d++) {
 Do not use `int`.

 In src/layout/umap.c
 <#1860 (comment)>:

> +                if (skip == 1) {
 +                    continue;
 +                }
 +            }
 +
 +            /* Get layout of random neighbor and gradient in embedding
 */
 +            for (int d = 0; d != ndim; d++) {
 +                VECTOR(to_emb)[d] = MATRIX(*layout, to, d);
 +                VECTOR(delta)[d] = MATRIX(*layout, from, d) -
 MATRIX(*layout, to, d);
 +            }
 +
 +            /* This repels the other vertex assuming it's a negative
 example
 +             * that is no weight, no edge */
 +            IGRAPH_CHECK(igraph_i_umap_repel(&delta, 0, a, b,
 &forces));
 +            /* The repulsive force is already *away* from the other
 (non-neighbor) vertex */
 +            for (int d = 0; d != ndim; d++) {
 Do not use `int`. I probably didn't catch all uses, please replace them
 all, except where `int` is truly needed (e.g. LAPACK error code).

 —
 Reply to this email directly, view it on GitHub
 <#1860 (review)>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AAJFEAEYEM6QMQU25RUCNZLU7BUV7ANCNFSM5JBM5LSQ>.
 Triage notifications on the go with GitHub Mobile for iOS
 <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>
 or Android
 <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.
 You are receiving this because you were mentioned.Message ID:
 ***@***.***>",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,61,https://github.com/igraph/igraph/pull/1860#issuecomment-1062739953,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","I have pieces of code which I need for my work as well, and I use them locally with an unreleased version of IGraph/M. I keep a separate branch of the C core for this. Can your students use such a solution? I am not comfortable releasing unbaked functionality.
There are multiple comments in the code which make the impression of work-in-progress notes. We should bring this to a quality so that someone else than you would be able to continue working on it in the future, if necessary. This means understanding what is or isn't complete, what needs improvements, and why. Some of the current comments make it seem like there are some problems, but don't always make it clear what those are or how to test for them.
This brings me to my main question:
Did you follow the algorithm in the arXiv paper to the letter, or did you make changes to it? Is the algorithm there described completely, or do you need to fill in some parts? Can you make it clear which parts of the code follow the paper, which are filling in missing details, which are changed, and which are your own invention? Answering these will be very helpful when looking through the code.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,62,https://github.com/igraph/igraph/pull/1860#issuecomment-1062746959,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","One last comment: if this does get merged, let us mark it as \experimental in the docs, meaning no commitment to current behaviour or even the API, when it gets released with 0.10.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,63,https://github.com/igraph/igraph/pull/1860#issuecomment-1062747348,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","This is 99% as in the paper and is complete. That's why we should merge.
Of course, a paper is not divine truth and algorithms can always be improved. We have a little bit of that here (e.g. explicitly avoid repelling neighbors for small graphs, much better conceptual framing without the whole topology smokescreen) but nothing essential. A few further, small improvements might emerge quite naturally from users' requests, in which case we should of course consider adding them.
I'm fixing the few things you noticed, will push in a minute. @ntamas it would be great if we could take a review soon, do you think that's on your radar?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,64,https://github.com/igraph/igraph/pull/1860#issuecomment-1062768536,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Okay, I made all requested changes and improved a few comments that made it look ""artisanal"". There's not point specifying to the letter what followed exactly the preprint and what took a slightly different approach: if someone wants to understand this is commented way better than any other implementation out there already, including the original authors'.
I'm in favour of tagging as \experimental in 0.10 if that makes you feel good. We can always break API in 0.11 anyway, so it's not a big deal I think. Since I'm not sure where you want the ""tag"" to appear, please push to the branch directly or perhaps @GroteGnoom can do it for you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/ntamas,65,https://github.com/igraph/igraph/pull/1860#issuecomment-1062771094,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","@ntamas it would be great if we could take a review soon, do you think that's on your radar?

Yes it is, give me a day or two, tops. (I might even do it today after lunch).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,66,https://github.com/igraph/igraph/pull/1860#issuecomment-1062772058,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","🙏 🙏
edit: let me know if you want to see cute baby pics 😏",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,67,https://github.com/igraph/igraph/pull/1860#issuecomment-1062867888,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Of course, a paper is not divine truth and algorithms can always be improved

Sure, I completely agree. The question was just to help with the review, not a comment on correctness.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,68,https://github.com/igraph/igraph/pull/1860#issuecomment-1094253815,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Hey guys, could we merge this? It's been such a tour de force... Happy to have it tagged ""experimental"" if you want, but at least I could build a Python interface and start using it to discover further bugs",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/szhorvat,69,https://github.com/igraph/igraph/pull/1860#issuecomment-1094844311,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",It makes sense to merge and expose to Python because then it's easier to test. Can you add \experimental to the docs first and remove that bit of unused code (if it's truly unused) that I mentioned above?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,70,https://github.com/igraph/igraph/pull/1860#issuecomment-1097800297,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Okay, I added an ""experimental"" line like in another layout function, deleted the unused variable, and merged develop into this branch. I hope this passes CI because I really have almost zero time to fix things these days. It would be just amazing if one of you @GroteGnoom @ntamas took a look at the CI issues and merged the PR...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/iosonofabio,71,https://github.com/igraph/igraph/pull/1860#issuecomment-1097823325,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","Phew tests passed now, let's merge! Yaay!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/ntamas,72,https://github.com/igraph/igraph/pull/1860#issuecomment-1098179663,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat",Give me at most a day to review this and then I'll merge.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/ntamas,73,https://github.com/igraph/igraph/pull/1860#issuecomment-1099116175,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","@GroteGnoom squash-and-merge or merge commit, which one would you prefer? Do you want to keep all the commits in the commit history of develop or is it okay to just have a single squashed commit?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1860,2021-11-30T10:20:39Z,2022-04-14T16:34:13Z,2022-04-15T09:18:40Z,MERGED,True,1264,1,8,https://github.com/GroteGnoom,Implement umap,114,[],https://github.com/igraph/igraph/pull/1860,https://github.com/GroteGnoom,74,https://github.com/igraph/igraph/pull/1860#issuecomment-1099335334,"I've started trying to implement UMAP. There's so much new stuff, that I'm writing code just to explore the problem and see what we need.
Prototype iteration summary:

Initially start from data in a vector space: perhaps skip graph building and start directly with weighted graph (e.g. knn) in a later iteration
Start directly with a sparse graph with ""distances""
Implement rough functions
Implement conversion distance->probability in original graph, mu(a)
Implement smoothed Euclidean distance->probability in embedded space, nu(a), via Gauss-Newton fitting of hyperparameters a and b (using line search to deal with strong off-diagonal elements of the Hessian)
Implement binary search for sigma, a rough estimate of the decay of the neighbor distance beyond the closest neighbor
Implement corner cases for the sigma calculation
Implement cross-entropy (CE) function
Implement derivatives of the CE for attractive and repulsive forces
Double check everything
Put it all together
Write header file
Write unit test code
Write unit test output
Test produces reasonable results, no strict checking yet ('t's a stochastic algo, so not sure how to do that?)
Check function naming
Write function docstring (first draft)
Tests pass locally (Fabio's computer)
Add a bunch of brackets that depend on #define UMAP_DEBUG for printing stuff... is this any good?
Redo the math on the CE and derivatives to make sure we are doing it correctly
Add unit test for unweighted graph
Lint code and docs
3D (theoretically ND) version
Cover trivial graphs
improve docs on (a,b) fit scaling behaviour
Stress test under a few corner and not-so-corner cases
Ask other igraph folks for review/suggestions
Move to layout

Todo:

Decide what to do about initializatoin choices
Merge PR 😏

Possible optimization:

Use openMP

edit (Fabio): added brief idea list as requested by @szhorvat","@GroteGnoom squash-and-merge or merge commit, which one would you prefer? Do you want to keep all the commits in the commit history of develop or is it okay to just have a single squashed commit?

I think squashed is better, there's a lot of commits in there that don't make any sense by themselves.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1868,2021-12-03T17:12:19Z,2021-12-03T18:59:45Z,2021-12-03T18:59:56Z,MERGED,True,27,0,1,https://github.com/szhorvat,Add stimulus to CI,15,[],https://github.com/igraph/igraph/pull/1868,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1868,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1868,2021-12-03T17:12:19Z,2021-12-03T18:59:45Z,2021-12-03T18:59:56Z,MERGED,True,27,0,1,https://github.com/szhorvat,Add stimulus to CI,15,[],https://github.com/igraph/igraph/pull/1868,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1868#issuecomment-985691582,,"Codecov Report

Merging #1868 (ae055cb) into master (11d4da2) will not change coverage.
The diff coverage is n/a.


❗ Current head ae055cb differs from pull request most recent head d10c6b8. Consider uploading reports for the commit d10c6b8 to get more accurate results


@@           Coverage Diff           @@
##           master    #1868   +/-   ##
=======================================
  Coverage   72.45%   72.45%           
=======================================
  Files         295      295           
  Lines       57490    57490           
=======================================
  Hits        41657    41657           
  Misses      15833    15833           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 11d4da2...d10c6b8. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1868,2021-12-03T17:12:19Z,2021-12-03T18:59:45Z,2021-12-03T18:59:56Z,MERGED,True,27,0,1,https://github.com/szhorvat,Add stimulus to CI,15,[],https://github.com/igraph/igraph/pull/1868,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1868#issuecomment-985718041,,"Sorry about the mess, it's done now @ntamas",True,{}
igraph/igraph,https://github.com/igraph/igraph,1868,2021-12-03T17:12:19Z,2021-12-03T18:59:45Z,2021-12-03T18:59:56Z,MERGED,True,27,0,1,https://github.com/szhorvat,Add stimulus to CI,15,[],https://github.com/igraph/igraph/pull/1868,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1868#issuecomment-985755653,,"Thanks, merged!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1869,2021-12-03T18:20:25Z,2021-12-03T18:27:59Z,2021-12-03T18:27:59Z,MERGED,True,4,3,2,https://github.com/szhorvat,ci: prettier display for GitHub actions runs,1,[],https://github.com/igraph/igraph/pull/1869,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1869,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1869,2021-12-03T18:20:25Z,2021-12-03T18:27:59Z,2021-12-03T18:27:59Z,MERGED,True,4,3,2,https://github.com/szhorvat,ci: prettier display for GitHub actions runs,1,[],https://github.com/igraph/igraph/pull/1869,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1869#issuecomment-985734643,,"Codecov Report

Merging #1869 (bc43410) into master (11d4da2) will not change coverage.
The diff coverage is n/a.


❗ Current head bc43410 differs from pull request most recent head 49fbf55. Consider uploading reports for the commit 49fbf55 to get more accurate results


@@           Coverage Diff           @@
##           master    #1869   +/-   ##
=======================================
  Coverage   72.45%   72.45%           
=======================================
  Files         295      295           
  Lines       57490    57490           
=======================================
  Hits        41657    41657           
  Misses      15833    15833           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 11d4da2...49fbf55. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1877,2021-12-07T09:36:09Z,2021-12-07T10:08:39Z,2021-12-07T10:08:39Z,MERGED,True,6,2,1,https://github.com/GroteGnoom,improve finally stack error messages,1,[],https://github.com/igraph/igraph/pull/1877,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1877,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1877,2021-12-07T09:36:09Z,2021-12-07T10:08:39Z,2021-12-07T10:08:39Z,MERGED,True,6,2,1,https://github.com/GroteGnoom,improve finally stack error messages,1,[],https://github.com/igraph/igraph/pull/1877,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1877#issuecomment-987742595,,"Codecov Report

Merging #1877 (b1b86a5) into develop (5f31b9c) will decrease coverage by 0.00%.
The diff coverage is 50.00%.


@@             Coverage Diff             @@
##           develop    #1877      +/-   ##
===========================================
- Coverage    73.93%   73.93%   -0.01%     
===========================================
  Files          342      342              
  Lines        57742    57744       +2     
===========================================
  Hits         42693    42693              
- Misses       15049    15051       +2     



Impacted Files
Coverage Δ





src/core/error.c
76.47% <50.00%> (-1.85%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 5f31b9c...b1b86a5. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1881,2021-12-08T18:57:49Z,2021-12-08T19:45:01Z,2021-12-08T19:45:06Z,MERGED,True,101,47,4,https://github.com/szhorvat,Check GLPK version in CMake,4,[],https://github.com/igraph/igraph/pull/1881,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1881,"Rewrite FindGLPK.cmake to allow for version check
Simplify FindGMP.cmake. While it looks in fewer places, it is consistent with FindGLPK.cmake. We can maybe do this for other libraries too. GMP_PREFIX is not necessary because there is the standard GMP_ROOT (provided automatically by CMake for any package)
Provide support for checking package versions in dependencies.cmake and check that GLPK >= 4.57

Fixes #1879","Rewrite FindGLPK.cmake to allow for version check
Simplify FindGMP.cmake. While it looks in fewer places, it is consistent with FindGLPK.cmake. We can maybe do this for other libraries too. GMP_PREFIX is not necessary because there is the standard GMP_ROOT (provided automatically by CMake for any package)
Provide support for checking package versions in dependencies.cmake and check that GLPK >= 4.57

Fixes #1879",True,{}
igraph/igraph,https://github.com/igraph/igraph,1881,2021-12-08T18:57:49Z,2021-12-08T19:45:01Z,2021-12-08T19:45:06Z,MERGED,True,101,47,4,https://github.com/szhorvat,Check GLPK version in CMake,4,[],https://github.com/igraph/igraph/pull/1881,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1881#issuecomment-989112979,"Rewrite FindGLPK.cmake to allow for version check
Simplify FindGMP.cmake. While it looks in fewer places, it is consistent with FindGLPK.cmake. We can maybe do this for other libraries too. GMP_PREFIX is not necessary because there is the standard GMP_ROOT (provided automatically by CMake for any package)
Provide support for checking package versions in dependencies.cmake and check that GLPK >= 4.57

Fixes #1879","Codecov Report

Merging #1881 (69d3429) into master (0d4583a) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1881   +/-   ##
=======================================
  Coverage   72.39%   72.39%           
=======================================
  Files         295      295           
  Lines       57479    57479           
=======================================
  Hits        41610    41610           
  Misses      15869    15869           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 0d4583a...69d3429. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1881,2021-12-08T18:57:49Z,2021-12-08T19:45:01Z,2021-12-08T19:45:06Z,MERGED,True,101,47,4,https://github.com/szhorvat,Check GLPK version in CMake,4,[],https://github.com/igraph/igraph/pull/1881,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1881#issuecomment-989140540,"Rewrite FindGLPK.cmake to allow for version check
Simplify FindGMP.cmake. While it looks in fewer places, it is consistent with FindGLPK.cmake. We can maybe do this for other libraries too. GMP_PREFIX is not necessary because there is the standard GMP_ROOT (provided automatically by CMake for any package)
Provide support for checking package versions in dependencies.cmake and check that GLPK >= 4.57

Fixes #1879",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,1,https://github.com/igraph/igraph/pull/1888,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,2,https://github.com/igraph/igraph/pull/1888#issuecomment-992420891,,Initial draft to implement the igraph_is_forest function mentioned here,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1888#issuecomment-992543099,,"Don't forget to add your function to doc/structural.xxml, so its documentation will be included.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1888#issuecomment-992564255,,"I think you've got a lot of the structure already correctly figured out 🙂
You've not added documentation yet, you can already include that as well.
I think you can continue. I'm interested to see your algorithm 🙂",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,5,https://github.com/igraph/igraph/pull/1888#issuecomment-993755189,,"Hey @GroteGnoom, I tried to run unit tests locally and realized that igraph_is_forest function isn't recognised in the files. I thought adding it to igraph_structural.h would be enough. Can you help me fix this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1888#issuecomment-993799741,,"That's strange. I'll check it myself too. You're sure it's the header, and not the linking?
Can you show me an error message? I've used your PR and it seems to work just fine.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,7,https://github.com/igraph/igraph/pull/1888#issuecomment-993818665,,"The error when I run the tests 168/401 Test #168: test::igraph_is_forest.............................***Failed    0.70 sec Test exited abnormally with error: Access violation
And when I hover over the function it shows this instead of the parameters",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/1888#issuecomment-993822104,,"I think those are two separate problems. Maybe the access violation is because you're not initializing everything properly, but that's hard to check without seeing all your code. I don't know why your IDE doesn't recognize the function, my vim did recognize it.
Try to push a minimal example that you expect to work and I can more easily look at it. That's why a draft is so nice, it doesn't have to be perfect :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,9,https://github.com/igraph/igraph/pull/1888#issuecomment-993838640,,"This is the current version, it works when I add the function on top of it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,10,https://github.com/igraph/igraph/pull/1888#issuecomment-993847966,,For me it builds fine but segfaults. I'll check things out and add some comments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1888#issuecomment-993863466,,Your undirected graph with cycle seems to segfault.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,12,https://github.com/igraph/igraph/pull/1888#issuecomment-993866009,,As for your build problems: Did you do a cmake .. and then a cmake --build . --target check in you build folder?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,13,https://github.com/igraph/igraph/pull/1888#issuecomment-993872115,,"Your undirected graph with cycle seems to segfault.

Oh! I accidentally added 6 vertices instead of 5.

Did you do a cmake .. and then a cmake --build . --target check

Yes, I will try to clone the repo again in another folder, maybe that might work.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,14,https://github.com/igraph/igraph/pull/1888#issuecomment-994962694,,"I have made the required changes, could you check if I missed something. Also currently this function is in forest.c (new file) but it could be moved to the trees.c file. Let me know if moving it there would be better.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,15,https://github.com/igraph/igraph/pull/1888#issuecomment-995034151,,"There's also another issue that needs to be resolved: the conflict with the include/igraph_structural.h
Did you maybe base your branch on master instead of develop?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,16,https://github.com/igraph/igraph/pull/1888#issuecomment-995039633,,"Did you maybe base your branch on master instead of develop?

Yes, thats why the functions still had int return type. I think that merge conflict can be resolved by just removing the int functions. Will this work?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,17,https://github.com/igraph/igraph/pull/1888#issuecomment-995046428,,"I think so, it seems like it's going to work out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,18,https://github.com/igraph/igraph/pull/1888#issuecomment-995071322,,"All right, that merge cleaned a lot of things up, thanks :) I think I will stop reviewing soon, and maybe continue tomorrow. We should try to pass the tests, but right now your res is of different types in the two functions, so it will not compile, because you try to pass it between them.",True,{'THUMBS_UP': ['https://github.com/rohitt28']}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/GroteGnoom,19,https://github.com/igraph/igraph/pull/1888#issuecomment-996063473,,"I think looks pretty great, and you done very good work. It was a pleasure working with you on this, thanks 🙂 I will leave it up to someone else do the final checks. @ntamas, can you take a look?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,20,https://github.com/igraph/igraph/pull/1888#issuecomment-996093485,,Thanks a lot for your helpful reviews. I will keep these suggestions in mind while contributing again.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/apps/codecov,21,https://github.com/igraph/igraph/pull/1888#issuecomment-996232572,,"Codecov Report

Merging #1888 (06962d7) into develop (5d346c8) will increase coverage by 0.03%.
The diff coverage is 97.59%.


@@             Coverage Diff             @@
##           develop    #1888      +/-   ##
===========================================
+ Coverage    73.87%   73.91%   +0.03%     
===========================================
  Files          342      342              
  Lines        57759    57845      +86     
===========================================
+ Hits         42672    42758      +86     
  Misses       15087    15087              



Impacted Files
Coverage Δ





src/properties/trees.c
71.28% <97.59%> (+18.34%)
⬆️


src/math/utils.c
29.11% <0.00%> (+5.42%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 5d346c8...06962d7. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/ntamas,22,https://github.com/igraph/igraph/pull/1888#issuecomment-996234198,,"Also, please take a look at the code coverage report here and try to exercise all newly added code paths in the unit tests. It seems like the case of the single-vertex graph is not covered. There is a branch in the forest visitor that the unit tests do not cover either.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1888#issuecomment-996237750,,I'd like to have the chance to review this before it is merged. Please give me a couple of days.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1888#issuecomment-996648858,,"Actually I think this is correct. The question can be put as: if there is a cycle in the graph, is it certain that at least one vertex will be ""discovered"" more than once (i.e. pushed onto the stack more than once) before it is fully processed.
The remaining part is the counting of visited vertices: why did you keep this check?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,25,https://github.com/igraph/igraph/pull/1888#issuecomment-996657115,,"counting of visited vertices: why did you keep this check?

Do you mean this one?
if(*res) { *res= visited_count==vcount; }
If yes then, in case of directed graph there could be 1 separate component with only 1 node that has self loop.
That node will have degree 1 so the  igraph_forest_visitor function will not be called for it. Then if rest of graph is a forest then we will get wrong output.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/rohitt28,26,https://github.com/igraph/igraph/pull/1888#issuecomment-996730614,,"if there is a cycle in the graph, is it certain that at least one vertex will be ""discovered"" more than once (i.e. pushed onto the stack more than once) before it is fully processed.

You are probably right about that. I tried some test cases in which I thought current algo will fail but it seems to pass.
For eg: igraph_small(&graph, 6, 0, 0, 1, 0, 2, 2, 1, -1); Anyways, I will just use another vector to keep track of parents.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1888#issuecomment-996755400,,"If yes then, in case of directed graph there could be 1 separate component with only 1 node that has self loop.
That node will have degree 1 so the igraph_forest_visitor function will not be called for it. Then if rest of graph is a forest then we will get wrong output.

Yes, you are correct about this.
Please give me a couple more days to convince myself about the correctness of the algorithm, or otherwise find a counterexample, and I'll get back to you. One reason why it is tricky is that if we skip pushing visited vertices on the stack then unvisited vertices will be pushed more than once only in the undirected case, not the directed case. That's of course not a problem because we only check for the visited status in the undirected case. I'm just explaining why I found this confusing: even though the code for the directed and undirected cases is almost identical, the way they work is quite different.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/szhorvat,28,https://github.com/igraph/igraph/pull/1888#issuecomment-996913608,,"@rohitt28 Thanks again for implementing this! Everything's fine with the algorithm. Can you fix the small issues I commented on, and double-check the formatting? Then I'll add a few comments and a few small documentation edits and we can merge this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/szhorvat,29,https://github.com/igraph/igraph/pull/1888#issuecomment-997029233,,"Summary of changes I made:
There were a couple of places where roots was accessed without checking that it is not NULL.
We now re-use the stack and neighbours vector across calls to the visitor function.
Added another test.
The rest are cosmetic changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/szhorvat,30,https://github.com/igraph/igraph/pull/1888#issuecomment-997031350,,"I think this is good to merge now.
Thanks so much for your work @rohitt28!",True,{'THUMBS_UP': ['https://github.com/rohitt28']}
igraph/igraph,https://github.com/igraph/igraph,1888,2021-12-13T12:12:53Z,2021-12-17T21:14:24Z,2021-12-18T03:17:45Z,MERGED,True,426,1,6,https://github.com/rohitt28,Check if a graph is a forest,22,[],https://github.com/igraph/igraph/pull/1888,https://github.com/ntamas,31,https://github.com/igraph/igraph/pull/1888#issuecomment-997035288,,Thanks a lot @rohitt28 !,True,{'THUMBS_UP': ['https://github.com/rohitt28']}
igraph/igraph,https://github.com/igraph/igraph,1890,2021-12-14T17:22:09Z,2021-12-14T17:25:20Z,2021-12-14T17:25:20Z,CLOSED,False,29574,30786,728,https://github.com/pradkrish,[WIP] create tree from parents,334,[],https://github.com/igraph/igraph/pull/1890,https://github.com/pradkrish,1,https://github.com/igraph/igraph/pull/1890,A very preliminary implementation,A very preliminary implementation,True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/pradkrish,1,https://github.com/igraph/igraph/pull/1891,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1891#issuecomment-993869074,,"For easier reference:
Fixes #1840",True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1891#issuecomment-993881389,,"I don't think I have the time to go through everything thoroughly,  but I'll at least add some comments :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1891#issuecomment-993892761,,"You don't seem to use the visited vector to check for cycles. Maybe you can add a test case for for a 2-edge cycle, which I think is detected correctly, and then a 3-edge cycle, which I think is not detected properly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1891#issuecomment-1014233032,,Happy new year! Let us know if you are still working on this project.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1891#issuecomment-1026622599,,@pradkrish Are you still planning to work on this?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/pradkrish,7,https://github.com/igraph/igraph/pull/1891#issuecomment-1029338959,,"@szhorvat Yes although I haven't even had time to even log into my github account for some weeks now. Omicron, school closures etc. Thanks for the nudge, I will try to get back to this as soon as I can.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1891#issuecomment-1032997299,,"I have merged the recent changes of the develop branch to this PR. @pradkrish if you resume working on this PR, you should run git pull first in your own copy to get the changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1891#issuecomment-1088410837,,"@pradkrish Are you planning to continue this project? It's alright if not, we just need to know how to proceed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1891,2021-12-14T17:39:49Z,,2022-05-26T09:28:46Z,OPEN,False,115,0,3,https://github.com/pradkrish,[WIP] tree from parents,2,[],https://github.com/igraph/igraph/pull/1891,https://github.com/pradkrish,10,https://github.com/igraph/igraph/pull/1891#issuecomment-1136416298,,"Hello, I am back now to resume working on this. I need to refresh my mind where I left off. It looks like there is some discussion to follow up. Should I still continue with this or are there other plans?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/ayushagr2002,1,https://github.com/igraph/igraph/pull/1892,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,2,https://github.com/igraph/igraph/pull/1892#issuecomment-995010912,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","You pushed three binary files, can you remove them?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1892#issuecomment-995021988,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",Thanks for your draft :) I've added some comments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/ayushagr2002,4,https://github.com/igraph/igraph/pull/1892#issuecomment-995416250,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",Thank you for the suggestions. I will make changes accordingly and make commits again.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1892#issuecomment-995506567,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",General nitpick: please put spaces after your commas.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1892#issuecomment-995602286,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",The binary file examples/simple/igraph_ring is still there and can be removed.,True,{'THUMBS_UP': ['https://github.com/ayushagr2002']}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1892#issuecomment-996069497,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","If you can still put those spaces after your commas, then you can press 'ready for review' and I'll hand it over to someone else for a final checkup. Thanks for your work 🙂",True,{'HEART': ['https://github.com/ayushagr2002']}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/1892#issuecomment-996159655,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",(The undirected n=2 case still needs to be checked),True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/ayushagr2002,9,https://github.com/igraph/igraph/pull/1892#issuecomment-996418613,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",Can you tell what should the graph look like for this case?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/ayushagr2002,10,https://github.com/igraph/igraph/pull/1892#issuecomment-996422828,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","For the case of n=2, the edge from 0-1 is the same as 1-0, so does it make sense for a closed loop in an undirected graph with two vertices? Please give your views.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1892#issuecomment-996463216,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","It matters if there is one edge between 0 and 1, or if there are two. With one edge you can't make a cycle, and with two you can.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/ayushagr2002,12,https://github.com/igraph/igraph/pull/1892#issuecomment-996488391,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","2-cycle graph:
0 1
0 1

Is this the expected output for undirected n=2?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1892#issuecomment-997034228,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","Is this the expected output for undirected n=2?

Yes.  It is a 2-cycle:",True,{'THUMBS_UP': ['https://github.com/ayushagr2002']}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1892#issuecomment-997359934,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","This is one possible solution, but as I said in this comment, we would like to make igraph_ring() completely independent of igraph_lattice(). Can you write an implementation that does not call igraph_lattice()?",True,{'THUMBS_UP': ['https://github.com/ayushagr2002']}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1892#issuecomment-997386832,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","There are a number of problems here that need to be fixed before we can go on with the review.
First, this PR appears to be based on a very old version of the develop branch, much older than what was current when you opened the PR, and from well before igraph was refactored to use igraph_integer_t consistently. I'm not sure how this happened, but there are many conflicts with the current develop. Make sure you base the work on the latest develop branch and that there are no merge conflicts. In fact, it might be easiest for you to create a new PR.
Second, you seem to have reformatted the entire regular.c file in a style that is different from what the rest of igraph uses. Please do not modify any code unrelated to igraph_ring. For the code that you do need to  touch, use the same style that you see in the rest of igraph.
Finally, do not commit irrelevant files (such as the examples/simple/igraph_ring executable).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1892#issuecomment-1002151778,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",@ayushagr2002 Are you still working on this?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/ayushagr2002,17,https://github.com/igraph/igraph/pull/1892#issuecomment-1002159083,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","Hi, I apologise for the inactivity due to some health issues. I will start working on it from now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/1892#issuecomment-1002187700,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","No problem, hope you are well now. There is no rush, I just wanted to make sure that you are still interested in completing this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1892#issuecomment-1014232421,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",I hope you are doing better. Let us know if you are still working on this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1892#issuecomment-1026654972,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.","@ayushagr2002 Are you still planning to finish this PR? If you don't have time, that's alright, but we need to know how to move forward.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1892,2021-12-15T07:14:03Z,2022-02-11T15:54:30Z,2022-02-11T15:54:30Z,CLOSED,False,250,103,4,https://github.com/ayushagr2002,Reimplementation of igraph_ring(),8,[],https://github.com/igraph/igraph/pull/1892,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1892#issuecomment-1036357049,"I have written initial implementation for the case of closed circular graphs when calling igraph_ring() when n=1 or 2. Please review and further guidance on it.
Fixes #1870.",Closing due to no response.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,1,https://github.com/igraph/igraph/pull/1893,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/1893#issuecomment-995684289,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Looks fine to me so far, apart from the comments I added above. The headers look okay, we can adjust later as you go ahead with the PR if needed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,3,https://github.com/igraph/igraph/pull/1893#issuecomment-997407269,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Hello! Just had a chance to read over the existing dijkstra code in detail (specifically, the implementation of igraph_shortest_paths_dijkstra() in paths/dijkstra.c), and I have a question about the 2 way heap. What exactly do igraph_2wheap_has_elem() and igraph_2wheap_has_active() do? They seem to return something related to VECTOR(h->index2)[idx], which judging by igraph_2wheap_get is an index in the data vector (albeit offset by 2). What does the index in the data vector have to do with 'having an element' or whether an element 'is active'?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1893#issuecomment-997477633,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Okay, so, the 2wheap isn't really well-documented (and it's not part of the public API either). I'm sorry about the lack of docs, but this is a good opportunity to improve the documentation :)
So, igraph_2wheap_t contains a size property and a data vector; these constitute a ""normal"" heap of doubles so there's not much to see here. Then we have index, which is an index (an integer) associated to each element in the heap. Let's call this ""item"" instead of index because it will become confusing later :)
So, when you push values into the heap, you push item-value pairs with igraph_2wheap_push_with_index(). The value that you push into the heap goes in data, while the item corresponding to the value (think vertex or edge indices) goes in index. When you swap two elements in the heap while maintaining the heap invariant, you swap them both in data (which swaps the values) and also swap them in index (which swaps the items); they are always moved as if they were a single pair. The maximum element is always at data[0], and the corresponding item is in index[0].
Now, the problem with the data structure so far is that looking up the value corresponding to an item is an O(n) operation because you need to scan the entire index array to find the item you are looking for. E.g., if you use the max-heap to store path lengths leading to vertices, and you want to know the length of the path leading to vertex 42, you need to scan the entire index array, find where 42 is in it, and then look at the corresponding cell in data. That's why we have index2 -- looking up index2[42] would tell you where item 42 is in index and data in O(1) time.
The dirty little secret of index2 is that it is not true that index[index2[42]] == 42 and data[index2[42]] == the-value-corresponding-to-item-42 because there are two special values: 0 and 1:

When index2[x] == 0, it means that item 42 is not in the heap at all. We need to do it like this because igraph_vector_long_init(&h->index2, ...) initializes the index2 array to all-zeros, and we don't want to rewrite the values again to another special value (say, -1). So, zero in index2 means ""item does not exist"". igraph_2wheap_has_elem(heap, item) will return false if heap->index2[item] is zero and true otherwise.
The other special value in index2 is 1, which means ""item is deactivated"". Deactivated items are just like removed items; igraph_2wheap_deactivate_max() basically pops the max item from the heap just like igraph_2wheap_delete_max(), the only difference is that you can distinguish between genuine removal and deactivation with igraph_2wheap_has_elem() and igraph_2wheap_has_active(). If the item is in the heap, both return true. If the item was deactivated but not deleted, igraph_2wheap_has_elem() returns true and igraph_2wheap_has_active() returns false. If the item was deleted, both return false.
And, of course you may have guessed it by now: if the item is truly in the heap and has not been deactivated, heap->index2[item] - 2 tells you the index where you should look for its value in heap->data[...].

Also, the meaning of ""deactivated"" and ""deleted"" depends on the concrete use-case of igraph_2wheap_t. I guess in Dijkstra's algorithm we push items in the heap when they are reached for the first time, and we deactivate them when we have popped them off the queue in Dijkstra's algorithm so we know that we have reached them and none of the newly discovered edges may change the lengths of the shortest paths leading to them.
I hope this helps.",True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,5,https://github.com/igraph/igraph/pull/1893#issuecomment-998351304,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","That explanation was awesome, thanks a bunch! I hadn't realised that removing and deactivating were two separate things, but it makes so much more sense now :). If I get time I'd like to contribute a PR paraphrasing your explanation into the relevant file, if that's okay?",True,"{'ROCKET': ['https://github.com/szhorvat', 'https://github.com/ntamas']}"
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/apps/codecov,6,https://github.com/igraph/igraph/pull/1893#issuecomment-998495862,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Codecov Report

Merging #1893 (8107afe) into develop (8ba233d) will increase coverage by 0.83%.
The diff coverage is 97.02%.


@@             Coverage Diff             @@
##           develop    #1893      +/-   ##
===========================================
+ Coverage    74.93%   75.77%   +0.83%     
===========================================
  Files          347      350       +3     
  Lines        57867    57807      -60     
===========================================
+ Hits         43363    43801     +438     
+ Misses       14504    14006     -498     



Impacted Files
Coverage Δ





src/paths/widest_paths.c
97.02% <97.02%> (ø)



src/core/error.c
71.56% <0.00%> (-4.34%)
⬇️


src/io/dimacs.c
68.10% <0.00%> (-2.44%)
⬇️


src/core/strvector.c
77.47% <0.00%> (-2.22%)
⬇️


src/core/vector_ptr.c
92.07% <0.00%> (-0.93%)
⬇️


src/constructors/de_bruijn.c
83.33% <0.00%> (-0.67%)
⬇️


src/core/vector.pmt
87.68% <0.00%> (-0.55%)
⬇️


src/graph/adjlist.c
63.35% <0.00%> (-0.54%)
⬇️


src/core/matrix.pmt
84.43% <0.00%> (-0.42%)
⬇️


src/io/ncol.c
9.81% <0.00%> (-0.38%)
⬇️


... and 47 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8ba233d...8107afe. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1893#issuecomment-998728267,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Yes, please, go ahead and feel free to improve the comments about igraph_2wheap_t. There's no need to make it super pretty as it is not part of the public API so it won't appear anywhere on the homepage. Just make it detailed enough that the next time we need it I won't have to read the source code again to figure out how things work :)",True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,8,https://github.com/igraph/igraph/pull/1893#issuecomment-999582385,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Okay, all the code is done. All that remains is to write up some more comphrensive tests, as well as further documentation.
I was originally planning to implement igraph_get_all_widest_paths, but I couldn't figure out a way to do it efficiently. It's not like igraph_get_all_shortest_paths because in that function, each path only traverses nodes in an order such that the distance from the source strictly increases which greatly narrows down the number of paths you can take. For igraph_get_all_widest_paths, the width is only non-increasing as you go further away from the source. This means that for certain cases (for example one where all the edge weights are the same weight), then finding all widest paths is equivalent to finding every path from one node to every other in an unweighted graph. This can be done with a DFS, but it's no better than the original brute force that inspired this issue. Hence, I've decided I won't be including igraph_get_all_widest_paths, unless we can find a better way to do it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1893#issuecomment-999617940,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","I won't be able to go through it for a while, just wanted to make sure that you've seen this wiki page:
https://github.com/igraph/igraph/wiki/Checklist-for-new-%28and-old%29-functions
(I think you can skip the functions.yaml part for now, but do consider the other points, if you haven't yet.)",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,10,https://github.com/igraph/igraph/pull/1893#issuecomment-999634163,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Yep, already looked through them for the most part, though I'll check the input vaidity in more detail when I write better tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,11,https://github.com/igraph/igraph/pull/1893#issuecomment-1012145331,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Ok I've finished the tests and documentation, as well as gone through everything in the ""implementing functions checklist"". In particular, I'm curious about my usage of IGRAPH_ALLOW_INTERRUPTION(). I couldn't find documentation on it, so I took my best guess for it. Otherwise, this PR is ready for review!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1893#issuecomment-1012211825,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Can you please resolve the conflicts with develop, to make it easier for us to test locally?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1893#issuecomment-1012215562,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","IGRAPH_ALLOW_INTERRUPTION() is like IGRAPH_ERROR (or like IGRAPH_CHECK). It checks if the user requested interruption, and if yes, it effectively raises an ""error"". Of course, it's not an error, but it's handled exactly the same way. It just has its own error code.
Thus, you need to pay attention to the same things as with any error check (make sure that if an error is found, all resources are properly freed).
Additionally, it's good to pay attention to performance, and not call it in very tight loops. How long the interrupt check takes depends on what's in the interrupt handler: it's different for each high-level interface. But generally the interrupt handler runs very fast, and you don't need to be concerned about it.",True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,14,https://github.com/igraph/igraph/pull/1893#issuecomment-1013132525,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Merge conflicts are resolved, and IGRAPH_ALLOW_INTERRUPTION() is called just a little less frequently now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1893#issuecomment-1015181587,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Out of curiosity, is there a way to run the tests locally before pushing publically to the PR?

Of course! Build the check target. If you use ninja (recommended), then ninja check. If you use make, then make check.
Please do ask any such question freely, and early. It will save you a lot of time and trouble. I always assumed that anyone who contributes a PR would run tests locally.",True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1893#issuecomment-1015275686,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Also, if you want to run a few tests only, you can save some time by running ninja build_tests && ctest -R name_of_test. name_of_test has to be a word or something that is part of the test name; ctest will run all tests that matches the regex given there. It also has an option to print the stdout in case of failure.",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1893#issuecomment-1015397902,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",We should write up a development guide detailing all of this.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,18,https://github.com/igraph/igraph/pull/1893#issuecomment-1024160115,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",@szhorvat Just checking the status of this PR. I've fixed the cause of the testing error and this commit is ready for review. Apologies if this was already on your radar!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1893#issuecomment-1024191083,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","It is on my radar, and thanks for the great contribution! Personally, I was very happy to see this work.
Unfortunately, I won't be able to do a proper review for a few weeks due to being overwhelmed with job applications. In order to test this thoroughly, I'd need to update the Mathematica interface of igraph to use the develop branch, which will take a while.
There is some urgency to merging this PR, as well as PR #1763, because @ntamas is working on changes that might affect this (replacing ""pointer vectors"" with ""vector lists""). If someone else could take a thorough look at this, and test is from some high-level interface, that would be really great. Not sure if @vtraag or @GroteGnoom can afford the time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,20,https://github.com/igraph/igraph/pull/1893#issuecomment-1024882806,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",Why test it from some high-level interface specifically?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/1893#issuecomment-1024889422,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","It's not strictly necessary, it's just how I like to test things. It makes it much easier for me to verify that the result is correct in some special cases. Sometimes I implement a very simple (and usually very inefficient) version of the same operation in a high-level language and compare results.
If people are confident about correctness without that sort of verification, then please go ahead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,22,https://github.com/igraph/igraph/pull/1893#issuecomment-1024895105,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","If @vtraag doesn't have time I can do it, but it will probably take me a couple of workdays, including understanding the theory, which means it will take weeks real time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,23,https://github.com/igraph/igraph/pull/1893#issuecomment-1030616493,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Can you use some helper functions to clean up your tests? There seems to be quite a bit of copied code. For example, two tests which only differ in weights should be two function calls with different weights, not two code blocks.
Also, can you remove unnecessary comments, like /* edges */ &edges,. I think that would also make it easier to read.",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,24,https://github.com/igraph/igraph/pull/1893#issuecomment-1032996460,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Eventually this PR will have to be updated so that the function signatures use the newly introduced igraph_vector_int_list_t type instead of an igraph_vector_ptr_t as the former is type-safe while the latter is not.
I'd suggest to go ahead with the review of the PR as is. If everything seems okay, I'll rewrite the functions to use igraph_vector_int_list_t before merging.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,25,https://github.com/igraph/igraph/pull/1893#issuecomment-1034930897,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","The widest paths tests should be a lot more readable now that I've moved most of the repetitive stuff into functions. I've run tests locally and it passes.
Looking at the details of why my tests are failing, I'm assuming it's because it is testing my branch after it's been merged into develop, which already has igraph_vector_ptr_t removed?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,26,https://github.com/igraph/igraph/pull/1893#issuecomment-1034941965,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",igraph_vector_ptr_t was not removed but igraph_paths.h is not including igraph_vector_ptr.h any more in the develop branch.  You can re-add the include and it should compile just fine.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,27,https://github.com/igraph/igraph/pull/1893#issuecomment-1035138208,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","There seems to be a line insrc/cliques/glet.c that stops the code from compiling. Specifically line 373 contains the line
igraph_vector_int_list_pop_back(&mycliques, cl);
which I believe should be
igraph_vector_int_list_remove_back(&mycliques, cl);
Exchanging it allows it to compile locally. Should I open a PR for this issue?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,28,https://github.com/igraph/igraph/pull/1893#issuecomment-1035139364,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","No, thanks, it's okay, I have recently renamed this function and forgot to follow up in develop. I'll do it, no need for a PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,29,https://github.com/igraph/igraph/pull/1893#issuecomment-1035140699,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","All good then, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,30,https://github.com/igraph/igraph/pull/1893#issuecomment-1035154208,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Seems to be more compilation issues with vector lists, this time in src/core/typed_list.pmt:543. I think I'm going to leave this for now, until develop is a bit more stable.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,31,https://github.com/igraph/igraph/pull/1893#issuecomment-1035175897,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","develop should compile again now (except the docs, which are being worked on).",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,32,https://github.com/igraph/igraph/pull/1893#issuecomment-1037224122,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Most functions that take weights also leave the option open to provide a NULL vector for weights, which are then treated as if they're all equal. That should also be possible here, and then all the paths should be equally wide. Maybe we should also do that here? @szhorvat ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,33,https://github.com/igraph/igraph/pull/1893#issuecomment-1037226093,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Since this is going to take a while to evaluate, I'll just make a checklist for confirmed tests, and then they don't have to be checked in one go:

 1. null weight vector
 2. Number of weights don't match number of edges
 3. NaN values in weights
 4. Empty graph
 5. Testing 1 Node Graph
 6. Testing Unreachable Nodes
 7. Testing Self Loops
 8. Testing Multiple Edges
 9. Testing Directed Graphs
 10. Testing Mode
 11. Testing Multiple Widest Paths
 12. Testing 5 Node Simple Graph
 13. Testing 7 Node Wikipedia Graph
 14. Testing Negative Weights -- Maybe print all the results? (comment)
 15. Testing Disconnected Graphs

I've checked if the test results correspond to the documentation.

 There's a few superfluous asserts ((comment)",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/szhorvat,34,https://github.com/igraph/igraph/pull/1893#issuecomment-1037501730,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Most functions that take weights also leave the option open to provide a NULL vector for weights, which are then treated as if they're all equal. That should also be possible here, and then all the paths should be equally wide. Maybe we should also do that here? @szhorvat ?

The problem is that I have never worked with this concept, so it is hard for me as well to judge if this would be useful in some situation. My current thinking is that it is completely pointless to look for widest paths in unweighted graphs. If someone tries to do that, it is likely because they did not understand the problem. Thus, it is better to require weights. It avoids confusion, especially for people who learn graph theory through igraph.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,35,https://github.com/igraph/igraph/pull/1893#issuecomment-1047022492,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","It'll be a couple days before I can really go over the test outputs properly and make sure I didn't do anything else silly.

Saw that the checklist hadn't been started yet, so took the chance to fix up a few minor things with the tests. Namely, making matrices the correct sizes, and making sure to add some asserts to better show the exact thing I'm testing. Tests should also be once again slightly more readable.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,36,https://github.com/igraph/igraph/pull/1893#issuecomment-1061636985,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Just like in the current PR, I've also copied huge chunks of code from src/paths/dijkstra.c in the past, but this makes it much harder to check and maintain the code. I think we should try to use more shared helper functions.
I'll wait with further checking until this is resolved, because it's pretty essential.",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,37,https://github.com/igraph/igraph/pull/1893#issuecomment-1093815307,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","We've talked about it a little bit, and it seems like it's not such an easy problem here to prevent code duplication without affecting performance. For now it seems the best course of action is to just keep going with this review, and later take a good look at all the copied Dijkstra code.",True,{'THUMBS_UP': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,38,https://github.com/igraph/igraph/pull/1893#issuecomment-1100595626,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","We need to think about what to do with #1880 and this PR. It's probably nicer to let everything conform to #1880, but that's not the case for shortest path functions right now, and maybe we want to merge this PR before changing everything.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/ntamas,39,https://github.com/igraph/igraph/pull/1893#issuecomment-1100736793,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","I think it's easier to merge this first and then take care of #1880 than to do the same thing in parallel in both the develop branch and here.
If you feel like this PR is ready apart from the handling of the parent vectors, let's merge this and deal with the parent vector representation later in #1880.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/GroteGnoom,40,https://github.com/igraph/igraph/pull/1893#issuecomment-1100830671,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","@Gomango999 Sorry for the long and weird (I was thinking about the best way to handle it all the time) review process, thanks for all the great work :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/Gomango999,41,https://github.com/igraph/igraph/pull/1893#issuecomment-1101048306,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.","Nope, it's been great looking at how much thought you all put into every PR. Thanks so much everyone for all the feedback and help!!!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/iosonofabio,42,https://github.com/igraph/igraph/pull/1893#issuecomment-1101065826,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",Good job @Gomango999 !,True,{'HEART': ['https://github.com/Gomango999']}
igraph/igraph,https://github.com/igraph/igraph,1893,2021-12-15T14:43:18Z,2022-04-17T08:24:26Z,2022-05-12T08:25:05Z,MERGED,True,1579,1,6,https://github.com/Gomango999,Widest Path Implementations,31,[],https://github.com/igraph/igraph/pull/1893,https://github.com/vtraag,43,https://github.com/igraph/igraph/pull/1893#issuecomment-1124681966,"This pull request implements various means of calculating widest paths, as requested in #1817.
The function headers are essentially identical to the shortest_path_dijkstra variants, since the problem of finding the widest path from a source node to every other node can be implemented as a modified Dijsktra. The only difference is that the igraph_widest_paths function (which only computes the widths and not the actual paths between all pairs of nodes) is split into Dijkstra and Floyd-Warshall implementations. The Floyd-Warshall algorithm will allow more efficient computation of widest paths between all pairs of nodes on dense graphs, as required by the Schulze method. Meanwhile, the Dijkstra implementation is more efficient for sparse graphs.
Note that there are several more implementations mentioned on Wikipedia, some of which are  faster for certain types of graphs then the ones listed above. However, I believe the Dijkstra (O(M log M)) and Floyd-Warshall (O(N^3)) implementations together should be suitable enough for the use cases described in the original issue.",This PR closes issue #1817.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1895,2021-12-20T18:59:33Z,2021-12-20T19:57:51Z,2021-12-20T19:57:51Z,MERGED,True,41,21,1,https://github.com/szhorvat,docs: improve introductory documentation,1,[],https://github.com/igraph/igraph/pull/1895,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1895,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1895,2021-12-20T18:59:33Z,2021-12-20T19:57:51Z,2021-12-20T19:57:51Z,MERGED,True,41,21,1,https://github.com/szhorvat,docs: improve introductory documentation,1,[],https://github.com/igraph/igraph/pull/1895,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1895#issuecomment-998191813,,"Codecov Report

Merging #1895 (3794af3) into master (d243f0b) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1895   +/-   ##
=======================================
  Coverage   72.39%   72.39%           
=======================================
  Files         295      295           
  Lines       57487    57487           
=======================================
  Hits        41619    41619           
  Misses      15868    15868           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d243f0b...3794af3. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1896,2021-12-20T22:39:57Z,2021-12-23T21:29:17Z,2021-12-23T21:29:21Z,MERGED,True,836,754,20,https://github.com/ntamas,Removing igraph_get_eids_multi() and adding igraph_get_all_eids_between(),11,[],https://github.com/igraph/igraph/pull/1896,https://github.com/ntamas,1,https://github.com/igraph/igraph/pull/1896,"This PR attempts to remove igraph_get_eids_multi() from the core API and replace it with igraph_get_all_eids_between(). It also attempts to remove the path argument of igraph_get_eids() in order to simplify the core API.
The primary reason for removing igraph_get_eids_multi() is that it does not make it possible to retrieve the edge IDs of all the edges between a pair of vertices without knowing in advance how many such edges there are between the pair. As such, I don't believe it has any use, which seems to be confirmed by the fact that the edge selector relying on this core API has been left incomplete for years now (for instance, the function that would have returned the number of edges selected by the selector was unimplemented).
The reason for removing the path argument of igraph_get_eids() is that it can be replicated by igraph_get_eids() and its pairs argument. igraph_get_eids() in its old version was essentially trying to do two different things (retrieving edge IDs by either pairs of vertices or a path of vertex IDs); now it does only one thing. A new function named igraph_expand_path_to_pairs() is provided to obtain a ""pairs vector"" from a ""path vector"".
This PR is a work in progress; I'm primarily soliciting feedback at this stage and exercising Codecov to figure out which parts need unit testing.","This PR attempts to remove igraph_get_eids_multi() from the core API and replace it with igraph_get_all_eids_between(). It also attempts to remove the path argument of igraph_get_eids() in order to simplify the core API.
The primary reason for removing igraph_get_eids_multi() is that it does not make it possible to retrieve the edge IDs of all the edges between a pair of vertices without knowing in advance how many such edges there are between the pair. As such, I don't believe it has any use, which seems to be confirmed by the fact that the edge selector relying on this core API has been left incomplete for years now (for instance, the function that would have returned the number of edges selected by the selector was unimplemented).
The reason for removing the path argument of igraph_get_eids() is that it can be replicated by igraph_get_eids() and its pairs argument. igraph_get_eids() in its old version was essentially trying to do two different things (retrieving edge IDs by either pairs of vertices or a path of vertex IDs); now it does only one thing. A new function named igraph_expand_path_to_pairs() is provided to obtain a ""pairs vector"" from a ""path vector"".
This PR is a work in progress; I'm primarily soliciting feedback at this stage and exercising Codecov to figure out which parts need unit testing.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1896,2021-12-20T22:39:57Z,2021-12-23T21:29:17Z,2021-12-23T21:29:21Z,MERGED,True,836,754,20,https://github.com/ntamas,Removing igraph_get_eids_multi() and adding igraph_get_all_eids_between(),11,[],https://github.com/igraph/igraph/pull/1896,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1896#issuecomment-998325069,"This PR attempts to remove igraph_get_eids_multi() from the core API and replace it with igraph_get_all_eids_between(). It also attempts to remove the path argument of igraph_get_eids() in order to simplify the core API.
The primary reason for removing igraph_get_eids_multi() is that it does not make it possible to retrieve the edge IDs of all the edges between a pair of vertices without knowing in advance how many such edges there are between the pair. As such, I don't believe it has any use, which seems to be confirmed by the fact that the edge selector relying on this core API has been left incomplete for years now (for instance, the function that would have returned the number of edges selected by the selector was unimplemented).
The reason for removing the path argument of igraph_get_eids() is that it can be replicated by igraph_get_eids() and its pairs argument. igraph_get_eids() in its old version was essentially trying to do two different things (retrieving edge IDs by either pairs of vertices or a path of vertex IDs); now it does only one thing. A new function named igraph_expand_path_to_pairs() is provided to obtain a ""pairs vector"" from a ""path vector"".
This PR is a work in progress; I'm primarily soliciting feedback at this stage and exercising Codecov to figure out which parts need unit testing.","Codecov Report

Merging #1896 (d705f60) into develop (05fd992) will increase coverage by 0.07%.
The diff coverage is 75.63%.


❗ Current head d705f60 differs from pull request most recent head 58a1a95. Consider uploading reports for the commit 58a1a95 to get more accurate results


@@             Coverage Diff             @@
##           develop    #1896      +/-   ##
===========================================
+ Coverage    73.93%   74.00%   +0.07%     
===========================================
  Files          342      343       +1     
  Lines        57854    57750     -104     
===========================================
- Hits         42773    42740      -33     
+ Misses       15081    15010      -71     



Impacted Files
Coverage Δ





src/graph/type_common.c
37.93% <37.93%> (ø)



src/flow/flow.c
87.42% <57.14%> (-0.28%)
⬇️


src/graph/type_indexededgelist.c
93.34% <78.26%> (+10.91%)
⬆️


src/graph/iterators.c
76.66% <93.18%> (+0.92%)
⬆️


src/centrality/truss.cpp
100.00% <100.00%> (ø)



src/misc/other.c
91.77% <100.00%> (+0.86%)
⬆️


src/centrality/coreness.c
89.39% <0.00%> (-0.16%)
⬇️


src/graph/visitors.c
85.18% <0.00%> (-0.07%)
⬇️


src/paths/unweighted.c
93.04% <0.00%> (-0.04%)
⬇️


... and 6 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 05fd992...58a1a95. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1896,2021-12-20T22:39:57Z,2021-12-23T21:29:17Z,2021-12-23T21:29:21Z,MERGED,True,836,754,20,https://github.com/ntamas,Removing igraph_get_eids_multi() and adding igraph_get_all_eids_between(),11,[],https://github.com/igraph/igraph/pull/1896,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1896#issuecomment-998349858,"This PR attempts to remove igraph_get_eids_multi() from the core API and replace it with igraph_get_all_eids_between(). It also attempts to remove the path argument of igraph_get_eids() in order to simplify the core API.
The primary reason for removing igraph_get_eids_multi() is that it does not make it possible to retrieve the edge IDs of all the edges between a pair of vertices without knowing in advance how many such edges there are between the pair. As such, I don't believe it has any use, which seems to be confirmed by the fact that the edge selector relying on this core API has been left incomplete for years now (for instance, the function that would have returned the number of edges selected by the selector was unimplemented).
The reason for removing the path argument of igraph_get_eids() is that it can be replicated by igraph_get_eids() and its pairs argument. igraph_get_eids() in its old version was essentially trying to do two different things (retrieving edge IDs by either pairs of vertices or a path of vertex IDs); now it does only one thing. A new function named igraph_expand_path_to_pairs() is provided to obtain a ""pairs vector"" from a ""path vector"".
This PR is a work in progress; I'm primarily soliciting feedback at this stage and exercising Codecov to figure out which parts need unit testing.","igraph_get_all_eids_between() does not work yet, FYI. Stay tuned.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1898,2021-12-23T12:40:14Z,2021-12-23T21:31:10Z,2021-12-23T21:31:28Z,MERGED,True,146,39,3,https://github.com/szhorvat,perf: minor speedup and refactor for weak connectedness,5,[],https://github.com/igraph/igraph/pull/1898,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1898,"igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.","igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1898,2021-12-23T12:40:14Z,2021-12-23T21:31:10Z,2021-12-23T21:31:28Z,MERGED,True,146,39,3,https://github.com/szhorvat,perf: minor speedup and refactor for weak connectedness,5,[],https://github.com/igraph/igraph/pull/1898,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1898#issuecomment-1000279483,"igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.","Codecov Report

Merging #1898 (7057a19) into master (2443cab) will increase coverage by 0.00%.
The diff coverage is 86.66%.


@@           Coverage Diff           @@
##           master    #1898   +/-   ##
=======================================
  Coverage   72.39%   72.40%           
=======================================
  Files         295      295           
  Lines       57487    57501   +14     
=======================================
+ Hits        41619    41633   +14     
  Misses      15868    15868           



Impacted Files
Coverage Δ





src/connectivity/components.c
94.40% <86.66%> (+0.13%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 2443cab...7057a19. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1898,2021-12-23T12:40:14Z,2021-12-23T21:31:10Z,2021-12-23T21:31:28Z,MERGED,True,146,39,3,https://github.com/szhorvat,perf: minor speedup and refactor for weak connectedness,5,[],https://github.com/igraph/igraph/pull/1898,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1898#issuecomment-1000309645,"igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.","Note to self: we need to merge this into develop where there will be some conflicts due to the integer transition.

I'll do that merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1898,2021-12-23T12:40:14Z,2021-12-23T21:31:10Z,2021-12-23T21:31:28Z,MERGED,True,146,39,3,https://github.com/szhorvat,perf: minor speedup and refactor for weak connectedness,5,[],https://github.com/igraph/igraph/pull/1898,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1898#issuecomment-1000322005,"igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.","I added one more small optimization using the number of edges.
Take a look at my comment above. If you still want ""connectivity"", I'll change it to that and merge into master, then into develop, then update the changelog.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1898,2021-12-23T12:40:14Z,2021-12-23T21:31:10Z,2021-12-23T21:31:28Z,MERGED,True,146,39,3,https://github.com/szhorvat,perf: minor speedup and refactor for weak connectedness,5,[],https://github.com/igraph/igraph/pull/1898,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1898#issuecomment-1000346263,"igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.","@ntamas This ended up with a bunch more commits. Please take another look, and I'll merge based on your final comments (both into master and develop). I have to go out now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1898,2021-12-23T12:40:14Z,2021-12-23T21:31:10Z,2021-12-23T21:31:28Z,MERGED,True,146,39,3,https://github.com/szhorvat,perf: minor speedup and refactor for weak connectedness,5,[],https://github.com/igraph/igraph/pull/1898,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1898#issuecomment-1000531937,"igraph_is_connected_weak():

terminate the search as soon as all nodes have been reached
avoid repeated calls to igraph_vector_size()
refactor for readability

I change the behaviour of igraph_is_connected_weak() for the null graph. This makes no difference as this is an internal function that was not used anywhere except from igraph_is_connected(), which already caught the case of the null graph. But let's be consistent: igraph_is_connected_weak() should always return the same result as igraph_is_connected() called in WEAK mode.
There were also some sloppinesses in there, e.g. already_added[neighbor]++ actually only ever incremented a 0 to a 1. Using ++ is confusing because it suggest repeated increments. The type is a char, which could overflow with repeated increments, so at first I thought something was wrong.
@ntamas, if you don't like where I put some of the declarations, let me know and I'll move them all to the top. The principle was to combine declaration with initialization.",THanks a lot! I've merged this into master; it would be great if you coudl take care of develop.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1902,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1902#issuecomment-1001221202,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","Codecov Report

Merging #1902 (f452ae9) into master (ce9c007) will increase coverage by 0.06%.
The diff coverage is 87.32%.


@@            Coverage Diff             @@
##           master    #1902      +/-   ##
==========================================
+ Coverage   72.39%   72.46%   +0.06%     
==========================================
  Files         295      295              
  Lines       57512    57640     +128     
==========================================
+ Hits        41638    41771     +133     
+ Misses      15874    15869       -5     



Impacted Files
Coverage Δ





src/isomorphism/isoclasses.c
89.34% <ø> (+11.25%)
⬆️


src/misc/motifs.c
94.20% <87.32%> (-0.61%)
⬇️


src/isomorphism/lad.c
95.22% <0.00%> (-0.13%)
⬇️


src/constructors/famous.c
68.00% <0.00%> (ø)



src/isomorphism/bliss/graph.cc
69.91% <0.00%> (+0.08%)
⬆️


src/random/random.c
60.20% <0.00%> (+0.14%)
⬆️


src/games/erdos_renyi.c
94.65% <0.00%> (+0.76%)
⬆️


src/cliques/cliques.c
90.26% <0.00%> (+1.10%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update ce9c007...f452ae9. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1902#issuecomment-1001249315,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","This is ready for general feedback, as it seems to be working correctly now, but I'll still make a few changes to simplify test code. The main test, which was modified here, will use a smaller graph so reduce the running time (LAD is slow at these motif sizes).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1902#issuecomment-1001250969,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","There's the question of where to put the code I used to create the lookup tables. It's written in Mathematica. We should keep it, otherwise it will be a pain to re-do everything from scratch next time we need to touch this functionality. I was hoping to make it short enough to insert it in comments, but that didn't quite work out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1902#issuecomment-1001495905,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","There's the question of where to put the code I used to create the lookup tables.

Put them in tools; this is where we keep the LAPACK patches (I doubt that they still work, though) and an ARPACK-related sed script.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1902#issuecomment-1001654839,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","@ntamas When you review this, please read the comment I added at the top of isoclasses.c and let me know if it is understandable. I'll add the lookup table generator a bit later. Let me know if you're happy with this and I'll do the merge (including the merge into develop). Please don't ""squash-and-merge"". The commits here are many, but clean.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1902#issuecomment-1002135287,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","The reason for the reduced coverage in LAD is that I reduced the graph sizes in the example::igraph_subisomorphic_lad test. This test was already the slowest. With the larger motifs I added, it now takes 3.5 seconds when compiled with all optimizations.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1902#issuecomment-1002291510,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","@ntamas These two are fixed. I'll refrain from force-pushed while you're reviewing, but I'll clean up the commits afterwards.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1902#issuecomment-1002296149,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","Feel free to force-push and then merge, it seems okay to me now!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1902,2021-12-26T17:46:00Z,2021-12-28T22:29:24Z,2021-12-28T22:29:24Z,MERGED,True,2986,694,11,https://github.com/szhorvat,feat: support isoclasses for 5 and 6 vertex undirected graphs,9,[],https://github.com/igraph/igraph/pull/1902,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1902#issuecomment-1002298583,"See forum for details: https://igraph.discourse.group/t/isoclasses-and-motif-finding-for-5-and-6-vertex-graphs/1050
Changes in this PR:

Remove isoclasses arrays. They were not used, and no one remembers what they were for.
Document how the lookup tables are structured.
Add support for 5- and 6-vertex undirected graphs.","@ntamas Can you merge master into develop before I merge this, so I can avoid any plfit-related merge conflicts when I later work on merging this into develop?",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1906,2022-01-01T11:20:30Z,2022-01-02T17:40:55Z,2022-01-02T17:40:55Z,MERGED,True,276,125,8,https://github.com/szhorvat,fix: correct error handling when reading Pajek file,10,[],https://github.com/igraph/igraph/pull/1906,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1906,"@ntamas I need some input here because I am completely new to Bison. If this approach is good, we can use it for all the parsers.
With this fix, the locally run fuzzer did not find crashes, but it does hit the memory limit occasionally. This happens because Pajek files are explicit about the number of vertices, and it is very easy to just use a number which is too large.","@ntamas I need some input here because I am completely new to Bison. If this approach is good, we can use it for all the parsers.
With this fix, the locally run fuzzer did not find crashes, but it does hit the memory limit occasionally. This happens because Pajek files are explicit about the number of vertices, and it is very easy to just use a number which is too large.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1906,2022-01-01T11:20:30Z,2022-01-02T17:40:55Z,2022-01-02T17:40:55Z,MERGED,True,276,125,8,https://github.com/szhorvat,fix: correct error handling when reading Pajek file,10,[],https://github.com/igraph/igraph/pull/1906,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1906#issuecomment-1003545493,"@ntamas I need some input here because I am completely new to Bison. If this approach is good, we can use it for all the parsers.
With this fix, the locally run fuzzer did not find crashes, but it does hit the memory limit occasionally. This happens because Pajek files are explicit about the number of vertices, and it is very easy to just use a number which is too large.","Codecov Report

Merging #1906 (57153be) into develop (d30259c) will decrease coverage by 0.00%.
The diff coverage is 85.29%.


❗ Current head 57153be differs from pull request most recent head 5cb39bb. Consider uploading reports for the commit 5cb39bb to get more accurate results


@@             Coverage Diff             @@
##           develop    #1906      +/-   ##
===========================================
- Coverage    74.10%   74.10%   -0.01%     
===========================================
  Files          343      343              
  Lines        57917    57917              
===========================================
- Hits         42921    42920       -1     
- Misses       14996    14997       +1     



Impacted Files
Coverage Δ





src/io/pajek.c
78.96% <85.29%> (-0.35%)
⬇️


src/isomorphism/bliss.cc
83.07% <0.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d30259c...5cb39bb. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1906,2022-01-01T11:20:30Z,2022-01-02T17:40:55Z,2022-01-02T17:40:55Z,MERGED,True,276,125,8,https://github.com/szhorvat,fix: correct error handling when reading Pajek file,10,[],https://github.com/igraph/igraph/pull/1906,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1906#issuecomment-1003749630,"@ntamas I need some input here because I am completely new to Bison. If this approach is good, we can use it for all the parsers.
With this fix, the locally run fuzzer did not find crashes, but it does hit the memory limit occasionally. This happens because Pajek files are explicit about the number of vertices, and it is very easy to just use a number which is too large.","This approach seems good to me in general, I can't think of a better solution either. Feel free to merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1917,2022-01-05T18:58:49Z,2022-01-05T20:17:48Z,2022-01-05T20:17:48Z,MERGED,True,1,0,1,https://github.com/antonio-rojas,Fix system plfit cmake detection,1,[],https://github.com/igraph/igraph/pull/1917,https://github.com/antonio-rojas,1,https://github.com/igraph/igraph/pull/1917,"The headers are installed under a pflit subdir by default, so the current cmake module can't find them.","The headers are installed under a pflit subdir by default, so the current cmake module can't find them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1917,2022-01-05T18:58:49Z,2022-01-05T20:17:48Z,2022-01-05T20:17:48Z,MERGED,True,1,0,1,https://github.com/antonio-rojas,Fix system plfit cmake detection,1,[],https://github.com/igraph/igraph/pull/1917,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1917#issuecomment-1005997902,"The headers are installed under a pflit subdir by default, so the current cmake module can't find them.","Codecov Report

Merging #1917 (90658e4) into master (6e5c222) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1917   +/-   ##
=======================================
  Coverage   72.52%   72.52%           
=======================================
  Files         295      295           
  Lines       57610    57610           
=======================================
  Hits        41784    41784           
  Misses      15826    15826           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 6e5c222...90658e4. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1917,2022-01-05T18:58:49Z,2022-01-05T20:17:48Z,2022-01-05T20:17:48Z,MERGED,True,1,0,1,https://github.com/antonio-rojas,Fix system plfit cmake detection,1,[],https://github.com/igraph/igraph/pull/1917,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1917#issuecomment-1006046614,"The headers are installed under a pflit subdir by default, so the current cmake module can't find them.",Thanks for the fix!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/jgmbenoit,1,https://github.com/igraph/igraph/pull/1921,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1921#issuecomment-1006411554,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","Codecov Report

Merging #1921 (0bf2b61) into master (1ef00c7) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #1921   +/-   ##
=======================================
  Coverage   72.52%   72.52%           
=======================================
  Files         295      295           
  Lines       57610    57610           
=======================================
  Hits        41784    41784           
  Misses      15826    15826           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1ef00c7...0bf2b61. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1921#issuecomment-1006424187,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","I am not sure if this is necessary. The internal PLFIT should continue to work, and the header should be picked up from the correct location (internal or external, as specified).
Can you please check if things work correctly after the patch in #1917?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1921#issuecomment-1006454737,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","I now verified that an external PLFIT is correctly used after #1917. The correct fix was in that PR, and this change breaks using the vendored PLFIT. I'm closing this now, please let us know if #1917 isn't sufficient.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/jgmbenoit,5,https://github.com/igraph/igraph/pull/1921#issuecomment-1006512879,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","The fix is needed when you build benchmarks outside the source and with an external plfit.
A more proper way might be to add a Requires field in the igraph.pc (see pkg-config(1)  section METADATA FILE SYNTAX).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1921#issuecomment-1006514233,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","Do you mean that you are not building the benchmarks using igraph's build system and the build_benchmarks target? How are you building them then?
Note that this change did break building with the vendored PLFIT. Also, one has to be very careful with such changes to ensure that the correct header gets picked up in all situation (i.e. vendored header in vendored mode and external header in external mode).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/jgmbenoit,7,https://github.com/igraph/igraph/pull/1921#issuecomment-1006525126,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.",I put the benchmarks along the other tests as examples. This allows to run benchmarks during the CI tests.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/jgmbenoit,8,https://github.com/igraph/igraph/pull/1921#issuecomment-1006532817,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","I am aware of the possible mismatches at building time.
I guess that I am attached to how GSL manages its headers. GSL gathers its headers in a gsl folder  and  calls them with a gsl/ prefix so that we do not have to specify the include path in traditional installations. igraph and plfit gather both their headers in a folder but they call their headers with no prefix so that we have to specify the include path even in traditional installations.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1921#issuecomment-1006580245,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","Could you please show what exactly is broken, through a code example? Then we can find a solution for it without breaking other stuff.
For reference, this is how I tested it:

Install PLFIT with -DCMAKE_INSTALL_PREFIX=/my/prefix. Then the headers go into /my/prefix/include/plfit.
Configure igraph with -DCMAKE_PREFIX_PATH=/my/prefix.
Build the benchmarks using cmake --build . --target build_benchmarks",True,{}
igraph/igraph,https://github.com/igraph/igraph,1921,2022-01-06T09:28:46Z,2022-01-06T10:29:57Z,2022-01-06T13:57:19Z,CLOSED,False,1,1,1,https://github.com/jgmbenoit,benchmarks: plfit folder: specify,1,[],https://github.com/igraph/igraph/pull/1921,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1921#issuecomment-1006610420,"This patch specify the folder of the plfit headers
for the benchmark igraph_power_law_fit.c.","I put the benchmarks along the other tests as examples. This allows to run benchmarks during the CI tests.

I'm sorry, I didn't see this message when I responded.
You can run the benchmarks by building the benchmark target, i.e. make benchmark if you use make. The benchmarks, at this point, are more or less just a rough development tool. They are not streamlined like the tests and they don't even work on all platforms (Windows). If you want to run them, it's best to use make instead of ninja because of the immediate output.
Does this help?
The benchmarks need a lot more work before they can be made part of an actually useful automated CI run, such as extracting and summarizing the timings. It would be nice to do this, there just wasn't enough time yet. They're not run on GitHub Actions and Azure because the timings are unpredictable there. They are only built, to ensure that they do not break when making breaking changes to the library.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1935,2022-01-19T08:41:19Z,2022-01-20T10:31:46Z,2022-01-24T09:35:59Z,CLOSED,False,238,0,3,https://github.com/kwofach,Generator for wheel graphs #1874,1,[],https://github.com/igraph/igraph/pull/1935,https://github.com/kwofach,1,https://github.com/igraph/igraph/pull/1935,"As a follow up works of #1874
In order to build, run and test, 3 lines are added to the existing CMakeLists.txt; know it's not proper but cannot figure out the proper way to build, run and test yet :-)
Moreover, currently included all changes in a single file igraph_wheel.c
Looking for your comments (and direction).
Thank you.","As a follow up works of #1874
In order to build, run and test, 3 lines are added to the existing CMakeLists.txt; know it's not proper but cannot figure out the proper way to build, run and test yet :-)
Moreover, currently included all changes in a single file igraph_wheel.c
Looking for your comments (and direction).
Thank you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1935,2022-01-19T08:41:19Z,2022-01-20T10:31:46Z,2022-01-24T09:35:59Z,CLOSED,False,238,0,3,https://github.com/kwofach,Generator for wheel graphs #1874,1,[],https://github.com/igraph/igraph/pull/1935,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1935#issuecomment-1016208895,"As a follow up works of #1874
In order to build, run and test, 3 lines are added to the existing CMakeLists.txt; know it's not proper but cannot figure out the proper way to build, run and test yet :-)
Moreover, currently included all changes in a single file igraph_wheel.c
Looking for your comments (and direction).
Thank you.","There is a lot of useful information in the wiki, in case you have not seen it yet: https://github.com/igraph/igraph/wiki Be sure to check the section on adding unit tests.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1935,2022-01-19T08:41:19Z,2022-01-20T10:31:46Z,2022-01-24T09:35:59Z,CLOSED,False,238,0,3,https://github.com/kwofach,Generator for wheel graphs #1874,1,[],https://github.com/igraph/igraph/pull/1935,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1935#issuecomment-1016836740,"As a follow up works of #1874
In order to build, run and test, 3 lines are added to the existing CMakeLists.txt; know it's not proper but cannot figure out the proper way to build, run and test yet :-)
Moreover, currently included all changes in a single file igraph_wheel.c
Looking for your comments (and direction).
Thank you.","You can also look at this PR to see what files you need to change when you add a new function:
https://github.com/igraph/igraph/pull/1856/files",True,{}
igraph/igraph,https://github.com/igraph/igraph,1935,2022-01-19T08:41:19Z,2022-01-20T10:31:46Z,2022-01-24T09:35:59Z,CLOSED,False,238,0,3,https://github.com/kwofach,Generator for wheel graphs #1874,1,[],https://github.com/igraph/igraph/pull/1935,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1935#issuecomment-1016848882,"As a follow up works of #1874
In order to build, run and test, 3 lines are added to the existing CMakeLists.txt; know it's not proper but cannot figure out the proper way to build, run and test yet :-)
Moreover, currently included all changes in a single file igraph_wheel.c
Looking for your comments (and direction).
Thank you.",Please also rebase to the develop branch 🙂,True,{}
igraph/igraph,https://github.com/igraph/igraph,1935,2022-01-19T08:41:19Z,2022-01-20T10:31:46Z,2022-01-24T09:35:59Z,CLOSED,False,238,0,3,https://github.com/kwofach,Generator for wheel graphs #1874,1,[],https://github.com/igraph/igraph/pull/1935,https://github.com/kwofach,5,https://github.com/igraph/igraph/pull/1935#issuecomment-1017287840,"As a follow up works of #1874
In order to build, run and test, 3 lines are added to the existing CMakeLists.txt; know it's not proper but cannot figure out the proper way to build, run and test yet :-)
Moreover, currently included all changes in a single file igraph_wheel.c
Looking for your comments (and direction).
Thank you.","Sorry, don't know how to keep using this line, another pull request has been made: #1938",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,1,https://github.com/igraph/igraph/pull/1938,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1938#issuecomment-1017972789,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Regarding the allocation of rim_vertex: this vector does not seem necessary to me. Can you come up with a version that does not allocate a vector to store vertex IDs? If not, can you explain why the allocation is necessary?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1938#issuecomment-1022066743,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Can you please merge the develop branch into this PR again and resolve the merge conflicts, so that the CI test would be run again?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,4,https://github.com/igraph/igraph/pull/1938#issuecomment-1022799756,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Only the following job is done:

git pull upstream develop
manually merge changes for tests/CMakeLists.txt
commit and git push origin develop
If additional works is needed, please let me know.
Thank you.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1938#issuecomment-1023972012,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","If additional works is needed, please let me know.

Currently the tests do not pass. Can you fix this?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,6,https://github.com/igraph/igraph/pull/1938#issuecomment-1024000555,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Sorry, could you provide more direction on ""how to""? e.g., I've tried to ""git pull upstream develop"" and ""cmake --build ."" again, and found some new error, but, the error comes from /tests/unit/tree.c which is other developer's works. On the other hand, I've found this web page has a window showing ""All checks have failed"" in red, which small words stating ""currently 21 failing and 1 action required checks"". Could you advice (1) whether I should fix all the things in this window, including to fix other developer's works and (2) how to check whether the modification can pass all the tests?
Thanks again.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1938#issuecomment-1024011767,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","If you click on the ""Files Changed"" tab in this PR, you will see what changes will be made once the PR gets merged.  Notice that tree was somehow added to tests/CMakeLists.txt. Perhaps it's due to a small mistake when merging develop back into your branch and resolving conflicts.  Just remove this line, and it will fix this specific problem.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/apps/codecov,8,https://github.com/igraph/igraph/pull/1938#issuecomment-1024027864,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Codecov Report

Merging #1938 (25e1fff) into develop (8684bc7) will increase coverage by 0.03%.
The diff coverage is 95.55%.


@@             Coverage Diff             @@
##           develop    #1938      +/-   ##
===========================================
+ Coverage    74.13%   74.16%   +0.03%     
===========================================
  Files          345      345              
  Lines        58113    58158      +45     
===========================================
+ Hits         43082    43135      +53     
+ Misses       15031    15023       -8     



Impacted Files
Coverage Δ





src/constructors/regular.c
91.23% <95.55%> (+5.79%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8684bc7...25e1fff. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1938#issuecomment-1024033912,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Can you make sure that files unrelated to work (vector.pmt, igraph_vector_pmt.h) are not modified by this PR? It looks like you accidentally reverted these to an earlier state when you merged develop into this branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,10,https://github.com/igraph/igraph/pull/1938#issuecomment-1024043857,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","I didn't work on vector.pmt nor igraph_vector_pmt.h;
maybe I have performed a ""git pull upstream develop"" which caused the problem.
I've changed ""igraph_tree()"" to ""igraph_kary_tree()"" in this commit according to your advice.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/1938#issuecomment-1024118677,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","I didn't work on vector.pmt nor igraph_vector_pmt.h;
maybe I have performed a ""git pull upstream develop"" which caused the problem.

No problem! These things may happen. It takes some time to get used to working with git.
You should be able to correct this by doing the following steps.

First fetch the latest code from the upstream repository (i.e. the official igraph/igraph repository).

git fetch upstream

To provide a bit of additional explanation: git fetch upstream fetches all code from the upstream repository, so that you have it locally available, but it is different from a git pull, which also merges things in your local branch.

Reset the incorrect files in your local develop branch to the files from the upstream develop branch.

git checkout upstream/develop -- src/core/vector.pmt
git checkout upstream/develop -- include/igraph_vector_pmt.h


Now you can simply add the changed files, commit and push them to your fork, so that they become visible in this PR

git add . -u
git commit -m ""Reset some files to develop branch""
git push

(Doing git add . -u will only update modified files, and will not add any new files that are untracked by git).
If you need more help, just let us know.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,12,https://github.com/igraph/igraph/pull/1938#issuecomment-1024251837,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Thank you very much!
""git fetch upstream"" + ""git checkout upstream/develop --"" is exactly what I was looking for (to rollback original files).
Thanks again!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,13,https://github.com/igraph/igraph/pull/1938#issuecomment-1024816247,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.",This commit fixes the documentation and follow the documentation guidelines: https://github.com/igraph/igraph/wiki/Documentation-guidelines,True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1938#issuecomment-1024943232,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","When you consider this PR ready to merge, please click the ""Ready for review"" button, or let us know that you consider it ready. Right now it still has ""draft"" status.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,15,https://github.com/igraph/igraph/pull/1938#issuecomment-1025046652,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.","Thanks for your advice. Status has been updated to ""ready for review"".",True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1938#issuecomment-1025571126,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.",I'll resolve the conflicts and then merge. Thanks for your contribution @kwofach !,True,{}
igraph/igraph,https://github.com/igraph/igraph,1938,2022-01-20T09:38:39Z,2022-01-31T10:13:29Z,2022-01-31T10:17:42Z,MERGED,True,313,0,7,https://github.com/kwofach,Re-work for #1874 generator for wheel graphs,8,[],https://github.com/igraph/igraph/pull/1938,https://github.com/kwofach,17,https://github.com/igraph/igraph/pull/1938#issuecomment-1025579793,"Thanks your great advices. Can build now and also found that ""cmake --build . --target check"" will look up the items in tests/CMakeLists.txt and do the following jobs: (1) create a test_igraph_wheel.out under /build/tests; and (2) compare this file with the expected-result file igraph_wheel.out under /tests/unit
Re-work in the following way:

fetch upstream and clone again
git checkout develop
add igraph_wheel to doc/generators.xxml
add new constants to include/igraph_constants.h
add new a item to include/igraph_constructors.h
add the implementation of igraph_wheel to src/constructors/regular.c
add igraph_wheel to /tests/CMakeLists.txt
add a unit test igraph_wheel.c to /tests/unit
add the expected teset result igraph_wheel.out to /tests/unit

Hope it would be closer to what is expected.",Really learnt a lot. Thank you very much!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/Nachiket18,1,https://github.com/igraph/igraph/pull/1939,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1939#issuecomment-1019099609,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","This is a good starting point. I closed the other PR (the comments won't disappear).
The next step now is to fix all the errors that prevent the code from compiling. You will not be able to check if it works correctly until it compiles.
Are you comfortable with compiling igraph on your own computer without these changes? Do you know how to run the tests? You should be using the very same steps to compile and test the function implemented in this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/Nachiket18,3,https://github.com/igraph/igraph/pull/1939#issuecomment-1025246413,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","This is a good starting point. I closed the other PR (the comments won't disappear).
The next step now is to fix all the errors that prevent the code from compiling. You will not be able to check if it works correctly until it compiles.
Are you comfortable with compiling igraph on your own computer without these changes? Do you know how to run the tests? You should be using the very same steps to compile and test the function implemented in this PR.

Thanks. I was able to compile the code using the instructions which specifies the usage for cmake and later the command cmake --build . Earlier there were compile time errors but at present the code ( including the Steiner tree change) is getting build without any errors.
I am however, confused about running test case. I did create create a test case and updated the CmakeLists.txt but running it and understanding why the CI is failing is proving little difficult for me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1939#issuecomment-1025512064,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Earlier there were compile time errors but at present the code ( including the Steiner tree change) is getting build without any errors.

Actually, the code does not build without errors. This is the first reason why the CI is failing, well before the tests. Here's the first error due to a type mismatch: you are sometimes using int and sometimes igraph_integer_t, which are not the same.
https://dev.azure.com/igraph-team/igraph/_build/results?buildId=2196&view=logs&j=9365e2c0-1fe2-55d7-9193-5883fccc1323&t=06be1443-af2e-53a2-9221-964df5414162&l=931
Can you fix all the compiler errors, which you can see in the output of the CI runs?
Generally, all integers used as indices (indexing into vectors, vertex and edges IDs) must be consistently igraph_integer_t.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1939#issuecomment-1030774072,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Can you please format the source files for readability? Use consistent indentation. Your editor should have an auto-format command.
Eventually, the formatting will need to match that of the rest of igraph, but for now, let's just have something that is consistent and readable, and we can worry matching to the rest of the codebase late.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/Nachiket18,6,https://github.com/igraph/igraph/pull/1939#issuecomment-1039837141,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Thanks @szhorvat
I made the changes that you had suggested. Could you review the issue that is caused at IGRAPH_ASSERT macro?
For next steps, I have something that I would need to discuss with you -
The igraph_steiner_dreyfus_wagner function calculates the minimum length of the Steiner tree for smaller graph as it's FPT algorithm for NP-complete problem. Should the code be designed in such a way that it outputs tree as result or would output have tree and minimum length?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1939#issuecomment-1039976433,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Should the code be designed in such a way that it outputs tree as result or would output have tree and minimum length?

It would be nice if the function could (optionally) provide both.
Let's first make sure that the code compiles, then that it works. We can do tweaks to it later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/Nachiket18,8,https://github.com/igraph/igraph/pull/1939#issuecomment-1057471323,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","@szhorvat - Thanks for the suggestions. I made some silly mistakes in the test case file. sorry about that. For building the code I'm using the following commands -
$ cmake --build .
$ cmake --build . --target check
Which commands should I run to check the errors and resolve them locally? I will keep a note of the linux_static_vendored when the tests are run here on the platform.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1939#issuecomment-1057818261,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Yes, these commands are correct. If you use them you should see the test failing, just like on the CI right now. Does the test not fail for you locally?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1939#issuecomment-1088412870,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","@Nachiket18 Let us know if you need more help with this. The immediate goal is to get the test suite to pass, and to make sure that you can run the tests locally on your computer.
I don't want to put too much pressure on you, so if you feel that you have no time right now, just let us know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/Nachiket18,11,https://github.com/igraph/igraph/pull/1939#issuecomment-1143013468,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","@szhorvat - I made the changes that you had suggested. I was able to build the code using the instructions from the official documentation.  However, during the target check there was error generated.
177/424 Test #177: test::igraph_steiner_tree_fpt
Test exited abnormally with error: Segmentation fault
Normally, I would add print statements to debug the code but for this project what should be the way to resolve it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1939#issuecomment-1143420352,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Either add printf statements to the tests if that's convenient for you and run it manually from the command line (the test should be built in test/test_igraph_steiner_tree_... in the build folder -- just make sure you rebuild if after adding the printf statements), or hook it up to a debugger and run through it step by step. I don't know what IDE / OS you are using, I usually use gdb or lldb from the command line on macOS, but I'm oldschool :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1939,2022-01-22T03:35:50Z,,2022-06-01T10:33:13Z,OPEN,False,281,0,6,https://github.com/Nachiket18,Steiner Tree Feature,42,[],https://github.com/igraph/igraph/pull/1939,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/1939#issuecomment-1143428375,"The functionality that is being developed is calculating the Steiner tree in a graph. Steiner Tree is created on basis of subset of terminals in the graphs with the condition that length of the tree should be minimum.
We are following the approach suggested in this paper - https://arxiv.org/abs/1710.00668
Also, we are taking reference of an FPT algorithm known as Dreyfus- Wagner algorithm - https://onlinelibrary.wiley.com/doi/10.1002/net.3230010302","Resolved the conflicts with the upstream develop branch, FYI.
I haven't checked the PR thoroughly yet so this is not a full review, but one thing that surely needs to be changed is that we have switched to using igraph_vector_int_t for variables that represents vertex indices so the function needs to be changed to use igraph_vector_int_t for vectors containing vertex indices. As for the distance matrix, that can probably stay as igraph_matrix_t because it can contain floating-point numbers in the weighted case, but infinite distances should be represented with IGRAPH_INFINITY and not INT_MAX.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1944,Fixes part of #1922,Fixes part of #1922,True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1944#issuecomment-1019245410,Fixes part of #1922,"Codecov Report

Merging #1944 (1369930) into develop (1856cd6) will increase coverage by 0.08%.
The diff coverage is n/a.


@@             Coverage Diff             @@
##           develop    #1944      +/-   ##
===========================================
+ Coverage    77.05%   77.13%   +0.08%     
===========================================
  Files          362      362              
  Lines        58471    58471              
===========================================
+ Hits         45055    45104      +49     
+ Misses       13416    13367      -49     



Impacted Files
Coverage Δ





src/io/graphml.c
82.31% <0.00%> (ø)



src/io/ncol.c
64.41% <0.00%> (+22.08%)
⬆️


src/io/ncol-lexer.l
69.23% <0.00%> (+38.46%)
⬆️


src/io/ncol-parser.y
57.14% <0.00%> (+57.14%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1856cd6...1369930. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1944#issuecomment-1019303012,Fixes part of #1922,"Could we compare the graph that was read back with the original using igraph_is_same_graph()?  In order to do so, we will need to order the vertices identically. We can ensure identical vertex order using the following canonicalization process:

Find the permutation that puts the vertex names in lexicographic order
Invert that permutation ...  igraph_vector_int_order will effectively do the inversion.
Use igraph_permute_vertices() to reorder the graph vertices

After having done this both for the original graph, as well as the graph that was read back, we can compare them using igraph_is_same_graph().",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/1944#issuecomment-1019312616,Fixes part of #1922,Could you explain why? Because it's more readable than a graphml? Or could there be information in there that we're not seeing now?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1944#issuecomment-1019359443,Fixes part of #1922,"I asked for this type of test after I modified the NCOL writer to write edges in a different order and introduced a bug, associating weights with the wrong edges (the bug was never pushed). I am looking for a test which can detect this type of bug.
This modification, even if bug-free, would change the GraphML output here. Then the output would need to be verified manually, diminishing the usefulness of the test.
I was looking for a test that verifies that the graph does not change after writing it to a file and reading it back again. The test should fail if and only if the graph that is read back is not identical to the original graph. It should not fail if, for example, the edge or vertex ordering changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1944#issuecomment-1021381398,Fixes part of #1922,"The test should fail if and only if the graph that is read back is not identical to the original graph. It should not fail if, for example, the edge or vertex ordering changes.

This is really what I'm looking for. ""Identical"" here means having the same edges and vertices (in whatever order), with correct attribute assignments. Any solution that achieves this is fine for me.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/1944#issuecomment-1024876312,Fixes part of #1922,"I've replaced the graphml write with the is_same_graph, but then checking for attributes separately doesn't seem easy. To compare edge attributes, you need to know which edge in graph1 corresponds to which edge in graph2. is_same_graph uses the internal representation of graphs for that.
Also doesn't is_same_graph still fail if the vertex ordering changes? It uses an ordered list of edges, but they're ordered by the second vertex.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1944#issuecomment-1083636346,Fixes part of #1922,"Could you rebase on current develop and make sure that the test still passes? This doesn't quite do everything I wanted, but I think we can improve it later. It would be useful to merge it as it is.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1944,2022-01-22T12:48:27Z,2022-04-02T18:26:08Z,2022-04-02T18:26:08Z,MERGED,True,114,0,3,https://github.com/GroteGnoom,add NCOL read/write consistency test,8,[],https://github.com/igraph/igraph/pull/1944,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1944#issuecomment-1086678168,Fixes part of #1922,"I changed it to abort() instead of exit(1). The reason is that if the program exits normally using exit(), without freeing all memory, LSan will complain about memory leaks. If it exits with abort(), it will be considered an abnormal exit, and there won't be distracting messages about memory leaks.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/borsgeorgica,1,https://github.com/igraph/igraph/pull/1945,Issue #1932,Issue #1932,True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1945#issuecomment-1019360276,Issue #1932,"There is actually a more concise implementation, that makes it very clear that execution can never reach the end of the function:
if (igraph_is_directed(graph)) {
    return igraph_is_dag(graph, res);
} else {
    return igraph_is_forest(graph, res, NULL, IGRAPH_ALL);
}",True,{'THUMBS_UP': ['https://github.com/borsgeorgica']}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/1945#issuecomment-1019360753,Issue #1932,"Codecov Report

Merging #1945 (10f100d) into develop (131992d) will decrease coverage by 0.01%.
The diff coverage is 0.00%.


❗ Current head 10f100d differs from pull request most recent head 01d4ea8. Consider uploading reports for the commit 01d4ea8 to get more accurate results


@@             Coverage Diff             @@
##           develop    #1945      +/-   ##
===========================================
- Coverage    74.11%   74.09%   -0.02%     
===========================================
  Files          345      345              
  Lines        58125    58137      +12     
===========================================
  Hits         43078    43078              
- Misses       15047    15059      +12     



Impacted Files
Coverage Δ





src/properties/trees.c
67.28% <0.00%> (-4.00%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 131992d...01d4ea8. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1945#issuecomment-1019361051,Issue #1932,"So far it looks good! Could you please add a test, which covers at least the following cases?

null graph
singleton graph
both directed an undirected cases
be sure that graphs which contain self-loops are not considered acyclic, in either the directed or undirected case
try to think of special cases where things might go wrong, and tests them; self-loops were the example I could think of",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/borsgeorgica,5,https://github.com/igraph/igraph/pull/1945#issuecomment-1019839129,Issue #1932,"There is actually a more concise implementation, that makes it very clear that execution can never reach the end of the function:
if (igraph_is_directed(graph)) {
    return igraph_is_dag(graph, res);
} else {
    return igraph_is_forest(graph, res, NULL, IGRAPH_ALL);
}


this is much nicer! thanks",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1945#issuecomment-1020133867,Issue #1932,"When you are done, mark this PR as ""ready for review"". I looked through it and everything looks fine to me.
Others may want to comment on the location where this function is included in the docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1945#issuecomment-1020159159,Issue #1932,"The PR seems okay to me as well; I'll merge it and we can still move the section around in the docs if we find a better place for it.
For instance, there's an entire chapter about ""graph cycles"" (https://igraph.org/c/html/latest/igraph-Cycles.html), and it barely has any content. Wouldn't it be better to put this function there, along with maybe the entire ""Topological sorting, directed acyclic graphs"" section and igraph_girth?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1945#issuecomment-1020159759,Issue #1932,Thanks for your contribution @borsgeorgica !,True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1945#issuecomment-1020175850,Issue #1932,"@borsgeorgica Indeed, thanks for the PR!
One of the goals of issue #1932 was as a gentle introduction to igraph internals. Now you have some familiarity with error codes, documentation, and perhaps you also saw how memory management works. If you are interested in continuing to work with igraph, now you are ready for more interesting contributions. You can look through the existing issues, make a proposal for a feature, or simply tell us what you are looking for and we may be able to suggest tasks for which no GitHub issue has been written up yet.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1945#issuecomment-1020192855,Issue #1932,@ntamas Can you add this to functions.yaml before we forget?,True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/borsgeorgica,11,https://github.com/igraph/igraph/pull/1945#issuecomment-1020369061,Issue #1932,"Thank you for giving me the opportunity to work on the issue and approving! I really appreciate the quick feedback.
I would love to work on other issues as well, it would be nice to learn more about the library, get a better understanding of some of the graph algorithms and get more used to writing C. I was also looking at this issue, would this be a good issue for me to do next? or shall I look at others? Also, I would be more than happy to work on any other problems that don’t have an issue open on Github yet.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1945,2022-01-22T19:38:26Z,2022-01-24T14:29:42Z,2022-01-25T08:18:43Z,MERGED,True,139,1,5,https://github.com/borsgeorgica,Add convenience function to check if a graph is acyclic,3,[],https://github.com/igraph/igraph/pull/1945,https://github.com/GroteGnoom,12,https://github.com/igraph/igraph/pull/1945#issuecomment-1020918537,Issue #1932,"#1882 seems fine 🙂 There shouldn't be any surprising difficulties, and you already know how to add a function, so go ahead!",True,{'THUMBS_UP': ['https://github.com/borsgeorgica']}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,1,https://github.com/igraph/igraph/pull/1946,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1946#issuecomment-1023967945,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","This is a good start that demonstrates the function's usage for a programmer.
Now let's think if we can make this example more educational. Can you come up with an example that is conceptually interesting, that perhaps is educational for a student of network science (and doesn't just illustrate an API usage)? This is your chance to be creative.
Have you worked with the concept of assortativity before?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1946#issuecomment-1023971258,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",This is a useful resource: http://networksciencebook.com/chapter/7,True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,4,https://github.com/igraph/igraph/pull/1946#issuecomment-1023986230,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Have you worked with the concept of assortativity before?

No. But I am interested in learning more about it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1946#issuecomment-1023994641,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","First take a look a the chapter I linked, and if you need tips on what to show in the example, just let us know.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,6,https://github.com/igraph/igraph/pull/1946#issuecomment-1023995735,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","First take a look a the chapter I linked, and if you need tips on what to show in the example, just let us know.

Thank you. I'll let you know if I have issues or get an idea.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/apps/codecov,7,https://github.com/igraph/igraph/pull/1946#issuecomment-1023997558,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Codecov Report

Merging #1946 (0e7e30a) into develop (a827625) will increase coverage by 0.00%.
The diff coverage is n/a.


@@           Coverage Diff            @@
##           develop    #1946   +/-   ##
========================================
  Coverage    74.93%   74.93%           
========================================
  Files          347      347           
  Lines        57867    57867           
========================================
+ Hits         43363    43364    +1     
+ Misses       14504    14503    -1     



Impacted Files
Coverage Δ





src/misc/mixing.c
94.59% <ø> (ø)



src/core/typed_list.pmt
76.16% <0.00%> (ø)



src/operators/rewire.c
95.45% <0.00%> (+1.13%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update a827625...0e7e30a. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,8,https://github.com/igraph/igraph/pull/1946#issuecomment-1025155162,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","First take a look a the chapter I linked, and if you need tips on what to show in the example, just let us know.

Hi. I read through the chapter. I have an idea of an example that probably is aimed at a beginner from a programmer's and network science student's perspective. I was thinking of demonstrating how graphs with identical degree sequences can have completely different assortativities.
It's not an original idea. The chapter illustrates this concept. It's also not very creative but as a beginner this is what I could come up with that wasn't mathematically heavy at the same time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1946#issuecomment-1025653568,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","I was thinking of demonstrating how graphs with identical degree sequences can have completely different assortativities.

Excellent idea!
Do you need tips on how to efficiently produce two graphs with the same degrees but different assortativity?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,10,https://github.com/igraph/igraph/pull/1946#issuecomment-1026090759,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Do you need tips on how to efficiently produce two graphs with the same degrees but different assortativity?

Would it be possible to efficiently produce the graphs using igraph_realize_degree_sequence?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1946#issuecomment-1026103140,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","A more efficient, and also fairly standard way is to use igraph_rewire(). This is what I suggest. The number of rewiring steps can be a few times the edge count.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,12,https://github.com/igraph/igraph/pull/1946#issuecomment-1026109345,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","A more efficient, and also fairly standard way is to use igraph_rewire().

Alright. I'll take a look at the usage of this function. Thanks.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,13,https://github.com/igraph/igraph/pull/1946#issuecomment-1027030926,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",I have changed assortativity.c so that it demonstrates how graphs with identical degree sequences can have different assortativities.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/1946#issuecomment-1027065104,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Let's summarize what you did:

Create a small directed graph on only 10 vertices.
Rewire it 5 times, then print assortativity values for all five.

The 5 result all look very different, but why? This is because the data (the graph) is tiny, so we can't get meaningful statistics. If the graph were large, all 5 results would be very similar.
Also note that in the undirected version, you still do the rewiring preserving the directed degree sequence, which is confusing in an example.
Here's how the example could be improved:

Create a large graph whose assortativity differs from the typical value for graphs having the same degrees. I suggest you use igraph_barabasi_game() in undirected mode. This function implements the preferential attachment model, connecting low-degree vertices to high-degree ones. Thus, it has large negative assortativity. Print this out.
Rewire a single time, and print the assortativity again. It will be significantly different from the original value. If the graph is not tiny, then repeated rewirings will not change the assortativity by much. Rewiring gives the ""typical"" assortativity of graphs with these specific degrees. This experiment shows that the preferential attachment graph is not typical (is has much more negative assortativity).

I suggest you skip the directed case for simplicity.
Additionally:

Keep the graph simple while rewiring, since the original graph was simple as well. IGRAPH_REWIRING_SIMPLE
Always use igraph_integer_t for indexing, and not int. igraph_integer_t can represent any valid index, while int may not be able to (depending on the platform).",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1946#issuecomment-1027072753,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","As for the parameters of igraph_barabasi_game(), use:

undirected
Experiment with values of m=1,2,3,... to get a nice result with clearly changing assortativity
power=1 for simplicity
A can be zero for undirected; this is simplest
outpref is irrelevant for undirected
algo should be IGRAPH_BARABASI_PSUMTREE for simple graphs and good performance",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,16,https://github.com/igraph/igraph/pull/1946#issuecomment-1027213354,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","The 5 result all look very different, but why? This is because the data (the graph) is tiny, so we can't get meaningful statistics. If the graph were large, all 5 results would be very similar.

Sorry, I didn't understand this properly. Why does this happen? Is it only related to the number of nodes/edges or is it also related to how the rewiring is done?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1946#issuecomment-1027239154,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Take 5 random numbers between 0 and 1, and compute the mean. The mean will fluctuate wildly, values of 0.2 or 0.7 are not uncommon. Now take 1000 random numbers between 0 and 1, and you'll find that the mean is always very close to 0.5. It's the same effect. The graph is too small, so there is high fluctuation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,18,https://github.com/igraph/igraph/pull/1946#issuecomment-1028729920,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Take 5 random numbers between 0 and 1, and compute the mean. The mean will fluctuate wildly, values of 0.2 or 0.7 are not uncommon. Now take 1000 random numbers between 0 and 1, and you'll find that the mean is always very close to 0.5. It's the same effect. The graph is too small, so there is high fluctuation.

Got it. This makes sense now.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,19,https://github.com/igraph/igraph/pull/1946#issuecomment-1028792468,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","* Create a large graph whose assortativity differs from the typical value for graphs having the same degrees. I suggest you use `igraph_barabasi_game()` in undirected mode. This function implements the preferential attachment model, connecting low-degree vertices to high-degree ones. Thus, it has large negative assortativity. Print this out.

* Rewire a single time, and print the assortativity again. It will be significantly different from the original value. If the graph is not tiny, then repeated rewirings will not change the assortativity by much. Rewiring gives the ""typical"" assortativity of graphs with these specific degrees. This experiment shows that the preferential attachment graph is not typical (is has much more negative assortativity).


I have understood what this means. Before working in the igraph_assortativity.c file, I thought I would play around with the function in a test program and experimented with the various options (number of nodes, power, m, A).
The assortativity before rewiring comes out to be in the (-0.05, -0.02) range while after rewiring, their assortativities tend to be around -0.006. Are these values appropriate or should the inital assortativity be closer to -1?
Also, I have kept the number of rewiring trials as 10 * number_of_edges.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,20,https://github.com/igraph/igraph/pull/1946#issuecomment-1028796109,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Here's an example.
#include <igraph.h>
#include <stdio.h>

int main(){
    igraph_t g;
    igraph_integer_t nodes = 100000, A = 0, power = 1, m = 1;
    
    igraph_rng_seed(igraph_rng_default(), 42);
    igraph_barabasi_game(&g, nodes, power, m, NULL, IGRAPH_UNDIRECTED, A, IGRAPH_UNDIRECTED, IGRAPH_BARABASI_PSUMTREE, NULL);
    
    igraph_integer_t edge_count = igraph_ecount(&g);
    printf(""Number of edges = %d\nnodes = %d\nA = %d\npower = %d\nm = %d\n\n"", edge_count, nodes, A, power, m); 
    
    igraph_vector_t degree;
    igraph_vector_init(&degree, 0); 
    igraph_degree(&g, &degree, igraph_vss_all(), IGRAPH_ALL, IGRAPH_LOOPS);

    igraph_real_t assortativity;
    igraph_assortativity(&g, &degree, NULL, &assortativity, IGRAPH_UNDIRECTED);
    printf(""Assortativity of undirected graph before rewiring = %g\n\n"", assortativity);

    for(int i = 0 ; i < 5 ; i++){
        igraph_rewire(&g, 10 * edge_count, IGRAPH_REWIRING_SIMPLE);
        igraph_assortativity(&g, &degree, NULL, &assortativity, IGRAPH_UNDIRECTED);
        printf(""Assortativity of undirected graph = %g\n"", assortativity);
    }   

    igraph_vector_destroy(&degree);
    printf(""\n"");

    igraph_destroy(&g);
}

Output:
Number of edges = 99999
nodes = 100000
A = 0
power = 1
m = 1

Assortativity of undirected graph before rewiring = -0.0204148

Assortativity of undirected graph = -0.00814841
Assortativity of undirected graph = -0.00855524
Assortativity of undirected graph = -0.00742923
Assortativity of undirected graph = -0.00699636
Assortativity of undirected graph = -0.00691494",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1946#issuecomment-1028812718,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","@valdaarhun Actually, I think your result is correct and the expectation that BA networks should have a large negative assortativity (in terms of absolute value) is not correct; see, e.g., this paper:

Concerning the assortativity properties of BA networks, in previous work some estimates of the Newman coefficient r were found (Newman 2002). According to these estimates, for large N (number of nodes), r vanishes as −ln(2N/N). It was therefore generally believed that BA networks are almost uncorrelated, and numerical simulations appeared to confirm this. However, more recent asymptotic estimates (Fotouhi and Rabbat 2018; Bertotti and Modanese 2019) yield a different result: r vanishes only as −ln(2N / sqrt(N)) for large N. It should be recalled that for real networks with the same scale-free exponent (γ=3), the r coefficient is always small in absolute value, so even this small total disassortativity is significant.

@szhorvat Given the above, how shall we proceed with the example?
Edit: one possible way to get a disassortative network is to radically decrease the number of nodes; e.g., with only 100 nodes and m=1, one can get disassortative networks around r = -0.3.",True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1946#issuecomment-1028967635,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","If I understand this right, the paper claims that the assortativity of BA networks approaches zero as the vertex count increases.
This, however, does not exclude the possibility that they are clearly more disassortative than a typical network with the same degrees.
Let's generate many BA networks with m=1, rewire each, and compare the assortativity histograms between the original and rewired networks. This is what we get:
100 vertices:

1000 vertices:

10000 vertices:

For 10000-vertex graphs, rewiring is almost guaranteed to make the graph less disassortative. I think this can still make a nice demonstration: generate a BA network, rewire it, print both assortativities. Repeat 5 times to show that rewiring consistently reduces disassortativity.

If we wanted strongly assortative/disassortative networks, we could use igraph_realize_degree_sequence with the ""largest first"" and ""smallest first"" methods. However, I would prefer to keep this for an example program associated with igraph_realize_degree_sequence (which you could easily do after this one @valdaarhun).",True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,23,https://github.com/igraph/igraph/pull/1946#issuecomment-1029306832,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","which you could easily do after this one @valdaarhun

I would love to work on that after this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/1946#issuecomment-1030206928,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",I just realize that this example is not run in the CI tests (and in fact there is an error in it which the compiler should have warned you about). Please add it to test/CMakeLists.txt within the add_examples just below # structural_properties.at.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,25,https://github.com/igraph/igraph/pull/1946#issuecomment-1030207086,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","which you could easily do after this one @valdaarhun

I would love to work on that after this.

Yes, that will be great.",True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,26,https://github.com/igraph/igraph/pull/1946#issuecomment-1030689091,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","and in fact there is an error in it which the compiler should have warned you about

I believe you are talking about the usage of igraph_vector_t instead of igraph_vector_int_t in igraph_degree(). That's the warning that I got after running the test.
I checked the docs for the 'develop' branch and noticed that igraph_degree() uses igraph_vector_int_t while igraph_assortativity() uses igraph_vector_t. So I instead used igraph_strength() (the weights for all the edges being equal to 1).
I am not sure if this method is appropriate for resolving the warnings.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,27,https://github.com/igraph/igraph/pull/1946#issuecomment-1032604664,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","I have not forgotten about this PR. I wanted to clean up the assortativity functionality (and its documentation) before proceeding with examples. This is happening in #1953, and will soon be completed.",True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,28,https://github.com/igraph/igraph/pull/1946#issuecomment-1034514879,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Sure, no problem. Let me know when I can continue.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,29,https://github.com/igraph/igraph/pull/1946#issuecomment-1035391164,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",The PR is ready for review.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,30,https://github.com/igraph/igraph/pull/1946#issuecomment-1035971132,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","There was one more test failure, in the documentation build. I corrected that now.  If you are not sure why a test fails, please ask us.
Thanks for your work on this!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,31,https://github.com/igraph/igraph/pull/1946#issuecomment-1035974217,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","Would you like to add an example for igraph_realize_degree_sequence() now?
I would suggest the following:

Create a random graph with a similar number of vertices and edges
Take its degrees
Create two graphs from this degree sequence, one with the ""largest first"" and one with the ""smallest first"" methods
Print the degree assortativity of the three graphs
Add comments in the example, pointing out that one method generates high-assortativity, the other low-assortativity graphs",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,32,https://github.com/igraph/igraph/pull/1946#issuecomment-1035977240,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.","It would be nice to add an example for igraph_assortativity_nominal() as well:

Use one of the graph generators that creates networks based on ""vertex types"". For some, like the ""stochastic block model"", you effectively input the types. For others, like ""establishment game"" or ""preference game"", the types are generated. Choose one you like an make sure you have the ""types"" (= categories) in a vector.
Show that the nominal assortativity is high based on these types.

Feel free to open PRs directly for any of these. Now that you see how adding examples works, everything should go much faster.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/valdaarhun,33,https://github.com/igraph/igraph/pull/1946#issuecomment-1036051078,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",I enjoyed working on this issue. I would like to work on the other two issues as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1946,2022-01-27T20:13:49Z,2022-02-11T08:22:36Z,2022-02-11T10:18:02Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Add examples for assortativity functions,32,[],https://github.com/igraph/igraph/pull/1946,https://github.com/szhorvat,34,https://github.com/igraph/igraph/pull/1946#issuecomment-1036053614,"Add examples showing usage of assortativity related functions to examples/simple.
Should close #1931 once completed.",Thanks for the work you did so far! Feel free to open PRs for these two issues as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1948,To fix #1867,To fix #1867,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1948#issuecomment-1025136915,To fix #1867,"Codecov Report

Merging #1948 (c6efd3c) into develop (8684bc7) will increase coverage by 0.04%.
The diff coverage is 77.27%.


@@             Coverage Diff             @@
##           develop    #1948      +/-   ##
===========================================
+ Coverage    74.13%   74.17%   +0.04%     
===========================================
  Files          345      344       -1     
  Lines        58113    58144      +31     
===========================================
+ Hits         43082    43131      +49     
+ Misses       15031    15013      -18     



Impacted Files
Coverage Δ





...ee_sequence_vl/gengraph_graph_molloy_optimized.cpp
30.80% <0.00%> (ø)



src/hrg/hrg.cc
59.51% <33.33%> (-0.30%)
⬇️


src/centrality/betweenness.c
94.14% <100.00%> (ø)



src/connectivity/components.c
94.93% <100.00%> (ø)



src/core/error.c
75.90% <100.00%> (-0.57%)
⬇️


src/io/graphml.c
82.66% <100.00%> (ø)



src/isomorphism/isoclasses.c
89.34% <100.00%> (ø)



src/core/stack.pmt
77.01% <0.00%> (-1.25%)
⬇️


src/io/ncol.c
10.19% <0.00%> (ø)



... and 8 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8684bc7...c6efd3c. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/GroteGnoom,3,https://github.com/igraph/igraph/pull/1948#issuecomment-1025144688,To fix #1867,"https://github.com/igraph/igraph/runs/4996866883?check_suite_focus=true
@ntamas It seems like every return value is assumed to be an int in stimulus. Can that be fixed? I can't find where that happens. Is it because of C implicit declarations returning an int?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1948#issuecomment-1025559002,To fix #1867,"@GroteGnoom

It seems like every return value is assumed to be an int in stimulus. Can that be fixed?

The default abstract return type in Stimulus is ERROR. ERROR is mapped to int in types.yaml, so you can change it there.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1948#issuecomment-1025563440,To fix #1867,Looks good to me -- feel free to merge after addressing the minor outstanding comments.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1948#issuecomment-1025661260,To fix #1867,"Is there a compiler warning which is triggered when assigning a non-enum value to an enum variable? If yes, maybe it's worth activating to see if any issues are revealed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1948#issuecomment-1027733542,To fix #1867,"Is there a compiler warning which is triggered when assigning a non-enum value to an enum variable? If yes, maybe it's worth activating to see if any issues are revealed.

The only warning option I found is -Wc++-compat for GCC (not Clang). However, this triggers so many unrelated warnings (which I can't seem to disable separately) that it is not useful.
Let's not bother with this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1948,2022-01-29T10:00:41Z,2022-02-05T11:57:08Z,2022-02-05T12:46:33Z,MERGED,True,136,155,26,https://github.com/GroteGnoom,Typedef igraph_error_t to igraph_error_type_t,6,[],https://github.com/igraph/igraph/pull/1948,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/1948#issuecomment-1030617701,To fix #1867,Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1950,2022-01-29T11:12:36Z,2022-01-29T15:45:15Z,2022-01-29T15:45:15Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add attribute combination docs,3,[],https://github.com/igraph/igraph/pull/1950,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1950,"I currently can't build the docs locally, so I made this a draft.
Fixes #1835","I currently can't build the docs locally, so I made this a draft.
Fixes #1835",True,{}
igraph/igraph,https://github.com/igraph/igraph,1950,2022-01-29T11:12:36Z,2022-01-29T15:45:15Z,2022-01-29T15:45:15Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add attribute combination docs,3,[],https://github.com/igraph/igraph/pull/1950,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1950#issuecomment-1024891633,"I currently can't build the docs locally, so I made this a draft.
Fixes #1835","Codecov Report

Merging #1950 (7d56a14) into develop (8684bc7) will increase coverage by 0.00%.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #1950   +/-   ##
========================================
  Coverage    74.13%   74.13%           
========================================
  Files          345      345           
  Lines        58113    58106    -7     
========================================
- Hits         43082    43077    -5     
+ Misses       15031    15029    -2     



Impacted Files
Coverage Δ





src/graph/attributes.c
85.05% <100.00%> (ø)



src/core/vector.pmt
86.99% <0.00%> (+0.12%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 8684bc7...7d56a14. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1950,2022-01-29T11:12:36Z,2022-01-29T15:45:15Z,2022-01-29T15:45:15Z,MERGED,True,71,1,4,https://github.com/GroteGnoom,Add attribute combination docs,3,[],https://github.com/igraph/igraph/pull/1950,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1950#issuecomment-1024934896,"I currently can't build the docs locally, so I made this a draft.
Fixes #1835",The documentation builds nicely in the CI environment so I'll merge it.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1951,2022-01-30T11:24:50Z,2022-02-06T08:47:24Z,2022-02-06T08:47:24Z,MERGED,True,222,1,9,https://github.com/GroteGnoom,Add igraph_blas_dgemm,5,[],https://github.com/igraph/igraph/pull/1951,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1951,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,1951,2022-01-30T11:24:50Z,2022-02-06T08:47:24Z,2022-02-06T08:47:24Z,MERGED,True,222,1,9,https://github.com/GroteGnoom,Add igraph_blas_dgemm,5,[],https://github.com/igraph/igraph/pull/1951,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1951#issuecomment-1025123052,,"Codecov Report

Merging #1951 (0d971e8) into develop (0b08dbb) will increase coverage by 0.00%.
The diff coverage is 92.30%.


@@           Coverage Diff            @@
##           develop    #1951   +/-   ##
========================================
  Coverage    74.18%   74.18%           
========================================
  Files          344      344           
  Lines        58144    58170   +26     
========================================
+ Hits         43133    43155   +22     
- Misses       15011    15015    +4     



Impacted Files
Coverage Δ





src/linalg/blas.c
88.52% <92.30%> (+2.81%)
⬆️


src/core/error.c
75.90% <0.00%> (-0.57%)
⬇️


src/hrg/hrg.cc
59.51% <0.00%> (-0.30%)
⬇️


src/connectivity/components.c
94.93% <0.00%> (ø)



...ee_sequence_vl/gengraph_graph_molloy_optimized.cpp
30.80% <0.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 0b08dbb...0d971e8. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1951,2022-01-30T11:24:50Z,2022-02-06T08:47:24Z,2022-02-06T08:47:24Z,MERGED,True,222,1,9,https://github.com/GroteGnoom,Add igraph_blas_dgemm,5,[],https://github.com/igraph/igraph/pull/1951,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/1951#issuecomment-1030702692,,@szhorvat My concerns have been addressed so I leave it up to you to merge it if you are happy with it.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1953,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1953#issuecomment-1031710942,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","Codecov Report

Merging #1953 (5387e99) into develop (69e5101) will increase coverage by 0.03%.
The diff coverage is 85.36%.


@@             Coverage Diff             @@
##           develop    #1953      +/-   ##
===========================================
+ Coverage    74.18%   74.22%   +0.03%     
===========================================
  Files          344      344              
  Lines        58170    58167       -3     
===========================================
+ Hits         43155    43174      +19     
+ Misses       15015    14993      -22     



Impacted Files
Coverage Δ





src/misc/mixing.c
94.59% <85.36%> (+26.02%)
⬆️


src/graph/adjlist.c
63.88% <0.00%> (-2.04%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d2e9224...5387e99. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1953#issuecomment-1031723734,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","This is ready for review, but please do not merge. I might polish it a bit.
I was thinking of adding a types_in to assortativity_nominal(), mirroring values_in, but I don't have time to think it through whether this makes sense, so I will leave it for later.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1953#issuecomment-1032414395,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","Seems okay to me! I won't merge now as you've requested, let me know when it's good to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/1953#issuecomment-1033003679,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.",Can you update the changelog pls after this is merged?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1953#issuecomment-1033009038,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","Yes, but this was supposed to be a squash-and-merge. Now we have a bunch of ugly messy commits with non-descriptive commit messages. Do you want to squash them after the fact or we leave them @ntamas ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1953#issuecomment-1033014714,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","Sorry, I was just looking through it at the same time as you apparently @ntamas . Only some minor nitpicks, all the rest looks fine to me!",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1953,2022-02-07T17:08:53Z,2022-02-08T19:55:03Z,2022-02-08T20:13:10Z,MERGED,True,371,105,5,https://github.com/szhorvat,"feat: normalization support for assortativity, and documentation updates",8,[],https://github.com/igraph/igraph/pull/1953,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1953#issuecomment-1033019332,"Changes:

Update the docs of assortativity. This was done quickly, feel free to push to this PR and improve it.
Add a normalized parameter to support non-normalized assortativity.
Do not refer to vertex values as ""types"" for valued assortativity.","Thanks @vtraag, I'll fix these tomorrow.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1957,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1957#issuecomment-1034838383,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Codecov Report

Merging #1957 (6508af9) into develop (1d2ab9e) will increase coverage by 0.32%.
The diff coverage is 97.94%.


@@             Coverage Diff             @@
##           develop    #1957      +/-   ##
===========================================
+ Coverage    75.78%   76.11%   +0.32%     
===========================================
  Files          350      352       +2     
  Lines        57486    57749     +263     
===========================================
+ Hits         43567    43956     +389     
+ Misses       13919    13793     -126     



Impacted Files
Coverage Δ





src/misc/order_cycle.cpp
97.22% <97.22%> (ø)



src/misc/cycle_bases.c
97.95% <97.95%> (ø)



src/core/typed_list.pmt
96.38% <100.00%> (+0.16%)
⬆️


src/constructors/lcf.c
93.61% <0.00%> (-4.06%)
⬇️


src/core/progress.c
66.66% <0.00%> (-3.93%)
⬇️


src/io/gml-tree.c
68.03% <0.00%> (-0.23%)
⬇️


src/linalg/arpack.c
73.94% <0.00%> (-0.07%)
⬇️


src/constructors/basic_constructors.c
100.00% <0.00%> (ø)



src/core/vector.pmt
88.00% <0.00%> (+0.01%)
⬆️


src/io/gml.c
79.60% <0.00%> (+0.04%)
⬆️


... and 8 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1d2ab9e...6508af9. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1957#issuecomment-1073213685,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Please DO NOT MERGE, just give feedback. I will merge myself later. At first, I expect technical comments, as understanding the algorithm would take time. I discussed the algorithm with @vtraag last year, but I am not sure if he remembers.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1957#issuecomment-1075051566,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Where feedback might be useful is an efficient algorithm to put edges in cycle order.
Currently, the minimum_cycle_basis() function produces cycles as sorted lists of edge IDs. This is actually sufficient for a surprisingly large number of applications, but in many cases users will expect the edge IDs to be ordered along the cycle instead. To do this, I used std::map from C++, hence the separate C++ source file. I'm not very happy with this, but it was the fastest way to handle this issue.
How the algorithm works is that it produces BFS-based fundamental cycles starting from all vertices (of degree d >= 3). This produces a list of candidate cycles of length (E - V + 1)*V, where E and V are edge and vertex counts. I.e., it produces a pretty huge list. These cycles are originally in the correct order, but they are sorted by edge ID for further processing. What we would do is to duplicate the original list in memory, and keep handles to the unsorted versions of cycles from the sorted one. However, this would complicate the code quite a bit (couldn't use vector_list anymore), and would more than double the already significant memory requirements. So I don't like it. This is why I opted to restore the cycle order on the final result instead.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1957#issuecomment-1075061583,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Yet another thing where I need feedback is a refactoring for IGRAPH_HANDLE_EXCEPTIONS(...). Now the argument is a large block of code, but this causes problems.  Notice the separate typedef std::map<igraph_integer_t, eid_pair_t> inclist_t; I have in that file. Why do I need that? Because writing map<igraph_integer_t, eid_pair_t> within IGRAPH_HANDLE_EXCEPTIONS(...) confuses the C preprocessor with that comma, and just won't work.
We probably want a begin/end style solution for IGRAPH_HANDLE_EXCEPTIONS, but I want to see concrete suggestions please.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/1957#issuecomment-1076223807,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.",Added a begin/end style solution as the first iteration. I think it's good enough. Another alternative would have been to move the function body to a separate function and just wrap a call to that function within IGRAPH_HANDLE_EXCEPTIONS().,True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1957#issuecomment-1076225576,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Where feedback might be useful is an efficient algorithm to put edges in cycle order.

Do you mean that the input of the algorithm is a graph and a list of edge IDs in arbitrary order that are guaranteed to form a cycle, and the result should be a list where the edge IDs are in the order they are traversed along the cycle? I don't see any particular problem with the current implementation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1957,2022-02-10T11:55:22Z,2022-03-26T08:06:48Z,2022-03-26T08:06:48Z,MERGED,True,1007,2,13,https://github.com/szhorvat,Cycle basis calculations,24,[],https://github.com/igraph/igraph/pull/1957,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/1957#issuecomment-1076246338,"Continuing from #1786
This PR implements some cycle basis calculations.

Fundamental cycle basis
Unweighed minimum cycle basis

It has a special feature where it can limit the length of cycles found, which drastically reduces computation time. This will be a unique feature of igraph.
Within the minimum cycle basis computation, I represent cycles as sorted vectors of edge IDs. This makes certain operations, such as ""adding"" cycles, efficient. However, in the end we obtain the cycles with an edge ID ordering that does not match the cycle structure. Therefore, in a final step we order the cycles. This operation was much easier with a map data structure, so I did it in C++. I could do it in pure C without writing a map from scratch, but it would be much more complicated, and I don't have the time now. There is an option that controls whether this reordering should be done. Setting it to false will speed the function up, though I did not yet time to benchmark by how much.
This PR also adds a igraph_vector_list_remove_consecutive_duplicates function.","Let me clarify.
Here's an example of a graph with edges labelled by ID:

3, 4, 8, 5 form a cycle, in this order. However, the (internal) computation returns the edge ID in sorted order, 3, 4, 5, 8. I use a separate function, igraph_i_order_cycle(), to put them back in cycle order, i.e. 3, 4, 8, 5.  This function is written in C++, not C, because it uses std::map.
I found this a bit ugly.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1962,Fixes #1956,Fixes #1956,True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1962#issuecomment-1037216459,Fixes #1956,"Codecov Report

Merging #1962 (eb6faa6) into develop (2b1134e) will increase coverage by 0.00%.
The diff coverage is 100.00%.


❗ Current head eb6faa6 differs from pull request most recent head 189a4cd. Consider uploading reports for the commit 189a4cd to get more accurate results


@@           Coverage Diff            @@
##           develop    #1962   +/-   ##
========================================
  Coverage    74.94%   74.94%           
========================================
  Files          347      347           
  Lines        57887    57898   +11     
========================================
+ Hits         43383    43392    +9     
- Misses       14504    14506    +2     



Impacted Files
Coverage Δ





src/centrality/betweenness.c
94.14% <ø> (ø)



src/paths/dijkstra.c
95.33% <ø> (ø)



src/math/utils.c
29.11% <100.00%> (ø)



src/io/ncol.c
9.93% <0.00%> (-0.26%)
⬇️


src/io/graphml.c
82.69% <0.00%> (+0.03%)
⬆️


src/core/vector.pmt
88.28% <0.00%> (+0.04%)
⬆️


src/io/gml.c
81.42% <0.00%> (+0.08%)
⬆️


src/community/label_propagation.c
94.61% <0.00%> (+0.09%)
⬆️


src/core/matrix.pmt
85.30% <0.00%> (+0.45%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 2b1134e...189a4cd. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1962#issuecomment-1037489924,Fixes #1956,"Thanks so much for this!
It generally looks good to me. Some small comments:

I am ambivalent about exposing IGRAPH_SHORTEST_PATH_EPSILON. What do others think? On the one hand, I'd say that this is an internal implementation detail, which shouldn't be exposed. On the other hand, it does make sense to document the threshold we use, and doing it this way ensures that it's always correct (if we write the 1e-10 in the doc text, we'll forget to update it). If we do expose this, let's mention where it is actually used: currently weighted betweenness and all_shortest_paths_dijkstra
Can you add the \briefs to the docs, and add a fullstop at the end?
There's a \c in one of the docs followed by a long quoted expression.  I think this won't render properly, and we'll need <code> instead. Can you check this please?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1962#issuecomment-1037970260,Fixes #1956,"There's a \c in one of the docs followed by a long quoted expression. I think this won't render properly,

You are correct, it won't. It works in Doxygen but not in our dumb parser; the doc syntax that we use was introduced when we migrated from Doxygen to Docbook and we wanted to save us the hassle of re-writing the doc markup, but it does not handle everything that Doxygen does.

I am ambivalent about exposing IGRAPH_SHORTEST_PATH_EPSILON. What do others think? On the one hand, I'd say that this is an internal implementation detail, which shouldn't be exposed. On the other hand, it does make sense to document the threshold we use

I think that the usage of some epsilon is a necessity due to floating-point comparisons, and the user should be aware that there is such a threshold. At that point, it does not hurt to document and expose what we actually use.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1962#issuecomment-1044824895,Fixes #1956,"Do you mind if I edit the docs a bit and change ""floats"" to ""real numbers""?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/GroteGnoom,6,https://github.com/igraph/igraph/pull/1962#issuecomment-1044856446,Fixes #1956,"Do you mind if I edit the docs a bit and change ""floats"" to ""real numbers""?

I do wonder why 🙂 They are way more float than real numbers. I do see more people do it, and of course we have igraph_real_t, but it does seem wrong to me. Reals are much different than floats.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1962#issuecomment-1044919922,Fixes #1956,"Well ""float"" is not even a proper word. It is a colloquialism used by some programmers. igraph's main audience is scientists, not programmers.
There is a chance for confusion with the float type of C.
The concept here applies to real numbers in the mathematical sense, not merely to their floating-point representation.
igraph uses the terminology ""real"", not ""float"". And it's not alone in this, so do several programming languages such as Fortran or Mathematica.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/1962#issuecomment-1044976856,Fixes #1956,"Well ""float"" is not even a proper word. It is a colloquialism used by some programmers. igraph's main audience is scientists, not programmers.


Maybe I'm missing some context here. Do you think there are a lot of people who use the C-part of igraph who don't know what floats are? Also, I thought especially mathematicians would balk at saying they're reals. They're a limited set of rational numbers with some extra things like NaN on top.

* There is a chance for confusion with the `float` type of C.


Ok, but that's why it says double-precision a few times, and the types are right there in the function. Couldn't people also be confused by thinking they're actually infinite precision?

* The concept here applies to real numbers in the mathematical sense, not merely to their floating-point representation.


But it's not a conceptual mathematical function and it deals with floating point numbers. I thought these functions were mainly used because of issues that would come up with floats, not reals.

* igraph uses the terminology ""real"", not ""float"". And it's not alone in this, so do several programming languages such as Fortran or Mathematica.


I know, and I don't fully know why. I thought for igraph it was just an easy way to not say float or double but leave it open which one you mean without finding another word that means floating point number. C uses 'float', why use Mathematica as an example instead of C?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1962,2022-02-12T12:45:25Z,2022-02-18T19:13:32Z,2022-02-18T19:13:33Z,MERGED,True,34,30,8,https://github.com/GroteGnoom,Expose float comparison with epsilon functions,3,[],https://github.com/igraph/igraph/pull/1962,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1962#issuecomment-1045020274,Fixes #1956,"OK, let's keep it as it is then. Can you please fix the last comment I made and then merge?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1964,2022-02-14T07:59:50Z,2022-02-17T09:14:05Z,2022-02-17T09:14:44Z,MERGED,True,8,21,2,https://github.com/araujo88,Reduced time complexity of igraph_vector_swap from O(n) to O(1).,12,[],https://github.com/igraph/igraph/pull/1964,https://github.com/araujo88,1,https://github.com/igraph/igraph/pull/1964,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,True,{}
igraph/igraph,https://github.com/igraph/igraph,1964,2022-02-14T07:59:50Z,2022-02-17T09:14:05Z,2022-02-17T09:14:44Z,MERGED,True,8,21,2,https://github.com/araujo88,Reduced time complexity of igraph_vector_swap from O(n) to O(1).,12,[],https://github.com/igraph/igraph/pull/1964,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1964#issuecomment-1039261745,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,"Actually, couldn't we just write the swap in terms of tmp directly instead of their components? It's really that simple, but we still want to hide this behind a function in case the implementation of vectors changes, and a direct swap is no longer correct.",True,"{'THUMBS_UP': ['https://github.com/GroteGnoom', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,1964,2022-02-14T07:59:50Z,2022-02-17T09:14:05Z,2022-02-17T09:14:44Z,MERGED,True,8,21,2,https://github.com/araujo88,Reduced time complexity of igraph_vector_swap from O(n) to O(1).,12,[],https://github.com/igraph/igraph/pull/1964,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/1964#issuecomment-1039268471,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,"Codecov Report

Merging #1964 (c07cf1d) into develop (2ce312b) will increase coverage by 0.00%.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #1964   +/-   ##
========================================
  Coverage    74.94%   74.94%           
========================================
  Files          347      347           
  Lines        57887    57880    -7     
========================================
- Hits         43383    43378    -5     
+ Misses       14504    14502    -2     



Impacted Files
Coverage Δ





src/core/matrix.pmt
85.03% <ø> (+0.18%)
⬆️


src/core/vector.pmt
88.28% <100.00%> (+0.04%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 2ce312b...c07cf1d. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1964,2022-02-14T07:59:50Z,2022-02-17T09:14:05Z,2022-02-17T09:14:44Z,MERGED,True,8,21,2,https://github.com/araujo88,Reduced time complexity of igraph_vector_swap from O(n) to O(1).,12,[],https://github.com/igraph/igraph/pull/1964,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1964#issuecomment-1039577401,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,"I just realized that to make this complete matrix_swap also needs to be updated (fix the complexity in the documentation, relax limitation of having to have the same size).",True,{'THUMBS_UP': ['https://github.com/araujo88']}
igraph/igraph,https://github.com/igraph/igraph,1964,2022-02-14T07:59:50Z,2022-02-17T09:14:05Z,2022-02-17T09:14:44Z,MERGED,True,8,21,2,https://github.com/araujo88,Reduced time complexity of igraph_vector_swap from O(n) to O(1).,12,[],https://github.com/igraph/igraph/pull/1964,https://github.com/vtraag,5,https://github.com/igraph/igraph/pull/1964#issuecomment-1041478553,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,"Hi @araujo88, I cleaned up some merge conflicts with the develop branch. There are still a few open code review comments that need to be addressed.
As @szhorvat  writes:

Actually, couldn't we just write the swap in terms of tmp directly instead of their components?

This would simplify the implementation. It essentially comes down to this:
igraph_vector_t tmp;
tmp = (*v1);
(*v1) = (*v2);
(*v2) = tmp;

Since igraph_vector_t is just a struct, by assigning another struct to it (i.e. the struct pointed to by v1, so *v1), will assign all members of the struct (i.e. stor_begin, stor_end and end in this case). This way, we can be oblivious to the details of what are the exact members in the igraph_vector_t struct, and we wouldn't need to update this function in case that changes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1964,2022-02-14T07:59:50Z,2022-02-17T09:14:05Z,2022-02-17T09:14:44Z,MERGED,True,8,21,2,https://github.com/araujo88,Reduced time complexity of igraph_vector_swap from O(n) to O(1).,12,[],https://github.com/igraph/igraph/pull/1964,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/1964#issuecomment-1042729108,This pull request references #1960 and reduces time complexity of igraph_vector_swap() from O(n) to O(1).,"Thanks for the contribution @araujo88 ! If you are interested in some other issues, contributions are always welcome!",True,{'THUMBS_UP': ['https://github.com/araujo88']}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/Katterrina,1,https://github.com/igraph/igraph/pull/1966,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/vtraag,2,https://github.com/igraph/igraph/pull/1966#issuecomment-1040100937,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","Thanks for taking a stab at this @Katterrina !
I think it would be better to stick to the asynchronous implementation of LPA, instead of switching to a synchronous implementation. What do you think @lovre?
You now seem to be taking the approach that you do one iteration over all nodes where you just check for dominance, and note move any label, correct? That generally sounds like a good direction to address the issue you identified in #1963.
When you are finished with your implementation, mark your PR as ready for review, and I'll take a closer look. Don't hesitate to ask any questions in the meantime!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/Katterrina,3,https://github.com/igraph/igraph/pull/1966#issuecomment-1040158539,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","You now seem to be taking the approach that you do one iteration over all nodes where you just check for dominance, and not move any label, correct?

Yes. I am not sure if it is the fastest solution, because it goes through all vertices twice, but I hope it works. I do not think the synchronous implementation was a good idea, but I did not realized the problems before I started programming.
I also modified the tests for LPA, but I am not sure with tests/unit/community_label_propagation2.out. The output for directed graph with unlabelled nodes not reachable from any labelled ones is a bit different now. I don't understand how it should work for directed graphs, so I can't check if it is correct.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/apps/codecov,4,https://github.com/igraph/igraph/pull/1966#issuecomment-1040175960,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","Codecov Report

Merging #1966 (514b6bf) into develop (85158c3) will increase coverage by 0.00%.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #1966   +/-   ##
========================================
  Coverage    74.94%   74.94%           
========================================
  Files          347      347           
  Lines        57887    57890    +3     
========================================
+ Hits         43383    43386    +3     
  Misses       14504    14504           



Impacted Files
Coverage Δ





src/community/label_propagation.c
94.61% <100.00%> (+0.09%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 85158c3...514b6bf. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/Katterrina,5,https://github.com/igraph/igraph/pull/1966#issuecomment-1040676097,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","Thank you very much for your comments, I corrected it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1966#issuecomment-1040721468,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","@vtraag Don't forget to update the changelog after merging. If you have time, it would also be nice to:

Backport to master (I expect another 0.9 release). This was we can ship the fix in the next python-igraph 0.9.x release.
Update the unit test to use the IGRAPH_ASSERT(a==b) style instead of the if (a != b) { return 1; } style.  @Katterrina you could do this second point if you like.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/1966#issuecomment-1040836075,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)",@szhorvat @vtraag Thanks for taking care of this PR while I am away; feel free to merge if you feel that it's solid enough. I went through the commits now and I only had one minor comment.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/Katterrina,8,https://github.com/igraph/igraph/pull/1966#issuecomment-1041320327,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)",Thank you for all the comments and suggestions!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1966,2022-02-14T21:56:33Z,2022-02-17T07:58:27Z,2022-02-17T08:41:07Z,MERGED,True,59,33,6,https://github.com/Katterrina,Ensure dominance for all labels in label propagation (fixes #1963),9,[],https://github.com/igraph/igraph/pull/1966,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/1966#issuecomment-1042700953,"I do not want to make the code much slower or memory consuming. I tried to implement the following idea: To check if the end condition holds, we need to count neighbors with diverse labels for each vertex (or weights of edges to the neighbors in a weighted case). We need to do the same for choosing a new label. I tried to count this only once, store the chosen new labels and apply it only if there is a next iteration to do.
It does not work, but I still hope I can figure out how to fix the problem. It has never finished for the unit tests right now. It could be because the updating process in my solution is synchronous, so there is a problem with oscillation -- it is described in the original paper that it could be a problem in a synchronous setting. (Or there might be some bug in my code, I do not have much experience in C programming.)","Thanks for the fix @Katterrina ! I've also backported it to the current master branch, meaning your fix will also be in our next 0.9 release. If you have anything else in the future, contributions are always welcome!",True,{}
igraph/igraph,https://github.com/igraph/igraph,1968,2022-02-19T09:33:12Z,,2022-05-26T09:28:46Z,OPEN,False,475,0,2,https://github.com/GroteGnoom,Add benchmark for using lazy adjlist in neighborhood,11,[],https://github.com/igraph/igraph/pull/1968,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1968,"Because of #1954
We want to consider using a lazy_adjlist for igraph_neighborhood.
If it turns out that's a wise idea, we might not want to merge the benchmarks at
all but just replace the old igraph_neighborhood. The benchmarks are
here just to make a decision.
The full graph and ring graph are there to show some extreme cases, so it's clear neither method is always faster.
I've also put together a different lazy adjlist, just to see how much quicker it would be than the usual lazy adjlist. It completely breaks encapsulation, but I thought it would be important to at least see what the tradeoffs were. If it's good enough, maybe we can make it cleaner, and still keep the benefits?
Todo:
use malloc instead of calloc for data in lazy adjlist 2
maybe try to optimize the non-lazy adjlist too?
Results for all vertices (on one particular computer):
Select all vertices:

Full graph:
order 1:
| Original function:                                                               0.017s  0.015s  0.001s
| Using a lazy adjlist:                                                            0.023s  0.021s  0.003s
| Using lazy adjlist 2:                                                            0.015s  0.015s      0s
| Using adjlist:                                                                   0.018s  0.018s      0s
order 2:
| Original function:                                                                1.76s   1.76s  0.002s
| Using a lazy adjlist:                                                             1.15s   1.14s  0.002s
| Using lazy adjlist 2:                                                              1.1s    1.1s  0.001s
| Using adjlist:                                                                    1.12s   1.11s  0.002s
order 3:
| Original function:                                                                1.78s   1.77s  0.002s
| Using a lazy adjlist:                                                             1.12s   1.11s  0.001s
| Using lazy adjlist 2:                                                             1.45s   1.45s  0.001s
| Using adjlist:                                                                   0.806s  0.804s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.351s  0.345s  0.006s
| Using a lazy adjlist:                                                             1.02s  0.983s  0.032s
| Using lazy adjlist 2:                                                            0.379s  0.372s  0.006s
| Using adjlist:                                                                    0.65s   0.64s  0.008s
order 2:
| Original function:                                                               0.491s  0.483s  0.008s
| Using a lazy adjlist:                                                             1.16s   1.14s  0.022s
| Using lazy adjlist 2:                                                            0.475s  0.469s  0.006s
| Using adjlist:                                                                   0.723s   0.71s  0.012s
order 3:
| Original function:                                                               0.645s   0.63s  0.014s
| Using a lazy adjlist:                                                             1.19s   1.15s  0.035s
| Using lazy adjlist 2:                                                            0.547s   0.53s  0.016s
| Using adjlist:                                                                   0.807s  0.784s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s  0.019s      0s
| Using lazy adjlist 2:                                                            0.009s  0.009s      0s
| Using adjlist:                                                                   0.013s  0.013s      0s
order 2:
| Original function:                                                               0.125s  0.124s  0.001s
| Using a lazy adjlist:                                                            0.114s  0.111s  0.003s
| Using lazy adjlist 2:                                                            0.098s  0.096s  0.002s
| Using adjlist:                                                                   0.099s  0.098s      0s
order 3:
| Original function:                                                                1.84s   1.79s   0.04s
| Using a lazy adjlist:                                                             1.34s   1.29s  0.042s
| Using lazy adjlist 2:                                                             1.33s   1.29s  0.046s
| Using adjlist:                                                                    1.27s   1.24s  0.022s


Select 10% of vertices:

Full graph:
order 1:
| Original function:                                                               0.012s  0.012s      0s
| Using a lazy adjlist:                                                            0.016s  0.016s  0.001s
| Using lazy adjlist 2:                                                            0.017s  0.016s      0s
| Using adjlist:                                                                   0.062s  0.062s      0s
order 2:
| Original function:                                                                1.84s   1.84s  0.002s
| Using a lazy adjlist:                                                             1.19s   1.19s  0.001s
| Using lazy adjlist 2:                                                             1.17s   1.17s  0.002s
| Using adjlist:                                                                    1.19s   1.19s  0.001s
order 3:
| Original function:                                                                1.81s    1.8s  0.002s
| Using a lazy adjlist:                                                             1.22s   1.22s  0.002s
| Using lazy adjlist 2:                                                             1.52s   1.52s  0.002s
| Using adjlist:                                                                   0.892s   0.89s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.338s  0.337s      0s
| Using a lazy adjlist:                                                            0.897s  0.894s  0.001s
| Using lazy adjlist 2:                                                            0.363s  0.361s  0.001s
| Using adjlist:                                                                    3.15s   3.14s  0.011s
order 2:
| Original function:                                                               0.453s  0.451s  0.001s
| Using a lazy adjlist:                                                            0.981s  0.979s  0.001s
| Using lazy adjlist 2:                                                            0.431s   0.43s  0.001s
| Using adjlist:                                                                    3.28s   3.25s  0.024s
order 3:
| Original function:                                                               0.587s  0.585s  0.001s
| Using a lazy adjlist:                                                             1.03s   1.03s  0.001s
| Using lazy adjlist 2:                                                            0.519s  0.517s  0.002s
| Using adjlist:                                                                    3.31s   3.28s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s   0.02s      0s
| Using lazy adjlist 2:                                                             0.01s   0.01s      0s
| Using adjlist:                                                                   0.066s  0.066s      0s
order 2:
| Original function:                                                               0.124s  0.124s      0s
| Using a lazy adjlist:                                                            0.204s  0.203s      0s
| Using lazy adjlist 2:                                                             0.11s   0.11s      0s
| Using adjlist:                                                                   0.149s  0.148s      0s
order 3:
| Original function:                                                                1.82s   1.81s  0.002s
| Using a lazy adjlist:                                                             1.42s   1.41s  0.002s
| Using lazy adjlist 2:                                                             1.29s   1.29s  0.002s
| Using adjlist:                                                                    1.32s   1.31s  0.002s","Because of #1954
We want to consider using a lazy_adjlist for igraph_neighborhood.
If it turns out that's a wise idea, we might not want to merge the benchmarks at
all but just replace the old igraph_neighborhood. The benchmarks are
here just to make a decision.
The full graph and ring graph are there to show some extreme cases, so it's clear neither method is always faster.
I've also put together a different lazy adjlist, just to see how much quicker it would be than the usual lazy adjlist. It completely breaks encapsulation, but I thought it would be important to at least see what the tradeoffs were. If it's good enough, maybe we can make it cleaner, and still keep the benefits?
Todo:
use malloc instead of calloc for data in lazy adjlist 2
maybe try to optimize the non-lazy adjlist too?
Results for all vertices (on one particular computer):
Select all vertices:

Full graph:
order 1:
| Original function:                                                               0.017s  0.015s  0.001s
| Using a lazy adjlist:                                                            0.023s  0.021s  0.003s
| Using lazy adjlist 2:                                                            0.015s  0.015s      0s
| Using adjlist:                                                                   0.018s  0.018s      0s
order 2:
| Original function:                                                                1.76s   1.76s  0.002s
| Using a lazy adjlist:                                                             1.15s   1.14s  0.002s
| Using lazy adjlist 2:                                                              1.1s    1.1s  0.001s
| Using adjlist:                                                                    1.12s   1.11s  0.002s
order 3:
| Original function:                                                                1.78s   1.77s  0.002s
| Using a lazy adjlist:                                                             1.12s   1.11s  0.001s
| Using lazy adjlist 2:                                                             1.45s   1.45s  0.001s
| Using adjlist:                                                                   0.806s  0.804s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.351s  0.345s  0.006s
| Using a lazy adjlist:                                                             1.02s  0.983s  0.032s
| Using lazy adjlist 2:                                                            0.379s  0.372s  0.006s
| Using adjlist:                                                                    0.65s   0.64s  0.008s
order 2:
| Original function:                                                               0.491s  0.483s  0.008s
| Using a lazy adjlist:                                                             1.16s   1.14s  0.022s
| Using lazy adjlist 2:                                                            0.475s  0.469s  0.006s
| Using adjlist:                                                                   0.723s   0.71s  0.012s
order 3:
| Original function:                                                               0.645s   0.63s  0.014s
| Using a lazy adjlist:                                                             1.19s   1.15s  0.035s
| Using lazy adjlist 2:                                                            0.547s   0.53s  0.016s
| Using adjlist:                                                                   0.807s  0.784s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s  0.019s      0s
| Using lazy adjlist 2:                                                            0.009s  0.009s      0s
| Using adjlist:                                                                   0.013s  0.013s      0s
order 2:
| Original function:                                                               0.125s  0.124s  0.001s
| Using a lazy adjlist:                                                            0.114s  0.111s  0.003s
| Using lazy adjlist 2:                                                            0.098s  0.096s  0.002s
| Using adjlist:                                                                   0.099s  0.098s      0s
order 3:
| Original function:                                                                1.84s   1.79s   0.04s
| Using a lazy adjlist:                                                             1.34s   1.29s  0.042s
| Using lazy adjlist 2:                                                             1.33s   1.29s  0.046s
| Using adjlist:                                                                    1.27s   1.24s  0.022s


Select 10% of vertices:

Full graph:
order 1:
| Original function:                                                               0.012s  0.012s      0s
| Using a lazy adjlist:                                                            0.016s  0.016s  0.001s
| Using lazy adjlist 2:                                                            0.017s  0.016s      0s
| Using adjlist:                                                                   0.062s  0.062s      0s
order 2:
| Original function:                                                                1.84s   1.84s  0.002s
| Using a lazy adjlist:                                                             1.19s   1.19s  0.001s
| Using lazy adjlist 2:                                                             1.17s   1.17s  0.002s
| Using adjlist:                                                                    1.19s   1.19s  0.001s
order 3:
| Original function:                                                                1.81s    1.8s  0.002s
| Using a lazy adjlist:                                                             1.22s   1.22s  0.002s
| Using lazy adjlist 2:                                                             1.52s   1.52s  0.002s
| Using adjlist:                                                                   0.892s   0.89s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.338s  0.337s      0s
| Using a lazy adjlist:                                                            0.897s  0.894s  0.001s
| Using lazy adjlist 2:                                                            0.363s  0.361s  0.001s
| Using adjlist:                                                                    3.15s   3.14s  0.011s
order 2:
| Original function:                                                               0.453s  0.451s  0.001s
| Using a lazy adjlist:                                                            0.981s  0.979s  0.001s
| Using lazy adjlist 2:                                                            0.431s   0.43s  0.001s
| Using adjlist:                                                                    3.28s   3.25s  0.024s
order 3:
| Original function:                                                               0.587s  0.585s  0.001s
| Using a lazy adjlist:                                                             1.03s   1.03s  0.001s
| Using lazy adjlist 2:                                                            0.519s  0.517s  0.002s
| Using adjlist:                                                                    3.31s   3.28s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s   0.02s      0s
| Using lazy adjlist 2:                                                             0.01s   0.01s      0s
| Using adjlist:                                                                   0.066s  0.066s      0s
order 2:
| Original function:                                                               0.124s  0.124s      0s
| Using a lazy adjlist:                                                            0.204s  0.203s      0s
| Using lazy adjlist 2:                                                             0.11s   0.11s      0s
| Using adjlist:                                                                   0.149s  0.148s      0s
order 3:
| Original function:                                                                1.82s   1.81s  0.002s
| Using a lazy adjlist:                                                             1.42s   1.41s  0.002s
| Using lazy adjlist 2:                                                             1.29s   1.29s  0.002s
| Using adjlist:                                                                    1.32s   1.31s  0.002s",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1968,2022-02-19T09:33:12Z,,2022-05-26T09:28:46Z,OPEN,False,475,0,2,https://github.com/GroteGnoom,Add benchmark for using lazy adjlist in neighborhood,11,[],https://github.com/igraph/igraph/pull/1968,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1968#issuecomment-1045978045,"Because of #1954
We want to consider using a lazy_adjlist for igraph_neighborhood.
If it turns out that's a wise idea, we might not want to merge the benchmarks at
all but just replace the old igraph_neighborhood. The benchmarks are
here just to make a decision.
The full graph and ring graph are there to show some extreme cases, so it's clear neither method is always faster.
I've also put together a different lazy adjlist, just to see how much quicker it would be than the usual lazy adjlist. It completely breaks encapsulation, but I thought it would be important to at least see what the tradeoffs were. If it's good enough, maybe we can make it cleaner, and still keep the benefits?
Todo:
use malloc instead of calloc for data in lazy adjlist 2
maybe try to optimize the non-lazy adjlist too?
Results for all vertices (on one particular computer):
Select all vertices:

Full graph:
order 1:
| Original function:                                                               0.017s  0.015s  0.001s
| Using a lazy adjlist:                                                            0.023s  0.021s  0.003s
| Using lazy adjlist 2:                                                            0.015s  0.015s      0s
| Using adjlist:                                                                   0.018s  0.018s      0s
order 2:
| Original function:                                                                1.76s   1.76s  0.002s
| Using a lazy adjlist:                                                             1.15s   1.14s  0.002s
| Using lazy adjlist 2:                                                              1.1s    1.1s  0.001s
| Using adjlist:                                                                    1.12s   1.11s  0.002s
order 3:
| Original function:                                                                1.78s   1.77s  0.002s
| Using a lazy adjlist:                                                             1.12s   1.11s  0.001s
| Using lazy adjlist 2:                                                             1.45s   1.45s  0.001s
| Using adjlist:                                                                   0.806s  0.804s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.351s  0.345s  0.006s
| Using a lazy adjlist:                                                             1.02s  0.983s  0.032s
| Using lazy adjlist 2:                                                            0.379s  0.372s  0.006s
| Using adjlist:                                                                    0.65s   0.64s  0.008s
order 2:
| Original function:                                                               0.491s  0.483s  0.008s
| Using a lazy adjlist:                                                             1.16s   1.14s  0.022s
| Using lazy adjlist 2:                                                            0.475s  0.469s  0.006s
| Using adjlist:                                                                   0.723s   0.71s  0.012s
order 3:
| Original function:                                                               0.645s   0.63s  0.014s
| Using a lazy adjlist:                                                             1.19s   1.15s  0.035s
| Using lazy adjlist 2:                                                            0.547s   0.53s  0.016s
| Using adjlist:                                                                   0.807s  0.784s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s  0.019s      0s
| Using lazy adjlist 2:                                                            0.009s  0.009s      0s
| Using adjlist:                                                                   0.013s  0.013s      0s
order 2:
| Original function:                                                               0.125s  0.124s  0.001s
| Using a lazy adjlist:                                                            0.114s  0.111s  0.003s
| Using lazy adjlist 2:                                                            0.098s  0.096s  0.002s
| Using adjlist:                                                                   0.099s  0.098s      0s
order 3:
| Original function:                                                                1.84s   1.79s   0.04s
| Using a lazy adjlist:                                                             1.34s   1.29s  0.042s
| Using lazy adjlist 2:                                                             1.33s   1.29s  0.046s
| Using adjlist:                                                                    1.27s   1.24s  0.022s


Select 10% of vertices:

Full graph:
order 1:
| Original function:                                                               0.012s  0.012s      0s
| Using a lazy adjlist:                                                            0.016s  0.016s  0.001s
| Using lazy adjlist 2:                                                            0.017s  0.016s      0s
| Using adjlist:                                                                   0.062s  0.062s      0s
order 2:
| Original function:                                                                1.84s   1.84s  0.002s
| Using a lazy adjlist:                                                             1.19s   1.19s  0.001s
| Using lazy adjlist 2:                                                             1.17s   1.17s  0.002s
| Using adjlist:                                                                    1.19s   1.19s  0.001s
order 3:
| Original function:                                                                1.81s    1.8s  0.002s
| Using a lazy adjlist:                                                             1.22s   1.22s  0.002s
| Using lazy adjlist 2:                                                             1.52s   1.52s  0.002s
| Using adjlist:                                                                   0.892s   0.89s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.338s  0.337s      0s
| Using a lazy adjlist:                                                            0.897s  0.894s  0.001s
| Using lazy adjlist 2:                                                            0.363s  0.361s  0.001s
| Using adjlist:                                                                    3.15s   3.14s  0.011s
order 2:
| Original function:                                                               0.453s  0.451s  0.001s
| Using a lazy adjlist:                                                            0.981s  0.979s  0.001s
| Using lazy adjlist 2:                                                            0.431s   0.43s  0.001s
| Using adjlist:                                                                    3.28s   3.25s  0.024s
order 3:
| Original function:                                                               0.587s  0.585s  0.001s
| Using a lazy adjlist:                                                             1.03s   1.03s  0.001s
| Using lazy adjlist 2:                                                            0.519s  0.517s  0.002s
| Using adjlist:                                                                    3.31s   3.28s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s   0.02s      0s
| Using lazy adjlist 2:                                                             0.01s   0.01s      0s
| Using adjlist:                                                                   0.066s  0.066s      0s
order 2:
| Original function:                                                               0.124s  0.124s      0s
| Using a lazy adjlist:                                                            0.204s  0.203s      0s
| Using lazy adjlist 2:                                                             0.11s   0.11s      0s
| Using adjlist:                                                                   0.149s  0.148s      0s
order 3:
| Original function:                                                                1.82s   1.81s  0.002s
| Using a lazy adjlist:                                                             1.42s   1.41s  0.002s
| Using lazy adjlist 2:                                                             1.29s   1.29s  0.002s
| Using adjlist:                                                                    1.32s   1.31s  0.002s","Codecov Report

Merging #1968 (7105609) into develop (ef1d7a8) will decrease coverage by 0.00%.
The diff coverage is n/a.


@@             Coverage Diff             @@
##           develop    #1968      +/-   ##
===========================================
- Coverage    74.94%   74.94%   -0.01%     
===========================================
  Files          347      347              
  Lines        57898    57893       -5     
===========================================
- Hits         43392    43387       -5     
  Misses       14506    14506              



Impacted Files
Coverage Δ





src/graph/adjlist.c
63.42% <0.00%> (-0.47%)
⬇️


src/core/vector.pmt
88.28% <0.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update ef1d7a8...7105609. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1968,2022-02-19T09:33:12Z,,2022-05-26T09:28:46Z,OPEN,False,475,0,2,https://github.com/GroteGnoom,Add benchmark for using lazy adjlist in neighborhood,11,[],https://github.com/igraph/igraph/pull/1968,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1968#issuecomment-1045984915,"Because of #1954
We want to consider using a lazy_adjlist for igraph_neighborhood.
If it turns out that's a wise idea, we might not want to merge the benchmarks at
all but just replace the old igraph_neighborhood. The benchmarks are
here just to make a decision.
The full graph and ring graph are there to show some extreme cases, so it's clear neither method is always faster.
I've also put together a different lazy adjlist, just to see how much quicker it would be than the usual lazy adjlist. It completely breaks encapsulation, but I thought it would be important to at least see what the tradeoffs were. If it's good enough, maybe we can make it cleaner, and still keep the benefits?
Todo:
use malloc instead of calloc for data in lazy adjlist 2
maybe try to optimize the non-lazy adjlist too?
Results for all vertices (on one particular computer):
Select all vertices:

Full graph:
order 1:
| Original function:                                                               0.017s  0.015s  0.001s
| Using a lazy adjlist:                                                            0.023s  0.021s  0.003s
| Using lazy adjlist 2:                                                            0.015s  0.015s      0s
| Using adjlist:                                                                   0.018s  0.018s      0s
order 2:
| Original function:                                                                1.76s   1.76s  0.002s
| Using a lazy adjlist:                                                             1.15s   1.14s  0.002s
| Using lazy adjlist 2:                                                              1.1s    1.1s  0.001s
| Using adjlist:                                                                    1.12s   1.11s  0.002s
order 3:
| Original function:                                                                1.78s   1.77s  0.002s
| Using a lazy adjlist:                                                             1.12s   1.11s  0.001s
| Using lazy adjlist 2:                                                             1.45s   1.45s  0.001s
| Using adjlist:                                                                   0.806s  0.804s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.351s  0.345s  0.006s
| Using a lazy adjlist:                                                             1.02s  0.983s  0.032s
| Using lazy adjlist 2:                                                            0.379s  0.372s  0.006s
| Using adjlist:                                                                    0.65s   0.64s  0.008s
order 2:
| Original function:                                                               0.491s  0.483s  0.008s
| Using a lazy adjlist:                                                             1.16s   1.14s  0.022s
| Using lazy adjlist 2:                                                            0.475s  0.469s  0.006s
| Using adjlist:                                                                   0.723s   0.71s  0.012s
order 3:
| Original function:                                                               0.645s   0.63s  0.014s
| Using a lazy adjlist:                                                             1.19s   1.15s  0.035s
| Using lazy adjlist 2:                                                            0.547s   0.53s  0.016s
| Using adjlist:                                                                   0.807s  0.784s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s  0.019s      0s
| Using lazy adjlist 2:                                                            0.009s  0.009s      0s
| Using adjlist:                                                                   0.013s  0.013s      0s
order 2:
| Original function:                                                               0.125s  0.124s  0.001s
| Using a lazy adjlist:                                                            0.114s  0.111s  0.003s
| Using lazy adjlist 2:                                                            0.098s  0.096s  0.002s
| Using adjlist:                                                                   0.099s  0.098s      0s
order 3:
| Original function:                                                                1.84s   1.79s   0.04s
| Using a lazy adjlist:                                                             1.34s   1.29s  0.042s
| Using lazy adjlist 2:                                                             1.33s   1.29s  0.046s
| Using adjlist:                                                                    1.27s   1.24s  0.022s


Select 10% of vertices:

Full graph:
order 1:
| Original function:                                                               0.012s  0.012s      0s
| Using a lazy adjlist:                                                            0.016s  0.016s  0.001s
| Using lazy adjlist 2:                                                            0.017s  0.016s      0s
| Using adjlist:                                                                   0.062s  0.062s      0s
order 2:
| Original function:                                                                1.84s   1.84s  0.002s
| Using a lazy adjlist:                                                             1.19s   1.19s  0.001s
| Using lazy adjlist 2:                                                             1.17s   1.17s  0.002s
| Using adjlist:                                                                    1.19s   1.19s  0.001s
order 3:
| Original function:                                                                1.81s    1.8s  0.002s
| Using a lazy adjlist:                                                             1.22s   1.22s  0.002s
| Using lazy adjlist 2:                                                             1.52s   1.52s  0.002s
| Using adjlist:                                                                   0.892s   0.89s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.338s  0.337s      0s
| Using a lazy adjlist:                                                            0.897s  0.894s  0.001s
| Using lazy adjlist 2:                                                            0.363s  0.361s  0.001s
| Using adjlist:                                                                    3.15s   3.14s  0.011s
order 2:
| Original function:                                                               0.453s  0.451s  0.001s
| Using a lazy adjlist:                                                            0.981s  0.979s  0.001s
| Using lazy adjlist 2:                                                            0.431s   0.43s  0.001s
| Using adjlist:                                                                    3.28s   3.25s  0.024s
order 3:
| Original function:                                                               0.587s  0.585s  0.001s
| Using a lazy adjlist:                                                             1.03s   1.03s  0.001s
| Using lazy adjlist 2:                                                            0.519s  0.517s  0.002s
| Using adjlist:                                                                    3.31s   3.28s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s   0.02s      0s
| Using lazy adjlist 2:                                                             0.01s   0.01s      0s
| Using adjlist:                                                                   0.066s  0.066s      0s
order 2:
| Original function:                                                               0.124s  0.124s      0s
| Using a lazy adjlist:                                                            0.204s  0.203s      0s
| Using lazy adjlist 2:                                                             0.11s   0.11s      0s
| Using adjlist:                                                                   0.149s  0.148s      0s
order 3:
| Original function:                                                                1.82s   1.81s  0.002s
| Using a lazy adjlist:                                                             1.42s   1.41s  0.002s
| Using lazy adjlist 2:                                                             1.29s   1.29s  0.002s
| Using adjlist:                                                                    1.32s   1.31s  0.002s","Thanks for looking into this!
There is no doubt that using either a lazy or non-lazy adjlist will speed this up if: (1) using an order greater than 1 (2) computing it for all vertices.
The question is: Will there be a noticeable slowdown when computing it only for some of the vertices with a small order (or order=1)?  Making the adjlist lazy should prevent any slowdown.
I noticed that you used a complete graph for the benchmark. In most cases, such a graph is not representative of real use cases. In this case, in particular, a complete graph does not make much sense as 1st order of each vertex is already the entire graph.
A random graph (Erdős-Rényi) would be a good starting point, but when processing only some vertices or just a single one (instead of all) you need to be careful not to accidentally start at one which is in a tiny component, or even a single isolated vertex. It will have a very small neighbourhood. You could keep generating random graphs until you get a connected one. To get a reasonable probability that the graph is connected, make sure that it has at least n log(n) / 2 edges where n is the vertex count.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1968,2022-02-19T09:33:12Z,,2022-05-26T09:28:46Z,OPEN,False,475,0,2,https://github.com/GroteGnoom,Add benchmark for using lazy adjlist in neighborhood,11,[],https://github.com/igraph/igraph/pull/1968,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1968#issuecomment-1046081933,"Because of #1954
We want to consider using a lazy_adjlist for igraph_neighborhood.
If it turns out that's a wise idea, we might not want to merge the benchmarks at
all but just replace the old igraph_neighborhood. The benchmarks are
here just to make a decision.
The full graph and ring graph are there to show some extreme cases, so it's clear neither method is always faster.
I've also put together a different lazy adjlist, just to see how much quicker it would be than the usual lazy adjlist. It completely breaks encapsulation, but I thought it would be important to at least see what the tradeoffs were. If it's good enough, maybe we can make it cleaner, and still keep the benefits?
Todo:
use malloc instead of calloc for data in lazy adjlist 2
maybe try to optimize the non-lazy adjlist too?
Results for all vertices (on one particular computer):
Select all vertices:

Full graph:
order 1:
| Original function:                                                               0.017s  0.015s  0.001s
| Using a lazy adjlist:                                                            0.023s  0.021s  0.003s
| Using lazy adjlist 2:                                                            0.015s  0.015s      0s
| Using adjlist:                                                                   0.018s  0.018s      0s
order 2:
| Original function:                                                                1.76s   1.76s  0.002s
| Using a lazy adjlist:                                                             1.15s   1.14s  0.002s
| Using lazy adjlist 2:                                                              1.1s    1.1s  0.001s
| Using adjlist:                                                                    1.12s   1.11s  0.002s
order 3:
| Original function:                                                                1.78s   1.77s  0.002s
| Using a lazy adjlist:                                                             1.12s   1.11s  0.001s
| Using lazy adjlist 2:                                                             1.45s   1.45s  0.001s
| Using adjlist:                                                                   0.806s  0.804s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.351s  0.345s  0.006s
| Using a lazy adjlist:                                                             1.02s  0.983s  0.032s
| Using lazy adjlist 2:                                                            0.379s  0.372s  0.006s
| Using adjlist:                                                                    0.65s   0.64s  0.008s
order 2:
| Original function:                                                               0.491s  0.483s  0.008s
| Using a lazy adjlist:                                                             1.16s   1.14s  0.022s
| Using lazy adjlist 2:                                                            0.475s  0.469s  0.006s
| Using adjlist:                                                                   0.723s   0.71s  0.012s
order 3:
| Original function:                                                               0.645s   0.63s  0.014s
| Using a lazy adjlist:                                                             1.19s   1.15s  0.035s
| Using lazy adjlist 2:                                                            0.547s   0.53s  0.016s
| Using adjlist:                                                                   0.807s  0.784s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s  0.019s      0s
| Using lazy adjlist 2:                                                            0.009s  0.009s      0s
| Using adjlist:                                                                   0.013s  0.013s      0s
order 2:
| Original function:                                                               0.125s  0.124s  0.001s
| Using a lazy adjlist:                                                            0.114s  0.111s  0.003s
| Using lazy adjlist 2:                                                            0.098s  0.096s  0.002s
| Using adjlist:                                                                   0.099s  0.098s      0s
order 3:
| Original function:                                                                1.84s   1.79s   0.04s
| Using a lazy adjlist:                                                             1.34s   1.29s  0.042s
| Using lazy adjlist 2:                                                             1.33s   1.29s  0.046s
| Using adjlist:                                                                    1.27s   1.24s  0.022s


Select 10% of vertices:

Full graph:
order 1:
| Original function:                                                               0.012s  0.012s      0s
| Using a lazy adjlist:                                                            0.016s  0.016s  0.001s
| Using lazy adjlist 2:                                                            0.017s  0.016s      0s
| Using adjlist:                                                                   0.062s  0.062s      0s
order 2:
| Original function:                                                                1.84s   1.84s  0.002s
| Using a lazy adjlist:                                                             1.19s   1.19s  0.001s
| Using lazy adjlist 2:                                                             1.17s   1.17s  0.002s
| Using adjlist:                                                                    1.19s   1.19s  0.001s
order 3:
| Original function:                                                                1.81s    1.8s  0.002s
| Using a lazy adjlist:                                                             1.22s   1.22s  0.002s
| Using lazy adjlist 2:                                                             1.52s   1.52s  0.002s
| Using adjlist:                                                                   0.892s   0.89s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.338s  0.337s      0s
| Using a lazy adjlist:                                                            0.897s  0.894s  0.001s
| Using lazy adjlist 2:                                                            0.363s  0.361s  0.001s
| Using adjlist:                                                                    3.15s   3.14s  0.011s
order 2:
| Original function:                                                               0.453s  0.451s  0.001s
| Using a lazy adjlist:                                                            0.981s  0.979s  0.001s
| Using lazy adjlist 2:                                                            0.431s   0.43s  0.001s
| Using adjlist:                                                                    3.28s   3.25s  0.024s
order 3:
| Original function:                                                               0.587s  0.585s  0.001s
| Using a lazy adjlist:                                                             1.03s   1.03s  0.001s
| Using lazy adjlist 2:                                                            0.519s  0.517s  0.002s
| Using adjlist:                                                                    3.31s   3.28s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s   0.02s      0s
| Using lazy adjlist 2:                                                             0.01s   0.01s      0s
| Using adjlist:                                                                   0.066s  0.066s      0s
order 2:
| Original function:                                                               0.124s  0.124s      0s
| Using a lazy adjlist:                                                            0.204s  0.203s      0s
| Using lazy adjlist 2:                                                             0.11s   0.11s      0s
| Using adjlist:                                                                   0.149s  0.148s      0s
order 3:
| Original function:                                                                1.82s   1.81s  0.002s
| Using a lazy adjlist:                                                             1.42s   1.41s  0.002s
| Using lazy adjlist 2:                                                             1.29s   1.29s  0.002s
| Using adjlist:                                                                    1.32s   1.31s  0.002s","Now that's surprising to me:
Ring graph:
order 1:
| Original function:                                                               0.025s  0.024s  0.001s
| Using adjlist:                                                                   0.063s  0.059s  0.004s

Is this consistently reproducible? What if you add a REPEAT in there to bring the timing closer to 1 second (and therefore make it more reliable)?
Maybe you can use a profiler to get some insight (if you're used to profilers)?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1968,2022-02-19T09:33:12Z,,2022-05-26T09:28:46Z,OPEN,False,475,0,2,https://github.com/GroteGnoom,Add benchmark for using lazy adjlist in neighborhood,11,[],https://github.com/igraph/igraph/pull/1968,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/1968#issuecomment-1046084716,"Because of #1954
We want to consider using a lazy_adjlist for igraph_neighborhood.
If it turns out that's a wise idea, we might not want to merge the benchmarks at
all but just replace the old igraph_neighborhood. The benchmarks are
here just to make a decision.
The full graph and ring graph are there to show some extreme cases, so it's clear neither method is always faster.
I've also put together a different lazy adjlist, just to see how much quicker it would be than the usual lazy adjlist. It completely breaks encapsulation, but I thought it would be important to at least see what the tradeoffs were. If it's good enough, maybe we can make it cleaner, and still keep the benefits?
Todo:
use malloc instead of calloc for data in lazy adjlist 2
maybe try to optimize the non-lazy adjlist too?
Results for all vertices (on one particular computer):
Select all vertices:

Full graph:
order 1:
| Original function:                                                               0.017s  0.015s  0.001s
| Using a lazy adjlist:                                                            0.023s  0.021s  0.003s
| Using lazy adjlist 2:                                                            0.015s  0.015s      0s
| Using adjlist:                                                                   0.018s  0.018s      0s
order 2:
| Original function:                                                                1.76s   1.76s  0.002s
| Using a lazy adjlist:                                                             1.15s   1.14s  0.002s
| Using lazy adjlist 2:                                                              1.1s    1.1s  0.001s
| Using adjlist:                                                                    1.12s   1.11s  0.002s
order 3:
| Original function:                                                                1.78s   1.77s  0.002s
| Using a lazy adjlist:                                                             1.12s   1.11s  0.001s
| Using lazy adjlist 2:                                                             1.45s   1.45s  0.001s
| Using adjlist:                                                                   0.806s  0.804s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.351s  0.345s  0.006s
| Using a lazy adjlist:                                                             1.02s  0.983s  0.032s
| Using lazy adjlist 2:                                                            0.379s  0.372s  0.006s
| Using adjlist:                                                                    0.65s   0.64s  0.008s
order 2:
| Original function:                                                               0.491s  0.483s  0.008s
| Using a lazy adjlist:                                                             1.16s   1.14s  0.022s
| Using lazy adjlist 2:                                                            0.475s  0.469s  0.006s
| Using adjlist:                                                                   0.723s   0.71s  0.012s
order 3:
| Original function:                                                               0.645s   0.63s  0.014s
| Using a lazy adjlist:                                                             1.19s   1.15s  0.035s
| Using lazy adjlist 2:                                                            0.547s   0.53s  0.016s
| Using adjlist:                                                                   0.807s  0.784s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s  0.019s      0s
| Using lazy adjlist 2:                                                            0.009s  0.009s      0s
| Using adjlist:                                                                   0.013s  0.013s      0s
order 2:
| Original function:                                                               0.125s  0.124s  0.001s
| Using a lazy adjlist:                                                            0.114s  0.111s  0.003s
| Using lazy adjlist 2:                                                            0.098s  0.096s  0.002s
| Using adjlist:                                                                   0.099s  0.098s      0s
order 3:
| Original function:                                                                1.84s   1.79s   0.04s
| Using a lazy adjlist:                                                             1.34s   1.29s  0.042s
| Using lazy adjlist 2:                                                             1.33s   1.29s  0.046s
| Using adjlist:                                                                    1.27s   1.24s  0.022s


Select 10% of vertices:

Full graph:
order 1:
| Original function:                                                               0.012s  0.012s      0s
| Using a lazy adjlist:                                                            0.016s  0.016s  0.001s
| Using lazy adjlist 2:                                                            0.017s  0.016s      0s
| Using adjlist:                                                                   0.062s  0.062s      0s
order 2:
| Original function:                                                                1.84s   1.84s  0.002s
| Using a lazy adjlist:                                                             1.19s   1.19s  0.001s
| Using lazy adjlist 2:                                                             1.17s   1.17s  0.002s
| Using adjlist:                                                                    1.19s   1.19s  0.001s
order 3:
| Original function:                                                                1.81s    1.8s  0.002s
| Using a lazy adjlist:                                                             1.22s   1.22s  0.002s
| Using lazy adjlist 2:                                                             1.52s   1.52s  0.002s
| Using adjlist:                                                                   0.892s   0.89s  0.001s

Ring graph:
order 1:
| Original function:                                                               0.338s  0.337s      0s
| Using a lazy adjlist:                                                            0.897s  0.894s  0.001s
| Using lazy adjlist 2:                                                            0.363s  0.361s  0.001s
| Using adjlist:                                                                    3.15s   3.14s  0.011s
order 2:
| Original function:                                                               0.453s  0.451s  0.001s
| Using a lazy adjlist:                                                            0.981s  0.979s  0.001s
| Using lazy adjlist 2:                                                            0.431s   0.43s  0.001s
| Using adjlist:                                                                    3.28s   3.25s  0.024s
order 3:
| Original function:                                                               0.587s  0.585s  0.001s
| Using a lazy adjlist:                                                             1.03s   1.03s  0.001s
| Using lazy adjlist 2:                                                            0.519s  0.517s  0.002s
| Using adjlist:                                                                    3.31s   3.28s  0.021s

Random graph:
order 1:
| Original function:                                                               0.008s  0.008s      0s
| Using a lazy adjlist:                                                             0.02s   0.02s      0s
| Using lazy adjlist 2:                                                             0.01s   0.01s      0s
| Using adjlist:                                                                   0.066s  0.066s      0s
order 2:
| Original function:                                                               0.124s  0.124s      0s
| Using a lazy adjlist:                                                            0.204s  0.203s      0s
| Using lazy adjlist 2:                                                             0.11s   0.11s      0s
| Using adjlist:                                                                   0.149s  0.148s      0s
order 3:
| Original function:                                                                1.82s   1.81s  0.002s
| Using a lazy adjlist:                                                             1.42s   1.41s  0.002s
| Using lazy adjlist 2:                                                             1.29s   1.29s  0.002s
| Using adjlist:                                                                    1.32s   1.31s  0.002s",I thought this would happen because of lots of little mallocs. I'll try to get some profiling going later 🙂,True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1969,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1969#issuecomment-1046007778,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Codecov Report

Merging #1969 (1dc7a55) into develop (3f51027) will decrease coverage by 0.00%.
The diff coverage is 72.56%.


@@             Coverage Diff             @@
##           develop    #1969      +/-   ##
===========================================
- Coverage    75.77%   75.77%   -0.01%     
===========================================
  Files          350      350              
  Lines        57407    57406       -1     
===========================================
- Hits         43501    43497       -4     
- Misses       13906    13909       +3     



Impacted Files
Coverage Δ





src/core/hashtable.c
98.00% <ø> (ø)



src/internal/hacks.c
0.00% <0.00%> (ø)



src/io/dot.c
22.80% <ø> (ø)



src/io/lgl.c
58.56% <ø> (ø)



src/io/ncol.c
9.81% <ø> (ø)



src/core/strvector.c
78.57% <74.28%> (+1.09%)
⬆️


src/graph/cattributes.c
68.20% <80.00%> (ø)



src/core/trie.c
91.17% <100.00%> (ø)



src/core/vector.pmt
87.87% <100.00%> (+0.07%)
⬆️


src/io/gml.c
81.22% <100.00%> (ø)



... and 2 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 3f51027...1dc7a55. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1969#issuecomment-1047811950,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","I'll put this here now, as later I'm going to forget it. It will also serve as a review checklist.

 reserve method; all reallocation should go through it, like in vector_t
 push_back method, add should be deprecated
 protection against overflow, especially when doubling storage in push_back / add
 functions that fail should leave the data structure in a consistent state; especially push_back / add
 get functions should return result directly",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/1969#issuecomment-1061856284,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Tried to resolve conflicts with develop by taking your changes, except these two:

igraph_strvector_move_interval() was removed
igraph_strvector_add() was renamed to _push_back(); _add() was kept as a deprecated alias.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1969#issuecomment-1063343202,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Can you please add this to the top?
#include ""internal/hacks.h"" /* strdup */

I don't want to change this file and create more conflicts.
strdump is not in C99 and we have a replacement for it, but the relevant header is not included in all files that use this function.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1969#issuecomment-1063833215,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","This is just a reminder that you can use strdup to duplicate strings instead of having to manually strlen, IGRAPH_CALLOC, strcpy. Remember to check the return value of strdup, though. Some of the existing code can be simplified with this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/1969#issuecomment-1063879074,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Many of the standard library (or POSIX) string handling functions come in two variants: one assumes null-terminated strings, the other takes the string length explicitly (but still handles early null terminators). Compare strcpy vs strncpy or strchr vs memchr.
Some of the parser code could be simplified and also made more efficient if we had the same thing for adding new entries to strvectors. Now we have add/push_back which assume a null-terminator. It would be nice to add a second version which takes the string length instead.
The flex interface uses pointer + length pairs instead of null-terminated strings because it effectively works with one long stream of characters (file contents) of which it needs to take subsets. In order to use null-terminated strings, it would have to make copies of parts of this stream. Instead, it just produces pointers to parts of the stream, along with character counts.
This is just one example where a string gets copied just so that a null terminator can be inserted: https://github.com/igraph/igraph/blob/develop/src/io/pajek-parser.y#L678

BTW there's also strndup(), but it's not in the C99 standard, so if we use it, we will need to provide a replacement for it, just like with strdup(). In practice, all platforms we care about should have it already.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/1969#issuecomment-1065848289,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Some of the code considers that strings might be NULL pointers, but that shouldn't be possible when using the strvector interface, and if it is possible that's a bug that should be fixed. So I'll remove the code that checks for NULL pointer strings.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/1969#issuecomment-1065849023,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end",I believe that some of the attribute handler code might use NULL pointers in strvector. Would have to check to be sure. I am not very familiar with the attribute handler as I don't use it in the Mathematica interface. I don't like the idea of allowing NULL pointers though.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/1969#issuecomment-1065849788,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","One more thought:
There are some cases where NULLs should be tolerated though, notably in igraph_strvector_destroy(). This is so that partially initialized strvectors can be safely freed. However, this should work with no extra effort, as free() is safe to call with a NULL argument.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/1969#issuecomment-1065852016,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","This is just a reminder that you can use strdup to duplicate strings instead of having to manually strlen, IGRAPH_CALLOC, strcpy. Remember to check the return value of strdup, though. Some of the existing code can be simplified with this.

That doesn't do the same as a REALLOC though. A strdup will always try to allocate memory, but with a realloc you might place the string at the same location.
I think we just need a little helper function which tries the realloc. -edit: that's just what set and set2 are.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/1969#issuecomment-1065852606,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Yes, you're right. Don't replace realloc. But it can be used for push_back?",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/GroteGnoom,13,https://github.com/igraph/igraph/pull/1969#issuecomment-1065893861,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","igraph_strvector_permdelete is a public function which says it's for internal use, but it's not actually used internally. What should we do with it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1969#issuecomment-1065959538,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end",Remove it if it is not used anywhere.,True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1969#issuecomment-1067319076,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","One more thing: since we now have reserve and capacity, we should probably have a resize_min as well.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/1969#issuecomment-1067629636,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Can you explain in the docs of _resize() and _init() that new elements are """"? I found code that does not assume that this is the case. It'll be easier to update these if the docs are very clear.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1969#issuecomment-1067744243,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Regarding commit remove superflulous allocations in append, this function is no longer correct. We need to clean up the vector in case of errors: free so-far allocated pieces and ensure that the original size is retained. Otherwise, the size has to be adjusted.
This optimization wasn't very important though. I am quite eager to have this merged soon, and we can make non-essential improvements later.
@ntamas What do you think about the naming of the set/set2 and push_back/push_back2 functions? This should be decided before merging, as it might require updating some of the function usages. I don't have special preferences here.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/1969#issuecomment-1069400908,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end",I like set_len and push_back_len better because push_back2 is pretty unclear about what the 2 means. I'll review this PR now and try to get the last bits sorted out.,True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/1969#issuecomment-1069425841,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Make sure that if an error occurs, the strvector stays consistent, and does not change its size or contents. This means that some of the changes will need to be undone. You might need to use ENTER/EXIT if there's a chance that IGRAPH_ERROR was called when the failure occurred.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/1969#issuecomment-1069676164,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Should igraph_strvector_get return a char * or const char *? Are we supposed to directly modify the strings in the vector? I don't think igraph does this at the moment. It's just a thought I had, no hard preference from my part.
Note that the STR macro returns a const char *.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/1969#issuecomment-1070675202,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","Should igraph_strvector_get return a char * or const char *?

I'll try const char* and see where it leads. It has an avalanche effect throughout the codebase, but so far it seems manageable.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/1969#issuecomment-1070731164,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end",Can you resolve the conflict with develop so that CI runs can resume?,True,{}
igraph/igraph,https://github.com/igraph/igraph,1969,2022-02-19T12:30:33Z,2022-03-17T16:21:05Z,2022-03-17T18:22:00Z,MERGED,True,798,577,31,https://github.com/GroteGnoom,Make strvector more like a vector,43,[],https://github.com/igraph/igraph/pull/1969,https://github.com/szhorvat,23,https://github.com/igraph/igraph/pull/1969#issuecomment-1070889029,"Trying to fix #1965
The first commit just changes the struct without doing anything useful. But the ability to have a storage size different from the size can later be used to have less allocations.
Todo:

check thoroughly (fix codecov warnings so you know changes are at least covered by tests (no, all codecov warnings are about allocation failures))
add reserve function and let stor_end be different from end","I looked through it, added a few minor touches and resize_min(). I wanted resize_min() because push_back() will now increase the capacity exponentially.
I still strongly dislike the idea of hiding out-of-bounds errors. I laid out my arguments above. However, I also want to move forward with this PR ASAP. Therefore I ask you to just make your decision, and merge without waiting for further input from me.
Next steps are:

Wait two days to see how it fares on OSS-fuzz
Eliminate all uses of deprecated functions (if any)
Refactor some of the graph reader code to make use of the new capabilities (reserve/capacity/resize_min)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/1972,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1972#issuecomment-1046794601,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","Codecov Report

Merging #1972 (3b98869) into develop (e392aae) will increase coverage by 0.02%.
The diff coverage is 76.27%.


@@             Coverage Diff             @@
##           develop    #1972      +/-   ##
===========================================
+ Coverage    75.65%   75.67%   +0.02%     
===========================================
  Files          349      349              
  Lines        57530    57523       -7     
===========================================
+ Hits         43524    43531       +7     
+ Misses       14006    13992      -14     



Impacted Files
Coverage Δ





src/core/trie.c
91.07% <50.00%> (ø)



src/core/error.c
71.56% <62.06%> (-4.34%)
⬇️


src/graph/type_indexededgelist.c
95.84% <100.00%> (+2.78%)
⬆️


src/hrg/hrg.cc
63.02% <100.00%> (+0.77%)
⬆️


src/graph/cattributes.c
68.20% <0.00%> (+0.04%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update e392aae...3b98869. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/vtraag,3,https://github.com/igraph/igraph/pull/1972#issuecomment-1047273377,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","The implementation looks good to me @szhorvat, I don't have any immediate remarks about that. The strange role of the all entry in igraph_i_protectedPtr is probably good to revise anyway.
The logic in dealing with this construction seems less obvious directly. That is, it seems quite contorted how to use this construction in practice, as it is implemented now in type_indexededgelist.c. The CHECK_ERR you implemented in type_indexededgelist.c now essentially performs a type of catch operation, catching the error and performing the restoration of the graph internals, before rethrowing the exception again through IGRAPH_ERROR. Could we perhaps make it work so that this becomes more clear? I don't immediately have a better idea, I'll have to think about.
You mention that the error handling in igraph is based on some of the ideas in https://ldeniau.web.cern.ch/ldeniau/html/oopc/oopc.html#Exceptions, but this is much more involved it seems (although a finally statement seems to be missing, ironically). Have you looked at this in more detail, and what are your thoughts?


If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.


This is probably a good idea anyway, wouldn't it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/1972#issuecomment-1047828399,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","You mention that the error handling in igraph is based on some of the ideas in https://ldeniau.web.cern.ch/ldeniau/html/oopc/oopc.html#Exceptions, but this is much more involved it seems (although a finally statement seems to be missing, ironically). Have you looked at this in more detail, and what are your thoughts?

I have not looked in details, as I realized that that system is quite different. I think it uses a separate stack for each try location, and uses longjmp for control flow. It's a full-blown exception mechanism. We may want to try to do something like that, or even borrow the whole system, but that's a huge change. This PR attempts a minimal fix.

The logic in dealing with this construction seems less obvious directly. That is, it seems quite contorted how to use this construction in practice, as it is implemented now in type_indexededgelist.c. The CHECK_ERR you implemented in type_indexededgelist.c now essentially performs a type of catch operation, catching the error and performing the restoration of the graph internals, before rethrowing the exception again through IGRAPH_ERROR. Could we perhaps make it work so that this becomes more clear? I don't immediately have a better idea, I'll have to think about.

It would be nice to wrap this up into a more structured construct that has a ""try"" and a ""catch/cleanup"" section. The problem is that the cleanup code tends to change as we progress through the block. For example, see the difference between these two cleanup blocks:
https://github.com/igraph/igraph/blob/develop/src/core/trie.c#L309
https://github.com/igraph/igraph/blob/develop/src/core/trie.c#L314
Thus sometimes we can't use a single piece of cleanup code throughout.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/1972#issuecomment-1047832224,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","Let's see if Tamás has any ideas when he's back from holidays. For now, I'm refraining from directly pinging him.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/1972#issuecomment-1047838715,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","BTW we already have an OSS-fuzz issue which I believe is related to the trie code I mentioned: https://oss-fuzz.com/testcase-detail/5699537782571008  It can be fixed by this, and the symptom would be eliminated by #1969, I believe.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/1972#issuecomment-1047845654,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","It would be nice to wrap this up into a more structured construct that has a ""try"" and a ""catch/cleanup"" section. The problem is that the cleanup code tends to change as we progress through the block.

Yes, this would be nicer, although I'm not sure how this could best be implemented without creating too many problems. Of course if there is different cleanup code, then we can just have different try/catch sections. This should in itself not really be problematic, should it?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/1972#issuecomment-1047858798,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","Just thinking out loud here: Instead of having a macro that returns directly, could we perhaps set it up as follows:
IGRAPH_FINALLY_ENTER()
igraph_error_t err = IGRAPH_SUCCESS;
do
{
    CHECK_ERR(x);
}
while(0)
if (err != IGRAPH_SUCCESS)
{
    // Handle specific problems
    ...

   IGRAPH_FINALLY_EXIT();
   IGRAPH_ERROR(""Propagate error up"", err);
}
IGRAPH_FINALLY_EXIT()
where then
#define CHECK_ERR(expr) \
      err = (expr); \
      if (err != IGRAPH_SUCCESS) { \
           break; \
      } 

We could then create macros that facilitate this workflow, e.g. create a CATCH macro as
#define CATCH(x)
if (err != IGRAPH_SUCCESS) \
{ \
    x \
 \
   IGRAPH_FINALLY_EXIT(); \
   IGRAPH_ERROR(""Propagate error up"", err); \
}
Perhaps we could similarly make a TRY macro that facilitates this, so that we could somehow end up writing
IGRAPH_TRY_BEGIN();
  x
IGRAPH_TRY_END();
CATCH(
  y
)",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/1972#issuecomment-1053660310,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","Let's see if Tamás has any ideas when he's back from holidays. For now, I'm refraining from directly pinging him.

Now that I've taken a look at it, it might be worth looking at how Python's Py_BEGIN_ALLOW_THREADS and Py_END_ALLOW_THREADS macro works. These macros are meant to be used in pairs, just like IGRAPH_FINALLY_ENTER and IGRAPH_FINALLY_EXIT (at least I cannot imagine why we would want to break these up in separate functions). Python's Py_BEGIN_ALLOW_THREADS macro opens a new block implicitly, and Py_END_ALLOW_THREADS closes the block, so the user is absolutely forced to use them in pairs (otherwise the code wouldn't compile). This is a neat trick that we might want to borrow. Note that this implies that handling and re-throwing an error code has to be moved out of the IGRAPH_FINALLY_ENTER .. IGRAPH_FINALLY_EXIT block; I consider this as an advantage because then you won't have multiple _EXIT calls for a single _ENTER.
I'm not really fond of trying to conjure up a try..catch syntax-alike in C with macros, though. Let's go ahead with this proposal first and see what sort of patterns emerge; after that we can still re-visit the question of adding more macros if that can potentially make the code clearer.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/1972#issuecomment-1053675822,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","I'd probably also move this code snippet:
igraph_i_finally_stack_size = 0;
igraph_i_finally_stack_level = 0;

to a separate igraph_i_reset_finally_stack() function as it is now being repeated many times.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/1972#issuecomment-1054234585,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","OK, so it looks like both of you are happy with how it works internally at the moment (division into levels)?
Then we only need to figure out how to make the interface nice and wrap it up into some convenient macros. Do I understand that something like what @vtraag proposed would work for you @ntamas? It should make it possible to achieve having a ""begin"" and an ""end"" macro, with no explicit exit point in the middle (other than break).
I'll try to get that done when I have time again, maybe next week.
If one of you wants to take this over in the meantime, feel free to do so. Just let me know so we don't duplicate the effort.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/1972#issuecomment-1054427608,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","OK, so it looks like both of you are happy with how it works internally at the moment (division into levels)?

Yes, that's fine for me. The only case where it can potentially break down if the callbacks from a third-party lib or parser are called on a different thread, but that has not been the case so far so I'm totally fine with the current solution.

Do I understand that something like what @vtraag proposed would work for you @ntamas?

I am satisfied with the current ENTER and EXIT macros and don't feel the need yet for anything more complex (try / catch stuff), but if you can come up with a proposal, I'm happy to take a look at it. Otherwise I'd just go with ENTER and EXIT and see how far it takes us and what patterns emerge in the long term.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/1972#issuecomment-1054495018,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","These are not macros in the current implementation, just functions. The plan was to first use these raw functions, then see what programming patterns we end up with, then finally try to wrap these patterns up into more structured-looking macros.
The problem is that I do not see how one can avoid EXITing in the middle when an error occurs. Exiting in the middle in some way is necessary for error handling. How the exit works is the question. It can be a direct call to EXIT followed by a return or some jump instruction to the part of the code that does the cleanup (a goto, a break in  do, some if/else or whatever—but these are hard to make flexible). If we don't want to exit in the middle at all, then we need to wrap every potentially failing function call into an ENTER/EXIT pair. Doing that conflicts with not repeating the cleanup code many times.
So the challenge is: how do we minimize the number of times the cleanup code has to be stated?  How do we deal with the size of the cleanup code ""growing"" as the algorithm proceeds through the block?
Luckily, the need for this ENTER/EXIT construct is very rare, so it IMO the solution does not have to be perfect. If it's a bit verbose that's okay.  In fact, personally I'd be even happy with just using the raw calls.  In the end, I just want a solution to fix #1970 and related issues, but I'm not fussy about how it is done.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/ntamas,14,https://github.com/igraph/igraph/pull/1972#issuecomment-1054559538,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","Okay, I can let go of the requirement that ENTER and EXIT are always used in pairs, in which case you can use EXIT wherever you want. Which basically takes us back to the present state of the PR, right?",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/1972#issuecomment-1059834557,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","In the end I did not create convenient wrapper macros. I would very much like to see this done, but I can't come up with anything I am happy with, and I don't want to spend more time on it. I also didn't touch the GraphML code since it seems to be working fine as it is, though in the future it might be refactored a bit to use this functionality.
If you'd like to, feel free to polish this, otherwise please just merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/1972#issuecomment-1060418439,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,1972,2022-02-21T11:46:58Z,2022-03-07T10:06:50Z,2022-03-15T21:12:13Z,MERGED,True,152,87,8,https://github.com/szhorvat,Multi-level error handling,8,[],https://github.com/igraph/igraph/pull/1972,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/1972#issuecomment-1060460838,"This is an attempt at fixing #1970
The idea is that the finally stack is now structured into separate levels:
8   ...           LEVEL 2 (CURRENT LEVEL)
7   ...
------------
6   ...
5   ...           LEVEL 1
4   ...
------------
3   ...
2   ...           LEVEL 0
1   destr2()
0   destr1()

When IGRAPH_FINALLY_FREE() is called by the error handler*, then destructors are executed only from the topmost level. This ensures that we have a chance to still work with data structures that are present at lower levels in the stack.
This is useful not only for #1970, but also for cases when using a library that operates with callback functions. This applies to almost every graph reader (Bison based parsers do effectively this) as well as some other functions.  We might need to set up a data structure for the library to work with, then call the library, which then calls back to a function provided by us. If a failure occurs in this function, it should be result in destroying the data that the library works with. That should be deferred until the library has fully returned. This can be ensured by ""entering"" a new finally stack level before calling the library.
Entering/exiting a level is done with IGRAPH_FINALLY_ENTER()/EXIT(). See the changes to igraph_add_edges() in this PR to see the typical programming patterns this leads to. We may want to wrap it up into a simpler-to-use macro, but I'm not sure it's actually worth it.

TODO

 Agree on and finalize design
 Use it in igraph_trie_get() (which sets special error handlers)
 Use it in GraphML reader (which sets special error handlers for a similar purpose)
 Use it in Bison-based graph readers, where the current error handling relies on Bison (not) allocating memory in a certain way


Footnotes:
* If we go with a solution like this, we might as well make calling IGRAPH_FINALLY_FREE() mandatory and do it in igraph_error() instead of leaving it to the error handler.","So once again, if someone can make this prettier, i.e. come up with a macro-based syntax that is less error-prone, that would be really great ...",True,{}
igraph/igraph,https://github.com/igraph/igraph,1974,2022-02-23T15:09:36Z,2022-02-25T08:01:22Z,2022-02-25T16:06:24Z,MERGED,True,78,1,5,https://github.com/vtraag,Fix initial modularity for walktrap,2,[],https://github.com/igraph/igraph/pull/1974,https://github.com/vtraag,1,https://github.com/igraph/igraph/pull/1974,"Walktrap maintains a list of modularity along each step of its merging of various communities. The initial modularity was always incorrectly set to 0, instead of the modularity of the singleton partition. Walktrap returns the actual membership that contains the maximum modularity.
The actual partition that was identified in walktrap in #1927 is the partition that puts the whole graph into a single cluster, which has a modularity of 0. However, because the initial modularity before any merge was incorrectly set to 0, it incorrectly returned the singleton partition instead. This PR fixes #1927.","Walktrap maintains a list of modularity along each step of its merging of various communities. The initial modularity was always incorrectly set to 0, instead of the modularity of the singleton partition. Walktrap returns the actual membership that contains the maximum modularity.
The actual partition that was identified in walktrap in #1927 is the partition that puts the whole graph into a single cluster, which has a modularity of 0. However, because the initial modularity before any merge was incorrectly set to 0, it incorrectly returned the singleton partition instead. This PR fixes #1927.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1974,2022-02-23T15:09:36Z,2022-02-25T08:01:22Z,2022-02-25T16:06:24Z,MERGED,True,78,1,5,https://github.com/vtraag,Fix initial modularity for walktrap,2,[],https://github.com/igraph/igraph/pull/1974,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/1974#issuecomment-1048888302,"Walktrap maintains a list of modularity along each step of its merging of various communities. The initial modularity was always incorrectly set to 0, instead of the modularity of the singleton partition. Walktrap returns the actual membership that contains the maximum modularity.
The actual partition that was identified in walktrap in #1927 is the partition that puts the whole graph into a single cluster, which has a modularity of 0. However, because the initial modularity before any merge was incorrectly set to 0, it incorrectly returned the singleton partition instead. This PR fixes #1927.","Codecov Report

Merging #1974 (1f0ab51) into develop (2620107) will increase coverage by 0.00%.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #1974   +/-   ##
========================================
  Coverage    74.94%   74.94%           
========================================
  Files          347      347           
  Lines        57893    57898    +5     
========================================
+ Hits         43387    43394    +7     
+ Misses       14506    14504    -2     



Impacted Files
Coverage Δ





src/community/walktrap/walktrap_communities.cpp
62.08% <100.00%> (+0.35%)
⬆️


src/community/walktrap/walktrap.cpp
91.30% <0.00%> (+8.69%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 2620107...1f0ab51. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1974,2022-02-23T15:09:36Z,2022-02-25T08:01:22Z,2022-02-25T16:06:24Z,MERGED,True,78,1,5,https://github.com/vtraag,Fix initial modularity for walktrap,2,[],https://github.com/igraph/igraph/pull/1974,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1974#issuecomment-1049070851,"Walktrap maintains a list of modularity along each step of its merging of various communities. The initial modularity was always incorrectly set to 0, instead of the modularity of the singleton partition. Walktrap returns the actual membership that contains the maximum modularity.
The actual partition that was identified in walktrap in #1927 is the partition that puts the whole graph into a single cluster, which has a modularity of 0. However, because the initial modularity before any merge was incorrectly set to 0, it incorrectly returned the singleton partition instead. This PR fixes #1927.","My only comment is that it would be nice to backport this to 0.9 as well so it can go into the 1.3 R release... but if you think it's not important, just skip it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1974,2022-02-23T15:09:36Z,2022-02-25T08:01:22Z,2022-02-25T16:06:24Z,MERGED,True,78,1,5,https://github.com/vtraag,Fix initial modularity for walktrap,2,[],https://github.com/igraph/igraph/pull/1974,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/1974#issuecomment-1049072600,"Walktrap maintains a list of modularity along each step of its merging of various communities. The initial modularity was always incorrectly set to 0, instead of the modularity of the singleton partition. Walktrap returns the actual membership that contains the maximum modularity.
The actual partition that was identified in walktrap in #1927 is the partition that puts the whole graph into a single cluster, which has a modularity of 0. However, because the initial modularity before any merge was incorrectly set to 0, it incorrectly returned the singleton partition instead. This PR fixes #1927.","Yeah, I agree, I will backport to 0.9.",True,{}
igraph/igraph,https://github.com/igraph/igraph,1996,2022-03-12T16:02:15Z,2022-03-14T14:42:11Z,2022-03-14T14:42:12Z,MERGED,True,107,7,4,https://github.com/GroteGnoom,Add igraph_sample_dirichlet tests,4,[],https://github.com/igraph/igraph/pull/1996,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/1996,Part of #1592,Part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,1996,2022-03-12T16:02:15Z,2022-03-14T14:42:11Z,2022-03-14T14:42:12Z,MERGED,True,107,7,4,https://github.com/GroteGnoom,Add igraph_sample_dirichlet tests,4,[],https://github.com/igraph/igraph/pull/1996,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/1996#issuecomment-1065912242,Part of #1592,"If this helps, one of the invariants is that the total of the result vector is in [0, 1].",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1996,2022-03-12T16:02:15Z,2022-03-14T14:42:11Z,2022-03-14T14:42:12Z,MERGED,True,107,7,4,https://github.com/GroteGnoom,Add igraph_sample_dirichlet tests,4,[],https://github.com/igraph/igraph/pull/1996,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/1996#issuecomment-1065914795,Part of #1592,"This function returns the result a bit differently than I expected.

The result vectors must be the same length as the alpha vector
The sum of each vector must be 1.
The vector elements are in (0,1)
n vectors are returned as the columns of a matrix",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,1996,2022-03-12T16:02:15Z,2022-03-14T14:42:11Z,2022-03-14T14:42:12Z,MERGED,True,107,7,4,https://github.com/GroteGnoom,Add igraph_sample_dirichlet tests,4,[],https://github.com/igraph/igraph/pull/1996,https://github.com/apps/codecov,4,https://github.com/igraph/igraph/pull/1996#issuecomment-1066787943,Part of #1592,"Codecov Report

Merging #1996 (5208118) into develop (f88ff4e) will increase coverage by 0.10%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #1996      +/-   ##
===========================================
+ Coverage    75.66%   75.77%   +0.10%     
===========================================
  Files          349      350       +1     
  Lines        57560    57395     -165     
===========================================
- Hits         43555    43490      -65     
+ Misses       14005    13905     -100     



Impacted Files
Coverage Δ





src/games/dotproduct.c
18.91% <100.00%> (+18.91%)
⬆️


src/community/infomap/infomap.cc
95.38% <0.00%> (-1.94%)
⬇️


src/community/walktrap/walktrap_graph.cpp
75.70% <0.00%> (-0.94%)
⬇️


src/graph/type_indexededgelist.c
95.16% <0.00%> (-0.68%)
⬇️


src/community/infomap/infomap_FlowGraph.cc
97.42% <0.00%> (-0.23%)
⬇️


src/core/sparsemat.c
81.82% <0.00%> (-0.02%)
⬇️


src/properties/triangles.c
91.10% <0.00%> (ø)



src/community/infomap/infomap_Node.cc




src/community/infomap/infomap_FlowGraph.h
100.00% <0.00%> (ø)



src/community/infomap/infomap_Node.h
100.00% <0.00%> (ø)



... and 4 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update f88ff4e...5208118. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2001,2022-03-14T16:03:11Z,2022-03-27T18:14:37Z,2022-03-27T18:14:37Z,MERGED,True,131,14,4,https://github.com/GroteGnoom,Add layout_gem tests,2,[],https://github.com/igraph/igraph/pull/2001,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2001,part of #1592,part of #1592,True,{}
igraph/igraph,https://github.com/igraph/igraph,2001,2022-03-14T16:03:11Z,2022-03-27T18:14:37Z,2022-03-27T18:14:37Z,MERGED,True,131,14,4,https://github.com/GroteGnoom,Add layout_gem tests,2,[],https://github.com/igraph/igraph/pull/2001,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2001#issuecomment-1067024893,part of #1592,"Codecov Report

Merging #2001 (953c018) into develop (7311a63) will increase coverage by 0.15%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #2001      +/-   ##
===========================================
+ Coverage    75.77%   75.93%   +0.15%     
===========================================
  Files          350      350              
  Lines        57395    57389       -6     
===========================================
+ Hits         43490    43576      +86     
+ Misses       13905    13813      -92     



Impacted Files
Coverage Δ





src/layout/gem.c
79.13% <100.00%> (+79.13%)
⬆️


src/core/matrix.pmt
84.37% <0.00%> (-0.07%)
⬇️


src/cliques/cliquer_wrapper.c
85.27% <0.00%> (ø)



src/core/vector.pmt
87.81% <0.00%> (+0.13%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 7311a63...953c018. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2001,2022-03-14T16:03:11Z,2022-03-27T18:14:37Z,2022-03-27T18:14:37Z,MERGED,True,131,14,4,https://github.com/GroteGnoom,Add layout_gem tests,2,[],https://github.com/igraph/igraph/pull/2001,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2001#issuecomment-1079955038,part of #1592,Is this ready for review?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2001,2022-03-14T16:03:11Z,2022-03-27T18:14:37Z,2022-03-27T18:14:37Z,MERGED,True,131,14,4,https://github.com/GroteGnoom,Add layout_gem tests,2,[],https://github.com/igraph/igraph/pull/2001,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/2001#issuecomment-1079963147,part of #1592,"Yes, I test almost no functionality, but that's hard to fix for a layout algorithm.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2006,2022-03-19T22:41:19Z,2022-03-20T07:32:55Z,2022-03-20T07:33:13Z,CLOSED,False,2,1,1,https://github.com/szhorvat,ci: fix msvc analyzer,1,[],https://github.com/igraph/igraph/pull/2006,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2006,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,2006,2022-03-19T22:41:19Z,2022-03-20T07:32:55Z,2022-03-20T07:33:13Z,CLOSED,False,2,1,1,https://github.com/szhorvat,ci: fix msvc analyzer,1,[],https://github.com/igraph/igraph/pull/2006,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2006#issuecomment-1073123803,,"Codecov Report

Merging #2006 (23098da) into master (189b6f9) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff           @@
##           master    #2006   +/-   ##
=======================================
  Coverage   72.53%   72.53%           
=======================================
  Files         295      295           
  Lines       57631    57631           
=======================================
  Hits        41803    41803           
  Misses      15828    15828           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 189b6f9...23098da. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2007,2022-03-19T22:56:37Z,2022-03-20T07:32:48Z,2022-03-20T07:32:48Z,CLOSED,False,10,6,1,https://github.com/szhorvat,"ci: fix msvc analyzer, restrict to develop, exclude paths",2,[],https://github.com/igraph/igraph/pull/2007,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2007,,,True,{}
igraph/igraph,https://github.com/igraph/igraph,2007,2022-03-19T22:56:37Z,2022-03-20T07:32:48Z,2022-03-20T07:32:48Z,CLOSED,False,10,6,1,https://github.com/szhorvat,"ci: fix msvc analyzer, restrict to develop, exclude paths",2,[],https://github.com/igraph/igraph/pull/2007,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2007#issuecomment-1073126350,,"Codecov Report

Merging #2007 (64ba424) into develop (5381ca7) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff            @@
##           develop    #2007   +/-   ##
========================================
  Coverage    75.78%   75.78%           
========================================
  Files          350      350           
  Lines        57486    57486           
========================================
  Hits         43567    43567           
  Misses       13919    13919           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 5381ca7...64ba424. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2010,2022-03-21T18:02:02Z,2022-03-21T21:19:21Z,2022-03-21T21:19:21Z,MERGED,True,183,82,9,https://github.com/szhorvat,strvector_merge(),4,[],https://github.com/igraph/igraph/pull/2010,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2010,"Let's agree on a design through this strvector example, then I will add an analogous function for vector_list. EDIT: Actually, vector_list doesn't even have append, so I will leave adding these for a separate PR.","Let's agree on a design through this strvector example, then I will add an analogous function for vector_list. EDIT: Actually, vector_list doesn't even have append, so I will leave adding these for a separate PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2010,2022-03-21T18:02:02Z,2022-03-21T21:19:21Z,2022-03-21T21:19:21Z,MERGED,True,183,82,9,https://github.com/szhorvat,strvector_merge(),4,[],https://github.com/igraph/igraph/pull/2010,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2010#issuecomment-1074241746,"Let's agree on a design through this strvector example, then I will add an analogous function for vector_list. EDIT: Actually, vector_list doesn't even have append, so I will leave adding these for a separate PR.","Codecov Report

Merging #2010 (b1c7926) into develop (acf94fe) will increase coverage by 0.00%.
The diff coverage is 88.88%.


@@           Coverage Diff            @@
##           develop    #2010   +/-   ##
========================================
  Coverage    75.99%   75.99%           
========================================
  Files          350      350           
  Lines        57496    57509   +13     
========================================
+ Hits         43694    43705   +11     
- Misses       13802    13804    +2     



Impacted Files
Coverage Δ





src/core/strvector.c
80.10% <85.71%> (+0.21%)
⬆️


src/core/hashtable.c
100.00% <100.00%> (ø)



src/graph/cattributes.c
73.62% <100.00%> (ø)



src/core/vector.pmt
88.00% <0.00%> (+0.01%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update acf94fe...b1c7926. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2010,2022-03-21T18:02:02Z,2022-03-21T21:19:21Z,2022-03-21T21:19:21Z,MERGED,True,183,82,9,https://github.com/szhorvat,strvector_merge(),4,[],https://github.com/igraph/igraph/pull/2010,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2010#issuecomment-1074278614,"Let's agree on a design through this strvector example, then I will add an analogous function for vector_list. EDIT: Actually, vector_list doesn't even have append, so I will leave adding these for a separate PR.",There is an extra commit to rename strvector_copy() to strvector_init_copy() for consistency with vector_init_copy() and to make it clear that it is a constructor.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2012,2022-03-22T21:23:24Z,2022-03-23T10:08:58Z,2022-03-23T10:50:01Z,MERGED,True,76,41,3,https://github.com/szhorvat,Fix up igraph_diversity(),4,[],https://github.com/igraph/igraph/pull/2012,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2012,"fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.","fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2012,2022-03-22T21:23:24Z,2022-03-23T10:08:58Z,2022-03-23T10:50:01Z,MERGED,True,76,41,3,https://github.com/szhorvat,Fix up igraph_diversity(),4,[],https://github.com/igraph/igraph/pull/2012,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2012#issuecomment-1075662425,"fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.","Codecov Report

Merging #2012 (cd8e5c4) into master (189b6f9) will increase coverage by 0.02%.
The diff coverage is 93.10%.


@@            Coverage Diff             @@
##           master    #2012      +/-   ##
==========================================
+ Coverage   72.53%   72.56%   +0.02%     
==========================================
  Files         295      295              
  Lines       57631    57632       +1     
==========================================
+ Hits        41803    41818      +15     
+ Misses      15828    15814      -14     



Impacted Files
Coverage Δ





src/properties/basic_properties.c
89.10% <93.10%> (+14.10%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 189b6f9...cd8e5c4. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2012,2022-03-22T21:23:24Z,2022-03-23T10:08:58Z,2022-03-23T10:50:01Z,MERGED,True,76,41,3,https://github.com/szhorvat,Fix up igraph_diversity(),4,[],https://github.com/igraph/igraph/pull/2012,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2012#issuecomment-1075680665,"fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.","As recommended by @vtraag in chat, I eliminated the separate branch for the igraph_vss_all() case. There should be no performance difference when compiled with LTO. This version reserves the appropriate amount of memory for res.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,2012,2022-03-22T21:23:24Z,2022-03-23T10:08:58Z,2022-03-23T10:50:01Z,MERGED,True,76,41,3,https://github.com/szhorvat,Fix up igraph_diversity(),4,[],https://github.com/igraph/igraph/pull/2012,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/2012#issuecomment-1076183526,"fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.",Thanks a lot!,True,{}
igraph/igraph,https://github.com/igraph/igraph,2012,2022-03-22T21:23:24Z,2022-03-23T10:08:58Z,2022-03-23T10:50:01Z,MERGED,True,76,41,3,https://github.com/szhorvat,Fix up igraph_diversity(),4,[],https://github.com/igraph/igraph/pull/2012,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/2012#issuecomment-1076186473,"fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.","Porting this to the develop branch now, FYI.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2012,2022-03-22T21:23:24Z,2022-03-23T10:08:58Z,2022-03-23T10:50:01Z,MERGED,True,76,41,3,https://github.com/szhorvat,Fix up igraph_diversity(),4,[],https://github.com/igraph/igraph/pull/2012,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2012#issuecomment-1076223286,"fix: fix up igraph_diversity()

Simplify code and avoid duplication
Check that weights are non-negative and non-NaN
Now return 0 for degree-1 vertices


First, a recap on the definition of ""diversity"" (not a particularly popular measure).
Take a vertex and all its incident edges. Divide the edge weights by the vertex strengths to obtain ""probabilities"" (values that sum to the vertex). The compute the Shannon entropy of these values, S = - \sum_i p_i log p_i. Finally, normalize it by the maximum value, which is log k for k values.

This is partly triggered by the tidygraph test suite failure with diversity(). The reason for the failure is that now igraph_diversity() accepts only undirected graphs. This decision was correct in my opinion. Arguably, the definition used by the function only makes sense for undirected graphs. For directed ones, one might choose to take only out-edges or similar. However, I don't want igraph to take the lead on generalizing very niche graph measures, and the cited paper only deals with the undirected case (as I recall).
The test case used by tidygraph is a k-ary tree, effectively: diversity(make_tree(10,2), weights=1:9). This triggers an error as this is a directed graph. But let's make it undirected and see what we get:
> diversity(make_tree(10,2,mode='undirected'), weights=1:9)
 [1] 0.9182958 0.8868595 0.9214632 0.9342064 0.8904916       NaN      -Inf       NaN
 [9]       NaN       NaN

Notice that the tree leaves (degree-1 vertices) get a NaN value, except for one, which gets -Inf. This is inconsistent, they should all be the same. This is likely the result of numerical roundoff.
This PR makes it so that degree-1 vertices always get a value of 0. This is the Shannon entropy when there is only one probability value (necessarily p=1). The normalized version would be 0/0 = NaN, but I think it makes sense to keep zeros as zero, even after using some sort of normalization.
Additionally, it now returns an explicit IGRAPH_NAN for isolated vertices instead of letting the NaN value arise as the result of calculations.
The function now checks that the weights are non-negative, which is necessary to take their logarithm. I opted to allow zero weights, and use 0*log(0) = 0, which is standard for entropy calculations.
Finally, the code has been refactored to avoid duplication.
Since some of these decisions may be controversial, here's a PR.  It should go in master and be part of R/igraph 1.3.0.","Actually, I think the check for NaN weights was not strictly necessary. We need to do that for betweenness because NaN will put the algorithm on the wrong track and risks a crash. But here, if a weight is NaN, it just causes some of the results to be NaN, which does make sense (especially with NA in R).
Anyway, this is not a big deal, let's leave this check as is.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,1,https://github.com/igraph/igraph/pull/2013,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/2013#issuecomment-1076818395,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","I converted this to a draft, which indicates that it is a work in progress, and prevents merging. When it is ready, press the ""ready for review"" button, and someone well review it. Feel free to ask questions while you're working on this.",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/2013#issuecomment-1077304924,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Codecov Report

Merging #2013 (b48c165) into develop (0d91fb4) will increase coverage by 0.82%.
The diff coverage is 82.49%.


@@             Coverage Diff             @@
##           develop    #2013      +/-   ##
===========================================
+ Coverage    76.74%   77.57%   +0.82%     
===========================================
  Files          362      362              
  Lines        58394    58811     +417     
===========================================
+ Hits         44817    45622     +805     
+ Misses       13577    13189     -388     



Impacted Files
Coverage Δ





src/community/louvain.c
96.18% <0.00%> (ø)



src/core/error.c
72.11% <ø> (ø)



src/internal/glpk_support.c
54.34% <ø> (ø)



src/internal/lsap.c
71.20% <ø> (ø)



src/io/gml-lexer.l
75.00% <ø> (+8.33%)
⬆️


src/io/graphml.c
82.31% <ø> (ø)



src/isomorphism/bliss/graph.cc
72.06% <ø> (-0.02%)
⬇️


src/layout/fruchterman_reingold.c
48.09% <ø> (ø)



src/misc/feedback_arc_set.c
86.53% <0.00%> (ø)



src/misc/scan.c
54.40% <ø> (ø)



... and 64 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update aba150f...b48c165. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,4,https://github.com/igraph/igraph/pull/2013#issuecomment-1077585355,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).",Hi. I have added missing test cases for Misses indicated by Codecov Report.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2013#issuecomment-1077664719,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","FYI — if you see the ""422 - test::glpk_error (SEGFAULT)"" test failure with MinGW, it's not because of the changes you made. That's an unrelated intermittent issue, #1850. I'll re-run that test now, which should get rid of the red x.",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/2013#issuecomment-1078747856,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hi @meetpatel0963, thanks for contributing this!
I just want to double check with @szhorvat about the idea of the implementation. We currently have igraph_random_edge_walk and igraph_random_walk, and the only difference is whether they return the path in terms of edges or in terms of vertices. In igraph_get_shortest_path we integrate that into a single function, which can return both the vertices and the edges in a single function. To me, this makes more sense. For that reason, I would therefore propose to just create a single new function igraph_random_walk for 0.10 (breaking API) with the signature:
igraph_error_t igraph_random_edge_walk(const igraph_t *graph,
                            const igraph_vector_t *weights,
                            igraph_vector_int_t *vertices,
                            igraph_vector_int_t *edges,
                            igraph_integer_t start,
                            igraph_neimode_t mode,
                            igraph_integer_t steps,
                            igraph_random_walk_stuck_t stuck)
where vertices contains the vertices in the random walk and edges contains the edges in the random walk, similar to how we approach this for igraph_get_shortest_path. This avoids a lot of code duplication between the two. The current code of igraph_random_edge_walk could well serve as the basis then, where it essentially is just a matter of pushing each start vertex into a vector at each step.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/2013#issuecomment-1078754527,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Having such an API makes sense, but I don't want to remove the current vertex walk implementation. The adjlist-based version is clearly faster than the inclist-based one, so we should keep this special case, and use it when the user only requests vertices and no weights are present (very common use case).
Thus, I would propose the same API that you suggest above (though I would prefer to call it igraph_random_walk() and to just deprecate igraph_random_edge_walk()). This would be backed by two internal functions: one using adjlist (used when only vertices are requested and there are no weights) and one using inclist (used in all other cases). We already have these two, it's just a question of a minor restructuring.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/2013#issuecomment-1078760457,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Thus, I would propose the same API that you suggest above (though I would prefer to call it igraph_random_walk() and to just deprecate igraph_random_edge_walk()).

Yes, sorry, I meant to call it igraph_random_walk as well.

The adjlist-based version is clearly faster than the inclist-based one, so we should keep this special case, and use it when the user only requests vertices and no weights are present (very common use case).

Yes, right, sorry, I didn't realise that the igraph_random_edge_walk always uses an inclist.
So, all in all, we then come to the proposal that we have two internal functions
igraph_error_t igraph_i_random_walk_adjlist(const igraph_t *graph,
                            igraph_vector_int_t *vertices,
                            igraph_integer_t start,
                            igraph_neimode_t mode,
                            igraph_integer_t steps,
                            igraph_random_walk_stuck_t stuck)
and
igraph_error_t igraph_i_random_walk_inclist(const igraph_t *graph,
                            const igraph_vector_t *weights,
                            igraph_vector_int_t *vertices,
                            igraph_vector_int_t *edges,
                            igraph_integer_t start,
                            igraph_neimode_t mode,
                            igraph_integer_t steps,
                            igraph_random_walk_stuck_t stuck)
with a single
igraph_error_t igraph_random_walk(const igraph_t *graph,
                            const igraph_vector_t *weights,
                            igraph_vector_int_t *vertices,
                            igraph_vector_int_t *edges,
                            igraph_integer_t start,
                            igraph_neimode_t mode,
                            igraph_integer_t steps,
                            igraph_random_walk_stuck_t stuck)
which essentially just calls
...
if (edges != NULL || weights != null)
    igraph_i_random_walk_inclist( ... );
else
    igraph_i_random_walk_adjlist( ... );

...
Are we on the same page then?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/2013#issuecomment-1078761345,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Once this work is done, it would be interesting to add a new RESTART value to igraph_random_walk_stuck_t. When the random walk gets stuck, it would restart from a random vertex. This is not particularly useful for real work, but it would be educational, and useful for demonstrating PageRank. While this can be implemented relatively easily using the current capabilities of this function, why not support it directly? Instructors/teachers might appreciate it, and I think we should support them well with igraph.

Yes, interesting idea! Perhaps better if that is done in a separate issue & PR?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2013#issuecomment-1078761531,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Are we on the same page then?

Yes!

(Also, you might have gotten an email about my last comment, which I just deleted, as it was based on a misunderstanding. Please ignore it.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/2013#issuecomment-1078772184,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Great!
@meetpatel0963 , are you comfortable updating the code in the direction described above? If something is unclear about it, do ask. If you are not comfortable making these changes, then just let us know, and we will handle it.",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,12,https://github.com/igraph/igraph/pull/2013#issuecomment-1078909724,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hi @vtraag.

are you comfortable updating the code in the direction described above?

Yes sure, I got the point. It makes sense. I will add the requested changes.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,13,https://github.com/igraph/igraph/pull/2013#issuecomment-1079193309,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hello. In case when both vertex IDs and edge IDs are needed,
size of the vector of vertex IDs will be = (steps + 1) and
size of the vector of edge IDs will be = steps, right?
In this case, we'll consider the steps as the number of edges traversed on the walk and include the vertex IDs of both start and end vertex of the walk in vertices. Is that correct or something else is expected?
Also, according to this:
...
if (edges != NULL || weights != null)
    igraph_i_random_walk_inclist( ... );
else
    igraph_i_random_walk_adjlist( ... );

...
We are assuming that vertices are always needed, right? Or it may happen that we only need edges and not vertices in which case a separate check is required in igraph_i_random_walk_inclist.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,14,https://github.com/igraph/igraph/pull/2013#issuecomment-1079401535,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hello. In case when both vertex IDs and edge IDs are needed, size of the vector of vertex IDs will be = (steps + 1) and size of the vector of edge IDs will be = steps, right?
In this case, we'll consider the steps as the number of edges traversed on the walk and include the vertex IDs of both start and end vertex of the walk in vertices. Is that correct or something else is expected?

Yes, let us do it like this, I think this makes most sense. The current two implementations are now not exactly consistent actually, because igraph_random_walk traverse steps - 1 edges, while igraph_random_edge_walk traverse steps edges. It's good to make this now consistent.

Also, according to this:
...
if (edges != NULL || weights != null)
    igraph_i_random_walk_inclist( ... );
else
    igraph_i_random_walk_adjlist( ... );

...
We are assuming that vertices are always needed, right? Or it may happen that we only need edges and not vertices in which case a separate check is required in igraph_i_random_walk_inclist.

No, the vertex argument is not necessarily needed. If we do a weighted random walk we need to access the edge weight, for which we need an inclist, not an adjlist. But, that doesn't mean that the vertex argument is needed.",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/2013#issuecomment-1079959117,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hit ""ready for review"" again when you're done with everything (it seems it's done?)",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,16,https://github.com/igraph/igraph/pull/2013#issuecomment-1083481197,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Sorry @meetpatel0963, I haven't yet found the time to do a proper review, I should be able to do so later this week.",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,17,https://github.com/igraph/igraph/pull/2013#issuecomment-1084083246,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hi @vtraag, Cool. Not a problem.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/2013#issuecomment-1084468354,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","I vote for deprecating igraph_random_edge_walk() properly first, and then removing it later. The deprecated version can be re-written to call the new random_walk() function with appropriate arguments if that is possible with the current refactoring.",True,"{'THUMBS_UP': ['https://github.com/vtraag', 'https://github.com/meetpatel0963']}"
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,19,https://github.com/igraph/igraph/pull/2013#issuecomment-1084514709,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","I vote for deprecating igraph_random_edge_walk() properly first, and then removing it later

OK, let's do that then.

The deprecated version can be re-written to call the new random_walk() function with appropriate arguments if that is possible with the current refactoring.

Yes, that should be possible.
@meetpatel0963, the comments in the review should provide guidance for doing this. But if some things are unclear, please do let us know.
FYI, the deprecated igraph_random_edge_walk does not need to be separately tested.",True,{'THUMBS_UP': ['https://github.com/meetpatel0963']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,20,https://github.com/igraph/igraph/pull/2013#issuecomment-1085420669,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).",Thank you very much for your comments and suggestions! I've added the requested changes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,21,https://github.com/igraph/igraph/pull/2013#issuecomment-1085747611,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).",Thank you very much for your help and suggestions! I've added the requested changes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/ntamas,22,https://github.com/igraph/igraph/pull/2013#issuecomment-1100748226,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Hmmm, what happened with this PR? Suddenly there are hundreds of files that appear as modified...",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,23,https://github.com/igraph/igraph/pull/2013#issuecomment-1100758233,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Yeah, good question, hadn't seen it previously. Probably something went wrong merging in the develop branch?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/2013#issuecomment-1100759420,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).",I think it's fine now.,True,"{'THUMBS_UP': ['https://github.com/vtraag', 'https://github.com/mp0963']}"
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,25,https://github.com/igraph/igraph/pull/2013#issuecomment-1100759681,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Thanks @szhorvat! GitHub garbled up something then, which is corrected by switching the base branch?",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/vtraag,26,https://github.com/igraph/igraph/pull/2013#issuecomment-1102394983,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Thanks @meetpatel0963! This was a wonderful contribution, we are very pleased with the high-quality code you provided. If you want to contribute something else in the future, that would be more than welcome.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/meetpatel0963,27,https://github.com/igraph/igraph/pull/2013#issuecomment-1107831459,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Thank you for all your help and suggestions @vtraag! Being new to open source, I believe it was a very good start for me. Sure, I would love to work on other tasks soon.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2013,2022-03-23T19:33:17Z,2022-04-19T09:37:07Z,2022-04-25T11:40:33Z,MERGED,True,579,285,10,https://github.com/meetpatel0963,Merge random_edge_walk() into random_walk(),27,[],https://github.com/igraph/igraph/pull/2013,https://github.com/ntamas,28,https://github.com/igraph/igraph/pull/2013#issuecomment-1108462754,"This pull request merges a function igraph_random_edge_walk into igraph_random_walk to support both the vertices and edges in a single function - part of #1882.

It uses igraph_i_random_walk_adjlist for unweighted graphs when only vertices are required.
It uses igraph_i_random_walk_inclist when edges are required and/or vertices are required (with weighted graphs).","Post-PR musings: I started wondering whether we used the term edge walk correctly in the past. In our implementation, we always have an active vertex and a random incident edge is selected; the next active vertex will be the other endpoint of that vertex. This means that it is possible to jump back and forth between the endpoints of that same edge so the ""current"" edge in the edge walk stays the same. However, in my interpretation of a proper edge walk, there is an active edge instead, and the next active edge is selected from the set of edges incident on at least one endpoint of the current edge, except the current edge, so it is not possible to encounter the same edge in two consecutive steps of the random walk. (In other words, the edge walk is a vertex walk on the line graph of the input graph).
This means (if my interpretation is correct) that at some point we need to get rid of igraph_random_edge_walk() in the C core, or transform it into a proper edge walk with the properties mentioned above instead of piggybacking on igraph_random_walk().",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2016,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2016#issuecomment-1079782371,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","Codecov Report

Merging #2016 (5d3a413) into develop (153d00b) will increase coverage by 0.16%.
The diff coverage is 88.21%.


@@             Coverage Diff             @@
##           develop    #2016      +/-   ##
===========================================
+ Coverage    76.74%   76.91%   +0.16%     
===========================================
  Files          362      362              
  Lines        58394    58462      +68     
===========================================
+ Hits         44817    44968     +151     
+ Misses       13577    13494      -83     



Impacted Files
Coverage Δ





src/io/gml-lexer.l
75.00% <ø> (+8.33%)
⬆️


src/io/gml.c
89.91% <85.93%> (+10.31%)
⬆️


src/io/gml-parser.y
88.76% <94.87%> (+11.38%)
⬆️


src/io/gml-tree.c
87.85% <100.00%> (+19.82%)
⬆️


src/core/printing.c
38.33% <0.00%> (+13.33%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 153d00b...5d3a413. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2016#issuecomment-1079925812,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","@ntamas What do we do with the creator argument in write_graph_gml()? Currently, it does not control what is written in the Creator field, but (contrary to the documentation) it only sets what to add to the standard igraph x.y.z instead of the date.
I suggest the following:

If creator is NULL, do the same thing as now.
If """", omit the Creator field
Otherwise, write the value of creator verbatim, without the igraph x.y.z

This will make it easier to write tests, as the output won't be dependent on either the time of day or the version of igraph. I know that there is a workaround for this when comparing with .out files (@VERSION@), but it cannot be used in all situations. I would like to be able to read in an .out file as GML, then output it, and verify that nothing changed.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2016#issuecomment-1079950780,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","I do some ugliness here by storing -1 in an igraph_attribute_type_t. This is not technically a valid value, but it happens to work as C represents enums with integers (but it does seem to use unsigned ints on my system!)

  
    
      igraph/src/io/gml.c
    
    
         Line 304
      in
      be67455
    
  
  
    

        
          
                * We use an attribute type value of -1 to mark attribute records which 
        
    
  



  
    
      igraph/src/io/gml.c
    
    
         Line 345
      in
      be67455
    
  
  
    

        
          
           atrec->type = -1; 
        
    
  



  
    
      igraph/src/io/gml.c
    
    
         Line 355
      in
      be67455
    
  
  
    

        
          
           } else if (type1 == -1) { 
        
    
  


The third of these lines linked above is prone to triggering compilers warnings (although it's not a warning that's enabled by default).
What do you think about using a legal, named values instead of -1, specifically IGRAPH_ATTRIBUTE_DEFAULT which is not used at the moment, @ntamas @vtraag ? See also #2015.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2016#issuecomment-1079951754,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.",I'm ready for a basic review before continuing with adding support for graph attributes.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/2016#issuecomment-1080014187,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","Re the creator field -- I'm not familiar with the GML spec, is this something that is mandated by the GML file format? If so, my preference would be to allow the user to override the creator field completely, so your proposal seems good (NULL should do what we do now, empty string should omit it if it is allowed by the GML spec, otherwise treat it as NULL, and any other value should override the creator field completely). After all, it could be the case that igraph is embedded in a larger app that wants to write its own name and version number in GML files instead of igraph's.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/2016#issuecomment-1080014248,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","What do you think about using a legal, named values instead of -1, specifically IGRAPH_ATTRIBUTE_DEFAULT which is not used at the moment, @ntamas @vtraag ? See also #2015.

Yes, that's better than using -1 for sure.",True,"{'THUMBS_UP': ['https://github.com/szhorvat', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/2016#issuecomment-1080015199,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","I'm not familiar with the GML spec

It's a rather loose spec. You'll find a link to the Internet Archive copy of it in the WIkiepdia page:
https://en.wikipedia.org/wiki/Graph_Modelling_Language
https://web.archive.org/web/20190303094704/http://www.fim.uni-passau.de:80/fileadmin/files/lehrstuhl/brandenburg/projekte/gml/gml-technical-report.pdf

is this something that is mandated by the GML file format?

No, it is not mandatory.",True,"{'THUMBS_UP': ['https://github.com/ntamas', 'https://github.com/vtraag']}"
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/2016#issuecomment-1085570927,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","@ntamas This is almost done. There's one little thing I need to decide about.  When writing a Boolean attribute, the GML writer shows a warning about converting it to numeric. This has already been so in the previous version. This warning is shown for every single edge and every single vertex that is written. Do we want to add a guard to prevent it from being printed more than once for each attribute? I have added other, new warnings for the GML writer, and prevented them from being printed more than once through igraph_vector_bool_t ignore_warning_shown, see e.g. here. However, now I realize that all three of our high-level interfaces have some sort of protection against excessive warning message, so maybe it's not worth the effort.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2016#issuecomment-1085571357,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","The rest of the code is ready for review, comments welcome.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/2016#issuecomment-1085682787,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","Yes, I'd add a boolean guard so the warning is not printed more than once.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/2016#issuecomment-1085688147,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","Done, and also corrected the size of the warning_shown vector (must be the attribute count, not the edge/vertex count). Ready for review.
When merging, please do NOT squash. There's too much here to be all squashed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/ntamas,13,https://github.com/igraph/igraph/pull/2016#issuecomment-1085688304,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.",This looks good to me now! We can merge if the CI runs pass.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2016,2022-03-26T21:54:08Z,2022-04-01T09:58:48Z,2022-04-01T09:58:48Z,MERGED,True,907,701,19,https://github.com/szhorvat,GML reader improvements,26,[],https://github.com/igraph/igraph/pull/2016,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/2016#issuecomment-1085689021,"Done

Replaces igraph_gml_string_t with char * for simplicity. igraph_gml_string_t would be useful for non-null terminated strings with a specified length. This is indeed the way Bison/Flex handle strings. However, we need to copy the strings into the GML tree anyway, and we were already converting them to null-terminated.
Records line numbers into the GML tree, so they can be used when reporting some errors.
A warning is given for each composite attribute that is encountered and ignored, mentioning the attribute name. Note that no warning is given when only a single value is ignored as opposed to all values, e.g. when one value of a certain attribute is composite but the others have simple types.
The default numerical attribute value is now NaN instead of 0. This is consistent with how the C attribute handler works in general, and helps the user sort out missing values from zero values.
Nodes with no IDs are no longer rejected. These are valid as isolated nodes according to the GML spec. These nodes get an ""id"" attribute value of NaN, in accordance with the above point.
Empty lists, [ ], are now allowed, in accordance with the GML spec. This allows specifying isolated nodes as node [ ].
The GML writer will now check that the supplied ids are valid integers. If some are not, all are discarded. This fix was necessary because reading some GML files will now create id values of NaN.
Duplicate node 'id' fields, or edge 'source' / 'target' fields now cause an error, duplicate directed causes only a warning.
Graph attributes are now supported in the reader (the writer already supported them). Fixes #174.
GML writer will only show each warning at most once for each edge/vertex attribute. Previously, warnings were shown as many times as the edge/vertex count.
The behaviour of the creator argument is now different, see #2016 (comment)
More tests.

Decisions

Duplicate id fields in node and duplicate source/target in edge are an error. Example: node [ id 1 id 2 ].
Duplicate directed field in graph is only a warning for now, but it could be made an error as well.
When duplicate attributes are present, all but the last is ignored. Example: node [ x 1 x 2 ]. This is how this function behaved in the past, and implementing duplicate detection would be some trouble for little gain. According to the GML spec, this should be treated as an array named x with two entries, but we don't support this, and can't support this since igraph only has scalar types.

Notes

_ characters in key names are supported in the reader, but not the writer. The writer skips them. The GML spec does not indicate support for these characters, so I think this is fine. We want to be tolerant when reading malformed files, but try not to write them.","Alright, I'll merge. If there are any bugs, OSS-fuzz should find them.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2017,ncol and nrow weren't correctly set after creation of a complex matrix.,ncol and nrow weren't correctly set after creation of a complex matrix.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2017#issuecomment-1086623114,ncol and nrow weren't correctly set after creation of a complex matrix.,"Codecov Report

Merging #2017 (d2ec434) into develop (1856cd6) will increase coverage by 0.26%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #2017      +/-   ##
===========================================
+ Coverage    77.05%   77.31%   +0.26%     
===========================================
  Files          362      361       -1     
  Lines        58471    58442      -29     
===========================================
+ Hits         45055    45186     +131     
+ Misses       13416    13256     -160     



Impacted Files
Coverage Δ





src/core/matrix.c
98.50% <100.00%> (+71.05%)
⬆️


src/core/set.c
92.85% <0.00%> (-0.90%)
⬇️


src/isomorphism/bliss/graph.cc
72.06% <0.00%> (-0.02%)
⬇️


src/io/gml.c
89.91% <0.00%> (ø)



src/io/graphml.c
82.31% <0.00%> (ø)



src/io/gml-parser.y
88.76% <0.00%> (ø)



src/internal/glpk_support.c
54.34% <0.00%> (ø)



src/core/hashtable.c




src/core/array.pmt
39.13% <0.00%> (+0.10%)
⬆️


src/core/matrix.pmt
85.97% <0.00%> (+1.55%)
⬆️


... and 6 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1856cd6...d2ec434. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2017#issuecomment-1086664710,ncol and nrow weren't correctly set after creation of a complex matrix.,"Can you please try:
#define _USE_MATH_DEFINES
#include <math.h>

instead of using an internal igraph header? There's value in keeping internal stuff out of tests when possible.
https://docs.microsoft.com/en-us/cpp/c-runtime-library/math-constants?view=msvc-170
I'm not sure if this will work after #include <igraph.h>, but I hope it does. igraph.h will indirectly include math.h itself. It would be useful to find out.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2017#issuecomment-1086677191,ncol and nrow weren't correctly set after creation of a complex matrix.,"It's a bit disturbing to me that this function was broken and no one even noticed. Do we really need this functionality? Theoretically, it should be useful for some of the spectral stuff, but apparently it's not currently used. igraph should not aim to provide matrices for general use. There are much better libraries for that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/2017#issuecomment-1086819235,ncol and nrow weren't correctly set after creation of a complex matrix.,"It's a bit disturbing to me that this function was broken and no one even noticed. Do we really need this functionality? Theoretically, it should be useful for some of the spectral stuff, but apparently it's not currently used. igraph should not aim to provide matrices for general use. There are much better libraries for that.

It seems like they're only used in igraph_eigen_matrix, which itself seems to be only used in tests. So maybe we should remove complex matrices altogether?
If we don't remove them, then the question remains if these functions are required. They seem pretty minimal to me, and the _real and _imag functions seem useful once something provides you with a complex matrix. We don't seem to have a real use for creating a complex matrix yourself, but it seems strange to only be able to split into real and imaginary parts, and not combine them.
We should probably conclude this first, before I go on to the other remarks :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2017#issuecomment-1086824587,ncol and nrow weren't correctly set after creation of a complex matrix.,"I vote for keeping these functions for now, but I do not have a very strong opinion on this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/vtraag,7,https://github.com/igraph/igraph/pull/2017#issuecomment-1086928468,ncol and nrow weren't correctly set after creation of a complex matrix.,"Unless we provide a useful implementation of complex matrices, I would vote to remove it if we don't need it ourselves.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/GroteGnoom,8,https://github.com/igraph/igraph/pull/2017#issuecomment-1086936811,ncol and nrow weren't correctly set after creation of a complex matrix.,"Unless we provide a useful implementation of complex matrices, I would vote to remove it if we don't need it ourselves.

I'm not sure if I understand you correctly, but we do have a functional implementation right now, because the usual matrix functions are also generated for complex matrices. I think only the functions for which you need an ordering are excluded.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/vtraag,9,https://github.com/igraph/igraph/pull/2017#issuecomment-1086947136,ncol and nrow weren't correctly set after creation of a complex matrix.,"Ah ok, from your earlier comments I got the impression that we didn't support complex matrices as well as regular matrices, but only provided a small part of the functionality. In that case, I'd say we should keep complex matrices in general.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/2017#issuecomment-1086985955,ncol and nrow weren't correctly set after creation of a complex matrix.,"+1 for keeping the functionality that we have now, but I also agree with @szhorvat that it should not be our goal to provide a generic matrix library.
OTOH I wonder whether the now-removed spectral coarse graining code made use of the complex matrix functionality.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2017,2022-04-02T11:46:27Z,2022-04-04T14:31:59Z,2022-04-04T14:31:59Z,MERGED,True,263,18,8,https://github.com/GroteGnoom,"Add complex matrix unit tests, docs, fix bugs",8,[],https://github.com/igraph/igraph/pull/2017,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/2017#issuecomment-1087402611,ncol and nrow weren't correctly set after creation of a complex matrix.,Go ahead and merge when you're happy @GroteGnoom,True,{}
igraph/igraph,https://github.com/igraph/igraph,2023,2022-04-03T11:31:44Z,2022-04-04T09:16:25Z,2022-04-04T09:16:25Z,MERGED,True,0,25,4,https://github.com/GroteGnoom,Remove vector_permdelete,1,[],https://github.com/igraph/igraph/pull/2023,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2023,"It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633","It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633",True,{}
igraph/igraph,https://github.com/igraph/igraph,2023,2022-04-03T11:31:44Z,2022-04-04T09:16:25Z,2022-04-04T09:16:25Z,MERGED,True,0,25,4,https://github.com/GroteGnoom,Remove vector_permdelete,1,[],https://github.com/igraph/igraph/pull/2023,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2023#issuecomment-1086845293,"It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633","Codecov Report

Merging #2023 (5d5934c) into develop (d43323b) will increase coverage by 0.01%.
The diff coverage is n/a.


@@             Coverage Diff             @@
##           develop    #2023      +/-   ##
===========================================
+ Coverage    77.13%   77.14%   +0.01%     
===========================================
  Files          362      362              
  Lines        58478    58469       -9     
===========================================
  Hits         45107    45107              
+ Misses       13371    13362       -9     



Impacted Files
Coverage Δ





src/core/vector.pmt
89.04% <ø> (+0.92%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d43323b...5d5934c. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2023,2022-04-03T11:31:44Z,2022-04-04T09:16:25Z,2022-04-04T09:16:25Z,MERGED,True,0,25,4,https://github.com/GroteGnoom,Remove vector_permdelete,1,[],https://github.com/igraph/igraph/pull/2023,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/2023#issuecomment-1086927861,"It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633","I've approved the changes in general, but I'd still like to put this up for a vote: shall we remove the _permdelete() function or not?
On one hand, it is not used for anything inside igraph.
On the other hand, people might have started using it for stuff outside igraph. This function provides functionality that is not meaningless outside igraph's context; it is a generic vector operation that basically generalizes shuffling the vector with an index vector in a way that also allows the deletion of some elements. I can imagine that this was actually used by people outside igraph, and if this is the case, we shouldn't remove it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2023,2022-04-03T11:31:44Z,2022-04-04T09:16:25Z,2022-04-04T09:16:25Z,MERGED,True,0,25,4,https://github.com/GroteGnoom,Remove vector_permdelete,1,[],https://github.com/igraph/igraph/pull/2023,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/2023#issuecomment-1086928152,"It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633",I would vote for removal.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2023,2022-04-03T11:31:44Z,2022-04-04T09:16:25Z,2022-04-04T09:16:25Z,MERGED,True,0,25,4,https://github.com/GroteGnoom,Remove vector_permdelete,1,[],https://github.com/igraph/igraph/pull/2023,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2023#issuecomment-1086934640,"It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633","I agree with Tamás that this is potentially useful, and I won't vote for removal. But I also won't stand in it's way. I'll abstain this time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2023,2022-04-03T11:31:44Z,2022-04-04T09:16:25Z,2022-04-04T09:16:25Z,MERGED,True,0,25,4,https://github.com/GroteGnoom,Remove vector_permdelete,1,[],https://github.com/igraph/igraph/pull/2023,https://github.com/vtraag,6,https://github.com/igraph/igraph/pull/2023#issuecomment-1086947290,"It said it's for internal use only, but is not used internally.
It was once used here, for example: 0988d60#diff-a9e323228f51816f9d45d22cbcede355646cbd280c8132719b3c0ea3f01c21e4R633",So then we let @GroteGnoom break the tie? :),True,"{'THUMBS_UP': ['https://github.com/szhorvat'], 'LAUGH': ['https://github.com/GroteGnoom']}"
igraph/igraph,https://github.com/igraph/igraph,2025,2022-04-04T09:10:44Z,2022-04-04T09:11:37Z,2022-04-04T09:11:37Z,MERGED,True,1,1,1,https://github.com/GroteGnoom,fix: ignore io/parsers for coverage,1,[],https://github.com/igraph/igraph/pull/2025,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2025,To prevent error on reading 'io/parsers/gml-lexer.c',To prevent error on reading 'io/parsers/gml-lexer.c',True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2026,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)","It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2026#issuecomment-1087497808,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)","Codecov Report

Merging #2026 (222cdb2) into develop (9e14d90) will increase coverage by 0.04%.
The diff coverage is n/a.


@@             Coverage Diff             @@
##           develop    #2026      +/-   ##
===========================================
+ Coverage    77.19%   77.23%   +0.04%     
===========================================
  Files          361      360       -1     
  Lines        58435    58380      -55     
===========================================
- Hits         45107    45089      -18     
+ Misses       13328    13291      -37     



Impacted Files
Coverage Δ





src/core/vector.pmt
94.05% <0.00%> (+0.97%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 9e14d90...222cdb2. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/2026#issuecomment-1087516648,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)",Removal is fine by me but please mention it in the changelog.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2026#issuecomment-1087521895,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)","This is different from the ""hashtable"" which was not really a hashtable. 3D arrays are a more generally useful data structure, with much less flexibility in how they may be implemented. I could easily see a need for these in these future. If a need does arise, the implementation will look pretty much identical to what we have now.
I vote to keep it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/2026#issuecomment-1087536104,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)","This is different from the ""hashtable"" which was not really a hashtable. 3D arrays are a more generally useful data structure, with much less flexibility in how they may be implemented. I could easily see a need for these in these future. If a need does arise, the implementation will look pretty much identical to what we have now.

If it isn't needed in all of igraph now, I can't really imagine what kinds of special cases we'd need it for in the future.
It's probably easier to add it back in if the need ever arises than to maintain it just in case. Then we also know the interface it needs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2026#issuecomment-1087546822,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)","OK, now I'm going to point out that these are public functions, and summon @ntamas who will ask to deprecate it before removal ;-)

There is one specific application that I have in mind for these 3D arrays. For quite a while now, I wanted to add functions to igraph which convert skeleton images to usable graphs. This includes 3D images, so we need 3D arrays. This is an extremely common use case for biological image/network analysis, as well as for working with spatial networks in other contexts.
For my personal work, I usually use Mathematica's own functions for this operation, but they are unsatisfactory in many situations. So for a while now I've been planning to write my own.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2026,2022-04-04T12:29:12Z,2022-04-04T13:23:53Z,2022-04-04T13:23:54Z,CLOSED,False,0,296,8,https://github.com/GroteGnoom,remove array3,1,[],https://github.com/igraph/igraph/pull/2026,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/2026#issuecomment-1087552877,"It's not used anywhere, only in tests.
I opened a quick PR to show that everything in the C core still runs perfectly without these arrays. If we want a subtler approach or there a good reason to keep array3, it's fine to close this :)","Ok, sounds cool :) Since you have a specific usage in mind, I'll just close this, and at least we can later find the argumentation for keeping it :) If I don't see skeletons in a year, I'll start complaining again ;)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2028,2022-04-05T07:29:34Z,2022-04-05T15:33:48Z,2022-04-05T15:34:09Z,MERGED,True,114,11,7,https://github.com/szhorvat,Creating regular trees,1,[],https://github.com/igraph/igraph/pull/2028,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2028,"This is a convenience function. https://en.wikipedia.org/wiki/Bethe_lattice
The default directedness in functions.yaml is undirected, as this is how these trees are commonly used. It's the total degree that is the same, not the out-degree.","This is a convenience function. https://en.wikipedia.org/wiki/Bethe_lattice
The default directedness in functions.yaml is undirected, as this is how these trees are commonly used. It's the total degree that is the same, not the out-degree.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2028,2022-04-05T07:29:34Z,2022-04-05T15:33:48Z,2022-04-05T15:34:09Z,MERGED,True,114,11,7,https://github.com/szhorvat,Creating regular trees,1,[],https://github.com/igraph/igraph/pull/2028,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2028#issuecomment-1088362606,"This is a convenience function. https://en.wikipedia.org/wiki/Bethe_lattice
The default directedness in functions.yaml is undirected, as this is how these trees are commonly used. It's the total degree that is the same, not the out-degree.","Codecov Report

Merging #2028 (18c7272) into develop (eaabb5b) will increase coverage by 0.00%.
The diff coverage is 88.88%.


@@           Coverage Diff            @@
##           develop    #2028   +/-   ##
========================================
  Coverage    77.31%   77.31%           
========================================
  Files          361      361           
  Lines        58443    58456   +13     
========================================
+ Hits         45187    45198   +11     
- Misses       13256    13258    +2     



Impacted Files
Coverage Δ





src/constructors/regular.c
88.81% <88.88%> (-0.20%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update eaabb5b...18c7272. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2028,2022-04-05T07:29:34Z,2022-04-05T15:33:48Z,2022-04-05T15:34:09Z,MERGED,True,114,11,7,https://github.com/szhorvat,Creating regular trees,1,[],https://github.com/igraph/igraph/pull/2028,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/2028#issuecomment-1088877588,"This is a convenience function. https://en.wikipedia.org/wiki/Bethe_lattice
The default directedness in functions.yaml is undirected, as this is how these trees are commonly used. It's the total degree that is the same, not the out-degree.",Please update the changelog in a separate commit if you have some time. Thanks! :),True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,2037,2022-04-15T22:22:47Z,2022-04-15T22:36:04Z,2022-04-15T22:36:04Z,MERGED,True,6,2,3,https://github.com/iosonofabio,UMAP bugfix: Forbid sampling probability above one,1,[],https://github.com/igraph/igraph/pull/2037,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/2037,"ATM the user can set the sampling probability in UMAP above one and it's assumed to be one.
That might lead to confusion, so let's forbid it.","ATM the user can set the sampling probability in UMAP above one and it's assumed to be one.
That might lead to confusion, so let's forbid it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2037,2022-04-15T22:22:47Z,2022-04-15T22:36:04Z,2022-04-15T22:36:04Z,MERGED,True,6,2,3,https://github.com/iosonofabio,UMAP bugfix: Forbid sampling probability above one,1,[],https://github.com/igraph/igraph/pull/2037,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2037#issuecomment-1100442573,"ATM the user can set the sampling probability in UMAP above one and it's assumed to be one.
That might lead to confusion, so let's forbid it.","Codecov Report

Merging #2037 (47f20ef) into develop (9c734be) will not change coverage.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #2037   +/-   ##
========================================
  Coverage    77.55%   77.55%           
========================================
  Files          362      362           
  Lines        58797    58797           
========================================
  Hits         45602    45602           
  Misses       13195    13195           



Impacted Files
Coverage Δ





src/layout/umap.c
94.48% <100.00%> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 9c734be...47f20ef. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2038,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/2038#issuecomment-1100736559,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","That's weird for me as well, I also think it should be i and not i + 1.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2038#issuecomment-1100752552,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","I double-checked that these are indeed one-based indices. I do not add one to them in the Mathematica interface, and the result I get this way is correct.
Note that these are NOT edge IDs. They are step numbers, i.e. they can be used to index into the result vector.
In functions.yaml on the develop branch, this output argument is marked as OPTIONAL OUT VERTEXSET bridges, which is wrong in several ways: (1) these are not zero-based indices, so they need no +1 for R (2) they are definitely not vertex IDs, but also not edge IDs. Can you have a look at this @ntamas, also on master and in the R interface v1.3?
If this is changed, it will need to be marked clearly as a breaking change.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2038#issuecomment-1100752712,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","On master it is OUT VECTOR bridges, so that's fine. But should result not be an EDGESETLIST or whatever a list of edge IDs is called on master, @ntamas ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/2038#issuecomment-1100753389,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","You are correct, the definition file should be fixed. Note that fixing the definition file is not a breaking change because the function is hand-written on the R side, and there we do not treat the bridges component of the result as a list of edge IDs.
On master I would not touch functions.yaml as it is not used in the R interface and it won't be used anywhere else anyway; even if we decide to start generating code for the Python interface, it will use functions.yaml from the develop branch. I changed the type of the bridges argument to OUT VECTOR_INT in the develop branch.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2038#issuecomment-1100754846,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","I mean that if we change from 1-based to 0-based indexing for 0.10, that's a breaking change that should be clearly noted.
I think it makes sense to do this change.
Is there a stimulus type that denotes an ""index vector"" (not merely an integer vector, but an index vector), @ntamas ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/GroteGnoom,7,https://github.com/igraph/igraph/pull/2038#issuecomment-1100829347,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","This is now one result of the tests:
Check graph with three vertices, two edges, remove one:
Bridges:0 -4702111234474983746
Modularity:-0.333333 -0.222222 -1.83255e-06
Membership:0 0 1
Merges:
1 0
0 -4702111234474983746

It's because the sizes of modularity, res and bridges are calculated up front using no_of_nodes - no_comps, which seems wrong. The size should at least depend on the number of edges that are removed. Maybe no_of_nodes - no_comps is an upper bound and everything should be resized to midx afterwards? I don't think you can calculate the number of merges easily beforehand.
However, for the result matrix, simply resizing afterwards will not work. I can count the number of merges first, which means there's another loop over all given removed-edges, or I can call igraph_matrix_permdelete_rows, which scales with the number of elements in the matrix.
Also, min(no_of_removed_edges, no_of_nodes - no_comps) seems like a better upper bound to start with.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,8,https://github.com/igraph/igraph/pull/2038#issuecomment-1101550661,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","I mean that if we change from 1-based to 0-based indexing for 0.10, that's a breaking change that should be clearly noted.

Indeed, but I'd consider that as a bugfix -- especially because the R interface currently adds +1 to the index vector so in R the indexing is effectively 2-based now, which absolutely doesn't make sense.

Is there a stimulus type that denotes an ""index vector"" (not merely an integer vector, but an index vector)

Yes there is, and you are right, it's probably better to use that in develop. I also changed it in master although it has no relevance there as the function is not autogenerated.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/2038#issuecomment-1101557456,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","Yes, using no_of_nodes - no_comps seems wrong; it is this way because initially this function was simply a helper function for edge betweenness, where we assumed that all the edges were removed, and that obviously the number of merges was no_of_nodes - no_comps because this many steps were needed to decompose everything into individual vertices.
This should be sorted out properly. I wouldn't care too much about efficiency here as this is a niche function that is unlikely to be used in performance-critical scenarios, so just go with whichever option feels simplest.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2038#issuecomment-1101560718,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","Indeed, but I'd consider that as a bugfix -- especially because the R interface currently adds +1 to the index vector so in R the indexing is effectively 2-based now, which absolutely doesn't make sense.

Just mention it under ""breaking changes"" in the changelog, so people are aware. I relied on this behaviour in the Mathematica interface and will need to remember to update it. I'll be reading the changelog for that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/GroteGnoom,11,https://github.com/igraph/igraph/pull/2038#issuecomment-1107422657,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","I think that removing 1 edge from a triangle should cause 0 merges, but the result is now 1. That's because igraph_i_community_eb_get_merges2 starts out with a membership vector where every vertex is it's own cluster. Any edge you choose is then counted as a merge. It seems plain incorrect to me, like it's checking what happens when adding edges instead of removing them. Maybe I'm just misunderstanding the docs? It does seem like eb_get_merges and eb_get_merges2 do the same thing.
Edit: conclusion: probably a misunderstanding of the documentation.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/GroteGnoom,12,https://github.com/igraph/igraph/pull/2038#issuecomment-1107808101,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","All the edges in the graph need to be removed. That's in the docs, but I interpreted it wrong. I now added an error. This solves all the issues for only removing a few edges.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/apps/codecov,13,https://github.com/igraph/igraph/pull/2038#issuecomment-1107812864,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","Codecov Report

Merging #2038 (4a6c430) into develop (4d2105b) will increase coverage by 0.09%.
The diff coverage is 85.00%.


❗ Current head 4a6c430 differs from pull request most recent head b96c5cf. Consider uploading reports for the commit b96c5cf to get more accurate results


@@             Coverage Diff             @@
##           develop    #2038      +/-   ##
===========================================
+ Coverage    77.82%   77.92%   +0.09%     
===========================================
  Files          363      363              
  Lines        59137    59151      +14     
===========================================
+ Hits         46022    46092      +70     
+ Misses       13115    13059      -56     



Impacted Files
Coverage Δ





src/community/edge_betweenness.c
93.31% <85.00%> (+29.75%)
⬆️


src/flow/flow.c
87.42% <0.00%> (-4.96%)
⬇️


src/paths/random_walk.c
95.41% <0.00%> (-0.09%)
⬇️


src/community/leading_eigenvector.c
86.26% <0.00%> (+0.30%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4d2105b...b96c5cf. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/GroteGnoom,14,https://github.com/igraph/igraph/pull/2038#issuecomment-1107855310,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","Currently the only CI error is 437 - test::glpk_error (SEGFAULT), which is not because of this PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/2038#issuecomment-1108483344,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/2038#issuecomment-1108504999,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1",I think it would make sense to rename this function. It is not really related to edge betweenness in any way. Even the documentation states this: it's useful in all cases when we have a sequence of edges to remove. The naming since to be a leftover from a time when it was only a helper function for the Girvan-Newman community detector.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/2038#issuecomment-1108506461,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","But if we rename it, it makes sense to think about whether it could be extended to the case when not all edges are removed, but only some of them. I don't have the mental energy for that now, but it does not seem feasible. Ping @vtraag since you are more fluent in clustering problems.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/2038#issuecomment-1108520891,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1",I'm wondering what happens when an edge ID appears twice in the input. Will it report an error cleanly?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/2038#issuecomment-1108523689,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","It looks like it returns a nonsense result, the same as when the number of removed edges is not the same as the edge count (i.e. as if that check didn't exist)?
It might be useful to guard against this: allocate a boolean vector of the same size as the edge count and tick off all edges as they are handled. Is this too big of a performance / memory use hit? Since this function would usually be run after a more costly computation that determines the order of edge removals, I think it's an acceptable cost (but I didn't benchmark).",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,20,https://github.com/igraph/igraph/pull/2038#issuecomment-1110875462,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","There are many more ways in which this function can be messed with; for instance, supplying invalid edge IDs are very likely to yield erroneous results without any error codes. Personally, I've always been thinking about this function as one that is meant for internal use only; in that sense it's kinda okay to have it as is. If we do anticipate that users will use this function on its own by supplying their own edge ID vectors, then of course we need more strict error checks, but in my opinion it is easier to make this function private instead as I don't think this would be used often by end users.
Note that the function is not even exposed in any of the higher-level interfaces so there mustn't have been overwhelming demand for it in the past.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/szhorvat,21,https://github.com/igraph/igraph/pull/2038#issuecomment-1110883031,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","supplying invalid edge IDs

That's checked for now, after @GroteGnoom's patch.

Note that the function is not even exposed in any of the higher-level interfaces

True, but I think there's value in this function, and I was just planning to expose it in IGraph/M. I would like to be able to experiment with various edge removal orders.

As far as I can tell, there's only one input check needed: make sure that each edge ID appears precisely once. Am I missing anything? If not, I'm willing to add this check.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,22,https://github.com/igraph/igraph/pull/2038#issuecomment-1110889514,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","I think that's all then, but note that there are actually two implementations (there's an internal static function) so make sure that the error checks affect both.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2038,2022-04-16T13:30:36Z,2022-04-25T12:04:02Z,2022-04-27T11:29:39Z,MERGED,True,221,14,5,https://github.com/GroteGnoom,add community_eb_get_merges tests,14,[],https://github.com/igraph/igraph/pull/2038,https://github.com/ntamas,23,https://github.com/igraph/igraph/pull/2038#issuecomment-1110890439,"I currently don't understand how the bridges result fits with the docs.
Why does this line
https://github.com/igraph/igraph/blob/develop/src/community/edge_betweenness.c#L287
VECTOR(*bridges)[midx] = i + 1;
add one to the index? It seems to me like it should just be i, not i + 1","Plus, we might need a better name. This function does not simply ""get the merges"", it processes an edge removal sequence and calculates Lots-Of-StuffTM based on it.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/iosonofabio,1,https://github.com/igraph/igraph/pull/2039,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions",True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2039#issuecomment-1100777270,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","Codecov Report

Merging #2039 (4a57281) into develop (1dfad7c) will increase coverage by 0.11%.
The diff coverage is 86.66%.


@@             Coverage Diff             @@
##           develop    #2039      +/-   ##
===========================================
+ Coverage    77.55%   77.67%   +0.11%     
===========================================
  Files          362      363       +1     
  Lines        58797    59089     +292     
===========================================
+ Hits         45602    45899     +297     
+ Misses       13195    13190       -5     



Impacted Files
Coverage Δ





src/layout/umap.c
93.89% <86.66%> (-0.59%)
⬇️


src/paths/widest_paths.c
97.02% <0.00%> (ø)



src/games/preference.c
85.13% <0.00%> (+3.69%)
⬆️


src/paths/random_walk.c
95.41% <0.00%> (+6.87%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1dfad7c...4a57281. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/iosonofabio,3,https://github.com/igraph/igraph/pull/2039#issuecomment-1100777310,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions",Would you prefer I code a dimensional check for custom initial layouts? Something like if it's not the right number of rows/columns the function should fail early?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/iosonofabio,4,https://github.com/igraph/igraph/pull/2039#issuecomment-1100778138,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","Clearly it was worth it, since it found a bug in the only test I had written 😱",True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2039#issuecomment-1101558684,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","This parameter is named use_seed in other layout functions. Can we make it consistent with them, in naming, behaviour, and position within the parameter list?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/2039#issuecomment-1101573121,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","I just wanted to say exactly what @szhorvat said, otherwise it seems fine to me",True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/2039#issuecomment-1101717664,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","One more comment:
When giving error messages about vertex coordinates, I would prefer to avoid referring to ""matrices"" directly. This is because the manner in which high-level interfaces expose coordinates may not be a matrix, and if it is a matrix, it may be the transpose of what the C interface uses.
Can you re-write it in terms of something like ""number of points"" and ""dimension"" or ""embedding dimension"", or whatever representation-agnostic phrasing you prefer?
Finally, with actual matrices let's not use 3 x 4 but 3 by 4, as x looks weird in some environments.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2039,2022-04-17T00:26:31Z,2022-04-19T12:07:48Z,2022-04-19T12:07:48Z,MERGED,True,76,36,4,https://github.com/iosonofabio,UMAP: Custom initial layout,7,[],https://github.com/igraph/igraph/pull/2039,https://github.com/iosonofabio,8,https://github.com/igraph/igraph/pull/2039#issuecomment-1101799863,"Let the user choose a custom initial layout for UMAP, especially useful for perturbative layouting.
Mentioned in igraph/python-igraph#529.
TODO:

 Test case
 Check custom initial layout dimensions","Thanks guys. I changed the name to use_seed, reordered the API function args to be consistent with other functions around, and changes the error message to not mention ""matrces"" anymore, but just ""points in X dimensions"".
I also added a test to catch a corner case for trivial graphs with a seed layout, which was segfaulting.
If it passes CI I'll merge.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2040,2022-04-17T10:11:37Z,2022-04-24T14:53:10Z,2022-04-24T14:53:10Z,MERGED,True,161,57,5,https://github.com/GroteGnoom,add st_vertex_connectivity tests,7,[],https://github.com/igraph/igraph/pull/2040,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2040,"I think two connected vertices with a IGRAPH_VCONN_NEI_IGNORE should return 0, not 1. Except for the direct path, there should be nothing to remove. Right?
In general, two connected vertices with a IGRAPH_VCONN_NEI_IGNORE seems to return one too many vertices, but maybe we want to change the docs, not the result.","I think two connected vertices with a IGRAPH_VCONN_NEI_IGNORE should return 0, not 1. Except for the direct path, there should be nothing to remove. Right?
In general, two connected vertices with a IGRAPH_VCONN_NEI_IGNORE seems to return one too many vertices, but maybe we want to change the docs, not the result.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2040,2022-04-17T10:11:37Z,2022-04-24T14:53:10Z,2022-04-24T14:53:10Z,MERGED,True,161,57,5,https://github.com/GroteGnoom,add st_vertex_connectivity tests,7,[],https://github.com/igraph/igraph/pull/2040,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/2040#issuecomment-1101597547,"I think two connected vertices with a IGRAPH_VCONN_NEI_IGNORE should return 0, not 1. Except for the direct path, there should be nothing to remove. Right?
In general, two connected vertices with a IGRAPH_VCONN_NEI_IGNORE seems to return one too many vertices, but maybe we want to change the docs, not the result.","I think that  IGRAPH_VCONN_IGNORE should mean ""just pretend that the edge is not there, but I don't want to bother removing it"". So, if there are two vertices that are only connected by a single edge and there exists no other path between them, the result should be zero.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2040,2022-04-17T10:11:37Z,2022-04-24T14:53:10Z,2022-04-24T14:53:10Z,MERGED,True,161,57,5,https://github.com/GroteGnoom,add st_vertex_connectivity tests,7,[],https://github.com/igraph/igraph/pull/2040,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/2040#issuecomment-1107445898,"I think two connected vertices with a IGRAPH_VCONN_NEI_IGNORE should return 0, not 1. Except for the direct path, there should be nothing to remove. Right?
In general, two connected vertices with a IGRAPH_VCONN_NEI_IGNORE seems to return one too many vertices, but maybe we want to change the docs, not the result.","Codecov Report

Merging #2040 (3c783ad) into develop (a513ceb) will increase coverage by 0.17%.
The diff coverage is 90.32%.


@@             Coverage Diff             @@
##           develop    #2040      +/-   ##
===========================================
+ Coverage    77.64%   77.82%   +0.17%     
===========================================
  Files          363      363              
  Lines        59066    59131      +65     
===========================================
+ Hits         45863    46018     +155     
+ Misses       13203    13113      -90     



Impacted Files
Coverage Δ





src/flow/flow.c
92.38% <90.32%> (+4.95%)
⬆️


src/layout/layout_random.c
39.53% <0.00%> (-60.47%)
⬇️


src/misc/conversion.c
81.99% <0.00%> (-2.34%)
⬇️


src/layout/fruchterman_reingold.c
47.15% <0.00%> (-0.94%)
⬇️


src/layout/umap.c
93.89% <0.00%> (-0.59%)
⬇️


src/community/walktrap/walktrap_graph.cpp
75.45% <0.00%> (-0.25%)
⬇️


src/games/islands.c
100.00% <0.00%> (ø)



src/io/parse_utils.c
69.76% <0.00%> (ø)



src/graph/iterators.c
76.46% <0.00%> (ø)



src/isomorphism/lad.c
95.23% <0.00%> (ø)



... and 31 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update a513ceb...3c783ad. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2040,2022-04-17T10:11:37Z,2022-04-24T14:53:10Z,2022-04-24T14:53:10Z,MERGED,True,161,57,5,https://github.com/GroteGnoom,add st_vertex_connectivity tests,7,[],https://github.com/igraph/igraph/pull/2040,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/2040#issuecomment-1107854562,"I think two connected vertices with a IGRAPH_VCONN_NEI_IGNORE should return 0, not 1. Except for the direct path, there should be nothing to remove. Right?
In general, two connected vertices with a IGRAPH_VCONN_NEI_IGNORE seems to return one too many vertices, but maybe we want to change the docs, not the result.",LGTM. Is this ready to merge now?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2040,2022-04-17T10:11:37Z,2022-04-24T14:53:10Z,2022-04-24T14:53:10Z,MERGED,True,161,57,5,https://github.com/GroteGnoom,add st_vertex_connectivity tests,7,[],https://github.com/igraph/igraph/pull/2040,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/2040#issuecomment-1107855139,"I think two connected vertices with a IGRAPH_VCONN_NEI_IGNORE should return 0, not 1. Except for the direct path, there should be nothing to remove. Right?
In general, two connected vertices with a IGRAPH_VCONN_NEI_IGNORE seems to return one too many vertices, but maybe we want to change the docs, not the result.",Sure!,True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2043,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2043#issuecomment-1101438606,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","Codecov Report

Merging #2043 (201c247) into master (dccec45) will increase coverage by 0.12%.
The diff coverage is 66.66%.


@@            Coverage Diff             @@
##           master    #2043      +/-   ##
==========================================
+ Coverage   72.52%   72.65%   +0.12%     
==========================================
  Files         294      294              
  Lines       57600    57698      +98     
==========================================
+ Hits        41777    41921     +144     
+ Misses      15823    15777      -46     



Impacted Files
Coverage Δ





src/community/walktrap/walktrap.cpp
100.00% <ø> (ø)



src/community/walktrap/walktrap_heap.cpp
43.96% <0.00%> (ø)



src/community/walktrap/walktrap_graph.cpp
76.14% <66.66%> (-0.49%)
⬇️


src/community/walktrap/walktrap_communities.cpp
66.66% <70.96%> (+7.43%)
⬆️


src/games/preference.c
88.43% <0.00%> (+6.05%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update dccec45...201c247. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2043#issuecomment-1101483786,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","I am rounding modularity values that are very close to zero to exact zero in the test, otherwise we get slightly different values across platforms (notably between x87 and SSE math).
However, this always affects the last value in the modularity vector, which I think should be zero anyway. This corresponds to a partitioning into connected components, so the modularity is zero. Should we just coerce it to an exact zero directly in the walktrap code, @vtraag ?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2043#issuecomment-1101486646,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","BTW the reason why I changes floats to doubles is so that we can have consistent precision across the library. I would expect a value on the order of 10^-7 to be truly different from zero, while something on the order of 10^-15 is typically the result of roundoff errors. However, if we use float, we have 10^-7 due to roundoff errors.
This change increases memory usage and might decrease performance somewhat (I didn't measure). I'm not too concerned about this. Let me know if you want me to revert it.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2043#issuecomment-1101689436,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.",@ntamas I'd like to get this in before R/igraph 1.3.1.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2043#issuecomment-1102337425,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","However, this always affects the last value in the modularity vector, which I think should be zero anyway. This corresponds to a partitioning into connected components, so the modularity is zero. Should we just coerce it to an exact zero directly in the walktrap code, @vtraag ?

This is not true. The last value is not always zero in disconnected graphs. Ignore my comment please.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/2043#issuecomment-1102370950,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.",Do you still need a review from Vincent or can I merge this?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/vtraag,8,https://github.com/igraph/igraph/pull/2043#issuecomment-1102396841,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","I can take a look now, shouldn't take too long.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/2043#issuecomment-1102400870,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","I think it's fine to merge.
The only theoretical issue here is: are there any uses/interpretations for negative weights that I missed? Is there any reason not to forbid negative weights?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2043#issuecomment-1102401710,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","@vtraag Ah, I just saw your comment. Since you're here, I would prefer that you take a look before merging.",True,{'THUMBS_UP': ['https://github.com/vtraag']}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/vtraag,11,https://github.com/igraph/igraph/pull/2043#issuecomment-1102463225,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","However, this always affects the last value in the modularity vector, which I think should be zero anyway. This corresponds to a partitioning into connected components, so the modularity is zero. Should we just coerce it to an exact zero directly in the walktrap code, @vtraag ?

This is not true. The last value is not always zero in disconnected graphs. Ignore my comment please.

No, this is indeed not the case, as you say. However, modularity is guaranteed to be 0 for a partition consisting of a single community only. This is something that we could do specifically? (We could also do this in the igraph_modularity function.)


I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.


In principle, it would be fine to allow zero weights. It's not directly clear to me though if something will crash currently if it has zero strength? Or will calculations fail to be correct at some point, without it being clear that calculations are incorrect?

The only theoretical issue here is: are there any uses/interpretations for negative weights that I missed? Is there any reason not to forbid negative weights?

I would indeed disallow negative weights, as they don't make sense in the context of modularity.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/2043#issuecomment-1102503151,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","It's not directly clear to me though if something will crash currently if it has zero strength?

I was going to say that in the worst case you get some Inf/NaN, but nothing should blow up.
However, I just did some fuzzing by setting random edge weights, then setting the strength of one vertex to 0, and this is what I found:

By far the most common case where some modularity values are not finite is when we have a star graph, with the star centre having strength zero.
However, very rarely, I get a crash. So something can indeed blow up, but I don't know what yet.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/2043#issuecomment-1102505277,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","If we're short on time because of R/igraph 1.3.1, I would merge as-is and investigate this later. After all, this problem was present in the previous version as well so there's no regression.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/2043#issuecomment-1102506398,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","My fuzzing code, for reference:
n = 7; (* vertex count *)
v = 2; (* strength of v will be set to 0 *)

Do[g = IGTryUntil[ConnectedGraphQ]@
   RandomGraph[BernoulliGraphDistribution[n, 0.5], 
    EdgeWeight -> {_ :> RandomReal[]}, VertexLabels -> Automatic];
 AnnotationValue[{g, IncidenceList[g, v]}, EdgeWeight] = 0;
 cl = IGCommunitiesWalktrap[g];
 mod = cl[""Modularity""];
 If[Not@VectorQ[mod, NumericQ], Break[]],
 {i, Infinity}
 ]
g
InputForm[cl]",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/2043#issuecomment-1102517921,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","ASan:
==99559==ERROR: AddressSanitizer: heap-use-after-free on address 0x607000a24228 at pc 0x00013a8bfbbe bp 0x7ffee03b34c0 sp 0x7ffee03b34b8
READ of size 8 at 0x607000a24228 thread T0
    #0 0x13a8bfbbd in igraph::walktrap::Neighbor_heap::move_down(int) walktrap_heap.cpp:74
    #1 0x13a8c083f in igraph::walktrap::Neighbor_heap::remove(igraph::walktrap::Neighbor*) walktrap_heap.cpp:109
    #2 0x13a8b0cbd in igraph::walktrap::Communities::remove_neighbor(igraph::walktrap::Neighbor*) walktrap_communities.cpp:595
    #3 0x13a8b5736 in igraph::walktrap::Communities::merge_communities(igraph::walktrap::Neighbor*) walktrap_communities.cpp:804
    #4 0x13a8b8062 in igraph::walktrap::Communities::merge_nearest_communities() walktrap_communities.cpp:895
    #5 0x13a8c41f7 in igraph_community_walktrap walktrap.cpp:130
    #6 0x139fd903a in IG::communityWalktrap(MLink*) const (IGraphM.dylib:x86_64+0xb303a)
    #7 0x139fd895f in IG_communityWalktrap (IGraphM.dylib:x86_64+0xb295f)

freed by thread T0 here:
    #0 0x10f8c7b02 in wrap__ZdlPv (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x6eb02)
    #1 0x13a8b6213 in igraph::walktrap::Communities::merge_communities(igraph::walktrap::Neighbor*) walktrap_communities.cpp:812
    #2 0x13a8b8062 in igraph::walktrap::Communities::merge_nearest_communities() walktrap_communities.cpp:895
    #3 0x13a8c41f7 in igraph_community_walktrap walktrap.cpp:130
    #4 0x139fd903a in IG::communityWalktrap(MLink*) const (IGraphM.dylib:x86_64+0xb303a)
    #5 0x139fd895f in IG_communityWalktrap (IGraphM.dylib:x86_64+0xb295f)

previously allocated by thread T0 here:
    #0 0x10f8c7502 in wrap__Znwm (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x6e502)
    #1 0x13a8ab11e in igraph::walktrap::Communities::Communities(igraph::walktrap::Graph*, int, long, igraph_matrix_t*, igraph_vector_t*) walktrap_communities.cpp:446
    #2 0x13a8af39a in igraph::walktrap::Communities::Communities(igraph::walktrap::Graph*, int, long, igraph_matrix_t*, igraph_vector_t*) walktrap_communities.cpp:393
    #3 0x13a8c40bd in igraph_community_walktrap walktrap.cpp:130
    #4 0x139fd903a in IG::communityWalktrap(MLink*) const (IGraphM.dylib:x86_64+0xb303a)
    #5 0x139fd895f in IG_communityWalktrap (IGraphM.dylib:x86_64+0xb295f)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/ntamas,16,https://github.com/igraph/igraph/pull/2043#issuecomment-1102525966,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.",Let's just merge as is and then we can return to this later.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/2043#issuecomment-1102536041,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","I would indeed disallow negative weights, as they don't make sense in the context of modularity.

I didn't even think of modularity, just the interpretation of weights as (non-normalized) probabilities in walktrap.
The spinglass community detection does support negative weights and does compute some sort of modularity. How is this modularity defined then? It should at least be documented.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,18,https://github.com/igraph/igraph/pull/2043#issuecomment-1102542273,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","The crash is likely related to comparisons of the delta_sigma sigma value (since comparison with NaN is always false, ! x < y does not imply x >= y, so assumptions may be broken).",True,{}
igraph/igraph,https://github.com/igraph/igraph,2043,2022-04-18T13:57:27Z,2022-04-19T12:08:43Z,2022-04-19T12:10:10Z,MERGED,True,278,101,11,https://github.com/szhorvat,Walktrap fixes,12,[],https://github.com/igraph/igraph/pull/2043,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/2043#issuecomment-1102547074,"Fixes #2041, fixes #2042
List of fixes, for pasting into the changelog (incomplete):

igraph_community_walktrap() would return an invalid modularity vector when the merges matrix was not requested.
igraph_community_walktrap() would return a modularity vector that was too long for disconnected graphs. This would cause a failure in some weighted graphs when the membership vector was requested.
igraph_community_walktrap() now uses double precision floating point operations internally instead of single precision.
igraph_community_walktrap() now checks the weight vector: only non-negative weights are accepted, and all vertices must have non-zero strength.

Notes:

I decided not to disallow zero weights, even though a vertex with zero strength would cause problems. If all vertices have a positive strength, everything should work fine.
The example program's output is unstable: the input graph is two cliques connected by a single edges. Thus a variety of cluster merge orders are equally valid. I made a small change (added an edge) so that the tests would pass, but keep in mind that this is fragile by nature.","@ntamas Wait a bit with the merge please, I will fix the zero-strength issue in a few min.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,1,https://github.com/igraph/igraph/pull/2046,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2046#issuecomment-1103971079,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Codecov Report

Merging #2046 (4ca4526) into develop (60ec295) will decrease coverage by 0.00%.
The diff coverage is 72.72%.


@@             Coverage Diff             @@
##           develop    #2046      +/-   ##
===========================================
- Coverage    79.79%   79.79%   -0.01%     
===========================================
  Files          364      364              
  Lines        59832    59843      +11     
===========================================
+ Hits         47745    47753       +8     
- Misses       12087    12090       +3     



Impacted Files
Coverage Δ





src/misc/mixing.c
94.73% <ø> (ø)



src/misc/motifs.c
94.74% <ø> (ø)



src/isomorphism/isoclasses.c
88.33% <72.72%> (-1.02%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 60ec295...4ca4526. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2046#issuecomment-1108489271,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Some more explanation:

Why is it so slow? Because tests are run with minimal optimization and a number of debugging options turned on (including address sanitizer and IGRAPH_VERIFY_FINALLY_STACK). That slows them down by 1-2 orders of magnitude.
Why do we want to make it fast even in debug mode? Because we frequently run the test suite while working on igraph, thus having to wait for it has a real productivity cost. Examples are run as part of the test suite.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,4,https://github.com/igraph/igraph/pull/2046#issuecomment-1108529262,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Some more explanation:
* Why is it so slow? Because tests are run with minimal optimization and a number of debugging options turned on (including address sanitizer and `IGRAPH_VERIFY_FINALLY_STACK`). That slow them down by 1-2 orders of magnitude.

* Why do we want to make it fast even in debug mode? Because we frequently run the test suite while working on igraph, thus having to wait for it has a real productivity cost. Examples are run as part of the test suite.


Makes sense. I'll work on it ASAP.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2046#issuecomment-1110255944,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",I resolved the conflict with develop. You'll need to git pull that change to your local repo.,True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,6,https://github.com/igraph/igraph/pull/2046#issuecomment-1111327616,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Cmake fails on building docs. It says /examples/simple/igraph_laplacian.c.xml couldn't be loaded.
Also, test::glpk_error fails with SEGFAULT in the mingw (static, x86_64) build.
How does one usually go about resolving these kind of errors?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/2046#issuecomment-1111335812,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Ignore the glpk_error failure; this happens all the time in the MinGW build, but it's non-deterministic.
As for the docs, I am refactoring the Laplacian functions in develop and something might have creeped in into this branch. I think we could also ignore this failure as it will be solved once we merge this PR into develop.",True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,8,https://github.com/igraph/igraph/pull/2046#issuecomment-1111349447,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Thanks for the contribution! The general approach is good, but this example is too slow. It runs for almost an entire minute on the CI, in debug mode. Can you get it down below 0.1 seconds?
https://dev.azure.com/igraph-team/igraph/_build/results?buildId=3052&view=logs&j=4c3a8381-b9de-5463-904f-918810769be8&t=a906eab8-d2a3-5e54-d199-606dbbfb0805&l=907
The reason is that this graph has a very large number of edges due to using high connection probabilities. Try using a smaller and much sparser graph.

The example now runs for 1-2 seconds.
https://dev.azure.com/igraph-team/igraph/_build/results?buildId=3116&view=logs&j=4c3a8381-b9de-5463-904f-918810769be8&t=a906eab8-d2a3-5e54-d199-606dbbfb0805&l=326",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/2046#issuecomment-1114764913,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Can you please try to reduce the timing to be comparable to most other tests, i.e. on the order of 0.01 seconds? This should be possible here by choosing the graph size and the inter-partition density appropriately.
I'll add some comments on the code to help with this.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2046#issuecomment-1126688303,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","@valdaarhun Please let us know if you're planning to complete this. No problem if you don't have time, I just want to know how to proceed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,11,https://github.com/igraph/igraph/pull/2046#issuecomment-1126689276,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",Hi. I am sorry for not letting you know. I am actually in the middle of my end semester college exams right now. They get over on Friday and then I would definitely like to get back to this issue.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/2046#issuecomment-1126694008,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Good luck with your exams! There's no rush with this PR, we just needed to know how to proceed.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,13,https://github.com/igraph/igraph/pull/2046#issuecomment-1126727261,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Good luck with your exams!

Thank you!",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,14,https://github.com/igraph/igraph/pull/2046#issuecomment-1133182203,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",Hi. My exams are done and I would like to get back to working on this PR.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/ntamas,15,https://github.com/igraph/igraph/pull/2046#issuecomment-1134519886,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",Congrats and welcome back! Please go through the comments by @szhorvat first and address those that need to be addressed; mark the rest as resolved. We can then have another round of reviews.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,16,https://github.com/igraph/igraph/pull/2046#issuecomment-1135428160,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Congrats and welcome back! Please go through the comments by @szhorvat first and address those that need to be addressed; mark the rest as resolved. We can then have another round of reviews.

Ok, thanks. Will do.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,17,https://github.com/igraph/igraph/pull/2046#issuecomment-1136170858,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",The power_law_fit failures on MinGW are known and are not related to what you are doing here. They can be ignored for now. We are investigating the cause of these (they may be due to an issue with GCC 12 in msys2 and not igraph).,True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,18,https://github.com/igraph/igraph/pull/2046#issuecomment-1138281384,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",The test now takes about as much time as the other tests running on the same platform.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/2046#issuecomment-1138300123,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",@valdaarhun Could you please help and update the expected output after the switch from LOOPS to NO_LOOPS?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,20,https://github.com/igraph/igraph/pull/2046#issuecomment-1138300744,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","@valdaarhun Could you please help and update the expected output after the switch from LOOPS to NO_LOOPS?

Sure. I'll do it right away.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,21,https://github.com/igraph/igraph/pull/2046#issuecomment-1138314902,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",I have updated the expected output.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,22,https://github.com/igraph/igraph/pull/2046#issuecomment-1138321193,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",codecov/patch seems to be failing. I haven't understood why that's the case.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/valdaarhun,23,https://github.com/igraph/igraph/pull/2046#issuecomment-1138342777,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.","Thank you. It was nice working on this issue. I got to learn a lot. If it's alright, I would like to also work on igraph_realize_degree_sequence as explained here.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,2046,2022-04-20T13:58:09Z,2022-05-26T09:23:02Z,2022-05-26T09:32:20Z,MERGED,True,159,12,11,https://github.com/valdaarhun,Add example demonstrating igraph_assortativity_nominal to example/simple,27,[],https://github.com/igraph/igraph/pull/2046,https://github.com/szhorvat,24,https://github.com/igraph/igraph/pull/2046#issuecomment-1138344577,"The example demonstrates that graphs with the same vertex types can have different assortativities.
Part of #1931.",Thanks for the contribution! Feel free to go ahead.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2047,2022-04-30T07:05:20Z,2022-05-02T10:44:59Z,2022-05-02T10:44:59Z,MERGED,True,15,43,2,https://github.com/GroteGnoom,Clean up ncol tests,2,[],https://github.com/igraph/igraph/pull/2047,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2047,"fix one: use a fixed filename instead of a temporary file, which gives an amazing amount of problems.
fix two: use print_attributes instead of igraph_write_graph_graphml, to have a much cleaner output.","fix one: use a fixed filename instead of a temporary file, which gives an amazing amount of problems.
fix two: use print_attributes instead of igraph_write_graph_graphml, to have a much cleaner output.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2047,2022-04-30T07:05:20Z,2022-05-02T10:44:59Z,2022-05-02T10:44:59Z,MERGED,True,15,43,2,https://github.com/GroteGnoom,Clean up ncol tests,2,[],https://github.com/igraph/igraph/pull/2047,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2047#issuecomment-1113936564,"fix one: use a fixed filename instead of a temporary file, which gives an amazing amount of problems.
fix two: use print_attributes instead of igraph_write_graph_graphml, to have a much cleaner output.","Codecov Report

Merging #2047 (e51eb8c) into develop (420b8e0) will not change coverage.
The diff coverage is n/a.


@@           Coverage Diff            @@
##           develop    #2047   +/-   ##
========================================
  Coverage    78.41%   78.41%           
========================================
  Files          363      363           
  Lines        59217    59217           
========================================
  Hits         46433    46433           
  Misses       12784    12784           

Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 420b8e0...e51eb8c. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2048,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2048#issuecomment-1114188852,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","Codecov Report

Merging #2048 (2b2dd12) into develop (4a7f04a) will increase coverage by 0.12%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #2048      +/-   ##
===========================================
+ Coverage    78.73%   78.85%   +0.12%     
===========================================
  Files          363      363              
  Lines        59217    59217              
===========================================
+ Hits         46622    46696      +74     
+ Misses       12595    12521      -74     



Impacted Files
Coverage Δ





src/io/dot.c
66.86% <100.00%> (+43.78%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4a7f04a...2b2dd12. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2048#issuecomment-1114647695,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","It looks like GraphViz does not support a missing RHS of a = sign. It errors on VAS=:
dot igraph_write_graph_dot.dot
Error: igraph_write_graph_dot.dot: syntax error in line 16 near '='

The format specs are here: https://graphviz.org/doc/info/lang.html According to me reading, the best way forward may be to just quote all strings for safety, and use """" for empty strings.
It would be useful to test escape sequences. The spec I linked to above says that the only valid escape sequence is \"", but in some old versions \n was also allowed. Could you take a look and see if igraph handles these well?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/ntamas,4,https://github.com/igraph/igraph/pull/2048#issuecomment-1114654348,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","SInce @GroteGnoom is working on igraph mostly during the weekends and I'd rather not let these fixes linger around in a PR, I'm inclined to merge this and we can fix the empty-string-RHS and the quotation issue in another PR. Any objections?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2048#issuecomment-1114654637,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","It looks like igraph_i_dot_escape() only adds quotes when necessary, but I don't understand why. What is the disadvantage of adding quotes when not strictly needed?
Anyway, the simplest change might be to just extend this function to also add quotes when the string is empty.
Additionally, neither \ nor newlines should be escaped according to the specs. Currently, both are escaped by igraph. However, if the string contains a newline, then quotes are necessary. I checked that the dot program handles explicit (unescaped) newlines in quoted strings.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2048#issuecomment-1114655118,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","Any objections?

Make sure it doesn't get forgotten. If you don't have time to fix it now, I suggest opening an issue and assigning it to someone.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/2048#issuecomment-1114656917,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","It looks like igraph_i_dot_escape() only adds quotes when necessary, but I don't understand why. What is the disadvantage of adding quotes when not strictly needed?

Just started to write a comment about this :) It is for making it easier to do quick-and-dirty text processing stuff with awk and sed and stuff where you don't want to bother with un-escaping. It's mostly a philosophical argument but I tend to follow the don't-quote-unless-necessary principle everywhere. (E.g., CSV files are also much easier to parse if you don't quote every cell value).",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/2048#issuecomment-1114657782,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","where you don't want to bother with un-escaping

Is this argument still valid if the only supported escape sequence is \""?
Anyway, since dot also removes unneeded quotes, and we already have code to do the same, let's not change that, just fix the bugs in it.
BTW I checked that ""compass directions"" (see specs) need no quoting.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/2048#issuecomment-1114661083,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","Well, you'd still need to strip the quotes from around the item of interest so I'd rather leave it as is.
Note that making a fully specs-compliant GML parser is probably more work than what we'd like to commit ourselves to. For instance, there's the question of string encoding. GML assumes UTF-8 encoding, so if we really want to be fully specs-compliant, we must escape "" only if it is a glyph on its own and is not part of some other glyph that happens to contain "" in the encoded byte sequence. Also, to complicate things further, an input graph may specify charset: ASCII in a graph attribute, and then we must parse the file as ASCII instead.
Also, this is also in the specs:

Another way to avoid non-ASCII characters in labels is to use HTML entities for special characters. During label evaluation, these entities are translated into the underlying character. This table shows the supported entities, with their Unicode value, a typical glyph, and the HTML entity name.

This is also something that takes a lot of time if we want to get this fully correct.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2048#issuecomment-1114664257,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","Note that making a fully specs-compliant GML parser is probably more work than what we'd like to commit ourselves to.

Do you mean DOT parser? We only have a DOT writer, not a parser/reader. A DOT writer is important to have because it makes it possible to visualize igraph graphs with GraphViz. Parsing is not important for us, as DOT isn't a common exchange format in my experience.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/ntamas,11,https://github.com/igraph/igraph/pull/2048#issuecomment-1114666808,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0","Okay, let me think.  You are probably right; I always mix up GML and DOT and I think I was mostly thinking about GML.
Also, I checked the UTF-8 encoding now, and luckily "" cannot appear in any valid UTF-8 byte sequence except the one that encodes "" itself, so we are okay, we don't need to go any more complicated with escaping as long as we only escape characters with an ASCII code less than 128.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2048,2022-05-01T09:57:30Z,2022-05-02T09:35:29Z,2022-05-02T09:37:45Z,MERGED,True,136,8,4,https://github.com/GroteGnoom,tests: add write_graph_dot,1,[],https://github.com/igraph/igraph/pull/2048,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/2048#issuecomment-1114668832,"There is also an example, but this test also tests the attributes.
Fix one: remove undefined behaviour on NaN
Fix two: do not read out of bounds if orig parameter in
igraph_i_dot_escape has length 0",Related bug filed in #2049,True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/szhorvat,1,https://github.com/igraph/igraph/pull/2059,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)",""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2059#issuecomment-1125883486,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","Codecov Report

Merging #2059 (b043a28) into develop (53308cc) will increase coverage by 0.12%.
The diff coverage is 84.82%.


❗ Current head b043a28 differs from pull request most recent head c1d38c0. Consider uploading reports for the commit c1d38c0 to get more accurate results


@@             Coverage Diff             @@
##           develop    #2059      +/-   ##
===========================================
+ Coverage    79.83%   79.95%   +0.12%     
===========================================
  Files          364      364              
  Lines        59664    60840    +1176     
===========================================
+ Hits         47630    48645    +1015     
- Misses       12034    12195     +161     



Impacted Files
Coverage Δ





src/io/gml.c
89.91% <84.82%> (-1.29%)
⬇️


src/misc/conversion.c
90.62% <0.00%> (-3.21%)
⬇️


src/constructors/adjacency.c
96.63% <0.00%> (-1.79%)
⬇️


src/paths/shortest_paths.c
79.97% <0.00%> (-0.64%)
⬇️


src/layout/fruchterman_reingold.c
48.51% <0.00%> (-0.18%)
⬇️


src/graph/type_indexededgelist.c
96.30% <0.00%> (+0.18%)
⬆️


src/misc/other.c
97.32% <0.00%> (+0.79%)
⬆️


src/properties/spectral.c
94.23% <0.00%> (+7.19%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 53308cc...c1d38c0. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2059#issuecomment-1125906040,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","We could maybe add an option to the writer to disable encoding the & character to &amp;, and only encode "". Then round-tripping through igraph will be fine: it will no longer break unsupported entities.
igraph_error_t igraph_write_graph_gml(const igraph_t *graph, FILE *outstream,
                                      const igraph_vector_t *id, const char *creator,
                                      igraph_bool_t only_encode_quotes);

Instead of a boolean, this option could be implemented through a bit field for future extensibility.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2059#issuecomment-1126690130,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","It still bothers me that reading and re-exporting technically valid files with this would break them by substituting &amp;aacute; for &aacute;.
My preference is to add the option to not encode & on export, and to do it with a bit-field solution for future extensibility, just as we do with igraph_edge_type_sw_t.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/2059#issuecomment-1126725292,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","What is the encoding of igraph string attribute value?

I'd say it's a de facto UTF-8 in the sense that no one claimed officially that it's UTF-8, but we should probably treat it like that as it seems to be the only sensible choice.

Instead of a boolean, this option could be implemented through a bit field for future extensibility.

I think we should have an igraph_gml_options_t and we should also move the creator string and the id vector there, the default being whatever we do now by default. In 99% of the cases I guess you only want to specify the graph and the output file, nothing else.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2059#issuecomment-1132836394,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","I think we should have an igraph_gml_options_t and we should also move the creator string and the id vector there, the default being whatever we do now by default. In 99% of the cases I guess you only want to specify the graph and the output file, nothing else.

What would this achieve?
Using the function is not difficult at the moment. Both creator and id accept NULL. However, in several tests, creator must be set to """" instead of NULL to avoid printing the date. I am concerned that introducing a igraph_gml_options_t would make some use cases significantly more complicated (creator="""") without making the typical usage much simpler.
It also wouldn't allow extensibility without breaking the ABI, so it doesn't really do much in the end. If we want some level of option-extensibility without breaking the ABI, we can use a bitfield (like libxml2), but I'd be happy with a simple boolean too, as I don't expect to want to add much more in the future.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/2059#issuecomment-1132919549,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","As discussed on Zoom with @szhorvat : we'll go ahead with a bit field argument instead of a full igraph_gml_options_t.
@szhorvat I'm marking this as draft; let me know when you're done with it and then I'll merge (or you can do it).",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/2059#issuecomment-1132990783,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","@ntamas Have a look at the stimulus part. I used the arbitrary value DEFAULT, but I don't recall where these are defined (intrerface-specific generator?) and whether the name should be prefixed, e.g. WRITE_GML_DEFAULT.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/2059#issuecomment-1132999229,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","The values are defined in the high-level language specific parts, and there is no need for the prefix, so it's OK.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2059,2022-05-13T10:11:04Z,2022-05-20T14:53:21Z,2022-05-20T14:53:43Z,MERGED,True,241,23,13,https://github.com/szhorvat,Basic character entity support for GML reader/writer,5,[],https://github.com/igraph/igraph/pull/2059,https://github.com/ntamas,10,https://github.com/igraph/igraph/pull/2059#issuecomment-1133002875,""" and & in string attributes values are now encoded to &quot; and &amp;, meaning that "" no longer leads to corrupted (unreadable) GML files.
Decoding support is only added for the five basic predefined entities.
Any other character entities or stray & characters are passed through unchanged, and left to be handled by the user. A warning is issued (at most once per read operation).
This means that if yEd writes an &Eacute; into a GML file, and this file is read in, then written back by igraph, we end up with &amp;Eacute; This is not ideal, but it's too complicated to deal with, and brings in a whole range of unpleasant issues, such as dealing with character encodings. What is the encoding of igraph string attribute values? We would need to make a decision about this before we can decode &Eacute;. (Yes, the GraphML reader is affected by this as well, and it produces consistent UTF-8: I documented this today.)","Awesome, thanks a lot!",True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2067,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.","fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2067#issuecomment-1126740537,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.","Codecov Report

Merging #2067 (9818310) into develop (1bc70e4) will decrease coverage by 0.00%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #2067      +/-   ##
===========================================
- Coverage    79.83%   79.83%   -0.01%     
===========================================
  Files          364      364              
  Lines        59673    59664       -9     
===========================================
- Hits         47639    47630       -9     
  Misses       12034    12034              



Impacted Files
Coverage Δ





src/constructors/adjacency.c
98.41% <100.00%> (-0.05%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 1bc70e4...9818310. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2067#issuecomment-1126810569,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.","I just wanted to note that we haven't actually discussed whether we actually wanted to do what I proposed in #1978.  I never got any feedback on it. Needless to say, I'm in favour :-)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/vtraag,4,https://github.com/igraph/igraph/pull/2067#issuecomment-1126812486,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.","Completely in favour too! I'm fine with simply replacing this function, such that it accepts weights directly instead of attributes.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/2067#issuecomment-1127417468,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.",I'm in favour as well.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/ntamas,6,https://github.com/igraph/igraph/pull/2067#issuecomment-1132772033,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.",I must have caused conflicts for this PR by committing 1bc70e4 so it's my turn to fix it :),True,{}
igraph/igraph,https://github.com/igraph/igraph,2067,2022-05-14T15:45:49Z,2022-05-20T12:23:24Z,2022-05-20T12:23:30Z,MERGED,True,141,98,10,https://github.com/GroteGnoom,return weighted_adjacency weights as a vector,6,[],https://github.com/igraph/igraph/pull/2067,https://github.com/ntamas,7,https://github.com/igraph/igraph/pull/2067#issuecomment-1132840130,"fixes #1978
We should of course still decide if we want this as a separate function. As far as I can tell, the current functionality just shouldn't exist.",Thanks!,True,{}
igraph/igraph,https://github.com/igraph/igraph,2070,2022-05-21T08:18:43Z,2022-05-30T05:31:04Z,2022-05-30T05:31:12Z,MERGED,True,95,90,10,https://github.com/GroteGnoom,Use parent vector of #1880 for get_shortest_paths,3,[],https://github.com/igraph/igraph/pull/2070,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2070,"get_shortest_paths_dijkstra too, because that passes results on to get_shortest_paths if there are no weights.","get_shortest_paths_dijkstra too, because that passes results on to get_shortest_paths if there are no weights.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2070,2022-05-21T08:18:43Z,2022-05-30T05:31:04Z,2022-05-30T05:31:12Z,MERGED,True,95,90,10,https://github.com/GroteGnoom,Use parent vector of #1880 for get_shortest_paths,3,[],https://github.com/igraph/igraph/pull/2070,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2070#issuecomment-1133587443,"get_shortest_paths_dijkstra too, because that passes results on to get_shortest_paths if there are no weights.","Codecov Report

Merging #2070 (9fe73ad) into develop (d91c56a) will decrease coverage by 0.03%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #2070      +/-   ##
===========================================
- Coverage    79.83%   79.79%   -0.04%     
===========================================
  Files          364      364              
  Lines        59769    59832      +63     
===========================================
+ Hits         47718    47745      +27     
- Misses       12051    12087      +36     



Impacted Files
Coverage Δ





src/paths/dijkstra.c
96.72% <100.00%> (ø)



src/paths/unweighted.c
94.14% <100.00%> (ø)



src/math/utils.c
93.93% <0.00%> (-6.07%)
⬇️


src/core/vector.c
74.79% <0.00%> (-5.30%)
⬇️


src/core/matrix.c
94.59% <0.00%> (-3.92%)
⬇️


src/math/complex.c
87.32% <0.00%> (-1.88%)
⬇️


src/io/gml.c
89.29% <0.00%> (-0.63%)
⬇️


src/layout/kamada_kawai.c
47.66% <0.00%> (-0.61%)
⬇️


src/core/matrix.pmt
85.82% <0.00%> (ø)



src/core/vector.pmt
94.27% <0.00%> (ø)



... and 1 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d91c56a...9fe73ad. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2070,2022-05-21T08:18:43Z,2022-05-30T05:31:04Z,2022-05-30T05:31:12Z,MERGED,True,95,90,10,https://github.com/GroteGnoom,Use parent vector of #1880 for get_shortest_paths,3,[],https://github.com/igraph/igraph/pull/2070,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/2070#issuecomment-1134518198,"get_shortest_paths_dijkstra too, because that passes results on to get_shortest_paths if there are no weights.",Thanks a lot! I've renamed some variables and will merge if the CI tests pass.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2070,2022-05-21T08:18:43Z,2022-05-30T05:31:04Z,2022-05-30T05:31:12Z,MERGED,True,95,90,10,https://github.com/GroteGnoom,Use parent vector of #1880 for get_shortest_paths,3,[],https://github.com/igraph/igraph/pull/2070,https://github.com/GroteGnoom,4,https://github.com/igraph/igraph/pull/2070#issuecomment-1140426688,"get_shortest_paths_dijkstra too, because that passes results on to get_shortest_paths if there are no weights.","I re-ran the tests, and they now mostly seem to pass :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2070,2022-05-21T08:18:43Z,2022-05-30T05:31:04Z,2022-05-30T05:31:12Z,MERGED,True,95,90,10,https://github.com/GroteGnoom,Use parent vector of #1880 for get_shortest_paths,3,[],https://github.com/igraph/igraph/pull/2070,https://github.com/ntamas,5,https://github.com/igraph/igraph/pull/2070#issuecomment-1140716364,"get_shortest_paths_dijkstra too, because that passes results on to get_shortest_paths if there are no weights.","Merged, thanks!",True,{}
igraph/igraph,https://github.com/igraph/igraph,2071,2022-05-21T08:41:04Z,2022-05-21T09:13:21Z,2022-05-21T09:13:21Z,MERGED,True,6,1,1,https://github.com/GroteGnoom,fix: make tree_game_loop_erased_random_walk overflow-safe,1,[],https://github.com/igraph/igraph/pull/2071,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2071,part of #51,part of #51,True,{}
igraph/igraph,https://github.com/igraph/igraph,2071,2022-05-21T08:41:04Z,2022-05-21T09:13:21Z,2022-05-21T09:13:21Z,MERGED,True,6,1,1,https://github.com/GroteGnoom,fix: make tree_game_loop_erased_random_walk overflow-safe,1,[],https://github.com/igraph/igraph/pull/2071,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2071#issuecomment-1133573980,part of #51,"Codecov Report

Merging #2071 (62b51d5) into develop (d91c56a) will increase coverage by 0.00%.
The diff coverage is 100.00%.


@@           Coverage Diff            @@
##           develop    #2071   +/-   ##
========================================
  Coverage    79.83%   79.83%           
========================================
  Files          364      364           
  Lines        59769    59770    +1     
========================================
+ Hits         47718    47719    +1     
  Misses       12051    12051           



Impacted Files
Coverage Δ





src/games/tree.c
94.00% <100.00%> (+0.12%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update d91c56a...62b51d5. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2072,2022-05-21T12:13:45Z,,2022-06-04T09:58:59Z,OPEN,False,793,26,7,https://github.com/GroteGnoom,Add igraph_sparse_adjacency,12,[],https://github.com/igraph/igraph/pull/2072,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2072,"includes the weighted counterpart.
Fixes #1838
issues:

Some functions call igraph_sparsemat_index in the inner loop, and that seems like it will be slow.
src/core/sparsemat.c defines CS_LONG 1 before including cs/cs.h. Should every source file that includes cs do this? Maybe this should be in igraph_sparsemat.h?","includes the weighted counterpart.
Fixes #1838
issues:

Some functions call igraph_sparsemat_index in the inner loop, and that seems like it will be slow.
src/core/sparsemat.c defines CS_LONG 1 before including cs/cs.h. Should every source file that includes cs do this? Maybe this should be in igraph_sparsemat.h?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2072,2022-05-21T12:13:45Z,,2022-06-04T09:58:59Z,OPEN,False,793,26,7,https://github.com/GroteGnoom,Add igraph_sparse_adjacency,12,[],https://github.com/igraph/igraph/pull/2072,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2072#issuecomment-1133871564,"includes the weighted counterpart.
Fixes #1838
issues:

Some functions call igraph_sparsemat_index in the inner loop, and that seems like it will be slow.
src/core/sparsemat.c defines CS_LONG 1 before including cs/cs.h. Should every source file that includes cs do this? Maybe this should be in igraph_sparsemat.h?","Codecov Report

Merging #2072 (88fab78) into develop (81636d1) will increase coverage by 0.31%.
The diff coverage is 97.85%.


@@             Coverage Diff             @@
##           develop    #2072      +/-   ##
===========================================
+ Coverage    79.79%   80.11%   +0.31%     
===========================================
  Files          364      364              
  Lines        59859    60189     +330     
===========================================
+ Hits         47763    48218     +455     
+ Misses       12096    11971     -125     



Impacted Files
Coverage Δ





src/constructors/adjacency.c
98.12% <97.85%> (-0.29%)
⬇️


src/community/walktrap/walktrap_communities.cpp
67.14% <0.00%> (-0.18%)
⬇️


src/random/random.c
77.46% <0.00%> (-0.17%)
⬇️


src/misc/degree_sequence.cpp
94.96% <0.00%> (ø)



src/core/sparsemat.c
82.88% <0.00%> (+0.27%)
⬆️


src/layout/kamada_kawai.c
88.78% <0.00%> (+41.12%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 81636d1...88fab78. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/pradkrish,1,https://github.com/igraph/igraph/pull/2079,Partially fixes #2027,Partially fixes #2027,True,{}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/szhorvat,2,https://github.com/igraph/igraph/pull/2079#issuecomment-1138967272,Partially fixes #2027,"Please check carefully the wiki page I linked: https://github.com/igraph/igraph/wiki/Quickstart-for-new-contributors
PRs should only be opened against the develop branch. We do not add new features on master at this time.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/2079#issuecomment-1138970842,Partially fixes #2027,"Codecov Report

Merging #2079 (953eb0a) into master (418d614) will increase coverage by 0.00%.
The diff coverage is 86.66%.


❗ Current head 953eb0a differs from pull request most recent head 5165166. Consider uploading reports for the commit 5165166 to get more accurate results


@@           Coverage Diff           @@
##           master    #2079   +/-   ##
=======================================
  Coverage   72.63%   72.63%           
=======================================
  Files         294      294           
  Lines       58077    58076    -1     
=======================================
+ Hits        42183    42186    +3     
+ Misses      15894    15890    -4     



Impacted Files
Coverage Δ





src/paths/distances.c
96.29% <86.66%> (-2.19%)
⬇️


src/core/psumtree.c
100.00% <0.00%> (ø)



src/games/barabasi.c
80.20% <0.00%> (+0.27%)
⬆️


src/games/citations.c
89.17% <0.00%> (+0.97%)
⬆️


src/games/recent_degree.c
92.70% <0.00%> (+1.21%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 418d614...5165166. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2079#issuecomment-1139415101,Partially fixes #2027,"FYI the test failures with MinGW are not related to your code, and have just been worked around master and develop. After you rebase this on develop (or open a new PR against develop), this annoyance will be gone.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/pradkrish,5,https://github.com/igraph/igraph/pull/2079#issuecomment-1139694554,Partially fixes #2027,"FYI the test failures with MinGW are not related to your code, and have just been worked around master and develop. After you rebase this on develop (or open a new PR against develop), this annoyance will be gone.

Yeah, it was an oversight on my part, I thought I was on develop branch. Also, it looks like the unit tests I have added is not building as part of the test suite.. I have added it to tests/CMakeList.txt. Am I missing something here?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2079#issuecomment-1139710219,Partially fixes #2027,"Also, it looks like the unit tests I have added is not building as part of the test suite..

Yes, is it, I can see igraph_center in the CTest output on the CI.",True,{'THUMBS_UP': ['https://github.com/pradkrish']}
igraph/igraph,https://github.com/igraph/igraph,2079,2022-05-26T18:18:59Z,2022-05-27T19:51:00Z,2022-05-27T19:51:32Z,CLOSED,False,63682,46490,1131,https://github.com/pradkrish,Use eccentricity to find graph centres,1396,[],https://github.com/igraph/igraph/pull/2079,https://github.com/pradkrish,7,https://github.com/igraph/igraph/pull/2079#issuecomment-1139976270,Partially fixes #2027,"That doesn't look good at all, best to abandon this and open a new PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/ntamas,1,https://github.com/igraph/igraph/pull/2081,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/ntamas,2,https://github.com/igraph/igraph/pull/2081#issuecomment-1139504289,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","I've requested an explicit review from @szhorvat because he is the owner of the issues that this PR is supposed to fix, but reviews and comments from @vtraag and @GroteGnoom are also appreciated.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/apps/codecov,3,https://github.com/igraph/igraph/pull/2081#issuecomment-1139506682,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Codecov Report

Merging #2081 (ad51a49) into develop (08f578b) will increase coverage by 0.12%.
The diff coverage is 98.71%.


@@             Coverage Diff             @@
##           develop    #2081      +/-   ##
===========================================
+ Coverage    80.00%   80.13%   +0.12%     
===========================================
  Files          364      365       +1     
  Lines        59863    59896      +33     
===========================================
+ Hits         47896    47996     +100     
+ Misses       11967    11900      -67     



Impacted Files
Coverage Δ





src/random/random.c
85.63% <97.95%> (+8.16%)
⬆️


src/games/degree_sequence_vl/gengraph_random.h
40.00% <100.00%> (ø)



src/random/rng_glibc2.c
100.00% <100.00%> (ø)



src/random/rng_mt19937.c
100.00% <100.00%> (ø)



src/random/rng_pcg32.c
100.00% <100.00%> (ø)



src/random/rng_pcg64.c
100.00% <100.00%> (ø)



vendor/plfit/mt.c
83.87% <100.00%> (ø)



src/games/correlated.c
75.86% <0.00%> (-7.76%)
⬇️


src/community/fluid.c
92.55% <0.00%> (-2.13%)
⬇️


src/linalg/eigen.c
71.65% <0.00%> (-1.05%)
⬇️


... and 16 more






Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 08f578b...ad51a49. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2081#issuecomment-1139580215,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","I don't know whether ICC and other esoteric compilers


No problem with ICC.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2081#issuecomment-1140461286,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Is the static functionigraph_i_rng_get_uint64() kept intentionally, or is it a an accidental leftover? It is never used.
Within the implementation of igraph_i_rng_get_uint64_bounded(), can we use igraph_i_rng_get_uint64 instead of igraph_i_rng_get_uint, even if it doesn't currently make a difference? The fact that uint is the same size as uint64 when this part of the code is active is ""hidden"".",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2081#issuecomment-1140472092,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Implementing a 64-bit PCG (or rather borrowing it from https://github.com/imneme/pcg-c) would be a nice test of the functionality, since now it's only tested with 32-bit generators.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,7,https://github.com/igraph/igraph/pull/2081#issuecomment-1140472870,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","It would be useful to do a benchmark and see if we lost any performance with this update. For example, see how long it takes to generate n random integers in a range, or n random reals in a range, or test the function igraph_tree_game() with method IGRAPH_RANDOM_LERW for a realistic but RNG-heavy use case.
Basic integer benchmark:
    RNG_BEGIN();

    long s = 0;
    for (long i=0; i < 1L << 28; i++) {
        s += RNG_INTEGER(56,78979);
    }
    printf(""%ld\n"", s);

    RNG_END();

Timing jumps from 2.3 (develop) to 2.5 (this branch) seconds on my machine. On the other hand, it comes down to 2.0 with PCG32.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/2081#issuecomment-1140509144,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","I pushed a proof of concept of (mostly) getting rid of ldexp(). We can revert this if you disagree, this is just to show how it might work.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,9,https://github.com/igraph/igraph/pull/2081#issuecomment-1140727477,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","An alternative, which I think I like better, is to tabulate the negative integer powers of 2 up to -64 and use them. This is just as fast as the solution I pushed, but doesn't involve that extra field in igraph_rng_t.
I'd suggest going with this one.
/* neg_pow2[k] = 2^-k for k = 0 .. 64 */
const igraph_real_t neg_pow2[] = {
    1., 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 
    0.001953125, 0.0009765625, 0.00048828125, 0.000244140625, 0.0001220703125, 
    0.00006103515625, 0.000030517578125, 0.0000152587890625, 7.62939453125e-6, 
    3.814697265625e-6, 1.9073486328125e-6, 9.5367431640625e-7, 4.76837158203125e-7, 
    2.384185791015625e-7, 1.1920928955078125e-7, 5.9604644775390625e-8, 2.9802322387695312e-8, 
    1.4901161193847656e-8, 7.4505805969238281e-9, 3.7252902984619141e-9, 1.862645149230957e-9,
     9.3132257461547852e-10, 4.6566128730773926e-10, 2.3283064365386963e-10, 1.1641532182693481e-10, 
    5.8207660913467407e-11, 2.9103830456733704e-11, 1.4551915228366852e-11, 7.2759576141834259e-12, 
    3.637978807091713e-12, 1.8189894035458565e-12, 9.0949470177292824e-13, 4.5474735088646412e-13, 
    2.2737367544323206e-13, 1.1368683772161603e-13, 5.6843418860808015e-14, 2.8421709430404007e-14, 
    1.4210854715202004e-14, 7.1054273576010019e-15, 3.5527136788005009e-15, 1.7763568394002505e-15, 
    8.8817841970012523e-16, 4.4408920985006262e-16, 2.2204460492503131e-16, 1.1102230246251565e-16, 
    5.5511151231257827e-17, 2.7755575615628914e-17, 1.3877787807814457e-17, 6.9388939039072284e-18, 
    3.4694469519536142e-18, 1.7347234759768071e-18, 8.6736173798840355e-19, 4.3368086899420177e-19, 
    2.1684043449710089e-19, 1.0842021724855044e-19, 5.4210108624275222e-20
};
These are in decimal format since MSVC doesn't support hexadecimal floating point notation. There are enough digits here to make these exact.

Yet another possibility is something like this:
(igraph_real_t) type->get(rng->state) / ((igraph_uint_t) 2 << type->bits)
This is actually markedly slower, but not as slow as calling ldexp every time. Also, it doesn't work for 64 bits.

If you were wondering about pow, it calls ldexp internally on my system.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,10,https://github.com/igraph/igraph/pull/2081#issuecomment-1140760651,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Final suggestion (along with neg_pow2 from above):
        igraph_real_t r = 0.0;
        uint8_t b = 0;
        while (b < DBL_MANT_DIG-1) {
            r += type->get(rng->state);
            r *= neg_pow2[type->bits];
            b += type->bits;
        }
        return r;
This fills up all 52 digits of a double (instead of just 32), and will therefore make two calls to the RNG, and be slower. My benchmark runs in ~3.5 s with this compared to ~2.8 s with the original and 2.2 with the same solution as here but using only 32 bits for random reals.
This would also require an update of some test outputs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,11,https://github.com/igraph/igraph/pull/2081#issuecomment-1140772757,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","I pushed the above solution, again as a proof of concept. This one only has 32 bit enabled so the tests wouldn't need to be updated before we agree on which way to go.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/ntamas,12,https://github.com/igraph/igraph/pull/2081#issuecomment-1140947032,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Is the static function igraph_i_rng_get_uint64() kept intentionally, or is it a an accidental leftover? It is never used

It should have been used in igraph_i_rng_get_uint64_bounded(), well spotted. I'll fix that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,13,https://github.com/igraph/igraph/pull/2081#issuecomment-1140997467,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Here's another thought:
At this moment, we do not allow the bounded integer generator to be overridden (unlike the various real generators). Maybe (I'm not sure yet myself) it would be useful to allow this. Here's why.
Our bounded integer generator is implemented in such a way that it will typically be faster for narrow ranges than wide ranges, simply because wide ranges may require more than one call to the RNG. It is plausible that the same is true for the bounded integer generators of some high-level languages.  Some high-level languages may not expose the raw RNG, only the bounded integer generator, meaning that that's the only thing we can hook up to igraph. If we use a wide range to supply the ""raw"" random values to igraph, then we lose performance even when igraph is generating numbers only for a narrow range.
We should take a careful look at some high-level languages (perhaps including those that don't have interfaces yet, such as Julia, Ruby or Perl), and see if they expose their raw random bit generator.
I checked Mathematica, and this is the performance of generating 100 million random integers in the range [0, 2^bits - 1]. As you can see, the larger the integers, the slower the function:

res = Table[
   {k, First@Timing[RandomInteger[{0, 2^k - 1}, 100000000];]},
   {k, 1, 63} (* go only up to 63 to ensure we're working with machine integers, not with bigints *)
];

ListPlot[res, Frame -> True, FrameLabel -> {""bits"", ""timing (s)""}, PlotTheme -> ""Detailed""]
Do you know what is the situation with Python and R, @ntamas?
Maybe we really should allow the integer generator to be overridden, but make it clear in the docs that you better know what you're doing before going ahead with this, and that you must ensure to cover the whole range of igraph_integer_t.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/2081#issuecomment-1141000958,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Something different:
If we are considering moving to PCG32, it might be best to do it for 0.10 (but only after this PR, so as not to introduce a lot of noise from updating test outputs). 0.10 will change the output from the RNG anyway. It's better to do this once for 0.10 rather than twice (also for 0.11).",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,15,https://github.com/igraph/igraph/pull/2081#issuecomment-1141002939,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Yet another comment:
We have code for generating numbers from a Poisson distribution. This is used internally for the geometric distribution. I would suggest exposing the Poisson generator, and make it overridable (since R provides this). Poisson distributions are likely to be useful to combinatorial problems, which igraph deals with. Since we're making significant changes to the RNG infrastructure, now is the time to do this.
Once again, this can be done after this PR was merged.",True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,16,https://github.com/igraph/igraph/pull/2081#issuecomment-1141006259,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","UPDATE: Done.
On the topic of overridable generators:
The geometric distribution generator is overridable. ""Geometric distribution"" can mean two slightly different things, as explained on Wikipedia. igraph and Mathematica use different definitions and this always confuses me. We need to expand the documentation and provide a clear definition and a warning (in case a user would override this generator with an incompatible one).
This is just a small doc TODO item that I wanted to write down before I forgot.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/ntamas,17,https://github.com/igraph/igraph/pull/2081#issuecomment-1141011062,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Do you know what is the situation with Python and R, @ntamas?

Python has random.randint(), but the documentation says that it relies on random.random(), which generates a random 53-bit double in the range [0, 1), using an underlying Mersenne Twister generator. We will be jumping through extra hoops anyway if we use the Python RNG, but it seems like we'd be using one less hoop if we allowed the developer of a custom igraph RNG type to override the behaviour of igraph_rng_get_integer().
R also has its own function to generate uniform integers; I don't know how it works under the hood, but it makes sense to allow RNG types to use as much of the host language as possible.",True,{'THUMBS_UP': ['https://github.com/szhorvat']}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/ntamas,18,https://github.com/igraph/igraph/pull/2081#issuecomment-1141040875,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.",PCG implementation replaced with the dual-licensed one. I have to go now but I'll continue later and add PCG-64.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,19,https://github.com/igraph/igraph/pull/2081#issuecomment-1141165500,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","Update: Done
TODO:
We have a failure with the Intel compiler.
igraph/src/random/pcg/pcg_variants.h(49): error: #error directive: Nonstandard GNU inlining semantics. Compile with -std=c99 or better.
      #error Nonstandard GNU inlining semantics. Compile with -std=c99 or better.

__GNUC_GNU_INLINE__ is defined by icc if compiling with -std=gnu99 (which is CMake's default, possibly needed by and definitely beneficial to igraph) but not when compiling with -std=c99.
UPDATE: This may be a bug in ICC and we'll need to verify what the actual behaviour is.
There are two macros: __GNUC_GNU_INLINE__, __GNUC_STDC_INLINE__. My understanding is that their defined status should be mutually exclusive. With GCC it seems to be, but with ICC it is not.
#include <stdio.h>

int main() {
#if __GNUC_STDC_INLINE__
        printf(""std\n"");
#endif
#if __GNUC_GNU_INLINE__
        printf(""gnu\n"");
#endif
    return 0;
}
> icc -std=gnu89 x.c && ./a.out 
gnu

> icc -std=gnu99 x.c && ./a.out 
std
gnu

> icc -std=c99 x.c && ./a.out 
std

> gcc -std=gnu89 x.c && ./a.out 
gnu

> gcc -std=gnu99 x.c && ./a.out 
std

> gcc -std=c99 x.c && ./a.out 
std

Note that the lack of  __GNUC_STDC_INLINE__ does not indicate C99 non-conformance. It might indicate that the compiler is something else than GCC. Also note that ICC emulates both GCC and MSVC (on Unix and Windows, respectively) so anything that's conditional on ICC must be written in an MSVC-compatible way.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,20,https://github.com/igraph/igraph/pull/2081#issuecomment-1141190705,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.",Tried to add a workaround above. I did not use defined() in case ICC starts to define this macro to 0 instead of 1.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/ntamas,21,https://github.com/igraph/igraph/pull/2081#issuecomment-1142659924,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.",I think all the comments / suggestions have been addressed. Time for another round of reviews?,True,{}
igraph/igraph,https://github.com/igraph/igraph,2081,2022-05-27T10:46:04Z,,2022-06-05T13:04:24Z,OPEN,False,5524,1951,91,https://github.com/ntamas,RNG refactoring for 0.10,89,[],https://github.com/igraph/igraph/pull/2081,https://github.com/szhorvat,22,https://github.com/igraph/igraph/pull/2081#issuecomment-1142684464,"This PR makes significant modifications to igraph's RNG machinery to satisfy the requirements outlined in issues #1981, #1986, #1987 and #1988. I'd appreciate a careful review because this affects critical parts of igraph.
In particular:

long int is banished from the public RNG interface, we use igraph_integer_t instead.
igraph_uint_t was added to cater for RNG needs where we need a type that has the same size as igraph_integer_t but is unsigned.
Care has been taken to ensure that the RNG behaves the same way on 32-bit and 64-bit platforms as long as the user does not start requesting integers with a range larger than what would fit in a 32-bit number.
min and max were removed from the RNG interface, we now simply require RNG implementors to specify how many bits of randomness they can generate in a single round, and we derive max from that. (min is always zero).
Casts to doubles were removed from igraph_rng_get_integer() because doubles cannot represent integers exactly if the integer is larger than 2^53-1.
64-bit igraph now requires either support for __uint128_t (provided by gcc and clang) or access to the _umul128 intrinsic (provided by MSVC) to ensure unbiased sampling from large integer ranges. I don't know whether ICC and other esoteric compilers support these or not so some help is needed with the testing there.
PCG32 has been added as an alternative RNG; we might switch to PCG32 in future versions as it seems to be a better fit overall than Mersenne Twister.","TODO list:

 We had a slight disagreement about full-precision unif01() sampling. We can perhaps discuss at the next meeting.
 RNG_POIS() needs to be included in the random_sampling test.
 The changelog will need a careful update after everything else is done.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,1,https://github.com/igraph/igraph/pull/2084,partially fixes #2027,partially fixes #2027,True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2084#issuecomment-1140073330,partially fixes #2027,"Codecov Report

Merging #2084 (db09f45) into develop (4700cd8) will increase coverage by 0.25%.
The diff coverage is 100.00%.


@@             Coverage Diff             @@
##           develop    #2084      +/-   ##
===========================================
+ Coverage    79.79%   80.05%   +0.25%     
===========================================
  Files          364      364              
  Lines        59859    59877      +18     
===========================================
+ Hits         47763    47933     +170     
+ Misses       12096    11944     -152     



Impacted Files
Coverage Δ





src/paths/distances.c
99.68% <100.00%> (+0.01%)
⬆️


src/community/walktrap/walktrap_communities.cpp
67.14% <0.00%> (-0.18%)
⬇️


src/random/random.c
77.46% <0.00%> (-0.17%)
⬇️


src/misc/degree_sequence.cpp
94.96% <0.00%> (ø)



src/paths/unweighted.c
94.68% <0.00%> (+0.53%)
⬆️


src/paths/bellman_ford.c
92.53% <0.00%> (+10.94%)
⬆️


src/layout/kamada_kawai.c
88.78% <0.00%> (+41.12%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4700cd8...db09f45. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,3,https://github.com/igraph/igraph/pull/2084#issuecomment-1140204354,partially fixes #2027,@szhorvat  this is ready for review.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2084#issuecomment-1140206336,partially fixes #2027,"Next time you can use the ""ready for review"" button (merging is disabled until the PR is marked as a draft).",True,{'THUMBS_UP': ['https://github.com/pradkrish']}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/szhorvat,5,https://github.com/igraph/igraph/pull/2084#issuecomment-1142610111,partially fixes #2027,"Can you please mark all of the addressed changes as ""resolved""? Just use this button:

When you feel that the PR is ready, just write a comment and someone will take a look.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,6,https://github.com/igraph/igraph/pull/2084#issuecomment-1143149350,partially fixes #2027,"Can you please mark all of the addressed changes as ""resolved""? Just use this button:

When you feel that the PR is ready, just write a comment and someone will take a look.

Thanks, will do. I thought it's up to the reviewer to ""resolve conversation"" based upon how convinced they are with changes. Now I know :)",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,7,https://github.com/igraph/igraph/pull/2084#issuecomment-1143152069,partially fixes #2027,This PR is ready for review.,True,{'THUMBS_UP': ['https://github.com/ntamas']}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/szhorvat,8,https://github.com/igraph/igraph/pull/2084#issuecomment-1143274517,partially fixes #2027,"Thanks, it looks good!
One little thing is to add the function to the docs in doc/structural.xxml, but I can take care of this later today and then merge.
Do you have any questions about the technical aspects of igraph so far? If not, you can go ahead with the Turán graph.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/ntamas,9,https://github.com/igraph/igraph/pull/2084#issuecomment-1143381992,partially fixes #2027,"I thought it's up to the reviewer to ""resolve conversation"" based upon how convinced they are with changes. Now I know :)

I think it's ultimately a matter of taste and habit. I tend to press the ""resolve conversation"" button myself if I resolved trivial things in the PR but leave it open if I'm not sure whether the reviewer will be satisfied with my solution.",True,{'THUMBS_UP': ['https://github.com/pradkrish']}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,10,https://github.com/igraph/igraph/pull/2084#issuecomment-1143532367,partially fixes #2027,"Thanks, it looks good!
One little thing is to add the function to the docs in doc/structural.xxml, but I can take care of this later today and then merge.
Do you have any questions about the technical aspects of igraph so far? If not, you can go ahead with the Turán graph.

Thanks. Please go ahead, add it to the docs and merge. I would like to implement igraph_graph_periphery next before moving on to Turan graph. It must be pretty much similar to the current PR.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,11,https://github.com/igraph/igraph/pull/2084#issuecomment-1143584452,partially fixes #2027,I have pushed another commit with the function added to the docs.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/szhorvat,12,https://github.com/igraph/igraph/pull/2084#issuecomment-1143586763,partially fixes #2027,"It won't quite be the same. Here we made the choice to compute the central vertices per component. If we want the same behaviour from the periphery calculation, then we can't just select vertices with eccentricity equal to the maximum within the entire graph. Instead, we would need to find the maximum for each component, and make the comparison with that.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,13,https://github.com/igraph/igraph/pull/2084#issuecomment-1143652015,partially fixes #2027,"by component, do you mean a connected subgraph?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/szhorvat,14,https://github.com/igraph/igraph/pull/2084#issuecomment-1143659774,partially fixes #2027,"Yes, but I'm simply trying to find a way to make the periphery calculation consistent with the existing centre calculation for the disconnected case. Now I realize that this is not so simple for the directed case. We'll have to think this through carefully before proceeding.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2084,2022-05-27T19:50:32Z,2022-06-06T16:59:23Z,2022-06-06T16:59:23Z,MERGED,True,198,0,6,https://github.com/pradkrish,Centre vertices of a graph,10,[],https://github.com/igraph/igraph/pull/2084,https://github.com/pradkrish,15,https://github.com/igraph/igraph/pull/2084#issuecomment-1143779923,partially fixes #2027,"Yes, but I'm simply trying to find a way to make the periphery calculation consistent with the existing centre calculation for the disconnected case. Now I realize that this is not so simple for the directed case. We'll have to think this through carefully before proceeding.

For the disconnected case like this igraph_small(&g, 4, IGRAPH_UNDIRECTED, -1) eccentricity per component will be zero. If we were implement periphery similar to centre, the central and peripheral vertices end up being the same. Is this one of the potential problem you are thinking of?",True,{}
igraph/igraph,https://github.com/igraph/igraph,2085,2022-05-28T10:25:33Z,2022-05-28T18:51:30Z,2022-05-29T14:21:14Z,MERGED,True,161,11,4,https://github.com/GroteGnoom,add layout_kamada_kawai unit tests,2,[],https://github.com/igraph/igraph/pull/2085,https://github.com/GroteGnoom,1,https://github.com/igraph/igraph/pull/2085,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2085,2022-05-28T10:25:33Z,2022-05-28T18:51:30Z,2022-05-29T14:21:14Z,MERGED,True,161,11,4,https://github.com/GroteGnoom,add layout_kamada_kawai unit tests,2,[],https://github.com/igraph/igraph/pull/2085,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2085#issuecomment-1140231123,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,"Codecov Report

Merging #2085 (d7068cb) into develop (81636d1) will increase coverage by 0.21%.
The diff coverage is 0.00%.


❗ Current head d7068cb differs from pull request most recent head 5bb8892. Consider uploading reports for the commit 5bb8892 to get more accurate results


@@             Coverage Diff             @@
##           develop    #2085      +/-   ##
===========================================
+ Coverage    79.79%   80.00%   +0.21%     
===========================================
  Files          364      364              
  Lines        59859    59859              
===========================================
+ Hits         47763    47893     +130     
+ Misses       12096    11966     -130     



Impacted Files
Coverage Δ





src/layout/kamada_kawai.c
88.16% <0.00%> (+40.49%)
⬆️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 81636d1...5bb8892. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2085,2022-05-28T10:25:33Z,2022-05-28T18:51:30Z,2022-05-29T14:21:14Z,MERGED,True,161,11,4,https://github.com/GroteGnoom,add layout_kamada_kawai unit tests,2,[],https://github.com/igraph/igraph/pull/2085,https://github.com/ntamas,3,https://github.com/igraph/igraph/pull/2085#issuecomment-1140313393,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,"Thanks! (And with this PR, coverage passes 80% for the first time ever).",True,{'HOORAY': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,2085,2022-05-28T10:25:33Z,2022-05-28T18:51:30Z,2022-05-29T14:21:14Z,MERGED,True,161,11,4,https://github.com/GroteGnoom,add layout_kamada_kawai unit tests,2,[],https://github.com/igraph/igraph/pull/2085,https://github.com/szhorvat,4,https://github.com/igraph/igraph/pull/2085#issuecomment-1140320956,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,Could you please include one more test for a graph with two connected vertices? I fixed a bug recently for this case.,True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,2085,2022-05-28T10:25:33Z,2022-05-28T18:51:30Z,2022-05-29T14:21:14Z,MERGED,True,161,11,4,https://github.com/GroteGnoom,add layout_kamada_kawai unit tests,2,[],https://github.com/igraph/igraph/pull/2085,https://github.com/GroteGnoom,5,https://github.com/igraph/igraph/pull/2085#issuecomment-1140414656,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,"278904e
If I chose a ridiculous kkconst I could get the result out of the bounding box, but I can't really find any NaNs.
Edit: it does fail on x86_64 MinGW",True,{}
igraph/igraph,https://github.com/igraph/igraph,2085,2022-05-28T10:25:33Z,2022-05-28T18:51:30Z,2022-05-29T14:21:14Z,MERGED,True,161,11,4,https://github.com/GroteGnoom,add layout_kamada_kawai unit tests,2,[],https://github.com/igraph/igraph/pull/2085,https://github.com/szhorvat,6,https://github.com/igraph/igraph/pull/2085#issuecomment-1140459231,Based on the fruchterman_reingold tests. When I printed out the values they also seemed ok.,"Thanks for the test expansion! I wouldn't put extreme values for kkconst. The problem appeared with the default value as well. Let's just put a reasonable value there, and keep the test as is otherwise.",True,{'THUMBS_UP': ['https://github.com/GroteGnoom']}
igraph/igraph,https://github.com/igraph/igraph,2086,2022-05-29T20:13:18Z,2022-05-30T07:42:59Z,2022-05-30T07:54:24Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Example on assortativites using igraph_realize_degree_sequence,4,[],https://github.com/igraph/igraph/pull/2086,https://github.com/valdaarhun,1,https://github.com/igraph/igraph/pull/2086,This example demonstrates differences in assortativities of graphs having the same degree sequence but different linkages. Based on this comment.,This example demonstrates differences in assortativities of graphs having the same degree sequence but different linkages. Based on this comment.,True,{}
igraph/igraph,https://github.com/igraph/igraph,2086,2022-05-29T20:13:18Z,2022-05-30T07:42:59Z,2022-05-30T07:54:24Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Example on assortativites using igraph_realize_degree_sequence,4,[],https://github.com/igraph/igraph/pull/2086,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2086#issuecomment-1140518005,This example demonstrates differences in assortativities of graphs having the same degree sequence but different linkages. Based on this comment.,"Codecov Report

Merging #2086 (53cac0f) into develop (4061ced) will not change coverage.
The diff coverage is n/a.


❗ Current head 53cac0f differs from pull request most recent head ff8f2fa. Consider uploading reports for the commit ff8f2fa to get more accurate results


@@           Coverage Diff            @@
##           develop    #2086   +/-   ##
========================================
  Coverage    80.01%   80.01%           
========================================
  Files          364      364           
  Lines        59859    59859           
========================================
  Hits         47895    47895           
  Misses       11964    11964           



Impacted Files
Coverage Δ





src/misc/degree_sequence.cpp
94.96% <ø> (ø)





Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update 4061ced...ff8f2fa. Read the comment docs.",True,{}
igraph/igraph,https://github.com/igraph/igraph,2086,2022-05-29T20:13:18Z,2022-05-30T07:42:59Z,2022-05-30T07:54:24Z,MERGED,True,48,0,4,https://github.com/valdaarhun,Example on assortativites using igraph_realize_degree_sequence,4,[],https://github.com/igraph/igraph/pull/2086,https://github.com/szhorvat,3,https://github.com/igraph/igraph/pull/2086#issuecomment-1140814519,This example demonstrates differences in assortativities of graphs having the same degree sequence but different linkages. Based on this comment.,Thanks for the contribution!,True,{'THUMBS_UP': ['https://github.com/valdaarhun']}
igraph/igraph,https://github.com/igraph/igraph,2088,2022-06-04T16:23:51Z,,2022-06-05T07:31:43Z,OPEN,False,180,0,5,https://github.com/pradkrish,Complete multipartite generator,6,[],https://github.com/igraph/igraph/pull/2088,https://github.com/pradkrish,1,https://github.com/igraph/igraph/pull/2088,fixes #1875,fixes #1875,True,{}
igraph/igraph,https://github.com/igraph/igraph,2088,2022-06-04T16:23:51Z,,2022-06-05T07:31:43Z,OPEN,False,180,0,5,https://github.com/pradkrish,Complete multipartite generator,6,[],https://github.com/igraph/igraph/pull/2088,https://github.com/apps/codecov,2,https://github.com/igraph/igraph/pull/2088#issuecomment-1146756620,fixes #1875,"Codecov Report

Merging #2088 (073d19f) into develop (fe14f74) will increase coverage by 0.00%.
The diff coverage is 88.23%.


@@           Coverage Diff            @@
##           develop    #2088   +/-   ##
========================================
  Coverage    80.01%   80.01%           
========================================
  Files          364      364           
  Lines        59859    59914   +55     
========================================
+ Hits         47894    47941   +47     
- Misses       11965    11973    +8     



Impacted Files
Coverage Δ





src/constructors/full.c
92.52% <88.23%> (-3.91%)
⬇️


src/random/random.c
77.46% <0.00%> (-0.17%)
⬇️




Continue to review full report at Codecov.

Legend - Click here to learn more
Δ = absolute <relative> (impact), ø = not affected, ? = missing data
Powered by Codecov. Last update fe14f74...073d19f. Read the comment docs.",True,{}
