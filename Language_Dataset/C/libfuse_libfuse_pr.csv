libfuse/libfuse,https://github.com/libfuse/libfuse,25,2016-03-09T19:14:32Z,2016-03-09T19:33:40Z,2016-03-09T20:14:26Z,CLOSED,False,274,872,20,https://github.com/tanzeel-bhatti,Fuse 2 9 bugfix,25,[],https://github.com/libfuse/libfuse/pull/25,https://github.com/tanzeel-bhatti,1,https://github.com/libfuse/libfuse/pull/25,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,25,2016-03-09T19:14:32Z,2016-03-09T19:33:40Z,2016-03-09T20:14:26Z,CLOSED,False,274,872,20,https://github.com/tanzeel-bhatti,Fuse 2 9 bugfix,25,[],https://github.com/libfuse/libfuse/pull/25,https://github.com/tanzeel-bhatti,2,https://github.com/libfuse/libfuse/pull/25#issuecomment-194460187,,pull request,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,25,2016-03-09T19:14:32Z,2016-03-09T19:33:40Z,2016-03-09T20:14:26Z,CLOSED,False,274,872,20,https://github.com/tanzeel-bhatti,Fuse 2 9 bugfix,25,[],https://github.com/libfuse/libfuse/pull/25,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/25#issuecomment-194469675,,I assume this was by mistake?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,25,2016-03-09T19:14:32Z,2016-03-09T19:33:40Z,2016-03-09T20:14:26Z,CLOSED,False,274,872,20,https://github.com/tanzeel-bhatti,Fuse 2 9 bugfix,25,[],https://github.com/libfuse/libfuse/pull/25,https://github.com/tanzeel-bhatti,4,https://github.com/libfuse/libfuse/pull/25#issuecomment-194488117,,"Yes, It actually was.
Sorry :/
On Thu, Mar 10, 2016 at 12:33 AM, Nikolaus Rath notifications@github.com
wrote:

I assume this was by mistake?
—
Reply to this email directly or view it on GitHub
#25 (comment).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,29,2016-03-21T22:09:42Z,2016-04-23T16:54:18Z,2016-04-23T16:54:18Z,MERGED,True,15,15,5,https://github.com/HalosGhost,Remove leading _ on header guards to comply with reserved identifier requirements,2,[],https://github.com/libfuse/libfuse/pull/29,https://github.com/HalosGhost,1,https://github.com/libfuse/libfuse/pull/29,should close #28 (note that anything that manually checks header guards might be broken by this—though that should be rare since essentially nothing should be doing that).,should close #28 (note that anything that manually checks header guards might be broken by this—though that should be rare since essentially nothing should be doing that).,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,30,2016-03-22T16:20:41Z,2016-03-23T16:23:02Z,2016-03-23T16:23:02Z,CLOSED,False,102,26,11,https://github.com/chittunoo,Fuse 2 9 bugfix,10,[],https://github.com/libfuse/libfuse/pull/30,https://github.com/chittunoo,1,https://github.com/libfuse/libfuse/pull/30,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,30,2016-03-22T16:20:41Z,2016-03-23T16:23:02Z,2016-03-23T16:23:02Z,CLOSED,False,102,26,11,https://github.com/chittunoo,Fuse 2 9 bugfix,10,[],https://github.com/libfuse/libfuse/pull/30,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/30#issuecomment-200421392,,I assume this was an accident?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,35,2016-04-02T16:39:38Z,2016-04-02T21:29:52Z,2016-04-02T21:30:00Z,MERGED,True,1,1,1,https://github.com/1ace,Fix spelling mistake,1,[],https://github.com/libfuse/libfuse/pull/35,https://github.com/1ace,1,https://github.com/libfuse/libfuse/pull/35,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,35,2016-04-02T16:39:38Z,2016-04-02T21:29:52Z,2016-04-02T21:30:00Z,MERGED,True,1,1,1,https://github.com/1ace,Fix spelling mistake,1,[],https://github.com/libfuse/libfuse/pull/35,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/35#issuecomment-204807376,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/emilymaier,1,https://github.com/libfuse/libfuse/pull/38,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.","read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/38#issuecomment-211454656,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.","I believe FUSE deliberately ships its own version of fuse_kernel.h - but unfortunately I don't remember the exact rationale. I'll ask Milklos, but expect that to take a while...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/38#issuecomment-211459517,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.","Thanks for the patch! A few comments:

I believe adding a new operation (FUSE_DIR_READ) requires a corresponding patch to the FUSE kernel module. Could you point me to the relevant (kernel) commit?
Why do you add a new dir_read function? Wouldn't it make sense to just use read? At least for the low-level API I do not see any problems.
Will dir_read be preceded by a call to open or opendir? Please mention this in the comments (of both dir_read and the relevant open functions)
Could you please add an example that can be used to test this functionality? Something similar to examples/{fsel,fselclient}.c would be great.
Is it possible to split out the removal of fuse_kernel.h, or does your patch depend on the newer version? As I said, I'd like to wait for Miklos comments on that.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/emilymaier,4,https://github.com/libfuse/libfuse/pull/38#issuecomment-211688584,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.","I believe some of this is responded to in the kernel patch thread :) As for the rest, this branch won't build without the patch I put on fuse-devel, no. It depends on FUSE_DIR_READ being defined. I could add it here as well, but I noticed that fuse_kernel.h is duplicated from the kernel and also somewhat outdated. The FS receives opendir from FUSE before this call; I'll add in some example code.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/38#issuecomment-213785452,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.","I've heard back from Miklos. fuse.h is shipped both in the kernel and in the library so that they don't have to be upgraded in lockstep. If fuse.h was availabel only in the kernel, you'd have to update the kernel to update libfuse (or vice-versa). So please update this file in both kernel and userspace.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/emilymaier,6,https://github.com/libfuse/libfuse/pull/38#issuecomment-216082511,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.","I've pushed a new branch that adds an example, keeps fuse_kernel.h, and puts in a few other fixes.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/38#issuecomment-218848523,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.",Please ping me once the kernel part is in. Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,38,2016-04-17T02:12:21Z,2016-11-10T21:40:19Z,2016-11-10T21:40:19Z,CLOSED,False,247,2,8,https://github.com/emilymaier,Add support for reading from directories,3,"['enhancement', 'kernel']",https://github.com/libfuse/libfuse/pull/38,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/38#issuecomment-259815373,"read(2) on a directory is an odd syscall, but the VFS permits it and existing filesystems use it, so this is the userspace side of letting FUSE filesystems implement it. I also removed fuse_kernel.h since it duplicates an outdated version of the kernel FUSE header.",I'm closing this issue for now. Please just submit a pull request when the kernel patches have been merged. Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,43,2016-05-08T05:31:07Z,2016-05-08T20:47:31Z,2016-05-08T20:47:32Z,CLOSED,False,281,872,20,https://github.com/feibob,Fuse 2 9 bugfix,26,[],https://github.com/libfuse/libfuse/pull/43,https://github.com/feibob,1,https://github.com/libfuse/libfuse/pull/43,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,43,2016-05-08T05:31:07Z,2016-05-08T20:47:31Z,2016-05-08T20:47:32Z,CLOSED,False,281,872,20,https://github.com/feibob,Fuse 2 9 bugfix,26,[],https://github.com/libfuse/libfuse/pull/43,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/43#issuecomment-217745159,,Looks accidental,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,44,2016-05-11T10:55:06Z,2016-05-11T21:02:53Z,2016-05-11T21:02:53Z,MERGED,True,1,1,1,https://github.com/dsheets,lib/fuse_lowlevel.c: fix small typo in fuse_ll_help,1,[],https://github.com/libfuse/libfuse/pull/44,https://github.com/dsheets,1,https://github.com/libfuse/libfuse/pull/44,s/disable remove file locking/disable remote file locking/,s/disable remove file locking/disable remote file locking/,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,44,2016-05-11T10:55:06Z,2016-05-11T21:02:53Z,2016-05-11T21:02:53Z,MERGED,True,1,1,1,https://github.com/dsheets,lib/fuse_lowlevel.c: fix small typo in fuse_ll_help,1,[],https://github.com/libfuse/libfuse/pull/44,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/44#issuecomment-218589302,s/disable remove file locking/disable remote file locking/,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,49,2016-05-19T17:55:42Z,2016-05-19T18:02:05Z,2016-05-19T18:02:10Z,CLOSED,False,2,0,1,https://github.com/Nikratio,Test CI,1,[],https://github.com/libfuse/libfuse/pull/49,https://github.com/Nikratio,1,https://github.com/libfuse/libfuse/pull/49,This should trigger a CI test. Let's see.,This should trigger a CI test. Let's see.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,49,2016-05-19T17:55:42Z,2016-05-19T18:02:05Z,2016-05-19T18:02:10Z,CLOSED,False,2,0,1,https://github.com/Nikratio,Test CI,1,[],https://github.com/libfuse/libfuse/pull/49,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/49#issuecomment-220404594,This should trigger a CI test. Let's see.,"Great, it works!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,55,2016-06-16T10:22:19Z,2016-06-20T18:12:23Z,2016-06-20T18:12:23Z,MERGED,True,14,0,1,https://github.com/hbrueckner,libfuse/fuse_daemonize:  wait until daemon child process is ready,1,[],https://github.com/libfuse/libfuse/pull/55,https://github.com/hbrueckner,1,https://github.com/libfuse/libfuse/pull/55,"Mounting a FUSE file system remotely using SSH in combination with
pseudo-terminal allocation (-t), results in ""Transport endpoint is
not connected"" errors when trying to access the file system contents.
For example:
ssh -t root@localhost  ""cmsfs-fuse /dev/disk/by-path/ccw-0.0.0190 /CMSFS""
Connection to localhost closed.
ls /CMSFS
ls: cannot access '/CMSFS': Transport endpoint is not connected
The cmsfs-fuse main program (which can also be any other FUSE file
system) calls into the fuse_main() libfuse library function.
The fuse_main() function later calls fuse_daemonize() to fork the
daemon process to handle the FUSE file system I/O.
The fuse_daemonize() function calls fork() as usual.  The child
proceeds with setsid() and then redirecting its file descriptors
to /dev/null etc.  The parent process, simply exits.
The child's functions and the parent's exit creates a subtle race.
This is seen with an SSH connection.  The SSH command above calls
cmsfs-fuse on an allocated pseudo-terminal device (-t option).
If the parent exits, SSH receives the command completion and closes
the connection, that means, it closes the master side of the
pseudo-terminal.  This causes a HUP signal being sent to the process
group on the pseudo-terminal.  At this point in time, the child might
not have completed the setsid() call and, hence, becomes terminated.
Note that fuse daemon sets up its signal handlers after fuse_daemonize()
has completed.
Even if the child has the chance to disassociate from its parent process
group to become it's own process group with setsid(), the child still
has the pseudo-terminal opened as stdin, stdout, and stderr.  So the
pseudo-terminal still behave as controlling terminal and might cause a
SIGHUP at closing the the master side.
To solve the problem, the parent has to wait until the child (the fuse
daemon process) has completed its processing, that means, has become
its own process group with setsid() and closed any file descriptors
pointing to the pseudo-terminal.
Closes: #27
Reported-by: Ofer Baruch oferba@il.ibm.com
Reviewed-by: Gerald Schaefer gerald.schaefer@de.ibm.com
Signed-off-by: Hendrik Brueckner brueckner@linux.vnet.ibm.com","Mounting a FUSE file system remotely using SSH in combination with
pseudo-terminal allocation (-t), results in ""Transport endpoint is
not connected"" errors when trying to access the file system contents.
For example:
ssh -t root@localhost  ""cmsfs-fuse /dev/disk/by-path/ccw-0.0.0190 /CMSFS""
Connection to localhost closed.
ls /CMSFS
ls: cannot access '/CMSFS': Transport endpoint is not connected
The cmsfs-fuse main program (which can also be any other FUSE file
system) calls into the fuse_main() libfuse library function.
The fuse_main() function later calls fuse_daemonize() to fork the
daemon process to handle the FUSE file system I/O.
The fuse_daemonize() function calls fork() as usual.  The child
proceeds with setsid() and then redirecting its file descriptors
to /dev/null etc.  The parent process, simply exits.
The child's functions and the parent's exit creates a subtle race.
This is seen with an SSH connection.  The SSH command above calls
cmsfs-fuse on an allocated pseudo-terminal device (-t option).
If the parent exits, SSH receives the command completion and closes
the connection, that means, it closes the master side of the
pseudo-terminal.  This causes a HUP signal being sent to the process
group on the pseudo-terminal.  At this point in time, the child might
not have completed the setsid() call and, hence, becomes terminated.
Note that fuse daemon sets up its signal handlers after fuse_daemonize()
has completed.
Even if the child has the chance to disassociate from its parent process
group to become it's own process group with setsid(), the child still
has the pseudo-terminal opened as stdin, stdout, and stderr.  So the
pseudo-terminal still behave as controlling terminal and might cause a
SIGHUP at closing the the master side.
To solve the problem, the parent has to wait until the child (the fuse
daemon process) has completed its processing, that means, has become
its own process group with setsid() and closed any file descriptors
pointing to the pseudo-terminal.
Closes: #27
Reported-by: Ofer Baruch oferba@il.ibm.com
Reviewed-by: Gerald Schaefer gerald.schaefer@de.ibm.com
Signed-off-by: Hendrik Brueckner brueckner@linux.vnet.ibm.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,55,2016-06-16T10:22:19Z,2016-06-20T18:12:23Z,2016-06-20T18:12:23Z,MERGED,True,14,0,1,https://github.com/hbrueckner,libfuse/fuse_daemonize:  wait until daemon child process is ready,1,[],https://github.com/libfuse/libfuse/pull/55,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/55#issuecomment-226530954,"Mounting a FUSE file system remotely using SSH in combination with
pseudo-terminal allocation (-t), results in ""Transport endpoint is
not connected"" errors when trying to access the file system contents.
For example:
ssh -t root@localhost  ""cmsfs-fuse /dev/disk/by-path/ccw-0.0.0190 /CMSFS""
Connection to localhost closed.
ls /CMSFS
ls: cannot access '/CMSFS': Transport endpoint is not connected
The cmsfs-fuse main program (which can also be any other FUSE file
system) calls into the fuse_main() libfuse library function.
The fuse_main() function later calls fuse_daemonize() to fork the
daemon process to handle the FUSE file system I/O.
The fuse_daemonize() function calls fork() as usual.  The child
proceeds with setsid() and then redirecting its file descriptors
to /dev/null etc.  The parent process, simply exits.
The child's functions and the parent's exit creates a subtle race.
This is seen with an SSH connection.  The SSH command above calls
cmsfs-fuse on an allocated pseudo-terminal device (-t option).
If the parent exits, SSH receives the command completion and closes
the connection, that means, it closes the master side of the
pseudo-terminal.  This causes a HUP signal being sent to the process
group on the pseudo-terminal.  At this point in time, the child might
not have completed the setsid() call and, hence, becomes terminated.
Note that fuse daemon sets up its signal handlers after fuse_daemonize()
has completed.
Even if the child has the chance to disassociate from its parent process
group to become it's own process group with setsid(), the child still
has the pseudo-terminal opened as stdin, stdout, and stderr.  So the
pseudo-terminal still behave as controlling terminal and might cause a
SIGHUP at closing the the master side.
To solve the problem, the parent has to wait until the child (the fuse
daemon process) has completed its processing, that means, has become
its own process group with setsid() and closed any file descriptors
pointing to the pseudo-terminal.
Closes: #27
Reported-by: Ofer Baruch oferba@il.ibm.com
Reviewed-by: Gerald Schaefer gerald.schaefer@de.ibm.com
Signed-off-by: Hendrik Brueckner brueckner@linux.vnet.ibm.com","Thanks for the patch! Don't worry about the test failure, that problem has always been present in the code base (and only recently become visible when adding clang tests).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,61,2016-07-13T20:31:12Z,2016-08-19T22:10:49Z,2016-08-19T22:10:49Z,CLOSED,False,2,0,1,https://github.com/treestem,Should fuse_do_release call do_forget() ?,1,[],https://github.com/libfuse/libfuse/pull/61,https://github.com/treestem,1,https://github.com/libfuse/libfuse/pull/61,"I see the name and id caches continually growing, even with ""-o remember=60"".
My test is an infinite loop of open, write, close on random file names.
fuse_clean_cache is not reaping old nodes because forget isn't called and we never decrement nlookup. With this patch, nodes go onto the lru list and are eventually reaped. Memory no longer grows continuously.","I see the name and id caches continually growing, even with ""-o remember=60"".
My test is an infinite loop of open, write, close on random file names.
fuse_clean_cache is not reaping old nodes because forget isn't called and we never decrement nlookup. With this patch, nodes go onto the lru list and are eventually reaped. Memory no longer grows continuously.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,61,2016-07-13T20:31:12Z,2016-08-19T22:10:49Z,2016-08-19T22:10:49Z,CLOSED,False,2,0,1,https://github.com/treestem,Should fuse_do_release call do_forget() ?,1,[],https://github.com/libfuse/libfuse/pull/61,https://github.com/treestem,2,https://github.com/libfuse/libfuse/pull/61#issuecomment-234073093,"I see the name and id caches continually growing, even with ""-o remember=60"".
My test is an infinite loop of open, write, close on random file names.
fuse_clean_cache is not reaping old nodes because forget isn't called and we never decrement nlookup. With this patch, nodes go onto the lru list and are eventually reaped. Memory no longer grows continuously.","While this problem does exist, the proposed patch is not correct.
This needs more thought.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,61,2016-07-13T20:31:12Z,2016-08-19T22:10:49Z,2016-08-19T22:10:49Z,CLOSED,False,2,0,1,https://github.com/treestem,Should fuse_do_release call do_forget() ?,1,[],https://github.com/libfuse/libfuse/pull/61,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/61#issuecomment-241148186,"I see the name and id caches continually growing, even with ""-o remember=60"".
My test is an infinite loop of open, write, close on random file names.
fuse_clean_cache is not reaping old nodes because forget isn't called and we never decrement nlookup. With this patch, nodes go onto the lru list and are eventually reaped. Memory no longer grows continuously.","Thanks for the update, I'll close this for now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,66,2016-07-21T09:12:32Z,2016-07-21T15:17:40Z,2016-07-21T15:17:42Z,MERGED,True,21,3,1,https://github.com/Alex-Richman,add error checking to setuid calls,1,[],https://github.com/libfuse/libfuse/pull/66,https://github.com/Alex-Richman,1,https://github.com/libfuse/libfuse/pull/66,This was raised by a static analysis tool and seemed worth fixing.,This was raised by a static analysis tool and seemed worth fixing.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,66,2016-07-21T09:12:32Z,2016-07-21T15:17:40Z,2016-07-21T15:17:42Z,MERGED,True,21,3,1,https://github.com/Alex-Richman,add error checking to setuid calls,1,[],https://github.com/libfuse/libfuse/pull/66,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/66#issuecomment-234286586,This was raised by a static analysis tool and seemed worth fixing.,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,68,2016-07-23T05:40:43Z,2016-08-04T19:46:38Z,2016-08-04T19:46:38Z,MERGED,True,3,3,1,https://github.com/bobrofon,Fix ${prefix} ignoring for MOUNT_FUSE_PATH and INIT_D_PATH,1,[],https://github.com/libfuse/libfuse/pull/68,https://github.com/bobrofon,1,https://github.com/libfuse/libfuse/pull/68,"Default values for MOUNT_FUSE_PATH, UDEV_RULES_PATH and INIT_D_PATH should be based on directory variables from  GNU Coding Standarts.
Directory variables left unexpanded because installation directory options may be changed via ""make install prefix=/foo"".","Default values for MOUNT_FUSE_PATH, UDEV_RULES_PATH and INIT_D_PATH should be based on directory variables from  GNU Coding Standarts.
Directory variables left unexpanded because installation directory options may be changed via ""make install prefix=/foo"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,69,2016-07-23T16:46:14Z,2016-07-23T17:18:00Z,2016-07-23T17:18:07Z,CLOSED,False,4,6,1,https://github.com/Nikratio,Disable thread sanitizer until we've fixed the bugs/false positives,1,[],https://github.com/libfuse/libfuse/pull/69,https://github.com/Nikratio,1,https://github.com/libfuse/libfuse/pull/69,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,70,2016-08-10T17:08:59Z,2016-10-03T17:15:39Z,2016-10-03T17:15:39Z,CLOSED,False,26,2,4,https://github.com/tjurkiewicz,Google's Bazel BUILD & canonical linker script extension,1,['enhancement'],https://github.com/libfuse/libfuse/pull/70,https://github.com/tjurkiewicz,1,https://github.com/libfuse/libfuse/pull/70,"Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse","Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,70,2016-08-10T17:08:59Z,2016-10-03T17:15:39Z,2016-10-03T17:15:39Z,CLOSED,False,26,2,4,https://github.com/tjurkiewicz,Google's Bazel BUILD & canonical linker script extension,1,['enhancement'],https://github.com/libfuse/libfuse/pull/70,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/70#issuecomment-241148553,"Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse","Thanks for the patch! Could you please add an entry in ChangeLog.rst, and a short description of how to build with Bazel to README.md (in the Installation section)?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,70,2016-08-10T17:08:59Z,2016-10-03T17:15:39Z,2016-10-03T17:15:39Z,CLOSED,False,26,2,4,https://github.com/tjurkiewicz,Google's Bazel BUILD & canonical linker script extension,1,['enhancement'],https://github.com/libfuse/libfuse/pull/70,https://github.com/tjurkiewicz,3,https://github.com/libfuse/libfuse/pull/70#issuecomment-243256798,"Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse","Hey, I'll add missing docs as soon as I am back from summer vacations (in Sep.)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,70,2016-08-10T17:08:59Z,2016-10-03T17:15:39Z,2016-10-03T17:15:39Z,CLOSED,False,26,2,4,https://github.com/tjurkiewicz,Google's Bazel BUILD & canonical linker script extension,1,['enhancement'],https://github.com/libfuse/libfuse/pull/70,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/70#issuecomment-251152978,"Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse",Any update on this? I'd like to make a FUSE 3 release soon.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,70,2016-08-10T17:08:59Z,2016-10-03T17:15:39Z,2016-10-03T17:15:39Z,CLOSED,False,26,2,4,https://github.com/tjurkiewicz,Google's Bazel BUILD & canonical linker script extension,1,['enhancement'],https://github.com/libfuse/libfuse/pull/70,https://github.com/tjurkiewicz,5,https://github.com/libfuse/libfuse/pull/70#issuecomment-251154282,"Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse","Hello,
I think it needs a bit more work than I tought / or newer version of Bazel.
I might had
requested this pull prematurely.
The problem is that it works perfectly when libfuse is being built
standalone, but
when built as a module, artifact resolution loses track of that
linkerscript file
and obviously build fails. Still, the change would be no more than one BUILD
file and renaming / updating ldscript file and Makefile entry, but I'd
suggest
postponing it.
Sorry for this. I hoped that some new version of bazel will be relased with
fix
to that. May we be in touch about this patch?
2016-10-03 18:23 GMT+02:00 Nikolaus Rath notifications@github.com:

Any update on this? I'd like to make a FUSE 3 release soon.
—
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub
#70 (comment), or mute
the thread
https://github.com/notifications/unsubscribe-auth/APQf1Y_fvuAwb62BfUjWQrRYyV15ETzxks5qwSvugaJpZM4JhXZF
.


Pozdrawiam,
Tomek Jurkiewicz",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,70,2016-08-10T17:08:59Z,2016-10-03T17:15:39Z,2016-10-03T17:15:39Z,CLOSED,False,26,2,4,https://github.com/tjurkiewicz,Google's Bazel BUILD & canonical linker script extension,1,['enhancement'],https://github.com/libfuse/libfuse/pull/70,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/70#issuecomment-251166432,"Added BAZEL buildfile that builds libfuse.a / libfuse.so libraries. Because of it's design, no config.h is generated, instead needed defines are provided (in fact, an empty config.h is created).  Version script for the linker was renamed so it ends with more canonical extension (Bazel doesn't allow any generated files to be used as linker scripts, so no copy of existing file can be used, at the same time, it expects version scripts to have one of .ld, .lds, .ldscript extensions).
Effectively, all that was changed in exiting codebase is the name of version script file.
More rules are to follow (ie. fusermount util).
Building fuse with installed and running bazel should be as simple as:
bazel build fuse","Sure. I'll close this for now, but feel free to re-open when you have something that works :-).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,74,2016-09-08T16:28:46Z,2016-09-27T13:00:49Z,2016-09-27T13:00:50Z,CLOSED,False,868,14,10,https://github.com/sforshee,Add support for posix ACLs,2,[],https://github.com/libfuse/libfuse/pull/74,https://github.com/sforshee,1,https://github.com/libfuse/libfuse/pull/74,"This pull request requires kernel support. Patches for Linux can be found at:
http://lkml.kernel.org/r/1472478397-131967-1-git-send-email-seth.forshee@canonical.com
With kernel support, these patches add support for posix ACLs by passing the raw posix ACL xattrs between the kernel and userspace. If supported by the filesystem, libfuse will parse the raw xattrs into an easier to use data structure and pass these to the filesystem's setacl/getacl callbacks for processing. Helpers are provided for common operations like converting between the posix and fuse ACL data structures, calculating the file mode from ACLs, updating ACLs when the file mode changes, and determining what ACLs should be inherited by children of a directory with default ACLs.","This pull request requires kernel support. Patches for Linux can be found at:
http://lkml.kernel.org/r/1472478397-131967-1-git-send-email-seth.forshee@canonical.com
With kernel support, these patches add support for posix ACLs by passing the raw posix ACL xattrs between the kernel and userspace. If supported by the filesystem, libfuse will parse the raw xattrs into an easier to use data structure and pass these to the filesystem's setacl/getacl callbacks for processing. Helpers are provided for common operations like converting between the posix and fuse ACL data structures, calculating the file mode from ACLs, updating ACLs when the file mode changes, and determining what ACLs should be inherited by children of a directory with default ACLs.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,74,2016-09-08T16:28:46Z,2016-09-27T13:00:49Z,2016-09-27T13:00:50Z,CLOSED,False,868,14,10,https://github.com/sforshee,Add support for posix ACLs,2,[],https://github.com/libfuse/libfuse/pull/74,https://github.com/sforshee,2,https://github.com/libfuse/libfuse/pull/74#issuecomment-249857519,"This pull request requires kernel support. Patches for Linux can be found at:
http://lkml.kernel.org/r/1472478397-131967-1-git-send-email-seth.forshee@canonical.com
With kernel support, these patches add support for posix ACLs by passing the raw posix ACL xattrs between the kernel and userspace. If supported by the filesystem, libfuse will parse the raw xattrs into an easier to use data structure and pass these to the filesystem's setacl/getacl callbacks for processing. Helpers are provided for common operations like converting between the posix and fuse ACL data structures, calculating the file mode from ACLs, updating ACLs when the file mode changes, and determining what ACLs should be inherited by children of a directory with default ACLs.","Closing this based on this message from Miklos indicating that there's currently not a use case for this in libfuse right now.
https://sourceforge.net/p/fuse/mailman/message/35387972/",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,80,2016-10-09T21:13:05Z,2016-10-09T21:19:33Z,2016-10-09T21:19:34Z,MERGED,True,9,113,7,https://github.com/Nikratio,Master proposed,4,[],https://github.com/libfuse/libfuse/pull/80,https://github.com/Nikratio,1,https://github.com/libfuse/libfuse/pull/80,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,82,2016-10-10T04:52:35Z,2016-10-10T05:03:07Z,2016-10-10T05:03:07Z,MERGED,True,632,360,24,https://github.com/Nikratio,Master proposed,10,[],https://github.com/libfuse/libfuse/pull/82,https://github.com/Nikratio,1,https://github.com/libfuse/libfuse/pull/82,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,88,2016-10-12T15:57:09Z,2016-10-12T16:32:07Z,2016-10-12T16:32:07Z,CLOSED,False,643,273,21,https://github.com/be47liberty,Master proposed,21,[],https://github.com/libfuse/libfuse/pull/88,https://github.com/be47liberty,1,https://github.com/libfuse/libfuse/pull/88,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,88,2016-10-12T15:57:09Z,2016-10-12T16:32:07Z,2016-10-12T16:32:07Z,CLOSED,False,643,273,21,https://github.com/be47liberty,Master proposed,21,[],https://github.com/libfuse/libfuse/pull/88,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/88#issuecomment-253265580,,I assume this was an accident.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,89,2016-10-14T12:59:10Z,2016-10-17T11:43:08Z,2016-10-17T11:43:08Z,CLOSED,False,0,0,0,https://github.com/jabolopes,Add fchmod FUSE operation.,0,[],https://github.com/libfuse/libfuse/pull/89,https://github.com/jabolopes,1,https://github.com/libfuse/libfuse/pull/89,"fchmod is analogous ftruncate: it extends the chmod operation with the
fuse_file_info argument, which includes the open file handle.
This operation allows clients of the FUSE library to distinguish between
the chmod and fchmod system calls.","fchmod is analogous ftruncate: it extends the chmod operation with the
fuse_file_info argument, which includes the open file handle.
This operation allows clients of the FUSE library to distinguish between
the chmod and fchmod system calls.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,93,2016-10-17T23:18:29Z,2016-10-18T03:21:33Z,2016-10-18T03:22:57Z,CLOSED,False,22,8,2,https://github.com/forgottenswitch,Fix gcc warnings,1,[],https://github.com/libfuse/libfuse/pull/93,https://github.com/forgottenswitch,1,https://github.com/libfuse/libfuse/pull/93,Stub compile warnings. Maybe some should be error-checked.,Stub compile warnings. Maybe some should be error-checked.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,93,2016-10-17T23:18:29Z,2016-10-18T03:21:33Z,2016-10-18T03:22:57Z,CLOSED,False,22,8,2,https://github.com/forgottenswitch,Fix gcc warnings,1,[],https://github.com/libfuse/libfuse/pull/93,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/93#issuecomment-254387733,Stub compile warnings. Maybe some should be error-checked.,"Hmm. I think gcc warning about (void) chdir(""/""); is a bug in GCC. The explicit cast makes it clear that we are deliberately ignoring the return value. In my opinion the empty if clauses introduced by your patch are worse than the GCC warning, so I'd rather add some more explicit (void) castings instead and hope that gcc gets fixed.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,93,2016-10-17T23:18:29Z,2016-10-18T03:21:33Z,2016-10-18T03:22:57Z,CLOSED,False,22,8,2,https://github.com/forgottenswitch,Fix gcc warnings,1,[],https://github.com/libfuse/libfuse/pull/93,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/93#issuecomment-254395543,Stub compile warnings. Maybe some should be error-checked.,"Amazing that there's actually a discussion about this. I didn't read the bug to the end (so I don't know which opinion eventually prevailed), but the only thing that's going to get into FUSE is a void cast and (if necessary) a patch to enable -Wno-unused-result when compiling with gcc6 (in gcc 4.9 the behavior is still - dare I say it? - sensible).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,93,2016-10-17T23:18:29Z,2016-10-18T03:21:33Z,2016-10-18T03:22:57Z,CLOSED,False,22,8,2,https://github.com/forgottenswitch,Fix gcc warnings,1,[],https://github.com/libfuse/libfuse/pull/93,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/93#issuecomment-254396573,Stub compile warnings. Maybe some should be error-checked.,"Not interested in at least adding the (void) castings? I can easily to it, but then you won't be the commit author (and you found the problem).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,94,2016-10-18T04:06:26Z,2016-10-19T01:54:14Z,2016-10-19T05:03:43Z,MERGED,True,2,2,1,https://github.com/forgottenswitch,Ignore some errors,1,[],https://github.com/libfuse/libfuse/pull/94,https://github.com/forgottenswitch,1,https://github.com/libfuse/libfuse/pull/94,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,99,2016-10-18T04:56:20Z,2016-10-28T04:53:25Z,2016-10-28T20:09:51Z,CLOSED,False,1,0,1,https://github.com/forgottenswitch,man: Document suid requirement,1,[],https://github.com/libfuse/libfuse/pull/99,https://github.com/forgottenswitch,1,https://github.com/libfuse/libfuse/pull/99,"/usr/bin/fusermount could not be set-uid-root if package manager whitelists suid executables.
Currently, a mount() fails, printing ""fusermount: mount failed:%s"", ""Operation not permitted"",
which looks like there is a mis-configuration of fstab.","/usr/bin/fusermount could not be set-uid-root if package manager whitelists suid executables.
Currently, a mount() fails, printing ""fusermount: mount failed:%s"", ""Operation not permitted"",
which looks like there is a mis-configuration of fstab.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,99,2016-10-18T04:56:20Z,2016-10-28T04:53:25Z,2016-10-28T20:09:51Z,CLOSED,False,1,0,1,https://github.com/forgottenswitch,man: Document suid requirement,1,[],https://github.com/libfuse/libfuse/pull/99,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/99#issuecomment-256835975,"/usr/bin/fusermount could not be set-uid-root if package manager whitelists suid executables.
Currently, a mount() fails, printing ""fusermount: mount failed:%s"", ""Operation not permitted"",
which looks like there is a mis-configuration of fstab.","Merged manually, thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,104,2016-10-20T13:18:20Z,2016-10-20T15:29:46Z,2016-10-20T20:16:48Z,MERGED,True,3,1,1,https://github.com/heroin-moose,Do not close stdout on fuse_session_destroy(),1,[],https://github.com/libfuse/libfuse/pull/104,https://github.com/heroin-moose,1,https://github.com/libfuse/libfuse/pull/104,"If fuse_session_mount() fails (or was never called in the first place)
we end up with the default fd value which happens to be 0. It hurts
long-running processes, which lifetime extends beyond session's
lifetime.","If fuse_session_mount() fails (or was never called in the first place)
we end up with the default fd value which happens to be 0. It hurts
long-running processes, which lifetime extends beyond session's
lifetime.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,109,2016-10-31T13:39:33Z,2016-10-31T17:20:43Z,2016-10-31T17:20:43Z,MERGED,True,1,0,1,https://github.com/divinity76,silence bogus eclipse linter warning,1,[],https://github.com/libfuse/libfuse/pull/109,https://github.com/divinity76,1,https://github.com/libfuse/libfuse/pull/109,"bogus warning
""No break at the end of case	cuse.c	/example	line 235	Code Analysis Problem""","bogus warning
""No break at the end of case	cuse.c	/example	line 235	Code Analysis Problem""",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,120,2016-11-23T22:53:21Z,2017-08-03T09:51:27Z,2017-08-03T09:51:27Z,CLOSED,False,6,9,1,https://github.com/przemoc,util/fusermount.c: Fix user mounting under grsec kernel.,1,[],https://github.com/libfuse/libfuse/pull/120,https://github.com/przemoc,1,https://github.com/libfuse/libfuse/pull/120,"If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186","If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,120,2016-11-23T22:53:21Z,2017-08-03T09:51:27Z,2017-08-03T09:51:27Z,CLOSED,False,6,9,1,https://github.com/przemoc,util/fusermount.c: Fix user mounting under grsec kernel.,1,[],https://github.com/libfuse/libfuse/pull/120,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/120#issuecomment-262860078,"If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186","Thanks for the patch! Since this affects a setuid binary, I want to review this very carefully and its going to take a little longer. Could you maybe expand on where the ""real access checks"" are done? Or is this going to be obvious once I look at the code (I haven't done that yet).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,120,2016-11-23T22:53:21Z,2017-08-03T09:51:27Z,2017-08-03T09:51:27Z,CLOSED,False,6,9,1,https://github.com/przemoc,util/fusermount.c: Fix user mounting under grsec kernel.,1,[],https://github.com/libfuse/libfuse/pull/120,https://github.com/przemoc,3,https://github.com/libfuse/libfuse/pull/120#issuecomment-263022461,"If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186","Today Timo linked me to the discussion from ML (~1.5y ago), that I wasn't aware of.
https://sourceforge.net/p/fuse/mailman/message/33378384/",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,120,2016-11-23T22:53:21Z,2017-08-03T09:51:27Z,2017-08-03T09:51:27Z,CLOSED,False,6,9,1,https://github.com/przemoc,util/fusermount.c: Fix user mounting under grsec kernel.,1,[],https://github.com/libfuse/libfuse/pull/120,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/120#issuecomment-263138552,"If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186","It seems the consensus back then was to either

Drop realpath() only if /etc/mtab is symlink to /proc/mounts. However, I think this should be a run-time rather than compile time check.
Drop privileges, open the directory, and then use the resulting fd for all futher work.
Would either of this solve the problem for grsec?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,120,2016-11-23T22:53:21Z,2017-08-03T09:51:27Z,2017-08-03T09:51:27Z,CLOSED,False,6,9,1,https://github.com/przemoc,util/fusermount.c: Fix user mounting under grsec kernel.,1,[],https://github.com/libfuse/libfuse/pull/120,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/120#issuecomment-269065194,"If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186",@przemoc Do you have an update on this?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,120,2016-11-23T22:53:21Z,2017-08-03T09:51:27Z,2017-08-03T09:51:27Z,CLOSED,False,6,9,1,https://github.com/przemoc,util/fusermount.c: Fix user mounting under grsec kernel.,1,[],https://github.com/libfuse/libfuse/pull/120,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/120#issuecomment-319923355,"If the user was not in readproc group, realpath() would fail causing
fusermount to fail.  The privilege drop for realpath() is unnecessary
as the real access checks are done in other places.
Based on patch by Timo Teräs for fuse package in Alpine Linux's aports:
http://git.alpinelinux.org/cgit/aports/commit/?id=b5d81e456487d4dbfbdf0d07ae6ca5cf3f59d186","Since there hasn't been any activity for more than 6 months, and from what I've heard the GRsec kernel is also no longer publically available, I'll close this for now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/przemoc,1,https://github.com/libfuse/libfuse/pull/121,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.","Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/121#issuecomment-262653396,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.","Thanks! Most of this looks good. I am not a friend of renaming the mount.fuse manpage though, I think because it is not specific to libfuse but also documents the kernel mount options. Also, the FUSE2 version is quite a mess, it mixes up kernel options with high level and low level options. Maybe it makes more sense to just drop this one from fuse 2 instead...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/przemoc,3,https://github.com/libfuse/libfuse/pull/121#issuecomment-262656221,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.","You're right, I went too far with this renaming mount.fuse.8 to mount.fuse3.8. I'll hopefully fix it tomorrow.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/121#issuecomment-262656468,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.",Thanks! Any specific reason why you excluded the examples directory?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/121#issuecomment-262656626,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.","Ops, and the same applies to the renaming of /etc/fuse.conf. No need for that, IMO.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/przemoc,6,https://github.com/libfuse/libfuse/pull/121#issuecomment-262658154,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.","I excluded examples/, because I'll have to prepare some code fixes there (it's quite late here today, that's why I'm postponing it, sorry). I always create PRs against upstream's master, so just wanted to avoid potential conflicts later (maybe there wouldn't be any, just being on the safe side).
Same configuration file is potentially problematic from packager's point of view (coexisting fuse 2 & 3), but I agree that having one fuse config file seems cleaner.
BTW Is there any stuff in fuse3's mount.fuse.8 that does not apply to fuse2? If no, then it would be very practical in distributions to stop shipping mount.fuse.8 from fuse2 and only take it from fuse3, when it will be officially released.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/121#issuecomment-262859984,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.","I think packagers should either ship libfuse2 and libfuse3 in the same package, or create a separate fuse-common package that contains manpage, udev rules, and configuration file.
At the moment, mount.fuse.8 is valid for both fuse2 and fuse3. If we add new options, we can just add a remark along the lines of ""introduced in fuse xx.yy."".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,121,2016-11-23T22:56:55Z,2016-11-29T05:33:14Z,2018-01-26T10:39:29Z,MERGED,True,37,36,11,https://github.com/przemoc,Continue renaming stuff for fuse3,4,[],https://github.com/libfuse/libfuse/pull/121,https://github.com/przemoc,8,https://github.com/libfuse/libfuse/pull/121#issuecomment-263146677,"Some stuff has been renamed already, but in most places old names remain. It's better to be consistent.
Nothing in examples/ directory has been changed yet.",I have updated the patchset. It should match your expectations better.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/przemoc,1,https://github.com/libfuse/libfuse/pull/123,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/123#issuecomment-263483334,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","I don't fully understand this patch. As far as I can tell, there are two unrelated changes:
First, you define that in mount.c and mount_util.c, using NetBSD should imply IGNORE_MTAB. This happens not to change the behavior because IGNORE_MTAB isn't used for anything else in these files, but I don't think this makes it a good idea. If NetBSD really should imply IGNORE_MTAB, shouldn't this be handled in configure.ac instead, so that it applies in all source files?
Secondly, you are turning mtab_needs_update into a no-op if IGNORE_MTAB is defined. This looks like a reasonable change.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/przemoc,3,https://github.com/libfuse/libfuse/pull/123#issuecomment-263546420,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","If NetBSD really should imply IGNORE_MTAB, shouldn't this be handled in configure.ac instead, so that it applies in all source files?

To be honest, I don't know whether compiling on NetBSD should imply IGNORE_MTAB globally. That's why I explained in last paragraph of my commit message, why global implication has not been applied.
In mount.c and mount_util.c questions when (if we build on NetBSD) and why (if we ignore mtab) were mixed. That's why I found depending solely on IGNORE_MTAB in the code part better, because it makes the intent (and the code) clearer.
In case of NetBSD status quo has been preserved, i.e. the compiled code remains the same. I have to admit, though, that I succumbed to idea of having simpler path that also fixes bug in other cases (well, I think it's ultimately a bug that --disable-mtab configure option was not respected).
If I split this commit, making the first one the same as current one, but in mount_util.c with added #else for __NetBSD__ (i.e. !defined(__NetBSD__) case), where IGNORE_MTAB becomes undefined if it was already defined (making it clear that IGNORE_MTAB has been ignored so far, because such commit will preserve status quo), and add another commit removing the #else case, then will it be ok for you?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/123#issuecomment-263609844,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","Maybe, I'd need to see the code to be sure. It's a little hard to tell from your description.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/przemoc,5,https://github.com/libfuse/libfuse/pull/123#issuecomment-263625191,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.",PR has been updated and rebased on master.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/123#issuecomment-263628388,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","Are you sure you pushed the right commits? I don't see e.g. an ""added #else"" anywhere.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/przemoc,7,https://github.com/libfuse/libfuse/pull/123#issuecomment-263630213,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","Yes, I am sure. There are 2 commits in this branch and you apparently looked into changes after applying both of them (manually or maybe via ""Files changes"" tab on GitHub), so you don't see the change introduced in the first commit. Please always check each commit (and its message), not only the whole series changes.
64a0c9f
d9e4091",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/123#issuecomment-264724036,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","Sorry, in that case we misunderstood each other. The patch that I would like to merge was the one that turned mtab_needs_update into a no-op if IGNORE_MTAB is defined (while keeping it a no-op for __NetBSD__). I do not want to locally make __NetBSD__ imply IGNORE_MTAB. If this is a good idea, then it should go into configure.ac.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/123#issuecomment-264724131,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","A quick Google search seems to confirm that NetBSD generally doesn't have /etc/mtab, so I think adding this to configure.ac would be fine.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/przemoc,10,https://github.com/libfuse/libfuse/pull/123#issuecomment-264733083,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.","It's a fact that in these 2 files mtab is ignored when compiled for NetBSD, so making it clear in the code is better. And to preserve status quo for non-NetBSD case I introduced the #else branch in one of files (which exposes kind of bug, that IGNORE_MTAB wasn't respected so far and mtab_needs_update wasn't turning into a no-op if you weren't using NetBSD). Only in second patch I'm fixing mtab_needs_update to make it a no-op for non-NetBSD case if IGNORE_MTAB is defined.
You're maintainer, so you can better tell whether activating IGNORE_MTAB code paths for NetBSD in the file I haven't touched, i.e. util/fusermount.c, is fine, but it shouldn't be part of this patchset (because I cannot test it; what I provided changes nothing in NetBSD case, so it's fine).
If you find that that fusermount.c is safe for defining IGNORE_MTAB if it's NetBSD, then I suggest introducing #define IGNORE_MTAB when __NetBSD__ is defined (like I did in 2 files) and make change in configure.ac in yet another commit, because then moving it to configure.ac will become a no change for the code.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,123,2016-11-27T23:38:15Z,2016-12-24T02:50:02Z,2018-01-26T10:39:52Z,CLOSED,False,11,4,2,https://github.com/przemoc,"lib/{mount.c,mount_util.c}: Depend on IGNORE_MTAB instead of __NetBSD__.",2,[],https://github.com/libfuse/libfuse/pull/123,https://github.com/Nikratio,11,https://github.com/libfuse/libfuse/pull/123#issuecomment-269065534,"Define IGNORE_MTAB in these files if __NetBSD__ is defined.
It makes the code more consistent (same pattern) and also allows
avoiding call to mtab_needs_update() (making it a macro returning 0)
if libfuse was configured with --disable-mtab.
util/fusermount.c's preprocessor directives also check IGNORE_MTAB, but
__NetBSD__ is nowhere inspected there, and because I don't have NetBSD
and I don't know NetBSD mounting behavior, I refrained from touching
this file and making -D__NetBSD__ -> -DIGNORE_MTAB a global thing.",I have added commit ac25c15 instead. Thanks for bringing this up!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,124,2016-11-28T14:18:06Z,2016-11-29T05:35:05Z,2018-01-26T10:39:19Z,MERGED,True,6,1,1,https://github.com/przemoc,Fixes for examples/passthrough_ll.c,3,[],https://github.com/libfuse/libfuse/pull/124,https://github.com/przemoc,1,https://github.com/libfuse/libfuse/pull/124,"3 simple fixes for examples/passthrough_ll.c, but 1 is important.","3 simple fixes for examples/passthrough_ll.c, but 1 is important.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,127,2016-12-04T17:13:32Z,2016-12-04T19:04:10Z,2016-12-04T19:04:10Z,MERGED,True,1,1,1,https://github.com/jay-hankins,Fix a grammatical error.,1,[],https://github.com/libfuse/libfuse/pull/127,https://github.com/jay-hankins,1,https://github.com/libfuse/libfuse/pull/127,,,True,"{'THUMBS_UP': ['https://github.com/kedarv', 'https://github.com/matthewess', 'https://github.com/spencer-brown', 'https://github.com/nickysemenza']}"
libfuse/libfuse,https://github.com/libfuse/libfuse,130,2016-12-11T08:36:21Z,2016-12-11T16:19:40Z,2016-12-11T16:19:40Z,MERGED,True,2,0,1,https://github.com/Khalian,Adding the markdown for travis CI build.,1,[],https://github.com/libfuse/libfuse/pull/130,https://github.com/Khalian,1,https://github.com/libfuse/libfuse/pull/130,For ease of reference.,For ease of reference.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,132,2016-12-16T14:27:09Z,2016-12-24T02:14:24Z,2016-12-26T10:04:09Z,MERGED,True,139,1,3,https://github.com/csabahenk,"Revert ""Dropped example/null.c""",1,[],https://github.com/libfuse/libfuse/pull/132,https://github.com/csabahenk,1,https://github.com/libfuse/libfuse/pull/132,"This reverts commit d5cdbb9.
null works completely fine, just the mountpoint should
be a regular file -- so there is no need to dismiss it.
Also fixing up compiler warnings.","This reverts commit d5cdbb9.
null works completely fine, just the mountpoint should
be a regular file -- so there is no need to dismiss it.
Also fixing up compiler warnings.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,132,2016-12-16T14:27:09Z,2016-12-24T02:14:24Z,2016-12-26T10:04:09Z,MERGED,True,139,1,3,https://github.com/csabahenk,"Revert ""Dropped example/null.c""",1,[],https://github.com/libfuse/libfuse/pull/132,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/132#issuecomment-267725563,"This reverts commit d5cdbb9.
null works completely fine, just the mountpoint should
be a regular file -- so there is no need to dismiss it.
Also fixing up compiler warnings.","Oh, interesting. I didn't know that a file can be a mountpoint. Thanks!
However, before adding this again, can we please document this, so that other's don't fell into the same trap as me? Ideally, main() would check if the mountpoint is indeed a file and abort if it's not....",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,132,2016-12-16T14:27:09Z,2016-12-24T02:14:24Z,2016-12-26T10:04:09Z,MERGED,True,139,1,3,https://github.com/csabahenk,"Revert ""Dropped example/null.c""",1,[],https://github.com/libfuse/libfuse/pull/132,https://github.com/csabahenk,3,https://github.com/libfuse/libfuse/pull/132#issuecomment-268575665,"This reverts commit d5cdbb9.
null works completely fine, just the mountpoint should
be a regular file -- so there is no need to dismiss it.
Also fixing up compiler warnings.","Yes, I thought of that, first I just didn't bother as I foremost just wanted to see if you support the restoration.
Now added the check.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,132,2016-12-16T14:27:09Z,2016-12-24T02:14:24Z,2016-12-26T10:04:09Z,MERGED,True,139,1,3,https://github.com/csabahenk,"Revert ""Dropped example/null.c""",1,[],https://github.com/libfuse/libfuse/pull/132,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/132#issuecomment-269064998,"This reverts commit d5cdbb9.
null works completely fine, just the mountpoint should
be a regular file -- so there is no need to dismiss it.
Also fixing up compiler warnings.","Merged, thanks! I also added some documentation, a test case, and removed the use of uninitialized memory.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,133,2016-12-19T09:26:52Z,2016-12-24T02:35:14Z,2016-12-24T02:35:14Z,MERGED,True,14,4,1,https://github.com/itsdeepak,Memory leak fixed in file : mount_bsd.c,1,[],https://github.com/libfuse/libfuse/pull/133,https://github.com/itsdeepak,1,https://github.com/libfuse/libfuse/pull/133,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,145,2017-02-24T20:32:50Z,2017-03-03T20:45:00Z,2017-03-03T20:45:00Z,MERGED,True,34,10,1,https://github.com/amosonn,Optimize fuse_fs_read.,1,[],https://github.com/libfuse/libfuse/pull/145,https://github.com/amosonn,1,https://github.com/libfuse/libfuse/pull/145,"Redundant copy when only op.read is available removed.
Formerly, fuse_fs_read called fuse_fs_read_buf unconditionally, and then copied the result from the fuse_buf into the provided mem. However, if op.read_buf is not provided, op.read is used, and then it can be used directly on the provided mem, saving the copy.","Redundant copy when only op.read is available removed.
Formerly, fuse_fs_read called fuse_fs_read_buf unconditionally, and then copied the result from the fuse_buf into the provided mem. However, if op.read_buf is not provided, op.read is used, and then it can be used directly on the provided mem, saving the copy.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,154,2017-03-28T05:14:15Z,2017-03-28T15:57:23Z,2017-03-28T15:57:23Z,MERGED,True,1,1,1,https://github.com/guraga,Do not use magic constant,1,[],https://github.com/libfuse/libfuse/pull/154,https://github.com/guraga,1,https://github.com/libfuse/libfuse/pull/154,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,154,2017-03-28T05:14:15Z,2017-03-28T15:57:23Z,2017-03-28T15:57:23Z,MERGED,True,1,1,1,https://github.com/guraga,Do not use magic constant,1,[],https://github.com/libfuse/libfuse/pull/154,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/154#issuecomment-289817009,,Thanks for the patch!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,159,2017-04-13T21:25:27Z,2017-04-14T20:29:19Z,2017-04-14T20:29:25Z,MERGED,True,5,5,1,https://github.com/tchajed,Set default options before parsing,1,[],https://github.com/libfuse/libfuse/pull/159,https://github.com/tchajed,1,https://github.com/libfuse/libfuse/pull/159,"Previously attr_timeout, entry_timeout, and negative_timeout from the mount options were ignored because the defaults were set after parsing.","Previously attr_timeout, entry_timeout, and negative_timeout from the mount options were ignored because the defaults were set after parsing.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,159,2017-04-13T21:25:27Z,2017-04-14T20:29:19Z,2017-04-14T20:29:25Z,MERGED,True,5,5,1,https://github.com/tchajed,Set default options before parsing,1,[],https://github.com/libfuse/libfuse/pull/159,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/159#issuecomment-294230559,"Previously attr_timeout, entry_timeout, and negative_timeout from the mount options were ignored because the defaults were set after parsing.",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,166,2017-05-11T08:40:15Z,2018-08-31T06:27:45Z,2018-08-31T06:27:45Z,CLOSED,False,7,3,2,https://github.com/OrenKishon,"Add fuse_file_info flags: no_read_buf, not_write_buf",1,['needs-info'],https://github.com/libfuse/libfuse/pull/166,https://github.com/OrenKishon,1,https://github.com/libfuse/libfuse/pull/166,"Currently the decision whether to use read (write) or read_buf (write_buf) is done in compilation time. We at Ctera Networks are developing a cloud-cache file system which upon a cache hit opens a spliacable disk file and upon a cache miss opens an a no-fd network stream.
We would like to have the option to decide whether to use the _buf functions at run time (on open).
This can be done by adding ""no_read_buf"" and ""no_write_buf"" flags to struct fuse_file_info","Currently the decision whether to use read (write) or read_buf (write_buf) is done in compilation time. We at Ctera Networks are developing a cloud-cache file system which upon a cache hit opens a spliacable disk file and upon a cache miss opens an a no-fd network stream.
We would like to have the option to decide whether to use the _buf functions at run time (on open).
This can be done by adding ""no_read_buf"" and ""no_write_buf"" flags to struct fuse_file_info",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,166,2017-05-11T08:40:15Z,2018-08-31T06:27:45Z,2018-08-31T06:27:45Z,CLOSED,False,7,3,2,https://github.com/OrenKishon,"Add fuse_file_info flags: no_read_buf, not_write_buf",1,['needs-info'],https://github.com/libfuse/libfuse/pull/166,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/166#issuecomment-300846811,"Currently the decision whether to use read (write) or read_buf (write_buf) is done in compilation time. We at Ctera Networks are developing a cloud-cache file system which upon a cache hit opens a spliacable disk file and upon a cache miss opens an a no-fd network stream.
We would like to have the option to decide whether to use the _buf functions at run time (on open).
This can be done by adding ""no_read_buf"" and ""no_write_buf"" flags to struct fuse_file_info",Why don't you always use the _buf functions? Just read the network stream into a memory buffer. Using _buf doesn't require you to provide an fd.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,166,2017-05-11T08:40:15Z,2018-08-31T06:27:45Z,2018-08-31T06:27:45Z,CLOSED,False,7,3,2,https://github.com/OrenKishon,"Add fuse_file_info flags: no_read_buf, not_write_buf",1,['needs-info'],https://github.com/libfuse/libfuse/pull/166,https://github.com/OrenKishon,3,https://github.com/libfuse/libfuse/pull/166#issuecomment-300884614,"Currently the decision whether to use read (write) or read_buf (write_buf) is done in compilation time. We at Ctera Networks are developing a cloud-cache file system which upon a cache hit opens a spliacable disk file and upon a cache miss opens an a no-fd network stream.
We would like to have the option to decide whether to use the _buf functions at run time (on open).
This can be done by adding ""no_read_buf"" and ""no_write_buf"" flags to struct fuse_file_info","Indeed this is our current implementation but it is a duplication of the
code that comes after the checks ""if (op.write_buf)... else"" etc, which i
see as redundant.
…
On Thu, May 11, 2017, 19:39 Nikolaus Rath ***@***.***> wrote:
 Why don't you *always* use the _buf functions? Just read the network
 stream into a memory buffer. Using _buf doesn't *require* you to provide
 an fd.

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#166 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/ABtw_iqORKBwpWUEUKxmVTW9TRIMEmMVks5r4zmzgaJpZM4NXrtF>
 .",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,166,2017-05-11T08:40:15Z,2018-08-31T06:27:45Z,2018-08-31T06:27:45Z,CLOSED,False,7,3,2,https://github.com/OrenKishon,"Add fuse_file_info flags: no_read_buf, not_write_buf",1,['needs-info'],https://github.com/libfuse/libfuse/pull/166,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/166#issuecomment-319941423,"Currently the decision whether to use read (write) or read_buf (write_buf) is done in compilation time. We at Ctera Networks are developing a cloud-cache file system which upon a cache hit opens a spliacable disk file and upon a cache miss opens an a no-fd network stream.
We would like to have the option to decide whether to use the _buf functions at run time (on open).
This can be done by adding ""no_read_buf"" and ""no_write_buf"" flags to struct fuse_file_info","Sorry, I still do not understand. Could you share the code?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,166,2017-05-11T08:40:15Z,2018-08-31T06:27:45Z,2018-08-31T06:27:45Z,CLOSED,False,7,3,2,https://github.com/OrenKishon,"Add fuse_file_info flags: no_read_buf, not_write_buf",1,['needs-info'],https://github.com/libfuse/libfuse/pull/166,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/166#issuecomment-417565339,"Currently the decision whether to use read (write) or read_buf (write_buf) is done in compilation time. We at Ctera Networks are developing a cloud-cache file system which upon a cache hit opens a spliacable disk file and upon a cache miss opens an a no-fd network stream.
We would like to have the option to decide whether to use the _buf functions at run time (on open).
This can be done by adding ""no_read_buf"" and ""no_write_buf"" flags to struct fuse_file_info",Closing this for now since there's been no activity for a while - please feel free to re-open if you want to continue working on this.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,172,2017-05-24T15:42:50Z,2017-05-24T16:58:46Z,2017-05-24T17:02:38Z,MERGED,True,10,0,2,https://github.com/bnaylor,Make tests build on bsd,1,[],https://github.com/libfuse/libfuse/pull/172,https://github.com/bnaylor,1,https://github.com/libfuse/libfuse/pull/172,"Note that the new build stuff also doesn't work on freebsd (no libdl, at least.)  I don't know anything about meson so I took a pass on that, still using ./configure","Note that the new build stuff also doesn't work on freebsd (no libdl, at least.)  I don't know anything about meson so I took a pass on that, still using ./configure",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,172,2017-05-24T15:42:50Z,2017-05-24T16:58:46Z,2017-05-24T17:02:38Z,MERGED,True,10,0,2,https://github.com/bnaylor,Make tests build on bsd,1,[],https://github.com/libfuse/libfuse/pull/172,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/172#issuecomment-303786911,"Note that the new build stuff also doesn't work on freebsd (no libdl, at least.)  I don't know anything about meson so I took a pass on that, still using ./configure","Thanks! Would you mind filing an issue about the error that you get when running Meson on FreeBSD? libdl is the Linux dynamic library loader, so there is most likely an equivalent thing on BSD..",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,172,2017-05-24T15:42:50Z,2017-05-24T16:58:46Z,2017-05-24T17:02:38Z,MERGED,True,10,0,2,https://github.com/bnaylor,Make tests build on bsd,1,[],https://github.com/libfuse/libfuse/pull/172,https://github.com/bnaylor,3,https://github.com/libfuse/libfuse/pull/172#issuecomment-303787839,"Note that the new build stuff also doesn't work on freebsd (no libdl, at least.)  I don't know anything about meson so I took a pass on that, still using ./configure","Sure, will do.  dlopen is just build into libc on FreeBSD, no need for -ldl, but meson doesn't seem to know that.  Will file an issue.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,174,2017-05-25T13:55:39Z,2017-05-25T18:51:14Z,2017-05-25T18:51:19Z,MERGED,True,0,2,1,https://github.com/pablomh,Remove fuse_fs_fgetattr and fuse_fs_ftruncate from linker script,1,[],https://github.com/libfuse/libfuse/pull/174,https://github.com/pablomh,1,https://github.com/libfuse/libfuse/pull/174,They were removed from source here: 73b6ff4,They were removed from source here: 73b6ff4,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,174,2017-05-25T13:55:39Z,2017-05-25T18:51:14Z,2017-05-25T18:51:19Z,MERGED,True,0,2,1,https://github.com/pablomh,Remove fuse_fs_fgetattr and fuse_fs_ftruncate from linker script,1,[],https://github.com/libfuse/libfuse/pull/174,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/174#issuecomment-304092425,They were removed from source here: 73b6ff4,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,177,2017-06-04T09:41:04Z,2017-06-05T15:25:16Z,2017-06-05T15:25:16Z,MERGED,True,4,4,2,https://github.com/pablomh,Fix comparison of integers of different signs,1,[],https://github.com/libfuse/libfuse/pull/177,https://github.com/pablomh,1,https://github.com/libfuse/libfuse/pull/177,"Some variables of different size and sign were getting compared
without any safe casting.
The build system also throws warnings at this and, being this
library used for filesystems, it's really important to ensure
stability.","Some variables of different size and sign were getting compared
without any safe casting.
The build system also throws warnings at this and, being this
library used for filesystems, it's really important to ensure
stability.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,177,2017-06-04T09:41:04Z,2017-06-05T15:25:16Z,2017-06-05T15:25:16Z,MERGED,True,4,4,2,https://github.com/pablomh,Fix comparison of integers of different signs,1,[],https://github.com/libfuse/libfuse/pull/177,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/177#issuecomment-306047053,"Some variables of different size and sign were getting compared
without any safe casting.
The build system also throws warnings at this and, being this
library used for filesystems, it's really important to ensure
stability.",Thanks for the patch! Looks good except for one comment above.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,177,2017-06-04T09:41:04Z,2017-06-05T15:25:16Z,2017-06-05T15:25:16Z,MERGED,True,4,4,2,https://github.com/pablomh,Fix comparison of integers of different signs,1,[],https://github.com/libfuse/libfuse/pull/177,https://github.com/kholk,3,https://github.com/libfuse/libfuse/pull/177#issuecomment-306048380,"Some variables of different size and sign were getting compared
without any safe casting.
The build system also throws warnings at this and, being this
library used for filesystems, it's really important to ensure
stability.","You should be right about that, but the patch is made to only solve the obvious problem of comparison of different types.
In any case, remember that errors on Linux and UNIX-based operating systems are identified with ""any"" (stated in errno.h) NEGATIVE number so, while the check can be improved for a specific error check case, the current version (ret<0) is just... Safe.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,177,2017-06-04T09:41:04Z,2017-06-05T15:25:16Z,2017-06-05T15:25:16Z,MERGED,True,4,4,2,https://github.com/pablomh,Fix comparison of integers of different signs,1,[],https://github.com/libfuse/libfuse/pull/177,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/177#issuecomment-306196650,"Some variables of different size and sign were getting compared
without any safe casting.
The build system also throws warnings at this and, being this
library used for filesystems, it's really important to ensure
stability.","The current version does not have ret < 0 but ret == -1, that's the problem (line 2938). We shouldn't be casting to an unsigned type (size_t) if the value may be negative.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,177,2017-06-04T09:41:04Z,2017-06-05T15:25:16Z,2017-06-05T15:25:16Z,MERGED,True,4,4,2,https://github.com/pablomh,Fix comparison of integers of different signs,1,[],https://github.com/libfuse/libfuse/pull/177,https://github.com/kholk,5,https://github.com/libfuse/libfuse/pull/177#issuecomment-306217145,"Some variables of different size and sign were getting compared
without any safe casting.
The build system also throws warnings at this and, being this
library used for filesystems, it's really important to ensure
stability.","That's absolutely right, but please note that I don't know when I'll find time to fix the commit!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/joe0184,1,https://github.com/libfuse/libfuse/pull/181,Add a high level API parameter to configure the number of idle worker threads for op handling.,Add a high level API parameter to configure the number of idle worker threads for op handling.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/trapexit,2,https://github.com/libfuse/libfuse/pull/181#issuecomment-311090976,Add a high level API parameter to configure the number of idle worker threads for op handling.,"While I think this is a necessary change there is still an issue with the design. Spawning threads on the fly with a hard reaping behavior is costly. I've seen massive thread churn in highly concurrent situations leading to high load.
I've been experimenting with fixing the number of threads and removing all the mutex usage in the main loop. Simplifies the code, reduces contention (there is no need for the mutexs there), and seems to perform better under load.
That said it's been all anecdotal and I need to build tests to ensure it makes a reasonable difference.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/joe0184,3,https://github.com/libfuse/libfuse/pull/181#issuecomment-311103018,Add a high level API parameter to configure the number of idle worker threads for op handling.,"I did notice that this really only answers half of your enhancement to improve threading. As far as the current implementation goes, we noticed when testing our workloads that increasing the number of idle threads to 32 can give us a 30% performance boost. This may be moot since it sounds like you are close to making your changes.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/trapexit,4,https://github.com/libfuse/libfuse/pull/181#issuecomment-311104475,Add a high level API parameter to configure the number of idle worker threads for op handling.,I've made these changes to 2.9.7 (though simple enough to port to 3.x. I don't see any conflict with your changes with what I've done so if @Nikratio is happy with them I think its fine. I need to confirm what I've done makes a difference before trying to upstream them. I also need to port my fs to the 3.x API at some point.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/181#issuecomment-314442822,Add a high level API parameter to configure the number of idle worker threads for op handling.,"This looks good to me. However, you still need to add code to preserve backwards compatibility. If you change the definition of fuse_loop_mt(), programs that were compiled against earlier versions of libfuse will crash when they are linked against the more recent one. And attempts to compile against the more recent version will fail. You can take a look at the recent introduction of fuse_lib_help for ideas of how to do that. Note, however, that there is still a problem with the symbol redefinition (see comments on the commit).
Without backwards compatibility, this would have to wait until libfuse4.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/joe0184,6,https://github.com/libfuse/libfuse/pull/181#issuecomment-314793168,Add a high level API parameter to configure the number of idle worker threads for op handling.,"Would it work to use a new max_idle_threads global variable instead of changing the function definition to pass the value? On one hand, it seems to depart from the project's coding style. On the other, it may reduce complexity by avoiding symbol versioning. Perhaps there are other implications that I'm not thinking of?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/181#issuecomment-314797381,Add a high level API parameter to configure the number of idle worker threads for op handling.,"Yeah, it would work, and yeah, that would be a pretty terrible solution.  Let's do it the right away.
As a matter of fact, let's make sure the problem does not re-appear in the future. Instead of adding a new parameter, let's introduce a struct fuse_loop_config that starts out with clone_fd and max_idle_threads fields and pass that instead of clone_fd. That still requires symbol versioning, but future extensions can than be added easily. (I can see a thread_init_fn function on the horizon that would be called whenever a new thread is created).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/joe0184,8,https://github.com/libfuse/libfuse/pull/181#issuecomment-316127654,Add a high level API parameter to configure the number of idle worker threads for op handling.,"I added the new struct and version of fuse_session_loop_mt, but I did not change the libfuse minor version number.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/181#issuecomment-319760704,Add a high level API parameter to configure the number of idle worker threads for op handling.,"Looks good to me now! I agree with @trapexit  that more documentation would be better, but I still think that this is an improvement over the status quo. So the only remaining issue is to fix the conflicts with the master branch, so that I can actually merge :-P.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,10,https://github.com/libfuse/libfuse/pull/181#issuecomment-319948571,Add a high level API parameter to configure the number of idle worker threads for op handling.,Working on the merge myself now...,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,11,https://github.com/libfuse/libfuse/pull/181#issuecomment-319986213,Add a high level API parameter to configure the number of idle worker threads for op handling.,"While attempting to merge, I found some additional problems, sorry:

Currently, the new max_idle field in struct fuse_config is never actually used (only set).
The calls to fuse_session_loop_mt() in fuse.c still use the clone_fd parameter.
The fuse_loop() function should also be changed to take a struct loop_config instead of int clonefd
Please add a ChangeLog entry and update the fuse version",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/joe0184,12,https://github.com/libfuse/libfuse/pull/181#issuecomment-322288597,Add a high level API parameter to configure the number of idle worker threads for op handling.,"Sorry that it took so long for me to get around to this. It turns out that max_idle_threads was being set to 0 and I guess that was causing the test to slow down to the point of failure. Is this still something we want users to be allowed to do? I could change fuse_parse_cmdline to allow it again. Otherwise, where would be the best place to document why you can't do it?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,13,https://github.com/libfuse/libfuse/pull/181#issuecomment-322481742,Add a high level API parameter to configure the number of idle worker threads for op handling.,"I think you should still allow the user to do it (if only becomes it actually makes the code cleaner, see my other comment). The right place to warn about the performance implications is In the description of struct fuse_loop_config (in fuse_common.h).
Thanks for working on this!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,181,2017-06-26T15:07:36Z,2017-08-24T13:17:02Z,2017-08-24T13:17:02Z,MERGED,True,105,21,13,https://github.com/joe0184,Add idle_threads parameter,1,[],https://github.com/libfuse/libfuse/pull/181,https://github.com/Nikratio,14,https://github.com/libfuse/libfuse/pull/181#issuecomment-324623215,Add a high level API parameter to configure the number of idle worker threads for op handling.,"Sorry that this has been taking so long. But with all the merges and separate commits, it's been very difficult to review. I just squashed and rebased everything on master. This should make things easier.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,183,2017-07-04T02:07:53Z,2017-07-08T10:16:14Z,2017-07-08T10:16:19Z,MERGED,True,1,1,1,https://github.com/PeterMartini,Update comment in example/null.c,1,[],https://github.com/libfuse/libfuse/pull/183,https://github.com/PeterMartini,1,https://github.com/libfuse/libfuse/pull/183,Update header comment in null.c to reference it's own name.,Update header comment in null.c to reference it's own name.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,183,2017-07-04T02:07:53Z,2017-07-08T10:16:14Z,2017-07-08T10:16:19Z,MERGED,True,1,1,1,https://github.com/PeterMartini,Update comment in example/null.c,1,[],https://github.com/libfuse/libfuse/pull/183,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/183#issuecomment-313847271,Update header comment in null.c to reference it's own name.,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,187,2017-07-28T16:08:28Z,2017-08-02T18:36:12Z,2017-08-02T18:36:19Z,MERGED,True,6,2,2,https://github.com/heirecka,Ask pkgconfig where we should install udev rules,1,[],https://github.com/libfuse/libfuse/pull/187,https://github.com/heirecka,1,https://github.com/libfuse/libfuse/pull/187,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,187,2017-07-28T16:08:28Z,2017-08-02T18:36:12Z,2017-08-02T18:36:19Z,MERGED,True,6,2,2,https://github.com/heirecka,Ask pkgconfig where we should install udev rules,1,[],https://github.com/libfuse/libfuse/pull/187,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/187#issuecomment-318754090,,"Why do you think this is better? On Debian, libdir is usr/lib, but udev rules are supposed to go in /lib/.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,187,2017-07-28T16:08:28Z,2017-08-02T18:36:12Z,2017-08-02T18:36:19Z,MERGED,True,6,2,2,https://github.com/heirecka,Ask pkgconfig where we should install udev rules,1,[],https://github.com/libfuse/libfuse/pull/187,https://github.com/heirecka,3,https://github.com/libfuse/libfuse/pull/187#issuecomment-318780012,,"All those small differences between distros ;-)
Guess I could ask udev about udevdir via pkg-config to make everybody happy.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,187,2017-07-28T16:08:28Z,2017-08-02T18:36:12Z,2017-08-02T18:36:19Z,MERGED,True,6,2,2,https://github.com/heirecka,Ask pkgconfig where we should install udev rules,1,[],https://github.com/libfuse/libfuse/pull/187,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/187#issuecomment-318819926,,Is there a way to use pkg-config? That would be great.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,187,2017-07-28T16:08:28Z,2017-08-02T18:36:12Z,2017-08-02T18:36:19Z,MERGED,True,6,2,2,https://github.com/heirecka,Ask pkgconfig where we should install udev rules,1,[],https://github.com/libfuse/libfuse/pull/187,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/187#issuecomment-319760060,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,188,2017-08-01T09:19:00Z,2017-08-01T14:26:24Z,2017-08-01T14:26:24Z,MERGED,True,3,3,3,https://github.com/hbl0307106015,Fix compiler warnings of gcc-5.4.x,1,[],https://github.com/libfuse/libfuse/pull/188,https://github.com/hbl0307106015,1,https://github.com/libfuse/libfuse/pull/188,"This PR can fix below  warnings which occur on compilation via gcc-5.4.x.
In file included from mount.c:24:0:
/home/banglang/work/op-lede/x86/staging_dir/toolchain-x86_64_gcc-5.4.0_musl/include/sys/poll.h:1:2: warning: #warning redirecting incorrect #include <sys/poll.h> to <poll.h> [-Wcpp]
#warning redirecting incorrect #include <sys/poll.h> to <poll.h>
^
In file included from cuse_client.c:43:0:
/home/banglang/work/op-lede/x86/staging_dir/toolchain-x86_64_gcc-5.4.0_musl/include/sys/fcntl.h:1:2: warning: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Wcpp]
#warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
^
In file included from ioctl_client.c:27:0:
/home/banglang/work/op-lede/x86/staging_dir/toolchain-x86_64_gcc-5.4.0_musl/include/sys/fcntl.h:1:2: warning: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Wcpp]
#warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
^
Signed-off-by: Banglang banglang.huang@foxmail.com","This PR can fix below  warnings which occur on compilation via gcc-5.4.x.
In file included from mount.c:24:0:
/home/banglang/work/op-lede/x86/staging_dir/toolchain-x86_64_gcc-5.4.0_musl/include/sys/poll.h:1:2: warning: #warning redirecting incorrect #include <sys/poll.h> to <poll.h> [-Wcpp]
#warning redirecting incorrect #include <sys/poll.h> to <poll.h>
^
In file included from cuse_client.c:43:0:
/home/banglang/work/op-lede/x86/staging_dir/toolchain-x86_64_gcc-5.4.0_musl/include/sys/fcntl.h:1:2: warning: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Wcpp]
#warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
^
In file included from ioctl_client.c:27:0:
/home/banglang/work/op-lede/x86/staging_dir/toolchain-x86_64_gcc-5.4.0_musl/include/sys/fcntl.h:1:2: warning: #warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h> [-Wcpp]
#warning redirecting incorrect #include <sys/fcntl.h> to <fcntl.h>
^
Signed-off-by: Banglang banglang.huang@foxmail.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,189,2017-08-03T13:14:04Z,2017-08-03T14:40:37Z,2017-08-03T15:10:14Z,MERGED,True,50,1,4,https://github.com/bapt,Freebsd,3,[],https://github.com/libfuse/libfuse/pull/189,https://github.com/bapt,1,https://github.com/libfuse/libfuse/pull/189,Upstream FreeBSD changes and fix build with meson,Upstream FreeBSD changes and fix build with meson,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,189,2017-08-03T13:14:04Z,2017-08-03T14:40:37Z,2017-08-03T15:10:14Z,MERGED,True,50,1,4,https://github.com/bapt,Freebsd,3,[],https://github.com/libfuse/libfuse/pull/189,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/189#issuecomment-319983236,Upstream FreeBSD changes and fix build with meson,"Wow, thanks a lot! Much appreciated.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,189,2017-08-03T13:14:04Z,2017-08-03T14:40:37Z,2017-08-03T15:10:14Z,MERGED,True,50,1,4,https://github.com/bapt,Freebsd,3,[],https://github.com/libfuse/libfuse/pull/189,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/189#issuecomment-319997695,Upstream FreeBSD changes and fix build with meson,"...where ""this patch"" is the ""Support fsname= option"" commit.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/marcinsulikowski,1,https://github.com/libfuse/libfuse/pull/190,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?","I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/190#issuecomment-320499248,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?","Thanks for the patch! No, the lack of FUSE_POSIX_ACL in libfuse is not a design choice. libfuse has not yet been updated to support ACLs. But it looks as if this is about to change :-).
I'll try to review this soon.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/190#issuecomment-320499497,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?","Alright, that patch is a little shorter than expected :-).
We do not need to add support for this unconditionally. You need to add a capability flag that the filesystem can test for (and set) in its init method (similarly to eg. FUSE_CAP_WRITEBACK_CACHE). The documentation for the capability flag should also clearly state what is expected of filesystems that enable this feature. It has been a while since I looked at the corresponding kernel patch, but I believe among other things it requires the file system to support getxattr and setxattr. Where possible, libfuse should also check for these requirements programmatically (and e.g. abort if the filesystems claims to support ACL's but doesn't define xattr handlers).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/marcinsulikowski,4,https://github.com/libfuse/libfuse/pull/190#issuecomment-320627704,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?","libfuse has not yet been updated to support ACLs


We do not need to add support for this unconditionally. You need to add a capability flag that the filesystem can test for (and set) in its init method (similarly to eg. FUSE_CAP_WRITEBACK_CACHE). The documentation for the capability flag should also clearly state what is expected of filesystems that enable this feature.

Haven't you already add this flag in e16fdc0 and 4fdf83f? Those commits seem to add the required FUSE_CAP_POSIX_ACL flag and document it. The only issue is that even if the filesystem implementation sets the capability flag in its init method, the corresponding feature flag is not passed to the kernel and this is what my commit tries to fix.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/190#issuecomment-320646578,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?","I'm getting old, yes, it seems I already added most of what's required. In that case, please just add a ChangeLog entry that documents that only now ACLs will actually work.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/marcinsulikowski,6,https://github.com/libfuse/libfuse/pull/190#issuecomment-320658920,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?",I updated the changelog file in my commit and also rebased the commit to the latest master branch to avoid conflicts with the changes in the changelog file related to the fuse-3.1.1 release.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,190,2017-08-03T15:02:09Z,2017-08-07T13:53:03Z,2017-08-07T13:53:08Z,MERGED,True,9,0,2,https://github.com/marcinsulikowski,Fix support for FUSE_POSIX_ACL,1,[],https://github.com/libfuse/libfuse/pull/190,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/190#issuecomment-320669630,"I tried to use the POSIX ACL feature which has been included in Linux kernels ≥ 4.9 but it did not work for me. After looking into the libfuse and Linux kernel sources I concluded that the kernel expects the FUSE_POSIX_ACL to be included when replying the initial FUSE_INIT request and the library never sets it. The change included in the attached commit fixes the problem for me.
However, maybe I did something wrong? I can see there are a few other flags which are never set by libfuse in outarg.flags in do_init (e.g., FUSE_HANDLE_KILLPRIV). Is the lack of FUSE_POSIX_ACL in outarg.flags an oversight in the library or maybe there is something else that file system implementations have to do to enable ACLs? How about the other flags?",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/saf,1,https://github.com/libfuse/libfuse/pull/192,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.","We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/192#issuecomment-320255774,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.","Thanks for the pull request!
My first instictive reaction is:

Having cache invalidation in the high-level API would be great
This should definitely land in libfuse 3.x first. After that we can think about backporting to libfuse 2.9 (which I am skeptical about, both because it's a new feature and it may involve significant changes)
It should probably be based on path names rather than inodes (or at least offer pathname based invalidation as an option), because the use of path names is about 50% of the high-level API. If you only use pathnames, you could also use the existing pathname-inode hash table and would not need to introduce another one.

I'll look into it in more detail when I have more time. But maybe you can already ponder the above :-).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/saf,3,https://github.com/libfuse/libfuse/pull/192#issuecomment-320626224,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.","Thank you for your feedback. The changes used the ""FS inode"" rather than the paths because that's what our network-based file system's server talks. It's probably OK, just a bit less convenient, for it to supply paths rather than inode numbers.
So, I can try my hand at reworking the solution. As you pointed out, all the necessary pieces are already there. Actually, I found code which used to be the fuse_invalidate in an old commit by Miklos (891b874eedc); how would you feel about just reviving that (in terms of implementation and naming)?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/trapexit,4,https://github.com/libfuse/libfuse/pull/192#issuecomment-320640224,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.",It'd be convenient to have the high level API offer both the node id & generation id as well as the path. There have been a few situations where keying off that value would have been nicer (unfortunately it's too early in the morning for me to remember the situation.),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/192#issuecomment-320647261,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.","I don't think this code will be useful, it hasn't aged well. The implementation should really call the fuse_lowlevel_notify function, and I think the name should be similar.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/saf,6,https://github.com/libfuse/libfuse/pull/192#issuecomment-320719215,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.","Yes, @Nikratio, I meant reviving that code and adapting it to the modern codebase, of course. It turned out to be pretty neat, but let me do some testing before I update the PR.
@trapexit, can you please elaborate on the scenarios where nodeid/generation would be useful for invalidation in high-level API? Aren't file systems which use the high-level API generally unaware of the node IDs, let alone node generations? Thanks.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/trapexit,7,https://github.com/libfuse/libfuse/pull/192#issuecomment-320722510,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.","I wasn't referring to invalidation. I'm speaking more generally. I would like if the API as a whole gave all information it held to the user. {node,generation} and internal inode (when not using use_ino) come to mind. Knowing {node,generation} is unique, for example, can make it more convenient as a key in certain data structures should you want to use the high level API and let it do the lower level node management but still want to efficiently reference those nodes.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,192,2017-08-04T13:49:05Z,2017-08-08T14:45:51Z,2017-08-08T14:46:13Z,CLOSED,False,85,4,2,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/192,https://github.com/saf,8,https://github.com/libfuse/libfuse/pull/192#issuecomment-320978525,"We introduce a new routine to the high-level FUSE API,
fuse_notify_inval_fs_inode, which is responsible for invalidating the
cached data for an inode.
The routine uses a new mapping of the ""FS inodes"" (inode numbers
returned in the 'st_ino' field from 'getattr') into the nodes in the
high-level FUSE API. Naturally, because multiple paths may refer to
the same inode on the file system due to hard links, the mapping is
one-to-many, and is implemented by means of a hash table. Internally,
the high-level API routine calls the low-level routine
fuse_notify_inval_inode.
This is useful for network-based file systems which use the high-level
FUSE API. Up to now, there was no way for those file systems to notify
the kernel about external changes.

I know this PR is not in perfect shape now (it could be using dynamically-sized hash tables, and it's based on fuse_2_9_bugfix), but before fixing and rebasing it, I'd like to ask for feedback from the maintainers on whether this would be an acceptable solution for providing external change notifications from file systems which use the high-level FUSE API.",I'm going to close this PR in favor of another one which I'm preparing which will be based on the master branch and answer @Nikratio's remarks.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,195,2017-08-08T14:47:39Z,2017-08-24T12:28:29Z,2017-08-24T12:28:29Z,CLOSED,False,378,4,9,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/195,https://github.com/saf,1,https://github.com/libfuse/libfuse/pull/195,"We re-introduce the functionality of invalidating the caches for an
inode specified by path by adding a new routine
fuse_invalidate_path. This is useful for network-based file systems
which use the high-level API, enabling them to notify the kernel about
external changes.
This is a revival of Miklos Szeredi's original code for the
fuse_invalidate routine.","We re-introduce the functionality of invalidating the caches for an
inode specified by path by adding a new routine
fuse_invalidate_path. This is useful for network-based file systems
which use the high-level API, enabling them to notify the kernel about
external changes.
This is a revival of Miklos Szeredi's original code for the
fuse_invalidate routine.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,195,2017-08-08T14:47:39Z,2017-08-24T12:28:29Z,2017-08-24T12:28:29Z,CLOSED,False,378,4,9,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/195,https://github.com/saf,2,https://github.com/libfuse/libfuse/pull/195#issuecomment-322827494,"We re-introduce the functionality of invalidating the caches for an
inode specified by path by adding a new routine
fuse_invalidate_path. This is useful for network-based file systems
which use the high-level API, enabling them to notify the kernel about
external changes.
This is a revival of Miklos Szeredi's original code for the
fuse_invalidate routine.",I have posted another commit which makes fuse_invalidate_path return -ENOENT if the entry does not exist as per your advice. Please let me know if you have any other remarks. Should I squash the commits (they are meant to be squashed) or is that done when accepting the PR?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,195,2017-08-08T14:47:39Z,2017-08-24T12:28:29Z,2017-08-24T12:28:29Z,CLOSED,False,378,4,9,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/195,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/195#issuecomment-322864297,"We re-introduce the functionality of invalidating the caches for an
inode specified by path by adding a new routine
fuse_invalidate_path. This is useful for network-based file systems
which use the high-level API, enabling them to notify the kernel about
external changes.
This is a revival of Miklos Szeredi's original code for the
fuse_invalidate routine.","Thanks! I can squash the commits on merge. However, I don't actually see any test case. Are you referring to the new file in the examples directory? If so, you need to make sure that the unit tests actually run that example. Take a look at test/test_examples.py to see how this is done.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,195,2017-08-08T14:47:39Z,2017-08-24T12:28:29Z,2017-08-24T12:28:29Z,CLOSED,False,378,4,9,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/195,https://github.com/saf,4,https://github.com/libfuse/libfuse/pull/195#issuecomment-323030379,"We re-introduce the functionality of invalidating the caches for an
inode specified by path by adding a new routine
fuse_invalidate_path. This is useful for network-based file systems
which use the high-level API, enabling them to notify the kernel about
external changes.
This is a revival of Miklos Szeredi's original code for the
fuse_invalidate routine.","Oh, sorry, the modified test_ctests.py got lost in my build folder. I now updated that and also rebased & squashed the commits because there were conflicts with some recent changes to master.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,195,2017-08-08T14:47:39Z,2017-08-24T12:28:29Z,2017-08-24T12:28:29Z,CLOSED,False,378,4,9,https://github.com/saf,Allow inode cache invalidation in high-level API,1,[],https://github.com/libfuse/libfuse/pull/195,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/195#issuecomment-324619897,"We re-introduce the functionality of invalidating the caches for an
inode specified by path by adding a new routine
fuse_invalidate_path. This is useful for network-based file systems
which use the high-level API, enabling them to notify the kernel about
external changes.
This is a revival of Miklos Szeredi's original code for the
fuse_invalidate routine.","Merged, thanks for your contribution!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,200,2017-08-14T15:45:53Z,2017-08-14T18:02:29Z,2017-08-14T18:23:03Z,MERGED,True,6,3,4,https://github.com/userwithuid,fix lto build,1,[],https://github.com/libfuse/libfuse/pull/200,https://github.com/userwithuid,1,https://github.com/libfuse/libfuse/pull/200,"attempt at a workaround for #198
same as what you did here for fuse.c, but you ignored the same call in helper.c.
builds on your gcc 4.8 travis. also, on my arch setup with gcc 7.1, this builds and runs fuse3+sshfs with -flto.","attempt at a workaround for #198
same as what you did here for fuse.c, but you ignored the same call in helper.c.
builds on your gcc 4.8 travis. also, on my arch setup with gcc 7.1, this builds and runs fuse3+sshfs with -flto.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,200,2017-08-14T15:45:53Z,2017-08-14T18:02:29Z,2017-08-14T18:23:03Z,MERGED,True,6,3,4,https://github.com/userwithuid,fix lto build,1,[],https://github.com/libfuse/libfuse/pull/200,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/200#issuecomment-322239478,"attempt at a workaround for #198
same as what you did here for fuse.c, but you ignored the same call in helper.c.
builds on your gcc 4.8 travis. also, on my arch setup with gcc 7.1, this builds and runs fuse3+sshfs with -flto.","Makes sense, thanks for looking into this!
Could you please add a ChangeLog entry though?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,200,2017-08-14T15:45:53Z,2017-08-14T18:02:29Z,2017-08-14T18:23:03Z,MERGED,True,6,3,4,https://github.com/userwithuid,fix lto build,1,[],https://github.com/libfuse/libfuse/pull/200,https://github.com/userwithuid,3,https://github.com/libfuse/libfuse/pull/200#issuecomment-322249244,"attempt at a workaround for #198
same as what you did here for fuse.c, but you ignored the same call in helper.c.
builds on your gcc 4.8 travis. also, on my arch setup with gcc 7.1, this builds and runs fuse3+sshfs with -flto.",changelog updated,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,210,2017-09-27T07:28:38Z,2017-09-27T14:01:56Z,2017-09-27T14:09:27Z,MERGED,True,1,1,1,https://github.com/mununum,Adding pointer dereferencing after calling dlsym(),1,['bug'],https://github.com/libfuse/libfuse/pull/210,https://github.com/mununum,1,https://github.com/libfuse/libfuse/pull/210,"dlsym() resolves the location of the loaded symbol,
therefore dlsym() returns the type (fuse_module_factory_t *), not (fuse_module_factory_t).
Added pointer dereferencing to correctly refer the factory function.","dlsym() resolves the location of the loaded symbol,
therefore dlsym() returns the type (fuse_module_factory_t *), not (fuse_module_factory_t).
Added pointer dereferencing to correctly refer the factory function.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,210,2017-09-27T07:28:38Z,2017-09-27T14:01:56Z,2017-09-27T14:09:27Z,MERGED,True,1,1,1,https://github.com/mununum,Adding pointer dereferencing after calling dlsym(),1,['bug'],https://github.com/libfuse/libfuse/pull/210,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/210#issuecomment-332464573,"dlsym() resolves the location of the loaded symbol,
therefore dlsym() returns the type (fuse_module_factory_t *), not (fuse_module_factory_t).
Added pointer dereferencing to correctly refer the factory function.",Thanks for the patch! Am I right that this just silences some (which?) compiler warning? Or are there any practical problems fixed by this? In that case it would be great to have a test case.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,210,2017-09-27T07:28:38Z,2017-09-27T14:01:56Z,2017-09-27T14:09:27Z,MERGED,True,1,1,1,https://github.com/mununum,Adding pointer dereferencing after calling dlsym(),1,['bug'],https://github.com/libfuse/libfuse/pull/210,https://github.com/mununum,3,https://github.com/libfuse/libfuse/pull/210#issuecomment-332527194,"dlsym() resolves the location of the loaded symbol,
therefore dlsym() returns the type (fuse_module_factory_t *), not (fuse_module_factory_t).
Added pointer dereferencing to correctly refer the factory function.","This issue is not the one of some compiler warning issues,
and there can be practical problems with this issue.
In order to test this issue, I first bypassed out builtin module registration in fuse.c
to execute the dlopen() routine when loading subdir module.
from fuse.c:4712 in master branch
    pthread_mutex_lock(&fuse_context_lock);
#if 0
    static int builtin_modules_registered = 0;
    /* Have the builtin modules already been registered? */
    if (builtin_modules_registered == 0) {
        /* If not, register them. */
        fuse_register_module(""subdir"", fuse_module_subdir_factory, NULL);
#ifdef HAVE_ICONV
        fuse_register_module(""iconv"", fuse_module_iconv_factory, NULL);
#endif
        builtin_modules_registered= 1;
    }
#endif
    pthread_mutex_unlock(&fuse_context_lock);

Then I have built libfusemod_subdir.so by compiling modules/subdir.c with -fPIC -shared option.
I tested basic FUSE implementation, ""hello"" by entering following command:
$ ./hello -o modules=""subdir,subdir=/subdir"" /mnt/fuse
Without this issue resolved, this execution crashes with segfault.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,210,2017-09-27T07:28:38Z,2017-09-27T14:01:56Z,2017-09-27T14:09:27Z,MERGED,True,1,1,1,https://github.com/mununum,Adding pointer dereferencing after calling dlsym(),1,['bug'],https://github.com/libfuse/libfuse/pull/210,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/210#issuecomment-332530835,"dlsym() resolves the location of the loaded symbol,
therefore dlsym() returns the type (fuse_module_factory_t *), not (fuse_module_factory_t).
Added pointer dereferencing to correctly refer the factory function.","Amazing. So this has been broken since 2013. I am almost tempted to remove the entire loadable module support, since apparently no one is using it. But I guess that wouldn't be fair to you, since I assume you are planning to use it now?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,215,2017-10-19T12:10:53Z,2017-10-20T07:42:31Z,2017-10-20T07:42:36Z,MERGED,True,9,2,2,https://github.com/Mic92,make udevrulesdir configurable,1,[],https://github.com/libfuse/libfuse/pull/215,https://github.com/Mic92,1,https://github.com/libfuse/libfuse/pull/215,"on nixos we install fuse in its own hierarchy independent from systemd.
cc @primeos","on nixos we install fuse in its own hierarchy independent from systemd.
cc @primeos",True,{'THUMBS_UP': ['https://github.com/primeos']}
libfuse/libfuse,https://github.com/libfuse/libfuse,215,2017-10-19T12:10:53Z,2017-10-20T07:42:31Z,2017-10-20T07:42:36Z,MERGED,True,9,2,2,https://github.com/Mic92,make udevrulesdir configurable,1,[],https://github.com/libfuse/libfuse/pull/215,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/215#issuecomment-338130785,"on nixos we install fuse in its own hierarchy independent from systemd.
cc @primeos",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,216,2017-10-20T21:05:53Z,2018-03-28T19:38:27Z,2018-03-28T19:38:27Z,MERGED,True,20,0,2,https://github.com/admorgan,Add example configuration file,1,[],https://github.com/libfuse/libfuse/pull/216,https://github.com/admorgan,1,https://github.com/libfuse/libfuse/pull/216,"Add a configuration file with all options disabled that includes
all valid options and their description. This file is called out
in the packaging notes to be included in the -common package","Add a configuration file with all options disabled that includes
all valid options and their description. This file is called out
in the packaging notes to be included in the -common package",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,216,2017-10-20T21:05:53Z,2018-03-28T19:38:27Z,2018-03-28T19:38:27Z,MERGED,True,20,0,2,https://github.com/admorgan,Add example configuration file,1,[],https://github.com/libfuse/libfuse/pull/216,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/216#issuecomment-377009947,"Add a configuration file with all options disabled that includes
all valid options and their description. This file is called out
in the packaging notes to be included in the -common package",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,219,2017-11-01T05:52:26Z,2017-11-01T05:54:45Z,2017-11-01T05:54:45Z,CLOSED,False,321,874,22,https://github.com/akilrgit123,Fuse 2 9 bugfix,31,[],https://github.com/libfuse/libfuse/pull/219,https://github.com/akilrgit123,1,https://github.com/libfuse/libfuse/pull/219,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/jsoref,1,https://github.com/libfuse/libfuse/pull/221,"issue #211
I have no idea if this will work. But is this the right file/direction?","issue #211
I have no idea if this will work. But is this the right file/direction?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/221#issuecomment-346590481,"issue #211
I have no idea if this will work. But is this the right file/direction?",That really depends on what you are trying to achieve. Maybe you could elaborate on your goals?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/221#issuecomment-346590849,"issue #211
I have no idea if this will work. But is this the right file/direction?","Sorry, just saw the issue reference. No, this is the wrong way to do it. As the issue says, this needs to be filtered out in the mount helper.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/jsoref,4,https://github.com/libfuse/libfuse/pull/221#issuecomment-346645610,"issue #211
I have no idea if this will work. But is this the right file/direction?",@Nikratio: where is that?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/221#issuecomment-346685483,"issue #211
I have no idea if this will work. But is this the right file/direction?",https://github.com/libfuse/libfuse/blob/master/util/mount.fuse.c#L155,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/jsoref,6,https://github.com/libfuse/libfuse/pull/221#issuecomment-346975141,"issue #211
I have no idea if this will work. But is this the right file/direction?",@Nikratio: how's this?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/221#issuecomment-347138859,"issue #211
I have no idea if this will work. But is this the right file/direction?",Doesn't look right to me. Why do you think the presence of nofail should affect the exit code?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/jsoref,8,https://github.com/libfuse/libfuse/pull/221#issuecomment-347270986,"issue #211
I have no idea if this will work. But is this the right file/direction?","Sorry. The documentation for this stuff is more or less vaporous. nofail definitely affects someone's handling of an error status. But, I think you're right, it's just the caller's understanding of the error status, not the callee.
I'll try to post the obvious/simpler fix (closer to my original, but for this file) tonight.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/jsoref,9,https://github.com/libfuse/libfuse/pull/221#issuecomment-347352772,"issue #211
I have no idea if this will work. But is this the right file/direction?",@Nikratio : how about this? :),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/Nikratio,10,https://github.com/libfuse/libfuse/pull/221#issuecomment-347889740,"issue #211
I have no idea if this will work. But is this the right file/direction?",Looks good! Now just add a ChangeLog entry for this.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,221,2017-11-23T00:15:13Z,2017-12-01T19:18:50Z,2018-01-09T22:34:45Z,MERGED,True,3,0,2,https://github.com/jsoref,Naive attempt at handling nofail,1,['needs-info'],https://github.com/libfuse/libfuse/pull/221,https://github.com/jsoref,11,https://github.com/libfuse/libfuse/pull/221#issuecomment-348078146,"issue #211
I have no idea if this will work. But is this the right file/direction?",@Nikratio : done,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,223,2017-11-26T04:51:00Z,2017-11-27T10:23:21Z,2017-11-27T18:03:36Z,MERGED,True,18,18,8,https://github.com/jsoref,Spelling,12,[],https://github.com/libfuse/libfuse/pull/223,https://github.com/jsoref,1,https://github.com/libfuse/libfuse/pull/223,"Generated by https://github.com/jsoref/spelling f; to maintain your repo, please consider fchurn","Generated by https://github.com/jsoref/spelling f; to maintain your repo, please consider fchurn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,223,2017-11-26T04:51:00Z,2017-11-27T10:23:21Z,2017-11-27T18:03:36Z,MERGED,True,18,18,8,https://github.com/jsoref,Spelling,12,[],https://github.com/libfuse/libfuse/pull/223,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/223#issuecomment-347139023,"Generated by https://github.com/jsoref/spelling f; to maintain your repo, please consider fchurn",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,225,2017-11-27T15:56:15Z,2017-11-27T19:53:10Z,2017-11-27T19:53:15Z,MERGED,True,2,2,1,https://github.com/divinity76,"fix ""Rath Consulting"" link",1,[],https://github.com/libfuse/libfuse/pull/225,https://github.com/divinity76,1,https://github.com/libfuse/libfuse/pull/225,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,225,2017-11-27T15:56:15Z,2017-11-27T19:53:10Z,2017-11-27T19:53:15Z,MERGED,True,2,2,1,https://github.com/divinity76,"fix ""Rath Consulting"" link",1,[],https://github.com/libfuse/libfuse/pull/225,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/225#issuecomment-347306371,,thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,229,2018-01-15T20:32:32Z,2018-01-15T20:45:55Z,2018-01-15T20:46:00Z,MERGED,True,1,1,1,https://github.com/Tomatosoup97,"Fix typo in ""passthrough"" docstring",1,[],https://github.com/libfuse/libfuse/pull/229,https://github.com/Tomatosoup97,1,https://github.com/libfuse/libfuse/pull/229,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,229,2018-01-15T20:32:32Z,2018-01-15T20:45:55Z,2018-01-15T20:46:00Z,MERGED,True,1,1,1,https://github.com/Tomatosoup97,"Fix typo in ""passthrough"" docstring",1,[],https://github.com/libfuse/libfuse/pull/229,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/229#issuecomment-357785353,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,232,2018-02-04T19:42:23Z,2018-05-24T15:02:42Z,2018-05-24T15:02:42Z,CLOSED,False,5,5,1,https://github.com/thopiekar,Adding possibility enforce a prefix,1,['needs-info'],https://github.com/libfuse/libfuse/pull/232,https://github.com/thopiekar,1,https://github.com/libfuse/libfuse/pull/232,"In most scenarios, the script is installing to the default locations, where eg. device nodes or udev rules are normally placed. However, since I want to install libfuse to a prefix, which is built with user permissions, I don't have the permissions to place files there.
Therefore I added a new variable, which forces to place the files into a custom prefix.
Of course, there is also DESTDIR, but in my case I don't want to use it, because (if prefix == destdir) I would get /my/custom/prefix/path/my/custom/prefix/path as the location for all the other files.
Any other solutions and thoughts are welcome!","In most scenarios, the script is installing to the default locations, where eg. device nodes or udev rules are normally placed. However, since I want to install libfuse to a prefix, which is built with user permissions, I don't have the permissions to place files there.
Therefore I added a new variable, which forces to place the files into a custom prefix.
Of course, there is also DESTDIR, but in my case I don't want to use it, because (if prefix == destdir) I would get /my/custom/prefix/path/my/custom/prefix/path as the location for all the other files.
Any other solutions and thoughts are welcome!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,232,2018-02-04T19:42:23Z,2018-05-24T15:02:42Z,2018-05-24T15:02:42Z,CLOSED,False,5,5,1,https://github.com/thopiekar,Adding possibility enforce a prefix,1,['needs-info'],https://github.com/libfuse/libfuse/pull/232,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/232#issuecomment-377009061,"In most scenarios, the script is installing to the default locations, where eg. device nodes or udev rules are normally placed. However, since I want to install libfuse to a prefix, which is built with user permissions, I don't have the permissions to place files there.
Therefore I added a new variable, which forces to place the files into a custom prefix.
Of course, there is also DESTDIR, but in my case I don't want to use it, because (if prefix == destdir) I would get /my/custom/prefix/path/my/custom/prefix/path as the location for all the other files.
Any other solutions and thoughts are welcome!",Can't you use DESTDIR and leave PREFIX unset to get the effect you want?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,232,2018-02-04T19:42:23Z,2018-05-24T15:02:42Z,2018-05-24T15:02:42Z,CLOSED,False,5,5,1,https://github.com/thopiekar,Adding possibility enforce a prefix,1,['needs-info'],https://github.com/libfuse/libfuse/pull/232,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/232#issuecomment-391747781,"In most scenarios, the script is installing to the default locations, where eg. device nodes or udev rules are normally placed. However, since I want to install libfuse to a prefix, which is built with user permissions, I don't have the permissions to place files there.
Therefore I added a new variable, which forces to place the files into a custom prefix.
Of course, there is also DESTDIR, but in my case I don't want to use it, because (if prefix == destdir) I would get /my/custom/prefix/path/my/custom/prefix/path as the location for all the other files.
Any other solutions and thoughts are welcome!",(Superseded by #233),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,233,2018-02-04T20:35:21Z,2018-09-28T13:48:59Z,2018-09-28T13:48:59Z,CLOSED,False,13,10,2,https://github.com/thopiekar,meson: Introducing skip-systemfiles,4,[],https://github.com/libfuse/libfuse/pull/233,https://github.com/thopiekar,1,https://github.com/libfuse/libfuse/pull/233,Adding this option is an alternative to a PR (#232) I created before. By introducing it we can tell ninja to skip installing system files.,Adding this option is an alternative to a PR (#232) I created before. By introducing it we can tell ninja to skip installing system files.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,233,2018-02-04T20:35:21Z,2018-09-28T13:48:59Z,2018-09-28T13:48:59Z,CLOSED,False,13,10,2,https://github.com/thopiekar,meson: Introducing skip-systemfiles,4,[],https://github.com/libfuse/libfuse/pull/233,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/233#issuecomment-377009711,Adding this option is an alternative to a PR (#232) I created before. By introducing it we can tell ninja to skip installing system files.,Thanks for the patch! Could you change the help text to state exactly what won't be installed? I wouldn't know what 'systemfiles' refers to.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,233,2018-02-04T20:35:21Z,2018-09-28T13:48:59Z,2018-09-28T13:48:59Z,CLOSED,False,13,10,2,https://github.com/thopiekar,meson: Introducing skip-systemfiles,4,[],https://github.com/libfuse/libfuse/pull/233,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/233#issuecomment-425441409,Adding this option is an alternative to a PR (#232) I created before. By introducing it we can tell ninja to skip installing system files.,Obsolete with PR 296,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,234,2018-02-08T13:34:22Z,2018-02-09T13:42:13Z,2018-02-09T18:55:19Z,MERGED,True,3,0,1,https://github.com/ashleypittman,Fix uninitialised read in fuse_new_30() (#231),1,[],https://github.com/libfuse/libfuse/pull/234,https://github.com/ashleypittman,1,https://github.com/libfuse/libfuse/pull/234,"Ensure that conf is always zero before it's read from to prevent
sporadic failure at startup if higher layers were build against
version 3.0","Ensure that conf is always zero before it's read from to prevent
sporadic failure at startup if higher layers were build against
version 3.0",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,240,2018-03-25T19:51:36Z,2018-03-28T19:33:00Z,2018-03-28T19:33:03Z,MERGED,True,6,6,4,https://github.com/kusumi,Fix build error on DragonFlyBSD (sync with other *BSD),1,[],https://github.com/libfuse/libfuse/pull/240,https://github.com/kusumi,1,https://github.com/libfuse/libfuse/pull/240,"Meson encountered an error in file util/meson.build, line 24, column 2:
Native dependency 'udev' not found

DragonFlyBSD has no ""bsd"" in uname, so add 'dragonfly' to conditionals.
While here do the same for test/util.py.
-- e.g. uname(1) in DragonFlyBSD
[root@ ~]# uname
DragonFly
[root@ ~]# python -c ""import sys; print(sys.platform)""
dragonfly5","Meson encountered an error in file util/meson.build, line 24, column 2:
Native dependency 'udev' not found

DragonFlyBSD has no ""bsd"" in uname, so add 'dragonfly' to conditionals.
While here do the same for test/util.py.
-- e.g. uname(1) in DragonFlyBSD
[root@ ~]# uname
DragonFly
[root@ ~]# python -c ""import sys; print(sys.platform)""
dragonfly5",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,240,2018-03-25T19:51:36Z,2018-03-28T19:33:00Z,2018-03-28T19:33:03Z,MERGED,True,6,6,4,https://github.com/kusumi,Fix build error on DragonFlyBSD (sync with other *BSD),1,[],https://github.com/libfuse/libfuse/pull/240,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/240#issuecomment-377008448,"Meson encountered an error in file util/meson.build, line 24, column 2:
Native dependency 'udev' not found

DragonFlyBSD has no ""bsd"" in uname, so add 'dragonfly' to conditionals.
While here do the same for test/util.py.
-- e.g. uname(1) in DragonFlyBSD
[root@ ~]# uname
DragonFly
[root@ ~]# python -c ""import sys; print(sys.platform)""
dragonfly5",thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/jazzl0ver,1,https://github.com/libfuse/libfuse/pull/241,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.","This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/Rondom,2,https://github.com/libfuse/libfuse/pull/241#issuecomment-376900077,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.",Have you tried including fcntl.h instead?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/jazzl0ver,3,https://github.com/libfuse/libfuse/pull/241#issuecomment-376910719,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.","@Rondom , just tried to include linux/fcntl.h:
# scl enable rh-python36 -- ninja install
[1/3] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
In file included from /usr/include/asm/fcntl.h:1,
                 from /usr/include/linux/fcntl.h:4,
                 from ../example/passthrough_ll.c:53:
/usr/include/asm-generic/fcntl.h:94: error: redefinition of ‘struct f_owner_ex’
/usr/include/asm-generic/fcntl.h:139: error: redefinition of ‘struct flock’
/usr/include/asm-generic/fcntl.h:156: error: redefinition of ‘struct flock64’
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:137: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:137: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:137: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:167: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:171: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:573: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
ninja: build stopped: subcommand failed.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/241#issuecomment-377008055,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.",Thanks for the patch! Have you tried if these values actually have the desired effect when used though? And how do we know that these are always the correct values to use?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/Rondom,5,https://github.com/libfuse/libfuse/pull/241#issuecomment-377010266,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.","So that fixes O_CLOEXEC only. AT_EMPTY_PATH and O_PATH were added in Linux 2.6.39.. I am not sure whether CentOS 6 has backported this. I have not looked at the code to see whether it works without support for those flags. Defining those constants manually won't magically implement the actual functionality, of course. So just because the code compiles this way, it doesn't mean that the executable will work as expected.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/241#issuecomment-377015635,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.",So I think what's actually needed here is a new build option that simply skips building the examples.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/jazzl0ver,7,https://github.com/libfuse/libfuse/pull/241#issuecomment-377203218,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.","@Nikratio , the desired effect was a successful build under CentOS 6. This effect was reached :)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/jazzl0ver,8,https://github.com/libfuse/libfuse/pull/241#issuecomment-397237562,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.","@Nikratio what kind of info do you need?
BTW, can you check why the Travis CI build has failed?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/241#issuecomment-397248429,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.","As Rondom said above, ""defining those constants manually won't magically implement the actual functionality. So just because the code compiles this way, it doesn't mean that the executable will work as expected"". Therefore, this is not a proper fix. Instead, what's actually needed here is a new build option that simply skips building the examples.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,241,2018-03-27T12:30:33Z,2018-08-31T06:29:06Z,2018-08-31T06:29:06Z,CLOSED,False,10,0,1,https://github.com/jazzl0ver,fix for the building under CentOS 6,1,['needs-info'],https://github.com/libfuse/libfuse/pull/241,https://github.com/Nikratio,10,https://github.com/libfuse/libfuse/pull/241#issuecomment-417565592,"This fixes the following errors:
[root@ip-172-22-2-106 build]# scl enable rh-python36 -- ninja install
[1/30] Compiling C object 'example/passthrough_ll@exe/passthrough_ll.c.o'.
FAILED: example/passthrough_ll@exe/passthrough_ll.c.o
cc  -Iexample/passthrough_ll@exe -Iexample -I../example -I. -I../ -Ilib -I../lib -Iinclude -I../include -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wall -Wextra -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -MD -MQ 'example/passthrough_ll@exe/passthrough_ll.c.o' -MF 'example/passthrough_ll@exe/passthrough_ll.c.o.d' -o 'example/passthrough_ll@exe/passthrough_ll.c.o' -c ../example/passthrough_ll.c
../example/passthrough_ll.c: In function ‘lo_getattr’:
../example/passthrough_ll.c:136: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:136: error: (Each undeclared identifier is reported only once
../example/passthrough_ll.c:136: error: for each function it appears in.)
../example/passthrough_ll.c: In function ‘lo_do_lookup’:
../example/passthrough_ll.c:166: error: ‘O_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c:170: error: ‘AT_EMPTY_PATH’ undeclared (first use in this function)
../example/passthrough_ll.c: In function ‘main’:
../example/passthrough_ll.c:572: error: ‘O_PATH’ undeclared (first use in this function)
At top level:
cc1: warning: unrecognized command line option ""-Wno-unused-result""
[2/30] Compiling C object 'example/null@exe/null.c.o'.
ninja: build stopped: subcommand failed.",Closing this for now since there's been no activity for a while - please feel free to re-open if you want to continue working on this.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,244,2018-04-12T11:24:08Z,2018-04-13T17:14:47Z,2018-04-13T17:14:54Z,MERGED,True,2,3,3,https://github.com/kusumi,Minor fixes,3,[],https://github.com/libfuse/libfuse/pull/244,https://github.com/kusumi,1,https://github.com/libfuse/libfuse/pull/244,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,244,2018-04-12T11:24:08Z,2018-04-13T17:14:47Z,2018-04-13T17:14:54Z,MERGED,True,2,3,3,https://github.com/kusumi,Minor fixes,3,[],https://github.com/libfuse/libfuse/pull/244,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/244#issuecomment-381202582,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,247,2018-05-08T06:09:41Z,2018-05-08T18:36:53Z,2018-05-08T18:36:53Z,MERGED,True,2,1,1,https://github.com/kusumi,Fix compile-time warnings on IGNORE_MTAB,1,[],https://github.com/libfuse/libfuse/pull/247,https://github.com/kusumi,1,https://github.com/libfuse/libfuse/pull/247,"Silence below warnings which appear if IGNORE_MTAB is defined.
[59/64] Compiling C object 'util/fusermount3@exe/fusermount.c.o'.
../util/fusermount.c:493:12: warning: function declaration isn't a prototype [-Wstrict-prototypes]
static int count_fuse_fs()
^~~~~~~~~~~~~
../util/fusermount.c: In function 'unmount_fuse':
../util/fusermount.c:508:46: warning: unused parameter 'quiet' [-Wunused-parameter]
static int unmount_fuse(const char *mnt, int quiet, int lazy)
^~~~~","Silence below warnings which appear if IGNORE_MTAB is defined.
[59/64] Compiling C object 'util/fusermount3@exe/fusermount.c.o'.
../util/fusermount.c:493:12: warning: function declaration isn't a prototype [-Wstrict-prototypes]
static int count_fuse_fs()
^~~~~~~~~~~~~
../util/fusermount.c: In function 'unmount_fuse':
../util/fusermount.c:508:46: warning: unused parameter 'quiet' [-Wunused-parameter]
static int unmount_fuse(const char *mnt, int quiet, int lazy)
^~~~~",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,249,2018-05-08T23:43:02Z,2018-05-09T16:25:31Z,2018-05-09T16:25:31Z,CLOSED,False,16,2,1,https://github.com/billziss-gh,Order locks in get_path2 to avoid deadlocks,1,['needs-info'],https://github.com/libfuse/libfuse/pull/249,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/249,"This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.","This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,249,2018-05-08T23:43:02Z,2018-05-09T16:25:31Z,2018-05-09T16:25:31Z,CLOSED,False,16,2,1,https://github.com/billziss-gh,Order locks in get_path2 to avoid deadlocks,1,['needs-info'],https://github.com/libfuse/libfuse/pull/249,https://github.com/bnaylor,2,https://github.com/libfuse/libfuse/pull/249#issuecomment-387617150,"This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.","Do not consider this a barrier to acceptance by any means, but I will also test this patch tomorrow with our internal tests that also uncovered this issue.  Will update with results.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,249,2018-05-08T23:43:02Z,2018-05-09T16:25:31Z,2018-05-09T16:25:31Z,CLOSED,False,16,2,1,https://github.com/billziss-gh,Order locks in get_path2 to avoid deadlocks,1,['needs-info'],https://github.com/libfuse/libfuse/pull/249,https://github.com/billziss-gh,3,https://github.com/libfuse/libfuse/pull/249#issuecomment-387617991,"This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.",@bnaylor absolutely. Looking forward to hear about the results.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,249,2018-05-08T23:43:02Z,2018-05-09T16:25:31Z,2018-05-09T16:25:31Z,CLOSED,False,16,2,1,https://github.com/billziss-gh,Order locks in get_path2 to avoid deadlocks,1,['needs-info'],https://github.com/libfuse/libfuse/pull/249,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/249#issuecomment-387762892,"This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.","Thanks for the patch!  It's not clear to me how ordering the paths avoids the deadlock though. Can you elaborate? Also, would it be possible to create a test-case for this?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,249,2018-05-08T23:43:02Z,2018-05-09T16:25:31Z,2018-05-09T16:25:31Z,CLOSED,False,16,2,1,https://github.com/billziss-gh,Order locks in get_path2 to avoid deadlocks,1,['needs-info'],https://github.com/libfuse/libfuse/pull/249,https://github.com/bnaylor,5,https://github.com/libfuse/libfuse/pull/249#issuecomment-387772098,"This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.","I still experience hangs with this change, but as we may be discovering in the issue page, my problem may be something specific to the bsd fuse kernel module.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,249,2018-05-08T23:43:02Z,2018-05-09T16:25:31Z,2018-05-09T16:25:31Z,CLOSED,False,16,2,1,https://github.com/billziss-gh,Order locks in get_path2 to avoid deadlocks,1,['needs-info'],https://github.com/libfuse/libfuse/pull/249,https://github.com/billziss-gh,6,https://github.com/libfuse/libfuse/pull/249#issuecomment-387796434,"This PR should fix issue #245. The same patch fixes a similar problem in OSXFUSE; see osxfuse/osxfuse#495
The PR passes all tests performed by sudo python3 -m pytest test/. I have not performed any additional testing at this time.",I am withdrawing this patch as I have also discovered cases that it does not handle. My apologies for the noise. More information on the issue page.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/250,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}","This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/bnaylor,2,https://github.com/libfuse/libfuse/pull/250#issuecomment-388869390,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}",I ran pjdfstest against Ontap with this patch and it passed.  I also confirmed that the new 'rename_dir_loop' test passes on stock FreeBSD.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/billziss-gh,3,https://github.com/libfuse/libfuse/pull/250#issuecomment-388873663,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}",@bnaylor thank you!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/billziss-gh,4,https://github.com/libfuse/libfuse/pull/250#issuecomment-389584494,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}",Please see review response above.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/billziss-gh,5,https://github.com/libfuse/libfuse/pull/250#issuecomment-389645159,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}","As per your request I have updated the patch to not include any of the new code under Linux. I have also updated the Changelog.
This new patch has been tested:

Under Linux (where the patch is inactive).
Under FreeBSD (where the patch is active).
Under OSX where the same patch fixes a similar rename deadlock.

I am requesting another review.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/billziss-gh,6,https://github.com/libfuse/libfuse/pull/250#issuecomment-390249372,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}",Fantastic. Thank you @Nikratio.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/billziss-gh,7,https://github.com/libfuse/libfuse/pull/250#issuecomment-393388314,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}",@Nikratio just wondering if we should also include this bugfix in the 2.9 series? Let me know and I can send PR.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,250,2018-05-13T18:25:05Z,2018-05-18T11:52:12Z,2018-05-31T10:48:31Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check when not done in kernel,3,[],https://github.com/libfuse/libfuse/pull/250,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/250#issuecomment-393492082,"This PR resolves the issue discussed in #245; the PR is not needed in Linux but is needed on BSD which libfuse purports to support.
Linux performs the directory loop check (rename(""a"", ""a/b/c"") or rename(""a/b/c"", ""a""), etc.) at the VFS layer [link]. Unfortunately other libfuse supported systems do not perform this check, which results in a hang in get_path2 as explained here.
The PR resolves the issue by adding a directory loop check in user mode for those system that do not perform it in kernel mode. The PR also adds a directory loop test in test_syscalls.c.
The PR has been tested on the following systems:


On Linux where the PR is NOT needed using python3 -m pytest test/ and the small test program included at the end of this post.


On OSXFUSE where the same patch applies against osxfuse/fuse and resolves the same issue (osxfuse/osxfuse#495).


NOTE: this PR has not been tested against FreeBSD or other BSD's. @bnaylor I am requesting your help here.


For completeness here is the small test program I used for my cross-platform testing:
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

void prename(const char *oldpath, const char *newpath, int expect_err)
{
    int err;

    err = -1 == rename(oldpath, newpath) ? errno : 0;
    if (err != expect_err)
        printf(""rename(\""%s\"", \""%s\"") = %d (expect %d)\n"", oldpath, newpath, err, expect_err);
    else
        printf(""rename(\""%s\"", \""%s\"") = %d\n"", oldpath, newpath, err);
}

int main()
{
    mkdir(""a"", 0700);
    prename(""a"", ""a"", 0);
    prename(""a"", ""a/b"", EINVAL);

    mkdir(""a/b"", 0700);
    mkdir(""a/b/c"", 0700);
    prename(""a"", ""a/b/c"", EINVAL);
    prename(""a"", ""a/b/c/a"", EINVAL);
    prename(""a/b/c"", ""a"", ENOTEMPTY);

    close(open(""a/foo"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    prename(""a/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/bar"", 0);
    prename(""a/b/bar"", ""a/foo"", 0);
    prename(""a/foo"", ""a/b/c/bar"", 0);
    prename(""a/b/c/bar"", ""a/foo"", 0);

    close(open(""a/bar"", O_CREAT));
    prename(""a/foo"", ""a/bar"", 0);
    unlink(""a/bar"");

    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    prename(""a/b"", ""a/d"", 0);
    prename(""a/d"", ""a/b"", 0);

    mkdir(""a/d"", 0700);
    mkdir(""a/d/e"", 0700);
    prename(""a/b"", ""a/d"", ENOTEMPTY);
    rmdir(""a/d/e"");
    rmdir(""a/d"");

    rmdir(""a/b/c"");
    rmdir(""a/b"");
    rmdir(""a"");

    return 0;
}","If you have the time, absolutely. Thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,252,2018-05-22T22:14:33Z,2018-05-24T15:01:38Z,2018-05-24T15:01:38Z,MERGED,True,1,1,1,https://github.com/edquist,fix documentation for opendir in fuse_operations,1,[],https://github.com/libfuse/libfuse/pull/252,https://github.com/edquist,1,https://github.com/libfuse/libfuse/pull/252,"the filehandle from opendir is passed to releasedir - there is no
closedir function in fuse_operations","the filehandle from opendir is passed to releasedir - there is no
closedir function in fuse_operations",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,252,2018-05-22T22:14:33Z,2018-05-24T15:01:38Z,2018-05-24T15:01:38Z,MERGED,True,1,1,1,https://github.com/edquist,fix documentation for opendir in fuse_operations,1,[],https://github.com/libfuse/libfuse/pull/252,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/252#issuecomment-391746923,"the filehandle from opendir is passed to releasedir - there is no
closedir function in fuse_operations",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,253,2018-05-22T22:16:06Z,2018-05-24T15:01:28Z,2018-05-24T15:01:28Z,MERGED,True,1,1,1,https://github.com/edquist,fix documentation for opendir in fuse_operations,1,[],https://github.com/libfuse/libfuse/pull/253,https://github.com/edquist,1,https://github.com/libfuse/libfuse/pull/253,"the filehandle from opendir is passed to releasedir - there is no
closedir function in fuse_operations","the filehandle from opendir is passed to releasedir - there is no
closedir function in fuse_operations",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,255,2018-06-05T22:48:53Z,2018-06-07T09:17:14Z,2018-06-07T17:24:04Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check (2.9 branch),1,[],https://github.com/libfuse/libfuse/pull/255,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/255,"This PR adds the same bug fix as #250 to the 2.9 branch. The PR adds:

The check_dir_loop function guarded by the same conditionals as discussed in the original PR.
The test_rename_dir_loop which passes on FreeBSD.
An entry in the ChangeLog.

This PR passes on FreeBSD (where the problem happens) and Linux.","This PR adds the same bug fix as #250 to the 2.9 branch. The PR adds:

The check_dir_loop function guarded by the same conditionals as discussed in the original PR.
The test_rename_dir_loop which passes on FreeBSD.
An entry in the ChangeLog.

This PR passes on FreeBSD (where the problem happens) and Linux.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,255,2018-06-05T22:48:53Z,2018-06-07T09:17:14Z,2018-06-07T17:24:04Z,MERGED,True,279,0,3,https://github.com/billziss-gh,rename: perform user mode dir loop check (2.9 branch),1,[],https://github.com/libfuse/libfuse/pull/255,https://github.com/billziss-gh,2,https://github.com/libfuse/libfuse/pull/255#issuecomment-395500370,"This PR adds the same bug fix as #250 to the 2.9 branch. The PR adds:

The check_dir_loop function guarded by the same conditionals as discussed in the original PR.
The test_rename_dir_loop which passes on FreeBSD.
An entry in the ChangeLog.

This PR passes on FreeBSD (where the problem happens) and Linux.",Thank you for merging this in.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,1,https://github.com/libfuse/libfuse/pull/259,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/259#issuecomment-400635424,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","Thanks! Could you please ping me again when the kernel part is merged? (I'll try to keep an eye on it, but I will probably forget).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,3,https://github.com/libfuse/libfuse/pull/259#issuecomment-400645372,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","Yes, of course! I am not sure if there will be any requests to change
the kernel headers, so until then this should not get merged in any
case.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,4,https://github.com/libfuse/libfuse/pull/259#issuecomment-401346675,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","Thanks @marcinsulikowski , an updated FUSE kernel change has been posted. This PR now uses that API and includes the suggestions about the libfuse improvements.",True,{'THUMBS_UP': ['https://github.com/marcinsulikowski']}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,5,https://github.com/libfuse/libfuse/pull/259#issuecomment-414659047,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","Latest update, based on the review comments from Miklos. The matching fuse module patch has been posted as well.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/259#issuecomment-417565511,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.",Thanks! Please ping me when the kernel part has been merged.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,7,https://github.com/libfuse/libfuse/pull/259#issuecomment-437656036,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","@Nikratio, the kernel change has been merged in Linus' tree as commit 88bc7d50. Please review this PR and see if it can be included in fuse-3.4?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,8,https://github.com/libfuse/libfuse/pull/259#issuecomment-437841216,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.",Thanks for the comments. I think I've addressed everything you mentioned.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/259#issuecomment-439488835,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","Hmm. It seems the tests already made use of deprecated functionality (at least if I interpret the CI results correctly). Sorry about that! It would of course be great if you could get them to work with the newest API, but if you just want to redefine FUSE_USE_API to the earlier version that's fine too.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/nixpanic,10,https://github.com/libfuse/libfuse/pull/259#issuecomment-439807037,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.","I've reverted the FUSE_USE_VERSION changes in examples/ now. As a reminder, #324 has been created. Not sure if/when I will have time to look at that though.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,259,2018-06-27T08:17:45Z,2018-11-19T12:33:57Z,2018-11-19T12:33:57Z,MERGED,True,422,50,14,https://github.com/nixpanic,Add support for copy_file_range(),4,"['enhancement', 'needs-info']",https://github.com/libfuse/libfuse/pull/259,https://github.com/Nikratio,11,https://github.com/libfuse/libfuse/pull/259#issuecomment-439878139,"This series updates the fuse_kernel.h file to the most recent version in Linus' tree.
copy_file_range() support in the FUSE kernel module has not been merged yet. The first version of the patch that adds it can be found on LKML and other mailinglist archives.",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,260,2018-06-27T15:11:40Z,2018-07-04T18:53:51Z,2018-07-04T18:53:51Z,CLOSED,False,5,2,4,https://github.com/gcsideal,Small improvements,3,[],https://github.com/libfuse/libfuse/pull/260,https://github.com/gcsideal,1,https://github.com/libfuse/libfuse/pull/260,"Fix man page name, build static library as well. Mostly for Debian packaging but would be good for everyone.","Fix man page name, build static library as well. Mostly for Debian packaging but would be good for everyone.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,260,2018-06-27T15:11:40Z,2018-07-04T18:53:51Z,2018-07-04T18:53:51Z,CLOSED,False,5,2,4,https://github.com/gcsideal,Small improvements,3,[],https://github.com/libfuse/libfuse/pull/260,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/260#issuecomment-401140128,"Fix man page name, build static library as well. Mostly for Debian packaging but would be good for everyone.","Looks like both_libraries has only been introduced in Meson 0.46 (i.e. the newest release). Is there a reason to use this instead of two separate targets (library + static_library)? I'd prefer not to depend on such a recent Meson version, but if this is required please bump the minimum version in meson.build and the version used in the CI (tests/travis-install.sh).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,260,2018-06-27T15:11:40Z,2018-07-04T18:53:51Z,2018-07-04T18:53:51Z,CLOSED,False,5,2,4,https://github.com/gcsideal,Small improvements,3,[],https://github.com/libfuse/libfuse/pull/260,https://github.com/gcsideal,3,https://github.com/libfuse/libfuse/pull/260#issuecomment-401688562,"Fix man page name, build static library as well. Mostly for Debian packaging but would be good for everyone.","The use of both_libraries was to keep library definitions together. But you are right, for supporting older Meson versions the distinct shared and static libraries build is encouraged. I think I'll have time for it in this afternoon.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,260,2018-06-27T15:11:40Z,2018-07-04T18:53:51Z,2018-07-04T18:53:51Z,CLOSED,False,5,2,4,https://github.com/gcsideal,Small improvements,3,[],https://github.com/libfuse/libfuse/pull/260,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/260#issuecomment-402542532,"Fix man page name, build static library as well. Mostly for Debian packaging but would be good for everyone.","Actually, I don't think we need to change the build file at all. In recent meson versions, you can just use meson configure -D default_library=both (cf. mesonbuild/meson#2711). I've merged the other changes.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,263,2018-07-02T02:19:58Z,2018-07-02T16:18:59Z,2018-07-02T20:25:25Z,MERGED,True,1,1,1,https://github.com/woodruffw,fuse.h: fix typo (currenlty -> currently),1,[],https://github.com/libfuse/libfuse/pull/263,https://github.com/woodruffw,1,https://github.com/libfuse/libfuse/pull/263,This just fixes a minor typo in the fuse.h documentation that I noticed when browsing the Doxygen pages.,This just fixes a minor typo in the fuse.h documentation that I noticed when browsing the Doxygen pages.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,263,2018-07-02T02:19:58Z,2018-07-02T16:18:59Z,2018-07-02T20:25:25Z,MERGED,True,1,1,1,https://github.com/woodruffw,fuse.h: fix typo (currenlty -> currently),1,[],https://github.com/libfuse/libfuse/pull/263,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/263#issuecomment-401858081,This just fixes a minor typo in the fuse.h documentation that I noticed when browsing the Doxygen pages.,Thanks!,True,{'HEART': ['https://github.com/woodruffw']}
libfuse/libfuse,https://github.com/libfuse/libfuse,264,2018-07-09T10:30:56Z,2018-07-09T15:50:43Z,2018-07-17T18:54:40Z,MERGED,True,3,1,1,https://github.com/Alexander-TX,Fix SIGSEGV when fuse_interrupted() is called outside the eventloop,1,[],https://github.com/libfuse/libfuse/pull/264,https://github.com/Alexander-TX,1,https://github.com/libfuse/libfuse/pull/264,"The issue was previously raised on fuse-devel, but the proposed fix never got merged.","The issue was previously raised on fuse-devel, but the proposed fix never got merged.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,264,2018-07-09T10:30:56Z,2018-07-09T15:50:43Z,2018-07-17T18:54:40Z,MERGED,True,3,1,1,https://github.com/Alexander-TX,Fix SIGSEGV when fuse_interrupted() is called outside the eventloop,1,[],https://github.com/libfuse/libfuse/pull/264,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/264#issuecomment-403526845,"The issue was previously raised on fuse-devel, but the proposed fix never got merged.",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,264,2018-07-09T10:30:56Z,2018-07-09T15:50:43Z,2018-07-17T18:54:40Z,MERGED,True,3,1,1,https://github.com/Alexander-TX,Fix SIGSEGV when fuse_interrupted() is called outside the eventloop,1,[],https://github.com/libfuse/libfuse/pull/264,https://github.com/Alexander-TX,3,https://github.com/libfuse/libfuse/pull/264#issuecomment-404406537,"The issue was previously raised on fuse-devel, but the proposed fix never got merged.","@Nikratio are there plans to release libfuse 2.9.8 with this fix? I have a patch, adding interruption support to a third-party filesystem, but this issue prevents me from upstreaming it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,264,2018-07-09T10:30:56Z,2018-07-09T15:50:43Z,2018-07-17T18:54:40Z,MERGED,True,3,1,1,https://github.com/Alexander-TX,Fix SIGSEGV when fuse_interrupted() is called outside the eventloop,1,[],https://github.com/libfuse/libfuse/pull/264,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/264#issuecomment-405689987,"The issue was previously raised on fuse-devel, but the proposed fix never got merged.","Yeah, sort-of. My efforts have been focused on fuse 3 and I haven't done a libfuse 2.x release for several years so I have actually forgotten what the procedure was. I have automated and documented most of it for libfuse 3 because it was somewhat cumbersome, so I am somewhat dreading to get back to it. But yeah, I'll make an effort.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,268,2018-07-17T19:16:19Z,2018-07-18T19:32:29Z,2018-07-31T07:42:21Z,MERGED,True,89,6,1,https://github.com/thejh,fusermount hardening,5,[],https://github.com/libfuse/libfuse/pull/268,https://github.com/thejh,1,https://github.com/libfuse/libfuse/pull/268,"Some of these patches are bugfixes for issues that I believe to be non-exploitable, the others are hardening changes that should make fusermount more robust against potential future problems.","Some of these patches are bugfixes for issues that I believe to be non-exploitable, the others are hardening changes that should make fusermount more robust against potential future problems.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,268,2018-07-17T19:16:19Z,2018-07-18T19:32:29Z,2018-07-31T07:42:21Z,MERGED,True,89,6,1,https://github.com/thejh,fusermount hardening,5,[],https://github.com/libfuse/libfuse/pull/268,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/268#issuecomment-409126889,"Some of these patches are bugfixes for issues that I believe to be non-exploitable, the others are hardening changes that should make fusermount more robust against potential future problems.",Makes sense to me. Could you provide a pull request? Please don't forget to add a brief entry to ChangeLog.rst as well.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,269,2018-07-20T17:07:21Z,2018-07-21T09:57:10Z,2018-07-21T21:07:40Z,MERGED,True,84,11,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,2,[],https://github.com/libfuse/libfuse/pull/269,https://github.com/rostislav,1,https://github.com/libfuse/libfuse/pull/269,"Hello,
The first commit adds a test of seekdir(), and the second fixes the bug that is exposed by the test.
I am not sure this is the best fix, but I tried to change as little as possible.
Another thing is that 2.9.x branch is also affected by the same bug. Would a similar fix be accepted there as well?","Hello,
The first commit adds a test of seekdir(), and the second fixes the bug that is exposed by the test.
I am not sure this is the best fix, but I tried to change as little as possible.
Another thing is that 2.9.x branch is also affected by the same bug. Would a similar fix be accepted there as well?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,269,2018-07-20T17:07:21Z,2018-07-21T09:57:10Z,2018-07-21T21:07:40Z,MERGED,True,84,11,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,2,[],https://github.com/libfuse/libfuse/pull/269,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/269#issuecomment-406702221,"Hello,
The first commit adds a test of seekdir(), and the second fixes the bug that is exposed by the test.
I am not sure this is the best fix, but I tried to change as little as possible.
Another thing is that 2.9.x branch is also affected by the same bug. Would a similar fix be accepted there as well?",Thanks for tracking this down! I think your fix is fine. I have just one request: could you please also add a comment to ChangeLog.rst?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,269,2018-07-20T17:07:21Z,2018-07-21T09:57:10Z,2018-07-21T21:07:40Z,MERGED,True,84,11,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,2,[],https://github.com/libfuse/libfuse/pull/269,https://github.com/rostislav,3,https://github.com/libfuse/libfuse/pull/269#issuecomment-406719985,"Hello,
The first commit adds a test of seekdir(), and the second fixes the bug that is exposed by the test.
I am not sure this is the best fix, but I tried to change as little as possible.
Another thing is that 2.9.x branch is also affected by the same bug. Would a similar fix be accepted there as well?",Thanks for review! I've added comments to ChangeLog.rst and edited commit messages a bit.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,270,2018-07-21T22:31:59Z,2018-07-23T10:02:58Z,2018-08-25T19:30:19Z,MERGED,True,16,3,4,https://github.com/rostislav,Fix memory leaks,4,[],https://github.com/libfuse/libfuse/pull/270,https://github.com/rostislav,1,https://github.com/libfuse/libfuse/pull/270,This series of commits fixes all memory leaks I found when running tests with LeakSanitizer enabled.,This series of commits fixes all memory leaks I found when running tests with LeakSanitizer enabled.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,270,2018-07-21T22:31:59Z,2018-07-23T10:02:58Z,2018-08-25T19:30:19Z,MERGED,True,16,3,4,https://github.com/rostislav,Fix memory leaks,4,[],https://github.com/libfuse/libfuse/pull/270,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/270#issuecomment-407005946,This series of commits fixes all memory leaks I found when running tests with LeakSanitizer enabled.,Thanks! Much appreciated.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,271,2018-07-24T08:24:34Z,2018-07-25T11:29:00Z,2018-08-25T19:29:31Z,MERGED,True,76,2,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,1,[],https://github.com/libfuse/libfuse/pull/271,https://github.com/rostislav,1,https://github.com/libfuse/libfuse/pull/271,"Hi Nikolaus,
This is a backport of my earlier commit in master fixing the same bug.","Hi Nikolaus,
This is a backport of my earlier commit in master fixing the same bug.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,271,2018-07-24T08:24:34Z,2018-07-25T11:29:00Z,2018-08-25T19:29:31Z,MERGED,True,76,2,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,1,[],https://github.com/libfuse/libfuse/pull/271,https://github.com/rostislav,2,https://github.com/libfuse/libfuse/pull/271#issuecomment-407378173,"Hi Nikolaus,
This is a backport of my earlier commit in master fixing the same bug.","When updating the changelog as per your request, I noticed that the changes actually included in 2.9.8 are under ""Unreleased Changes"" in the changelog (e. g. fusermount hardening). I guess it's not intended?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,271,2018-07-24T08:24:34Z,2018-07-25T11:29:00Z,2018-08-25T19:29:31Z,MERGED,True,76,2,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,1,[],https://github.com/libfuse/libfuse/pull/271,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/271#issuecomment-407703892,"Hi Nikolaus,
This is a backport of my earlier commit in master fixing the same bug.","Indeed, I forgot to commit this file. Should be fixed now. thanks for the pointer!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,271,2018-07-24T08:24:34Z,2018-07-25T11:29:00Z,2018-08-25T19:29:31Z,MERGED,True,76,2,3,https://github.com/rostislav,Fix readdir() bug when a non-zero offset is specified in filler,1,[],https://github.com/libfuse/libfuse/pull/271,https://github.com/rostislav,4,https://github.com/libfuse/libfuse/pull/271#issuecomment-407712119,"Hi Nikolaus,
This is a backport of my earlier commit in master fixing the same bug.","Updated my commit with your latest update of fuse_2_9_bugfix, now my changes in ChangeLog are under ""Unreleased Changes""",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,273,2018-07-24T21:56:29Z,2018-07-25T10:11:50Z,2018-08-25T19:41:52Z,MERGED,True,0,1,1,https://github.com/rostislav,Remove unused member of 'struct fuse_dh',1,[],https://github.com/libfuse/libfuse/pull/273,https://github.com/rostislav,1,https://github.com/libfuse/libfuse/pull/273,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,276,2018-07-31T08:54:08Z,2018-07-31T14:20:57Z,2018-07-31T14:20:57Z,MERGED,True,3,0,2,https://github.com/roboshim, Allow fuse mount into autofs structure ,3,[],https://github.com/libfuse/libfuse/pull/276,https://github.com/roboshim,1,https://github.com/libfuse/libfuse/pull/276,"I hope I have created pull request correctly. Please, if there is something wrong, just edit/change it. Thank you.","I hope I have created pull request correctly. Please, if there is something wrong, just edit/change it. Thank you.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,277,2018-08-03T15:27:22Z,2018-08-05T09:33:28Z,2018-08-05T09:33:28Z,MERGED,True,7,4,1,https://github.com/bbarenblat,"Realphabetize, re-document, and add FAT to the file system whitelist",2,[],https://github.com/libfuse/libfuse/pull/277,https://github.com/bbarenblat,1,https://github.com/libfuse/libfuse/pull/277,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,278,2018-08-04T04:45:22Z,2018-08-05T09:33:54Z,2018-08-05T09:33:54Z,CLOSED,False,2,0,2,https://github.com/gcsideal,Add FAT to mountpoint file system whitelist,1,[],https://github.com/libfuse/libfuse/pull/278,https://github.com/gcsideal,1,https://github.com/libfuse/libfuse/pull/278,FAT needs to whitelisted as well.,FAT needs to whitelisted as well.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,278,2018-08-04T04:45:22Z,2018-08-05T09:33:54Z,2018-08-05T09:33:54Z,CLOSED,False,2,0,2,https://github.com/gcsideal,Add FAT to mountpoint file system whitelist,1,[],https://github.com/libfuse/libfuse/pull/278,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/278#issuecomment-410507661,FAT needs to whitelisted as well.,Thanks! Ben was a little faster than you :-). #277,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,281,2018-08-09T02:06:38Z,2018-08-09T18:15:47Z,2018-08-09T18:15:47Z,MERGED,True,1,0,1,https://github.com/danielfullmer,Add bcachefs to mountpoint file system whitelist,1,[],https://github.com/libfuse/libfuse/pull/281,https://github.com/danielfullmer,1,https://github.com/libfuse/libfuse/pull/281,"Please consider adding bcachefs to the whitelist.
See: https://evilpiepirate.org/git/bcachefs-tools.git/tree/libbcachefs/bcachefs_format.h#n1275","Please consider adding bcachefs to the whitelist.
See: https://evilpiepirate.org/git/bcachefs-tools.git/tree/libbcachefs/bcachefs_format.h#n1275",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,281,2018-08-09T02:06:38Z,2018-08-09T18:15:47Z,2018-08-09T18:15:47Z,MERGED,True,1,0,1,https://github.com/danielfullmer,Add bcachefs to mountpoint file system whitelist,1,[],https://github.com/libfuse/libfuse/pull/281,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/281#issuecomment-411849273,"Please consider adding bcachefs to the whitelist.
See: https://evilpiepirate.org/git/bcachefs-tools.git/tree/libbcachefs/bcachefs_format.h#n1275",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,1,https://github.com/libfuse/libfuse/pull/282,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/282#issuecomment-413463702,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Thanks! This is great, I really like having a more feature-rich low-level example. My only concerns are the  two minor issues mentioned above.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/282#issuecomment-417566192,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"ping Would you be able to add the documentation update, so this can get merged? Should be just a few lines if I understand the issue correctly.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/282#issuecomment-425441883,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"ping Are you no longer interested in working on this?
The only thing that prevents a merge is the missing testcase...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,5,https://github.com/libfuse/libfuse/pull/282#issuecomment-425447541,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"I'm definitely interested in this getting merged.  It's part of a bigger project that we are working on internally and will hopefully go public in some weeks. Getting it upstream is obviously very important.
OTOH, I've a lot on my plate and python is not the language that I'm highly skilled in, so I'd definitely accept some help there.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/282#issuecomment-425849651,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Got you. Will add a test case later today, if I can find out how to extend the push request (there was some way to do that...)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/282#issuecomment-425856990,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Ok, I've extended the testcases. There is one new failure when running with active writeback. It comes from the test_syscalls test which is in C :-).
50 [open_acc(O_RDONLY) mode: 0400 message: 'Success'] OK
 51 [open_acc(O_WRONLY) mode: 0200 message: 'Success'] do_test_open_acc() - open: Permission denied
 52 [open_acc(O_RDONLY | O_TRUNC) mode: 0400 message: 'Permission denied'] OK

Unfortunately I do not have permission to extend your pull request with the test changes. Could you give me permissions? Instructions at
https://help.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/282#issuecomment-425857300,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"For now, I have pushed the updated branch to https://github.com/libfuse/libfuse/commits/miklos-pull-request",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,9,https://github.com/libfuse/libfuse/pull/282#issuecomment-425882098,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Thank's for helping.
Ticked the box to give permissions.
The failed testcase is expected.  This mode only works if the server has elevated privileges (CAP_DAC_OVERRIDE) because in writeback mode the kernel may also issue read requests (even if file was opened for write-only) and hence the passthrough fs has to open the file for reading as well as for writing, which fails if the file is only openable for write and the server lacks privileges.
I think the right solution to that would be to disable writeback cache for the inode where read permission is denied (an unlikely situation).  This is not currently possible, as writeback mode is per-superblock not per-inode, but that's fixable in the fuse kernel module and in API's.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,10,https://github.com/libfuse/libfuse/pull/282#issuecomment-425913508,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Right. I don't suppose you have a patch ready for implementing per-inode cache settings? :-)
What do you think is the best way to handle the current situation? I think we can either drop this particular test completely, or add an additional command line parameter to test_syscalls that causes it to skip the test only if writeback caching is enabled.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,11,https://github.com/libfuse/libfuse/pull/282#issuecomment-425917541,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Adding ""-51"" to the test command line will disable this test.  If you only add it for the ""-owriteback"" case, all the better.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,12,https://github.com/libfuse/libfuse/pull/282#issuecomment-425920395,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"done, let's see",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,13,https://github.com/libfuse/libfuse/pull/282#issuecomment-425996834,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Are those numbers dynamic? Test 51 is now skipped, but now test 52 is the failing one?!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,14,https://github.com/libfuse/libfuse/pull/282#issuecomment-426009734,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Umm, a seekdir test was added by commit 5f125c5 ""Fix readdir() bug when a non-zero offset is specified in filler (#269)"".  The problem is that it was added in the middle, thus causing all the test numbers after it to shift by one.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,15,https://github.com/libfuse/libfuse/pull/282#issuecomment-426201813,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"I don't follow. The test passes locally (with 51 excluded), but did not pass on Travis. I haven't rebased anything, it seems that the numbers are simply different between the test runs.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,16,https://github.com/libfuse/libfuse/pull/282#issuecomment-426205131,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,The travis run has a seekdir test at position12 while the local run doesn't have it.  So I guess travis is doing a merge with HEAD before running the tests.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,17,https://github.com/libfuse/libfuse/pull/282#issuecomment-426602571,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,Explicitly rebased and updated the test number now. Let's see...,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,18,https://github.com/libfuse/libfuse/pull/282#issuecomment-426774822,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Looks good now! Could you still document the  that . and .. should not get an increased lookup count? As far as I can tell, this isn't documented anywhere yet the example refers to this as a requirement.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,19,https://github.com/libfuse/libfuse/pull/282#issuecomment-428322819,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"ping
Any chance you could write a few words so we can merge this? :-)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/szmi,20,https://github.com/libfuse/libfuse/pull/282#issuecomment-428479498,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"It seems to be documented in fuse_lowlevel.h:
 * In contrast to readdir() (which does not affect the lookup counts),
 * the lookup count of every entry returned by readdirplus(), except "".""
 * and "".."", is incremented by one.

The sentence is structured a bit awkwardly, maybe it should be
 * In contrast to readdir() the lookup count of every entry returned by readdirplus() is incremented by one, with the exception of ""."" and ""..""",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,282,2018-08-15T07:34:25Z,2018-10-10T09:49:49Z,2018-10-10T09:49:49Z,MERGED,True,719,95,2,https://github.com/szmi,passthrough_ll update,13,[],https://github.com/libfuse/libfuse/pull/282,https://github.com/Nikratio,21,https://github.com/libfuse/libfuse/pull/282#issuecomment-428509897,This fixes a couple of bugs in the passthrough_ll example filesystem and adds support for lots of missing operations.  Options are added to configure a base path and to control caching.,"Right you are. Weird, I was sure I carefully looked at exactly that section of the file...
Thanks for you patience! Merging now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,283,2018-08-20T20:54:37Z,2018-08-25T19:17:40Z,2018-08-25T19:17:40Z,MERGED,True,10,12,4,https://github.com/t-chaik,Make meson build scripts subprojects friendly,1,[],https://github.com/libfuse/libfuse/pull/283,https://github.com/t-chaik,1,https://github.com/libfuse/libfuse/pull/283,"Multiple meson build scripts improvements including:

Bump meson requirement to 0.40.1 (0.40 already required)
Declare a dependency object for main library
Stop using add_global_arguments()
Various minor style fixes

The main interest for this is to be able to wrap libfuse as a meson subproject.","Multiple meson build scripts improvements including:

Bump meson requirement to 0.40.1 (0.40 already required)
Declare a dependency object for main library
Stop using add_global_arguments()
Various minor style fixes

The main interest for this is to be able to wrap libfuse as a meson subproject.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,283,2018-08-20T20:54:37Z,2018-08-25T19:17:40Z,2018-08-25T19:17:40Z,MERGED,True,10,12,4,https://github.com/t-chaik,Make meson build scripts subprojects friendly,1,[],https://github.com/libfuse/libfuse/pull/283,https://github.com/t-chaik,2,https://github.com/libfuse/libfuse/pull/283#issuecomment-415962011,"Multiple meson build scripts improvements including:

Bump meson requirement to 0.40.1 (0.40 already required)
Declare a dependency object for main library
Stop using add_global_arguments()
Various minor style fixes

The main interest for this is to be able to wrap libfuse as a meson subproject.",Should be fine now.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,285,2018-08-23T09:36:10Z,2018-09-28T13:50:16Z,2018-09-28T13:50:16Z,CLOSED,False,10,5,1,https://github.com/AnimusPEXUS,fix ninja install when running not under root,1,[],https://github.com/libfuse/libfuse/pull/285,https://github.com/AnimusPEXUS,1,https://github.com/libfuse/libfuse/pull/285,#284,#284,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,285,2018-08-23T09:36:10Z,2018-09-28T13:50:16Z,2018-09-28T13:50:16Z,CLOSED,False,10,5,1,https://github.com/AnimusPEXUS,fix ninja install when running not under root,1,[],https://github.com/libfuse/libfuse/pull/285,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/285#issuecomment-415990692,#284,Thanks for the patch! But could you explain which problem you are solving? How is installation as non-root related to DESTDIR? And why would you not install the init script when DESTDIR is set?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,285,2018-08-23T09:36:10Z,2018-09-28T13:50:16Z,2018-09-28T13:50:16Z,CLOSED,False,10,5,1,https://github.com/AnimusPEXUS,fix ninja install when running not under root,1,[],https://github.com/libfuse/libfuse/pull/285,https://github.com/AnimusPEXUS,3,https://github.com/libfuse/libfuse/pull/285#issuecomment-416155764,#284,"I'm building packages not under root.
trying to 'ninja install DESTDIR=(something)' installs some parts to '(something)', but fails on the part, where external script tries to create /dev/fuse (mknod) and chown/chmod on ""${prefix}/${bindir}/fusermount3""
I've used 'test -z ""${DESTDIR}""' check, to keep up in the mood of other checks inside util/install_helper.sh, keeping in mind, what DESTDIR variable - most probably used not under the root.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,285,2018-08-23T09:36:10Z,2018-09-28T13:50:16Z,2018-09-28T13:50:16Z,CLOSED,False,10,5,1,https://github.com/AnimusPEXUS,fix ninja install when running not under root,1,[],https://github.com/libfuse/libfuse/pull/285,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/285#issuecomment-416185282,#284,"I see. I do not think relying on DESTDIR is a good solution here though. This is certainly used also when running as root, eg to create .deb packages. Neither would it work to check for $UID == 0, because the user may have accidentally run as non-root, in which case we want to show an error message.
I think the only clean way to handle this is to add a new build option, maybe along the lines of #233.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,285,2018-08-23T09:36:10Z,2018-09-28T13:50:16Z,2018-09-28T13:50:16Z,CLOSED,False,10,5,1,https://github.com/AnimusPEXUS,fix ninja install when running not under root,1,[],https://github.com/libfuse/libfuse/pull/285,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/285#issuecomment-425441803,#284,"Closing for now, feel free to reopen when comments are addressed",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,286,2018-08-23T17:26:34Z,2018-08-23T17:30:52Z,2018-08-23T17:30:52Z,CLOSED,False,139,7,1,https://github.com/mtheall,Add mknod and setattr to passthrough_ll,1,[],https://github.com/libfuse/libfuse/pull/286,https://github.com/mtheall,1,https://github.com/libfuse/libfuse/pull/286,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,286,2018-08-23T17:26:34Z,2018-08-23T17:30:52Z,2018-08-23T17:30:52Z,CLOSED,False,139,7,1,https://github.com/mtheall,Add mknod and setattr to passthrough_ll,1,[],https://github.com/libfuse/libfuse/pull/286,https://github.com/mtheall,2,https://github.com/libfuse/libfuse/pull/286#issuecomment-415503100,,"Sorry, I didn't notice there was another passthrough_ll pr that already adds this.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,287,2018-08-25T19:56:36Z,2018-08-26T08:43:33Z,2018-08-26T08:43:38Z,MERGED,True,2,1,1,https://github.com/rostislav,Fix invalid free of memory pointer in 'struct fuse_buf',1,[],https://github.com/libfuse/libfuse/pull/287,https://github.com/rostislav,1,https://github.com/libfuse/libfuse/pull/287,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,287,2018-08-25T19:56:36Z,2018-08-26T08:43:33Z,2018-08-26T08:43:38Z,MERGED,True,2,1,1,https://github.com/rostislav,Fix invalid free of memory pointer in 'struct fuse_buf',1,[],https://github.com/libfuse/libfuse/pull/287,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/287#issuecomment-416023434,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,288,2018-08-25T20:52:14Z,2018-08-26T08:55:07Z,2018-08-26T08:55:07Z,MERGED,True,23,3,1,https://github.com/rostislav,Fix memory leak of FUSE modules,1,[],https://github.com/libfuse/libfuse/pull/288,https://github.com/rostislav,1,https://github.com/libfuse/libfuse/pull/288,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/guss77,1,https://github.com/libfuse/libfuse/pull/290,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.","For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/290#issuecomment-416575289,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.","Thanks for the patch! I think you forgot the most important part though: updating the documentation so that developers can actually make use of the new error codes 😉.
Would you be able to do that as well?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/guss77,3,https://github.com/libfuse/libfuse/pull/290#issuecomment-416582617,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.","@Nikratio - Yea, sure.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/guss77,4,https://github.com/libfuse/libfuse/pull/290#issuecomment-416583461,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.","Current documentation (Assuming I found the correct location) just say ""return ... nonzero on failure"". Which is still accurate 😉.
I can try to analyze the reason for all the different codes (including 1) and add some text - is this what you mean?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/290#issuecomment-416597190,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.","I mean you should describe what error code is returned in which situation - otherwise there's no point in returning different error codes, because they don't mean anything, right?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/guss77,6,https://github.com/libfuse/libfuse/pull/290#issuecomment-416599583,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.",@Nikratio - you mean in fuse.h line 821 ?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,290,2018-08-28T12:43:49Z,2018-08-29T16:20:57Z,2018-08-30T08:24:55Z,MERGED,True,15,6,2,https://github.com/guss77,return different non-zero error codes,2,[],https://github.com/libfuse/libfuse/pull/290,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/290#issuecomment-416679084,"For different errors, we should have different error codes to help a developer figure out what exactly we don't like about their system.",yes,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,1,https://github.com/libfuse/libfuse/pull/291,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/291#issuecomment-417015651,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Thanks for the patch!
@szmi Could you take a look at this? How would this interact with the plans in issue #77?
@saittam Could you similarly take a look at issue #77 to see if there are conflicts or synergies?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/291#issuecomment-417016919,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","I'm a little confused by the goal here. Normally the ""suitable privileged process"" is fusermount, so the filesystem does not need any special permissions. Why doesn't that work for you?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,4,https://github.com/libfuse/libfuse/pull/291#issuecomment-417040888,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Regarding why fusermount doesn't work for us: fusermount requires setuid (technically, you could make it work by setting CAP_SYS_ADMIN in fscaps, but that doesn't change much). setuid (and fscaps just as well) is known to be risky since it allows unprivileged processes to gain privilege. Using setuid in a bullet-proof way is practically impossible. The conceptual problem is that there's too much attack surface in startup code of the setuid binary that the unprivileged process can freely access. I usually cite https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt as an example to demonstrate how hopeless the situation is ;-) Given that fusermount is dynamically linked, chances are pretty high that a variant of the attack described in the qualys writeup linked above would have worked against it (I haven't tried though).
Given the above background, Chrome OS has adopted the general policy to ban setuid and fscaps binaries in general. This means that we'd like to avoid fusermount if we can. Our typical approach is to use no_new_privs to prevent a process or its children to ever regain privileges that it has dropped (capabilities + securebits as used in my demo commands are a weaker form of this idea). This not only defends against the issues above, but also makes it much simpler to argue about security at a high level - privilege can no longer be created from thin air, so you can be pretty confident that certain things just can't happen in certain parts of the system.
Of course, this sometimes implies architecture changes to reorder or move privileged operations to different processes. A standard pattern is to have a privileged parent process that handles all privileged operations and isolate the code that's exposed to attacks into a heavily sandboxed child process. This is exactly what this patch allows, i.e. the privileged parent process takes care of mounting, then spawns the helper and setting up things such that the helper or its children can't gain privilege. ""suitably privileged process"" was meant to refer to the parent that spawns the FUSE binary, not a child of the FUSE binary (as would be the case with setuid). Sorry for being unclear about this.
I hope the above helps clarify things, let me know if there are further questions!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/291#issuecomment-417115407,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Thanks for the explanations, this sounds reasonable. My main concern is potential incompatibility (or the lack of coordination) with the plans described in issue #77.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/szmi,6,https://github.com/libfuse/libfuse/pull/291#issuecomment-417267217,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Interesting work.  Yes, there's interaction with issue #77, so if you want to be ""future compatible"" with this, then don't design it with ""pre-mounted"" in mind.  The generic sequence should be:

grab device descriptor
start unprivileged fuse daemon in the background
do the mounting

Problem with that sequence is that with current kernels you'll get EPERM when reading the device before it's mounted.   Not nice.  So lets start with fixing the kernel not to do that.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,7,https://github.com/libfuse/libfuse/pull/291#issuecomment-417289792,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","So I've read through #77 - let me recap the gist of it to make sure I understand correctly. The current state of things is this:

fd = open(/dev/fuse)
mount(fd)
start loop to read(fd) and process events

The problem is that mount() may trigger code in the kernel that would like to access the file system, which is not currently possible until after mount() completes and the FUSE daemon starts processing events. So the proposal is to change things to this instead:

fd = open(/dev/fuse)
start loop to read(fd) and process events
mount(fd)

Correct?
Side note: My immediate concern with this change are concurrency implications for userspace. IIUC you need to be able to process events while the thread that called mount() is still hanging in the syscall? Or would mount() return early before the mount has actually completed fully (that feels odd too, but I can't claim I know mount() syscall semantics well enough to be able to judge).
Regarding implications to my patch: I don't think there is anything that is fundamentally incompatible. The only thing that changes is that the privileged parent process needs to perform the mount and helper-spawning steps in reverse order (as already noted by Miklos above). That's simple enough, and when switching to the new world the privileged parent can send the PREINIT notification as proposed in #77, then spawn the FUSE daemon, then mount() and things will be fine. Arguably, spawing the FUSE daemon in a separate process might even simplify things for #77 since it naturally allows for concurrency (assuming my concern above is actually valid).
Given the backwards compatibility concerns aren't any different with/without my patch, and that whatever backwards compatibility solution you decide on for #77 will almost certainly work just as well with a spawned FUSE helper, I'm hoping we don't need to block this until the solution to #77 to materializes.
Regarding naming, I chose the ""pre-mounted"" term only after writing the code for lack of a better description of the idea :-D I'm happy to change naming of course. Maybe call the new FUSE daemon mode ""mount-less operation""? I'm having a hard time to come up with something that is both descriptive and short enough, open for suggestions.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/szmi,8,https://github.com/libfuse/libfuse/pull/291#issuecomment-417296032,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Re concurrency: normally (no SElinux setup involved) it woudn't be needed.  So a serialized setup would look like:

open /dev/fuse
read init request
write init reply
mount
start loop processing requests

Then there's the requirements from SElinux.  Not sure how to handle that, we could just require the processing loop to start in the background.
Or we could keep the serialized setup by preloading the security xattrs before starting the mount.
In any case the kernel should definitely handle the non-serialized case as well as the serialized one, so we could have mount(2) being called concurrently with I/O on the device descriptor and things should works fine.  As well as handling the legacy sequence, of course.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,9,https://github.com/libfuse/libfuse/pull/291#issuecomment-417304420,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Thanks Miklos for clarifying, sounds like the concurrent mount() + FUSE daemon initializing and processing I/O on the FUSE fd in a subprocess should work fine then and this PR is generally compatible with #77. Let me know in case there are any remaining concerns I've missed.
How do we want to proceed here? I have added a couple comments in the code that you might want to consider, and I'm happy to spin a new patch version with naming changes and whatever other improvements you'd like to see.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/szmi,10,https://github.com/libfuse/libfuse/pull/291#issuecomment-417307964,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Okay, so aesthetically the empty mountpoint argument is pretty bad.  Could we have an explicit ""--no-mount"" argument instead?
Also agree about not using the standard I/O descriptors.  Perhaps explicit argument ""--comm-fd=NN"" or whatever.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,11,https://github.com/libfuse/libfuse/pull/291#issuecomment-417563944,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","I agree with Miklos, but I don't think we need two new options. I'd say let's introduce a new --mount-fd=%d option which specifies the FD and, when specified, makes the mountpoint argument obsolete. I don't have a strong opinion of the kinds of checks to perform on the FD.
For nomenclature, I don't think this truly requires a new name. Currently, the term ""pre-mounted"" is used only once in a comment in the code, and there you can just completely omit the sentence that uses it. Writing a changelog entry without giving it a name shouldn't be too hard either.
One thing that bugs me is that the code for the caller (that does the mounting) would probably be similar for all users of this feature. Since we need a unit test for this feature anyway, would it make sense to add code for getting a suitable fd to libfuse as well? Ideally we'd provide another library function (so both the filesystem and the caller would link against libfuse). If that is not desirable from a security point of view, maybe we can still provide a separate, tiny library or at least a standalone C file that can be included verbatim?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,12,https://github.com/libfuse/libfuse/pull/291#issuecomment-417585057,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Thanks for the feedback! Single --mount-fd option sounds good, and I'll avoid dedicated feature naming as suggested. Will uploaded a new version of the patch that incorporates the feedback.
Regarding duplication of the mounting logic in the parent process, I have actually already thought about this from a somewhat different angle: I realized that adding support for the new mechanism in mount.fuse3 would be a good idea since it is a privileged parent process. If we also add in some basic support for dropping privileges, we get something that allows people to run fully deprivileged FUSE daemons for fstab mounts.
I have hacked together a proof of concept of this yesterday night, now uploaded here: saittam@c2a2a74 The code is super hacky at this point, but it already reuses parse_mount_opts and fuse_kern_mount for setting up the mount in the parent process, so providing a proper library function for this shouldn't be too hard. Are you OK with mount.fuse linking to libfuse.so though? Currently it doesn't and there's a comment at the top of the util/meson.build file that states the goal for stuff in /util is to be kept ""as standalone as possible"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,13,https://github.com/libfuse/libfuse/pull/291#issuecomment-417593210,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Interesting discovery: lib/mount_bsd.c already supports what I'm trying to achieve via the FUSE_DEV_FD to pass the file descriptor and FUSE_NO_MOUNT or empty mountpoint parameter to bypass mounting. Maybe we should lift this functionality from lib/mount_bsd.c to lib/fuse_lowlevel.c instead of implementing the same thing with a different interface? Then again, command-line switches are probably simpler to use in some situations than environment variables. WDYT?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,14,https://github.com/libfuse/libfuse/pull/291#issuecomment-417637448,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'",Uploaded new patch version and adjusted pull request title to reflect new commit message.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,15,https://github.com/libfuse/libfuse/pull/291#issuecomment-417658916,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","I think extending mount.fuse3 to do this is a great idea. There is a bit of an impedance mismatch though. mount.fuse3 is supposed to work with any fuse filesystem. But libfuse does not prescribe a specific way for filesystems to handle their command line parsing (it used to do this in the past, but I really want to get away from that). So there is no guarantee that if mount.fuse3 passes a --mount-fd parameter to the filesystem binary, it will be understood. That means at they very least mount.fuse3 will need to get a --use-mountfd parameter that controls the use of this feature. Using an environment variable, on the other hand, would work with any FUSE filesystem. So maybe it's worth to reconsider.. any thoughts?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,16,https://github.com/libfuse/libfuse/pull/291#issuecomment-417661710,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","I think the comment in util/meson.build is outdated. With meson, out-of-source builds are supported in all cases. So we should just remove the intermediate target and have fusermount depend directly on ../lib/mount_util.c.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,17,https://github.com/libfuse/libfuse/pull/291#issuecomment-417662507,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","We probably shouldn't put too much weight on what mount_bsd.c does. For a long time, FreeBSD has actually shipped its own FUSE mount helper so this code wasn't actually used. More recently, I have merged in the FreeBSD changes in an attempt to minimize divergence. However, at the kernel side FreeBSD is very much behind, so there is almost no reason to use libfuse3 and the integrated code is probably not used by many people. I don't know about the other BSDs though.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,18,https://github.com/libfuse/libfuse/pull/291#issuecomment-417771517,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Regarding mount.fuse3 integration vs. FUSE file system command line handling: Good point. A middle ground might be to pass mount_fd as a mount option (or just reuse the existing fd option that we pass to the kernel?); it should be safe to assume that all FUSE file system implementations will have a way for the user to specify arbitrary mount options and pass them on to libfuse? My gut feeling is that a command line parameter or a mount option are slightly preferable over environment variables since they tend to be easier to discover, but I really don't feel strongly. Let me know what your preference is.
Ack on the additional background regarding util/meson.build comment and BSD situation, useful context to have.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,19,https://github.com/libfuse/libfuse/pull/291#issuecomment-417936900,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","If we go with reusing the ""fd"" mount option, is there a way to check if the given fd matches the given mountpoint?
I dislike having a mount option make the mountpoint parameter obsolete (feels like a laying violation). If we could instead check if the fd is consistent with the specified path and mount options, that would make for a nicer experience.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,20,https://github.com/libfuse/libfuse/pull/291#issuecomment-418057834,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Regarding checking whether the /dev/fuse FD is associate with a given mount:

stat() on the mount gives you the device number, which is reflected in /sys/fs/fuse/connections/N.
I'm not aware of a way to get the device number for a /dev/fuse FD though. The kernel has that information, but I don't see anything that exposes it. How does one know which mount the entries in /sys/fs/fuse/connections refer to?
In the presence of bind mounts, there can be multiple points where (a subtree of) the file system is mounted. So the /dev/fuse file descriptor <-> mountpoints relationship is actually a complicated one in general.
It's possible that the FUSE filesystem daemon doesn't even see the mountpoint(s) it is mounted at. This can happen if you're running the daemon in a mount namespace and/or use pivot_root to constrain what it can see in the file system. In fact, I'd like to do so for Chrome OS - less stuff a process can see in the FS generally means lower risk.

Bottom line: I'm doubtful whether the consistency check you proposed is meaningful.
As a side note, it is interesting that obsoleting the mountpoint parameter feels like a layering violation to you (in which sense?). IMHO, the file system implementation knowing about higher-layer concerns such as where it's mounted is a layering violation in itself. I'm very aware that my perspective is probably biased by my background though!
Here's another idea that came to mind while thinking about this: Instead of the --mount-fd option, we could also special-case mountpoints of the form ""/dev/fd/%u"" to refer to an already opened /dev/fuse file descriptor. Would that make more sense to you?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/davies,21,https://github.com/libfuse/libfuse/pull/291#issuecomment-418139294,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","If I understand it correctly, this patch opens a door for zero-downtime upgrading (spawn the new version and pass the fd to it, then stop reading new requests and flush all buffers,  then tell child process to process new requests), that's very useful, thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,22,https://github.com/libfuse/libfuse/pull/291#issuecomment-418178586,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","The layering violation that bugs me is unrelated to FUSE, it only relates to command line parsing. I feel that the number of required arguments (i.e., stuff without leading dashes) should not depend on what parameters (i.e., stuff with leading dashes) are specified. The other way around is fine, and quite usual for subcommands. This bugs me somewhat about the --mount-fd option, but even more about the fd mount option: in that case it is the occurence of a string in the value of a parameter that changes the syntax of the whole command line.
My preference is therefore to keep the syntax unchanged (i.e., always require a mount point argument). But that only makes sense if we can make sure that the fd is consistent with the mountpoint, which it seems we sadly cannot do.
The /dev/fd/%u suggestion nicely solves the syntax problem, but instead introduces a semantic one - it's no longer clear what the argument actualy specifies.
I can't offer any better alternatives though, and I don't think this should block the patch, so feel free to choose either the /dev/fd approach or the -o fd=%d approach, depending on what makes cleaner code.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,23,https://github.com/libfuse/libfuse/pull/291#issuecomment-418326876,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Thanks for elaborating on your concerns regarding the mountpoint parameter, I get your point now. In the end, I guess there's no denying that if we're not actually mounting anything, a mountpoint parameter is technically out of place ;-) We could make a separate command line syntax that does not take any mountpoint, but given libfuse doesn't parse the command line directly I think it's better to stay compatible with the current syntax.
All things considered, the /dev/fd/%u option seems like the best compromise to me. As you note, it doesn't actually specify a mount point, but it refers to the object that is mounted (i.e. the /dev/fuse file descriptor), so it can be thought of as a generalization of mountpoint to ""kernel file system handle"". A traditional mountpoint argument would merely allow for that handle to be created on the spot. I think it should also allow to support Miklos' proposed filesystem file descriptors (as described here: https://lwn.net/Articles/718638/) if/when that change appears in the kernel.
Regarding zero-downtime upgrading: That's an interesting application indeed, and I'm not aware of conceptual problems in my patch that would prevent this. I have no idea how much state a typical FUSE file system implementation holds on the userspace side though, but assuming flushing and reloading as suggested in @davies reply is practical, that might not be a big deal. Another potential complication might be the initialization handshake, which will not reoccur if you re-use an existing FUSE file descriptor (not sure whether that is something FUSE file systems can be made to deal with?). Another missing piece you need is to get the FUSE file system to pass its existing file descriptor. libfuse library support could solve that, or alternatively you could just connect via ptrace() to the existing process and make it exec() the new version :-p",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,24,https://github.com/libfuse/libfuse/pull/291#issuecomment-419083222,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","New version is up that addresses all feedback thus far to the best of my knowledge, so this should be ready for finer-grained code review now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,25,https://github.com/libfuse/libfuse/pull/291#issuecomment-425441636,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","ping Are you no longer interested in working on this?
The only thing that prevents a merge is the missing testcase...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,26,https://github.com/libfuse/libfuse/pull/291#issuecomment-425567145,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","I still intend to finish this, but was busy with other stuff, sorry. I have
a test case working, need to polish and upload the code, hopefully early
next week.
…
On Fri, Sep 28, 2018, 09:49 Nikolaus Rath ***@***.***> wrote:
 *ping* Are you no longer interested in working on this?

 The only thing that prevents a merge is the missing testcase...

 —
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#291 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/AAJL6qmncEn6f0mnSSlFTnBAImAu-B8Eks5ufikCgaJpZM4WRv_W>
 .",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,27,https://github.com/libfuse/libfuse/pull/291#issuecomment-426271647,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","New version that adds tests and bumps the fuse version to 3.3 is up. Note that I also ended up making an standaline API function for opening and mounting the fuse file descriptor instead of reusing existing low-level fuse_session APIs. Reason is that fuse_session_new will choke on options it doesn't understand (intentional?), which was identified by the tests that verify passing the clone_fd option works (yay for testing!).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,28,https://github.com/libfuse/libfuse/pull/291#issuecomment-426286814,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'",Looks like the test is failing because it can't set SECUREBITS. Might be a CI environment issue? Is there a way to reproduce what the CI is doing locally so I can nail down what's failing?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,29,https://github.com/libfuse/libfuse/pull/291#issuecomment-426603337,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","No, I don't know what Travis is doing exactly. We will probably have to disable these tests on Travis - assuming that they work fine locally.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,30,https://github.com/libfuse/libfuse/pull/291#issuecomment-426604542,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","...however, it fails for me locally as well:
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse_unprivileged] FAILED                                                                                                [ 35%]

========================================================================================== FAILURES ==========================================================================================
_________________________________________________________________ test_hello[hello-options0-invoke_mount_fuse_unprivileged] __________________________________________________________________
Traceback (most recent call last):
  File ""/home/nikratio/in-progress/libfuse/build/test/test_examples.py"", line 64, in test_hello
    wait_for_mount(mount_process, mnt_dir)
  File ""/home/nikratio/in-progress/libfuse/build/test/util.py"", line 42, in wait_for_mount
    pytest.fail('file system process terminated prematurely')
  File ""/home/nikratio/.local/lib/python3.5/site-packages/_pytest/outcomes.py"", line 104, in fail
    raise Failed(msg=msg, pytrace=pytrace)
Failed: file system process terminated prematurely
------------------------------------------------------------------------------------ Captured stderr call ------------------------------------------------------------------------------------
/home/nikratio/in-progress/libfuse/build/test/../util/mount.fuse3: Failed to set securebits Operation not permitted
================================================================================== short test summary info ===================================================================================
FAIL test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse_unprivileged]
====================================================================================== warnings summary ======================================================================================

This is on Debian stable, not a container, no special hardening settings.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,31,https://github.com/libfuse/libfuse/pull/291#issuecomment-426604720,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'",Might it require root permissions?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,32,https://github.com/libfuse/libfuse/pull/291#issuecomment-427374608,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Might it require root permissions?

It requires capabilities, yes. The failure is either because it doesn't have CAP_SETPCAP, or because SECUREBITS are already locked. Note that the assumption is that mount.fuse3 is invoked with privileges (otherwise it couldn't mount either!).
What is the command line that used to invoke the test? It passes for me when invoked like this:
sudo python3 -m pytest build/test/
Can you also try capsh --print in your shell (and under sudo in case you're using that to launch the test) to see how securebits and the capabilities look like? I'll see whether I can reproduce the travis environment to nail this down.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,33,https://github.com/libfuse/libfuse/pull/291#issuecomment-427566730,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Might it require root permissions?

It requires capabilities, yes. The failure is either because it doesn't have CAP_SETPCAP, or because SECUREBITS are already locked. Note that the assumption is that mount.fuse3 is invoked with privileges (otherwise it couldn't mount either!).

Not sure I agree. Currently an ordinary user can call mount.fuse3 and things will work (assuming that fusermount3 is setuid). For the un-initiated it will be quite confusing that passing the unprivileged option means that mount.fuse3 requires more privileges. Can we detect this case and print a more helpful error message?
Also, could you add this option to doc/mount.fuse3.8 as well? (Apologies, this really is maintained in plain nroff...).

What is the command line that used to invoke the test? It passes for me when invoked like this:
sudo python3 -m pytest build/test/
Can you also try capsh --print in your shell (and under sudo in case you're using that to launch the test) to see how securebits and the capabilities look like? I'll see whether I can reproduce the travis environment to nail this down.

No need, as root it runs just fine. This is also why the Travis tests fail, most of them run as regular user. Could you skip the unprivileged test when there's insufficient privileges? (to skip, just call pytest.skip(reason)).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,34,https://github.com/libfuse/libfuse/pull/291#issuecomment-427769377,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Might it require root permissions?

It requires capabilities, yes. The failure is either because it doesn't have CAP_SETPCAP, or because SECUREBITS are already locked. Note that the assumption is that mount.fuse3 is invoked with privileges (otherwise it couldn't mount either!).

Not sure I agree. Currently an ordinary user can call mount.fuse3 and things will work (assuming that fusermount3 is setuid). For the un-initiated it will be quite confusing that passing the unprivileged option means that mount.fuse3 requires more privileges. Can we detect this case and print a more helpful error message?

Done. Also, I've renamed the ""unprivileged"" option to ""drop_privileges"", which makes it clearer that mount.fuse expects to have privileges and then drop them.

Also, could you add this option to doc/mount.fuse3.8 as well? (Apologies, this really is maintained in plain nroff...).

Done, created a new section detailing options handled by mount.fuse. While at it, I also documented the setuid option.


What is the command line that used to invoke the test? It passes for me when invoked like this:
sudo python3 -m pytest build/test/
Can you also try capsh --print in your shell (and under sudo in case you're using that to launch the test) to see how securebits and the capabilities look like? I'll see whether I can reproduce the travis environment to nail this down.

No need, as root it runs just fine. This is also why the Travis tests fail, most of them run as regular user. Could you skip the unprivileged test when there's insufficient privileges? (to skip, just call pytest.skip(reason)).

Done.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,35,https://github.com/libfuse/libfuse/pull/291#issuecomment-427797298,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Great, thanks for being so response!
The test cases now fail for a different reason. I'm struggling to interpret the error though (/bin/sh: 1: hello: Permission denied). Does that tell you anything? It might well be that the Travis environment doesn't like some of the privilege dropping stuff, but this error doesn't sound like that...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,36,https://github.com/libfuse/libfuse/pull/291#issuecomment-427803033,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Great, thanks for being so response!
The test cases now fail for a different reason. I'm struggling to interpret the error though (/bin/sh: 1: hello: Permission denied). Does that tell you anything? It might well be that the Travis environment doesn't like some of the privilege dropping stuff, but this error doesn't sound like that...

Stumped me as well, but a bit of local testing suggests that the problem might be that root can't exec the hello,hello_ll binaries for the case where it runs without CAP_DAC_OVERRIDE and other permission bits don't allow execution. I've just uploaded a new version with a speculative fix for that (setting umask in the travis script).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,37,https://github.com/libfuse/libfuse/pull/291#issuecomment-427805349,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Great, thanks for being so response!
The test cases now fail for a different reason. I'm struggling to interpret the error though (/bin/sh: 1: hello: Permission denied). Does that tell you anything? It might well be that the Travis environment doesn't like some of the privilege dropping stuff, but this error doesn't sound like that...

Stumped me as well, but a bit of local testing suggests that the problem might be that root can't exec the hello,hello_ll binaries for the case where it runs without CAP_DAC_OVERRIDE and other permission bits don't allow execution. I've just uploaded a new version with a speculative fix for that (setting umask in the travis script).

Turns out this didn't resolve it. Let me push a version that prints some diagnostics to hopefully find out more...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,38,https://github.com/libfuse/libfuse/pull/291#issuecomment-427838852,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Great, thanks for being so response!
The test cases now fail for a different reason. I'm struggling to interpret the error though (/bin/sh: 1: hello: Permission denied). Does that tell you anything? It might well be that the Travis environment doesn't like some of the privilege dropping stuff, but this error doesn't sound like that...

Stumped me as well, but a bit of local testing suggests that the problem might be that root can't exec the hello,hello_ll binaries for the case where it runs without CAP_DAC_OVERRIDE and other permission bits don't allow execution. I've just uploaded a new version with a speculative fix for that (setting umask in the travis script).

Turns out this didn't resolve it. Let me push a version that prints some diagnostics to hopefully find out more...

I'm still not any wiser unfortunately. I'll let this sink in and take a fresh look tomorrow.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,39,https://github.com/libfuse/libfuse/pull/291#issuecomment-427871474,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Great, thanks for being so response!
The test cases now fail for a different reason. I'm struggling to interpret the error though (/bin/sh: 1: hello: Permission denied). Does that tell you anything? It might well be that the Travis environment doesn't like some of the privilege dropping stuff, but this error doesn't sound like that...

Stumped me as well, but a bit of local testing suggests that the problem might be that root can't exec the hello,hello_ll binaries for the case where it runs without CAP_DAC_OVERRIDE and other permission bits don't allow execution. I've just uploaded a new version with a speculative fix for that (setting umask in the travis script).

Turns out this didn't resolve it. Let me push a version that prints some diagnostics to hopefully find out more...

I'm still not any wiser unfortunately. I'll let this sink in and take a fresh look tomorrow.

As long as it works locally for you and me, I'm fine with merging it even if the CI complains. Let's just make sure that the tests are skipped on the CI then instead of failing.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,40,https://github.com/libfuse/libfuse/pull/291#issuecomment-428190475,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'","Hooray, the tests are passing! :-D
It turns out my initial hunch that the binaries aren't accessible by the root user (running without CAP_DAC_OVERRIDE, i.e. lacking root's file system permission override powers), but the problem was that the entire directory hierarchy (not only the directory tree created by the build) isn't accessible. I've now adjust things to build in a temp directory instead. @Nikratio you'll want to look at the travis-build.sh changes in the latest version of the patch.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/Nikratio,41,https://github.com/libfuse/libfuse/pull/291#issuecomment-428322640,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'",Awesome!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,291,2018-08-29T15:06:39Z,2018-10-09T19:36:23Z,2018-10-10T08:11:13Z,MERGED,True,351,38,14,https://github.com/saittam,Allow passing `/dev/fuse` file descriptor from parent process ,2,[],https://github.com/libfuse/libfuse/pull/291,https://github.com/saittam,42,https://github.com/libfuse/libfuse/pull/291#issuecomment-428479022,"This adds a new ""pre-mounted"" mode of operation in which the FUSE file
system helper is launched after the /dev/fuse file descriptor has been
opened opened and the file system been mounted by a suitably
privileged process.
Pre-mounted mode is requested by passing an empty string as
mountpoint, which reflects the fact that the FUSE helper doesn't
actually perform or trigger any mounting itself.
The main benefit of pre-mounted mode is that no privileged operations
need to be performed by the file system implementation itself directly
or indirectly, so the FUSE process can run with zero privilege.
Moreover, mechanisms like securebits and no_new_privs can be used to
prevent subprocesses from re-acquiring privilege, which further helps
reduce risk for the case the FUSE helper gets exploited by a malicious
file system.
Below is an example that illustrates this. Note that I'm using shell
for presentation purposes, the assumption is that there's a privileged
daemon that handles mounting and spawning the FUSE helper in a
suitable sandbox.
Make binaries and libs executable by anyone
$ chmod o+rx build/lib/libfuse3.so* example/hello
$ export LD_LIBRARY_PATH=$PWD/build/lib
example/hello can mount successfully with privilege
$ sudo sh -c ""LD_LIBRARY_PATH=build/lib ./example/hello /mnt/tmp""
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
example/hello fails to mount without privilege
$ sudo capsh --drop=all --secbits=0x3f -- -c 'LD_LIBRARY_PATH=build/lib ./example/hello -f /mnt/tmp'
fusermount3: mount failed: Operation not permitted
Pre-mounting allows example/hello to work without privilege
$ sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
' &
[1] 55491
$ sudo cat /mnt/tmp/hello
Hello World!
$ sudo umount /mnt/tmp
[1]+  Done                    sudo sh -c '
exec 0<>/dev/fuse
mount -i -o nodev,nosuid,noexec,fd=0,rootmode=40000,user_id=0,group_id=0 -t fuse hello /mnt/tmp
capsh --drop=all --secbits=0x3f -- -c ""LD_LIBRARY_PATH=build/lib example/hello -f """"""
'",Excellent! Thanks for your patience on this.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,296,2018-09-06T23:12:02Z,2018-09-28T13:48:34Z,2018-09-28T13:48:43Z,MERGED,True,14,3,2,https://github.com/t-chaik,Add build options for utils and examples,1,[],https://github.com/libfuse/libfuse/pull/296,https://github.com/t-chaik,1,https://github.com/libfuse/libfuse/pull/296,"Allow skipping utils build & installation (-Dutils=false) and examples
build (-Dexamples=false). By default behaviour is unchanged (both are
true: utils and examples get build).","Allow skipping utils build & installation (-Dutils=false) and examples
build (-Dexamples=false). By default behaviour is unchanged (both are
true: utils and examples get build).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,296,2018-09-06T23:12:02Z,2018-09-28T13:48:34Z,2018-09-28T13:48:43Z,MERGED,True,14,3,2,https://github.com/t-chaik,Add build options for utils and examples,1,[],https://github.com/libfuse/libfuse/pull/296,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/296#issuecomment-425441328,"Allow skipping utils build & installation (-Dutils=false) and examples
build (-Dexamples=false). By default behaviour is unchanged (both are
true: utils and examples get build).",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,297,2018-09-26T06:12:21Z,2018-09-27T08:29:24Z,2018-09-27T08:29:24Z,MERGED,True,1,1,1,https://github.com/chkno,Fix unlink errno check,1,[],https://github.com/libfuse/libfuse/pull/297,https://github.com/chkno,1,https://github.com/libfuse/libfuse/pull/297,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,297,2018-09-26T06:12:21Z,2018-09-27T08:29:24Z,2018-09-27T08:29:24Z,MERGED,True,1,1,1,https://github.com/chkno,Fix unlink errno check,1,[],https://github.com/libfuse/libfuse/pull/297,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/297#issuecomment-425004654,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,300,2018-10-15T13:37:14Z,2018-10-16T13:07:29Z,2018-10-16T13:07:29Z,CLOSED,False,4,1,1,https://github.com/Chethangc,I faced the problem with meson build version.,1,[],https://github.com/libfuse/libfuse/pull/300,https://github.com/Chethangc,1,https://github.com/libfuse/libfuse/pull/300,"meson build version was old and if we upgrade the OS then no build version error
so keep your OS updated and upgraded for error less installation.","meson build version was old and if we upgrade the OS then no build version error
so keep your OS updated and upgraded for error less installation.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,300,2018-10-15T13:37:14Z,2018-10-16T13:07:29Z,2018-10-16T13:07:29Z,CLOSED,False,4,1,1,https://github.com/Chethangc,I faced the problem with meson build version.,1,[],https://github.com/libfuse/libfuse/pull/300,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/300#issuecomment-430192919,"meson build version was old and if we upgrade the OS then no build version error
so keep your OS updated and upgraded for error less installation.","Thanks for the patch! The instructions are a little unclear though - what does it mean that the ""operating system is upgraded""? This is a little too general to be useful, especially since libfuse should not require upgrading the entire operating system. Do you remember what exactly you had to upgrade?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,300,2018-10-15T13:37:14Z,2018-10-16T13:07:29Z,2018-10-16T13:07:29Z,CLOSED,False,4,1,1,https://github.com/Chethangc,I faced the problem with meson build version.,1,[],https://github.com/libfuse/libfuse/pull/300,https://github.com/Chethangc,3,https://github.com/libfuse/libfuse/pull/300#issuecomment-430195377,"meson build version was old and if we upgrade the OS then no build version error
so keep your OS updated and upgraded for error less installation.","Sorry for the unclear instruction,I had a meson build error ie 0.45 or
higher version is required in Ubuntu 16.10 and 17.10

I was not able to update the meson.
Because for 16.04 the version is 0.42.
I upgraded my operating system to - 18.04 it executed without error.
Meson version changed and its error free installation.

I mean to say that uprade your existing os to 18.04 or higher when ever you
face a problem in installation of fuse.
      Don't try to install in older version of Ubuntu it may give you error.
…
On Tue, Oct 16, 2018, 4:24 PM Nikolaus Rath ***@***.***> wrote:
 Thanks for the patch! The instructions are a little unclear though - what
 does it mean that the ""operating system is upgraded""? This is a little too
 general to be useful, especially since libfuse should not require upgrading
 the entire operating system. Do you remember what exactly you had to
 upgrade?

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#300 (comment)>, or mute
 the thread
 <https://github.com/notifications/unsubscribe-auth/AeFCxjP9zx5yCZVvga1AImZg4KiquI52ks5ulbr9gaJpZM4XcW0Q>
 .",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,300,2018-10-15T13:37:14Z,2018-10-16T13:07:29Z,2018-10-16T13:07:29Z,CLOSED,False,4,1,1,https://github.com/Chethangc,I faced the problem with meson build version.,1,[],https://github.com/libfuse/libfuse/pull/300,https://github.com/Chethangc,4,https://github.com/libfuse/libfuse/pull/300#issuecomment-430196883,"meson build version was old and if we upgrade the OS then no build version error
so keep your OS updated and upgraded for error less installation.","As per my knowledge it requires entire os upgrade is required.
Meson is platform dependent.
Installed meson version
16.04- 0.42 build error
17.14- 0.44 error while pytest same 0.45 or higher is required.
18.04 error free installation.

In a class of 60 almost 40 students who have not upgraded os got this
errors.
…
On Tue, Oct 16, 2018, 4:33 PM Chethan G C ***@***.***> wrote:
 Sorry for the unclear instruction,I had a meson build error ie 0.45 or
 higher version is required in Ubuntu 16.10 and 17.10

 I was not able to update the meson.
 Because for 16.04 the version is 0.42.
 I upgraded my operating system to - 18.04 it executed without error.
 Meson version changed and its error free installation.

 I mean to say that uprade your existing os to 18.04 or higher when ever
 you face a problem in installation of fuse.
       Don't try to install in older version of Ubuntu it may give you
 error.


 On Tue, Oct 16, 2018, 4:24 PM Nikolaus Rath ***@***.***>
 wrote:

> Thanks for the patch! The instructions are a little unclear though - what
> does it mean that the ""operating system is upgraded""? This is a little too
> general to be useful, especially since libfuse should not require upgrading
> the entire operating system. Do you remember what exactly you had to
> upgrade?
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <#300 (comment)>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AeFCxjP9zx5yCZVvga1AImZg4KiquI52ks5ulbr9gaJpZM4XcW0Q>
> .
>",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,300,2018-10-15T13:37:14Z,2018-10-16T13:07:29Z,2018-10-16T13:07:29Z,CLOSED,False,4,1,1,https://github.com/Chethangc,I faced the problem with meson build version.,1,[],https://github.com/libfuse/libfuse/pull/300,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/300#issuecomment-430230143,"meson build version was old and if we upgrade the OS then no build version error
so keep your OS updated and upgraded for error less installation.",Thanks for clarifying! I have just updated the meson.build file accordingly.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/kevin-vigor,1,https://github.com/libfuse/libfuse/pull/302,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/302#issuecomment-430642810,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Thanks for the patch! Just to make sure, when you wrote unmounted by umount, you mean unmounted by fusermount -u, right? Otherwise I do not understand how making changes to fusermount will affect the situation.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/kevin-vigor,3,https://github.com/libfuse/libfuse/pull/302#issuecomment-430694346,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Hi Nikolaus! No, I actually do mean 'unmounted by umount' (but the same problem occurs when you unmount using fusermount -u).
In auto_unmount mode, libfuse spawns an instance of fusermount to watch the filesystem process when mounting  (see fuse_mount_fusermount()). When the filesystem process dies the watching fusermount process then unmounts the mountpoint (see the auto_unmount case in util/fusermount.c:main()).
This works properly when the filesystem process dies due to a crash or something which leaves the mount in place (the watching fusermount cleans up the mountpoint, preventing the dreaded 'transport endpoint not connected' error). But when the filesystem process is cleanly unmounted, then the watching fusermount unmounts the mountpoint a second time, which is usually not a problem (it just fails silently), but breaks when running under autofs.
I have tested this patch by unmounting the filesystem using umount, fusermount -u, and by simply killing the filesystem process. It works properly in all cases (only the last one worked before).
FWIW a version of this patch has been deployed inside Facebook for several years so it has had a lot of test cycles.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/302#issuecomment-430856129,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Ah, got you. I somehow managed to overlook the auto_unmount part.
I am not sure I like this approach though. It fixes the issue for autofs, but what about other situations were the filesystem is mounted on top of an existing mountpoint (especially another FUSE one). Wouldn't that still result in a double unmount? Would it maybe a better approach to unmount only if accessing the mountpoint gives a ""Transport endpoint not connected"" error?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/kevin-vigor,5,https://github.com/libfuse/libfuse/pull/302#issuecomment-431058552,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Yeah, this is a partial solution for sure, double unmounts can still occur. It does solve a large class of problems, though, and I was trying to be conservative and change existing behaviour (unmount all the things!) as little as possible.
But I will happily implement the 'unmount only on transport endpoint error' version, if you are willing to accept it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/kevin-vigor,6,https://github.com/libfuse/libfuse/pull/302#issuecomment-431105850,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Updated patch to check that mount is in broken (ENOTCONN) state before unmounting, as well as the filesystem type check previously posted.
As a bonus, this now only affects the auto_unmount case; the prior version of this diff altered behaviour of 'fusermount -u' which seems undesirable.
Tested unmounting with umount, fusermount -u, fusermount3 -u, and by kill -9'ing the filesystem process. In all cases the fuse filesystem was unmounted and the underlying autofs filesystem remained mounted.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/302#issuecomment-431221966,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Thanks, I like this much better. But is there a reason to retain the additional type check? Carrying this around everywhere makes the good more complicated.
Also, please add a line to ChangeLog.rst",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,302,2018-10-16T23:38:45Z,2018-11-06T18:45:16Z,2018-11-06T18:45:16Z,MERGED,True,63,11,1,https://github.com/kevin-vigor,"When in auto_unmount mode, check filesystem type before unmounting.",1,[],https://github.com/libfuse/libfuse/pull/302,https://github.com/kevin-vigor,8,https://github.com/libfuse/libfuse/pull/302#issuecomment-431414766,"This addresses a problem when a fuse filesystem using auto_unmount is mounted
by autofs. Autofs uses a stacked mount approach, mounting the mountpoint as
type 'autofs'; then when the mountpoint is accessed the fuse filesystem is
mounted over the autofs mount.
Prior to this change, when such a filesystem was unmounted by 'umount',
the mountpoint would be unmounted twice, once by autofs, once by fusermount.
This resulted in the autofs mount being umounted, and autofs was broken
thereafter.","Unfortunately I believe it is still necessary to check the filesystem type. The problem is that if autofs is in use and a normal unmount occurs, autofs is the active mount when fusermount runs the cleanup code. If we then try to access the mountpoint to see it is is returning ENOTCONN, autofs will happily mount the filesystem again. The result is that you can never actually unmount because the unmount process causes a new mount.
I attempted to explain this in the comment block preceding should_auto_unmount().
Changelog entry has been added.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,305,2018-10-18T20:04:55Z,2018-10-18T20:09:07Z,2018-10-18T20:09:07Z,CLOSED,False,8,24,3,https://github.com/ahmed-masud,Meson test when libfuse is a subproject,3,[],https://github.com/libfuse/libfuse/pull/305,https://github.com/ahmed-masud,1,https://github.com/libfuse/libfuse/pull/305,"A small change to suppress error from test/wrong_command.c when libfuse is a subproject, avoids cluttering of test reports in the parent project.","A small change to suppress error from test/wrong_command.c when libfuse is a subproject, avoids cluttering of test reports in the parent project.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,305,2018-10-18T20:04:55Z,2018-10-18T20:09:07Z,2018-10-18T20:09:07Z,CLOSED,False,8,24,3,https://github.com/ahmed-masud,Meson test when libfuse is a subproject,3,[],https://github.com/libfuse/libfuse/pull/305,https://github.com/ahmed-masud,2,https://github.com/libfuse/libfuse/pull/305#issuecomment-431145020,"A small change to suppress error from test/wrong_command.c when libfuse is a subproject, avoids cluttering of test reports in the parent project.","I think i screwed this up, will create another one",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,306,2018-10-18T20:35:58Z,2018-10-19T06:16:31Z,2018-10-19T21:15:31Z,CLOSED,False,5,1,2,https://github.com/ahmed-masud,skip rather than report error while running `ninja test` when libfuse is subproject,3,[],https://github.com/libfuse/libfuse/pull/306,https://github.com/ahmed-masud,1,https://github.com/libfuse/libfuse/pull/306,Have wrong_command return a skip code (77) rather than get an error when libfuse is a subproject,Have wrong_command return a skip code (77) rather than get an error when libfuse is a subproject,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,306,2018-10-18T20:35:58Z,2018-10-19T06:16:31Z,2018-10-19T21:15:31Z,CLOSED,False,5,1,2,https://github.com/ahmed-masud,skip rather than report error while running `ninja test` when libfuse is subproject,3,[],https://github.com/libfuse/libfuse/pull/306,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/306#issuecomment-431501255,Have wrong_command return a skip code (77) rather than get an error when libfuse is a subproject,"You know that you can just change the pull request, right?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,308,2018-10-19T07:24:17Z,2018-10-19T21:17:48Z,2018-10-19T21:17:48Z,MERGED,True,16,3,2,https://github.com/ahmed-masud,* Fixed ninja test / meson test when libfuse is a subproject,1,[],https://github.com/libfuse/libfuse/pull/308,https://github.com/ahmed-masud,1,https://github.com/libfuse/libfuse/pull/308,"Modified test/meson.build and test/wrong_command.c to report a
skip to remove clutter from parent project running meson test harness.","Modified test/meson.build and test/wrong_command.c to report a
skip to remove clutter from parent project running meson test harness.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,308,2018-10-19T07:24:17Z,2018-10-19T21:17:48Z,2018-10-19T21:17:48Z,MERGED,True,16,3,2,https://github.com/ahmed-masud,* Fixed ninja test / meson test when libfuse is a subproject,1,[],https://github.com/libfuse/libfuse/pull/308,https://github.com/ahmed-masud,2,https://github.com/libfuse/libfuse/pull/308#issuecomment-431270090,"Modified test/meson.build and test/wrong_command.c to report a
skip to remove clutter from parent project running meson test harness.",Hopefully this is cleaner :-),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,309,2018-10-19T16:47:30Z,2018-10-19T21:19:29Z,2018-10-19T21:19:29Z,MERGED,True,2,0,1,https://github.com/vplugaru,Add SpectrumScale/GPFS and Lustre to FS whitelist.,1,[],https://github.com/libfuse/libfuse/pull/309,https://github.com/vplugaru,1,https://github.com/libfuse/libfuse/pull/309,Add SpectrumScale/GPFS and Lustre to FS whitelist as per issue #304.,Add SpectrumScale/GPFS and Lustre to FS whitelist as per issue #304.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/t-chaik,1,https://github.com/libfuse/libfuse/pull/310,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399","When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/310#issuecomment-431684692,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399",Hmm. What is the context here? It seems odd to me that you'd want to run the install_helper script at all if you're using libfuse a s a sub-project. I'd think the only reason to do that if you want to link against the library...,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/t-chaik,3,https://github.com/libfuse/libfuse/pull/310#issuecomment-431685437,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399","I'm not a FUSE expert, so please correct me if I'm wrong, but isn't a set-uid root installed fusermount3 required for unprivileged user mount and unmount operations?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/310#issuecomment-431686068,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399","Yes. But that would normally be provided by a standalone libfuse installation, not when it's used as a subproject. Do you have a specific application that uses libfuse as a subproject and wants to install a fusermount? If so, why?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/t-chaik,5,https://github.com/libfuse/libfuse/pull/310#issuecomment-431687859,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399","BuildBox is a tool that allows running commands in an unprivileged sandbox using Bubblewrap ontop of a FUSE provided file system. It builds using meson, has libfuse dependency and mount/unmount FUSE filesystems at runtime. Building libfuse as a subproject would be of great help on distros where fuse3 is not available, but is less useful if fusermount3 is not installed along.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/310#issuecomment-433646788,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399","I would be very unhappy if installing Buildbox would end-up installing a general purpose setuid binary in /sbin. Also, the installation instructions (https://gitlab.com/BuildStream/buildbox/blob/master/INSTALL.rst) actually say to install the dependencies separately. So... I'm still not convinced that this is a good idea (and apparently the BuildBox dev's aren't either).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,310,2018-10-21T15:13:12Z,2019-03-09T10:37:00Z,2019-03-09T10:37:00Z,CLOSED,False,8,7,2,https://github.com/t-chaik,Avoid using MESON_SOURCE_ROOT in install script,1,[],https://github.com/libfuse/libfuse/pull/310,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/310#issuecomment-471165727,"When libfuse is used as a meson subproject, MESON_SOURCE_ROOT is set to
the parent package source directory in install script environment, thus
breaking source file references. There doesn't seem to be a preferred
way of accessing the current project's source directory from such a script
at the moment [1]. This patch works around this by passing the current
project source directory as an argument of the script.
[1] mesonbuild/meson#4399",Closing this for the reasons given above. Feel free to re-open if there's anything I haven't considered.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,314,2018-10-24T15:19:05Z,2018-10-25T04:17:57Z,2018-10-25T04:17:57Z,CLOSED,False,16,3,2,https://github.com/ahmed-masud,* Fixed ninja test / meson test when libfuse is a sub-project,1,[],https://github.com/libfuse/libfuse/pull/314,https://github.com/ahmed-masud,1,https://github.com/libfuse/libfuse/pull/314,"Modified test/meson.build and test/wrong_command.c to report a
skip to remove clutter from parent project running meson test harness","Modified test/meson.build and test/wrong_command.c to report a
skip to remove clutter from parent project running meson test harness",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,314,2018-10-24T15:19:05Z,2018-10-25T04:17:57Z,2018-10-25T04:17:57Z,CLOSED,False,16,3,2,https://github.com/ahmed-masud,* Fixed ninja test / meson test when libfuse is a sub-project,1,[],https://github.com/libfuse/libfuse/pull/314,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/314#issuecomment-432909188,"Modified test/meson.build and test/wrong_command.c to report a
skip to remove clutter from parent project running meson test harness",Already merged - guess this was an accidental reopen?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/novel,1,https://github.com/libfuse/libfuse/pull/321,Please refer to commit messages of individual commits for more details.,Please refer to commit messages of individual commits for more details.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/novel,2,https://github.com/libfuse/libfuse/pull/321#issuecomment-437673726,Please refer to commit messages of individual commits for more details.,"I thought it's Linux specific because it's only built on Linux:
if host_machine.system().startswith('linux')
   libfuse_sources += [ 'mount.c', 'mount_util.c' ]
else
   libfuse_sources += [ 'mount_bsd.c' ]
endif

I thought that it could be a mistake (also I've seen some ifndefs NetBSD there), but in fact it doesn't build if I add it to sources list on FreeBSD. I'll take a look, probably I'll be able to fix it without introducing a new file.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/novel,3,https://github.com/libfuse/libfuse/pull/321#issuecomment-437675795,Please refer to commit messages of individual commits for more details.,Updated.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/stesser,4,https://github.com/libfuse/libfuse/pull/321#issuecomment-437679896,Please refer to commit messages of individual commits for more details.,"I'm not opening a new issue since I think the following applies to this one ... (let me know if you prefer a seperate issue for tracking purposes).
I had to add the following diff to make libfuse build on FreeBSD, since the mount_util.c is not compiled on FreeBSD and it contains the body of fuse_mnt_parse_fuse_fd(). With this patch, the code that depends on fuse_mnt_parse_fuse_fd() returning an fd != -1 is optimized out.
+++ lib/mount_util.h
@@ -15,4 +15,9 @@ int fuse_mnt_umount(const char *progname, const char *
                    const char *rel_mnt, int lazy);
 char *fuse_mnt_resolve_path(const char *progname, const char *orig);
 int fuse_mnt_check_fuseblk(void);
+
+#if defined(__FreeBSD__)
+#define fuse_mnt_parse_fuse_fd(x) (-1)
+#else
 int fuse_mnt_parse_fuse_fd(const char *mountpoint);
+#endif",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/novel,5,https://github.com/libfuse/libfuse/pull/321#issuecomment-437680169,Please refer to commit messages of individual commits for more details.,"I'm not opening a new issue since I think the following applies to this one ... (let me know if you prefer a seperate issue for tracking purposes).

This should be fixed as well by this PR I believe, please take a look at this commit: a9177e0",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/stesser,6,https://github.com/libfuse/libfuse/pull/321#issuecomment-437680969,Please refer to commit messages of individual commits for more details.,"Yes, I have verified that commit a9177e0 builds on FreeBSD without any patches.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/novel,7,https://github.com/libfuse/libfuse/pull/321#issuecomment-437681612,Please refer to commit messages of individual commits for more details.,"I haven't test the fd's  thing, yet to figure out how to test it properly.
I did test regular sshfs mounts though and that works for me now with these patches (that's what I was trying to fix in the first place, noticed build issues later when started looking into it).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,321,2018-11-11T10:54:13Z,2018-11-11T19:40:27Z,2018-11-11T19:40:27Z,MERGED,True,8,8,3,https://github.com/novel,Fix build and mounting on FreeBSD,2,[],https://github.com/libfuse/libfuse/pull/321,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/321#issuecomment-437698233,Please refer to commit messages of individual commits for more details.,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,330,2018-12-01T14:29:42Z,2018-12-02T01:32:51Z,2018-12-02T01:32:51Z,CLOSED,False,2,0,1,https://github.com/Mashimiao,lib/fuse_lowlevel.c: fix memory leak,1,['needs-info'],https://github.com/libfuse/libfuse/pull/330,https://github.com/Mashimiao,1,https://github.com/libfuse/libfuse/pull/330,Signed-off-by: Ma Shimiao shimiao.ma@gmail.com,Signed-off-by: Ma Shimiao shimiao.ma@gmail.com,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,330,2018-12-01T14:29:42Z,2018-12-02T01:32:51Z,2018-12-02T01:32:51Z,CLOSED,False,2,0,1,https://github.com/Mashimiao,lib/fuse_lowlevel.c: fix memory leak,1,['needs-info'],https://github.com/libfuse/libfuse/pull/330,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/330#issuecomment-443453121,Signed-off-by: Ma Shimiao shimiao.ma@gmail.com,"Thanks for the patch! Could you briefly explain why you think there is a leak? Note that your patch results in crashing because of an invalid free() call, while without the patch the tests are passing.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,330,2018-12-01T14:29:42Z,2018-12-02T01:32:51Z,2018-12-02T01:32:51Z,CLOSED,False,2,0,1,https://github.com/Mashimiao,lib/fuse_lowlevel.c: fix memory leak,1,['needs-info'],https://github.com/libfuse/libfuse/pull/330,https://github.com/Mashimiao,3,https://github.com/libfuse/libfuse/pull/330#issuecomment-443472967,Signed-off-by: Ma Shimiao shimiao.ma@gmail.com,"Oh, sorry...   that may be my fault.   I find we just do malloc int do_poll, but not free ph in that function.
I rescan the test code, and find it will be freed in other places.  will close this pr.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/browei,1,https://github.com/libfuse/libfuse/pull/332,Fixed paddings exceeds the boundary which cost one more unsigned int,Fixed paddings exceeds the boundary which cost one more unsigned int,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/332#issuecomment-444938981,Fixed paddings exceeds the boundary which cost one more unsigned int,"This would break  compatibility with binaries compiled against libfuse headers before this change, wouldn't it?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/jpandre,3,https://github.com/libfuse/libfuse/pull/332#issuecomment-445258454,Fixed paddings exceeds the boundary which cost one more unsigned int,"This is unfortunate. The more as the next field is an uint64, which on most 64-bit cpus is aligned to 8 bytes, so a couple of ints are lost. It is even possible that uint64's are aligned differently in 32-bit mode, and as a consequence 32-bit user-space file systems would not run on a 64-bit kernel (check needed).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/332#issuecomment-445443584,Fixed paddings exceeds the boundary which cost one more unsigned int,"Yeah, I agree. Do you see any solution though?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/jpandre,5,https://github.com/libfuse/libfuse/pull/332#issuecomment-445482084,Fixed paddings exceeds the boundary which cost one more unsigned int,"Actually, you are lucky. Formerly there were an int and a bit field, which took two ints. The int was then redefined as a bit field, creating the overflow, and also taking two ints. This is why the error was not noticed earlier (though the used bits fields were relocated).
I suggest you fix the size of the unused field, and add another dummy int in order to show a clean layout (to remain compatible with old binaries, this extra int should be inserted before the fields, but you may prefer to be compatible with recent binaries and insert the extra int after the fields).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/332#issuecomment-445759717,Fixed paddings exceeds the boundary which cost one more unsigned int,"Thanks for looking into this! Would you mind updating the pull request?
As far as I can see all changes in this area of the file are 8+ years old - is that what you mean with ""recent binaries""?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/jpandre,7,https://github.com/libfuse/libfuse/pull/332#issuecomment-447552067,Fixed paddings exceeds the boundary which cost one more unsigned int,"Sorry for the delay. In the meantime, I discovered that the header I use (Centos7, updated last month) is not the same as the one on the repository. In particular the old field ""fh_old"", which had been kept for years to maintain binary compatibility, has been removed, supposedly with no damage.
This means the binary compatibility is not needed any more, and the proposed patch should do.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,332,2018-12-06T14:11:13Z,2019-01-07T14:06:32Z,2019-01-07T14:06:32Z,CLOSED,False,1,1,1,https://github.com/browei,Fixed paddings exceeds the boundary,1,['needs-info'],https://github.com/libfuse/libfuse/pull/332,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/332#issuecomment-448145032,Fixed paddings exceeds the boundary which cost one more unsigned int,"Sorry, I still do not understand. struct fuse_file_info was last changed 8+ years ago. Any changes made here that change the layout will thus break compatibility with any binary that was compiled between 8 years ago and today. Why do you think that ""binary compatibility is not needed any more""?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,337,2018-12-20T17:35:03Z,2018-12-22T12:14:57Z,2018-12-22T12:14:59Z,MERGED,True,1,0,1,https://github.com/devkral,fix memory leak in print_module_help method,1,[],https://github.com/libfuse/libfuse/pull/337,https://github.com/devkral,1,https://github.com/libfuse/libfuse/pull/337,"The members of the fuse_args struct are never freed, so there is a small memory leak.","The members of the fuse_args struct are never freed, so there is a small memory leak.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,337,2018-12-20T17:35:03Z,2018-12-22T12:14:57Z,2018-12-22T12:14:59Z,MERGED,True,1,0,1,https://github.com/devkral,fix memory leak in print_module_help method,1,[],https://github.com/libfuse/libfuse/pull/337,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/337#issuecomment-449566023,"The members of the fuse_args struct are never freed, so there is a small memory leak.",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,339,2019-01-07T20:52:00Z,2019-03-09T11:02:24Z,2019-03-09T11:02:24Z,MERGED,True,22,11,1,https://github.com/chadaustin,fuse_lowlevel_ops documentation updates,2,[],https://github.com/libfuse/libfuse/pull/339,https://github.com/chadaustin,1,https://github.com/libfuse/libfuse/pull/339,"Add a bit of clarity to the fuse_lowlevel_ops documentation, as it's one of the best high-level descriptions of the FUSE kernel protocol.
Fixes #333.","Add a bit of clarity to the fuse_lowlevel_ops documentation, as it's one of the best high-level descriptions of the FUSE kernel protocol.
Fixes #333.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,339,2019-01-07T20:52:00Z,2019-03-09T11:02:24Z,2019-03-09T11:02:24Z,MERGED,True,22,11,1,https://github.com/chadaustin,fuse_lowlevel_ops documentation updates,2,[],https://github.com/libfuse/libfuse/pull/339,https://github.com/chadaustin,2,https://github.com/libfuse/libfuse/pull/339#issuecomment-456514965,"Add a bit of clarity to the fuse_lowlevel_ops documentation, as it's one of the best high-level descriptions of the FUSE kernel protocol.
Fixes #333.",More code review clarifications.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,340,2019-01-14T19:26:18Z,2019-01-14T20:28:42Z,2019-01-14T20:28:47Z,MERGED,True,3,3,1,https://github.com/kusumi,Unbreak build on DragonFly BSD,2,[],https://github.com/libfuse/libfuse/pull/340,https://github.com/kusumi,1,https://github.com/libfuse/libfuse/pull/340,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,340,2019-01-14T19:26:18Z,2019-01-14T20:28:42Z,2019-01-14T20:28:47Z,MERGED,True,3,3,1,https://github.com/kusumi,Unbreak build on DragonFly BSD,2,[],https://github.com/libfuse/libfuse/pull/340,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/340#issuecomment-454149888,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,344,2019-01-22T11:34:45Z,2019-02-26T17:52:27Z,2019-02-26T17:53:00Z,CLOSED,False,63,7,3,https://github.com/stefanha,fuse_lowlevel: validate path components,1,['needs-info'],https://github.com/libfuse/libfuse/pull/344,https://github.com/stefanha,1,https://github.com/libfuse/libfuse/pull/344,"Several FUSE requests contain single path components.  A correct FUSE
client sends well-formed path components but there is currently no input
validation in fuse_lowlevel.c in case something went wrong.
File system implementations might accidentally treat invalid inputs as
absolute/relative paths instead of rejecting them.  Save implementations
from duplicating input validation by handling it in fuse_lowlevel.c.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com","Several FUSE requests contain single path components.  A correct FUSE
client sends well-formed path components but there is currently no input
validation in fuse_lowlevel.c in case something went wrong.
File system implementations might accidentally treat invalid inputs as
absolute/relative paths instead of rejecting them.  Save implementations
from duplicating input validation by handling it in fuse_lowlevel.c.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,344,2019-01-22T11:34:45Z,2019-02-26T17:52:27Z,2019-02-26T17:53:00Z,CLOSED,False,63,7,3,https://github.com/stefanha,fuse_lowlevel: validate path components,1,['needs-info'],https://github.com/libfuse/libfuse/pull/344,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/344#issuecomment-456542453,"Several FUSE requests contain single path components.  A correct FUSE
client sends well-formed path components but there is currently no input
validation in fuse_lowlevel.c in case something went wrong.
File system implementations might accidentally treat invalid inputs as
absolute/relative paths instead of rejecting them.  Save implementations
from duplicating input validation by handling it in fuse_lowlevel.c.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com","With ""FUSE client"", do you mean the kernel? Because that is what your code seems to be checking, but I am not convinced that this is worth it. Or do you mean a userspace client accessing the filesystem? In that case the kernel will do the checks already...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,344,2019-01-22T11:34:45Z,2019-02-26T17:52:27Z,2019-02-26T17:53:00Z,CLOSED,False,63,7,3,https://github.com/stefanha,fuse_lowlevel: validate path components,1,['needs-info'],https://github.com/libfuse/libfuse/pull/344,https://github.com/szmi,3,https://github.com/libfuse/libfuse/pull/344#issuecomment-456711770,"Several FUSE requests contain single path components.  A correct FUSE
client sends well-formed path components but there is currently no input
validation in fuse_lowlevel.c in case something went wrong.
File system implementations might accidentally treat invalid inputs as
absolute/relative paths instead of rejecting them.  Save implementations
from duplicating input validation by handling it in fuse_lowlevel.c.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com","Nikolaus, the rationale for this patch is that the peer where the messages come from may not always be trusted, so input should be validated.   If the peer is the host kernel, then we do trust it, but in the virtio-fs case the peer is a virtualized guest kernel, and the hypervisor must not place any trust in the virtualized OS, otherwise an attacker could escape from the guest to the host.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,344,2019-01-22T11:34:45Z,2019-02-26T17:52:27Z,2019-02-26T17:53:00Z,CLOSED,False,63,7,3,https://github.com/stefanha,fuse_lowlevel: validate path components,1,['needs-info'],https://github.com/libfuse/libfuse/pull/344,https://github.com/stefanha,4,https://github.com/libfuse/libfuse/pull/344#issuecomment-456755346,"Several FUSE requests contain single path components.  A correct FUSE
client sends well-formed path components but there is currently no input
validation in fuse_lowlevel.c in case something went wrong.
File system implementations might accidentally treat invalid inputs as
absolute/relative paths instead of rejecting them.  Save implementations
from duplicating input validation by handling it in fuse_lowlevel.c.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",Perhaps it's simplest to move this input validation into the virtio-fs-specific file system implementation instead of generic libfuse.  My hope was that cheap sanity checks would be useful because they protect all file system implementations and anyone porting FUSE to other platforms or new usecases (like virtio-fs!) will benefit.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,344,2019-01-22T11:34:45Z,2019-02-26T17:52:27Z,2019-02-26T17:53:00Z,CLOSED,False,63,7,3,https://github.com/stefanha,fuse_lowlevel: validate path components,1,['needs-info'],https://github.com/libfuse/libfuse/pull/344,https://github.com/stefanha,5,https://github.com/libfuse/libfuse/pull/344#issuecomment-467542907,"Several FUSE requests contain single path components.  A correct FUSE
client sends well-formed path components but there is currently no input
validation in fuse_lowlevel.c in case something went wrong.
File system implementations might accidentally treat invalid inputs as
absolute/relative paths instead of rejecting them.  Save implementations
from duplicating input validation by handling it in fuse_lowlevel.c.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",Having thought about it more I've closed this pull request and we'll do the sanity checking in the file system instead.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,345,2019-01-22T16:16:29Z,2019-01-22T20:03:01Z,2019-01-22T20:03:01Z,MERGED,True,5,0,1,https://github.com/szmi,passthrough_ll: lo_create() should honor CACHE_NEVER,1,[],https://github.com/libfuse/libfuse/pull/345,https://github.com/szmi,1,https://github.com/libfuse/libfuse/pull/345,"lo_create() did not honour CACHE_NEVER in lo_create(), which has an effect
on how I/O is performed after the open.
The value of CACHE_ALWAYS, which results in setting fi->keep_cache, only
has an effect for the state of the cache at open, and since the file was
just created the cache is always empty.  Hence setting this doesn't have an
effect on lo_create(), but keep it for symmetry with lo_open().","lo_create() did not honour CACHE_NEVER in lo_create(), which has an effect
on how I/O is performed after the open.
The value of CACHE_ALWAYS, which results in setting fi->keep_cache, only
has an effect for the state of the cache at open, and since the file was
just created the cache is always empty.  Hence setting this doesn't have an
effect on lo_create(), but keep it for symmetry with lo_open().",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/kivikakk,1,https://github.com/libfuse/libfuse/pull/346,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/trapexit,2,https://github.com/libfuse/libfuse/pull/346#issuecomment-457064928,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","I might be missing something but wouldn't just passing the nodeid through the API be a better design? Allowing the user to treat it as a key into whatever data store they wish thereby keeping the API simpler? Or does the existing high level API not provide callbacks sufficient for the management of the life of the objects?
Then again you could just use the fusepath as a key though not as nice.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/kivikakk,3,https://github.com/libfuse/libfuse/pull/346#issuecomment-457068866,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","I might be missing something but wouldn't just passing the nodeid through the API be a better design?

For my purposes at least, both the nodeid and the parent nodeid are required. One caveat: the nodeid for the target itself often doesn't exist at the point of time of calling into the fs.
For instance, take mknod. fuse_lib_mknod calls fuse_fs_mknod, and only if it succeeds does it then call lookup_path, causing the creation of the underlying struct node. The API in this PR is designed to be called once you know the target exists (i.e. you wouldn't call fuse_set_context_node_userdata until you knew for sure you were returning 0). If we passed the nodeid into the fs's op function, it implies we already created the struct node, even if the fs op might fail and not do anything.

Or does the existing high level API not provide callbacks sufficient for the management of the life of the objects?

Indeed, I don't think there is (again, unless I've missed something obvious). But we could add a callback in free_node (or wherever) to let that happen. It does mean the user code would be duplicating the node hash table, but it would be a smaller change to FUSE.

Then again you could just use the fusepath as a key though not as nice.

Which path exactly do you mean by ""fusepath""? A big benefit of storing this data against the node is that the reference is maintained in the face of renames -- of the node itself, or of any of its parents.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/kivikakk,4,https://github.com/libfuse/libfuse/pull/346#issuecomment-459232293,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","In 7d0336a I've changed the API from:
void *fuse_get_context_node_userdata(int parent);
pthread_mutex_t *fuse_get_context_node_userdata_lock(int parent);
int fuse_set_context_node_userdata(int parent, void *data, void (*finalize)(void *));
To:
struct fuse_node_userdata {
	void *data;
	void (*finalize)(void *);
};

struct fuse_node_userdata *fuse_context_node_userdata_acquire(int parent);
struct fuse_node_userdata *fuse_context_node_userdata_timedacquire(
		int parent, const struct timespec *restrict abs_timeout);
int fuse_context_node_userdata_release(int parent);
This has simplified code in both the FUSE and client side.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/346#issuecomment-459742592,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","Interesting idea. Not yet sure what I think about it.
One thing that would definitely have to change in order for this to go in is that we need to clearly document what a ""node"" is, when it is created, destroyed, whether it's mutable, etc. It's bad enough that the term is used all over the code internally, but we can no longer get away with that once it's part of the public API. Clearly writing this down may also expose potential issues with this idea, so I think this would be a good next step.
(I have this hunch that if you need something like a node, you be actually be better of using the low-level API)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/kivikakk,6,https://github.com/libfuse/libfuse/pull/346#issuecomment-460124927,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","Clearly writing this down may also expose potential issues with this idea, so I think this would be a good next step.

I think this is an excellent next step. The properties of a node and how it can be expected to behave are currently implicit in the operations the various library functions do to them (seen most clearly in rename) -- making it explicit should be helpful.

(I have this hunch that if you need something like a node, you be actually be better of using the low-level API)

I had initially started on using the low-level API, but 95% of what we need is in the high-level API, and I didn't really want to copy fuse.c into my codebase, instead seeing about implementing what I needed as a patch to FUSE instead. I was inspired by the following mailing list post from @mrvn:

The fuse kernel interface works on inodes and the low level interface reflects this. The high level interface works on paths and has to translate between inodes and path. That takes memory and cpu to do.
BUT, what would be the point of using the low level interface if you then need to translate those inode numbers to paths yourself? Do you think you can translate them faster using less resources? Less bugs?
IMHO the low level interface is best when implementing an actual filesystem based on inodes where you don't do any mapping from inode to path.
For all the pass through filesystems that translate fuse operations to operations of an underlying filesystem (e.g. unionfs-fuse) the highlevel interface is far better suited.

As what I'm working on is a passthrough filesystem at its core, the argument is persuasive.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/346#issuecomment-460793069,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","For all the pass through filesystems that translate fuse operations to operations of an underlying filesystem (e.g. unionfs-fuse) the highlevel interface is far better suited.

As what I'm working on is a passthrough filesystem at its core, the argument is persuasive.

Actually, making a truly standard-conforming passthrough filesystem is rather hard (potentially even impossible) with the high-level API. The combination correctly handling hard links and removal of files while they are still open is very difficult to encapsulate in a path-based API. You may want to take a look at the example passthrough_ll filesystem.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/kivikakk,8,https://github.com/libfuse/libfuse/pull/346#issuecomment-460862845,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","Indeed, we started out with using the low-level API, but with a bunch of TODOs for things like path (re)construction, cache eviction, proper synchronisation, etc. The high-level API provides all these things battle-tested and, at thousands of LoC, isn't something I'm keen to reimplement.
Our filesystem's use case (Linux implementation of VFS for Git) doesn't need to handle hard links -- git doesn't support them at all. In short, we don't need to be 100% standard conforming, since we only need to support the operations that make sense for a git working tree.
As for removing files while they're still open, that is indeed tricky, and the work the high-level API does here (with node hiding) is helpful, and (I believe) sufficient for our uses. Am I missing something about the downsides of how the high-level API works here? (put another way: what would a better implementation look like?)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/trapexit,9,https://github.com/libfuse/libfuse/pull/346#issuecomment-460864942,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","The node hiding behavior in the high level API could be more flexible. Having a dedicated ""hide"" callback would give more control to the user. Some of the misc issues with the high level API IMO is the result of trying to hide too much from the user.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,346,2019-01-24T04:11:27Z,2019-02-11T00:32:45Z,2019-02-11T00:32:45Z,CLOSED,False,185,39,6,https://github.com/kivikakk,context node userdata,6,[],https://github.com/libfuse/libfuse/pull/346,https://github.com/kivikakk,10,https://github.com/libfuse/libfuse/pull/346#issuecomment-462196460,"👋 Greetings! I wanted to wave an idea by, and I figure the best way to do so is with code.
This PR shows a feature addition which I'm using in some currently-private code; namely, the ability to add a piece of userdata to a struct node when using the high-level API. There are some awkward edges in the newly introduced API which I'm not happy with, but it's possible I might have missed something obvious.
The motivation to store userdata against struct node is for fast, cache-like access. In my use-case, I'm writing a stacking filesystem which stores information in extended attributes on the lower fs. However, making a call to lgetxattr(2) every time I need to check the metadata would quickly become a bottleneck. Using this API, I cache the attributes against the struct node which the request is executed against. The cache stays attached to the correct node thanks to the high-level API's management of nodes.
One awkward edge is the need for the parent argument. In my use-case, we most often need to check/set the xattrs of the directory containing the target node, rather than the node itself, in order to make decisions about how to handle the request. To facilitate this, we store the fuse_ino_t and any applicable path name component in the struct fuse_context_i when preparing the request. This requires developers to understand how the low-level API works and why, say, readlink doesn't have the parent directory accessible in this API, but mknod does. This could be fixed with some overhead.
The other awkward edge is when there's more than one ""context node"" applicable for a given request. This is seen clearly in rename and copy_file_range. This doesn't affect my work as we only need to access the node userdata in a select number of operations, but does affect the generality of the API.
Do you have any thoughts about this kind of API or how to make it cleaner? Do you think something similar to this might be accepted into FUSE, or is it totally outside your design vision? I decided to try this path first to see if there's something general that might be useful to more than just me, but if we can't make it work, I might just need to copy the high-level API fuse.c into my own project with modifications.
Thanks for your time!","We've decided for now to go in a different direction that doesn't necessitate this kind of metadata (or reification of struct node), so I'm closing the PR.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,347,2019-01-24T10:01:18Z,2019-03-09T10:39:33Z,2019-03-09T10:39:33Z,MERGED,True,3,0,2,https://github.com/1c7718e7,Add HFS+ to filesystem whitelist,1,[],https://github.com/libfuse/libfuse/pull/347,https://github.com/1c7718e7,1,https://github.com/libfuse/libfuse/pull/347,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,354,2019-02-06T05:02:23Z,2019-03-09T11:05:18Z,2019-03-12T23:45:24Z,CLOSED,False,12,3,3,https://github.com/kivikakk,add option to disable symbol versioning,1,[],https://github.com/libfuse/libfuse/pull/354,https://github.com/kivikakk,1,https://github.com/libfuse/libfuse/pull/354,"I found that when building libfuse as a static library (meson configure --default-library static), I invariably hit errors like this when trying to use it:
libtool: link:  gcc -shared  -fPIC -DPIC  .libs/projfs.o .libs/projfs_vfsapi.o   -lfuse3 -ldl -lpthread  -g -O2   -Wl,-soname -Wl,libprojfs.so.0 -Wl,-version-script -Wl,.libs/libprojfs.ver -o .libs/libprojfs.so.0.0.0
/usr/bin/ld: .libs/libprojfs.so.0.0.0: version node not found for symbol fuse_loop_mt@@FUSE_3.2
/usr/bin/ld: failed to set dynamic section sizes: Bad value
collect2: error: ld returned 1 exit status

This is without adjusting the calling code at all. Indeed, even if I drop all calls to fuse_loop_mt in the calling code, this still happens, so I guess some versioning weirdness left inside libfuse.a is producing this when linking.
Disabling symbol versioning with the option in this PR gets things moving, though I have to a) not build examples, as invalidate_path won't build like this (undefined reference to fuse_new), and b) use names like fuse_new_31 and fuse_loop_mt_32 in the calling code.
I'm probably missing something big re: symbol versioning and static linkage, but it's all pretty new to me. I'm submitting this PR in case it might be something useful to have anyway. Feel free to close quickly if you don't care for it.","I found that when building libfuse as a static library (meson configure --default-library static), I invariably hit errors like this when trying to use it:
libtool: link:  gcc -shared  -fPIC -DPIC  .libs/projfs.o .libs/projfs_vfsapi.o   -lfuse3 -ldl -lpthread  -g -O2   -Wl,-soname -Wl,libprojfs.so.0 -Wl,-version-script -Wl,.libs/libprojfs.ver -o .libs/libprojfs.so.0.0.0
/usr/bin/ld: .libs/libprojfs.so.0.0.0: version node not found for symbol fuse_loop_mt@@FUSE_3.2
/usr/bin/ld: failed to set dynamic section sizes: Bad value
collect2: error: ld returned 1 exit status

This is without adjusting the calling code at all. Indeed, even if I drop all calls to fuse_loop_mt in the calling code, this still happens, so I guess some versioning weirdness left inside libfuse.a is producing this when linking.
Disabling symbol versioning with the option in this PR gets things moving, though I have to a) not build examples, as invalidate_path won't build like this (undefined reference to fuse_new), and b) use names like fuse_new_31 and fuse_loop_mt_32 in the calling code.
I'm probably missing something big re: symbol versioning and static linkage, but it's all pretty new to me. I'm submitting this PR in case it might be something useful to have anyway. Feel free to close quickly if you don't care for it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,354,2019-02-06T05:02:23Z,2019-03-09T11:05:18Z,2019-03-12T23:45:24Z,CLOSED,False,12,3,3,https://github.com/kivikakk,add option to disable symbol versioning,1,[],https://github.com/libfuse/libfuse/pull/354,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/354#issuecomment-471167496,"I found that when building libfuse as a static library (meson configure --default-library static), I invariably hit errors like this when trying to use it:
libtool: link:  gcc -shared  -fPIC -DPIC  .libs/projfs.o .libs/projfs_vfsapi.o   -lfuse3 -ldl -lpthread  -g -O2   -Wl,-soname -Wl,libprojfs.so.0 -Wl,-version-script -Wl,.libs/libprojfs.ver -o .libs/libprojfs.so.0.0.0
/usr/bin/ld: .libs/libprojfs.so.0.0.0: version node not found for symbol fuse_loop_mt@@FUSE_3.2
/usr/bin/ld: failed to set dynamic section sizes: Bad value
collect2: error: ld returned 1 exit status

This is without adjusting the calling code at all. Indeed, even if I drop all calls to fuse_loop_mt in the calling code, this still happens, so I guess some versioning weirdness left inside libfuse.a is producing this when linking.
Disabling symbol versioning with the option in this PR gets things moving, though I have to a) not build examples, as invalidate_path won't build like this (undefined reference to fuse_new), and b) use names like fuse_new_31 and fuse_loop_mt_32 in the calling code.
I'm probably missing something big re: symbol versioning and static linkage, but it's all pretty new to me. I'm submitting this PR in case it might be something useful to have anyway. Feel free to close quickly if you don't care for it.","Thanks for reporting this! I don't understand this fully myself, but I believe that (1) you are right, something is wrong here and (2) disabling versioning is not the right solution.
I'll therefore close this pull request, but it would be great if you could report the problems as bug. Maybe someone else has an idea, and if not, at least it's documented together with a workaround.
Thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,354,2019-02-06T05:02:23Z,2019-03-09T11:05:18Z,2019-03-12T23:45:24Z,CLOSED,False,12,3,3,https://github.com/kivikakk,add option to disable symbol versioning,1,[],https://github.com/libfuse/libfuse/pull/354,https://github.com/kivikakk,3,https://github.com/libfuse/libfuse/pull/354#issuecomment-472223800,"I found that when building libfuse as a static library (meson configure --default-library static), I invariably hit errors like this when trying to use it:
libtool: link:  gcc -shared  -fPIC -DPIC  .libs/projfs.o .libs/projfs_vfsapi.o   -lfuse3 -ldl -lpthread  -g -O2   -Wl,-soname -Wl,libprojfs.so.0 -Wl,-version-script -Wl,.libs/libprojfs.ver -o .libs/libprojfs.so.0.0.0
/usr/bin/ld: .libs/libprojfs.so.0.0.0: version node not found for symbol fuse_loop_mt@@FUSE_3.2
/usr/bin/ld: failed to set dynamic section sizes: Bad value
collect2: error: ld returned 1 exit status

This is without adjusting the calling code at all. Indeed, even if I drop all calls to fuse_loop_mt in the calling code, this still happens, so I guess some versioning weirdness left inside libfuse.a is producing this when linking.
Disabling symbol versioning with the option in this PR gets things moving, though I have to a) not build examples, as invalidate_path won't build like this (undefined reference to fuse_new), and b) use names like fuse_new_31 and fuse_loop_mt_32 in the calling code.
I'm probably missing something big re: symbol versioning and static linkage, but it's all pretty new to me. I'm submitting this PR in case it might be something useful to have anyway. Feel free to close quickly if you don't care for it.","Thanks, done!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,1,https://github.com/libfuse/libfuse/pull/356,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/356#issuecomment-462260542,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~",Thanks! Where does the magic number of 1280 come from? The error message sounds more like an off-by-one error...,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,3,https://github.com/libfuse/libfuse/pull/356#issuecomment-462283239,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","It doesn't have to be 1280, but I just aligned with 256 since the original size was 1024.
It can be anything as long as it's larger than potential end result of ""%s/%s"" that the compiler can find on compile time.
Basically, the first ""%s"" is from 1024 bytes buffer if you look at callers, hence whatever comes for ""/%s"" could potentially exceed the existing 1024 bytes destination buffer size, and that's what compiler is warning. Most of the C strings for the second ""%s"" aren't that long, so 1280 is more than enough, but 1024 or 1025 is not.
The warning I pasted in the commit message is just one example. There are huge number of these from PATH()/PATH2() macros. All the PATH()/PATH2() calls are generating this warning, plus a few more from other places which I fixed also.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/356#issuecomment-462488341,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","Ah, I see. I think in that case the proper solution is to use PATH_MAX rather than an arbitrary value. What do you think?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,5,https://github.com/libfuse/libfuse/pull/356#issuecomment-462595493,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","OK, I'll re-PR with PATH_MAX.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,6,https://github.com/libfuse/libfuse/pull/356#issuecomment-462623194,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","Actually, PATH_MAX value is platform specific, so using it as a size relative to hard coded buffer size (1024) doesn't always work.
http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html
e.g. PATH_MAX is 4096 on Linux, but not on *BSD.
[root@ tmp]# uname -r
11.2-RELEASE
[root@ tmp]# cat ./test1.c
#include <stdio.h>
#include <limits.h>

int main(void) {
        printf(""%d\n"", PATH_MAX);
        return 0;
}
[root@ tmp]# clang -Wall -g ./test1.c
[root@ tmp]# ./a.out
1024",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/356#issuecomment-462918977,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","I'm sorry, I don't follow. Yes, PATH_MAX is platform specific. Why is that a problem? It will still be the maximum length of the constructed path. I'm not sure what you mean with ""relative to hard coded buffer size"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,8,https://github.com/libfuse/libfuse/pull/356#issuecomment-462921337,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","If I change my 1280 to PATH_MAX, it equals changing 1280 to 1024 on *BSD, hence nothing has changed from what we have now on *BSD or possibly some other platforms. gcc still complains in the same way that it did before on those platforms....
The point is that the source buffer for the first ""%s"" is 1024.
gcc is complaining on possible truncation (snprintf case) or overflow (sprintf case) when we store the source string plus some C string literals (in ""%s/%s"" format), given the destination buffer is also 1024. The destination buffer needs to be something that compiler can statically determine truncation or overflow does not happen.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/356#issuecomment-462924249,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","Having a destination buffer larger than PATH_MAX doesn't make sense, since using it would give errors later on. If that gives a compiler warning, then the warning is spurious and we should find a way to suppress it without changing the semantics of the code. Does GCC have something like pragmas?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,10,https://github.com/libfuse/libfuse/pull/356#issuecomment-462926137,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","It's not about runtime correctness on filesystem semantics.
It's just to silence compiler. This is something that recent versions of gcc complains. gcc is warning on whatever it can statically find without knowing filesystem semantics.
If you don't want to change it, I'm okay with that too. I'm just sending it as there are more than 30 of these.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/Nikratio,11,https://github.com/libfuse/libfuse/pull/356#issuecomment-462929700,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","I think we are in agreement that the compiler should be silenced. However, doing this by replacing 1024 with some higher value at the same time also changes the runtime semantics, and not in the right direction. If you can find a way to preserve the runtime semantics but silence the warning, that's fine with me.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,12,https://github.com/libfuse/libfuse/pull/356#issuecomment-462931920,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","If we want to use PATH_MAX (which is fine of course), the source buffer size in this code was supposed to be something based on PATH_MAX.
The real problem is not what the diff is doing, but rather the fact that the source buffer already had 1024. My diff and gcc warnings are both based on that.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/kusumi,13,https://github.com/libfuse/libfuse/pull/356#issuecomment-462936772,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","However, doing this by replacing 1024 with some higher value at the same time also changes the _runtime semantics_
Not really. Not changing destination buffer size (1024) to higher value is changing runtime semnantics, because that can cause potential truncation for snprintf(3), and overflow for sprintf(3), which is exactly what the compiler is warning...
Well, not a big deal as we most likely never have that long path in this case. Feel free to close it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,356,2019-02-11T06:26:45Z,2019-03-09T10:39:03Z,2019-03-09T10:39:03Z,MERGED,True,5,5,1,https://github.com/kusumi,Silence -Wformat-truncation=/-Wformat-overflow= warnings,1,['needs-info'],https://github.com/libfuse/libfuse/pull/356,https://github.com/Nikratio,14,https://github.com/libfuse/libfuse/pull/356#issuecomment-471165829,"sprintf(3)/snprintf(3) destination buffers need to be large enough
so that gcc doesn't warn -Wformat-truncation= or -Wformat-overflow=
when source buffer size is 1024 bytes.
../test/test_syscalls.c:1445:47: warning: '%s' directive output may be truncated writing 1 byte into a region of size between 0 and 1023 [-Wformat-truncation=]
 #define PATH(p)  (snprintf(path, sizeof path, ""%s/%s"", testdir, p), path)
                                               ^~~~~~~
../test/test_syscalls.c:1458:19:
  res = mkdir(PATH(""a""), 0755);
                   ~~~","Well, I guess one magic number isn't better than the other, and if it does silence the warnings...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,359,2019-02-13T01:39:35Z,2019-02-13T09:42:16Z,2019-02-13T09:42:20Z,MERGED,True,1,1,1,https://github.com/hselin,Fixed fuse_free_buf() to check each fuse_buf array element instead of…,1,[],https://github.com/libfuse/libfuse/pull/359,https://github.com/hselin,1,https://github.com/libfuse/libfuse/pull/359,Current fuse_free_buf() code always checks buf->buf[0].flags to free buf->buf[i].mem instead of buf->buf[i].flags.,Current fuse_free_buf() code always checks buf->buf[0].flags to free buf->buf[i].mem instead of buf->buf[i].flags.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,359,2019-02-13T01:39:35Z,2019-02-13T09:42:16Z,2019-02-13T09:42:20Z,MERGED,True,1,1,1,https://github.com/hselin,Fixed fuse_free_buf() to check each fuse_buf array element instead of…,1,[],https://github.com/libfuse/libfuse/pull/359,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/359#issuecomment-463129295,Current fuse_free_buf() code always checks buf->buf[0].flags to free buf->buf[i].mem instead of buf->buf[i].flags.,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,363,2019-02-19T02:42:29Z,2019-02-25T21:06:43Z,2019-02-25T21:06:47Z,MERGED,True,7,0,1,https://github.com/Forty-Bot,hello_ll: Fix null pointer dereference,1,[],https://github.com/libfuse/libfuse/pull/363,https://github.com/Forty-Bot,1,https://github.com/libfuse/libfuse/pull/363,"If hello_ll is invoked without a mountpoint, it will try to call
fuse_session_mount anyway with the NULL mountpoint (which then causes a
segfault). Print out a short help message instead (taken from
passthrough_ll.c).","If hello_ll is invoked without a mountpoint, it will try to call
fuse_session_mount anyway with the NULL mountpoint (which then causes a
segfault). Print out a short help message instead (taken from
passthrough_ll.c).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,363,2019-02-19T02:42:29Z,2019-02-25T21:06:43Z,2019-02-25T21:06:47Z,MERGED,True,7,0,1,https://github.com/Forty-Bot,hello_ll: Fix null pointer dereference,1,[],https://github.com/libfuse/libfuse/pull/363,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/363#issuecomment-467183130,"If hello_ll is invoked without a mountpoint, it will try to call
fuse_session_mount anyway with the NULL mountpoint (which then causes a
segfault). Print out a short help message instead (taken from
passthrough_ll.c).",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,371,2019-02-28T05:58:50Z,2019-02-28T08:48:25Z,2019-02-28T08:48:25Z,CLOSED,False,5,2,1,https://github.com/xiaofangzhen,"Fix libfuse3.so.3.4.1 build fail, when modules/iconv.c is built",3,[],https://github.com/libfuse/libfuse/pull/371,https://github.com/xiaofangzhen,1,https://github.com/libfuse/libfuse/pull/371,"when modules/iconv.c is built, libiconv is required ,otherwise Link will fail. Such as :
FAILED: lib/libfuse3.so.3.4.1
-o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/f▽se_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
ninja: build stopped: subcommand failed.","when modules/iconv.c is built, libiconv is required ,otherwise Link will fail. Such as :
FAILED: lib/libfuse3.so.3.4.1
-o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/f▽se_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
ninja: build stopped: subcommand failed.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,372,2019-02-28T09:59:32Z,2019-03-04T09:43:23Z,2019-03-04T09:43:23Z,MERGED,True,5,1,1,https://github.com/xiaofangzhen,Link against libiconv when possible,7,[],https://github.com/libfuse/libfuse/pull/372,https://github.com/xiaofangzhen,1,https://github.com/libfuse/libfuse/pull/372,"When modules/iconv.c is built , linking needs -liconv. otherwise . In some system, <iconv.h> can be found ,but libiconv can not. Other ,there is failure:
FAILED: lib/libfuse3.so.3.4.1
cc  -o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/fuse_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
[42/63] Compiling C object 'example/example@@poll@exe/poll.c.o'.
ninja: build stopped: subcommand failed.","When modules/iconv.c is built , linking needs -liconv. otherwise . In some system, <iconv.h> can be found ,but libiconv can not. Other ,there is failure:
FAILED: lib/libfuse3.so.3.4.1
cc  -o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/fuse_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
[42/63] Compiling C object 'example/example@@poll@exe/poll.c.o'.
ninja: build stopped: subcommand failed.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,372,2019-02-28T09:59:32Z,2019-03-04T09:43:23Z,2019-03-04T09:43:23Z,MERGED,True,5,1,1,https://github.com/xiaofangzhen,Link against libiconv when possible,7,[],https://github.com/libfuse/libfuse/pull/372,https://github.com/xiaofangzhen,2,https://github.com/libfuse/libfuse/pull/372#issuecomment-468556822,"When modules/iconv.c is built , linking needs -liconv. otherwise . In some system, <iconv.h> can be found ,but libiconv can not. Other ,there is failure:
FAILED: lib/libfuse3.so.3.4.1
cc  -o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/fuse_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
[42/63] Compiling C object 'example/example@@poll@exe/poll.c.o'.
ninja: build stopped: subcommand failed.","I have update the meson.build and lib/meson.build. I think the reason of building failure is :
At first ,gcc searches the iconv.h ,and the order of search path is :
gcc version 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC)
COLLECT_GCC_OPTIONS='-v' '-E' '-mtune=generic' '-march=x86-64'
/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/cc1 -E -quiet -v /dev/null -mtune=generic -march=x86-64
ignoring nonexistent directory ""/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include-fixed""
ignoring nonexistent directory ""/usr/lib/gcc/x86_64-redhat-linux/4.8.5/../../../../x86_64-redhat-linux/include""
#include ""..."" search starts here:
#include <...> search starts here:
/usr/lib/gcc/x86_64-redhat-linux/4.8.5/include
/usr/local/include
/usr/include
So, if /usr/local/include/iconv.h exists, it will be searched first. And then is /usr/include/iconv.h.
However, the iconv.h in libc exists in /usr/include/, the iconv.h in libiconv in /usr/local/include/
So the libiconv's header will be searched first , if exists. And in libiconv's header ,there is a define:
69 #ifndef LIBICONV_PLUG
70 #define iconv_open libiconv_open
71 #endif
But , in libc ,the libiconv_open is not defined. So , I think if libiconv exists, it should be linked..",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,372,2019-02-28T09:59:32Z,2019-03-04T09:43:23Z,2019-03-04T09:43:23Z,MERGED,True,5,1,1,https://github.com/xiaofangzhen,Link against libiconv when possible,7,[],https://github.com/libfuse/libfuse/pull/372,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/372#issuecomment-468672630,"When modules/iconv.c is built , linking needs -liconv. otherwise . In some system, <iconv.h> can be found ,but libiconv can not. Other ,there is failure:
FAILED: lib/libfuse3.so.3.4.1
cc  -o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/fuse_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
[42/63] Compiling C object 'example/example@@poll@exe/poll.c.o'.
ninja: build stopped: subcommand failed.","That sounds right. If libiconf exists, it should be linked. Could you update your pull request to implement that?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,372,2019-02-28T09:59:32Z,2019-03-04T09:43:23Z,2019-03-04T09:43:23Z,MERGED,True,5,1,1,https://github.com/xiaofangzhen,Link against libiconv when possible,7,[],https://github.com/libfuse/libfuse/pull/372,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/372#issuecomment-468673240,"When modules/iconv.c is built , linking needs -liconv. otherwise . In some system, <iconv.h> can be found ,but libiconv can not. Other ,there is failure:
FAILED: lib/libfuse3.so.3.4.1
cc  -o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/fuse_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
[42/63] Compiling C object 'example/example@@poll@exe/poll.c.o'.
ninja: build stopped: subcommand failed.","(Currently you are linking against libiconv if HAVE_ICONV is defined and the library exists, but you are not attempting to link when setting HAVE_ICONV - unless that test only compiles without linking?)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,372,2019-02-28T09:59:32Z,2019-03-04T09:43:23Z,2019-03-04T09:43:23Z,MERGED,True,5,1,1,https://github.com/xiaofangzhen,Link against libiconv when possible,7,[],https://github.com/libfuse/libfuse/pull/372,https://github.com/xiaofangzhen,5,https://github.com/libfuse/libfuse/pull/372#issuecomment-469128731,"When modules/iconv.c is built , linking needs -liconv. otherwise . In some system, <iconv.h> can be found ,but libiconv can not. Other ,there is failure:
FAILED: lib/libfuse3.so.3.4.1
cc  -o lib/libfuse3.so.3.4.1 'lib/lib@@fuse3@sha/fuse.c.o' 'lib/lib@@fuse3@sha/fuse_loop.c.o' 'lib/lib@@fuse3@sha/fuse_loop_mt.c.o' 'lib/lib@@fuse3@sha/fuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/fuse_opt.c.o' 'lib/lib@@fuse3@sha/fuse_signals.c.o' 'lib/lib@@fuse3@sha/buffer.c.o' 'lib/lib@@fuse3@sha/cuse_lowlevel.c.o' 'lib/lib@@fuse3@sha/helper.c.o' 'lib/lib@@fuse3@sha/modules_subdir.c.o' 'lib/lib@@fuse3@sha/mount_util.c.o' 'lib/lib@@fuse3@sha/mount.c.o' 'lib/lib@@fuse3@sha/modules_iconv.c.o' -Wl,--no-undefined -Wl,--as-needed -shared -fPIC -Wl,--start-group -Wl,-soname,libfuse3.so.3 -Wl,--version-script,/root/fusermaste/libfuse-master/lib/fuse_versionscript -ldl -lrt -Wl,--end-group -pthread
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_new': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:679: undefined reference to libiconv_open'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:685: undefined reference to libiconv_open' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:704: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:706: undefined reference to libiconv_close' lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_convpath':
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:68: undefined reference to libiconv' /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:96: undefined reference to libiconv'
lib/lib@@fuse3@sha/modules_iconv.c.o: In function iconv_destroy': /root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:571: undefined reference to libiconv_close'
/root/fusermaste/libfuse-master/build/../lib/modules/iconv.c:572: undefined reference to `libiconv_close'
collect2: error: ld returned 1 exit status
[42/63] Compiling C object 'example/example@@poll@exe/poll.c.o'.
ninja: build stopped: subcommand failed.","I have update the pull request.You can merge it. I think complies without linking can do well. Because,if HAVE_ICONV is not set, libiconv should not be linked.  ,If HAVE_ICONV is set ,only if libiconv exist, we could link against it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,374,2019-03-06T18:59:34Z,2019-03-09T09:50:23Z,2019-03-09T09:50:23Z,MERGED,True,1,1,1,https://github.com/asomers,Fix the changelog entry for protocol version 7.12,1,[],https://github.com/libfuse/libfuse/pull/374,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/374,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,374,2019-03-06T18:59:34Z,2019-03-09T09:50:23Z,2019-03-09T09:50:23Z,MERGED,True,1,1,1,https://github.com/asomers,Fix the changelog entry for protocol version 7.12,1,[],https://github.com/libfuse/libfuse/pull/374,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/374#issuecomment-471080812,,"Thanks! For the commit message, could you provide a reference for this? E.g. a link to the CL that added the flag? Otherwise it's hard to confirm that the new version is correct...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,374,2019-03-06T18:59:34Z,2019-03-09T09:50:23Z,2019-03-09T09:50:23Z,MERGED,True,1,1,1,https://github.com/asomers,Fix the changelog entry for protocol version 7.12,1,[],https://github.com/libfuse/libfuse/pull/374,https://github.com/asomers,3,https://github.com/libfuse/libfuse/pull/374#issuecomment-471108650,,Looks like the build failure is unrelated.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,375,2019-03-07T17:30:34Z,2019-03-08T21:24:51Z,2019-03-08T21:41:20Z,MERGED,True,27,24,7,https://github.com/asomers,Document fuse_fsync_in.fsync_flags and remove magic numbers,1,[],https://github.com/libfuse/libfuse/pull/375,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/375,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,375,2019-03-07T17:30:34Z,2019-03-08T21:24:51Z,2019-03-08T21:41:20Z,MERGED,True,27,24,7,https://github.com/asomers,Document fuse_fsync_in.fsync_flags and remove magic numbers,1,[],https://github.com/libfuse/libfuse/pull/375,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/375#issuecomment-471081209,,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,377,2019-03-07T19:48:52Z,2019-03-08T21:26:32Z,2019-03-08T21:26:38Z,MERGED,True,2,0,1,https://github.com/samh-sifive,Bugfix: unmount FUSE filesystems reliably on NFS,1,[],https://github.com/libfuse/libfuse/pull/377,https://github.com/samh-sifive,1,https://github.com/libfuse/libfuse/pull/377,"When an NFS directory is reachable by the user, but not by root (e.g. squash_root is set and the intermediate directories are not world readable) it is possible to mount, but not unmount a FUSE filesystem.
The problem is that fusermount -u attempts to enter the parent directory as root when unmounting the filesystem. By changing the parent directory as the user, and only then switching to root, we can traverse the root-unreadable intermediate directories. This makes the FUSE unmount behavior symmetric with mount.
Fixes #376","When an NFS directory is reachable by the user, but not by root (e.g. squash_root is set and the intermediate directories are not world readable) it is possible to mount, but not unmount a FUSE filesystem.
The problem is that fusermount -u attempts to enter the parent directory as root when unmounting the filesystem. By changing the parent directory as the user, and only then switching to root, we can traverse the root-unreadable intermediate directories. This makes the FUSE unmount behavior symmetric with mount.
Fixes #376",True,{'THUMBS_UP': ['https://github.com/terpstra']}
libfuse/libfuse,https://github.com/libfuse/libfuse,377,2019-03-07T19:48:52Z,2019-03-08T21:26:32Z,2019-03-08T21:26:38Z,MERGED,True,2,0,1,https://github.com/samh-sifive,Bugfix: unmount FUSE filesystems reliably on NFS,1,[],https://github.com/libfuse/libfuse/pull/377,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/377#issuecomment-471081665,"When an NFS directory is reachable by the user, but not by root (e.g. squash_root is set and the intermediate directories are not world readable) it is possible to mount, but not unmount a FUSE filesystem.
The problem is that fusermount -u attempts to enter the parent directory as root when unmounting the filesystem. By changing the parent directory as the user, and only then switching to root, we can traverse the root-unreadable intermediate directories. This makes the FUSE unmount behavior symmetric with mount.
Fixes #376",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,378,2019-03-08T23:10:12Z,2019-03-10T19:35:31Z,2019-03-10T19:35:31Z,MERGED,True,26,15,2,https://github.com/asomers,Improve documentation for the flush method,3,[],https://github.com/libfuse/libfuse/pull/378,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/378,Fixes #373,Fixes #373,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,379,2019-03-09T20:41:29Z,2019-03-11T17:32:46Z,2019-03-11T17:32:46Z,MERGED,True,4,0,1,https://github.com/maxice8,Define ALLPERMS for musl libc systems.,1,[],https://github.com/libfuse/libfuse/pull/379,https://github.com/maxice8,1,https://github.com/libfuse/libfuse/pull/379,Like Void Linux musl and Alpine Linux,Like Void Linux musl and Alpine Linux,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,380,2019-03-10T08:47:28Z,2019-03-10T11:13:14Z,2019-03-10T11:13:14Z,CLOSED,False,9,3,2,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int,1,[],https://github.com/libfuse/libfuse/pull/380,https://github.com/jpandre,1,https://github.com/libfuse/libfuse/pull/380,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.","On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,381,2019-03-10T11:19:00Z,2019-03-11T17:35:24Z,2019-03-11T17:35:24Z,MERGED,True,24,12,5,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int (v2),1,[],https://github.com/libfuse/libfuse/pull/381,https://github.com/jpandre,1,https://github.com/libfuse/libfuse/pull/381,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.","On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,381,2019-03-10T11:19:00Z,2019-03-11T17:35:24Z,2019-03-11T17:35:24Z,MERGED,True,24,12,5,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int (v2),1,[],https://github.com/libfuse/libfuse/pull/381,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/381#issuecomment-471336746,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.","Thanks! Could you please also describe the change in Changes.rst, so that people who are using ioctl() know what to do?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,381,2019-03-10T11:19:00Z,2019-03-11T17:35:24Z,2019-03-11T17:35:24Z,MERGED,True,24,12,5,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int (v2),1,[],https://github.com/libfuse/libfuse/pull/381,https://github.com/trapexit,3,https://github.com/libfuse/libfuse/pull/381#issuecomment-471337495,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.",And squash the commits?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,381,2019-03-10T11:19:00Z,2019-03-11T17:35:24Z,2019-03-11T17:35:24Z,MERGED,True,24,12,5,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int (v2),1,[],https://github.com/libfuse/libfuse/pull/381,https://github.com/trapexit,4,https://github.com/libfuse/libfuse/pull/381#issuecomment-471488040,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.",You don't need to close PRs. Just overwrite your branch and the PR will get updated.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,381,2019-03-10T11:19:00Z,2019-03-11T17:35:24Z,2019-03-11T17:35:24Z,MERGED,True,24,12,5,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int (v2),1,[],https://github.com/libfuse/libfuse/pull/381,https://github.com/jpandre,5,https://github.com/libfuse/libfuse/pull/381#issuecomment-471494964,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.","I do not know why it got closed...
How should I overwrite my branch ? It is already pushed.

trapexit wrote:
…

 You don't need to close PRs. Just overwrite your branch and the PR
 will get updated.

 —
 You are receiving this because you modified the open/close state.
 Reply to this email directly, view it on GitHub
 <#381 (comment)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/ACF8xg6i6YqwFQQoviRUQphAcp-OXUR0ks5vVjIPgaJpZM4bnNE5>.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,381,2019-03-10T11:19:00Z,2019-03-11T17:35:24Z,2019-03-11T17:35:24Z,MERGED,True,24,12,5,https://github.com/jpandre,Defined the (*ioctl)() commands as unsigned int (v2),1,[],https://github.com/libfuse/libfuse/pull/381,https://github.com/trapexit,6,https://github.com/libfuse/libfuse/pull/381#issuecomment-471497361,"On Linux the ioctl() commands are requested as ""unsigned long"", but fuse
truncates them to 32 bits. Transmitting the commands to user space
file systems as ""unsigned int"" is a workaround for processing ioctl
commands which do not fit into a signed int.",You already did by force pushing the branch. That's what push -f does.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,384,2019-03-13T10:08:07Z,2019-06-13T11:59:10Z,2019-06-13T11:59:11Z,MERGED,True,33,9,3,https://github.com/scosu,RFC: max_pages support implementation,1,[],https://github.com/libfuse/libfuse/pull/384,https://github.com/scosu,1,https://github.com/libfuse/libfuse/pull/384,"Hi,
implementation for libfuse of the 4.20 max_pages feature. In this implementation I am coupling it to the max_write parameter. By default the max_pages will be at the maximum on kernels >= 4.20 and at 32 for < 4.20.
Best,
Markus","Hi,
implementation for libfuse of the 4.20 max_pages feature. In this implementation I am coupling it to the max_write parameter. By default the max_pages will be at the maximum on kernels >= 4.20 and at 32 for < 4.20.
Best,
Markus",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,384,2019-03-13T10:08:07Z,2019-06-13T11:59:10Z,2019-06-13T11:59:11Z,MERGED,True,33,9,3,https://github.com/scosu,RFC: max_pages support implementation,1,[],https://github.com/libfuse/libfuse/pull/384,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/384#issuecomment-483796196,"Hi,
implementation for libfuse of the 4.20 max_pages feature. In this implementation I am coupling it to the max_write parameter. By default the max_pages will be at the maximum on kernels >= 4.20 and at 32 for < 4.20.
Best,
Markus","Apologies for the delay, and thanks for the patch! Could you please:

rebase on current master?
confirm that fuse_kernel.h matches the kernel headers exactly (or you changes will get lost on the next sync)
add a ChangeLog entry",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,384,2019-03-13T10:08:07Z,2019-06-13T11:59:10Z,2019-06-13T11:59:11Z,MERGED,True,33,9,3,https://github.com/scosu,RFC: max_pages support implementation,1,[],https://github.com/libfuse/libfuse/pull/384,https://github.com/scosu,3,https://github.com/libfuse/libfuse/pull/384#issuecomment-491748139,"Hi,
implementation for libfuse of the 4.20 max_pages feature. In this implementation I am coupling it to the max_write parameter. By default the max_pages will be at the maximum on kernels >= 4.20 and at 32 for < 4.20.
Best,
Markus","sorry for the delay, but I finally updated this patch.
I removed the header synchronization patch as it didn't contain anything significant and added a ChangeLog entry.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/chadaustin,1,https://github.com/libfuse/libfuse/pull/391,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.","Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/chadaustin,2,https://github.com/libfuse/libfuse/pull/391#issuecomment-479247983,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.","The relevant kernel commits are:
torvalds/linux@d9a9ea9
torvalds/linux@fabf7e0",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/391#issuecomment-479598912,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.","Thanks, this is great! Could you please also add a definition of FUSE_CAP_NO_OPENDIR_SUPPORT to the header files and add an entry to ChangeLog.rst?",True,{'THUMBS_UP': ['https://github.com/chadaustin']}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/chadaustin,4,https://github.com/libfuse/libfuse/pull/391#issuecomment-480962553,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.","I think I touched all the right places. :)
Note that the kernel now has a handful of flags that aren't currently documented in libfuse: https://github.com/torvalds/linux/blob/master/include/uapi/linux/fuse.h
Specifically FUSE_ABORT_ERROR, FUSE_MAX_PAGES, and, perhaps most interestingly, FUSE_CACHE_SYMLINKS.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/chadaustin,5,https://github.com/libfuse/libfuse/pull/391#issuecomment-480963041,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.","Ah, I see the build failure. Should I add an ifdef to libfuse? Is it expected people will recompile libfuse when upgrading kernels?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/391#issuecomment-480987076,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.","No, you need to sync up include/fuse_kernel.h with the kernel headers (cf. 4ae58ff). In this case, re-basing to current master may already fix the issue.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,391,2019-04-02T23:12:13Z,2019-04-16T18:45:00Z,2019-04-16T18:45:00Z,MERGED,True,24,0,5,https://github.com/chadaustin,Add documentation for opting out of opendir and releasedir,1,[],https://github.com/libfuse/libfuse/pull/391,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/391#issuecomment-483796697,"Add documentation for kernel 5.1's opendir/releasedir opt-out behavior, which also implies readdir caching.",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,392,2019-04-03T09:30:52Z,2019-04-03T20:43:48Z,2019-04-03T20:43:48Z,MERGED,True,7,4,2,https://github.com/lemenkov,Whitelist smb2,3,[],https://github.com/libfuse/libfuse/pull/392,https://github.com/lemenkov,1,https://github.com/libfuse/libfuse/pull/392,"Whitelist SMB2 found on some NAS devices. We have CIFS whitelisted already, so let's allow next-gen CIFS as well.
Also I've sorted out allowed filesystems alphabetically.","Whitelist SMB2 found on some NAS devices. We have CIFS whitelisted already, so let's allow next-gen CIFS as well.
Also I've sorted out allowed filesystems alphabetically.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,392,2019-04-03T09:30:52Z,2019-04-03T20:43:48Z,2019-04-03T20:43:48Z,MERGED,True,7,4,2,https://github.com/lemenkov,Whitelist smb2,3,[],https://github.com/libfuse/libfuse/pull/392,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/392#issuecomment-479599112,"Whitelist SMB2 found on some NAS devices. We have CIFS whitelisted already, so let's allow next-gen CIFS as well.
Also I've sorted out allowed filesystems alphabetically.",Thanks! Could you please add an entry to ChangeLog.rst?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,392,2019-04-03T09:30:52Z,2019-04-03T20:43:48Z,2019-04-03T20:43:48Z,MERGED,True,7,4,2,https://github.com/lemenkov,Whitelist smb2,3,[],https://github.com/libfuse/libfuse/pull/392,https://github.com/lemenkov,3,https://github.com/libfuse/libfuse/pull/392#issuecomment-479641379,"Whitelist SMB2 found on some NAS devices. We have CIFS whitelisted already, so let's allow next-gen CIFS as well.
Also I've sorted out allowed filesystems alphabetically.","Thanks! Could you please add an entry to ChangeLog.rst?

Done.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/393,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.","Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/jpandre,2,https://github.com/libfuse/libfuse/pull/393#issuecomment-480035121,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.","Replacing ""Thread ID of the calling process"" by ""Process ID of the calling process"" hides the fact that the pid identifies a thread in a multi-thread process. I would rather suggest ""Process ID of the calling thread"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/asomers,3,https://github.com/libfuse/libfuse/pull/393#issuecomment-480035495,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.","""Process ID of the calling thread"" sounds good.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/393#issuecomment-480518418,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.","I'm short on discussion time at the moment, so I've just merged the non-controversial parts for now. Thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/393#issuecomment-483796462,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.",Would you mind rebasing on current master if you have the time?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/393#issuecomment-491968162,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.","Yes, should be fixed now. Sorry about that. Let me know when you want me to take another look!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,393,2019-04-04T18:29:17Z,2019-09-27T18:46:47Z,2019-09-27T18:46:47Z,CLOSED,False,3494,30,12,https://github.com/asomers,More documentation improvements,6,[],https://github.com/libfuse/libfuse/pull/393,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/393#issuecomment-501670167,"Clarify the relationship between file handles and file descriptors, add references to O_EXEC and O_SEARCH, and do some proofreading.","Friendly ping. Do you think further changes are needed here? If so, would you mind rebasing to current master?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,398,2019-04-17T23:24:07Z,2019-04-18T08:55:43Z,2019-04-18T18:40:57Z,MERGED,True,8,1,2,https://github.com/liubogithub,Add fallocate and use it instead of posix_fallocate if possible,1,[],https://github.com/libfuse/libfuse/pull/398,https://github.com/liubogithub,1,https://github.com/libfuse/libfuse/pull/398,"fuse.ko has supported FALLOC_FL_KEEP_SIZE and FALLOC_FL_PUNCH_HOLE at this
moment and more modes may be supported in the future.
fallocate(2) supports modes while posix_fallocate(2) does not, so this
makes lo_fallocate use fallocate(2) instead.
Signed-off-by: Liu Bo bo.liu@linux.alibaba.com","fuse.ko has supported FALLOC_FL_KEEP_SIZE and FALLOC_FL_PUNCH_HOLE at this
moment and more modes may be supported in the future.
fallocate(2) supports modes while posix_fallocate(2) does not, so this
makes lo_fallocate use fallocate(2) instead.
Signed-off-by: Liu Bo bo.liu@linux.alibaba.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,398,2019-04-17T23:24:07Z,2019-04-18T08:55:43Z,2019-04-18T18:40:57Z,MERGED,True,8,1,2,https://github.com/liubogithub,Add fallocate and use it instead of posix_fallocate if possible,1,[],https://github.com/libfuse/libfuse/pull/398,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/398#issuecomment-484414878,"fuse.ko has supported FALLOC_FL_KEEP_SIZE and FALLOC_FL_PUNCH_HOLE at this
moment and more modes may be supported in the future.
fallocate(2) supports modes while posix_fallocate(2) does not, so this
makes lo_fallocate use fallocate(2) instead.
Signed-off-by: Liu Bo bo.liu@linux.alibaba.com",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,402,2019-04-30T20:07:36Z,2019-09-27T18:50:05Z,2019-09-27T19:05:52Z,CLOSED,False,155,72,3,https://github.com/asomers,Enable passthrough_ll on FreeBSD,4,[],https://github.com/libfuse/libfuse/pull/402,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/402,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,402,2019-04-30T20:07:36Z,2019-09-27T18:50:05Z,2019-09-27T19:05:52Z,CLOSED,False,155,72,3,https://github.com/asomers,Enable passthrough_ll on FreeBSD,4,[],https://github.com/libfuse/libfuse/pull/402,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/402#issuecomment-489449643,,"Is this PR still up-to-date, or are you planning to rewrite as described in issue #407 ?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,402,2019-04-30T20:07:36Z,2019-09-27T18:50:05Z,2019-09-27T19:05:52Z,CLOSED,False,155,72,3,https://github.com/asomers,Enable passthrough_ll on FreeBSD,4,[],https://github.com/libfuse/libfuse/pull/402,https://github.com/asomers,3,https://github.com/libfuse/libfuse/pull/402#issuecomment-489449693,,I'm planning to do #407 first and then rebase this PR.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,402,2019-04-30T20:07:36Z,2019-09-27T18:50:05Z,2019-09-27T19:05:52Z,CLOSED,False,155,72,3,https://github.com/asomers,Enable passthrough_ll on FreeBSD,4,[],https://github.com/libfuse/libfuse/pull/402,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/402#issuecomment-501669853,,Friendly ping. Any update on this? Or should I just close this PR for now?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,402,2019-04-30T20:07:36Z,2019-09-27T18:50:05Z,2019-09-27T19:05:52Z,CLOSED,False,155,72,3,https://github.com/asomers,Enable passthrough_ll on FreeBSD,4,[],https://github.com/libfuse/libfuse/pull/402,https://github.com/asomers,5,https://github.com/libfuse/libfuse/pull/402#issuecomment-536060592,,"Sorry; I got things mostly working but eventually concluded that it's too hard and perhaps impossible to get true passthrough semantics without AT_EMPTY_PATH.  A better example for the low-level API would be to store each FUSE-visible file as two flat files on the underlying file system (one for the inode itself and one for the data), and store FUSE-visible directories in flat files, too.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,402,2019-04-30T20:07:36Z,2019-09-27T18:50:05Z,2019-09-27T19:05:52Z,CLOSED,False,155,72,3,https://github.com/asomers,Enable passthrough_ll on FreeBSD,4,[],https://github.com/libfuse/libfuse/pull/402,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/402#issuecomment-536062084,,"No worries, I appreciate your efforts!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,404,2019-05-01T03:54:44Z,2019-05-01T15:04:27Z,2019-05-01T15:24:54Z,MERGED,True,12,1,2,https://github.com/asomers,Add CI for FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/404,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/404,"This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403","This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,404,2019-05-01T03:54:44Z,2019-05-01T15:04:27Z,2019-05-01T15:24:54Z,MERGED,True,12,1,2,https://github.com/asomers,Add CI for FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/404,https://github.com/asomers,2,https://github.com/libfuse/libfuse/pull/404#issuecomment-488275915,"This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403","I don't know why Cirrus didn't build.  Did you check ""Require approval for builds from users without write permissions"" on the Cirrus config page?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,404,2019-05-01T03:54:44Z,2019-05-01T15:04:27Z,2019-05-01T15:24:54Z,MERGED,True,12,1,2,https://github.com/asomers,Add CI for FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/404,https://github.com/fkorotkov,3,https://github.com/libfuse/libfuse/pull/404#issuecomment-488278647,"This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403",You either need to install Cirrus CI for the organization or enable it for the repository if you hand picked the repositories before.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,404,2019-05-01T03:54:44Z,2019-05-01T15:04:27Z,2019-05-01T15:24:54Z,MERGED,True,12,1,2,https://github.com/asomers,Add CI for FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/404,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/404#issuecomment-488307703,"This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403",I installed it for the organization.,True,{'THUMBS_UP': ['https://github.com/fkorotkov']}
libfuse/libfuse,https://github.com/libfuse/libfuse,404,2019-05-01T03:54:44Z,2019-05-01T15:04:27Z,2019-05-01T15:24:54Z,MERGED,True,12,1,2,https://github.com/asomers,Add CI for FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/404,https://github.com/asomers,5,https://github.com/libfuse/libfuse/pull/404#issuecomment-488309051,"This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403","Well, it's not working.  I don't think you should've merged this PR before it got a successful build.  @fkorotkov do you have any special insights as to why Cirrus isn't building this project?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,404,2019-05-01T03:54:44Z,2019-05-01T15:04:27Z,2019-05-01T15:24:54Z,MERGED,True,12,1,2,https://github.com/asomers,Add CI for FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/404,https://github.com/fkorotkov,6,https://github.com/libfuse/libfuse/pull/404#issuecomment-488311591,"This commit adds builds for FreeBSD using cirrus-ci.  Running the tests
is TODO; they don't work on FreeBSD yet.
Fixes #403",Fixed in #405,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,405,2019-05-01T15:08:22Z,2019-05-01T15:19:11Z,2019-05-01T15:21:24Z,MERGED,True,4,2,1,https://github.com/fkorotkov,Fixed Cirrus Config,1,[],https://github.com/libfuse/libfuse/pull/405,https://github.com/fkorotkov,1,https://github.com/libfuse/libfuse/pull/405,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,405,2019-05-01T15:08:22Z,2019-05-01T15:19:11Z,2019-05-01T15:21:24Z,MERGED,True,4,2,1,https://github.com/fkorotkov,Fixed Cirrus Config,1,[],https://github.com/libfuse/libfuse/pull/405,https://github.com/asomers,2,https://github.com/libfuse/libfuse/pull/405#issuecomment-488312862,,Thanks @fkorotkov !,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,406,2019-05-02T15:20:11Z,2019-05-05T17:35:52Z,2019-05-05T17:35:53Z,CLOSED,False,4,3,1,https://github.com/asomers,Fix compiler warning in cuse_lowlevel.c,1,[],https://github.com/libfuse/libfuse/pull/406,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/406,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,406,2019-05-02T15:20:11Z,2019-05-05T17:35:52Z,2019-05-05T17:35:53Z,CLOSED,False,4,3,1,https://github.com/asomers,Fix compiler warning in cuse_lowlevel.c,1,[],https://github.com/libfuse/libfuse/pull/406,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/406#issuecomment-489447025,,already fixed in master,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,409,2019-05-05T01:06:04Z,2019-05-05T17:36:14Z,2019-05-07T18:40:16Z,MERGED,True,19,0,1,https://github.com/DrDaveD,Add defines for missing SECBITs on older kernels,1,[],https://github.com/libfuse/libfuse/pull/409,https://github.com/DrDaveD,1,https://github.com/libfuse/libfuse/pull/409,"This is needed to compile fuse3 for centos6.
There's also a problem compiling examples because of a missing AT_EMPTY_PATH, but the examples can be skipped.","This is needed to compile fuse3 for centos6.
There's also a problem compiling examples because of a missing AT_EMPTY_PATH, but the examples can be skipped.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,411,2019-05-08T15:52:30Z,2019-05-08T16:15:18Z,2019-05-08T16:15:19Z,CLOSED,False,63,1,4,https://github.com/kevin-vigor,Add support for specifying FUSE_MAX_PAGES at init time.,1,[],https://github.com/libfuse/libfuse/pull/411,https://github.com/kevin-vigor,1,https://github.com/libfuse/libfuse/pull/411,"Support for max_pages is added to fuse_lowlevel.c. Example usage is added to passthrough_ll. A new ""max_pages"" mount option is added to fuse_parse_conn_info_opts().","Support for max_pages is added to fuse_lowlevel.c. Example usage is added to passthrough_ll. A new ""max_pages"" mount option is added to fuse_parse_conn_info_opts().",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,411,2019-05-08T15:52:30Z,2019-05-08T16:15:18Z,2019-05-08T16:15:19Z,CLOSED,False,63,1,4,https://github.com/kevin-vigor,Add support for specifying FUSE_MAX_PAGES at init time.,1,[],https://github.com/libfuse/libfuse/pull/411,https://github.com/kevin-vigor,2,https://github.com/libfuse/libfuse/pull/411#issuecomment-490551446,"Support for max_pages is added to fuse_lowlevel.c. Example usage is added to passthrough_ll. A new ""max_pages"" mount option is added to fuse_parse_conn_info_opts().","Discovered problems with large settings, withdrawing for now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,413,2019-05-09T16:47:40Z,2019-05-15T20:35:57Z,2019-05-15T20:38:55Z,MERGED,True,163,27,5,https://github.com/asomers,passthrough: fix unix-domain sockets on FreeBSD,3,[],https://github.com/libfuse/libfuse/pull/413,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/413,"FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.","FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,413,2019-05-09T16:47:40Z,2019-05-15T20:35:57Z,2019-05-15T20:38:55Z,MERGED,True,163,27,5,https://github.com/asomers,passthrough: fix unix-domain sockets on FreeBSD,3,[],https://github.com/libfuse/libfuse/pull/413,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/413#issuecomment-491969207,"FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.","Thanks, looks good now - except that it broke some of the unit tests (see CI results) - could you take another look? :-)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,413,2019-05-09T16:47:40Z,2019-05-15T20:35:57Z,2019-05-15T20:38:55Z,MERGED,True,163,27,5,https://github.com/asomers,passthrough: fix unix-domain sockets on FreeBSD,3,[],https://github.com/libfuse/libfuse/pull/413,https://github.com/asomers,3,https://github.com/libfuse/libfuse/pull/413#issuecomment-491970440,"FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.",I don't think those tests are related to my changes.  Are you sure that it isn't just an intermittent test?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,413,2019-05-09T16:47:40Z,2019-05-15T20:35:57Z,2019-05-15T20:38:55Z,MERGED,True,163,27,5,https://github.com/asomers,passthrough: fix unix-domain sockets on FreeBSD,3,[],https://github.com/libfuse/libfuse/pull/413,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/413#issuecomment-491979448,"FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.","Quite sure, I've never seen them before and I've just merged a pull request that passed: https://travis-ci.org/libfuse/libfuse",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,413,2019-05-09T16:47:40Z,2019-05-15T20:35:57Z,2019-05-15T20:38:55Z,MERGED,True,163,27,5,https://github.com/asomers,passthrough: fix unix-domain sockets on FreeBSD,3,[],https://github.com/libfuse/libfuse/pull/413,https://github.com/asomers,5,https://github.com/libfuse/libfuse/pull/413#issuecomment-492747922,"FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.","Ok, it took me way too long to find the problem, but it should be fixed now.  BTW, have you considered rewriting the tests?  They'd be much more maintainable with proper testcase isolation.  I've recently done something very similar using Googletest.  Unfortunately, I don't have time to rewrite all of libfuse's tests myself.
https://svnweb.freebsd.org/base/projects/fuse2/tests/sys/fs/fusefs/",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,413,2019-05-09T16:47:40Z,2019-05-15T20:35:57Z,2019-05-15T20:38:55Z,MERGED,True,163,27,5,https://github.com/asomers,passthrough: fix unix-domain sockets on FreeBSD,3,[],https://github.com/libfuse/libfuse/pull/413,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/413#issuecomment-492813318,"FreeBSD doesn't allow creating sockets using mknod(2).  Instead, you
must use socket(2) and bind(2).  Add appropriate logic to
examples/passthrough.cc.  Also, add a test in test_syscalls.c.  In order
to make the test work, I had to shorten the mountpoint that pytest
generates by abbreviating some stuff in test_examples.py.","You mean test_syscalls.c? Yeah, that's high on my ""list of things that should be done"" list, but also very low on my ""list of things that I enjoy doing"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,420,2019-05-23T22:53:06Z,2019-05-24T07:54:43Z,2019-05-24T07:54:43Z,MERGED,True,0,3,1,https://github.com/asomers,Remove incorrect comment about fuse_entry_param.generation,1,[],https://github.com/libfuse/libfuse/pull/420,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/420,"A comment said that fuse_entry_param.generation must be non-zero.
However, I can't find anything in the kernel that requires that, and
real-world file systems don't seem to follow that advice, either.","A comment said that fuse_entry_param.generation must be non-zero.
However, I can't find anything in the kernel that requires that, and
real-world file systems don't seem to follow that advice, either.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,421,2019-05-24T15:40:06Z,2019-07-04T08:01:20Z,2019-07-04T13:28:35Z,MERGED,True,16,9,3,https://github.com/DrDaveD,Skip install parts that require root when not running as root,3,[],https://github.com/libfuse/libfuse/pull/421,https://github.com/DrDaveD,1,https://github.com/libfuse/libfuse/pull/421,"When running as non-root, for example when building a package, skip the parts of the install process that require root.
This takes the place of a patch that the Fedora build of fuse3 was applying.","When running as non-root, for example when building a package, skip the parts of the install process that require root.
This takes the place of a patch that the Fedora build of fuse3 was applying.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,421,2019-05-24T15:40:06Z,2019-07-04T08:01:20Z,2019-07-04T13:28:35Z,MERGED,True,16,9,3,https://github.com/DrDaveD,Skip install parts that require root when not running as root,3,[],https://github.com/libfuse/libfuse/pull/421,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/421#issuecomment-497972820,"When running as non-root, for example when building a package, skip the parts of the install process that require root.
This takes the place of a patch that the Fedora build of fuse3 was applying.","Thanks for the patch! I think fixing this issue is a good idea, but this isn't the right way to do it because it means that if you accidentally run as non-root, you get an incomplete install without any warning or error messages.
If you could rework the patch to instead introduce a new build option (e.g. nonroot, similar to utils or disable-mtab), I'd be happy to merge.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,421,2019-05-24T15:40:06Z,2019-07-04T08:01:20Z,2019-07-04T13:28:35Z,MERGED,True,16,9,3,https://github.com/DrDaveD,Skip install parts that require root when not running as root,3,[],https://github.com/libfuse/libfuse/pull/421,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/421#issuecomment-501669675,"When running as non-root, for example when building a package, skip the parts of the install process that require root.
This takes the place of a patch that the Fedora build of fuse3 was applying.","Are you interested in reworking this as described above? If not, hope it's ok if I close the PR.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,421,2019-05-24T15:40:06Z,2019-07-04T08:01:20Z,2019-07-04T13:28:35Z,MERGED,True,16,9,3,https://github.com/DrDaveD,Skip install parts that require root when not running as root,3,[],https://github.com/libfuse/libfuse/pull/421,https://github.com/DrDaveD,4,https://github.com/libfuse/libfuse/pull/421#issuecomment-501717075,"When running as non-root, for example when building a package, skip the parts of the install process that require root.
This takes the place of a patch that the Fedora build of fuse3 was applying.","Sorry, yes I am.  I made an attempt last week that didn't work but I plan to get back to it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,421,2019-05-24T15:40:06Z,2019-07-04T08:01:20Z,2019-07-04T13:28:35Z,MERGED,True,16,9,3,https://github.com/DrDaveD,Skip install parts that require root when not running as root,3,[],https://github.com/libfuse/libfuse/pull/421,https://github.com/DrDaveD,5,https://github.com/libfuse/libfuse/pull/421#issuecomment-508208453,"When running as non-root, for example when building a package, skip the parts of the install process that require root.
This takes the place of a patch that the Fedora build of fuse3 was applying.","Ok this version seems to work, how does it look to you?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,424,2019-06-04T19:59:58Z,2019-06-06T12:31:43Z,2019-06-06T12:31:49Z,MERGED,True,10,10,4,https://github.com/michaelforney,Minor portability fixes,3,[],https://github.com/libfuse/libfuse/pull/424,https://github.com/michaelforney,1,https://github.com/libfuse/libfuse/pull/424,Fixes some uses of non-standard C features.,Fixes some uses of non-standard C features.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,424,2019-06-04T19:59:58Z,2019-06-06T12:31:43Z,2019-06-06T12:31:49Z,MERGED,True,10,10,4,https://github.com/michaelforney,Minor portability fixes,3,[],https://github.com/libfuse/libfuse/pull/424,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/424#issuecomment-499474143,Fixes some uses of non-standard C features.,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,425,2019-06-04T20:18:29Z,2019-06-15T10:16:46Z,2019-06-15T10:16:46Z,MERGED,True,2,0,1,https://github.com/michaelforney,Fix build with IGNORE_MTAB,1,['needs-info'],https://github.com/libfuse/libfuse/pull/425,https://github.com/michaelforney,1,https://github.com/libfuse/libfuse/pull/425,"IGNORE_MTAB doesn't seem to be a documented option, but it is referenced in lib/mount.c, lib/mount_util.c, and util/fusermount.c, though only defined in lib/mount_util.c.
However, I've been building with -DIGNORE_MTAB since my system has /etc/mtab as a symlink to /proc/self/mounts, and I don't want fuse to try to modify it.","IGNORE_MTAB doesn't seem to be a documented option, but it is referenced in lib/mount.c, lib/mount_util.c, and util/fusermount.c, though only defined in lib/mount_util.c.
However, I've been building with -DIGNORE_MTAB since my system has /etc/mtab as a symlink to /proc/self/mounts, and I don't want fuse to try to modify it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,425,2019-06-04T20:18:29Z,2019-06-15T10:16:46Z,2019-06-15T10:16:46Z,MERGED,True,2,0,1,https://github.com/michaelforney,Fix build with IGNORE_MTAB,1,['needs-info'],https://github.com/libfuse/libfuse/pull/425,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/425#issuecomment-499474800,"IGNORE_MTAB doesn't seem to be a documented option, but it is referenced in lib/mount.c, lib/mount_util.c, and util/fusermount.c, though only defined in lib/mount_util.c.
However, I've been building with -DIGNORE_MTAB since my system has /etc/mtab as a symlink to /proc/self/mounts, and I don't want fuse to try to modify it.","It looks as if you've just moved some code around - is that intentional? If there are changes to the logic, could you separate them out?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,425,2019-06-04T20:18:29Z,2019-06-15T10:16:46Z,2019-06-15T10:16:46Z,MERGED,True,2,0,1,https://github.com/michaelforney,Fix build with IGNORE_MTAB,1,['needs-info'],https://github.com/libfuse/libfuse/pull/425,https://github.com/michaelforney,3,https://github.com/libfuse/libfuse/pull/425#issuecomment-499774468,"IGNORE_MTAB doesn't seem to be a documented option, but it is referenced in lib/mount.c, lib/mount_util.c, and util/fusermount.c, though only defined in lib/mount_util.c.
However, I've been building with -DIGNORE_MTAB since my system has /etc/mtab as a symlink to /proc/self/mounts, and I don't want fuse to try to modify it.","Yes, this just moves the definitions of chdir_to_parent and check_is_mount (along with dependent functions clone_newns and check_is_mount_child) outside the #ifndef IGNORE_MTAB block, since they are used by should_auto_unmount.
There are no logical changes.
An equivalent fix is
diff --git a/util/fusermount.c b/util/fusermount.c
index 5e0b104..56da6ec 100644
--- a/util/fusermount.c
+++ b/util/fusermount.c
@@ -208,6 +208,7 @@ static int may_unmount(const char *mnt, int quiet)
 
 	return 0;
 }
+#endif
 
 /*
  * Check whether the file specified in ""fusermount3 -u"" is really a
@@ -395,6 +396,7 @@ static int chdir_to_parent(char *copy, const char **lastp)
 	return 0;
 }
 
+#ifndef IGNORE_MTAB
 /* Check whether the kernel supports UMOUNT_NOFOLLOW flag */
 static int umount_nofollow_support(void)
 {
but I thought it would be better to group the mtab-specific functions in a single preprocessing group.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,425,2019-06-04T20:18:29Z,2019-06-15T10:16:46Z,2019-06-15T10:16:46Z,MERGED,True,2,0,1,https://github.com/michaelforney,Fix build with IGNORE_MTAB,1,['needs-info'],https://github.com/libfuse/libfuse/pull/425,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/425#issuecomment-501669457,"IGNORE_MTAB doesn't seem to be a documented option, but it is referenced in lib/mount.c, lib/mount_util.c, and util/fusermount.c, though only defined in lib/mount_util.c.
However, I've been building with -DIGNORE_MTAB since my system has /etc/mtab as a symlink to /proc/self/mounts, and I don't want fuse to try to modify it.","Ah, got it. Could you please push the equivalent patch for the benefit of future readers and usability of git blame?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,425,2019-06-04T20:18:29Z,2019-06-15T10:16:46Z,2019-06-15T10:16:46Z,MERGED,True,2,0,1,https://github.com/michaelforney,Fix build with IGNORE_MTAB,1,['needs-info'],https://github.com/libfuse/libfuse/pull/425,https://github.com/michaelforney,5,https://github.com/libfuse/libfuse/pull/425#issuecomment-501843121,"IGNORE_MTAB doesn't seem to be a documented option, but it is referenced in lib/mount.c, lib/mount_util.c, and util/fusermount.c, though only defined in lib/mount_util.c.
However, I've been building with -DIGNORE_MTAB since my system has /etc/mtab as a symlink to /proc/self/mounts, and I don't want fuse to try to modify it.",Updated to use the ifdef fix instead.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,433,2019-07-09T20:04:23Z,2019-07-09T20:54:09Z,2019-07-10T07:35:27Z,MERGED,True,24,1,1,https://github.com/navytux,Sync fuse_kernel.h with Linux 5.2,1,[],https://github.com/libfuse/libfuse/pull/433,https://github.com/navytux,1,https://github.com/libfuse/libfuse/pull/433,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,433,2019-07-09T20:04:23Z,2019-07-09T20:54:09Z,2019-07-10T07:35:27Z,MERGED,True,24,1,1,https://github.com/navytux,Sync fuse_kernel.h with Linux 5.2,1,[],https://github.com/libfuse/libfuse/pull/433,https://github.com/navytux,2,https://github.com/libfuse/libfuse/pull/433#issuecomment-509946309,,Thanks,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,1,https://github.com/libfuse/libfuse/pull/434,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,2,https://github.com/libfuse/libfuse/pull/434#issuecomment-510196698,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","amended the patch with the following interdiff:
--- a/include/fuse_common.h
+++ b/include/fuse_common.h
@@ -71,10 +71,6 @@ struct fuse_file_info {
            seekable. */
        unsigned int nonseekable : 1;
 
-       /** Can be filled in by open, to indicate that the file is
-           stream-like (no file position at all). */
-       unsigned int stream : 1;
-
        /* Indicates that flock locks for this file should be
           released.  If set, lock_owner shall contain a valid value.
           May only be set in ->release(). */
@@ -86,8 +82,12 @@ struct fuse_file_info {
            nothing when set by open()). */
        unsigned int cache_readdir : 1;
 
+       /** Can be filled in by open, to indicate that the file is
+           stream-like (no file position at all). */
+       unsigned int stream : 1;
+
        /** Padding.  Reserved for future use*/
-       unsigned int padding : 26;
+       unsigned int padding : 25;
 
        /** File handle id.  May be filled in by filesystem in create,
         * open, and opendir().  Available in most other file operations on the
appologize for missing that padding and binary compatibility initially.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,3,https://github.com/libfuse/libfuse/pull/434#issuecomment-510201084,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","( CI: FreeBSD failure seems to be unrelated to the patch - it says it did not start the build job at all: ""Failed to start: Read timed out"" )",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,4,https://github.com/libfuse/libfuse/pull/434#issuecomment-514533682,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","Ping, @Nikratio .",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/434#issuecomment-514743865,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","Thanks for the patch! I'm somewhat confused by this. From the description, it seems that at this point in time any reasonable filesystem would set both nonseekable and stream_like. Is that correct? If so, let's state this clearly in the comments (which are used to generate documentation).
Then, I understand that we cannot implicitly set stream_like, because eg gvfs depends on it not being set. Is that correct? However, as I understand this will lead to deadlocks, thus making such filesystems unusable anyway - so why do we have to care? Is the likelihood of the deadlock very small?
Finally, what is it exactly that these file systems depend on? Or, what would go wrong if we were to set stream_like automatically in libfuse?
It seems to me that we should either make a strong statement that the two flags must always be used together, or need to supply more documentation on when it makes sense to set only nonseekable.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,6,https://github.com/libfuse/libfuse/pull/434#issuecomment-514773994,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","@Nikratio, first of all thanks for feedback. Yes it is a bit confusing, mostly due to requirement to keep old ""just nonseekable"" semantic working. Let me try to clarify:

From the description, it seems that at this point in time any reasonable filesystem would set both nonseekable and stream_like. Is that correct?

Yes, that's correct. Any reasonable filesystem that implements pipe-like of bidirectional socket-like file must set both stream=1 and nonseekable=1.

Then, I understand that we cannot implicitly set stream_like, because eg gvfs depends on it not being set. Is that correct?

Yes, that's correct. The reason why we just don't change nonseekable=1 semantic to drop position is that there are filesystems that use nonseekable=1 and file position in e.g. read.

However, as I understand this will lead to deadlocks, thus making such filesystems unusable anyway - so why do we have to care? Is the likelihood of the deadlock very small?

nonseekable=1 and read/write methods that use ppos don't always lead to deadlock. They lead to deadlock only if there is synchronization/waiting in between read and write. For example in kernel there are several files that use nonseekable_open (analog of nonseekable=1 in libfuse) but provide plain data buffer to read from or write to. For such cases read method checks the position and uses it to see from where to continue to read. Strictly speaking the file is seekable, because there is a notion of position, and it will be just that llseek will fail because nonseekable_open was used. There is also no deadlock here because there is no waiting in between read and write.
Contrary to above simple case of nonseekable=1 with buffer, for real stream files, if there is a dependency connection in between read and write (i.e. read is returning server reply to command that was written) the deadlock is always there and appears 100% of the cases. And even without tx->rx cycle, if just receive operation is blocking (e.g. it receives data from serial port and there is no data coming), the write will be stucked waiting for read to wake up.
In other words for really stream-like files with read/write having blocking semantics the deadlock is always there and stream=1 just has to be used. However there are case where files are really seekable and use position in their read/write handlers that is needed for read/write implementation correctness, and that in turn require the f_pos_lock to be there for read/write not to racily step onto each other toes.
And some of those seekable files - both in kernel and in userspace - historically use nonseekable_open e.g. due to being lazy to implement llseek and so nonseekable=1 semantic, at least for userspace, cannot be changed to avoid providing ppos.
Speaking about gvfs specifically, if I understand it correctly, I see that for streams they are checking that read(..., pos) receives position at where last read was stopped. If we won't continue to provide position into that read, the codepath that checks if (offset != fh->pos) (https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1258) will trigger which can lead to read operation failing.
It is indeed better that gvfs change its stream operations to use both nonseekable=1 and stream=1
(/cc @alexlarsson @ondrejholy @rosslagerwall), but we cannot change already released versions, and also there can be other FUSE-based filesystems that depend on nonseekable=1 still providing position. In other words we cannot change nonseekable=1 semantic because of backward compatibility, even though in some cases the usage is subject to deadlock.

Finally, what is it exactly that these file systems depend on? Or, what would go wrong if we were to set stream_like automatically in libfuse?

Please see above - e.g. those filesystem use position provided into read handler to see from where in their buffer they should continue to provide data.

It seems to me that we should either make a strong statement that the two flags must always be used together, or need to supply more documentation on when it makes sense to set only nonseekable.

I suggest to go the strong statement way. Because nonseekable=1 + position looks like a bit of hack to me because people were lazy to either implement llseek returning -ENOTSUPP or to simply implement it.
I suggest to apply the following interdiff:
--- a/include/fuse_common.h
+++ b/include/fuse_common.h
@@ -68,7 +68,8 @@ struct fuse_file_info {
        unsigned int flush : 1;
 
        /** Can be filled in by open, to indicate that the file is not
-           seekable. */
+           seekable. For pipe-like and socket-like files both nonseekable=1
+           and stream=1 must be set. */
        unsigned int nonseekable : 1;
 
        /* Indicates that flock locks for this file should be
@@ -83,7 +84,16 @@ struct fuse_file_info {
        unsigned int cache_readdir : 1;
 
        /** Can be filled in by open, to indicate that the file is
-           stream-like (no file position at all). */
+         * stream-like (no file position at all).
+         *
+         * Both stream=1 and nonseekable=1 must be set for pipe-like and
+         * socket-like files. See
+         *
+         *     git.kernel.org/linus/10dce8af3422, and
+         *     git.kernel.org/linus/bbd84f33652f
+         *
+         * for details.
+         */
        unsigned int stream : 1;
 
        /** Padding.  Reserved for future use*/
and add a bold warning in next libfuse release notes about the issue.
What do you think?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/434#issuecomment-516552869,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","Thanks for the explanations! I'm on vacation right now, will take a closer look in 2 weeks.
Quick impression: I feel like the steam like vs non seekable distinction is not useful, i'd rather call the new flag ""truly_nonseekable""  or something like that and have or imply the other (so that we can retire that at dinyner point). And in addition to the mailing list link, I'd add a short summary along the lines of ""if truly non seekable, offset values are undefined. If legacy non seekable, offset values will point to current position but deadlocks may occur""",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,8,https://github.com/libfuse/libfuse/pull/434#issuecomment-516571015,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","@Nikratio thanks for feedback and looking forward to your closer look when you are back. On ""nonseekable"" vs ""trully nonseekable"" I suggest to use the ""stream"" terminology as this is what the kernel is using. Being stream also implies being nonseekable (the kernel enforces it) and the same can be done at client side by libfuse (selecting nonseekable=1 if stream was set =1 just in case we are running on older kernel). Stream is also more clear (to me) compared to ""trully nonseekable"".

I'd add a short summary along the lines of ""if truly non seekable, offset values are undefined. If legacy non seekable, offset values will point to current position but deadlocks may occur""

Good idea to add such explanation. Only I would suggest to change ""undefined"" to something exact - there is no current position and pos passed to read/write handlers will be 0.
Anyway, looking forward to hear from you after vacation.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/434#issuecomment-517633236,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","I see. Ok, let's do this:


Let's rename nonseekable to nonseekable_broken. This means that filesystems linked against old libfuse versions will continue to work, but attempting to compile against a new version will break. Prominently mention this in ChangeLog.rst


Let's add a comment stating that (1) this flag causes deadlocks, (2) that streamlike should be used instead, and that (3) the difference is that with streamlike no offset is passed to read/write. Clearly mark the linux-kernel link as ""background reading"".


Let's add a comment to streamlike that explains that write/read handler will always receive a zero offset.


Do not require setting both streamlike and nonseekable_broken - if necessary, libfuse should internally set nonseekable_broken.


Sounds good?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/Nikratio,10,https://github.com/libfuse/libfuse/pull/434#issuecomment-528978265,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481",Are you still interested in working on this?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,11,https://github.com/libfuse/libfuse/pull/434#issuecomment-529009787,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481",Appologize for getting stuck. I was trying to finish something else and got completely swamped. I will try to provide feedback here in a day or two hopefuly.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,434,2019-07-10T19:16:57Z,,2019-09-19T19:53:37Z,OPEN,False,9,2,3,https://github.com/navytux,Add support for stream-like files,1,[],https://github.com/libfuse/libfuse/pull/434,https://github.com/navytux,12,https://github.com/libfuse/libfuse/pull/434#issuecomment-533284194,"Starting from 2008 it became possible to implement FUSE filesystems
with pipe/socket-like files. For this a filesystem server should set
file_info->nonseekable and the kernel will correspondingly use
FMODE_NONSEEKABLE for opened file handle. See commit cafdcb2 ""If
open sets fi->nonseekable, libfuse will tell the kernel that the file is
not seekable"" which added nonseekable support to libfuse.
Unfortunately in 2014 a kernel regression was introduced(*): all file IO
switched to be done under lock (file->f_pos_lock) with the idea that
file position changes should be atomic. However for stream-like
files that were using nonseekable open it created possibility of
deadlock in between read and write:
- file read could be waiting for data from filesystem server
- filesystem server is generating data in reply to client write to that file
- write to that file is waiting for f_pos_lock taken by read
-> deadlock

Unfortunately now the regression is not possible to fix on just kernel
side because a) it is already 5 years after 2014, and b) there are
existing FUSE filesystems that use nonseekable open and position for
corresponding file(+). In other words because of backward compatibility
today we cannot change the kernel to avoid taking f_pos_lock and not to
pass file position for filesystem server for nonseekable FUSE file
handles.
The solution to the deadlock problem, that is already merged to Linux
kernel, is to introduce new FUSE open flag (FOPEN_STREAM) that is
explicitly marking file handle as not having position at all, and thus
for such file handle the kernel will avoid taking f_pos_lock.
git.kernel.org/linus/10dce8af3422
git.kernel.org/linus/bbd84f33652f

When implementing stream-like files filesystem servers should be using
both FOPEN_NONSEEKABLE and FOPEN_STREAM:
- on kernels released before 2014, since in-kernel FUSE client
  ignores unknown FOPEN flags, this will continue to work ok as before.
- on kernels with FOPEN_STREAM support, this will avoid
  read/write deadlock.
- on kernels released after 2014 but without FOPEN_STREAM
  support, the deadlock will be there but using FOPEN_STREAM
  does not make the situation worse.

- FOPEN_STREAM was merged into Linux 5.2 (see commits ^^^) and
  was backported to all long-term stable Linux kernel versions
  that are taking their roots after kernel regression point:

  Linux 5.1  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v5.1.4-110-g5bb2a758f2ed
  Linux 4.19 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.19.45-82-gfea685000caf
  Linux 4.14 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.14.124-35-g585724f83b0c
  Linux 4.9  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.9.180-83-gcfd8d2e79524
  Linux 4.4  git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v4.4.180-241-gc9696a8f3e64
  Linux 3.18 https://android.googlesource.com/kernel/common/+/9225b2f9d042
  Linux 3.16 git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=v3.16.69-123-g6d654f9d5d1f

Note: we cannot change libfuse to use use both FOPEN_NONSEEKABLE and
FOPEN_STREAM on just file->info_nonseekable=1 for the same backward
compatibility reason why we cannot change the kernel to avoid using file
position for nonseekable opens (see ""+"" again). Thus let's introduce
new flag file_info->stream and let filesystems that implement
stream-like files set both file_info->stream and
file_info->nonseekable_open.
Even though example/poll.c implements only read, I've changed that
example to use file_info->stream=1 too, because file implemented there
does not use file position at all and because that example is kind of
canonical on how to implement ""pipe-like"" files with libfuse.
Since this patch is trying to fix regression introduced in 2014, it
should be applied to all libfuse branches covering time after that
moment:
- master (current 3.x development)
- fuse_3_0_bugfix
- fuse-2_9_bugfix
- fuse_2_8_bugfix

/cc @Nikratio, @szmi
(*) git.kernel.org/linus/9c225f2655e3
(+) e.g. gvfs, see
https://codesearch.debian.net/search?q=-%3Enonseekable+%3D
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1080
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1247-1346
https://gitlab.gnome.org/GNOME/gvfs/blob/1.40.0-6-gcbc54396/client/gvfsfusedaemon.c#L1399-1481","@Nikratio, first of all I appologize once again for the long delay with replying.


Let's rename nonseekable to nonseekable_broken. This means that filesystems linked against old libfuse versions will continue to work, but attempting to compile against a new version will break. Prominently mention this in ChangeLog.rst


I'm not sure that breaking libfuse backward compatibility - even source one - is acceptable.
However if backward compatibility break is acceptable I would expose only stream setting and not expose nonseekable setting at all, i.e. don't expose even nonseekable_broken or anything like that.
Of course if such breakage is decided to be made, it has to be done with incrementing FUSE API number in major way. I agree that making a bold statement in the changelog is required in any way - if, or if not - backward compatibility is lost.
By the way, we are talking not only about new libfuse releases, but also about backports for older libfuse releases too - see e.g. #435 and #436 as, from my point of view, it is not good to leave users of those older libfuse release out of luck to avoid the deadlock regression fixes.


Let's add a comment stating that (1) this flag causes deadlocks, (2) that streamlike should be used instead, and that (3) the difference is that with streamlike no offset is passed to read/write. Clearly mark the linux-kernel link as ""background reading"".


Agree.

Let's add a comment to streamlike that explains that write/read handler will always receive a zero offset.

Agree.

Do not require setting both streamlike and nonseekable_broken - if necessary, libfuse should internally set nonseekable_broken.

Agree.

I have to clarify one thing: personally I'm not using libfuse for my project (which is based on go-fuse). However because libfuse is kind of canonical library for FUSE-based filesystems (at least it was started from that) with this libfuse fixes I just wanted to be a good ""citizen"" by not leaving libfuse not notified and not adapted to the FUSE kernel fixes that got merged. Unfortunately it is a very tough time for me at present and I do not have the time resources to continue working on libfuse bits for at least several months. I appologize for this inconvenience, but unfortunately it means that either libfuse people pick this work up and carry it on, or it has to wait until I could have at least some spare cycles to continue working on this topic. Of course I would prefer to finish this myself if I have the chance, but at present I cannot afford that. I appologize for this inconvenience and hope for understanding...
Sorry once again for the delay with replying. Best,
Kirill",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,435,2019-07-10T19:49:56Z,2019-09-27T18:49:49Z,2019-09-27T18:49:50Z,CLOSED,False,13,2,4,https://github.com/navytux,[2.9 backport] Add support for stream-like files,2,[],https://github.com/libfuse/libfuse/pull/435,https://github.com/navytux,1,https://github.com/libfuse/libfuse/pull/435,"This is 2.9 backport of #434.
Please see details in that PR and in the second patch in hereby series.
Thanks beforehand,
Kirill
/cc @Nikratio, @szmi","This is 2.9 backport of #434.
Please see details in that PR and in the second patch in hereby series.
Thanks beforehand,
Kirill
/cc @Nikratio, @szmi",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,435,2019-07-10T19:49:56Z,2019-09-27T18:49:49Z,2019-09-27T18:49:50Z,CLOSED,False,13,2,4,https://github.com/navytux,[2.9 backport] Add support for stream-like files,2,[],https://github.com/libfuse/libfuse/pull/435,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/435#issuecomment-536056793,"This is 2.9 backport of #434.
Please see details in that PR and in the second patch in hereby series.
Thanks beforehand,
Kirill
/cc @Nikratio, @szmi","I'm closing this for now pending discussion in #434. I am not sure this is worth fixing in 2.9 though, especially since the (in my opinion) cleanest fix involves breaking backwards compatibility.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,436,2019-07-10T19:56:53Z,2019-09-27T18:49:02Z,2019-09-27T18:49:02Z,CLOSED,False,14,2,4,https://github.com/navytux,[2.8 backport] Add support for stream-like files,2,[],https://github.com/libfuse/libfuse/pull/436,https://github.com/navytux,1,https://github.com/libfuse/libfuse/pull/436,"This is 2.8 backport of #434.
Please see details in that PR and in the second patch in hereby series.
Thanks beforehand,
Kirill
/cc @Nikratio, @szmi","This is 2.8 backport of #434.
Please see details in that PR and in the second patch in hereby series.
Thanks beforehand,
Kirill
/cc @Nikratio, @szmi",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,436,2019-07-10T19:56:53Z,2019-09-27T18:49:02Z,2019-09-27T18:49:02Z,CLOSED,False,14,2,4,https://github.com/navytux,[2.8 backport] Add support for stream-like files,2,[],https://github.com/libfuse/libfuse/pull/436,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/436#issuecomment-536056552,"This is 2.8 backport of #434.
Please see details in that PR and in the second patch in hereby series.
Thanks beforehand,
Kirill
/cc @Nikratio, @szmi",I'm closing this for now pending discussion in #434. Please note also that I do not intend to do any releases of the 2.8 branch anymore.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,438,2019-07-16T12:02:38Z,2019-07-23T19:52:16Z,2019-07-23T19:52:16Z,MERGED,True,35,0,1,https://github.com/giuseppe,fuse-lowlevel: set pipe size to max,1,[],https://github.com/libfuse/libfuse/pull/438,https://github.com/giuseppe,1,https://github.com/libfuse/libfuse/pull/438,"on failure to set the pipe size, set it to the maximum allowed by the
kernel.
If the first request required more than the maximum allowed, the
can_grow flag would be reset thus preventing any further resize.
Grow the pipe to the maximum allowed to increase the likelihood of
using splice for successive requests instead of falling back to
read/write.
Signed-off-by: Giuseppe Scrivano gscrivan@redhat.com","on failure to set the pipe size, set it to the maximum allowed by the
kernel.
If the first request required more than the maximum allowed, the
can_grow flag would be reset thus preventing any further resize.
Grow the pipe to the maximum allowed to increase the likelihood of
using splice for successive requests instead of falling back to
read/write.
Signed-off-by: Giuseppe Scrivano gscrivan@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,438,2019-07-16T12:02:38Z,2019-07-23T19:52:16Z,2019-07-23T19:52:16Z,MERGED,True,35,0,1,https://github.com/giuseppe,fuse-lowlevel: set pipe size to max,1,[],https://github.com/libfuse/libfuse/pull/438,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/438#issuecomment-511814617,"on failure to set the pipe size, set it to the maximum allowed by the
kernel.
If the first request required more than the maximum allowed, the
can_grow flag would be reset thus preventing any further resize.
Grow the pipe to the maximum allowed to increase the likelihood of
using splice for successive requests instead of falling back to
read/write.
Signed-off-by: Giuseppe Scrivano gscrivan@redhat.com","Thanks! Looking at this, wouldn't it be easier to get rid of the pipe growing logic and set it to the maximum size right from the beginning? Are there any disadvantages of having a large pipe size?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,438,2019-07-16T12:02:38Z,2019-07-23T19:52:16Z,2019-07-23T19:52:16Z,MERGED,True,35,0,1,https://github.com/giuseppe,fuse-lowlevel: set pipe size to max,1,[],https://github.com/libfuse/libfuse/pull/438,https://github.com/giuseppe,3,https://github.com/libfuse/libfuse/pull/438#issuecomment-511978037,"on failure to set the pipe size, set it to the maximum allowed by the
kernel.
If the first request required more than the maximum allowed, the
can_grow flag would be reset thus preventing any further resize.
Grow the pipe to the maximum allowed to increase the likelihood of
using splice for successive requests instead of falling back to
read/write.
Signed-off-by: Giuseppe Scrivano gscrivan@redhat.com","Thanks! Looking at this, wouldn't it be easier to get rid of the pipe growing logic and set it to the maximum size right from the beginning? Are there any disadvantages of having a large pipe size?

I don't think there are disadvantages beside wasting some memory.  AFAICS the main advantage for the lazy allocation that is used now is that on a host with /proc/sys/fs/pipe-max-size set to a big value, we will always use the biggest value even in the case there won't be any request that needs it.
With the current code instead we are sure we set the maximum value only if there was already a request that needed more than the maximum size.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,438,2019-07-16T12:02:38Z,2019-07-23T19:52:16Z,2019-07-23T19:52:16Z,MERGED,True,35,0,1,https://github.com/giuseppe,fuse-lowlevel: set pipe size to max,1,[],https://github.com/libfuse/libfuse/pull/438,https://github.com/giuseppe,4,https://github.com/libfuse/libfuse/pull/438#issuecomment-514259469,"on failure to set the pipe size, set it to the maximum allowed by the
kernel.
If the first request required more than the maximum allowed, the
can_grow flag would be reset thus preventing any further resize.
Grow the pipe to the maximum allowed to increase the likelihood of
using splice for successive requests instead of falling back to
read/write.
Signed-off-by: Giuseppe Scrivano gscrivan@redhat.com",@Nikratio anything more to move this PR forward?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,438,2019-07-16T12:02:38Z,2019-07-23T19:52:16Z,2019-07-23T19:52:16Z,MERGED,True,35,0,1,https://github.com/giuseppe,fuse-lowlevel: set pipe size to max,1,[],https://github.com/libfuse/libfuse/pull/438,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/438#issuecomment-514358533,"on failure to set the pipe size, set it to the maximum allowed by the
kernel.
If the first request required more than the maximum allowed, the
can_grow flag would be reset thus preventing any further resize.
Grow the pipe to the maximum allowed to increase the likelihood of
using splice for successive requests instead of falling back to
read/write.
Signed-off-by: Giuseppe Scrivano gscrivan@redhat.com","Sorry for the delay. I suspect that just requesting a large size will not consume any memory unless someone actually writes that much data, and that it would therefore be okay to simplify the code. However, I don't have time to confirm so will do the conservative choice and merge as-is. Thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,445,2019-08-20T08:54:27Z,2019-08-23T19:58:07Z,2019-08-23T19:58:07Z,MERGED,True,8,2,1,https://github.com/AsumFace,Clarify bitfield padding issue,2,[],https://github.com/libfuse/libfuse/pull/445,https://github.com/AsumFace,1,https://github.com/libfuse/libfuse/pull/445,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,445,2019-08-20T08:54:27Z,2019-08-23T19:58:07Z,2019-08-23T19:58:07Z,MERGED,True,8,2,1,https://github.com/AsumFace,Clarify bitfield padding issue,2,[],https://github.com/libfuse/libfuse/pull/445,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/445#issuecomment-523052319,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,"I'm sorry, but what would be the problem with adding another flag and reducing the padding by one?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,445,2019-08-20T08:54:27Z,2019-08-23T19:58:07Z,2019-08-23T19:58:07Z,MERGED,True,8,2,1,https://github.com/AsumFace,Clarify bitfield padding issue,2,[],https://github.com/libfuse/libfuse/pull/445,https://github.com/AsumFace,3,https://github.com/libfuse/libfuse/pull/445#issuecomment-523082828,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,"It very likely does not do what the programmer intends. The current padding field is not located inside the same 32 bit block where the flags are due to being oversized by one bit, which is not apparent without closer inspection. Luckily, as long as the padding remains too large to fit, no breakage will occur, but who knows what breakage might occur based on wrong assumptions about the struct layout later on.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,445,2019-08-20T08:54:27Z,2019-08-23T19:58:07Z,2019-08-23T19:58:07Z,MERGED,True,8,2,1,https://github.com/AsumFace,Clarify bitfield padding issue,2,[],https://github.com/libfuse/libfuse/pull/445,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/445#issuecomment-524328520,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,"Got you, thanks! But there is no reason to talk about backwards compatibility, etc for the second 32 bit, is there? It can be used in the future just like the remaining bits in the preceding byte.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,445,2019-08-20T08:54:27Z,2019-08-23T19:58:07Z,2019-08-23T19:58:07Z,MERGED,True,8,2,1,https://github.com/AsumFace,Clarify bitfield padding issue,2,[],https://github.com/libfuse/libfuse/pull/445,https://github.com/AsumFace,5,https://github.com/libfuse/libfuse/pull/445#issuecomment-524395451,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,"Yeah, the second 32 bit can be used up for additional flags as you'd expect. The change effectively only affects the naming of the padding that's already there after all.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,445,2019-08-20T08:54:27Z,2019-08-23T19:58:07Z,2019-08-23T19:58:07Z,MERGED,True,8,2,1,https://github.com/AsumFace,Clarify bitfield padding issue,2,[],https://github.com/libfuse/libfuse/pull/445,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/445#issuecomment-524400207,The current situation is evidently devious and the next person adding another named bit field will probably be fooled by it (again) and shorten the padding field. This change should avert that while maintaining backwards compatibility.,Could you change the comment appropriately then?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,447,2019-08-29T08:34:33Z,2019-08-29T19:28:30Z,2019-08-29T19:28:34Z,MERGED,True,5,4,3,https://github.com/stefanha,Avoid gcc 9.1 strncpy(3) warnings,1,[],https://github.com/libfuse/libfuse/pull/447,https://github.com/stefanha,1,https://github.com/libfuse/libfuse/pull/447,"Recent GCC releases have warnings related to common strncpy(3) bugs.
These warnings can be avoided by explicitly NUL-terminating the buffer
or using memcpy(3) when the intention is to copy just the characters
without the NUL terminator.
This commit fixes the following warnings:
[1/27] Compiling C object 'test/9f86d08@@test_syscalls@exe/test_syscalls.c.o'.
In function ‘test_socket’,
inlined from ‘main’ at ../test/test_syscalls.c:1899:9:
../test/test_syscalls.c:1760:2: warning: ‘strncpy’ output may be truncated copying 108 bytes from a string of length 1023 [-Wstringop-truncation]
1760 |  strncpy(su.sun_path, testsock, sizeof(su.sun_path));
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[2/27] Compiling C object 'lib/76b5a35@@fuse3@sha/fuse.c.o'.
../lib/fuse.c: In function ‘add_name’:
../lib/fuse.c:968:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
968 |  strncpy(s, name, len);
|  ^~~~~~~~~~~~~~~~~~~~~
../lib/fuse.c:944:15: note: length computed here
944 |  size_t len = strlen(name);
|               ^~~~~~~~~~~~
[3/27] Compiling C object 'lib/76b5a35@@fuse3@sha/fuse_lowlevel.c.o'.
../lib/fuse_lowlevel.c: In function ‘fuse_add_direntry’:
../lib/fuse_lowlevel.c:288:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
288 |  strncpy(dirent->name, name, namelen);
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../lib/fuse_lowlevel.c:276:12: note: length computed here
276 |  namelen = strlen(name);
|            ^~~~~~~~~~~~
../lib/fuse_lowlevel.c: In function ‘fuse_add_direntry_plus’:
../lib/fuse_lowlevel.c:381:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
381 |  strncpy(dirent->name, name, namelen);
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../lib/fuse_lowlevel.c:366:12: note: length computed here
366 |  namelen = strlen(name);
|            ^~~~~~~~~~~~
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com","Recent GCC releases have warnings related to common strncpy(3) bugs.
These warnings can be avoided by explicitly NUL-terminating the buffer
or using memcpy(3) when the intention is to copy just the characters
without the NUL terminator.
This commit fixes the following warnings:
[1/27] Compiling C object 'test/9f86d08@@test_syscalls@exe/test_syscalls.c.o'.
In function ‘test_socket’,
inlined from ‘main’ at ../test/test_syscalls.c:1899:9:
../test/test_syscalls.c:1760:2: warning: ‘strncpy’ output may be truncated copying 108 bytes from a string of length 1023 [-Wstringop-truncation]
1760 |  strncpy(su.sun_path, testsock, sizeof(su.sun_path));
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[2/27] Compiling C object 'lib/76b5a35@@fuse3@sha/fuse.c.o'.
../lib/fuse.c: In function ‘add_name’:
../lib/fuse.c:968:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
968 |  strncpy(s, name, len);
|  ^~~~~~~~~~~~~~~~~~~~~
../lib/fuse.c:944:15: note: length computed here
944 |  size_t len = strlen(name);
|               ^~~~~~~~~~~~
[3/27] Compiling C object 'lib/76b5a35@@fuse3@sha/fuse_lowlevel.c.o'.
../lib/fuse_lowlevel.c: In function ‘fuse_add_direntry’:
../lib/fuse_lowlevel.c:288:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
288 |  strncpy(dirent->name, name, namelen);
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../lib/fuse_lowlevel.c:276:12: note: length computed here
276 |  namelen = strlen(name);
|            ^~~~~~~~~~~~
../lib/fuse_lowlevel.c: In function ‘fuse_add_direntry_plus’:
../lib/fuse_lowlevel.c:381:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
381 |  strncpy(dirent->name, name, namelen);
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../lib/fuse_lowlevel.c:366:12: note: length computed here
366 |  namelen = strlen(name);
|            ^~~~~~~~~~~~
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,447,2019-08-29T08:34:33Z,2019-08-29T19:28:30Z,2019-08-29T19:28:34Z,MERGED,True,5,4,3,https://github.com/stefanha,Avoid gcc 9.1 strncpy(3) warnings,1,[],https://github.com/libfuse/libfuse/pull/447,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/447#issuecomment-526327875,"Recent GCC releases have warnings related to common strncpy(3) bugs.
These warnings can be avoided by explicitly NUL-terminating the buffer
or using memcpy(3) when the intention is to copy just the characters
without the NUL terminator.
This commit fixes the following warnings:
[1/27] Compiling C object 'test/9f86d08@@test_syscalls@exe/test_syscalls.c.o'.
In function ‘test_socket’,
inlined from ‘main’ at ../test/test_syscalls.c:1899:9:
../test/test_syscalls.c:1760:2: warning: ‘strncpy’ output may be truncated copying 108 bytes from a string of length 1023 [-Wstringop-truncation]
1760 |  strncpy(su.sun_path, testsock, sizeof(su.sun_path));
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[2/27] Compiling C object 'lib/76b5a35@@fuse3@sha/fuse.c.o'.
../lib/fuse.c: In function ‘add_name’:
../lib/fuse.c:968:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
968 |  strncpy(s, name, len);
|  ^~~~~~~~~~~~~~~~~~~~~
../lib/fuse.c:944:15: note: length computed here
944 |  size_t len = strlen(name);
|               ^~~~~~~~~~~~
[3/27] Compiling C object 'lib/76b5a35@@fuse3@sha/fuse_lowlevel.c.o'.
../lib/fuse_lowlevel.c: In function ‘fuse_add_direntry’:
../lib/fuse_lowlevel.c:288:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
288 |  strncpy(dirent->name, name, namelen);
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../lib/fuse_lowlevel.c:276:12: note: length computed here
276 |  namelen = strlen(name);
|            ^~~~~~~~~~~~
../lib/fuse_lowlevel.c: In function ‘fuse_add_direntry_plus’:
../lib/fuse_lowlevel.c:381:2: warning: ‘strncpy’ output truncated before terminating nul copying as many bytes from a string as its length [-Wstringop-truncation]
381 |  strncpy(dirent->name, name, namelen);
|  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../lib/fuse_lowlevel.c:366:12: note: length computed here
366 |  namelen = strlen(name);
|            ^~~~~~~~~~~~
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,448,2019-09-03T14:29:04Z,2019-09-04T14:59:19Z,2019-09-04T14:59:19Z,MERGED,True,303,175,18,https://github.com/stefanha,Add fuse_log.h APIs for custom log message handlers,1,[],https://github.com/libfuse/libfuse/pull/448,https://github.com/stefanha,1,https://github.com/libfuse/libfuse/pull/448,"Introduce an API for custom log handler functions.  This allows libfuse
applications to send messages to syslog(3) or other logging systems.
See include/fuse_log.h for details.
Convert libfuse from fprintf(stderr, ...) to log_fuse(level, ...).  Most
messages are error messages with FUSE_LOG_ERR log level.  There are also
some debug messages which now use the FUSE_LOG_DEBUG log level.
Note that lib/mount_util.c is used by both libfuse and fusermount3.
Since fusermount3 does not link against libfuse, we cannot call
fuse_log() from lib/mount_util.c.  This file will continue to use
fprintf(stderr, ...) until someone figures out how to split it up.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com","Introduce an API for custom log handler functions.  This allows libfuse
applications to send messages to syslog(3) or other logging systems.
See include/fuse_log.h for details.
Convert libfuse from fprintf(stderr, ...) to log_fuse(level, ...).  Most
messages are error messages with FUSE_LOG_ERR log level.  There are also
some debug messages which now use the FUSE_LOG_DEBUG log level.
Note that lib/mount_util.c is used by both libfuse and fusermount3.
Since fusermount3 does not link against libfuse, we cannot call
fuse_log() from lib/mount_util.c.  This file will continue to use
fprintf(stderr, ...) until someone figures out how to split it up.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,448,2019-09-03T14:29:04Z,2019-09-04T14:59:19Z,2019-09-04T14:59:19Z,MERGED,True,303,175,18,https://github.com/stefanha,Add fuse_log.h APIs for custom log message handlers,1,[],https://github.com/libfuse/libfuse/pull/448,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/448#issuecomment-527620852,"Introduce an API for custom log handler functions.  This allows libfuse
applications to send messages to syslog(3) or other logging systems.
See include/fuse_log.h for details.
Convert libfuse from fprintf(stderr, ...) to log_fuse(level, ...).  Most
messages are error messages with FUSE_LOG_ERR log level.  There are also
some debug messages which now use the FUSE_LOG_DEBUG log level.
Note that lib/mount_util.c is used by both libfuse and fusermount3.
Since fusermount3 does not link against libfuse, we cannot call
fuse_log() from lib/mount_util.c.  This file will continue to use
fprintf(stderr, ...) until someone figures out how to split it up.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com","Thanks, this is great! Could you please add an entry to Changelog.rst as well?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,448,2019-09-03T14:29:04Z,2019-09-04T14:59:19Z,2019-09-04T14:59:19Z,MERGED,True,303,175,18,https://github.com/stefanha,Add fuse_log.h APIs for custom log message handlers,1,[],https://github.com/libfuse/libfuse/pull/448,https://github.com/stefanha,3,https://github.com/libfuse/libfuse/pull/448#issuecomment-527802653,"Introduce an API for custom log handler functions.  This allows libfuse
applications to send messages to syslog(3) or other logging systems.
See include/fuse_log.h for details.
Convert libfuse from fprintf(stderr, ...) to log_fuse(level, ...).  Most
messages are error messages with FUSE_LOG_ERR log level.  There are also
some debug messages which now use the FUSE_LOG_DEBUG log level.
Note that lib/mount_util.c is used by both libfuse and fusermount3.
Since fusermount3 does not link against libfuse, we cannot call
fuse_log() from lib/mount_util.c.  This file will continue to use
fprintf(stderr, ...) until someone figures out how to split it up.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com",@Nikratio Done!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,449,2019-09-09T08:52:44Z,2019-09-09T09:14:03Z,2019-09-09T09:14:06Z,MERGED,True,2,2,1,https://github.com/dagrh,passthrough_ll: fix fallocate variant ifdefs,1,[],https://github.com/libfuse/libfuse/pull/449,https://github.com/dagrh,1,https://github.com/libfuse/libfuse/pull/449,"If fallocate isn't available we incorrectly check for the value of
HAVE_POSIX_FALLOCATE rather than it being defined.
We also fail to initialise 'err' in the case where neither are defined.
Fixes: 5fc562c (""Add fallocate and use it instead of ..."")
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","If fallocate isn't available we incorrectly check for the value of
HAVE_POSIX_FALLOCATE rather than it being defined.
We also fail to initialise 'err' in the case where neither are defined.
Fixes: 5fc562c (""Add fallocate and use it instead of ..."")
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,449,2019-09-09T08:52:44Z,2019-09-09T09:14:03Z,2019-09-09T09:14:06Z,MERGED,True,2,2,1,https://github.com/dagrh,passthrough_ll: fix fallocate variant ifdefs,1,[],https://github.com/libfuse/libfuse/pull/449,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/449#issuecomment-529375649,"If fallocate isn't available we incorrectly check for the value of
HAVE_POSIX_FALLOCATE rather than it being defined.
We also fail to initialise 'err' in the case where neither are defined.
Fixes: 5fc562c (""Add fallocate and use it instead of ..."")
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,450,2019-09-10T11:36:36Z,2019-09-10T13:25:16Z,2019-09-10T13:25:16Z,MERGED,True,47,27,5,https://github.com/stefanha,Export log api,3,[],https://github.com/libfuse/libfuse/pull/450,https://github.com/stefanha,1,https://github.com/libfuse/libfuse/pull/450,"Oops, I forgot to add the fuse_log.h API to lib/fuse_versionscript so that the symbols are actually public.
Also export the fuse_log() function so applications can do unified logging through it and demonstrate this in passthrough_ll.c.","Oops, I forgot to add the fuse_log.h API to lib/fuse_versionscript so that the symbols are actually public.
Also export the fuse_log() function so applications can do unified logging through it and demonstrate this in passthrough_ll.c.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,450,2019-09-10T11:36:36Z,2019-09-10T13:25:16Z,2019-09-10T13:25:16Z,MERGED,True,47,27,5,https://github.com/stefanha,Export log api,3,[],https://github.com/libfuse/libfuse/pull/450,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/450#issuecomment-529913862,"Oops, I forgot to add the fuse_log.h API to lib/fuse_versionscript so that the symbols are actually public.
Also export the fuse_log() function so applications can do unified logging through it and demonstrate this in passthrough_ll.c.",Thanks! Could you please squash the first two commits? Looks like the second is just a fixup of the first.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,450,2019-09-10T11:36:36Z,2019-09-10T13:25:16Z,2019-09-10T13:25:16Z,MERGED,True,47,27,5,https://github.com/stefanha,Export log api,3,[],https://github.com/libfuse/libfuse/pull/450,https://github.com/stefanha,3,https://github.com/libfuse/libfuse/pull/450#issuecomment-529927031,"Oops, I forgot to add the fuse_log.h API to lib/fuse_versionscript so that the symbols are actually public.
Also export the fuse_log() function so applications can do unified logging through it and demonstrate this in passthrough_ll.c.","@Nikratio Thanks for the feedback, I have squashed the two first commits.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,451,2019-09-13T06:51:35Z,2019-09-15T15:56:57Z,2019-09-20T13:22:22Z,MERGED,True,3,0,2,https://github.com/tenzap,Whitelist UFSD,3,[],https://github.com/libfuse/libfuse/pull/451,https://github.com/tenzap,1,https://github.com/libfuse/libfuse/pull/451,fixes #418,fixes #418,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,452,2019-09-13T06:55:34Z,2019-09-15T15:57:09Z,2019-09-20T13:21:21Z,MERGED,True,7,0,2,https://github.com/tenzap,Whitelist UFSD (backport to 2.9 branch),2,[],https://github.com/libfuse/libfuse/pull/452,https://github.com/tenzap,1,https://github.com/libfuse/libfuse/pull/452,fixes #418,fixes #418,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,454,2019-09-19T21:08:49Z,2019-11-03T09:45:04Z,2019-11-03T09:45:04Z,CLOSED,False,454,430,29,https://github.com/billziss-gh,fuse_types.h: rename standard types,1,[],https://github.com/libfuse/libfuse/pull/454,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/454,"This PR implements the proposal in #453. The motivation/rationale behind this proposal is explained there.
The PR introduces a header fuse_types.h and changes the types:

ino_t → fuse_ino_t (this was already defined, but moved to fuse_types.h)
uid_t → fuse_uid_t
gid_t → fuse_gid_t
pid_t → fuse_pid_t
dev_t → fuse_dev_t
mode_t → fuse_mode_t
nlink_t → fuse_nlink_t
off_t → fuse_off_t
fsblkcnt_t → fuse_fsblkcnt_t
fsfilcnt_t → fuse_fsfilcnt_t
blksize_t → fuse_blksize_t
blkcnt_t → fuse_blkcnt_t
struct timespec → struct fuse_timespec
struct stat → struct fuse_stat
struct statvfs → struct fuse_statvfs
struct flock → struct fuse_flock
struct iovec → struct fuse_iovec

On systems such as Linux and FreeBSD which have sensible definitions of struct stat, etc. the FUSE ""type"" is simply a macro that points to the system definition:
#define fuse_stat stat","This PR implements the proposal in #453. The motivation/rationale behind this proposal is explained there.
The PR introduces a header fuse_types.h and changes the types:

ino_t → fuse_ino_t (this was already defined, but moved to fuse_types.h)
uid_t → fuse_uid_t
gid_t → fuse_gid_t
pid_t → fuse_pid_t
dev_t → fuse_dev_t
mode_t → fuse_mode_t
nlink_t → fuse_nlink_t
off_t → fuse_off_t
fsblkcnt_t → fuse_fsblkcnt_t
fsfilcnt_t → fuse_fsfilcnt_t
blksize_t → fuse_blksize_t
blkcnt_t → fuse_blkcnt_t
struct timespec → struct fuse_timespec
struct stat → struct fuse_stat
struct statvfs → struct fuse_statvfs
struct flock → struct fuse_flock
struct iovec → struct fuse_iovec

On systems such as Linux and FreeBSD which have sensible definitions of struct stat, etc. the FUSE ""type"" is simply a macro that points to the system definition:
#define fuse_stat stat",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,454,2019-09-19T21:08:49Z,2019-11-03T09:45:04Z,2019-11-03T09:45:04Z,CLOSED,False,454,430,29,https://github.com/billziss-gh,fuse_types.h: rename standard types,1,[],https://github.com/libfuse/libfuse/pull/454,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/454#issuecomment-536057569,"This PR implements the proposal in #453. The motivation/rationale behind this proposal is explained there.
The PR introduces a header fuse_types.h and changes the types:

ino_t → fuse_ino_t (this was already defined, but moved to fuse_types.h)
uid_t → fuse_uid_t
gid_t → fuse_gid_t
pid_t → fuse_pid_t
dev_t → fuse_dev_t
mode_t → fuse_mode_t
nlink_t → fuse_nlink_t
off_t → fuse_off_t
fsblkcnt_t → fuse_fsblkcnt_t
fsfilcnt_t → fuse_fsfilcnt_t
blksize_t → fuse_blksize_t
blkcnt_t → fuse_blkcnt_t
struct timespec → struct fuse_timespec
struct stat → struct fuse_stat
struct statvfs → struct fuse_statvfs
struct flock → struct fuse_flock
struct iovec → struct fuse_iovec

On systems such as Linux and FreeBSD which have sensible definitions of struct stat, etc. the FUSE ""type"" is simply a macro that points to the system definition:
#define fuse_stat stat","TBH, I am not convinced this amount of churn is worth the benefits. At the very least, let's wait until the WinFuse port is working (according to #453 it is not)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,454,2019-09-19T21:08:49Z,2019-11-03T09:45:04Z,2019-11-03T09:45:04Z,CLOSED,False,454,430,29,https://github.com/billziss-gh,fuse_types.h: rename standard types,1,[],https://github.com/libfuse/libfuse/pull/454,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/454#issuecomment-549120245,"This PR implements the proposal in #453. The motivation/rationale behind this proposal is explained there.
The PR introduces a header fuse_types.h and changes the types:

ino_t → fuse_ino_t (this was already defined, but moved to fuse_types.h)
uid_t → fuse_uid_t
gid_t → fuse_gid_t
pid_t → fuse_pid_t
dev_t → fuse_dev_t
mode_t → fuse_mode_t
nlink_t → fuse_nlink_t
off_t → fuse_off_t
fsblkcnt_t → fuse_fsblkcnt_t
fsfilcnt_t → fuse_fsfilcnt_t
blksize_t → fuse_blksize_t
blkcnt_t → fuse_blkcnt_t
struct timespec → struct fuse_timespec
struct stat → struct fuse_stat
struct statvfs → struct fuse_statvfs
struct flock → struct fuse_flock
struct iovec → struct fuse_iovec

On systems such as Linux and FreeBSD which have sensible definitions of struct stat, etc. the FUSE ""type"" is simply a macro that points to the system definition:
#define fuse_stat stat",Will close this for now (cf discussion in #453),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,457,2019-09-23T19:52:30Z,2019-11-03T09:44:32Z,2019-11-03T09:44:32Z,MERGED,True,194,0,11,https://github.com/yuri-per,Implement lseek operation,1,[],https://github.com/libfuse/libfuse/pull/457,https://github.com/yuri-per,1,https://github.com/libfuse/libfuse/pull/457,"This PR adds support for lseek API on sparse files (SEEK_DATA and SEEK_HOLE) available in kernel starting from 4.5.
Resolves: #115","This PR adds support for lseek API on sparse files (SEEK_DATA and SEEK_HOLE) available in kernel starting from 4.5.
Resolves: #115",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,457,2019-09-23T19:52:30Z,2019-11-03T09:44:32Z,2019-11-03T09:44:32Z,MERGED,True,194,0,11,https://github.com/yuri-per,Implement lseek operation,1,[],https://github.com/libfuse/libfuse/pull/457,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/457#issuecomment-536055658,"This PR adds support for lseek API on sparse files (SEEK_DATA and SEEK_HOLE) available in kernel starting from 4.5.
Resolves: #115","Thanks, looks good! Just one minor thing: please add an entry to Changelog.rst (under a new ""Unreleased Changes"" heading).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,457,2019-09-23T19:52:30Z,2019-11-03T09:44:32Z,2019-11-03T09:44:32Z,MERGED,True,194,0,11,https://github.com/yuri-per,Implement lseek operation,1,[],https://github.com/libfuse/libfuse/pull/457,https://github.com/yuri-per,3,https://github.com/libfuse/libfuse/pull/457#issuecomment-536180678,"This PR adds support for lseek API on sparse files (SEEK_DATA and SEEK_HOLE) available in kernel starting from 4.5.
Resolves: #115","Thanks, looks good! Just one minor thing: please add an entry to Changelog.rst (under a new ""Unreleased Changes"" heading).

Done",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,462,2019-10-14T17:47:05Z,2019-11-03T09:44:13Z,2019-11-03T13:30:04Z,MERGED,True,3,0,1,https://github.com/asomers,Use the -o intr mount option on FreeBSD,1,[],https://github.com/libfuse/libfuse/pull/462,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/462,"FUSE file systems normally indicate their interruptibility by returning
ENOSYS to the first FUSE_INTERRUPT operation.  But that causes two
problems for file systems that aren't interruptible:


A process may block on a signal, even if another thread could've
handled the signal.  The kernel must know whether the FUSE thread is
interruptible before deciding which thread should receive a signal.


The protocol allows a FUSE daemon to simply ignore FUSE_INTERRUPT
operations.  From the kernel's point of view, that is indistinguishable
from a FUSE_INTERRUPT operation arriving after the original operation
had already completed.  Thus, the kernel can't interpret an ignored
FUSE_INTERRUPT as an indication that the daemon is non-interruptible.


With the -o nointr mount option, no FUSE_INTERRUPT operations will ever
be sent.  Most FUSE file systems should require no modifications to take
advantage of this mount option.","FUSE file systems normally indicate their interruptibility by returning
ENOSYS to the first FUSE_INTERRUPT operation.  But that causes two
problems for file systems that aren't interruptible:


A process may block on a signal, even if another thread could've
handled the signal.  The kernel must know whether the FUSE thread is
interruptible before deciding which thread should receive a signal.


The protocol allows a FUSE daemon to simply ignore FUSE_INTERRUPT
operations.  From the kernel's point of view, that is indistinguishable
from a FUSE_INTERRUPT operation arriving after the original operation
had already completed.  Thus, the kernel can't interpret an ignored
FUSE_INTERRUPT as an indication that the daemon is non-interruptible.


With the -o nointr mount option, no FUSE_INTERRUPT operations will ever
be sent.  Most FUSE file systems should require no modifications to take
advantage of this mount option.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,464,2019-10-17T12:37:03Z,2019-11-03T09:43:44Z,2019-11-03T09:43:44Z,MERGED,True,9,7,1,https://github.com/stefanha,passthrough_ll: drop lo_dirp->fd field,1,[],https://github.com/libfuse/libfuse/pull/464,https://github.com/stefanha,1,https://github.com/libfuse/libfuse/pull/464,"fdopendir(3) takes ownership of the file descriptor.  The presence of
the lo_dirp->fd field could lead to someone incorrectly adding a
close(d->fd) cleanup call in the future.
Do not store the file descriptor in struct lo_dirp since it is unused.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com
Reviewed-by: Dr. David Alan Gilbert dgilbert@redhat.com","fdopendir(3) takes ownership of the file descriptor.  The presence of
the lo_dirp->fd field could lead to someone incorrectly adding a
close(d->fd) cleanup call in the future.
Do not store the file descriptor in struct lo_dirp since it is unused.
Signed-off-by: Stefan Hajnoczi stefanha@redhat.com
Reviewed-by: Dr. David Alan Gilbert dgilbert@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,465,2019-10-24T19:12:46Z,2019-10-24T21:46:19Z,2019-10-24T21:46:20Z,MERGED,True,1,1,1,https://github.com/emilyaherbert,Changing the README so that the security limitations also work for women.,1,[],https://github.com/libfuse/libfuse/pull/465,https://github.com/emilyaherbert,1,https://github.com/libfuse/libfuse/pull/465,,,True,{'THUMBS_UP': ['https://github.com/nicksam112']}
libfuse/libfuse,https://github.com/libfuse/libfuse,472,2019-11-19T12:37:01Z,2019-11-20T11:43:53Z,2019-11-20T11:43:53Z,MERGED,True,1,0,1,https://github.com/tkulasek,fix memleak in cuse_lowlevel_setup,1,[],https://github.com/libfuse/libfuse/pull/472,https://github.com/tkulasek,1,https://github.com/libfuse/libfuse/pull/472,"Local variable args is not freed on cuse_lowlevel_setup success.
It causes memory leak:
==317489==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 32 byte(s) in 2 object(s) allocated from:
    #0 0x7f5dfc14d048 in __interceptor_realloc (/lib64/libasan.so.5+0xf0048)
    #1 0x7f5dfbd2efe2 in fuse_opt_add_arg (/lib64/libfuse3.so.3+0x19fe2)

Indirect leak of 10 byte(s) in 2 object(s) allocated from:
    #0 0x7f5dfc098e60 in strdup (/lib64/libasan.so.5+0x3be60)
    #1 0x7f5dfbd2efc6 in fuse_opt_add_arg (/lib64/libfuse3.so.3+0x19fc6)

SUMMARY: AddressSanitizer: 42 byte(s) leaked in 4 allocation(s).","Local variable args is not freed on cuse_lowlevel_setup success.
It causes memory leak:
==317489==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 32 byte(s) in 2 object(s) allocated from:
    #0 0x7f5dfc14d048 in __interceptor_realloc (/lib64/libasan.so.5+0xf0048)
    #1 0x7f5dfbd2efe2 in fuse_opt_add_arg (/lib64/libfuse3.so.3+0x19fe2)

Indirect leak of 10 byte(s) in 2 object(s) allocated from:
    #0 0x7f5dfc098e60 in strdup (/lib64/libasan.so.5+0x3be60)
    #1 0x7f5dfbd2efc6 in fuse_opt_add_arg (/lib64/libfuse3.so.3+0x19fc6)

SUMMARY: AddressSanitizer: 42 byte(s) leaked in 4 allocation(s).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,474,2019-11-19T22:38:02Z,2019-11-27T09:36:31Z,2019-11-27T09:36:31Z,MERGED,True,35,0,4,https://github.com/hselin,Add support for FUSE_EXPLICIT_INVAL_DATA,1,[],https://github.com/libfuse/libfuse/pull/474,https://github.com/hselin,1,https://github.com/libfuse/libfuse/pull/474,"Enable only invalidate cached pages on explicit request.
Let me know if anything needs to be changed. Thanks!
Issue: #473","Enable only invalidate cached pages on explicit request.
Let me know if anything needs to be changed. Thanks!
Issue: #473",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,474,2019-11-19T22:38:02Z,2019-11-27T09:36:31Z,2019-11-27T09:36:31Z,MERGED,True,35,0,4,https://github.com/hselin,Add support for FUSE_EXPLICIT_INVAL_DATA,1,[],https://github.com/libfuse/libfuse/pull/474,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/474#issuecomment-555968674,"Enable only invalidate cached pages on explicit request.
Let me know if anything needs to be changed. Thanks!
Issue: #473","Thanks! Could you please also update ChangeLog.rst? (if necessary, add a new heading ""Unreleased Changes"").",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,474,2019-11-19T22:38:02Z,2019-11-27T09:36:31Z,2019-11-27T09:36:31Z,MERGED,True,35,0,4,https://github.com/hselin,Add support for FUSE_EXPLICIT_INVAL_DATA,1,[],https://github.com/libfuse/libfuse/pull/474,https://github.com/hselin,3,https://github.com/libfuse/libfuse/pull/474#issuecomment-556380076,"Enable only invalidate cached pages on explicit request.
Let me know if anything needs to be changed. Thanks!
Issue: #473","@Nikratio
Updated ChangeLog.rst.
Let me know if it is okay with you. Thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,476,2019-11-28T10:47:10Z,2019-11-29T09:14:28Z,2019-11-29T09:14:29Z,MERGED,True,5,5,1,https://github.com/dagrh,Kill off some proto_major < 6 checks,1,[],https://github.com/libfuse/libfuse/pull/476,https://github.com/dagrh,1,https://github.com/libfuse/libfuse/pull/476,"fuse_init already refuses to start if we're on major < 7 ,
so we can kill off checks for old major versions.
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","fuse_init already refuses to start if we're on major < 7 ,
so we can kill off checks for old major versions.
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,480,2019-12-21T14:41:08Z,2019-12-31T10:01:27Z,2020-01-02T03:33:02Z,MERGED,True,2,2,1,https://github.com/xiaosuo,Style: Fix an indention in comments,1,[],https://github.com/libfuse/libfuse/pull/480,https://github.com/xiaosuo,1,https://github.com/libfuse/libfuse/pull/480,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,482,2019-12-31T00:19:41Z,2019-12-31T09:58:58Z,2019-12-31T23:34:37Z,MERGED,True,29,4,6,https://github.com/billziss-gh,Make ioctl prototype conditional on FUSE_USE_VERSION.,1,[],https://github.com/libfuse/libfuse/pull/482,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/482,"Define FUSE_USE_VERSION < 35 to get old ioctl prototype
with int commands; define FUSE_USE_VERSION >= 35 to get
new ioctl prototype with unsigned int commands.
Fixes #463.","Define FUSE_USE_VERSION < 35 to get old ioctl prototype
with int commands; define FUSE_USE_VERSION >= 35 to get
new ioctl prototype with unsigned int commands.
Fixes #463.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,483,2019-12-31T23:30:07Z,2020-01-02T11:06:19Z,2020-01-02T11:06:19Z,MERGED,True,2,1,2,https://github.com/billziss-gh,Fixed an issue with the linker version script.,1,[],https://github.com/libfuse/libfuse/pull/483,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/483,Fixes #467.,Fixes #467.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,484,2019-12-31T23:48:40Z,2020-01-02T11:08:03Z,2020-01-02T11:08:04Z,MERGED,True,4,1,2,https://github.com/billziss-gh,Fixed a problem with cleaning up mount opts.,2,[],https://github.com/libfuse/libfuse/pull/484,https://github.com/billziss-gh,1,https://github.com/libfuse/libfuse/pull/484,There was a potential memory cleanup problem in fuse_session_new that this simple patch fixes.,There was a potential memory cleanup problem in fuse_session_new that this simple patch fixes.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/dagrh,1,https://github.com/libfuse/libfuse/pull/485,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/485#issuecomment-570594179,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","I'm not sure about this one. I do not know what the original authors intended for all these files. LICENSE itself was written by me in 2018 as a best guess to at least distinguish better between GPL and LGPL. To me, changing all these files feels like pretending that there is more certainty than there actually is.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/dagrh,3,https://github.com/libfuse/libfuse/pull/485#issuecomment-570604239,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","If there's uncertainty about the actual intent of the license we have a bigger problem! People (i.e. me!) might be attempting to take the files and use them in a GPLv2 project - and that's how this came up, because a reviewer pointed out they were uncomfortable with the 'GPL' in passthrough_ll.c.
Now, looking at passthrough_ll.c,  it was created in f55e489 by Miklos in 2014, and it said:
This program can be distributed under the terms of the GNU GPL.
See the file COPYING.
and at the time the COPYING file said:
GNU GENERAL PUBLIC LICENSE
Version 2, June 1991
..
so that seems consistent to me; (COPYING has been there since Nov 2001) and there are some older files.
We've currently not got a COPYING file - since they got renamed; which is a bit confusing since we now have all the headers saying they're GPL and pointing to a non-existent file for clarification.
There's also at least one inconsistency with teh LICENSE file, which is example/passthrough_helpers.h which has, what I think isa  BSD license.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/485#issuecomment-570801483,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","Yeah, that's what I'm saying - there is a bigger problem :-).
Maybe we can tackle the issue file by file? If we have specific evidence of the intention (as you dug up for passthrough_ll.c), then I'll happily apply patches to the headers.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/szmi,5,https://github.com/libfuse/libfuse/pull/485#issuecomment-571056018,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com",The project predates GPLv3 and the intention has definitely been to refer to the then actual version (GPLv2).,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/485#issuecomment-571301668,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","@szmi, are you the original author of all the files in the distribution (other than those later added by me)?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,485,2020-01-03T14:36:51Z,2020-03-13T16:46:45Z,2020-03-13T16:46:45Z,MERGED,True,23,23,23,https://github.com/dagrh,State GPL version in comment,1,[],https://github.com/libfuse/libfuse/pull/485,https://github.com/szmi,7,https://github.com/libfuse/libfuse/pull/485#issuecomment-571305143,"In a bunch of comments we say 'under the terms of the GNU GPL', make
it clear this is GPLv2 (as LICENSE says).
Signed-off-by: Dr. David Alan Gilbert dgilbert@redhat.com","All except:

bsd mount support (Csaba Henk)
cuse and ioctl/poll examples (Tejun Heo)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,486,2020-01-06T11:42:42Z,2020-01-06T20:32:51Z,2020-01-06T20:32:51Z,MERGED,True,1,1,1,https://github.com/dagrh,virtiofsd/passthrough_ll: Pass errno to fuse_reply_err(),1,[],https://github.com/libfuse/libfuse/pull/486,https://github.com/dagrh,1,https://github.com/libfuse/libfuse/pull/486,"lo_copy_file_range() passes -errno to fuse_reply_err() and then fuse_reply_err()
changes it to errno again, so that subsequent fuse_send_reply_iov_nofree() catches
the wrong errno.(i.e. reports ""fuse: bad error value: ..."").
Make fuse_send_reply_iov_nofree() accept the correct -errno by passing errno
directly in lo_copy_file_range().
Signed-off-by: Xiao Yang yangx.jy@cn.fujitsu.com
Reviewed-by: Eryu Guan eguan@linux.alibaba.com
dgilbert:
Upstreaming from virtiofsd https://www.redhat.com/archives/virtio-fs/2020-January/msg00000.html )","lo_copy_file_range() passes -errno to fuse_reply_err() and then fuse_reply_err()
changes it to errno again, so that subsequent fuse_send_reply_iov_nofree() catches
the wrong errno.(i.e. reports ""fuse: bad error value: ..."").
Make fuse_send_reply_iov_nofree() accept the correct -errno by passing errno
directly in lo_copy_file_range().
Signed-off-by: Xiao Yang yangx.jy@cn.fujitsu.com
Reviewed-by: Eryu Guan eguan@linux.alibaba.com
dgilbert:
Upstreaming from virtiofsd https://www.redhat.com/archives/virtio-fs/2020-January/msg00000.html )",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,490,2020-01-16T17:35:11Z,2020-03-13T16:47:19Z,2020-03-13T16:47:19Z,CLOSED,False,3,3,1,https://github.com/bobrofon,install_helper: Install init_script in sysconfdir,1,[],https://github.com/libfuse/libfuse/pull/490,https://github.com/bobrofon,1,https://github.com/libfuse/libfuse/pull/490,"fuse3 init script was always installing to /etc directory even if prefix
variable is defined. Now it is installing to sysconfdir directory.
Also update-rc.d was running even if using root permissins was
explicitly disabled via useroot definition.
Fixes #489","fuse3 init script was always installing to /etc directory even if prefix
variable is defined. Now it is installing to sysconfdir directory.
Also update-rc.d was running even if using root permissins was
explicitly disabled via useroot definition.
Fixes #489",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,490,2020-01-16T17:35:11Z,2020-03-13T16:47:19Z,2020-03-13T16:47:19Z,CLOSED,False,3,3,1,https://github.com/bobrofon,install_helper: Install init_script in sysconfdir,1,[],https://github.com/libfuse/libfuse/pull/490,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/490#issuecomment-575273909,"fuse3 init script was always installing to /etc directory even if prefix
variable is defined. Now it is installing to sysconfdir directory.
Also update-rc.d was running even if using root permissins was
explicitly disabled via useroot definition.
Fixes #489","I believe with this change the default directory for the init script is /usr/local/etc. Is that correct?
Having the default be /etc even if libfuse is installed to /usr/local is a feature, not a bug (libraries are readily usable when installed into /usr/local, but an initscript there will do nothing)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,490,2020-01-16T17:35:11Z,2020-03-13T16:47:19Z,2020-03-13T16:47:19Z,CLOSED,False,3,3,1,https://github.com/bobrofon,install_helper: Install init_script in sysconfdir,1,[],https://github.com/libfuse/libfuse/pull/490,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/490#issuecomment-598815762,"fuse3 init script was always installing to /etc directory even if prefix
variable is defined. Now it is installing to sysconfdir directory.
Also update-rc.d was running even if using root permissins was
explicitly disabled via useroot definition.
Fixes #489",Close per comment above.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,491,2020-01-17T09:25:39Z,2020-03-13T16:47:56Z,2020-03-13T16:47:57Z,CLOSED,False,7,3,3,https://github.com/bobrofon,meson_options: Add initscriptsdir option,1,[],https://github.com/libfuse/libfuse/pull/491,https://github.com/bobrofon,1,https://github.com/libfuse/libfuse/pull/491,"Add meson option 'initscriptsdir' to explicitly define location of
system initialization scripts. 'initscriptsdir' is '/etc/init.d' by
default.
Option usage:
meson --prefix=/usr/local -Dinitscriptsdir=/custom/init.d libfuse-src-dir build-dir
DESTDIR=""${PWD}/install-dir"" ninja -C build-dir
As a result, init script will be installed into
""${PWD}/install-dir/custom/init.d"" location.
Fixes #489","Add meson option 'initscriptsdir' to explicitly define location of
system initialization scripts. 'initscriptsdir' is '/etc/init.d' by
default.
Option usage:
meson --prefix=/usr/local -Dinitscriptsdir=/custom/init.d libfuse-src-dir build-dir
DESTDIR=""${PWD}/install-dir"" ninja -C build-dir
As a result, init script will be installed into
""${PWD}/install-dir/custom/init.d"" location.
Fixes #489",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,491,2020-01-17T09:25:39Z,2020-03-13T16:47:56Z,2020-03-13T16:47:57Z,CLOSED,False,7,3,3,https://github.com/bobrofon,meson_options: Add initscriptsdir option,1,[],https://github.com/libfuse/libfuse/pull/491,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/491#issuecomment-598816028,"Add meson option 'initscriptsdir' to explicitly define location of
system initialization scripts. 'initscriptsdir' is '/etc/init.d' by
default.
Option usage:
meson --prefix=/usr/local -Dinitscriptsdir=/custom/init.d libfuse-src-dir build-dir
DESTDIR=""${PWD}/install-dir"" ninja -C build-dir
As a result, init script will be installed into
""${PWD}/install-dir/custom/init.d"" location.
Fixes #489","I do not think the extra complexity justifies the benefits here, sorry.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,492,2020-01-24T02:49:03Z,2020-01-24T15:53:33Z,2020-01-24T15:53:33Z,MERGED,True,1,1,1,https://github.com/t-msn,passthrough_ll: Use cache_readdir for directory open,1,[],https://github.com/libfuse/libfuse/pull/492,https://github.com/t-msn,1,https://github.com/libfuse/libfuse/pull/492,"Upstreamed from:
https://www.redhat.com/archives/virtio-fs/2020-January/msg00106.html
Since keep_cache(FOPEN_KEEP_CACHE) has no effect for directory as
described in fuse_common.h, use cache_readdir(FOPEN_CACHE_DIR) for
directory open when cache=always mode.
Signed-off-by: Misono Tomohiro misono.tomohiro@jp.fujitsu.com","Upstreamed from:
https://www.redhat.com/archives/virtio-fs/2020-January/msg00106.html
Since keep_cache(FOPEN_KEEP_CACHE) has no effect for directory as
described in fuse_common.h, use cache_readdir(FOPEN_CACHE_DIR) for
directory open when cache=always mode.
Signed-off-by: Misono Tomohiro misono.tomohiro@jp.fujitsu.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,493,2020-01-24T19:24:45Z,2020-01-25T10:17:09Z,2020-01-25T10:17:10Z,MERGED,True,20,8,1,https://github.com/algrebe,"Fixes 477, optional src_dir in tst_(rmdir,unlink)",1,[],https://github.com/libfuse/libfuse/pull/493,https://github.com/algrebe,1,https://github.com/libfuse/libfuse/pull/493,"tst_rmdir and tst_unlink now pass for passthrough_hp.
Previously, tst_rmdir and tst_unlink created the directory / file
using src_dir, causing the test to fail as the cache was stale.
Now, the src_dir is optional. When cache is enabled, tst_rmdir
and tst_unlink do not provide a src_dir, forcing the test to
use mnt_dir itself.","tst_rmdir and tst_unlink now pass for passthrough_hp.
Previously, tst_rmdir and tst_unlink created the directory / file
using src_dir, causing the test to fail as the cache was stale.
Now, the src_dir is optional. When cache is enabled, tst_rmdir
and tst_unlink do not provide a src_dir, forcing the test to
use mnt_dir itself.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,494,2020-01-27T12:57:51Z,2020-01-27T16:13:12Z,2020-01-27T16:54:41Z,MERGED,True,6,6,3,https://github.com/zsugabubus,Remove trailing comma in enums,1,[],https://github.com/libfuse/libfuse/pull/494,https://github.com/zsugabubus,1,https://github.com/libfuse/libfuse/pull/494,I got hit by compiler errors. They are illegal in C89/90.,I got hit by compiler errors. They are illegal in C89/90.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/tianshan,1,https://github.com/libfuse/libfuse/pull/495,Signed-off-by: Tianshan Qu qutianshan@gmail.com,Signed-off-by: Tianshan Qu qutianshan@gmail.com,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/495#issuecomment-580331288,Signed-off-by: Tianshan Qu qutianshan@gmail.com,Why is this more efficient?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/tianshan,3,https://github.com/libfuse/libfuse/pull/495#issuecomment-580589480,Signed-off-by: Tianshan Qu qutianshan@gmail.com,@Nikratio bitwise AND is faster than mod operator,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/trapexit,4,https://github.com/libfuse/libfuse/pull/495#issuecomment-580693723,Signed-off-by: Tianshan Qu qutianshan@gmail.com,"Yes, but 1) have you ensured that the table is always a power of 2? 2) Unless the hash is called very often it won't really matter in practice on modern machines.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/tianshan,5,https://github.com/libfuse/libfuse/pull/495#issuecomment-580753763,Signed-off-by: Tianshan Qu qutianshan@gmail.com,"@trapexit

the initialize value is hard coded 8192 (NODE_TABLE_MIN_SIZE) assign in node_table_init,  table grow is always double in node_table_resize, table reduce is halved in node_table_reduce
id_hash and name_hash are called each request in lookup phase.
but indeed, the optimize is so little to observe in test",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/jpandre,6,https://github.com/libfuse/libfuse/pull/495#issuecomment-581004088,Signed-off-by: Tianshan Qu qutianshan@gmail.com,"Consider the code below :
unsigned int mod(unsigned int w)
{
return (w % 8192);
}
gcc compiles it as :
movl    %edi, %eax
andl    $8191, %eax
ret
So gcc does the optimization when relevant.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/tianshan,7,https://github.com/libfuse/libfuse/pull/495#issuecomment-581047921,Signed-off-by: Tianshan Qu qutianshan@gmail.com,"@jpandre I think you are right, after enable compile optimization, the two ways are almost the same.
I will close this pr, thanks for yours time.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,495,2020-01-30T09:20:10Z,2020-02-01T16:53:28Z,2020-02-02T12:44:27Z,CLOSED,False,4,4,1,https://github.com/tianshan,Optimize high level id/name hash efficiency,1,[],https://github.com/libfuse/libfuse/pull/495,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/495#issuecomment-581131948,Signed-off-by: Tianshan Qu qutianshan@gmail.com,"I'm not surprised that GCC optimizes division by a hardcoded value, but I doubt that it will do the same if the divisor is variable (as in the code). It's rather unlikely that static analysis can tell that f->id_table.size will always be a power of two, and checking this at runtime would incur an extra penalty.
The reason I haven't applied this yet is that I it makes the code depend on the table size being a power of two. This is currently true, but people may change it without realizing that this is a hidden requirement.
If someone wants to push this, then the best way forward would probably be to store just the exponent of the table size, which would make the requirement explicit.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,496,2020-01-30T13:19:37Z,2020-01-30T16:17:26Z,2020-01-30T16:30:45Z,MERGED,True,13,13,13,https://github.com/zsugabubus,examples: mark ops variables constant,1,[],https://github.com/libfuse/libfuse/pull/496,https://github.com/zsugabubus,1,https://github.com/libfuse/libfuse/pull/496,"Placing 400 bytes read-only data into data segment is not so good, especially in examples.","Placing 400 bytes read-only data into data segment is not so good, especially in examples.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,497,2020-01-31T13:25:03Z,2020-01-31T18:38:42Z,2020-01-31T18:38:42Z,MERGED,True,4,3,1,https://github.com/fweimer,Update comment for the copy_file_range operation,1,[],https://github.com/libfuse/libfuse/pull/497,https://github.com/fweimer,1,https://github.com/libfuse/libfuse/pull/497,"copy_file_range was first implemented with copy-based emulation in
glibc 2.27, but the emulation was subsequently removed again because
correct emulation depends on why the application attempted to make a
copy.  Therefore, file systems cannot rely on low-level userspace
performing emulation.","copy_file_range was first implemented with copy-based emulation in
glibc 2.27, but the emulation was subsequently removed again because
correct emulation depends on why the application attempted to make a
copy.  Therefore, file systems cannot rely on low-level userspace
performing emulation.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,498,2020-02-04T04:55:11Z,2020-02-04T14:57:26Z,2020-02-04T14:57:26Z,MERGED,True,1,0,1,https://github.com/maxice8,Include limits.h because of PATH_MAX usage.,1,[],https://github.com/libfuse/libfuse/pull/498,https://github.com/maxice8,1,https://github.com/libfuse/libfuse/pull/498,Fixes build with musl libc on Alpine Linux.,Fixes build with musl libc on Alpine Linux.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,500,2020-02-11T08:21:04Z,2020-03-13T16:48:10Z,2020-03-14T10:34:50Z,MERGED,True,1,1,1,https://github.com/gaul,Align help options,1,[],https://github.com/libfuse/libfuse/pull/500,https://github.com/gaul,1,https://github.com/libfuse/libfuse/pull/500,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,501,2020-02-17T14:07:08Z,2020-02-24T21:42:42Z,2020-02-24T21:42:42Z,MERGED,True,0,2,1,https://github.com/philmd,Trivial fix reported by Clang static analyzer,1,[],https://github.com/libfuse/libfuse/pull/501,https://github.com/philmd,1,https://github.com/libfuse/libfuse/pull/501,"Upstreamed from:
https://lists.gnu.org/archive/html/qemu-devel/2020-02/msg04176.html","Upstreamed from:
https://lists.gnu.org/archive/html/qemu-devel/2020-02/msg04176.html",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,502,2020-02-18T06:04:35Z,2020-02-24T21:41:29Z,2020-02-24T21:41:29Z,MERGED,True,1,0,1,https://github.com/philmd,Travis-CI: Fix ImportError: No module named 'zipp',1,[],https://github.com/libfuse/libfuse/pull/502,https://github.com/philmd,1,https://github.com/libfuse/libfuse/pull/502,"Upgrade pip to fix [*]:
[66/66] Linking target example/passthrough_hp.
Traceback (most recent call last):
File ""/usr/lib/python3.5/runpy.py"", line 174, in _run_module_as_main
mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
File ""/usr/lib/python3.5/runpy.py"", line 133, in _get_module_details
return _get_module_details(pkg_main_name, error)
File ""/usr/lib/python3.5/runpy.py"", line 109, in _get_module_details
import(pkg_name)
File ""/usr/local/lib/python3.5/dist-packages/pytest/init.py"", line 6, in 
from _pytest.assertion import register_assert_rewrite
File ""/usr/local/lib/python3.5/dist-packages/_pytest/assertion/init.py"", line 7, in 
from _pytest.assertion import rewrite
File ""/usr/local/lib/python3.5/dist-packages/_pytest/assertion/rewrite.py"", line 24, in 
from _pytest.assertion import util
File ""/usr/local/lib/python3.5/dist-packages/_pytest/assertion/util.py"", line 14, in 
import _pytest._code
File ""/usr/local/lib/python3.5/dist-packages/_pytest/_code/init.py"", line 2, in 
from .code import Code  # noqa
File ""/usr/local/lib/python3.5/dist-packages/_pytest/_code/code.py"", line 28, in 
import pluggy
File ""/usr/local/lib/python3.5/dist-packages/pluggy/init.py"", line 16, in 
from .manager import PluginManager, PluginValidationError
File ""/usr/local/lib/python3.5/dist-packages/pluggy/manager.py"", line 11, in 
import importlib_metadata
File ""/usr/local/lib/python3.5/dist-packages/importlib_metadata/init.py"", line 9, in 
import zipp
ImportError: No module named 'zipp'
The command ""test/travis-build.sh"" exited with 1.
[*] https://travis-ci.org/libfuse/libfuse/builds/651523034
Signed-off-by: Philippe Mathieu-Daudé philmd@redhat.com","Upgrade pip to fix [*]:
[66/66] Linking target example/passthrough_hp.
Traceback (most recent call last):
File ""/usr/lib/python3.5/runpy.py"", line 174, in _run_module_as_main
mod_name, mod_spec, code = _get_module_details(mod_name, _Error)
File ""/usr/lib/python3.5/runpy.py"", line 133, in _get_module_details
return _get_module_details(pkg_main_name, error)
File ""/usr/lib/python3.5/runpy.py"", line 109, in _get_module_details
import(pkg_name)
File ""/usr/local/lib/python3.5/dist-packages/pytest/init.py"", line 6, in 
from _pytest.assertion import register_assert_rewrite
File ""/usr/local/lib/python3.5/dist-packages/_pytest/assertion/init.py"", line 7, in 
from _pytest.assertion import rewrite
File ""/usr/local/lib/python3.5/dist-packages/_pytest/assertion/rewrite.py"", line 24, in 
from _pytest.assertion import util
File ""/usr/local/lib/python3.5/dist-packages/_pytest/assertion/util.py"", line 14, in 
import _pytest._code
File ""/usr/local/lib/python3.5/dist-packages/_pytest/_code/init.py"", line 2, in 
from .code import Code  # noqa
File ""/usr/local/lib/python3.5/dist-packages/_pytest/_code/code.py"", line 28, in 
import pluggy
File ""/usr/local/lib/python3.5/dist-packages/pluggy/init.py"", line 16, in 
from .manager import PluginManager, PluginValidationError
File ""/usr/local/lib/python3.5/dist-packages/pluggy/manager.py"", line 11, in 
import importlib_metadata
File ""/usr/local/lib/python3.5/dist-packages/importlib_metadata/init.py"", line 9, in 
import zipp
ImportError: No module named 'zipp'
The command ""test/travis-build.sh"" exited with 1.
[*] https://travis-ci.org/libfuse/libfuse/builds/651523034
Signed-off-by: Philippe Mathieu-Daudé philmd@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,505,2020-02-24T10:24:30Z,2020-03-13T19:02:42Z,2020-03-13T19:02:42Z,MERGED,True,6,8,1,https://github.com/jyvet,Fix issue preventing using splice with reads,1,[],https://github.com/libfuse/libfuse/pull/505,https://github.com/jyvet,1,https://github.com/libfuse/libfuse/pull/505,"Context: SPLICE_WRITE is not used with regular buffers
(i.e. when they are not file-descriptor backed buffers).
There is a bug which assumes file descriptors are used.
If the amount of data associated with those FD is lower
than twice the page size, SPLICE_WRITE is not utilized.
With regular buffers the aggregated size is always 0.
This patch prevents to fallback to non-splice enabled
copies if FD total size is equal to 0 (basically no
copy involving FDs).","Context: SPLICE_WRITE is not used with regular buffers
(i.e. when they are not file-descriptor backed buffers).
There is a bug which assumes file descriptors are used.
If the amount of data associated with those FD is lower
than twice the page size, SPLICE_WRITE is not utilized.
With regular buffers the aggregated size is always 0.
This patch prevents to fallback to non-splice enabled
copies if FD total size is equal to 0 (basically no
copy involving FDs).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,505,2020-02-24T10:24:30Z,2020-03-13T19:02:42Z,2020-03-13T19:02:42Z,MERGED,True,6,8,1,https://github.com/jyvet,Fix issue preventing using splice with reads,1,[],https://github.com/libfuse/libfuse/pull/505,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/505#issuecomment-590564480,"Context: SPLICE_WRITE is not used with regular buffers
(i.e. when they are not file-descriptor backed buffers).
There is a bug which assumes file descriptors are used.
If the amount of data associated with those FD is lower
than twice the page size, SPLICE_WRITE is not utilized.
With regular buffers the aggregated size is always 0.
This patch prevents to fallback to non-splice enabled
copies if FD total size is equal to 0 (basically no
copy involving FDs).","I don't quite understand. If the source is a regular buffer, splicing doesn't make any sense. As splice(2) says: ""splice()  moves data between two file descriptors without copying between kernel address space and user address space"".
Am I missing something here?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,505,2020-02-24T10:24:30Z,2020-03-13T19:02:42Z,2020-03-13T19:02:42Z,MERGED,True,6,8,1,https://github.com/jyvet,Fix issue preventing using splice with reads,1,[],https://github.com/libfuse/libfuse/pull/505,https://github.com/jyvet,3,https://github.com/libfuse/libfuse/pull/505#issuecomment-590971307,"Context: SPLICE_WRITE is not used with regular buffers
(i.e. when they are not file-descriptor backed buffers).
There is a bug which assumes file descriptors are used.
If the amount of data associated with those FD is lower
than twice the page size, SPLICE_WRITE is not utilized.
With regular buffers the aggregated size is always 0.
This patch prevents to fallback to non-splice enabled
copies if FD total size is equal to 0 (basically no
copy involving FDs).","Thank you for your comment. It works in that case because of the vmsplice (splice user pages to/from a pipe) call in lib/fuse_lowlevel.c.
We are using this capability with IME burst buffer.
I'll resubmit another version today. I think we should keep the 2 pages limit (as using splice calls on small sizes may decrease performance).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,505,2020-02-24T10:24:30Z,2020-03-13T19:02:42Z,2020-03-13T19:02:42Z,MERGED,True,6,8,1,https://github.com/jyvet,Fix issue preventing using splice with reads,1,[],https://github.com/libfuse/libfuse/pull/505,https://github.com/jyvet,4,https://github.com/libfuse/libfuse/pull/505#issuecomment-592513132,"Context: SPLICE_WRITE is not used with regular buffers
(i.e. when they are not file-descriptor backed buffers).
There is a bug which assumes file descriptors are used.
If the amount of data associated with those FD is lower
than twice the page size, SPLICE_WRITE is not utilized.
With regular buffers the aggregated size is always 0.
This patch prevents to fallback to non-splice enabled
copies if FD total size is equal to 0 (basically no
copy involving FDs).","Sorry for the delay. Here are some results with a parallel burst buffer using FUSE (vmsplice + splice from/to user space buffers).
IOR with 10 MPI tasks, 40s runs, 5 iterations (single client node with fuse on Centos 7.6, NUMA affinity set):

4K random with splice:
Max Write: 681.28 MiB/sec (714.38 MB/sec)
Max Read:  331.25 MiB/sec (347.34 MB/sec)

4K random without splice:
Max Write: 584.35 MiB/sec (612.74 MB/sec)
Max Read:  321.47 MiB/sec (337.09 MB/sec)

512B random with splice:
Max Write: 60.41 MiB/sec (63.34 MB/sec)
Max Read:  40.81 MiB/sec (42.79 MB/sec)

512B random without splice:
Max Write: 87.39 MiB/sec (91.64 MB/sec)
Max Read:  47.51 MiB/sec (49.82 MB/sec)

It confirms using splice brings overheads on small sizes.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,511,2020-04-20T16:57:18Z,2020-04-20T19:20:20Z,2020-04-20T19:20:20Z,MERGED,True,2,2,2,https://github.com/ffontaine,meson.build: libfuse is a C only project,1,[],https://github.com/libfuse/libfuse/pull/511,https://github.com/ffontaine,1,https://github.com/libfuse/libfuse/pull/511,"Do not mandate cpp otherwise build without a C++ compiler will fail on:
../output-1/build/libfuse3-3.9.1/meson.build:1:0: ERROR: Unknown compiler(s): [['/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++']]
The follow exceptions were encountered:
Running ""/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++ --version"" gave ""[Errno 2] No such file or directory: '/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++'""

Fixes:

http://autobuild.buildroot.org/results/a6e64213f2910b2b81e79cb1e96e558413d7f70a

Signed-off-by: Fabrice Fontaine fontaine.fabrice@gmail.com","Do not mandate cpp otherwise build without a C++ compiler will fail on:
../output-1/build/libfuse3-3.9.1/meson.build:1:0: ERROR: Unknown compiler(s): [['/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++']]
The follow exceptions were encountered:
Running ""/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++ --version"" gave ""[Errno 2] No such file or directory: '/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++'""

Fixes:

http://autobuild.buildroot.org/results/a6e64213f2910b2b81e79cb1e96e558413d7f70a

Signed-off-by: Fabrice Fontaine fontaine.fabrice@gmail.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,511,2020-04-20T16:57:18Z,2020-04-20T19:20:20Z,2020-04-20T19:20:20Z,MERGED,True,2,2,2,https://github.com/ffontaine,meson.build: libfuse is a C only project,1,[],https://github.com/libfuse/libfuse/pull/511,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/511#issuecomment-616714900,"Do not mandate cpp otherwise build without a C++ compiler will fail on:
../output-1/build/libfuse3-3.9.1/meson.build:1:0: ERROR: Unknown compiler(s): [['/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++']]
The follow exceptions were encountered:
Running ""/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++ --version"" gave ""[Errno 2] No such file or directory: '/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++'""

Fixes:

http://autobuild.buildroot.org/results/a6e64213f2910b2b81e79cb1e96e558413d7f70a

Signed-off-by: Fabrice Fontaine fontaine.fabrice@gmail.com",It looks like your patch breaks the build - could you take another look?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,511,2020-04-20T16:57:18Z,2020-04-20T19:20:20Z,2020-04-20T19:20:20Z,MERGED,True,2,2,2,https://github.com/ffontaine,meson.build: libfuse is a C only project,1,[],https://github.com/libfuse/libfuse/pull/511,https://github.com/ffontaine,3,https://github.com/libfuse/libfuse/pull/511#issuecomment-616755471,"Do not mandate cpp otherwise build without a C++ compiler will fail on:
../output-1/build/libfuse3-3.9.1/meson.build:1:0: ERROR: Unknown compiler(s): [['/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++']]
The follow exceptions were encountered:
Running ""/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++ --version"" gave ""[Errno 2] No such file or directory: '/home/buildroot/autobuild/instance-2/output-1/host/bin/microblazeel-buildroot-linux-uclibc-g++'""

Fixes:

http://autobuild.buildroot.org/results/a6e64213f2910b2b81e79cb1e96e558413d7f70a

Signed-off-by: Fabrice Fontaine fontaine.fabrice@gmail.com",PR has been updated to fix travis build. FreeBSD failure is not related to this PR.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,514,2020-05-14T14:33:14Z,2020-05-14T19:17:51Z,2020-05-14T19:17:51Z,MERGED,True,14,139,2,https://github.com/szmi,passthrough_ll: remove symlink fallbacks,2,[],https://github.com/libfuse/libfuse/pull/514,https://github.com/szmi,1,https://github.com/libfuse/libfuse/pull/514,"Path lookup in the kernel has special rules for looking up magic symlinks
under /proc.  If a filesystem operation is instructed to follow symlinks
(e.g. via AT_SYMLINK_FOLLOW or lack of AT_SYMLINK_NOFOLLOW), and the final
component is such a proc symlink, then the target of the magic symlink is
used for the operation, even if the target itself is a symlink.  I.e. path
lookup is always terminated after following a final magic symlink.
I was erronously assuming that in the above case the target symlink would
also be followed, and so workarounds were added for a couple of operations
to handle the symlink case.  Since the symlink can be handled simply by
following the proc symlink, these workardouds are not needed.
Signed-off-by: Miklos Szeredi mszeredi@redhat.com","Path lookup in the kernel has special rules for looking up magic symlinks
under /proc.  If a filesystem operation is instructed to follow symlinks
(e.g. via AT_SYMLINK_FOLLOW or lack of AT_SYMLINK_NOFOLLOW), and the final
component is such a proc symlink, then the target of the magic symlink is
used for the operation, even if the target itself is a symlink.  I.e. path
lookup is always terminated after following a final magic symlink.
I was erronously assuming that in the above case the target symlink would
also be followed, and so workarounds were added for a couple of operations
to handle the symlink case.  Since the symlink can be handled simply by
following the proc symlink, these workardouds are not needed.
Signed-off-by: Miklos Szeredi mszeredi@redhat.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,514,2020-05-14T14:33:14Z,2020-05-14T19:17:51Z,2020-05-14T19:17:51Z,MERGED,True,14,139,2,https://github.com/szmi,passthrough_ll: remove symlink fallbacks,2,[],https://github.com/libfuse/libfuse/pull/514,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/514#issuecomment-628824727,"Path lookup in the kernel has special rules for looking up magic symlinks
under /proc.  If a filesystem operation is instructed to follow symlinks
(e.g. via AT_SYMLINK_FOLLOW or lack of AT_SYMLINK_NOFOLLOW), and the final
component is such a proc symlink, then the target of the magic symlink is
used for the operation, even if the target itself is a symlink.  I.e. path
lookup is always terminated after following a final magic symlink.
I was erronously assuming that in the above case the target symlink would
also be followed, and so workarounds were added for a couple of operations
to handle the symlink case.  Since the symlink can be handled simply by
following the proc symlink, these workardouds are not needed.
Signed-off-by: Miklos Szeredi mszeredi@redhat.com",Thanks! Would you have time to also update examples/passthrough_hp.cc?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,515,2020-05-15T03:03:14Z,2020-05-15T18:34:32Z,2020-05-15T19:49:44Z,MERGED,True,1,1,1,https://github.com/neheb,fix format in test,1,[],https://github.com/libfuse/libfuse/pull/515,https://github.com/neheb,1,https://github.com/libfuse/libfuse/pull/515,Fixes warning under 32-bit.,Fixes warning under 32-bit.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,516,2020-05-15T15:59:36Z,2020-05-15T18:32:10Z,2020-05-15T18:32:10Z,MERGED,True,1,0,1,https://github.com/Vogtinator,Avoid closing se->fd twice in fuse_lowlevel.c,1,[],https://github.com/libfuse/libfuse/pull/516,https://github.com/Vogtinator,1,https://github.com/libfuse/libfuse/pull/516,"If fuse_session_unmount is called before fuse_session_destroy, both
would try to close(se->fd). Avoid that by resetting it in
fuse_session_unmount.","If fuse_session_unmount is called before fuse_session_destroy, both
would try to close(se->fd). Avoid that by resetting it in
fuse_session_unmount.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,519,2020-06-18T00:15:23Z,2020-07-03T11:39:10Z,2020-07-03T11:39:10Z,MERGED,True,1,1,1,https://github.com/hselin-kalista-io,Minor print alignment in iconv_help(),1,[],https://github.com/libfuse/libfuse/pull/519,https://github.com/hselin-kalista-io,1,https://github.com/libfuse/libfuse/pull/519,"Fixed minor print alignment issue in iconv_help(), replacing tab with space
Old

New","Fixed minor print alignment issue in iconv_help(), replacing tab with space
Old

New",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,520,2020-06-22T02:05:07Z,2020-06-22T05:27:59Z,2020-06-22T05:27:59Z,MERGED,True,1,1,1,https://github.com/yeonsh,Typo fixed.,1,[],https://github.com/libfuse/libfuse/pull/520,https://github.com/yeonsh,1,https://github.com/libfuse/libfuse/pull/520,Fixed a typo.,Fixed a typo.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,522,2020-07-01T03:50:37Z,2020-07-01T05:20:02Z,2020-07-01T05:20:02Z,MERGED,True,1,0,1,https://github.com/winndows,"libfuse: Assign NULL to ""old"" to avoid free it twice",1,[],https://github.com/libfuse/libfuse/pull/522,https://github.com/winndows,1,https://github.com/libfuse/libfuse/pull/522,"Assign NULL to ""old"" at the first free(), to avoid the possible 2nd free() for it.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Assign NULL to ""old"" at the first free(), to avoid the possible 2nd free() for it.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,523,2020-07-01T08:46:00Z,2020-07-02T01:20:18Z,2020-07-02T01:20:18Z,CLOSED,False,1,3,2,https://github.com/winndows,fuse_lowlevel: Remove useless NULL assert for se,2,[],https://github.com/libfuse/libfuse/pull/523,https://github.com/winndows,1,https://github.com/libfuse/libfuse/pull/523,"Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,524,2020-07-02T01:51:20Z,2020-07-03T11:30:41Z,2020-07-03T11:30:41Z,MERGED,True,1,1,1,https://github.com/winndows,"Fix the typo ""filed"" -> ""field"" in fuse manpage",1,[],https://github.com/libfuse/libfuse/pull/524,https://github.com/winndows,1,https://github.com/libfuse/libfuse/pull/524,"Fix the typo ""filed"" -> ""field"" in fuse manpage.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Fix the typo ""filed"" -> ""field"" in fuse manpage.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,525,2020-07-02T02:26:23Z,2020-07-11T06:20:17Z,2020-07-11T06:22:58Z,CLOSED,False,0,2,1,https://github.com/winndows,fuse_lowlevel: Remove useless NULL assert for se,1,[],https://github.com/libfuse/libfuse/pull/525,https://github.com/winndows,1,https://github.com/libfuse/libfuse/pull/525,"Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,525,2020-07-02T02:26:23Z,2020-07-11T06:20:17Z,2020-07-11T06:22:58Z,CLOSED,False,0,2,1,https://github.com/winndows,fuse_lowlevel: Remove useless NULL assert for se,1,[],https://github.com/libfuse/libfuse/pull/525,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/525#issuecomment-653502147,"Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",Could you explain why this is useless?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,525,2020-07-02T02:26:23Z,2020-07-11T06:20:17Z,2020-07-11T06:22:58Z,CLOSED,False,0,2,1,https://github.com/winndows,fuse_lowlevel: Remove useless NULL assert for se,1,[],https://github.com/libfuse/libfuse/pull/525,https://github.com/winndows,3,https://github.com/libfuse/libfuse/pull/525#issuecomment-653733825,"Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Could you explain why this is useless?

If se is NULL, line 171: ""if (se->debug) {"" in this file will dereference NULL pointer.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,525,2020-07-02T02:26:23Z,2020-07-11T06:20:17Z,2020-07-11T06:22:58Z,CLOSED,False,0,2,1,https://github.com/winndows,fuse_lowlevel: Remove useless NULL assert for se,1,[],https://github.com/libfuse/libfuse/pull/525,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/525#issuecomment-656835065,"Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","That's actually a bug above, then. Probably the assert should go there, or the check for se->debug should first check for se !+= NULL.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,525,2020-07-02T02:26:23Z,2020-07-11T06:20:17Z,2020-07-11T06:22:58Z,CLOSED,False,0,2,1,https://github.com/winndows,fuse_lowlevel: Remove useless NULL assert for se,1,[],https://github.com/libfuse/libfuse/pull/525,https://github.com/winndows,5,https://github.com/libfuse/libfuse/pull/525#issuecomment-656999870,"Remove useless NULL assert for se.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",move assert for se before se->debug check,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,526,2020-07-02T03:33:10Z,2020-07-03T11:29:48Z,2020-07-03T11:29:48Z,MERGED,True,1,1,1,https://github.com/winndows,README: Correct the directory name from 'examples' to 'example',1,[],https://github.com/libfuse/libfuse/pull/526,https://github.com/winndows,1,https://github.com/libfuse/libfuse/pull/526,"Correct the directory name from 'examples' to 'example' in readme.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Correct the directory name from 'examples' to 'example' in readme.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,528,2020-07-03T05:21:39Z,2020-07-03T11:28:06Z,2020-07-03T11:28:06Z,MERGED,True,4,4,1,https://github.com/craig08,docs: Replace `mesonconf` with `meson configure`,1,[],https://github.com/libfuse/libfuse/pull/528,https://github.com/craig08,1,https://github.com/libfuse/libfuse/pull/528,Fixes #527,Fixes #527,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,529,2020-07-04T03:44:13Z,2020-07-10T18:59:58Z,2020-07-10T18:59:59Z,MERGED,True,9,4,1,https://github.com/jgalar,Fix: crash on failure to set locale,1,[],https://github.com/libfuse/libfuse/pull/529,https://github.com/jgalar,1,https://github.com/libfuse/libfuse/pull/529,"Problem description
setlocale() can fail, returning NULL, if the user has an invalid (or missing) locale set in the LANG environment variable.
In my case, this happens when using VS Code's integrated terminal to launch a fuse-based filesystem. A bug (fix upcoming) results in VS Code setting an invalid locale.
iconv_help() currently passes the return value of setlocale(...) directly to strdup() without checking if it is NULL, resulting in a crash.
How to reproduce
To reproduce, simply set LANG=""something_invalid"" and call fuse_lib_help().
Stack trace when the process receives SIGSEGV:
(gdb) bt
 #0  0x00007fabd0fcc4b5 in __strlen_avx2 () from /usr/lib/libc.so.6
 #1  0x00007fabd0ef9233 in strdup () from /usr/lib/libc.so.6
 #2  0x00007fabd13b8128 in iconv_help () at ../lib/modules/iconv.c:641
 #3  0x00007fabd13b81a8 in iconv_opt_proc (data=0x55580a6ee850, arg=0x55580a6edfb0 ""-h"", key=0, outargs=0x7ffeeb1a8ec8) at ../lib/modules/iconv.c:658
 #4  0x00007fabd13af7d5 in call_proc (ctx=0x7ffeeb1a8ea0, arg=0x55580a6edfb0 ""-h"", key=0, iso=0) at ../lib/fuse_opt.c:161
 #5  0x00007fabd13afaf1 in process_opt (ctx=0x7ffeeb1a8ea0, opt=0x7fabd13c3d40 <iconv_opts>, sep=0, arg=0x55580a6edfb0 ""-h"", iso=0) at ../lib/fuse_opt.c:233
 #6  0x00007fabd13afd5a in process_gopt (ctx=0x7ffeeb1a8ea0, arg=0x55580a6edfb0 ""-h"", iso=0) at ../lib/fuse_opt.c:285
 #7  0x00007fabd13b0117 in process_one (ctx=0x7ffeeb1a8ea0, arg=0x55580a6edfb0 ""-h"") at ../lib/fuse_opt.c:368
 #8  0x00007fabd13b0190 in opt_parse (ctx=0x7ffeeb1a8ea0) at ../lib/fuse_opt.c:379
 #9  0x00007fabd13b03d3 in fuse_opt_parse (args=0x7ffeeb1a8f70, data=0x55580a6ee850, opts=0x7fabd13c3d40 <iconv_opts>, proc=0x7fabd13b8186 <iconv_opt_proc>)
    at ../lib/fuse_opt.c:414
 #10 0x00007fabd13b8226 in iconv_new (args=0x7ffeeb1a8f70, next=0x0) at ../lib/modules/iconv.c:680
 #11 0x00007fabd13a5627 in print_module_help (name=0x7fabd13b9e1c ""iconv"", fac=0x7fabd13d48e0 <fuse_module_iconv_factory>) at ../lib/fuse.c:4692
 #12 0x00007fabd13a56aa in fuse_lib_help (args=0x7ffeeb1a9238) at ../lib/fuse.c:4721

Fix
iconv_help() is modified to print an error when setlocale() fails. It then carries on printing the iconv module's help.
Reading setlocale(3), it seems that the strdup() of the result was not necessary.","Problem description
setlocale() can fail, returning NULL, if the user has an invalid (or missing) locale set in the LANG environment variable.
In my case, this happens when using VS Code's integrated terminal to launch a fuse-based filesystem. A bug (fix upcoming) results in VS Code setting an invalid locale.
iconv_help() currently passes the return value of setlocale(...) directly to strdup() without checking if it is NULL, resulting in a crash.
How to reproduce
To reproduce, simply set LANG=""something_invalid"" and call fuse_lib_help().
Stack trace when the process receives SIGSEGV:
(gdb) bt
 #0  0x00007fabd0fcc4b5 in __strlen_avx2 () from /usr/lib/libc.so.6
 #1  0x00007fabd0ef9233 in strdup () from /usr/lib/libc.so.6
 #2  0x00007fabd13b8128 in iconv_help () at ../lib/modules/iconv.c:641
 #3  0x00007fabd13b81a8 in iconv_opt_proc (data=0x55580a6ee850, arg=0x55580a6edfb0 ""-h"", key=0, outargs=0x7ffeeb1a8ec8) at ../lib/modules/iconv.c:658
 #4  0x00007fabd13af7d5 in call_proc (ctx=0x7ffeeb1a8ea0, arg=0x55580a6edfb0 ""-h"", key=0, iso=0) at ../lib/fuse_opt.c:161
 #5  0x00007fabd13afaf1 in process_opt (ctx=0x7ffeeb1a8ea0, opt=0x7fabd13c3d40 <iconv_opts>, sep=0, arg=0x55580a6edfb0 ""-h"", iso=0) at ../lib/fuse_opt.c:233
 #6  0x00007fabd13afd5a in process_gopt (ctx=0x7ffeeb1a8ea0, arg=0x55580a6edfb0 ""-h"", iso=0) at ../lib/fuse_opt.c:285
 #7  0x00007fabd13b0117 in process_one (ctx=0x7ffeeb1a8ea0, arg=0x55580a6edfb0 ""-h"") at ../lib/fuse_opt.c:368
 #8  0x00007fabd13b0190 in opt_parse (ctx=0x7ffeeb1a8ea0) at ../lib/fuse_opt.c:379
 #9  0x00007fabd13b03d3 in fuse_opt_parse (args=0x7ffeeb1a8f70, data=0x55580a6ee850, opts=0x7fabd13c3d40 <iconv_opts>, proc=0x7fabd13b8186 <iconv_opt_proc>)
    at ../lib/fuse_opt.c:414
 #10 0x00007fabd13b8226 in iconv_new (args=0x7ffeeb1a8f70, next=0x0) at ../lib/modules/iconv.c:680
 #11 0x00007fabd13a5627 in print_module_help (name=0x7fabd13b9e1c ""iconv"", fac=0x7fabd13d48e0 <fuse_module_iconv_factory>) at ../lib/fuse.c:4692
 #12 0x00007fabd13a56aa in fuse_lib_help (args=0x7ffeeb1a9238) at ../lib/fuse.c:4721

Fix
iconv_help() is modified to print an error when setlocale() fails. It then carries on printing the iconv module's help.
Reading setlocale(3), it seems that the strdup() of the result was not necessary.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,530,2020-07-08T02:35:53Z,2020-07-10T18:58:08Z,2020-07-10T18:58:08Z,MERGED,True,1,2,1,https://github.com/winndows,fuse_lowlevel: Move assert for se before dereferencing it with se->debug,1,[],https://github.com/libfuse/libfuse/pull/530,https://github.com/winndows,1,https://github.com/libfuse/libfuse/pull/530,"Move assert for se before dereferencing it with se->debug.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn","Move assert for se before dereferencing it with se->debug.
Signed-off-by: Liao Pingfang liao.pingfang@zte.com.cn",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,532,2020-07-11T09:54:49Z,2020-08-09T11:37:27Z,2020-08-09T11:37:27Z,MERGED,True,6,0,2,https://github.com/asafkahlon,Define fuse_session_loop_mt as a macro on uclibc and MacOS,3,[],https://github.com/libfuse/libfuse/pull/532,https://github.com/asafkahlon,1,https://github.com/libfuse/libfuse/pull/532,"On uclibc and MacOS we don't use versioned symbols. Hence,
there's no definition for fuse_session_loop_mt on those cases
and the linker won't be able to resolve calls to fuse_session_loop_mt()
Signed-off-by: Asaf Kahlon asafka7@gmail.com","On uclibc and MacOS we don't use versioned symbols. Hence,
there's no definition for fuse_session_loop_mt on those cases
and the linker won't be able to resolve calls to fuse_session_loop_mt()
Signed-off-by: Asaf Kahlon asafka7@gmail.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,532,2020-07-11T09:54:49Z,2020-08-09T11:37:27Z,2020-08-09T11:37:27Z,MERGED,True,6,0,2,https://github.com/asafkahlon,Define fuse_session_loop_mt as a macro on uclibc and MacOS,3,[],https://github.com/libfuse/libfuse/pull/532,https://github.com/asafkahlon,2,https://github.com/libfuse/libfuse/pull/532#issuecomment-666967530,"On uclibc and MacOS we don't use versioned symbols. Hence,
there's no definition for fuse_session_loop_mt on those cases
and the linker won't be able to resolve calls to fuse_session_loop_mt()
Signed-off-by: Asaf Kahlon asafka7@gmail.com","@yann-morin-1998 fixed your comments, thanks.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,533,2020-07-11T09:58:22Z,2021-06-09T08:07:25Z,2021-06-09T08:07:25Z,MERGED,True,8,1,2,https://github.com/asafkahlon,Add an option to disable building tests,1,[],https://github.com/libfuse/libfuse/pull/533,https://github.com/asafkahlon,1,https://github.com/libfuse/libfuse/pull/533,Signed-off-by: Asaf Kahlon asafka7@gmail.com,Signed-off-by: Asaf Kahlon asafka7@gmail.com,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,533,2020-07-11T09:58:22Z,2021-06-09T08:07:25Z,2021-06-09T08:07:25Z,MERGED,True,8,1,2,https://github.com/asafkahlon,Add an option to disable building tests,1,[],https://github.com/libfuse/libfuse/pull/533,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/533#issuecomment-671041030,Signed-off-by: Asaf Kahlon asafka7@gmail.com,Thanks for the patch! Can you explain the use-case in which not compiling (and thus running) the tests is desirable?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,533,2020-07-11T09:58:22Z,2021-06-09T08:07:25Z,2021-06-09T08:07:25Z,MERGED,True,8,1,2,https://github.com/asafkahlon,Add an option to disable building tests,1,[],https://github.com/libfuse/libfuse/pull/533,https://github.com/asafkahlon,3,https://github.com/libfuse/libfuse/pull/533#issuecomment-671071620,Signed-off-by: Asaf Kahlon asafka7@gmail.com,"The case is not compiling and not running the tests, which is currently not possible when just invoking a regular build with meson.
If, for example, you compile an embedded linux system and you want to include libfuse in it, you don't want to compile the tests because they won't be installed on the target board.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,533,2020-07-11T09:58:22Z,2021-06-09T08:07:25Z,2021-06-09T08:07:25Z,MERGED,True,8,1,2,https://github.com/asafkahlon,Add an option to disable building tests,1,[],https://github.com/libfuse/libfuse/pull/533,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/533#issuecomment-739805264,Signed-off-by: Asaf Kahlon asafka7@gmail.com,"Not sure I follow. Tests will never be installed, no matter if embedded or not. They should still be run before installation though, to ensure that everything works.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,533,2020-07-11T09:58:22Z,2021-06-09T08:07:25Z,2021-06-09T08:07:25Z,MERGED,True,8,1,2,https://github.com/asafkahlon,Add an option to disable building tests,1,[],https://github.com/libfuse/libfuse/pull/533,https://github.com/asafkahlon,5,https://github.com/libfuse/libfuse/pull/533#issuecomment-740103619,Signed-off-by: Asaf Kahlon asafka7@gmail.com,"@Nikratio Yeah, I know the tests won't be installed, but why would you want to compile them over and over again unless explicitly asked?
Anyway, you need to explicitly run another command in order to run the tests, so I don't think we should compile them if we don't have an intention to actually run them too.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,535,2020-07-14T01:38:49Z,2020-07-15T09:51:13Z,2020-07-15T09:51:14Z,CLOSED,False,1220,0,2,https://github.com/west90xy,West90xy patch 1,2,[],https://github.com/libfuse/libfuse/pull/535,https://github.com/west90xy,1,https://github.com/libfuse/libfuse/pull/535,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,535,2020-07-14T01:38:49Z,2020-07-15T09:51:13Z,2020-07-15T09:51:14Z,CLOSED,False,1220,0,2,https://github.com/west90xy,West90xy patch 1,2,[],https://github.com/libfuse/libfuse/pull/535,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/535#issuecomment-658669652,,"I assume this was opened by mistake? If not, could you please elaborate on the purpose of the patch?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,536,2020-07-28T15:19:24Z,2020-08-09T11:35:44Z,2020-09-09T14:52:35Z,MERGED,True,1,1,1,https://github.com/AKowshik,Fixed typo in command to compile program,1,[],https://github.com/libfuse/libfuse/pull/536,https://github.com/AKowshik,1,https://github.com/libfuse/libfuse/pull/536,Fixed a typo in the command specified to compile the given program.,Fixed a typo in the command specified to compile the given program.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,537,2020-07-30T01:01:16Z,2020-08-09T11:35:28Z,2020-08-09T11:35:28Z,MERGED,True,4,4,2,https://github.com/dancerj,Doc fixes,3,[],https://github.com/libfuse/libfuse/pull/537,https://github.com/dancerj,1,https://github.com/libfuse/libfuse/pull/537,I have made some minor documentation updates. Let me know what you think!,I have made some minor documentation updates. Let me know what you think!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,539,2020-08-05T08:22:22Z,2020-08-09T11:34:59Z,2020-08-09T15:32:43Z,MERGED,True,2,2,1,https://github.com/lwhsu,Fix FreeBSD CI,1,[],https://github.com/libfuse/libfuse/pull/539,https://github.com/lwhsu,1,https://github.com/libfuse/libfuse/pull/539,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,541,2020-08-15T15:51:23Z,2020-08-16T10:10:42Z,2020-08-16T10:10:42Z,CLOSED,False,1,0,1,https://github.com/stevenwkane1,Create curlruby,1,[],https://github.com/libfuse/libfuse/pull/541,https://github.com/stevenwkane1,1,https://github.com/libfuse/libfuse/pull/541,https://github.com/s3fs-fuse/s3fs-fuse.git,https://github.com/s3fs-fuse/s3fs-fuse.git,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,541,2020-08-15T15:51:23Z,2020-08-16T10:10:42Z,2020-08-16T10:10:42Z,CLOSED,False,1,0,1,https://github.com/stevenwkane1,Create curlruby,1,[],https://github.com/libfuse/libfuse/pull/541,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/541#issuecomment-674507564,https://github.com/s3fs-fuse/s3fs-fuse.git,I assume this was opened by mistake?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/spotrh,1,https://github.com/libfuse/libfuse/pull/545,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.","Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.",True,{'THUMBS_UP': ['https://github.com/Rondom']}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/545#issuecomment-689764574,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.",Thanks! Could you maybe update the CI script (tests/travis-build.sh IIRC) to attempt a build with link time optimization to make sure this works as expected?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/spotrh,3,https://github.com/libfuse/libfuse/pull/545#issuecomment-690594586,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.","Your travis environment is using Ubuntu 16.04 LTS (Xenial). I do not believe there are gcc-10 packages (even in the compiler test ppa) for Xenial. If you move to Ubuntu 18.04 LTS (Bionic), I can add a PPA to .travis.yml and include gcc-10 in the packages list. Once that happens, I can easily update the CI script.
My testing has been on Fedora 33, but Bionic + ppa:ubuntu-toolchain-r/test should be equivalent.
Are you okay with that change?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/545#issuecomment-690622350,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.",Please feel free to update as needed. The only reason for using Xenial is probably because this was up to date when the CI was set up.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/545#issuecomment-690976136,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/545#issuecomment-690979435,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.","Hmm. Looks like this doesn't quite work (not sure why the failing CI didn't show up above):
https://travis-ci.org/github/libfuse/libfuse
Could you take another look?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/spotrh,7,https://github.com/libfuse/libfuse/pull/545#issuecomment-691125052,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.","I can... but it doesn't look like Travis generated any useful logging here:
https://travis-ci.com/github/libfuse/libfuse/builds/183868601",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,545,2020-09-08T15:11:39Z,2020-09-11T09:15:44Z,2020-09-11T17:34:30Z,MERGED,True,38,10,6,https://github.com/spotrh,Implement GCC 10 style symbol versioning,3,[],https://github.com/libfuse/libfuse/pull/545,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/545#issuecomment-691223808,"Previously, libfuse was using top level ASM constructs to implement symbol versioning. These constructs are incompatible with Link Time Optimization (LTO). GCC v10 introduces a new mechanism for symbol versioning which works with LTO.
This PR adds a meson check to verify that the build compiler supports the symver attribute and if not, falls back to the ASM constructs.
I am submitting this change on behalf of Jeff Law law@redhat.com with his permission.","That's odd - the last time I looked at it, the logs were there.
The error was something about gcc-7 complaining about -Wattributes.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,547,2020-09-09T14:41:31Z,2020-09-09T19:17:07Z,2020-09-10T12:38:39Z,MERGED,True,42,18,6,https://github.com/AKowshik,Updated example code to work with new API,1,[],https://github.com/libfuse/libfuse/pull/547,https://github.com/AKowshik,1,https://github.com/libfuse/libfuse/pull/547,Updated the example programs that would fail on updating FUSE_USE_VERSION to 34. Used the newer versions of certain functions that would cause the program to fail.,Updated the example programs that would fail on updating FUSE_USE_VERSION to 34. Used the newer versions of certain functions that would cause the program to fail.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,547,2020-09-09T14:41:31Z,2020-09-09T19:17:07Z,2020-09-10T12:38:39Z,MERGED,True,42,18,6,https://github.com/AKowshik,Updated example code to work with new API,1,[],https://github.com/libfuse/libfuse/pull/547,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/547#issuecomment-689763266,Updated the example programs that would fail on updating FUSE_USE_VERSION to 34. Used the newer versions of certain functions that would cause the program to fail.,Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,549,2020-09-11T14:39:46Z,2020-09-12T08:28:28Z,2020-09-12T08:28:28Z,MERGED,True,17,7,4,https://github.com/spotrh,Adjust .travis.yml to use ppa syntax,18,[],https://github.com/libfuse/libfuse/pull/549,https://github.com/spotrh,1,https://github.com/libfuse/libfuse/pull/549,I think this is what is confusing travis... difficult for me to test this locally though.,I think this is what is confusing travis... difficult for me to test this locally though.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,549,2020-09-11T14:39:46Z,2020-09-12T08:28:28Z,2020-09-12T08:28:28Z,MERGED,True,17,7,4,https://github.com/spotrh,Adjust .travis.yml to use ppa syntax,18,[],https://github.com/libfuse/libfuse/pull/549,https://github.com/spotrh,2,https://github.com/libfuse/libfuse/pull/549#issuecomment-691140728,I think this is what is confusing travis... difficult for me to test this locally though.,"Okay, so Travis is working again, looks like the meson check needs to be improved.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,549,2020-09-11T14:39:46Z,2020-09-12T08:28:28Z,2020-09-12T08:28:28Z,MERGED,True,17,7,4,https://github.com/spotrh,Adjust .travis.yml to use ppa syntax,18,[],https://github.com/libfuse/libfuse/pull/549,https://github.com/spotrh,3,https://github.com/libfuse/libfuse/pull/549#issuecomment-691361377,I think this is what is confusing travis... difficult for me to test this locally though.,"Well, that took longer than I thought it would. There's a few things here:

The original meson.build test was incorrect, it was reporting that it supported the symver attribute in gcc 7 when it most certainly did not. That is now fixed with a more correct sample code.
Moving from xenial to bionic broke some things. Specifically, there was a warning about an undefined marker (uses_fuse), which I defined.
The version of valgrind in bionic was throwing a WARNING because it did not know how to handle amd64 syscall 326 (copy_file_range). Upstream added that support in valgrind 3.16.1, but there was no available build of 3.16.1 for bionic... so I made a build and made a PPE for it to live in.
When I added the valgrind PPE to the list of sources for the .travis.yml, Travis started to throw errors pulling down the corresponding public key from the Ubuntu keyserver. This is an itinerant failure, sometimes it would succeed, but it looked like it was failing more often than not. Best guess is that the Ubuntu keyserver is having issues (there are lots of other people who have this issue with the Ubuntu keyserver and Travis)
So... I added some logic to manually install the public key and the updated valgrind and that seems to work all of the time.
Oh, and I also spent far too much time trying to convince the travis buld bash script to pass two options as an array to meson. Eventually gave up and just used the most important one.

Apologies for the commit spam.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,549,2020-09-11T14:39:46Z,2020-09-12T08:28:28Z,2020-09-12T08:28:28Z,MERGED,True,17,7,4,https://github.com/spotrh,Adjust .travis.yml to use ppa syntax,18,[],https://github.com/libfuse/libfuse/pull/549,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/549#issuecomment-691444669,I think this is what is confusing travis... difficult for me to test this locally though.,Thank you very much for figuring all this out!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,550,2020-09-12T12:56:51Z,2020-09-14T08:45:02Z,2020-09-14T08:45:02Z,MERGED,True,6,2,1,https://github.com/spotrh,rework this code to be correct in all known cases,1,[],https://github.com/libfuse/libfuse/pull/550,https://github.com/spotrh,1,https://github.com/libfuse/libfuse/pull/550,"Woke up this morning and realized I had not quite gotten this conditional right. If __has_attribute is not defined by the compiler, we want to #error out of the check, not pass it. This change addresses that case properly (I didn't catch it before because no modern compiler that I am aware of does not support __has_attribute, but it is possible that old Linux or non-Linux OSes would not.","Woke up this morning and realized I had not quite gotten this conditional right. If __has_attribute is not defined by the compiler, we want to #error out of the check, not pass it. This change addresses that case properly (I didn't catch it before because no modern compiler that I am aware of does not support __has_attribute, but it is possible that old Linux or non-Linux OSes would not.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,551,2020-09-16T09:25:11Z,2020-09-20T18:08:15Z,2020-09-20T18:08:15Z,MERGED,True,20,1,4,https://github.com/eduble,Allow caching symlinks in kernel page cache.,1,[],https://github.com/libfuse/libfuse/pull/551,https://github.com/eduble,1,https://github.com/libfuse/libfuse/pull/551,"This commit defines a new capability called FUSE_CAP_CACHE_SYMLINKS.
It is off by default but you can now enable it by setting this flag in
in the want field of the fuse_conn_info structure.
When enabled, the kernel will save symlinks in its page cache,
by making use of the feature introduced in kernel 4.20:
torvalds/linux@5571f1e","This commit defines a new capability called FUSE_CAP_CACHE_SYMLINKS.
It is off by default but you can now enable it by setting this flag in
in the want field of the fuse_conn_info structure.
When enabled, the kernel will save symlinks in its page cache,
by making use of the feature introduced in kernel 4.20:
torvalds/linux@5571f1e",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,551,2020-09-16T09:25:11Z,2020-09-20T18:08:15Z,2020-09-20T18:08:15Z,MERGED,True,20,1,4,https://github.com/eduble,Allow caching symlinks in kernel page cache.,1,[],https://github.com/libfuse/libfuse/pull/551,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/551#issuecomment-694440642,"This commit defines a new capability called FUSE_CAP_CACHE_SYMLINKS.
It is off by default but you can now enable it by setting this flag in
in the want field of the fuse_conn_info structure.
When enabled, the kernel will save symlinks in its page cache,
by making use of the feature introduced in kernel 4.20:
torvalds/linux@5571f1e","Thank you!
Could you please add an entry to ChangeLog.rst and expand the comment in fuse_common.h to explain how to invalidate the cached links? (I presume it's either with fuse_inval_entry or fuse_inval_ino?)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,551,2020-09-16T09:25:11Z,2020-09-20T18:08:15Z,2020-09-20T18:08:15Z,MERGED,True,20,1,4,https://github.com/eduble,Allow caching symlinks in kernel page cache.,1,[],https://github.com/libfuse/libfuse/pull/551,https://github.com/eduble,3,https://github.com/libfuse/libfuse/pull/551#issuecomment-694828627,"This commit defines a new capability called FUSE_CAP_CACHE_SYMLINKS.
It is off by default but you can now enable it by setting this flag in
in the want field of the fuse_conn_info structure.
When enabled, the kernel will save symlinks in its page cache,
by making use of the feature introduced in kernel 4.20:
torvalds/linux@5571f1e","Hi,
I amended the commit, let me know if it is OK.
Thanks
Etienne",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,553,2020-10-03T12:03:39Z,2020-10-03T12:14:00Z,2020-10-03T12:14:00Z,MERGED,True,2,2,2,https://github.com/ferivoz,"Fix typo ""retuned"" -> ""returned""",1,[],https://github.com/libfuse/libfuse/pull/553,https://github.com/ferivoz,1,https://github.com/libfuse/libfuse/pull/553,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,556,2020-10-29T02:32:37Z,2020-10-29T10:59:24Z,2020-10-29T12:04:55Z,MERGED,True,7,22,4,https://github.com/neheb,uclibc changes,2,[],https://github.com/libfuse/libfuse/pull/556,https://github.com/neheb,1,https://github.com/libfuse/libfuse/pull/556,"First commit fixes compilation with sshfs. See: libfuse/sshfs#221
Second one is a cleanup.","First commit fixes compilation with sshfs. See: libfuse/sshfs#221
Second one is a cleanup.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,558,2020-11-04T09:29:43Z,2020-11-04T18:32:55Z,2020-11-05T01:05:49Z,MERGED,True,1,1,1,https://github.com/lilohuang,Fixing incorrect datetime,1,[],https://github.com/libfuse/libfuse/pull/558,https://github.com/lilohuang,1,https://github.com/libfuse/libfuse/pull/558,It should be 2020 rather than 2010. Thanks.,It should be 2020 rather than 2010. Thanks.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,559,2020-11-05T11:12:21Z,2020-11-06T19:26:04Z,2020-11-06T19:26:04Z,MERGED,True,40,12,5,https://github.com/ZhiqiangLiu26,Fix several fd leakage problems 、memory leakage problems and accessing NULL pointer problems,6,[],https://github.com/libfuse/libfuse/pull/559,https://github.com/ZhiqiangLiu26,1,https://github.com/libfuse/libfuse/pull/559,"Coverity checker reports several kinds of problesm:

fd leakage problems
memory leakage problems
accessing NULL pointer problems

In this pr, we fix these problems to make coverity checker happy.
Signed-off-by: Zhiqiang Liu liuzhiqiang26@huawei.com
Signed-off-by: Haotian Li lihaotian9@huawei.com","Coverity checker reports several kinds of problesm:

fd leakage problems
memory leakage problems
accessing NULL pointer problems

In this pr, we fix these problems to make coverity checker happy.
Signed-off-by: Zhiqiang Liu liuzhiqiang26@huawei.com
Signed-off-by: Haotian Li lihaotian9@huawei.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,560,2020-11-11T02:12:21Z,2020-11-11T09:32:57Z,2020-11-11T09:32:57Z,MERGED,True,1,1,1,https://github.com/ZhiqiangLiu26,buffer.c: correct return value when buf is NULL,1,[],https://github.com/libfuse/libfuse/pull/560,https://github.com/ZhiqiangLiu26,1,https://github.com/libfuse/libfuse/pull/560,"In commit d614415 (""buffer.c: check whether buf is
NULL in fuse_bufvec_advance func""), if fuse_bufvec_current
func returns NULL, it returns 1 directly. Actually,
we should return 0 when buf is NULL.
Fixes: d614415 (""buffer.c: check whether buf is NULL in fuse_bufvec_advance func"")
Signed-off-by: Zhiqiang Liu liuzhiqiang26@huawei.com
Signed-off-by: Haotian Li lihaotian9@huawei.com","In commit d614415 (""buffer.c: check whether buf is
NULL in fuse_bufvec_advance func""), if fuse_bufvec_current
func returns NULL, it returns 1 directly. Actually,
we should return 0 when buf is NULL.
Fixes: d614415 (""buffer.c: check whether buf is NULL in fuse_bufvec_advance func"")
Signed-off-by: Zhiqiang Liu liuzhiqiang26@huawei.com
Signed-off-by: Haotian Li lihaotian9@huawei.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,564,2020-11-16T17:22:34Z,2020-11-17T11:06:33Z,2020-11-17T11:06:33Z,MERGED,True,1,1,1,https://github.com/huglovefan,fix errno comparison,1,[],https://github.com/libfuse/libfuse/pull/564,https://github.com/huglovefan,1,https://github.com/libfuse/libfuse/pull/564,"this affected -o remember in single-thread mode, it could prematurely exit if a signal was received
# start an example filesystem from example/
./passthrough -f -s -o remember=5 ./mnt

# make the poll() call return with EINTR
pkill -PIPE passthrough","this affected -o remember in single-thread mode, it could prematurely exit if a signal was received
# start an example filesystem from example/
./passthrough -f -s -o remember=5 ./mnt

# make the poll() call return with EINTR
pkill -PIPE passthrough",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,568,2020-11-24T04:47:27Z,2020-11-24T09:28:14Z,2020-11-24T09:43:43Z,MERGED,True,2,0,2,https://github.com/Rethan,examples/cuse_client: add include file to eliminate compiler warning,1,[],https://github.com/libfuse/libfuse/pull/568,https://github.com/Rethan,1,https://github.com/libfuse/libfuse/pull/568,"Compiler warning about close(fd), add include file to fix.
Fix issue#567
Signed-off-by: haoyixing haoyixing@kuaishou.com","Compiler warning about close(fd), add include file to fix.
Fix issue#567
Signed-off-by: haoyixing haoyixing@kuaishou.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,571,2020-12-14T02:39:04Z,2020-12-14T10:16:06Z,2020-12-14T10:16:06Z,MERGED,True,1,1,1,https://github.com/gaul,Correct errno comparison,1,[],https://github.com/libfuse/libfuse/pull/571,https://github.com/gaul,1,https://github.com/libfuse/libfuse/pull/571,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,573,2020-12-18T18:48:04Z,2020-12-19T10:43:19Z,2020-12-19T10:43:20Z,MERGED,True,1,0,1,https://github.com/chaserhkj,Add exfat to whitelist,1,[],https://github.com/libfuse/libfuse/pull/573,https://github.com/chaserhkj,1,https://github.com/libfuse/libfuse/pull/573,Fixes #572,Fixes #572,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,574,2020-12-24T00:02:04Z,2020-12-27T11:17:47Z,2020-12-28T09:55:23Z,MERGED,True,1,23,1,https://github.com/sargun,util/fusermount.c: Assume the kernel supports UMOUNT_NOFOLLOW,1,[],https://github.com/libfuse/libfuse/pull/574,https://github.com/sargun,1,https://github.com/libfuse/libfuse/pull/574,"UMOUNT_NOFOLLOW was added in Kernel 2.6.34. It's been 10 years since it's been added
Kernel 5.9, and 5.10 break this check mechanism1. Let's deprecate it.
Signed-off-by: Sargun Dhillon sargun@sargun.me","UMOUNT_NOFOLLOW was added in Kernel 2.6.34. It's been 10 years since it's been added
Kernel 5.9, and 5.10 break this check mechanism1. Let's deprecate it.
Signed-off-by: Sargun Dhillon sargun@sargun.me",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,574,2020-12-24T00:02:04Z,2020-12-27T11:17:47Z,2020-12-28T09:55:23Z,MERGED,True,1,23,1,https://github.com/sargun,util/fusermount.c: Assume the kernel supports UMOUNT_NOFOLLOW,1,[],https://github.com/libfuse/libfuse/pull/574,https://github.com/sargun,2,https://github.com/libfuse/libfuse/pull/574#issuecomment-750608353,"UMOUNT_NOFOLLOW was added in Kernel 2.6.34. It's been 10 years since it's been added
Kernel 5.9, and 5.10 break this check mechanism1. Let's deprecate it.
Signed-off-by: Sargun Dhillon sargun@sargun.me",This should be backported to 2.9 as well. What's the process for that?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,574,2020-12-24T00:02:04Z,2020-12-27T11:17:47Z,2020-12-28T09:55:23Z,MERGED,True,1,23,1,https://github.com/sargun,util/fusermount.c: Assume the kernel supports UMOUNT_NOFOLLOW,1,[],https://github.com/libfuse/libfuse/pull/574,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/574#issuecomment-751455175,"UMOUNT_NOFOLLOW was added in Kernel 2.6.34. It's been 10 years since it's been added
Kernel 5.9, and 5.10 break this check mechanism1. Let's deprecate it.
Signed-off-by: Sargun Dhillon sargun@sargun.me","Thanks!
The backport ""process"" is to send a pull request for the 2.9 branch and cross your fingers that at some point there will be a release again (very unlikely).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,575,2020-12-31T17:52:59Z,2021-01-01T19:34:59Z,2021-01-01T19:34:59Z,MERGED,True,4,2,1,https://github.com/asomers,Fix FUSE_COPY_FILE_RANGE in the passthrough example,1,[],https://github.com/libfuse/libfuse/pull/575,https://github.com/asomers,1,https://github.com/libfuse/libfuse/pull/575,"Only close the file descriptors if they were just opened.  Otherwise,
the second FUSE_COPY_FILE_RANGE operation on any given file will fail
with EBADF.","Only close the file descriptors if they were just opened.  Otherwise,
the second FUSE_COPY_FILE_RANGE operation on any given file will fail
with EBADF.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,577,2021-01-07T22:09:43Z,2021-01-08T10:07:03Z,2021-01-08T10:07:03Z,MERGED,True,1,1,1,https://github.com/richardweinberger,fusermount: Check for argv[0] being present,1,[],https://github.com/libfuse/libfuse/pull/577,https://github.com/richardweinberger,1,https://github.com/libfuse/libfuse/pull/577,"It is perfectly legal to execute a program with argc == 0 and therefore
no argv.
fusermount needs to check for this case, otherwise it will pass a NULL
poiunter to strdup() and cause undefined behavior.
Especially since fusermount is setuid root, we need to extra be careful.
Signed-off-by: Richard Weinberger richard@nod.at","It is perfectly legal to execute a program with argc == 0 and therefore
no argv.
fusermount needs to check for this case, otherwise it will pass a NULL
poiunter to strdup() and cause undefined behavior.
Especially since fusermount is setuid root, we need to extra be careful.
Signed-off-by: Richard Weinberger richard@nod.at",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,578,2021-01-09T18:18:07Z,2021-01-10T11:50:29Z,2021-01-10T11:59:23Z,MERGED,True,1,1,1,https://github.com/Feverfew,Fix typo,1,[],https://github.com/libfuse/libfuse/pull/578,https://github.com/Feverfew,1,https://github.com/libfuse/libfuse/pull/578,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,579,2021-01-09T19:47:33Z,2021-01-12T10:41:35Z,2021-01-12T10:41:35Z,MERGED,True,4,4,1,https://github.com/jbaber,Fix a few typos in README.md.,2,[],https://github.com/libfuse/libfuse/pull/579,https://github.com/jbaber,1,https://github.com/libfuse/libfuse/pull/579,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,581,2021-01-16T11:29:32Z,2021-01-17T10:49:08Z,2021-01-17T14:13:34Z,MERGED,True,1,1,1,https://github.com/bigon,Fix FTBFS on kfreebsd,1,[],https://github.com/libfuse/libfuse/pull/581,https://github.com/bigon,1,https://github.com/libfuse/libfuse/pull/581,"kfreebsd is a FreeBSD kernel and a GNU libc
The only macro defined in that case is FreeBSD_kernel
Fix #580","kfreebsd is a FreeBSD kernel and a GNU libc
The only macro defined in that case is FreeBSD_kernel
Fix #580",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,582,2021-01-28T19:12:42Z,2021-01-28T21:51:10Z,2021-01-29T07:52:12Z,MERGED,True,9,1,2,https://github.com/skitt,"Ignore ""-o nonempty""",1,[],https://github.com/libfuse/libfuse/pull/582,https://github.com/skitt,1,https://github.com/libfuse/libfuse/pull/582,"Commit 0bef21e removed ""-o nonempty"" since mounting over
non-empty directories is always allowed. But this broke tools which
specify ""-o nonempty"". Since the expected behaviour is the same
anyway, ignoring the ""nonempty"" option seems safe, and allows programs
specifying ""-o nonempty"" to continue working with fusermount3.
This would fix https://bugs.debian.org/939767
Signed-off-by: Stephen Kitt steve@sk2.org","Commit 0bef21e removed ""-o nonempty"" since mounting over
non-empty directories is always allowed. But this broke tools which
specify ""-o nonempty"". Since the expected behaviour is the same
anyway, ignoring the ""nonempty"" option seems safe, and allows programs
specifying ""-o nonempty"" to continue working with fusermount3.
This would fix https://bugs.debian.org/939767
Signed-off-by: Stephen Kitt steve@sk2.org",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,582,2021-01-28T19:12:42Z,2021-01-28T21:51:10Z,2021-01-29T07:52:12Z,MERGED,True,9,1,2,https://github.com/skitt,"Ignore ""-o nonempty""",1,[],https://github.com/libfuse/libfuse/pull/582,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/582#issuecomment-769311611,"Commit 0bef21e removed ""-o nonempty"" since mounting over
non-empty directories is always allowed. But this broke tools which
specify ""-o nonempty"". Since the expected behaviour is the same
anyway, ignoring the ""nonempty"" option seems safe, and allows programs
specifying ""-o nonempty"" to continue working with fusermount3.
This would fix https://bugs.debian.org/939767
Signed-off-by: Stephen Kitt steve@sk2.org",Could you also add an entry to ChangeList.rst?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,582,2021-01-28T19:12:42Z,2021-01-28T21:51:10Z,2021-01-29T07:52:12Z,MERGED,True,9,1,2,https://github.com/skitt,"Ignore ""-o nonempty""",1,[],https://github.com/libfuse/libfuse/pull/582,https://github.com/skitt,3,https://github.com/libfuse/libfuse/pull/582#issuecomment-769322006,"Commit 0bef21e removed ""-o nonempty"" since mounting over
non-empty directories is always allowed. But this broke tools which
specify ""-o nonempty"". Since the expected behaviour is the same
anyway, ignoring the ""nonempty"" option seems safe, and allows programs
specifying ""-o nonempty"" to continue working with fusermount3.
This would fix https://bugs.debian.org/939767
Signed-off-by: Stephen Kitt steve@sk2.org","Could you also add an entry to ChangeList.rst?

Of course; I followed the model used previously, with an “Unreleased Changes” section.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,584,2021-02-02T15:48:58Z,2021-02-03T09:53:22Z,2021-02-03T09:53:22Z,MERGED,True,69,3,6,https://github.com/mpartel,Fix returning inode numbers from readdir() in offset==0 mode.,1,[],https://github.com/libfuse/libfuse/pull/584,https://github.com/mpartel,1,https://github.com/libfuse/libfuse/pull/584,"Test added for all passthrough examples.
passthrough.c uses offset==0 mode. The others don't.
passthrough.c changed to set FUSE_FILL_DIR_PLUS to make the test pass.
This fixes #583.","Test added for all passthrough examples.
passthrough.c uses offset==0 mode. The others don't.
passthrough.c changed to set FUSE_FILL_DIR_PLUS to make the test pass.
This fixes #583.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,590,2021-03-15T09:44:10Z,2021-04-12T10:08:50Z,2021-04-12T10:08:50Z,MERGED,True,0,1,1,https://github.com/ui-HookeyChiang,Remove unused fuse_worker bufsize,1,[],https://github.com/libfuse/libfuse/pull/590,https://github.com/ui-HookeyChiang,1,https://github.com/libfuse/libfuse/pull/590,Remove unused fuse_worker bufsize which is not used since 561d705,Remove unused fuse_worker bufsize which is not used since 561d705,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,591,2021-03-15T10:31:59Z,2021-03-18T09:52:31Z,2021-03-30T21:56:58Z,MERGED,True,48,9,5,https://github.com/jpandre,Fix returning d_type by readdir(3) in off == 0 mode,2,[],https://github.com/libfuse/libfuse/pull/591,https://github.com/jpandre,1,https://github.com/libfuse/libfuse/pull/591,"When using the off == 0 mode and not using the readdir_plus mode,
the d_type was not returned, and the use_ino flag was not used for
returning d_ino.
Until a recent patch, this was also the case when using the readdir_plus
mode. It is likely the original developer intentionally used the
offs == 0 situation to trigger something while processing the first
call.
So this patch fixes the returned values for d_ino and d_type in both
with and without the readdir_plus mode. It also restores the original
design for the first returned entry in readdir_plus mode.
The test for the returned d_ino when off == 0 has been adjusted to
take the d_type into consideration.","When using the off == 0 mode and not using the readdir_plus mode,
the d_type was not returned, and the use_ino flag was not used for
returning d_ino.
Until a recent patch, this was also the case when using the readdir_plus
mode. It is likely the original developer intentionally used the
offs == 0 situation to trigger something while processing the first
call.
So this patch fixes the returned values for d_ino and d_type in both
with and without the readdir_plus mode. It also restores the original
design for the first returned entry in readdir_plus mode.
The test for the returned d_ino when off == 0 has been adjusted to
take the d_type into consideration.",True,{'THUMBS_UP': ['https://github.com/nh2']}
libfuse/libfuse,https://github.com/libfuse/libfuse,591,2021-03-15T10:31:59Z,2021-03-18T09:52:31Z,2021-03-30T21:56:58Z,MERGED,True,48,9,5,https://github.com/jpandre,Fix returning d_type by readdir(3) in off == 0 mode,2,[],https://github.com/libfuse/libfuse/pull/591,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/591#issuecomment-801783221,"When using the off == 0 mode and not using the readdir_plus mode,
the d_type was not returned, and the use_ino flag was not used for
returning d_ino.
Until a recent patch, this was also the case when using the readdir_plus
mode. It is likely the original developer intentionally used the
offs == 0 situation to trigger something while processing the first
call.
So this patch fixes the returned values for d_ino and d_type in both
with and without the readdir_plus mode. It also restores the original
design for the first returned entry in readdir_plus mode.
The test for the returned d_ino when off == 0 has been adjusted to
take the d_type into consideration.",Thanks for working on this!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,591,2021-03-15T10:31:59Z,2021-03-18T09:52:31Z,2021-03-30T21:56:58Z,MERGED,True,48,9,5,https://github.com/jpandre,Fix returning d_type by readdir(3) in off == 0 mode,2,[],https://github.com/libfuse/libfuse/pull/591,https://github.com/nh2,3,https://github.com/libfuse/libfuse/pull/591#issuecomment-810604163,"When using the off == 0 mode and not using the readdir_plus mode,
the d_type was not returned, and the use_ino flag was not used for
returning d_ino.
Until a recent patch, this was also the case when using the readdir_plus
mode. It is likely the original developer intentionally used the
offs == 0 situation to trigger something while processing the first
call.
So this patch fixes the returned values for d_ino and d_type in both
with and without the readdir_plus mode. It also restores the original
design for the first returned entry in readdir_plus mode.
The test for the returned d_ino when off == 0 has been adjusted to
take the d_type into consideration.","I can confirm that this PR fixes readdir() always returning DT_UNKNOWN in sshfs, thus making many recursive directory traversal operations in many programming languages much faster, as they don't need to fall back to stat().
Thank you!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,592,2021-03-24T13:38:53Z,2021-03-25T08:40:27Z,2021-03-25T11:45:35Z,MERGED,True,5,5,1,https://github.com/gaul,Fix typos,1,[],https://github.com/libfuse/libfuse/pull/592,https://github.com/gaul,1,https://github.com/libfuse/libfuse/pull/592,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,593,2021-03-30T10:15:43Z,2021-03-30T12:37:30Z,2021-10-07T16:51:34Z,MERGED,True,1,1,1,https://github.com/tniessen,Fix typo in fuse_lowlevel.h,1,[],https://github.com/libfuse/libfuse/pull/593,https://github.com/tniessen,1,https://github.com/libfuse/libfuse/pull/593,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,596,2021-04-13T17:05:22Z,2021-04-13T17:54:10Z,2021-04-13T17:54:10Z,MERGED,True,8,5,1,https://github.com/heirecka,Fix a few meson warnings,2,[],https://github.com/libfuse/libfuse/pull/596,https://github.com/heirecka,1,https://github.com/libfuse/libfuse/pull/596,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,597,2021-04-22T22:55:31Z,2021-04-23T07:31:37Z,2021-04-23T07:31:38Z,MERGED,True,1,1,1,https://github.com/manueljacob,Add missing exceptions to fuse_reply_err() documentation.,1,[],https://github.com/libfuse/libfuse/pull/597,https://github.com/manueljacob,1,https://github.com/libfuse/libfuse/pull/597,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/paralin,1,https://github.com/libfuse/libfuse/pull/598,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/598#issuecomment-831743000,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","Please take a look at the history of this file. Both settings are causing problems in different circumstances (e.g. your change would re-open #427).
It is not clear to me what the right way to fix this is.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/paralin,3,https://github.com/libfuse/libfuse/pull/598#issuecomment-832220511,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","@Nikratio while an appropriate solution is found, could you possibly add an option to disable installing the init.d script?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/598#issuecomment-857482366,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","Pull requests for making init script installation optional are welcome :-).
I'll this pull request, since it seems it's not really making things better than the status quo.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/paralin,5,https://github.com/libfuse/libfuse/pull/598#issuecomment-1145349031,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","@Nikratio as you can see from the extensive log of cross-references in this PR, this is still a patch in the Skiff Buildroot tree.
I don't know if there was ever a fixed for this merged?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/eli-schwartz,6,https://github.com/libfuse/libfuse/pull/598#issuecomment-1145412875,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","Both settings are causing problems in different circumstances

From the sound of it, the answer is no.
Some people don't want it to use anything other than /etc because if you configure with a prefix of /usr/local, the default sysconfdir is /usr/local/etc while the init script expects that sysconfdir is /etc.
Some people want it to respect sysconfdir, because they don't want the init script at all, and cannot write to /etc.
Simply removing it altogether was probably not a perfectly ideal attempt at a solution tbh.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,598,2021-05-03T02:07:35Z,2021-06-09T08:06:35Z,2022-06-02T23:42:53Z,CLOSED,False,0,13,1,https://github.com/paralin,install_helper: fix sysconf dir for init.d script,1,[],https://github.com/libfuse/libfuse/pull/598,https://github.com/paralin,7,https://github.com/libfuse/libfuse/pull/598#issuecomment-1145440903,"Fixes the following build error in Buildroot as a host package:
Running custom install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false
+ sysconfdir=/host/etc
+ bindir=/host/bin
+ udevrulesdir=/host/lib/udev/rules.d
+ useroot=false
+ '[' -z '' ']'
+ DESTDIR=
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/fuse.conf /host/etc/fuse.conf
+ false
+ install -D -m 644 /build/host-libfuse3-3.10.3/util/udev.rules /host/lib/udev/rules.d/99-fuse3.rules
+ install -D -m 755 /build/host-libfuse3-3.10.3/util/init_script /etc/init.d/fuse3
install: cannot create regular file '/etc/init.d/fuse3': Permission denied
FAILED: install script 'install_helper.sh /host/etc /host/bin /host/lib/udev/rules.d false' exit code 1, stopped
FAILED: meson-install

As far as I can tell, this is correct - and the current implementation is wrong - because it should be installing the init.d script to sysconfdir.","Probably not ideal, but I certainly was alarmed to find that the install script was writing to my host machine's /etc, while I was trying to get it to write to a ""target"" FS in Buildroot.
Also, most distros are using Systemd and not OpenRC, so installing the OpenRC script also doesn't make sense there.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,599,2021-05-05T09:15:32Z,2021-05-05T09:51:08Z,2021-05-05T09:51:08Z,MERGED,True,1,1,1,https://github.com/dancerj,fusermount3.1: refer to mount.fuse3,1,[],https://github.com/libfuse/libfuse/pull/599,https://github.com/dancerj,1,https://github.com/libfuse/libfuse/pull/599,mount.fuse was renamed to mount.fuse3.,mount.fuse was renamed to mount.fuse3.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,600,2021-05-06T00:29:23Z,2021-05-07T09:43:31Z,2021-05-19T00:58:45Z,MERGED,True,20,17,4,https://github.com/dancerj,Fix doxygen warnings.,6,[],https://github.com/libfuse/libfuse/pull/600,https://github.com/dancerj,1,https://github.com/libfuse/libfuse/pull/600,"Some parameters were undocumented.
tested with doxygen doc/Doxyfile","Some parameters were undocumented.
tested with doxygen doc/Doxyfile",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,600,2021-05-06T00:29:23Z,2021-05-07T09:43:31Z,2021-05-19T00:58:45Z,MERGED,True,20,17,4,https://github.com/dancerj,Fix doxygen warnings.,6,[],https://github.com/libfuse/libfuse/pull/600,https://github.com/dancerj,2,https://github.com/libfuse/libfuse/pull/600#issuecomment-833148381,"Some parameters were undocumented.
tested with doxygen doc/Doxyfile",Not sure if I want to remove the source code from individual pages or fix the 2 pages to include the source code.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,600,2021-05-06T00:29:23Z,2021-05-07T09:43:31Z,2021-05-19T00:58:45Z,MERGED,True,20,17,4,https://github.com/dancerj,Fix doxygen warnings.,6,[],https://github.com/libfuse/libfuse/pull/600,https://github.com/dancerj,3,https://github.com/libfuse/libfuse/pull/600#issuecomment-843666662,"Some parameters were undocumented.
tested with doxygen doc/Doxyfile",I realized that I fixed the warnings but some descriptions disappeared. I figured out what I did wrong and here's a pull request to fix it: #608,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,601,2021-05-08T09:04:44Z,2021-05-08T13:15:55Z,2021-05-08T13:15:55Z,MERGED,True,2,0,2,https://github.com/rfjakob,"doc: Add ""fuse (4)"" to SEE ALSO sections in man pages",1,[],https://github.com/libfuse/libfuse/pull/601,https://github.com/rfjakob,1,https://github.com/libfuse/libfuse/pull/601,"fuse (4) is an excellent introduction to the FUSE protocol,
and it lists fusermount (1) and mount.fuse (8) in its
SEE ALSO section.
I (the author of gocryptfs) was not aware of this man
page till March 2021, which suggest that it should be
made more discoverable.
So link back to fuse (4) in our SEE ALSO sections.","fuse (4) is an excellent introduction to the FUSE protocol,
and it lists fusermount (1) and mount.fuse (8) in its
SEE ALSO section.
I (the author of gocryptfs) was not aware of this man
page till March 2021, which suggest that it should be
made more discoverable.
So link back to fuse (4) in our SEE ALSO sections.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,602,2021-05-08T21:17:33Z,2021-05-09T09:00:57Z,2021-05-14T23:16:00Z,MERGED,True,78,41,1,https://github.com/Garfield96,Update cxxopts from 2.2.0 to 2.2.1,1,[],https://github.com/libfuse/libfuse/pull/602,https://github.com/Garfield96,1,https://github.com/libfuse/libfuse/pull/602,"This PR updates cxxopts to the latest released version (https://github.com/jarro2783/cxxopts/releases/tag/v2.2.1) and thereby resolves compiler errors raised by gcc 11.
Tested with gcc 11.1.0 and gcc 10.2.1
closes: #585","This PR updates cxxopts to the latest released version (https://github.com/jarro2783/cxxopts/releases/tag/v2.2.1) and thereby resolves compiler errors raised by gcc 11.
Tested with gcc 11.1.0 and gcc 10.2.1
closes: #585",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,604,2021-05-09T08:37:30Z,2021-05-09T10:12:01Z,2021-05-14T23:16:00Z,MERGED,True,17,1,2,https://github.com/Garfield96,Fix memory leaks in examples,2,[],https://github.com/libfuse/libfuse/pull/604,https://github.com/Garfield96,1,https://github.com/libfuse/libfuse/pull/604,"This PR fixes two memory leaks in the examples passthrough_hp and passthrough_ll. These leaks were found using address sanitizer. Now, the only remaining leaks detected by asan are located in the option parser logic.","This PR fixes two memory leaks in the examples passthrough_hp and passthrough_ll. These leaks were found using address sanitizer. Now, the only remaining leaks detected by asan are located in the option parser logic.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/Smit-tay,1,https://github.com/libfuse/libfuse/pull/606,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !","This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/606#issuecomment-840752237,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !","Thanks for submitting this!
The drawback of merging this is that it will incur a continuous maintenance overhead - now everyone who makes changes that affect the build needs to be familiar with two different build systems.
Unless there are good reasons for supporting both, I'd therefore leave this open as a pull request, so that interested people can find it and apply it on their own.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/Smit-tay,3,https://github.com/libfuse/libfuse/pull/606#issuecomment-840782138,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !","Understood.

I will do my best to maintain my fork (Smit-tay/libfuse-cmake) - keeping it
current with upstream libfuse/libfuse at least a few times a year.

I'm wondering about adding some kind of link in the readme.md to direct
CMake users to my fork, though.  That might be a good strategy.
…
On Thu, 13 May 2021 at 20:37, Nikolaus Rath ***@***.***> wrote:
 Thanks for submitting this!

 The drawback of merging this is that it will incur a continuous
 maintenance overhead - now everyone who makes changes that affect the build
 needs to be familiar with two different build systems.

 Unless there are good reasons for supporting both, I'd therefore leave
 this open as a pull request, so that interested people can find it and
 apply it on their own.

 —
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#606 (comment)>, or
 unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AA5P73Q7AYRN5X3AENBQV5LTNQL7HANCNFSM4423VW4Q>
 .",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/wdlkmpx,4,https://github.com/libfuse/libfuse/pull/606#issuecomment-1023799778,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !","I often cross compile static apps, and just hit the Meson wall
A ""low level"" C llb using Meson ... it just feels wrong",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/eli-schwartz,5,https://github.com/libfuse/libfuse/pull/606#issuecomment-1023827844,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !",Can you elaborate on what feels wrong about it? :),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/Smit-tay,6,https://github.com/libfuse/libfuse/pull/606#issuecomment-1024055494,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !","It shouldn't make any difference if you use CMake or Meson.
That being said, I have never used Meson for cross compiling.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,606,2021-05-13T16:39:06Z,2022-04-17T12:47:08Z,2022-04-17T12:47:08Z,CLOSED,False,793,87,38,https://github.com/Smit-tay,Add CMake support - plus !,62,[],https://github.com/libfuse/libfuse/pull/606,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/606#issuecomment-1100868857,"This is a rather substantial change which adds CMake build support.
Almost all of the changes are additional CMakeLists.txt files to support that.
It also adds a Jenkins file which can be used in place of Travis.
There are minor modifications to a very few source code files to eliminate warnings.
I supply this in the hopes that someone might find it useful.
You mileage may vary !",I'll close this pull request per discussion above. Please feel free to submit a PR just for README to point at the separately maintained branch.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,607,2021-05-15T11:56:56Z,2021-06-09T08:04:41Z,2021-11-07T23:51:46Z,MERGED,True,12,8,2,https://github.com/Garfield96,Cuse example: Fix memory leak,2,[],https://github.com/libfuse/libfuse/pull/607,https://github.com/Garfield96,1,https://github.com/libfuse/libfuse/pull/607,"This PR fixes the remaining memory leaks found by asan. Thus, leak checking was re-enabled in Travis CI.","This PR fixes the remaining memory leaks found by asan. Thus, leak checking was re-enabled in Travis CI.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,608,2021-05-17T23:36:37Z,2021-05-19T08:32:14Z,2021-05-19T08:32:14Z,MERGED,True,6,6,2,https://github.com/dancerj,Define FUSE_USE_VERSION in Doxygen.,1,[],https://github.com/libfuse/libfuse/pull/608,https://github.com/dancerj,1,https://github.com/libfuse/libfuse/pull/608,"We currently do not pass anything in PREDEFINED and that means
FUSE_USE_VERSION is undefined.
Add that definition so that Doxygen built-in C pre-processor can use
FUSE_USE_VERSION value to find the correct comment to parse.
tested with doxygen doc/Doxyfile and now ioctl definitions appear.","We currently do not pass anything in PREDEFINED and that means
FUSE_USE_VERSION is undefined.
Add that definition so that Doxygen built-in C pre-processor can use
FUSE_USE_VERSION value to find the correct comment to parse.
tested with doxygen doc/Doxyfile and now ioctl definitions appear.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,609,2021-05-19T09:15:55Z,2021-06-09T08:04:08Z,2021-06-09T08:57:56Z,MERGED,True,1,1,1,https://github.com/sir-sigurd,fix typo in man,1,[],https://github.com/libfuse/libfuse/pull/609,https://github.com/sir-sigurd,1,https://github.com/libfuse/libfuse/pull/609,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/lixiaokeng,1,https://github.com/libfuse/libfuse/pull/610,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/610#issuecomment-852072929,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com",Thanks for the report! Could you elaborate on why this is not a problem when running in daemon mode?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/lixiaokeng,3,https://github.com/libfuse/libfuse/pull/610#issuecomment-852718853,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","Thanks for the report! Could you elaborate on why this is not a problem when running in daemon mode?

We can't make sure there is no problem in daemon mode. We find this problem in foreground mode and don't know the impact of deleting chdir in daemon mode, so just revert c52c325.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/610#issuecomment-852861636,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","I think it makes more sense for a program that is intended to run in the background to not make assumptions about the current path. If you truly need a specific working directory, why not chdir into it after calling fuse_daemonize?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/lixiaokeng,5,https://github.com/libfuse/libfuse/pull/610#issuecomment-853503169,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","We have tried it. However, we can't lock all chdir() when it is multi-thread , because we just provide a link library. I agree that  “a program run in the background should not make assumptions about the current path”.  But the cuse always runs in foreground mode, so some functions are called with relative path.  The commit (c52c325) that we want to  revert just changes the directory in foreground mode.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/610#issuecomment-857480628,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","Sorry, I still do not understand. What's preventing you from running chdir after fuse_daemonize, but before starting any threads? What's preventing you from not using relative paths at all by prepending your desired ""working directory"" to any relative path that you encounter?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/lixiaokeng,7,https://github.com/libfuse/libfuse/pull/610#issuecomment-859218682,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","The cuse_thread will created from time to time in process running. If we want to  solve the problem, we should lock every chdir() and position of using relative path. As I said before， we provide a library to users  and we can't prevent the users from using relative path which was valid in past （in old spdk）.
Here is another question. Does the commit (c52c325) fix some bug? I don't known what effect there will be without it.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/Nikratio,8,https://github.com/libfuse/libfuse/pull/610#issuecomment-859354166,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com",I still do not understand why you cannot run chdir after fuse_daemonize. Any threads created afterwards will see the effect of this and can use relative paths.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/lixiaokeng,9,https://github.com/libfuse/libfuse/pull/610#issuecomment-859398941,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","As the picture shows， cuse_thread (may be created in any time) and users' thread run concurrently. We should not only run chdir after fuse_daemonize but also  add lock for  process  running correctly.  If no lock, cuse_thread runs chdir(""/"") then switch  to users' thead, there will be a fault in using relative paths. However, we just provide a "".so"" file to users. We can't add lock in users' code and can't prevent the users from using relative path. Anyway, it is reasonable to use a relative path in the foreground mode.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,610,2021-05-31T02:57:45Z,2021-09-06T12:38:30Z,2021-09-06T12:38:30Z,CLOSED,False,0,2,1,https://github.com/lixiaokeng,"fuse3: revert ""fuse_daemonize(): chdir to '/' even if not running in the background""",1,[],https://github.com/libfuse/libfuse/pull/610,https://github.com/joelnn,10,https://github.com/libfuse/libfuse/pull/610#issuecomment-907328844,"The nvme-cuse in SPDK 21.01 uses cuse in foreground mode. If
fuse_daemonize function calls chdir to '/', then all functions
call with relative-path parameter will report error due to
the working directory changed. The bugfix in SPDK can't fix
the all sence, like: apps call chdir self or multi-thread
race condition etc. Prefer revert patch in fuse3 to fix the
bug in cuse foreground mode.
Signed-off-by: Lixiaokenglixiaokeng@huawei.com
Signed-off-by: Weifeng Susuweifeng1@huawei.com","fuse_daemonize is a small helper function and c52c325 has survived 8 years, you should probably just not use fuse_daemonize. In fact it does nothing other than the chdir that you don't like, in foreground mode.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,611,2021-06-02T09:02:38Z,2021-06-02T09:23:07Z,2021-06-15T11:06:33Z,MERGED,True,1,1,1,https://github.com/amir73il,test/test_syscalls.c: fix test failure on xfs src dir,1,[],https://github.com/libfuse/libfuse/pull/611,https://github.com/amir73il,1,https://github.com/libfuse/libfuse/pull/611,"rename dir loop test fails when test tmp dir is xfs with an error
test_rename_dir_loop() - rename : File exists
That is because xfs returns EEXIST for the case of renaming over
a non-empty directory.
According to rename(2) man page, EEXIST and ENOTEMPTY are both valid
error code in this case.
Signed-off-by: Amir Goldstein amir73il@gmail.com","rename dir loop test fails when test tmp dir is xfs with an error
test_rename_dir_loop() - rename : File exists
That is because xfs returns EEXIST for the case of renaming over
a non-empty directory.
According to rename(2) man page, EEXIST and ENOTEMPTY are both valid
error code in this case.
Signed-off-by: Amir Goldstein amir73il@gmail.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,612,2021-06-09T18:31:37Z,2021-06-14T08:13:13Z,2021-06-15T11:05:54Z,MERGED,True,255,98,2,https://github.com/amir73il,Test reused inodes,4,[],https://github.com/libfuse/libfuse/pull/612,https://github.com/amir73il,1,https://github.com/libfuse/libfuse/pull/612,"To test this kernel fix https://lore.kernel.org/linux-fsdevel/20210609181158.479781-1-amir73il@gmail.com/
This test passes on all the example passthrough filesystems in libfuse without the kernel fix,
because none of these fs can reuse inode numbers of non evicted inodes.
Specifically, all the ll passthrough examples keep open fd's for all live inodes in real fs,
so real fs cannot reuse those inode numbers.","To test this kernel fix https://lore.kernel.org/linux-fsdevel/20210609181158.479781-1-amir73il@gmail.com/
This test passes on all the example passthrough filesystems in libfuse without the kernel fix,
because none of these fs can reuse inode numbers of non evicted inodes.
Specifically, all the ll passthrough examples keep open fd's for all live inodes in real fs,
so real fs cannot reuse those inode numbers.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,612,2021-06-09T18:31:37Z,2021-06-14T08:13:13Z,2021-06-15T11:05:54Z,MERGED,True,255,98,2,https://github.com/amir73il,Test reused inodes,4,[],https://github.com/libfuse/libfuse/pull/612,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/612#issuecomment-859353235,"To test this kernel fix https://lore.kernel.org/linux-fsdevel/20210609181158.479781-1-amir73il@gmail.com/
This test passes on all the example passthrough filesystems in libfuse without the kernel fix,
because none of these fs can reuse inode numbers of non evicted inodes.
Specifically, all the ll passthrough examples keep open fd's for all live inodes in real fs,
so real fs cannot reuse those inode numbers.","Thanks for the patch! Could you provide a more detailed description of what the patch does? Looking at the diff, this mostly looks like a re-factoring to me (passing around struct stat instead of char path).
Also, if the test is guaranteed to always succeed, what exactly are the benefits of making the change?
Might it be possible to change e.g. examples/hello_ll.c to trigger the behavior that we want to test?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,612,2021-06-09T18:31:37Z,2021-06-14T08:13:13Z,2021-06-15T11:05:54Z,MERGED,True,255,98,2,https://github.com/amir73il,Test reused inodes,4,[],https://github.com/libfuse/libfuse/pull/612,https://github.com/amir73il,3,https://github.com/libfuse/libfuse/pull/612#issuecomment-859381249,"To test this kernel fix https://lore.kernel.org/linux-fsdevel/20210609181158.479781-1-amir73il@gmail.com/
This test passes on all the example passthrough filesystems in libfuse without the kernel fix,
because none of these fs can reuse inode numbers of non evicted inodes.
Specifically, all the ll passthrough examples keep open fd's for all live inodes in real fs,
so real fs cannot reuse those inode numbers.","Re: what the patch does?
Isn't the description in commit message of the top commit clear about the WHAT?
As to the WHY, that is explained in the (not so easy to understand) commit message of the linked kernel patch.
In a nut shell, test keeps open O_PATH fd for some files and then tries to use those fd to stat those files again at the end of the test.
As the commit message explains, getting an error on those fstat() calls is perfectly valid, but observing the wrong file via that O_PATH fd is very much wrong and can lead to serious security breach.
RE: change an example to trigger the test failure
Hard question.
Short answer:
Maybe I change passthrough_hp to close the unlinked inode.fd on
unlink() and it would not break other tests, but fail this one. I will try.
Long answer:
I have a branch in my github with an example fs that fails the test (cachegwfs-tests).
The example is based on passthrough_hp, but it is not a trivial change and
it only works over specific src fs (xfs and ext4).
I can contribute a simpler version of this fs to examples, but I have bigger plans -
I plan to factor out and contribute libfuse passthrough library from my fs to help
consolidate the development efforts on different passthrough fs.
It's still in very early stages, but you can see the general idea on my fuse_passthrough branch.
Bottom line:
There is no rush to merge this test.
I posted it mostly as a reference test for the kernel fix.
I will see about making the test fail on passthrough_hp",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,612,2021-06-09T18:31:37Z,2021-06-14T08:13:13Z,2021-06-15T11:05:54Z,MERGED,True,255,98,2,https://github.com/amir73il,Test reused inodes,4,[],https://github.com/libfuse/libfuse/pull/612,https://github.com/amir73il,4,https://github.com/libfuse/libfuse/pull/612#issuecomment-860065104,"To test this kernel fix https://lore.kernel.org/linux-fsdevel/20210609181158.479781-1-amir73il@gmail.com/
This test passes on all the example passthrough filesystems in libfuse without the kernel fix,
because none of these fs can reuse inode numbers of non evicted inodes.
Specifically, all the ll passthrough examples keep open fd's for all live inodes in real fs,
so real fs cannot reuse those inode numbers.","All right. I managed to change passthrough_hp in a way that it:

Passes all upstream libfusse tests
Fails the modified test_syscalls in this PR on upstream kernel
Passes  the modified test_syscalls in this PR on patched kernel",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,613,2021-06-16T10:12:36Z,2021-06-16T17:25:15Z,2021-06-17T07:47:04Z,MERGED,True,2,4,1,https://github.com/lixiaokeng,Fix: a potential crash on failure to setlocale,1,[],https://github.com/libfuse/libfuse/pull/613,https://github.com/lixiaokeng,1,https://github.com/libfuse/libfuse/pull/613,"setlocale() can fail, returning NULL, which will lead
to a crash in iconv_new(). Fix it like in iconv_help().
Signed-off-by: Lixiaokeng lixiaokeng@huawei.com","setlocale() can fail, returning NULL, which will lead
to a crash in iconv_new(). Fix it like in iconv_help().
Signed-off-by: Lixiaokeng lixiaokeng@huawei.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,614,2021-06-16T10:13:09Z,2021-09-06T12:37:46Z,2021-09-06T12:37:46Z,MERGED,True,6,1,1,https://github.com/lixiaokeng,Fix: fd and memory leak in mount.fuse.c,1,[],https://github.com/libfuse/libfuse/pull/614,https://github.com/lixiaokeng,1,https://github.com/libfuse/libfuse/pull/614,"The command isn't freed and the fuse_fd isn't
closed if execl failed. Fix it.
Signed-off-by: Lixiaokeng lixiaokeng@huawei.com","The command isn't freed and the fuse_fd isn't
closed if execl failed. Fix it.
Signed-off-by: Lixiaokeng lixiaokeng@huawei.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,615,2021-06-17T16:14:17Z,2021-11-07T11:25:47Z,2021-11-07T11:25:47Z,CLOSED,False,6,0,1,https://github.com/gkurz,passthrough_ll: Don't allow file creation with FUSE_OPEN,1,[],https://github.com/libfuse/libfuse/pull/615,https://github.com/gkurz,1,https://github.com/libfuse/libfuse/pull/615,"A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org","A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,615,2021-06-17T16:14:17Z,2021-11-07T11:25:47Z,2021-11-07T11:25:47Z,CLOSED,False,6,0,1,https://github.com/gkurz,passthrough_ll: Don't allow file creation with FUSE_OPEN,1,[],https://github.com/libfuse/libfuse/pull/615,https://github.com/gkurz,2,https://github.com/libfuse/libfuse/pull/615#issuecomment-863400773,"A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org",Travis CI is failing on test/test_examples.py::test_passthrough_hp[False] FAILED. The test name seems to indicate it is for passthrough_hp while my patch is for passthrough_ll... so I guess something else is breaking the test.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,615,2021-06-17T16:14:17Z,2021-11-07T11:25:47Z,2021-11-07T11:25:47Z,CLOSED,False,6,0,1,https://github.com/gkurz,passthrough_ll: Don't allow file creation with FUSE_OPEN,1,[],https://github.com/libfuse/libfuse/pull/615,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/615#issuecomment-863829893,"A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org","Thanks for the patch!
The ""FUSE Client"" in this context is the Linux kernel, right?
If we return EINVAL, then this signals to the userspace process who has called open that it did something wrong - which isn't the case. So I think this is sub-optimal. I agree that it makes sense to check for this, but I think we should be handling it differently. At the very least print an explanatory message, and maybe just terminate the process instead of returning an error.
Have you checked if passthrough_hp may have the same problem?
Wouldn't such a check be placed better in FUSE itself rather than in one of the examples? Or is there a situation where a FUSE filesystem would want to accept this flag in its open handler?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,615,2021-06-17T16:14:17Z,2021-11-07T11:25:47Z,2021-11-07T11:25:47Z,CLOSED,False,6,0,1,https://github.com/gkurz,passthrough_ll: Don't allow file creation with FUSE_OPEN,1,[],https://github.com/libfuse/libfuse/pull/615,https://github.com/gkurz,4,https://github.com/libfuse/libfuse/pull/615#issuecomment-863884972,"A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org","Thanks for the patch!
The ""FUSE Client"" in this context is the Linux kernel, right?

Yes.

If we return EINVAL, then this signals to the userspace process who has called open that it did something wrong - which isn't the case.

You're right that userspace didn't do anything wrong. The culprit is the linux kernel : O_CREAT should be converted to a FUSE_CREATE or FUSE_MKNOD request but not FUSE_OPEN.

So I think this is sub-optimal. I agree that it makes sense to check for this, but I think we should be handling it differently. At the very least print an explanatory message,  and maybe just terminate the process instead of returning an error.

I have mixed feelings about this. This patch was originaly made for QEMU's virtiofsd passthough_ll.c. In our case, the kernel FUSE driver is untrusted code and we need to harden virtiofsd against buggy guests. Replacing an abort() by an exit() doesn't make much sense in this respect. Another solution could be to ignore O_CREAT (i.e. flags &= ~O_CREAT) when processing a FUSE_OPEN request : ENOENT would be returned if the file doesn't exist, which is definitely something that userspace should
be ready to handle when calling open(), no matter O_CREAT is specified or not.
I guess printing an error message is fine if it doesn't allow the guest to flood some log files on the host.

Have you checked if passthrough_hp may have the same problem?

No.

Wouldn't such a check be placed better in FUSE itself rather than in one of the examples? Or is there a situation where a FUSE filesystem would want to accept this flag in its open handler?

Since we already have FUSE_MKNOD and FUSE_CREATE to handle open(O_CREAT), I don't see
a case where we'd also handle this with FUSE_OPEN.
So, yes, this should probably be handled in fuse_lowlevel.c:do_create() rather than lo_create().",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,615,2021-06-17T16:14:17Z,2021-11-07T11:25:47Z,2021-11-07T11:25:47Z,CLOSED,False,6,0,1,https://github.com/gkurz,passthrough_ll: Don't allow file creation with FUSE_OPEN,1,[],https://github.com/libfuse/libfuse/pull/615,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/615#issuecomment-962585768,"A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org","Are you still interested in working on this? If not, I'll close the pull request for now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,615,2021-06-17T16:14:17Z,2021-11-07T11:25:47Z,2021-11-07T11:25:47Z,CLOSED,False,6,0,1,https://github.com/gkurz,passthrough_ll: Don't allow file creation with FUSE_OPEN,1,[],https://github.com/libfuse/libfuse/pull/615,https://github.com/gkurz,6,https://github.com/libfuse/libfuse/pull/615#issuecomment-962589398,"A well behaved FUSE client uses FUSE_CREATE to create files. It isn't
supposed to pass O_CREAT along a FUSE_OPEN request, as documented in
the ""fuse_lowlevel.h"" header :
/**
 * Open a file
 *
 * Open flags are available in fi->flags. The following rules
 * apply.
 *
 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
 *    filtered out / handled by the kernel.

But if the client happens to do it anyway, the server ends up passing
this flag to open() without the mandatory mode_t 4th argument. Since
open() is a variadic function, glibc will happily pass whatever it
finds on the stack to the syscall. If this file is compiled with
-D_FORTIFY_SOURCE=2, glibc will even detect that and abort:
*** invalid openat64 call: O_CREAT or O_TMPFILE without mode ***: terminated
Specifying O_CREAT with FUSE_OPEN is a protocol violation. Check this
in lo_open() and return an error to the client : EINVAL since this is
already what glibc returns with other illegal flag combinations.
The FUSE filesystem doesn't currently support O_TMPFILE, but the very
same would happen if O_TMPFILE was passed in a FUSE_OPEN request. Check
that as well.
Signed-off-by: Greg Kurz groug@kaod.org","Are you still interested in working on this? If not, I'll close the pull request for now.

I've switched to another project and I won't be able to go ahead with this. Feel free to close this PR.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,616,2021-06-22T11:11:19Z,2021-06-23T10:46:20Z,2021-06-23T10:47:07Z,MERGED,True,19,3,2,https://github.com/amir73il,Do not run unlinked files test on passthrough_hp with old kernels,1,[],https://github.com/libfuse/libfuse/pull/616,https://github.com/amir73il,1,https://github.com/libfuse/libfuse/pull/616,"test_syscalls unlinked testfiles check fails on passthourhg_hp without
the kernel commit ""fuse: fix illegal access to inode with reused nodeid""
queued for kernel 5.14 [1].
Make this check opt-in and do not run it with kernel version before 5.14.
[1] https://lore.kernel.org/linux-fsdevel/CAJfpegtGKjeK8E5QsHKF0=re1J9wVHuGRVgg9NDJ_OOwQdCUNg@mail.gmail.com/
Signed-off-by: Amir Goldstein amir73il@gmail.com","test_syscalls unlinked testfiles check fails on passthourhg_hp without
the kernel commit ""fuse: fix illegal access to inode with reused nodeid""
queued for kernel 5.14 [1].
Make this check opt-in and do not run it with kernel version before 5.14.
[1] https://lore.kernel.org/linux-fsdevel/CAJfpegtGKjeK8E5QsHKF0=re1J9wVHuGRVgg9NDJ_OOwQdCUNg@mail.gmail.com/
Signed-off-by: Amir Goldstein amir73il@gmail.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,616,2021-06-22T11:11:19Z,2021-06-23T10:46:20Z,2021-06-23T10:47:07Z,MERGED,True,19,3,2,https://github.com/amir73il,Do not run unlinked files test on passthrough_hp with old kernels,1,[],https://github.com/libfuse/libfuse/pull/616,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/616#issuecomment-866732332,"test_syscalls unlinked testfiles check fails on passthourhg_hp without
the kernel commit ""fuse: fix illegal access to inode with reused nodeid""
queued for kernel 5.14 [1].
Make this check opt-in and do not run it with kernel version before 5.14.
[1] https://lore.kernel.org/linux-fsdevel/CAJfpegtGKjeK8E5QsHKF0=re1J9wVHuGRVgg9NDJ_OOwQdCUNg@mail.gmail.com/
Signed-off-by: Amir Goldstein amir73il@gmail.com",Thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,619,2021-07-24T21:28:17Z,2021-07-25T10:21:45Z,2021-07-25T17:06:46Z,MERGED,True,7,0,2,https://github.com/thesamesam,util/ulockmgr_server.c: conditionally define closefrom (fix glibc-2.34+),1,[],https://github.com/libfuse/libfuse/pull/619,https://github.com/thesamesam,1,https://github.com/libfuse/libfuse/pull/619,"util/ulockmgr_server.c: conditionally define closefrom (fix glibc-2.34+)
closefrom(3) has joined us in glibc-land from *BSD and Solaris. Since
it's available in glibc 2.34+, we want to detect it and only define our
fallback if the libc doesn't provide it.
Bug: https://bugs.gentoo.org/803923
Signed-off-by: Sam James sam@gentoo.org","util/ulockmgr_server.c: conditionally define closefrom (fix glibc-2.34+)
closefrom(3) has joined us in glibc-land from *BSD and Solaris. Since
it's available in glibc 2.34+, we want to detect it and only define our
fallback if the libc doesn't provide it.
Bug: https://bugs.gentoo.org/803923
Signed-off-by: Sam James sam@gentoo.org",True,{'HOORAY': ['https://github.com/TheSonicMaster']}
libfuse/libfuse,https://github.com/libfuse/libfuse,620,2021-08-03T22:20:31Z,2021-08-04T08:56:44Z,2021-08-04T08:56:45Z,MERGED,True,7,9,1,https://github.com/giuliobenetti,meson.build: fix wrong .symver detection,1,[],https://github.com/libfuse/libfuse/pull/620,https://github.com/giuliobenetti,1,https://github.com/libfuse/libfuse/pull/620,"As pointed here 1 __has_attribute() is broken for many attributes and
if it doesn't support the specific attribute it returns true, so we
can't really rely on that for this check. This lead to Buildroot
libfuse3 build failure 2 where that shows up with:
error: symver is only supported on ELF platforms

Indeed Microblaze doesn't support ELF since it doesn't include oself.h,
but __has_attribute(symver) returns true.
So let's substitute the #ifdef __has_attribute() with a stronger test on
a function foo() with attribute((symver (""test@TEST""))).
Signed-off-by: Giulio Benetti giulio.benetti@benettiengineering.com","As pointed here 1 __has_attribute() is broken for many attributes and
if it doesn't support the specific attribute it returns true, so we
can't really rely on that for this check. This lead to Buildroot
libfuse3 build failure 2 where that shows up with:
error: symver is only supported on ELF platforms

Indeed Microblaze doesn't support ELF since it doesn't include oself.h,
but __has_attribute(symver) returns true.
So let's substitute the #ifdef __has_attribute() with a stronger test on
a function foo() with attribute((symver (""test@TEST""))).
Signed-off-by: Giulio Benetti giulio.benetti@benettiengineering.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,623,2021-08-20T17:52:07Z,2021-08-25T12:46:25Z,2021-08-25T12:46:25Z,MERGED,True,2,2,4,https://github.com/a1346054,Minor cleanup,3,[],https://github.com/libfuse/libfuse/pull/623,https://github.com/a1346054,1,https://github.com/libfuse/libfuse/pull/623,,,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,623,2021-08-20T17:52:07Z,2021-08-25T12:46:25Z,2021-08-25T12:46:25Z,MERGED,True,2,2,4,https://github.com/a1346054,Minor cleanup,3,[],https://github.com/libfuse/libfuse/pull/623,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/623#issuecomment-903548422,,Thank you! The problem with white-space fixes is that they make git blame much harder to use and there is nothing that prevents trailing whitespace from being introduced again in the future. So I would prefer if you could revert those.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,623,2021-08-20T17:52:07Z,2021-08-25T12:46:25Z,2021-08-25T12:46:25Z,MERGED,True,2,2,4,https://github.com/a1346054,Minor cleanup,3,[],https://github.com/libfuse/libfuse/pull/623,https://github.com/a1346054,3,https://github.com/libfuse/libfuse/pull/623#issuecomment-904603640,,"I added the .editorconfig file, to make conforming editors remove trailing whitespace by default, so that it doesn't come back.
Trailing whitespace makes a lot of editors give annoying warnings.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,623,2021-08-20T17:52:07Z,2021-08-25T12:46:25Z,2021-08-25T12:46:25Z,MERGED,True,2,2,4,https://github.com/a1346054,Minor cleanup,3,[],https://github.com/libfuse/libfuse/pull/623,https://github.com/Nikratio,4,https://github.com/libfuse/libfuse/pull/623#issuecomment-905409193,,"As for the SSHFS changes, I don't think the .editorconfig file will be sufficient to ensure that this does not recur. There's too many editors that are not using it (including Emacs).
Can we split this into one pull request for whitespace + ignore file + CI changes, and a second one for the other changes?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,623,2021-08-20T17:52:07Z,2021-08-25T12:46:25Z,2021-08-25T12:46:25Z,MERGED,True,2,2,4,https://github.com/a1346054,Minor cleanup,3,[],https://github.com/libfuse/libfuse/pull/623,https://github.com/a1346054,5,https://github.com/libfuse/libfuse/pull/623#issuecomment-905422712,,Split those commits into #624 where the whitespace discussion can happen.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,624,2021-08-25T11:38:36Z,2022-04-17T12:50:22Z,2022-04-17T12:50:22Z,CLOSED,False,64,66,28,https://github.com/a1346054,WIP: removal of trailing whitespace,2,[],https://github.com/libfuse/libfuse/pull/624,https://github.com/a1346054,1,https://github.com/libfuse/libfuse/pull/624,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,624,2021-08-25T11:38:36Z,2022-04-17T12:50:22Z,2022-04-17T12:50:22Z,CLOSED,False,64,66,28,https://github.com/a1346054,WIP: removal of trailing whitespace,2,[],https://github.com/libfuse/libfuse/pull/624,https://github.com/Rondom,2,https://github.com/libfuse/libfuse/pull/624#issuecomment-905559694,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,"I think, we can use wtf (whitespace total fixer) in CI for this simple task. https://github.com/dlenski/wtf",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,624,2021-08-25T11:38:36Z,2022-04-17T12:50:22Z,2022-04-17T12:50:22Z,CLOSED,False,64,66,28,https://github.com/a1346054,WIP: removal of trailing whitespace,2,[],https://github.com/libfuse/libfuse/pull/624,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/624#issuecomment-913615975,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,Are you still actively working on this?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,624,2021-08-25T11:38:36Z,2022-04-17T12:50:22Z,2022-04-17T12:50:22Z,CLOSED,False,64,66,28,https://github.com/a1346054,WIP: removal of trailing whitespace,2,[],https://github.com/libfuse/libfuse/pull/624,https://github.com/a1346054,4,https://github.com/libfuse/libfuse/pull/624#issuecomment-917707340,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,"I'm still learning how other projects make sure no new trailing whitespace is introduced in git, without giving unhelpful error messages to the contributor or making it too cumbersome.
If anyone watching this wishes to provide some input, I'd appreciate it (or any help with it).
Feel free to leave this PR open, I will rebase the PR in case some conflicts are introduced.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,624,2021-08-25T11:38:36Z,2022-04-17T12:50:22Z,2022-04-17T12:50:22Z,CLOSED,False,64,66,28,https://github.com/a1346054,WIP: removal of trailing whitespace,2,[],https://github.com/libfuse/libfuse/pull/624,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/624#issuecomment-962584999,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,Any update on this?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,624,2021-08-25T11:38:36Z,2022-04-17T12:50:22Z,2022-04-17T12:50:22Z,CLOSED,False,64,66,28,https://github.com/a1346054,WIP: removal of trailing whitespace,2,[],https://github.com/libfuse/libfuse/pull/624,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/624#issuecomment-1100869351,Split from #623 to allow for discussion on how to make sure trailing whitespace is removed and doesn't come back.,"Will close this for now, feel free to re-open when this is ready for review.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,628,2021-10-27T06:36:10Z,2021-10-27T08:22:08Z,2021-10-27T08:22:09Z,CLOSED,False,2,2,1,https://github.com/Dantali0n,Use sysconfdir variable for init.d scripts in install_helper,1,[],https://github.com/libfuse/libfuse/pull/628,https://github.com/Dantali0n,1,https://github.com/libfuse/libfuse/pull/628,"No matter what collection of meson build in and project options is chosen, currently installing fuse with user permissions will always result in an error because the /etc/init.d is unconfigurable from meson.
This patch makes the init.d directory respect the sysconfdir variable","No matter what collection of meson build in and project options is chosen, currently installing fuse with user permissions will always result in an error because the /etc/init.d is unconfigurable from meson.
This patch makes the init.d directory respect the sysconfdir variable",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,628,2021-10-27T06:36:10Z,2021-10-27T08:22:08Z,2021-10-27T08:22:09Z,CLOSED,False,2,2,1,https://github.com/Dantali0n,Use sysconfdir variable for init.d scripts in install_helper,1,[],https://github.com/libfuse/libfuse/pull/628,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/628#issuecomment-952649058,"No matter what collection of meson build in and project options is chosen, currently installing fuse with user permissions will always result in an error because the /etc/init.d is unconfigurable from meson.
This patch makes the init.d directory respect the sysconfdir variable","Thanks for the patch!
It seems to me that even with this patch (1) installing with user permissions will fail because fusermount3 can't be mount with setuid, and (2) the init script will by default be installed into /usr/local/etc/init.d, where it doesn't do anything - i.e., installation will fail silently rather than loudly.
So it's not clear to me that this is an improvement over the status quo.
Please also see issue #427, pr #598 and pr #491 for previous discussions about this.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,628,2021-10-27T06:36:10Z,2021-10-27T08:22:08Z,2021-10-27T08:22:09Z,CLOSED,False,2,2,1,https://github.com/Dantali0n,Use sysconfdir variable for init.d scripts in install_helper,1,[],https://github.com/libfuse/libfuse/pull/628,https://github.com/Dantali0n,3,https://github.com/libfuse/libfuse/pull/628#issuecomment-952659638,"No matter what collection of meson build in and project options is chosen, currently installing fuse with user permissions will always result in an error because the /etc/init.d is unconfigurable from meson.
This patch makes the init.d directory respect the sysconfdir variable","The difference is that this allows the install to complete with user permissions entirely to an alternative directory structure, the user can chroot into that and than perform the necessary steps with appropriate permissions to setup fuse.
Although discussion is great my time is short, so I will just close this pr and compile from my fork.
Kind regards,
Dantali0n",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,630,2021-11-07T19:57:06Z,2022-04-17T12:50:45Z,2022-04-17T12:50:46Z,CLOSED,False,6,2,1,https://github.com/some00,WIP: Fix dlsym usage,1,[],https://github.com/libfuse/libfuse/pull/630,https://github.com/some00,1,https://github.com/libfuse/libfuse/pull/630,"""fuse_module__factory"" is a function pointer but is loaded like a
function, which results an crash for any external module.","""fuse_module__factory"" is a function pointer but is loaded like a
function, which results an crash for any external module.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,630,2021-11-07T19:57:06Z,2022-04-17T12:50:45Z,2022-04-17T12:50:46Z,CLOSED,False,6,2,1,https://github.com/some00,WIP: Fix dlsym usage,1,[],https://github.com/libfuse/libfuse/pull/630,https://github.com/some00,2,https://github.com/libfuse/libfuse/pull/630#issuecomment-1004057560,"""fuse_module__factory"" is a function pointer but is loaded like a
function, which results an crash for any external module.","Changed the title of the PR to WIP

There is a further issue at cleanup when using modules. I found a solution for it.
I would like to extend it with a test case.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,630,2021-11-07T19:57:06Z,2022-04-17T12:50:45Z,2022-04-17T12:50:46Z,CLOSED,False,6,2,1,https://github.com/some00,WIP: Fix dlsym usage,1,[],https://github.com/libfuse/libfuse/pull/630,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/630#issuecomment-1100869414,"""fuse_module__factory"" is a function pointer but is loaded like a
function, which results an crash for any external module.","Closing this for now, please re-open when ready for review.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,1,https://github.com/libfuse/libfuse/pull/631,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,2,https://github.com/libfuse/libfuse/pull/631#issuecomment-971424530,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","This completely breaks check_unlinked_testfile()
The only purpose of the ->fd field is to keep an open O_PATH
fd for unlinked files.
Need to figure out why getting EBADF for those fds that
should be valid O_PATH fds.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,3,https://github.com/libfuse/libfuse/pull/631#issuecomment-971810570,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","This completely breaks check_unlinked_testfile() The only purpose of the ->fd field is to keep an open O_PATH fd for unlinked files.
Need to figure out why getting EBADF for those fds that should be valid O_PATH fds.

Ok, I may have something.  Here's the sfs_unlink() (from example/passthrough_hp.cc):
                    if (inode.fd > 0 && !inode.nopen) {
                            if (fs.debug)
                                    cerr << ""DEBUG: unlink: release inode "" << e.attr.st_ino
                                            << ""; fd="" << inode.fd << endl;
                            lock_guard<mutex> g_fs {fs.mutex};
                            close(inode.fd);
                            inode.fd = -ENOENT;
                            inode.generation++;
                    }

This close(inode.fd) will effectively cause the test to fail; commenting it (and the next statement) makes the failure go away.  But to be honest I'm not really sure that's the correct way to fix.  Could we simply remove this whole if statement?  @amir73il can you advise please?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,4,https://github.com/libfuse/libfuse/pull/631#issuecomment-971892901,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","@luis-henrix the code in sfs_unlink() is intentional and correct.
The problem is with the code in fcheck_stat().
fstat() should not be used to check an O_PATH fd.
The EBADF error is the result of that misuse.
Instead, for O_PATH fd , the function should use fstatat(fd, """", &stbuf, AT_EMPTY_PATH)
I am not sure how the test worked when I tested. I cannot check it right now, but thought I'd give you the suggested fix anyway.
@Nikratio I guess none of the CI machines run with kernel >= 5.14 where this test is run?
I remember we discussed this but don't remember the answer.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,5,https://github.com/libfuse/libfuse/pull/631#issuecomment-972747286,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","@luis-henrix the code in sfs_unlink() is intentional and correct. The problem is with the code in fcheck_stat(). fstat() should not be used to check an O_PATH fd. The EBADF error is the result of that misuse.
Instead, for O_PATH fd , the function should use fstatat(fd, """", &stbuf, AT_EMPTY_PATH) I am not sure how the test worked when I tested. I cannot check it right now, but thought I'd give you the suggested fix anyway.

Ok, to be honest I'm not sure why using fstatat() instead of fstat() should make a difference.  According to the man page, they both should be OK with an O_PATH file descriptor.  But the truth is that I still see the same error using fstatat().
But I still think the issue is on the example/passthrough_hp.cc code.  When the test unlinks a file, sfs_unlink() is called and runs the above code snippet (which does inode.fd = -ENOENT).  Later on, when the test does the fstat() in fcheck_stat(), function sfs_getattr() will eventually get executed and will execute fstatat() with an invalid (-ENOENT) fd.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,6,https://github.com/libfuse/libfuse/pull/631#issuecomment-972817775,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","@luis-henrix yes you are right. fstat() should work.
close(inode.fd) is essential to testing inode number reuse, but leaving an invalid inode.fd is not good.
I think a possible solution is to do:
inode.fd = open(""/dev/null"", O_PATH); in sfs_unlink after closing inode.fd.
If this works for you, please verify that the test fails on kernel < 5.14 (before ""fuse: fix illegal access to inode with reused nodeid""). You will need to remove the test requirement LooseVersion(platform.release()) >= '5.14' in test_examples.py.
The expectation of a good test result is that fstat() returns with ESTALE/ENONET because the fuse inode held by the O_PATH fd is no longer valid and that fstat() will NOT return the attributes of ""/dev/null"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,7,https://github.com/libfuse/libfuse/pull/631#issuecomment-973060481,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","If this works for you, please verify that the test fails on kernel < 5.14 (before ""fuse: fix illegal access to inode with reused nodeid""). You will need to remove the test requirement LooseVersion(platform.release()) >= '5.14' in test_examples.py. The expectation of a good test result is that fstat() returns with ESTALE/ENONET because the fuse inode held by the O_PATH fd is no longer valid and that fstat() will NOT return the attributes of ""/dev/null"".

So, I've tested the code with
@@ -525,7 +525,7 @@ static void sfs_unlink(fuse_req_t req, fuse_ino_t parent, const char *name) {
                                            << ""; fd="" << inode.fd << endl;
                            lock_guard<mutex> g_fs {fs.mutex};
                            close(inode.fd);
-                           inode.fd = -ENOENT;
+                           inode.fd = open(""/dev/null"", O_PATH);
                            inode.generation++;
                    }
            }
and
@@ -245,8 +245,8 @@ def test_passthrough_hp(short_tmpdir, cache, output_checker):
             # unlinked testfiles check fails without kernel fix
             # ""fuse: fix illegal access to inode with reused nodeid""
             # so opt-in for this test from kernel 5.14
-            if LooseVersion(platform.release()) >= '5.14':
-                syscall_test_cmd.append('-u')
+            #if LooseVersion(platform.release()) >= '5.14':
+            syscall_test_cmd.append('-u')
             subprocess.check_call(syscall_test_cmd)
     except:
         cleanup(mount_process, mnt_dir)
The test passes both with a v5.13 (without commit 15db16837a35 (""fuse: fix illegal access to inode with reused nodeid"")) and with a recent kernel (5.16-rc1).  The reason seems to be that fcheck_stat() masks ESTALE, EIO and ENOENT (I checked that errno is set to EIO with both kernels) .
Looking deeper, I found that the reason for getting EIO there is because, when doing that fstat(), the kernel function fuse_do_getattr() will do:
                if (fuse_invalid_attr(&outarg.attr) ||
                    inode_wrong_type(inode, outarg.attr.mode)) {
                        fuse_make_bad(inode);
                        err = -EIO;
                } else {

due to wrong inode mode.
Sooo... changing the inode.fd to /dev/null isn't probably a good idea.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,8,https://github.com/libfuse/libfuse/pull/631#issuecomment-973108140,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","How about trying with some regular file like ""/proc/version""?
Thanks for the accurate analysis. Sorry I cannot test this right now.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,9,https://github.com/libfuse/libfuse/pull/631#issuecomment-973128374,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","How about trying with some regular file like ""/proc/version""?

No, that won't work either because fcheck_stat() will then call st_check_type(), st_check_mode(), st_check_size() and st_check_nlink(), and they will all fail.
However it still doesn't seem to fail on kernel 5.13 when I comment out these extra checks in fcheck_stat().  I can't see a reason for it not failing, as you mentioned that it should without commit 15db16837a35.  But I'll have to leave that for tomorrow.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,10,https://github.com/libfuse/libfuse/pull/631#issuecomment-973138744,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","@luis-henrix the whole point of the test is for st_check_type() and friends to fail on 5.13, because the kernel driver did not recognize the generation change of the inode.
The kernel bug fix should result in EIO/STALE error from fstat(), because inode_wrong_type() was replaced with fuse_stale_inode() that will make the test pass, because it will not get to st_check_type() and friends.
You see, passthrough_hp is emulating a reused inode number (nodeid) with different generation, which is a situation that can happen and kernel needs to deal with it correctly.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,11,https://github.com/libfuse/libfuse/pull/631#issuecomment-974125780,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","Thanks @amir73il I think I understand the point of the st_check_*() functions and that they rightfully fail for 5.13.
Unfortunately, the test also fails with a 5.16 kernel in these checks (when using ""/proc/version"" of the inode.fd):
...
  3 [check_unlinked_testfile] st_check_mode() - mode 0444 instead of 0644             
  3 [check_unlinked_testfile] st_check_size() - length 0 instead of 26                
  3 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0                 
  4 [check_unlinked_testfile] st_check_mode() - mode 0444 instead of 0644             
  4 [check_unlinked_testfile] st_check_size() - length 0 instead of 26                
  4 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0                 
  5 [check_unlinked_testfile] st_check_mode() - mode 0444 instead of 0644             
...

I believe this is because fuse_do_getattr() is not returning -EIO.  This kernel function should probably use fuse_stale_inode() instead of inode_wrong_type() to also check the inode generation.  However, from what I could see, there is no easy way for doing that without changing the fuse protocol to also include the generation in struct fuse_attr_out.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,12,https://github.com/libfuse/libfuse/pull/631#issuecomment-974194652,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","Ok @luis-henrix I think I understand what's going on. I think all you need to fix the test is add EBADF to accepted errors for passing the test.
I guess when I tested I tested over ext4 or xfs and inodes got reused.
I am guessing you are testing over btrfs where inode numbers do not get reused.
The test will not verify the kernel fix over btrfs but at least it will not fail.
Are my assumptions correct? Can you test over xfs or ext4?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,13,https://github.com/libfuse/libfuse/pull/631#issuecomment-974206824,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","Are my assumptions correct? Can you test over xfs or ext4?

No, I am not using btrfs.  My workstation runs on ext4 and I was using virtme to run the tests (to easily pick the kernel versions I wanted).  But to double-check I've just tried to run the test on bare-metal (running the distro 5.14.14-based kernel).  Same result as above.
For the record, I'm using the follow to run the test:
python3 -m pytest test/test_examples.py::test_passthrough_hp[False]",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,14,https://github.com/libfuse/libfuse/pull/631#issuecomment-974237506,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","Ok so to sum it up. I think it is fine to fix the test by accepting EBADF as correct outcome.
I think that xfs ext4 are supposed to get success from fstat() for some of the unlinked files some of the times and on old kernel and then fail the other checks but the nature of these failures is random so if you do not observe those failures I will investigate it later.
For new kernel fstat() should always fail for some error, so the test should pass.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/luis-henrix,15,https://github.com/libfuse/libfuse/pull/631#issuecomment-974253220,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de",@amir73il Thanks! (I didn't even had time to add a comment before you approved it :-) ),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,631,2021-11-17T09:42:39Z,2021-11-20T10:09:26Z,2021-11-20T10:09:26Z,MERGED,True,2,1,1,https://github.com/luis-henrix,test/test_syscalls.c: clean-up unlinked files from fds list,1,[],https://github.com/libfuse/libfuse/pull/631,https://github.com/amir73il,16,https://github.com/libfuse/libfuse/pull/631#issuecomment-974284962,"Test test/test_examples.py::test_passthrough_hp[False] was failing due to lack
of file descriptors clean-up when the test file is unlinked.  This would result
in errors such as:
3 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
4 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
5 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
9 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor
...
This patch simply replaces all the unlink() calls to files created with
create_testfile() by a new helper unlink_testfile() that will also set the ->fd
to -1.
Signed-off-by: Luís Henriques lhenriques@suse.de","I can confirm that on my system with kernel v5.9.6 and underlying ext4 I can see the EBADF:
14 [check_unlinked_testfile] st_check_size() - length 45 instead of 0 14 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 15 [check_unlinked_testfile] st_check_size() - length 45 instead of 0 15 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 16 [check_unlinked_testfile] st_check_size() - length 45 instead of 13 16 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 17 [check_unlinked_testfile] st_check_size() - length 45 instead of 26 17 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 18 [check_unlinked_testfile] st_check_size() - length 45 instead of 126 18 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 19 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 0600 19 [check_unlinked_testfile] st_check_size() - length 45 instead of 0 19 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 20 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 0600 20 [check_unlinked_testfile] st_check_size() - length 45 instead of 13 20 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 21 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 0600 21 [check_unlinked_testfile] st_check_size() - length 45 instead of 26 21 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 22 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 0600 22 [check_unlinked_testfile] st_check_size() - length 45 instead of 126 22 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 23 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 0400 23 [check_unlinked_testfile] st_check_size() - length 45 instead of 0 23 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 24 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 0200 24 [check_unlinked_testfile] st_check_size() - length 45 instead of 0 24 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 25 [check_unlinked_testfile] st_check_mode() - mode 0644 instead of 00 25 [check_unlinked_testfile] st_check_size() - length 45 instead of 0 25 [check_unlinked_testfile] st_check_nlink() - nlink 1 instead of 0 49 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor 50 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor 51 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor 52 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor 53 [check_unlinked_testfile] fcheck_stat() - fstat: Bad file descriptor 36 unlinked testfile checks failed FAILED
and that the test still fails as expected after whitelisting EBADF.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,633,2021-12-11T16:44:24Z,2021-12-12T16:28:58Z,2021-12-12T16:28:58Z,MERGED,True,6,0,1,https://github.com/mheinzler,Document possible NULL paths when directories are removed,1,[],https://github.com/libfuse/libfuse/pull/633,https://github.com/mheinzler,1,https://github.com/libfuse/libfuse/pull/633,"When directories with open handles are removed, the releasedir and fsyncdir operations might be called with a NULL path. That is because there is no hiding behavior like for regular files and the nodes get removed immediately.
This was also discussed on the mailing list:
https://sourceforge.net/p/fuse/mailman/fuse-devel/thread/FR2P281MB0757789828DD816269D15F0A96649%40FR2P281MB0757.DEUP281.PROD.OUTLOOK.COM/","When directories with open handles are removed, the releasedir and fsyncdir operations might be called with a NULL path. That is because there is no hiding behavior like for regular files and the nodes get removed immediately.
This was also discussed on the mailing list:
https://sourceforge.net/p/fuse/mailman/fuse-devel/thread/FR2P281MB0757789828DD816269D15F0A96649%40FR2P281MB0757.DEUP281.PROD.OUTLOOK.COM/",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/amir73il,1,https://github.com/libfuse/libfuse/pull/635,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1","The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/635#issuecomment-1004066564,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1","Thanks, looks good! Please just document the new flag in ChangeLog.rst.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/635#issuecomment-1004185733,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1",This seems to break a unit test...?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/amir73il,4,https://github.com/libfuse/libfuse/pull/635#issuecomment-1004203988,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1","Interesting.
The test was not supposed to change logically for writeback=True, but there are those mutex locks that may have changed timing. I will remove them from the writeback=True case.
However, the assertion that failed (ERROR: Expected 8192 bytes, got 4096) is not really guaranteed with writeback cache enabled - it is only very probable...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/Nikratio,5,https://github.com/libfuse/libfuse/pull/635#issuecomment-1004209657,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1",The idea with the assertion is probably to test that writes are indeed cached without relying on timing. So maybe it is sufficient to reduce the size of userspace writes and/or change the assertion to not-equal to userspace write size...,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/aakefbs,6,https://github.com/libfuse/libfuse/pull/635#issuecomment-1066514621,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1","It is there any reason this is not merged yet? I have also taken this into our branch, as it helps to demonstrate the effect of reduced kernel/userspace context switches
https://lore.kernel.org/lkml/20220224032337.19284-1-dharamhans87@gmail.com/T/#m72cb0466ad77fc7b6cfa2b8609faae72a8381891",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,635,2022-01-03T12:31:21Z,2022-03-14T09:48:43Z,2022-03-14T11:22:43Z,MERGED,True,94,2,9,https://github.com/amir73il,Add support for FOPEN_NOFLUSH flag,4,[],https://github.com/libfuse/libfuse/pull/635,https://github.com/aakefbs,7,https://github.com/libfuse/libfuse/pull/635#issuecomment-1066665473,"The support for the flag was added by commit a390ccb316be (""fuse: add FOPEN_NOFLUSH"") to kernel v5.16-rc1",Thanks for merging @Nikratio !,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,636,2022-01-11T18:49:49Z,2022-01-11T19:56:37Z,2022-01-11T19:56:37Z,MERGED,True,2,2,1,https://github.com/xorian,Avoid ENOENT response when recently invalidated fuse_ino_t is received from the kernel,1,[],https://github.com/libfuse/libfuse/pull/636,https://github.com/xorian,1,https://github.com/libfuse/libfuse/pull/636,"When a file is replaced by rename, a parallel open of the filename being replaced (in a race with the rename) may fail with ENOENT, making it appear (incorrectly) as though the rename was not atomic.  This happens because the call to fuse_lib_open receives the fuse_ino_t of the file being replaced, which becomes invalidated by the rename operation.  When encountering the node which now has no parent, try_get_path returns -ENOENT which then becomes the error result of the file open syscall.
If the reply sent by fuse_lib_open is instead -ESTALE, the renamed file will be opened instead which is the expected behavior.  Changing the response in try_get_path also fixes similar rename atomicity races for other operations.
As described in a mailing list post:
https://marc.info/?l=fuse-devel&m=164149468119994&w=2
Fixes #637","When a file is replaced by rename, a parallel open of the filename being replaced (in a race with the rename) may fail with ENOENT, making it appear (incorrectly) as though the rename was not atomic.  This happens because the call to fuse_lib_open receives the fuse_ino_t of the file being replaced, which becomes invalidated by the rename operation.  When encountering the node which now has no parent, try_get_path returns -ENOENT which then becomes the error result of the file open syscall.
If the reply sent by fuse_lib_open is instead -ESTALE, the renamed file will be opened instead which is the expected behavior.  Changing the response in try_get_path also fixes similar rename atomicity races for other operations.
As described in a mailing list post:
https://marc.info/?l=fuse-devel&m=164149468119994&w=2
Fixes #637",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,638,2022-01-23T03:27:30Z,2022-01-23T10:17:04Z,2022-01-23T10:19:00Z,MERGED,True,3,3,1,https://github.com/gaul,Fix ReST end-string nits,1,[],https://github.com/libfuse/libfuse/pull/638,https://github.com/gaul,1,https://github.com/libfuse/libfuse/pull/638,This makes the file more readable with syntax highlighting.,This makes the file more readable with syntax highlighting.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,641,2022-02-09T08:51:00Z,2022-02-09T14:59:10Z,2022-02-09T14:59:10Z,MERGED,True,4,0,2,https://github.com/jpandre,Fixed returning an error condition to ioctl(2),1,[],https://github.com/libfuse/libfuse/pull/641,https://github.com/jpandre,1,https://github.com/libfuse/libfuse/pull/641,"When returning a negative error code by ->ioctl() to the high level interface, no error is propagated to the low level, and the reply message to the kernel is shown as successful.
A negative result is however returned to kernel, so the kernel can detect the bad condition, but this appears to not be the case since kernel 5.15.
The proposed fix is more in line with the usual processing of errors in fuse, taking into account that ioctl(2) always returns a non-negative value in the absence of errors.","When returning a negative error code by ->ioctl() to the high level interface, no error is propagated to the low level, and the reply message to the kernel is shown as successful.
A negative result is however returned to kernel, so the kernel can detect the bad condition, but this appears to not be the case since kernel 5.15.
The proposed fix is more in line with the usual processing of errors in fuse, taking into account that ioctl(2) always returns a non-negative value in the absence of errors.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,641,2022-02-09T08:51:00Z,2022-02-09T14:59:10Z,2022-02-09T14:59:10Z,MERGED,True,4,0,2,https://github.com/jpandre,Fixed returning an error condition to ioctl(2),1,[],https://github.com/libfuse/libfuse/pull/641,https://github.com/jpandre,2,https://github.com/libfuse/libfuse/pull/641#issuecomment-1033510555,"When returning a negative error code by ->ioctl() to the high level interface, no error is propagated to the low level, and the reply message to the kernel is shown as successful.
A negative result is however returned to kernel, so the kernel can detect the bad condition, but this appears to not be the case since kernel 5.15.
The proposed fix is more in line with the usual processing of errors in fuse, taking into account that ioctl(2) always returns a non-negative value in the absence of errors.","See the context of this proposal in
tuxera/ntfs-3g#28
and
#640",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,642,2022-02-11T18:44:10Z,2022-02-11T20:07:01Z,2022-02-11T20:30:04Z,MERGED,True,0,2,1,https://github.com/davidgaleano,Removed duplicated code.,1,[],https://github.com/libfuse/libfuse/pull/642,https://github.com/davidgaleano,1,https://github.com/libfuse/libfuse/pull/642,The cap for FUSE_CAP_WRITEBACK_CACHE was printed twice. The other copy of these two lines where at line 72. I deleted the first copy because it was out of order with the other definitions and its formatting was not matching.,The cap for FUSE_CAP_WRITEBACK_CACHE was printed twice. The other copy of these two lines where at line 72. I deleted the first copy because it was out of order with the other definitions and its formatting was not matching.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,644,2022-02-28T11:42:22Z,2022-04-08T09:37:18Z,2022-04-08T14:34:56Z,CLOSED,False,340,55,8,https://github.com/d-hans,Introducing atomic open in libfuse,5,[],https://github.com/libfuse/libfuse/pull/644,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/644,"This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open  in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220224032337.19284-1-dharamhans87@gmail.com/.
I will re-base the patches against fixed indentation.","This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open  in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220224032337.19284-1-dharamhans87@gmail.com/.
I will re-base the patches against fixed indentation.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,644,2022-02-28T11:42:22Z,2022-04-08T09:37:18Z,2022-04-08T14:34:56Z,CLOSED,False,340,55,8,https://github.com/d-hans,Introducing atomic open in libfuse,5,[],https://github.com/libfuse/libfuse/pull/644,https://github.com/d-hans,2,https://github.com/libfuse/libfuse/pull/644#issuecomment-1092660527,"This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open  in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220224032337.19284-1-dharamhans87@gmail.com/.
I will re-base the patches against fixed indentation.",i am closing this pull request as i need to rearrange patches. will open new pull request feature wise so that merging of patches becomes easy.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,644,2022-02-28T11:42:22Z,2022-04-08T09:37:18Z,2022-04-08T14:34:56Z,CLOSED,False,340,55,8,https://github.com/d-hans,Introducing atomic open in libfuse,5,[],https://github.com/libfuse/libfuse/pull/644,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/644#issuecomment-1092929163,"This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open  in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220224032337.19284-1-dharamhans87@gmail.com/.
I will re-base the patches against fixed indentation.",Please also wait until these patches have been merged on the kernel side - thanks!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,648,2022-03-21T10:03:17Z,2022-04-17T12:53:52Z,2022-04-17T12:53:52Z,CLOSED,False,4,5,3,https://github.com/heysion,fix: reduce memset syscall and set buf default value,1,[],https://github.com/libfuse/libfuse/pull/648,https://github.com/heysion,1,https://github.com/libfuse/libfuse/pull/648,"reduce memset in fuse_reply_create initialize buf.
set buffer default value with buf[0] = \0
Log:
test/test_ctests.py::test_write_cache[False] PASSED                                      [  2%]
test/test_ctests.py::test_write_cache[True] PASSED                                       [  4%]
test/test_ctests.py::test_notify1[True-notify_inval_inode] PASSED                        [  6%]
test/test_ctests.py::test_notify1[True-invalidate_path] PASSED                           [  8%]
test/test_ctests.py::test_notify1[True-notify_store_retrieve] PASSED                     [ 10%]
test/test_ctests.py::test_notify1[False-notify_inval_inode] PASSED                       [ 12%]
test/test_ctests.py::test_notify1[False-invalidate_path] PASSED                          [ 14%]
test/test_ctests.py::test_notify1[False-notify_store_retrieve] PASSED                    [ 17%]
test/test_ctests.py::test_notify_file_size[True] PASSED                                  [ 19%]
test/test_ctests.py::test_notify_file_size[False] PASSED                                 [ 21%]
test/test_examples.py::test_hello[hello-options0-invoke_directly] PASSED                 [ 23%]
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse] PASSED               [ 25%]
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse_drop_privileges] PASSED [ 27%]
test/test_examples.py::test_hello[hello-options1-invoke_directly] PASSED                 [ 29%]
test/test_examples.py::test_hello[hello-options1-invoke_mount_fuse] PASSED               [ 31%]
test/test_examples.py::test_hello[hello-options1-invoke_mount_fuse_drop_privileges] PASSED [ 34%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_directly] PASSED              [ 36%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_mount_fuse] PASSED            [ 38%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_mount_fuse_drop_privileges] PASSED [ 40%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_directly] PASSED              [ 42%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_mount_fuse] PASSED            [ 44%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_mount_fuse_drop_privileges] PASSED [ 46%]
test/test_examples.py::test_passthrough[False-passthrough-False] PASSED                  [ 48%]
test/test_examples.py::test_passthrough[False-passthrough-True] SKIPPED                  [ 51%]
test/test_examples.py::test_passthrough[False-passthrough_plus-False] PASSED             [ 53%]
test/test_examples.py::test_passthrough[False-passthrough_plus-True] SKIPPED             [ 55%]
test/test_examples.py::test_passthrough[False-passthrough_fh-False] PASSED               [ 57%]
test/test_examples.py::test_passthrough[False-passthrough_fh-True] SKIPPED               [ 59%]
test/test_examples.py::test_passthrough[False-passthrough_ll-False] PASSED               [ 61%]
test/test_examples.py::test_passthrough[False-passthrough_ll-True] PASSED                [ 63%]
test/test_examples.py::test_passthrough[True-passthrough-False] PASSED                   [ 65%]
test/test_examples.py::test_passthrough[True-passthrough-True] SKIPPED                   [ 68%]
test/test_examples.py::test_passthrough[True-passthrough_plus-False] PASSED              [ 70%]
test/test_examples.py::test_passthrough[True-passthrough_plus-True] SKIPPED              [ 72%]
test/test_examples.py::test_passthrough[True-passthrough_fh-False] PASSED                [ 74%]
test/test_examples.py::test_passthrough[True-passthrough_fh-True] SKIPPED                [ 76%]
test/test_examples.py::test_passthrough[True-passthrough_ll-False] PASSED                [ 78%]
test/test_examples.py::test_passthrough[True-passthrough_ll-True] PASSED                 [ 80%]
test/test_examples.py::test_passthrough_hp[False] PASSED                                 [ 82%]
test/test_examples.py::test_passthrough_hp[True] PASSED                                  [ 85%]
test/test_examples.py::test_ioctl PASSED                                                 [ 87%]
test/test_examples.py::test_poll PASSED                                                  [ 89%]
test/test_examples.py::test_null PASSED                                                  [ 91%]
test/test_examples.py::test_notify_inval_entry[True] PASSED                              [ 93%]
test/test_examples.py::test_notify_inval_entry[False] PASSED                             [ 95%]
test/test_examples.py::test_cuse PASSED                                                  [ 97%]
test/test_examples.py::test_printcap PASSED                                              [100%]

=================================== short test summary info ====================================
SKIPPED [6] test/test_examples.py:143: example does not support writeback caching
================================ 41 passed, 6 skipped in 42.90s ================================","reduce memset in fuse_reply_create initialize buf.
set buffer default value with buf[0] = \0
Log:
test/test_ctests.py::test_write_cache[False] PASSED                                      [  2%]
test/test_ctests.py::test_write_cache[True] PASSED                                       [  4%]
test/test_ctests.py::test_notify1[True-notify_inval_inode] PASSED                        [  6%]
test/test_ctests.py::test_notify1[True-invalidate_path] PASSED                           [  8%]
test/test_ctests.py::test_notify1[True-notify_store_retrieve] PASSED                     [ 10%]
test/test_ctests.py::test_notify1[False-notify_inval_inode] PASSED                       [ 12%]
test/test_ctests.py::test_notify1[False-invalidate_path] PASSED                          [ 14%]
test/test_ctests.py::test_notify1[False-notify_store_retrieve] PASSED                    [ 17%]
test/test_ctests.py::test_notify_file_size[True] PASSED                                  [ 19%]
test/test_ctests.py::test_notify_file_size[False] PASSED                                 [ 21%]
test/test_examples.py::test_hello[hello-options0-invoke_directly] PASSED                 [ 23%]
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse] PASSED               [ 25%]
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse_drop_privileges] PASSED [ 27%]
test/test_examples.py::test_hello[hello-options1-invoke_directly] PASSED                 [ 29%]
test/test_examples.py::test_hello[hello-options1-invoke_mount_fuse] PASSED               [ 31%]
test/test_examples.py::test_hello[hello-options1-invoke_mount_fuse_drop_privileges] PASSED [ 34%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_directly] PASSED              [ 36%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_mount_fuse] PASSED            [ 38%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_mount_fuse_drop_privileges] PASSED [ 40%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_directly] PASSED              [ 42%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_mount_fuse] PASSED            [ 44%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_mount_fuse_drop_privileges] PASSED [ 46%]
test/test_examples.py::test_passthrough[False-passthrough-False] PASSED                  [ 48%]
test/test_examples.py::test_passthrough[False-passthrough-True] SKIPPED                  [ 51%]
test/test_examples.py::test_passthrough[False-passthrough_plus-False] PASSED             [ 53%]
test/test_examples.py::test_passthrough[False-passthrough_plus-True] SKIPPED             [ 55%]
test/test_examples.py::test_passthrough[False-passthrough_fh-False] PASSED               [ 57%]
test/test_examples.py::test_passthrough[False-passthrough_fh-True] SKIPPED               [ 59%]
test/test_examples.py::test_passthrough[False-passthrough_ll-False] PASSED               [ 61%]
test/test_examples.py::test_passthrough[False-passthrough_ll-True] PASSED                [ 63%]
test/test_examples.py::test_passthrough[True-passthrough-False] PASSED                   [ 65%]
test/test_examples.py::test_passthrough[True-passthrough-True] SKIPPED                   [ 68%]
test/test_examples.py::test_passthrough[True-passthrough_plus-False] PASSED              [ 70%]
test/test_examples.py::test_passthrough[True-passthrough_plus-True] SKIPPED              [ 72%]
test/test_examples.py::test_passthrough[True-passthrough_fh-False] PASSED                [ 74%]
test/test_examples.py::test_passthrough[True-passthrough_fh-True] SKIPPED                [ 76%]
test/test_examples.py::test_passthrough[True-passthrough_ll-False] PASSED                [ 78%]
test/test_examples.py::test_passthrough[True-passthrough_ll-True] PASSED                 [ 80%]
test/test_examples.py::test_passthrough_hp[False] PASSED                                 [ 82%]
test/test_examples.py::test_passthrough_hp[True] PASSED                                  [ 85%]
test/test_examples.py::test_ioctl PASSED                                                 [ 87%]
test/test_examples.py::test_poll PASSED                                                  [ 89%]
test/test_examples.py::test_null PASSED                                                  [ 91%]
test/test_examples.py::test_notify_inval_entry[True] PASSED                              [ 93%]
test/test_examples.py::test_notify_inval_entry[False] PASSED                             [ 95%]
test/test_examples.py::test_cuse PASSED                                                  [ 97%]
test/test_examples.py::test_printcap PASSED                                              [100%]

=================================== short test summary info ====================================
SKIPPED [6] test/test_examples.py:143: example does not support writeback caching
================================ 41 passed, 6 skipped in 42.90s ================================",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,648,2022-03-21T10:03:17Z,2022-04-17T12:53:52Z,2022-04-17T12:53:52Z,CLOSED,False,4,5,3,https://github.com/heysion,fix: reduce memset syscall and set buf default value,1,[],https://github.com/libfuse/libfuse/pull/648,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/648#issuecomment-1073711173,"reduce memset in fuse_reply_create initialize buf.
set buffer default value with buf[0] = \0
Log:
test/test_ctests.py::test_write_cache[False] PASSED                                      [  2%]
test/test_ctests.py::test_write_cache[True] PASSED                                       [  4%]
test/test_ctests.py::test_notify1[True-notify_inval_inode] PASSED                        [  6%]
test/test_ctests.py::test_notify1[True-invalidate_path] PASSED                           [  8%]
test/test_ctests.py::test_notify1[True-notify_store_retrieve] PASSED                     [ 10%]
test/test_ctests.py::test_notify1[False-notify_inval_inode] PASSED                       [ 12%]
test/test_ctests.py::test_notify1[False-invalidate_path] PASSED                          [ 14%]
test/test_ctests.py::test_notify1[False-notify_store_retrieve] PASSED                    [ 17%]
test/test_ctests.py::test_notify_file_size[True] PASSED                                  [ 19%]
test/test_ctests.py::test_notify_file_size[False] PASSED                                 [ 21%]
test/test_examples.py::test_hello[hello-options0-invoke_directly] PASSED                 [ 23%]
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse] PASSED               [ 25%]
test/test_examples.py::test_hello[hello-options0-invoke_mount_fuse_drop_privileges] PASSED [ 27%]
test/test_examples.py::test_hello[hello-options1-invoke_directly] PASSED                 [ 29%]
test/test_examples.py::test_hello[hello-options1-invoke_mount_fuse] PASSED               [ 31%]
test/test_examples.py::test_hello[hello-options1-invoke_mount_fuse_drop_privileges] PASSED [ 34%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_directly] PASSED              [ 36%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_mount_fuse] PASSED            [ 38%]
test/test_examples.py::test_hello[hello_ll-options0-invoke_mount_fuse_drop_privileges] PASSED [ 40%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_directly] PASSED              [ 42%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_mount_fuse] PASSED            [ 44%]
test/test_examples.py::test_hello[hello_ll-options1-invoke_mount_fuse_drop_privileges] PASSED [ 46%]
test/test_examples.py::test_passthrough[False-passthrough-False] PASSED                  [ 48%]
test/test_examples.py::test_passthrough[False-passthrough-True] SKIPPED                  [ 51%]
test/test_examples.py::test_passthrough[False-passthrough_plus-False] PASSED             [ 53%]
test/test_examples.py::test_passthrough[False-passthrough_plus-True] SKIPPED             [ 55%]
test/test_examples.py::test_passthrough[False-passthrough_fh-False] PASSED               [ 57%]
test/test_examples.py::test_passthrough[False-passthrough_fh-True] SKIPPED               [ 59%]
test/test_examples.py::test_passthrough[False-passthrough_ll-False] PASSED               [ 61%]
test/test_examples.py::test_passthrough[False-passthrough_ll-True] PASSED                [ 63%]
test/test_examples.py::test_passthrough[True-passthrough-False] PASSED                   [ 65%]
test/test_examples.py::test_passthrough[True-passthrough-True] SKIPPED                   [ 68%]
test/test_examples.py::test_passthrough[True-passthrough_plus-False] PASSED              [ 70%]
test/test_examples.py::test_passthrough[True-passthrough_plus-True] SKIPPED              [ 72%]
test/test_examples.py::test_passthrough[True-passthrough_fh-False] PASSED                [ 74%]
test/test_examples.py::test_passthrough[True-passthrough_fh-True] SKIPPED                [ 76%]
test/test_examples.py::test_passthrough[True-passthrough_ll-False] PASSED                [ 78%]
test/test_examples.py::test_passthrough[True-passthrough_ll-True] PASSED                 [ 80%]
test/test_examples.py::test_passthrough_hp[False] PASSED                                 [ 82%]
test/test_examples.py::test_passthrough_hp[True] PASSED                                  [ 85%]
test/test_examples.py::test_ioctl PASSED                                                 [ 87%]
test/test_examples.py::test_poll PASSED                                                  [ 89%]
test/test_examples.py::test_null PASSED                                                  [ 91%]
test/test_examples.py::test_notify_inval_entry[True] PASSED                              [ 93%]
test/test_examples.py::test_notify_inval_entry[False] PASSED                             [ 95%]
test/test_examples.py::test_cuse PASSED                                                  [ 97%]
test/test_examples.py::test_printcap PASSED                                              [100%]

=================================== short test summary info ====================================
SKIPPED [6] test/test_examples.py:143: example does not support writeback caching
================================ 41 passed, 6 skipped in 42.90s ================================","As far as I can tell, the patch only adds explicit initialization.
Could you elaborate on the benefits of this change?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,649,2022-03-21T19:05:26Z,2022-03-22T08:46:33Z,2022-03-22T08:46:33Z,MERGED,True,9,3,1,https://github.com/fdinoff,Fix fd leak with clone_fd,1,[],https://github.com/libfuse/libfuse/pull/649,https://github.com/fdinoff,1,https://github.com/libfuse/libfuse/pull/649,"do_interrupt would destroy_req on the request without decrementing the
channel's refcount. With clone_fd this could leak file descriptors if
the worker thread holding the cloned fd was destroyed. (Only
max_idle_threads are kept).","do_interrupt would destroy_req on the request without decrementing the
channel's refcount. With clone_fd this could leak file descriptors if
the worker thread holding the cloned fd was destroyed. (Only
max_idle_threads are kept).",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,1,https://github.com/libfuse/libfuse/pull/652,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/fdinoff,2,https://github.com/libfuse/libfuse/pull/652#issuecomment-1080830913,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com",I've also noticed issues with this code. One of the other issues we saw was that thread creation holds mt->lock. Which led to weird slowdowns when thread chrun was making thread creation slow.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,3,https://github.com/libfuse/libfuse/pull/652#issuecomment-1081717250,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","Thank you for investigating this! I think you have discovered an issue that should be fixed, but I am not sure if your fix is the right approach since it changes the code to contradict the documentation and name of the max_idle option.
Do I understand correctly that the behavior that gives you better performance could also be achieved by simply setting max_idle to a very high number? In that case, perhaps what is needed is not a code change but a modification of the default value? However, I am a bit wary about tuning a default to optimize a benchmark suite. Do you know if there are any practical applications that benefit from a high number of threads?

Sorry I had first missed your introduction text. Increasing max_idle to a very high value is not a good idea, imho. My final is for sure not to optimize bonnie, but optimize a real live file system. Bonnie over passthrough_{ll,hp} is just a simple test that can be done locally or on a single system and also can be demonstrated to kernel devs. We have tested different max_idle parameters in the past and the default of 10 was not too bad for us. Increasing the number of threads resulted in worse results.
Test kernel patches and to demonstrate it to Miklos/fsdevel I also need to restrict the number of threads.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,4,https://github.com/libfuse/libfuse/pull/652#issuecomment-1081720012,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","Also, there might be applications spawning hundreds or thousands of threads - I don't think that increasing the default number of threads to area of thousands is a good idea.
I simple test for this is here https://github.com/aakefbs/fs-heavy-load-stress-tests",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,5,https://github.com/libfuse/libfuse/pull/652#issuecomment-1083388998,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","@Nikratio When you review it, please pay attention to FUSE_SYMVER  - the usage of ""@@"" and ""@"" is not well documented. I spent ages trying to understand why linking failed and in the end it was the double ""@"" I was initially using.
Please also double verify lib/fuse_versionscript:  ""} FUSE_3.4"".",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/652#issuecomment-1092927439,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","I think I may have poorly expressed some of my previous comments. I am not fundamentally opposed to anything that you're proposing. I may have different thoughts on some of your suggestions, but I am open to be convinced that your way is the better one. So please do not rule anything out just because I said I didn't like it on first sight.
How about you rework the pull request along the lines that you consider best on all the discussions above, and we take a fresh look at that?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,7,https://github.com/libfuse/libfuse/pull/652#issuecomment-1114643781,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com",Just wondering about the current status of this.. are you still working on this? Or is this waiting for my review?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,8,https://github.com/libfuse/libfuse/pull/652#issuecomment-1114660201,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","@Nikratio Please see my comment from 24 days ago - I had asked about your opinion (@BenBE is welcome to comment as well) about the  apprroach using ifdef. The patch is complete, but I need to double check if binary and api compatibility works.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,9,https://github.com/libfuse/libfuse/pull/652#issuecomment-1114676973,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","I'm not sure why we need the version_id in the struct if the struct is private to FUSE. But other than that, this looks fine to me.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,10,https://github.com/libfuse/libfuse/pull/652#issuecomment-1115387361,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","@Nikratio  I kept the 'spurious' ifdef indentation for, as I personally have hard time to decipher it without that. Please let me know what you think - I can remove it.
In any way, please don't merge yet, I didn't manage to run some manual tests yet and I'm not sure if abi/api compatibility is covered already by the existing automatic tests.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,11,https://github.com/libfuse/libfuse/pull/652#issuecomment-1115842086,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","It's a bit odd to have top level function definitions indented, especially with the long multi-line comment. But I guess it's okay.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,12,https://github.com/libfuse/libfuse/pull/652#issuecomment-1119717817,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","@Nikratio  Don't merge it yet please, I eventually found the time to test today and there is another ABI/API issue. I had extended struct fuse_cmdline_opts, but old binaries obviously only pass an old smaller version and that causes a buffer overflow. Looks like we need versioning for that as well. Not sure yet if we want to make it private or follow another way to detect the struct version.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,13,https://github.com/libfuse/libfuse/pull/652#issuecomment-1121564853,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","I hope that I fixed all issues now, although I'm not entirely sure about the ulibc/apple fuse_parse_cmdline() compatible symbol. I don't have a non-linux system - hard to test for me.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,14,https://github.com/libfuse/libfuse/pull/652#issuecomment-1122137841,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com",I don't see github tests running anymore?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,15,https://github.com/libfuse/libfuse/pull/652#issuecomment-1122142458,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","@Nikratio I'm just reviewing a bit my own changes and see this
[lib/meson.build](https://github.com/aakefbs/libfuse/commit/db734ebaae5203f1bac333525bbdb44992e027ad?diff=unified#diff-f95a8510ab53a5e21d9e4a306b12f76fc79086143aa8989c13effed889bec144)
@@ -37,7 +37,7 @@ libfuse = library('fuse3', libfuse_sources, version: meson.project_version(),
                  soversion: '3', include_directories: include_dirs,
                  dependencies: deps, install: true,
                  link_depends: 'fuse_versionscript',
                  c_args: [ '-DFUSE_USE_VERSION=35',
                  c_args: [ '-DFUSE_USE_VERSION=312',

This is with your 3.11 patch applied - why is part of libfuse compiled so far with -DFUSE_USE_VERSION=35?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,16,https://github.com/libfuse/libfuse/pull/652#issuecomment-1122149379,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com",Because some parts of FUSE haven't been updated (or confirmed not to need changes) to use the most recent API.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,17,https://github.com/libfuse/libfuse/pull/652#issuecomment-1127973886,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","So I'm lost here what to do about travis - I don't know what ""Because some parts of FUSE haven't been updated (or confirmed not to need changes) to use the most recent API."" means.
I just set up travis for my own github account and updated patches triggered travis there.
https://app.travis-ci.com/github/aakefbs/libfuse/builds/250710225
I was search for ""github does not run travis"" and at best I find that one should switch to github actions, hmm.
I think missing in the tests are ABI compat checks - build an unpatched version, store the example/ binaries, then add in the patches, compile and run old binaries with the library. I don't know how to automate this with github/travis, though, as it means one needs to compile a different commit than currently provided. I had manually done this, except of ULIBC/APPLE.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,18,https://github.com/libfuse/libfuse/pull/652#issuecomment-1129308217,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","So I'm lost here what to do about travis

Uhm, what's wrong with Travis? And is this related to the pull request?


I don't know what ""Because some parts of FUSE haven't been updated (or confirmed not to need changes) to use the most recent API."" means.


This is unrelated to Travis, I think?
It means that some parts of the FUSE codebase (eg the examples) have not been updated to use the most recent libfuse API. We can leave this as-is (it's not looking great from a maintenance point of view, but there is nothing technically wrong with it). Or, someone would need to look how the API has changed and - where required - update the code to make use of the new API.
Makes sense?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,19,https://github.com/libfuse/libfuse/pull/652#issuecomment-1129349414,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","May question was why Travis does not run on the current patches. So you say that because I didn't update everything to the new API it does not run travis? How would it know that?
I have no issue to update the all the other examples, but I think we should add some tests for the old API - I had basically used non-converted examples to test that I didn't break anything (and initially found some issues).
Any objections to merge and I work on API tests during the next days?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,20,https://github.com/libfuse/libfuse/pull/652#issuecomment-1129363467,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","May question was why Travis does not run on the current patches.

Ah, good question. Looks like an issue on the Travis side - there are ""no credits left"". But as an open-source project we shouldn't need any credits. I've emailed support.

So you say that because I didn't update everything to the new API it does not run travis?

No, I'm saying this is totally unrelated.

I have no issue to update the all the other examples, but I think we should add some tests for the old API - I had basically used non-converted examples to test that I didn't break anything (and initially found some issues). Any objections to merge and I work on API tests during the next days?

Let's wait until Travis is back-up (hopefully support will respond soon), just to make sure we don't break CI by accident.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,21,https://github.com/libfuse/libfuse/pull/652#issuecomment-1139464247,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","Any updates on Travis? I wonder if we should switch to github actions. Btw, eventually I understood you comment ""Because some parts of FUSE haven't been updated (or confirmed not to need changes) to use the most recent API."" - it is related to my question about ""-DFUSE_USE_VERSION"" in different meson files and not to my unit-test/travis question.  Pity that github does not have threaded comments...",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/Nikratio,22,https://github.com/libfuse/libfuse/pull/652#issuecomment-1139507638,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com","Travis should be running again, it seems you need to reapply for open source credits once a year",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,652,2022-03-28T11:33:00Z,,2022-06-01T10:48:24Z,OPEN,False,413,61,14,https://github.com/aakefbs,fuse-loop/fuse_do_work: Avoid lots of thread creations/destructions,3,[],https://github.com/libfuse/libfuse/pull/652,https://github.com/aakefbs,23,https://github.com/libfuse/libfuse/pull/652#issuecomment-1143442095,"On benchmarking metadata operations with a single threaded bonnie++
and ""max_idle_threads"" limited to 1, 'top' was showing suspicious
160% cpu usage.
Profiling the system with flame graphs showed that an astonishing
amount of CPU time was spent in thread creation and destruction.
After verifying the code it turned out that fuse_do_work() was
creating a new thread every time all existing idle threads
were already busy. And then just a few lines later after processing
the current request it noticed that it had created too many threads
and destructed the current thread. I.e. there was a thread
creation/destruction ping-pong.
Code is changed to only create new threads if the max number of
threads is not reached.
Furthermore, thread destruction is disabled, as creation/destruction
is expensive in general.
With this change cpu usage of passthrough_hp went from ~160% to
~80% (with different values of max_idle_threads). And bonnie
values got approximately faster by 90%. This is a with single
threaded bonnie++
bonnie++ -x 4 -q -s0  -d  -n 30:1:1:10 -r 0
Without this patch, using the default max_idle_threads=10 and just
a single bonnie++ the thread creation/destruction code path is not
triggered.  Just one libfuse and one application thread is just
a corner case - the requirement for the issue was just
n-application-threads >= max_idle_threads.
Signed-off-by: Bernd Schubert bschubert@ddn.com",Thanks for fixing it! Looks like Travis verified the request. Any objections to merge?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,653,2022-03-28T11:42:51Z,2022-03-31T14:27:02Z,2022-03-31T17:39:01Z,MERGED,True,39,7,1,https://github.com/aakefbs,Passthrough hp,2,[],https://github.com/libfuse/libfuse/pull/653,https://github.com/aakefbs,1,https://github.com/libfuse/libfuse/pull/653,Two fixes - disable splice and and inode ref leak.,Two fixes - disable splice and and inode ref leak.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,653,2022-03-28T11:42:51Z,2022-03-31T14:27:02Z,2022-03-31T17:39:01Z,MERGED,True,39,7,1,https://github.com/aakefbs,Passthrough hp,2,[],https://github.com/libfuse/libfuse/pull/653,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/653#issuecomment-1082134567,Two fixes - disable splice and and inode ref leak.,"Looks good, thanks. Will merge when CI run is complete.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,653,2022-03-28T11:42:51Z,2022-03-31T14:27:02Z,2022-03-31T17:39:01Z,MERGED,True,39,7,1,https://github.com/aakefbs,Passthrough hp,2,[],https://github.com/libfuse/libfuse/pull/653,https://github.com/aakefbs,3,https://github.com/libfuse/libfuse/pull/653#issuecomment-1082420593,Two fixes - disable splice and and inode ref leak.,Did I overload travis and it does not want to run anymore?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,653,2022-03-28T11:42:51Z,2022-03-31T14:27:02Z,2022-03-31T17:39:01Z,MERGED,True,39,7,1,https://github.com/aakefbs,Passthrough hp,2,[],https://github.com/libfuse/libfuse/pull/653,https://github.com/aakefbs,4,https://github.com/libfuse/libfuse/pull/653#issuecomment-1084912862,Two fixes - disable splice and and inode ref leak.,Thank you!,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,654,2022-03-28T16:27:17Z,,2022-04-17T12:48:02Z,OPEN,False,20,2,1,https://github.com/aakefbs,passthrough_hp: Add options for clone_fd and number of threads,1,[],https://github.com/libfuse/libfuse/pull/654,https://github.com/aakefbs,1,https://github.com/libfuse/libfuse/pull/654,This is useful for benchmarking fuse.,This is useful for benchmarking fuse.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,655,2022-04-08T06:53:50Z,2022-04-08T08:56:31Z,2022-04-08T10:12:01Z,CLOSED,False,370,57,8,https://github.com/d-hans,Parallel writes,6,[],https://github.com/libfuse/libfuse/pull/655,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/655,Allow parallel direct writes on the same file,Allow parallel direct writes on the same file,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,655,2022-04-08T06:53:50Z,2022-04-08T08:56:31Z,2022-04-08T10:12:01Z,CLOSED,False,370,57,8,https://github.com/d-hans,Parallel writes,6,[],https://github.com/libfuse/libfuse/pull/655,https://github.com/d-hans,2,https://github.com/libfuse/libfuse/pull/655#issuecomment-1092620038,Allow parallel direct writes on the same file,closing this pull request as it got combined with other patches whereas wants to raise it for parallel write only,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,656,2022-04-08T09:20:09Z,2022-04-08T14:34:32Z,2022-05-02T06:19:44Z,MERGED,True,51,38,2,https://github.com/d-hans,Modify structures in libfuse to handle flags beyond 32 bits.,1,[],https://github.com/libfuse/libfuse/pull/656,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/656,"In fuse kernel, 'commit 53db28933e95 (""fuse: extend init flags"")'
made the changes to handle flags going beyond 32 bits but i think
changes were not done in libfuse to handle the same.
This patch prepares the ground in libfuse for incoming FUSE kernel
patches (Atomic open + lookup) where flags went beyond 32 bits.
It makes struct same as in fuse kernel resulting in name change of
few fields.","In fuse kernel, 'commit 53db28933e95 (""fuse: extend init flags"")'
made the changes to handle flags going beyond 32 bits but i think
changes were not done in libfuse to handle the same.
This patch prepares the ground in libfuse for incoming FUSE kernel
patches (Atomic open + lookup) where flags went beyond 32 bits.
It makes struct same as in fuse kernel resulting in name change of
few fields.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,657,2022-04-08T10:09:01Z,2022-05-02T05:53:28Z,2022-05-02T06:19:37Z,CLOSED,False,322,55,8,https://github.com/d-hans,Atomic open+lookup,4,[],https://github.com/libfuse/libfuse/pull/657,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/657,"This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-1-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-2-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-3-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322121212.5087-1-dharamhans87@gmail.com/","This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-1-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-2-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-3-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322121212.5087-1-dharamhans87@gmail.com/",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,657,2022-04-08T10:09:01Z,2022-05-02T05:53:28Z,2022-05-02T06:19:37Z,CLOSED,False,322,55,8,https://github.com/d-hans,Atomic open+lookup,4,[],https://github.com/libfuse/libfuse/pull/657,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/657#issuecomment-1092929554,"This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-1-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-2-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-3-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322121212.5087-1-dharamhans87@gmail.com/",Could you please ping this request once the changes have been merged into the kernel?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,657,2022-04-08T10:09:01Z,2022-05-02T05:53:28Z,2022-05-02T06:19:37Z,CLOSED,False,322,55,8,https://github.com/d-hans,Atomic open+lookup,4,[],https://github.com/libfuse/libfuse/pull/657,https://github.com/d-hans,3,https://github.com/libfuse/libfuse/pull/657#issuecomment-1114520214,"This patch series prepares the ground and implement atomic lookup + open in libfuse. Also it modifies passthrough_ll to handle the same. Code changes to implement atomic open in fuse kernel has been raised through following patch series
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-1-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-2-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322115148.3870-3-dharamhans87@gmail.com/
https://lore.kernel.org/linux-fsdevel/20220322121212.5087-1-dharamhans87@gmail.com/","would be raising a new request as some changes has been done in fuse kernel patches(not merged yet), we need corresponding changes here in libfuse.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,658,2022-04-08T10:10:34Z,2022-04-08T14:36:02Z,2022-05-02T06:20:04Z,MERGED,True,18,0,1,https://github.com/d-hans,Passthrough_ll should display cmd line options,1,[],https://github.com/libfuse/libfuse/pull/658,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/658,"Make passthrough_ll to display all its cmdline options
instead of keeping them hidden.
(I am not sure if these are intentionally kept hidden)","Make passthrough_ll to display all its cmdline options
instead of keeping them hidden.
(I am not sure if these are intentionally kept hidden)",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,659,2022-04-08T10:20:23Z,,2022-04-17T12:47:20Z,OPEN,False,30,2,5,https://github.com/d-hans,Enable parallel direct writes on the same file,1,[],https://github.com/libfuse/libfuse/pull/659,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/659,"Right now fuse kernel serializes direct writes on the
same file. This serialization is good for such FUSE
implementations which rely on the inode lock to
avoid any data inconsistency issues but it hurts badly
such FUSE implementations which have their own mechanism
of dealing with cache/data integrity and can handle
parallel writes on the same file.
This patch allows parallel writes on the same file to be
enabled with the help of a flag FOPEN_PARALLEL_WRITES.
FUSE implementations which want to use this feature can
set this flag during fuse init. Default behaviour remains
same i.e no parallel writes on the same file.
Raised the corresponding fuse kernel patches
https://lore.kernel.org/linux-fsdevel/20220408061809.12324-2-dharamhans87@gmail.com/T/#mb83b9cfa287f880657d226333eea05a5396aff8b
https://lore.kernel.org/linux-fsdevel/20220408061809.12324-2-dharamhans87@gmail.com/T/#m26fdbf6424ad4c39ea0d0dcd444fe736182aeaf2","Right now fuse kernel serializes direct writes on the
same file. This serialization is good for such FUSE
implementations which rely on the inode lock to
avoid any data inconsistency issues but it hurts badly
such FUSE implementations which have their own mechanism
of dealing with cache/data integrity and can handle
parallel writes on the same file.
This patch allows parallel writes on the same file to be
enabled with the help of a flag FOPEN_PARALLEL_WRITES.
FUSE implementations which want to use this feature can
set this flag during fuse init. Default behaviour remains
same i.e no parallel writes on the same file.
Raised the corresponding fuse kernel patches
https://lore.kernel.org/linux-fsdevel/20220408061809.12324-2-dharamhans87@gmail.com/T/#mb83b9cfa287f880657d226333eea05a5396aff8b
https://lore.kernel.org/linux-fsdevel/20220408061809.12324-2-dharamhans87@gmail.com/T/#m26fdbf6424ad4c39ea0d0dcd444fe736182aeaf2",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,659,2022-04-08T10:20:23Z,,2022-04-17T12:47:20Z,OPEN,False,30,2,5,https://github.com/d-hans,Enable parallel direct writes on the same file,1,[],https://github.com/libfuse/libfuse/pull/659,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/659#issuecomment-1092922432,"Right now fuse kernel serializes direct writes on the
same file. This serialization is good for such FUSE
implementations which rely on the inode lock to
avoid any data inconsistency issues but it hurts badly
such FUSE implementations which have their own mechanism
of dealing with cache/data integrity and can handle
parallel writes on the same file.
This patch allows parallel writes on the same file to be
enabled with the help of a flag FOPEN_PARALLEL_WRITES.
FUSE implementations which want to use this feature can
set this flag during fuse init. Default behaviour remains
same i.e no parallel writes on the same file.
Raised the corresponding fuse kernel patches
https://lore.kernel.org/linux-fsdevel/20220408061809.12324-2-dharamhans87@gmail.com/T/#mb83b9cfa287f880657d226333eea05a5396aff8b
https://lore.kernel.org/linux-fsdevel/20220408061809.12324-2-dharamhans87@gmail.com/T/#m26fdbf6424ad4c39ea0d0dcd444fe736182aeaf2",Thanks! Could you please ping this request once the necessary patches have been merged into the kernel?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,661,2022-04-11T18:02:30Z,2022-04-17T12:45:38Z,2022-04-17T12:45:38Z,MERGED,True,8,0,1,https://github.com/aakefbs,Add missing kernel flags up to 1ULL << 33,1,[],https://github.com/libfuse/libfuse/pull/661,https://github.com/aakefbs,1,https://github.com/libfuse/libfuse/pull/661,Just a further sync with the in-kernel flags.,Just a further sync with the in-kernel flags.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,661,2022-04-11T18:02:30Z,2022-04-17T12:45:38Z,2022-04-17T12:45:38Z,MERGED,True,8,0,1,https://github.com/aakefbs,Add missing kernel flags up to 1ULL << 33,1,[],https://github.com/libfuse/libfuse/pull/661,https://github.com/aakefbs,2,https://github.com/libfuse/libfuse/pull/661#issuecomment-1100227894,Just a further sync with the in-kernel flags.,@d-hans Please review.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,662,2022-04-11T18:42:48Z,2022-04-17T12:45:18Z,2022-04-17T12:45:18Z,MERGED,True,5,2,1,https://github.com/aakefbs,Set FUSE_INIT_EXT in fuse_init_out::flags,1,[],https://github.com/libfuse/libfuse/pull/662,https://github.com/aakefbs,1,https://github.com/libfuse/libfuse/pull/662,"It is better to tell the kernel that libfuse knows
about the 64 bit flag extension.","It is better to tell the kernel that libfuse knows
about the 64 bit flag extension.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,662,2022-04-11T18:42:48Z,2022-04-17T12:45:18Z,2022-04-17T12:45:18Z,MERGED,True,5,2,1,https://github.com/aakefbs,Set FUSE_INIT_EXT in fuse_init_out::flags,1,[],https://github.com/libfuse/libfuse/pull/662,https://github.com/aakefbs,2,https://github.com/libfuse/libfuse/pull/662#issuecomment-1095422118,"It is better to tell the kernel that libfuse knows
about the 64 bit flag extension.",Patch for the kernel side also follows.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,662,2022-04-11T18:42:48Z,2022-04-17T12:45:18Z,2022-04-17T12:45:18Z,MERGED,True,5,2,1,https://github.com/aakefbs,Set FUSE_INIT_EXT in fuse_init_out::flags,1,[],https://github.com/libfuse/libfuse/pull/662,https://github.com/aakefbs,3,https://github.com/libfuse/libfuse/pull/662#issuecomment-1100227551,"It is better to tell the kernel that libfuse knows
about the 64 bit flag extension.",@d-hans Please review.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/schra,1,https://github.com/libfuse/libfuse/pull/664,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));","I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/aakefbs,2,https://github.com/libfuse/libfuse/pull/664#issuecomment-1100278743,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));","See fuse.c fill_dir() and the called fuse_add_direntry(). If use_ino is specified, it uses the inode number. And anyway, it uses the buffer to fill in dirent->type.
Similar with a bit more complex code in fill_dir_plus().
Line 2777 in fuse.c points to fuse_lib_getattr(), which is the kernel getattr call - it might get called on readdir(), but also gets called normal stat().
Anyway, I don't think your patch is correct. If you want to document it, please add in that without readdir-plus file-type and inode number are used from struct stat.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/Nikratio,3,https://github.com/libfuse/libfuse/pull/664#issuecomment-1100868207,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));",What @aakefbs said :-).,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/schra,4,https://github.com/libfuse/libfuse/pull/664#issuecomment-1101787669,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));","I tried to adjust the wording according to @aakefbs' concerns and pushed it to my fork. But since the PR is closed now, the PR is not updated anymore with my changes. Here is my updated commit in my fork: schra@3b2979a. Is that wording better @Nikratio @aakefbs?",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/aakefbs,5,https://github.com/libfuse/libfuse/pull/664#issuecomment-1101816950,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));",Much better now! Looks good to me.,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/Nikratio,6,https://github.com/libfuse/libfuse/pull/664#issuecomment-1102500276,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));",Looks good to me to. It looks like I can't re-open the pull request either. Maybe you can open a new one?,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,664,2022-04-14T21:44:06Z,2022-04-17T12:43:55Z,2022-04-19T16:45:03Z,CLOSED,False,4,0,1,https://github.com/schra,patch: document ignored parameter of readdir's fill parameter,1,[],https://github.com/libfuse/libfuse/pull/664,https://github.com/schra,7,https://github.com/libfuse/libfuse/pull/664#issuecomment-1102867699,"I'm not 100% sure about this. My reasoning is as follows:
fuse_lib_readdir calls fuse_readdir_common which calls
readdir_fill which uses fill_dir as the fuse_fill_dir_t.
fill_dir will then call fuse_add_direntry_to_dh and push an entry to
a linked list. That is, the stat that you pass to the fill function is
definitely stored in the linked list.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 3545
      in
      2b7a6f0
    
  
  
    

        
          
           if (fuse_add_direntry_to_dh(dh, name, &stbuf) == -1) 
        
    
  


However, I think that the linked list is not really used (?). If you
want to access the stat via the fs, then the getattr hook is
executed, which, however, doesn't use the linked list and just uses a
new, zeroed-out stdbuf.
See 
  
    
      libfuse/lib/fuse.c
    
    
         Line 2777
      in
      2b7a6f0
    
  
  
    

        
          
           memset(&buf, 0, sizeof(buf));",Created a new PR. Thanks for the elaborate feedback folks :),True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,665,2022-04-19T16:43:35Z,2022-04-20T10:15:08Z,2022-04-20T10:15:08Z,MERGED,True,7,0,1,https://github.com/schra,patch: document ignored fill parameter of readdir,1,[],https://github.com/libfuse/libfuse/pull/665,https://github.com/schra,1,https://github.com/libfuse/libfuse/pull/665,Follow-up of #664,Follow-up of #664,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,666,2022-04-20T05:09:20Z,2022-04-20T05:10:35Z,2022-04-20T05:10:35Z,CLOSED,False,218,56,7,https://github.com/flying-122,support fuse crash recovery,1,[],https://github.com/libfuse/libfuse/pull/666,https://github.com/flying-122,1,https://github.com/libfuse/libfuse/pull/666,Signed-off-by: Peng Hao flyingpeng@tencent.com,Signed-off-by: Peng Hao flyingpeng@tencent.com,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,671,2022-05-02T05:58:41Z,2022-05-02T06:36:16Z,2022-05-02T06:36:16Z,CLOSED,False,165,1,6,https://github.com/d-hans,Implement Atomic lookup + create,1,[],https://github.com/libfuse/libfuse/pull/671,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/671,"There are certain places where we can avoid costly lookup calls
into libfuse from fuse kernel. One of such place is

When we go for opening the file with O_CREAT flags.

Since we are going to create a file (passing O_CREAT in open),
its very much likely that file does not exist yet so lookup
performed before creating a file can be avoided. Instead this
lookup can be performed as part of create call itself.
Now with these changes, user space when receiving atomic create is
supposed to create the file if it does not exist/perform lookup on
the file if already existing, fill in the attributes, set 'file_created'
bit in 'struct fuse_file_info' and open the file. These filled in
attributes are used by fuse kernel to make inode stand/revalidate.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","There are certain places where we can avoid costly lookup calls
into libfuse from fuse kernel. One of such place is

When we go for opening the file with O_CREAT flags.

Since we are going to create a file (passing O_CREAT in open),
its very much likely that file does not exist yet so lookup
performed before creating a file can be avoided. Instead this
lookup can be performed as part of create call itself.
Now with these changes, user space when receiving atomic create is
supposed to create the file if it does not exist/perform lookup on
the file if already existing, fill in the attributes, set 'file_created'
bit in 'struct fuse_file_info' and open the file. These filled in
attributes are used by fuse kernel to make inode stand/revalidate.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,671,2022-05-02T05:58:41Z,2022-05-02T06:36:16Z,2022-05-02T06:36:16Z,CLOSED,False,165,1,6,https://github.com/d-hans,Implement Atomic lookup + create,1,[],https://github.com/libfuse/libfuse/pull/671,https://github.com/d-hans,2,https://github.com/libfuse/libfuse/pull/671#issuecomment-1114542659,"There are certain places where we can avoid costly lookup calls
into libfuse from fuse kernel. One of such place is

When we go for opening the file with O_CREAT flags.

Since we are going to create a file (passing O_CREAT in open),
its very much likely that file does not exist yet so lookup
performed before creating a file can be avoided. Instead this
lookup can be performed as part of create call itself.
Now with these changes, user space when receiving atomic create is
supposed to create the file if it does not exist/perform lookup on
the file if already existing, fill in the attributes, set 'file_created'
bit in 'struct fuse_file_info' and open the file. These filled in
attributes are used by fuse kernel to make inode stand/revalidate.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t",duplicate,True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,672,2022-05-02T06:33:37Z,,2022-05-17T11:10:36Z,OPEN,False,251,18,6,https://github.com/d-hans,Atomic open passthrough ll,2,[],https://github.com/libfuse/libfuse/pull/672,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/672,"These patches implement atomic open + lookup in libfuse. Passthrough_ll has also been modified to handle atomic open requests.
Link to the fuse kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","These patches implement atomic open + lookup in libfuse. Passthrough_ll has also been modified to handle atomic open requests.
Link to the fuse kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,672,2022-05-02T06:33:37Z,,2022-05-17T11:10:36Z,OPEN,False,251,18,6,https://github.com/d-hans,Atomic open passthrough ll,2,[],https://github.com/libfuse/libfuse/pull/672,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/672#issuecomment-1114642403,"These patches implement atomic open + lookup in libfuse. Passthrough_ll has also been modified to handle atomic open requests.
Link to the fuse kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","Thanks! Can you please re-submit this pull request once the patches have been merged into an official kernel release? In the meantime, I'll convert this to draf",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,672,2022-05-02T06:33:37Z,,2022-05-17T11:10:36Z,OPEN,False,251,18,6,https://github.com/d-hans,Atomic open passthrough ll,2,[],https://github.com/libfuse/libfuse/pull/672,https://github.com/d-hans,3,https://github.com/libfuse/libfuse/pull/672#issuecomment-1114707660,"These patches implement atomic open + lookup in libfuse. Passthrough_ll has also been modified to handle atomic open requests.
Link to the fuse kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","Sure, Thanks Nikolaus!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,673,2022-05-02T06:35:57Z,,2022-05-17T10:57:53Z,OPEN,False,211,1,7,https://github.com/d-hans,Atomic create passthrough ll,2,[],https://github.com/libfuse/libfuse/pull/673,https://github.com/d-hans,1,https://github.com/libfuse/libfuse/pull/673,"These patches implements atomic create operation. passthrough_ll has been modified to handle atomic create.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","These patches implements atomic create operation. passthrough_ll has been modified to handle atomic create.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,673,2022-05-02T06:35:57Z,,2022-05-17T10:57:53Z,OPEN,False,211,1,7,https://github.com/d-hans,Atomic create passthrough ll,2,[],https://github.com/libfuse/libfuse/pull/673,https://github.com/Nikratio,2,https://github.com/libfuse/libfuse/pull/673#issuecomment-1114642180,"These patches implements atomic create operation. passthrough_ll has been modified to handle atomic create.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","Thanks! Can you please re-submit this pull request once the patches have been merged into an official kernel release? In the meantime, I'll convert this to draft.",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,673,2022-05-02T06:35:57Z,,2022-05-17T10:57:53Z,OPEN,False,211,1,7,https://github.com/d-hans,Atomic create passthrough ll,2,[],https://github.com/libfuse/libfuse/pull/673,https://github.com/d-hans,3,https://github.com/libfuse/libfuse/pull/673#issuecomment-1114707957,"These patches implements atomic create operation. passthrough_ll has been modified to handle atomic create.
Link to the kernel patch is
https://lore.kernel.org/linux-fsdevel/20220502054628.25826-1-dharamhans87@gmail.com/T/#t","Would do, thanks!",True,{}
libfuse/libfuse,https://github.com/libfuse/libfuse,677,2022-05-06T13:55:45Z,2022-05-06T20:21:07Z,2022-05-09T08:46:40Z,MERGED,True,4,2,1,https://github.com/aakefbs,Fix a test strncpy compilation warning with recent gcc ,1,[],https://github.com/libfuse/libfuse/pull/677,https://github.com/aakefbs,1,https://github.com/libfuse/libfuse/pull/677,"meson configure -D buildtype=debugoptimized
meson configure -D b_sanitize=address,undefined
Results in '-fsanitize=address,undefined ... -O2 -g' that made
compilation to give errors with recent gcc versions.
bernd@t1700bs build-ubuntu>ninja -v
[1/2] ccache gcc -Itest/test_syscalls.p -Itest -I../test -Iinclude -I../include -Ilib -I../lib -I. -I.. -fdiagnostics-color=always -fsanitize=address,undefined -fno-omit-frame-pointer -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wextra -Werror -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -DHAVE_SYMVER_ATTRIBUTE -MD -MQ test/test_syscalls.p/test_syscalls.c.o -MF test/test_syscalls.p/test_syscalls.c.o.d -o test/test_syscalls.p/test_syscalls.c.o -c ../test/test_syscalls.c
FAILED: test/test_syscalls.p/test_syscalls.c.o
ccache gcc -Itest/test_syscalls.p -Itest -I../test -Iinclude -I../include -Ilib -I../lib -I. -I.. -fdiagnostics-color=always -fsanitize=address,undefined -fno-omit-frame-pointer -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wextra -Werror -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -DHAVE_SYMVER_ATTRIBUTE -MD -MQ test/test_syscalls.p/test_syscalls.c.o -MF test/test_syscalls.p/test_syscalls.c.o.d -o test/test_syscalls.p/test_syscalls.c.o -c ../test/test_syscalls.c
In file included from /usr/include/string.h:519,
from ../test/test_syscalls.c:7:
In function ‘strncpy’,
inlined from ‘test_socket’ at ../test/test_syscalls.c:1885:2,
inlined from ‘main’ at ../test/test_syscalls.c:2030:9:
/usr/include/x86_64-linux-gnu/bits/string_fortified.h:95:10: error: ‘__builtin_strncpy’ output may be truncated copying 107 bytes from a string of length 1023 [-Werror=stringop-truncation]
95 |   return __builtin___strncpy_chk (__dest, __src, __len,
|          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
96 |                                   __glibc_objsize (__dest));
|                                   ~~~~~~~~~~~~~~~~~~~~~~~~~
I disagree a bit on the gcc sanity here, as the code was behaving
correctly and even already checked the string length. But sice
the string length is already verified, that length can be used
for the final strncpy.","meson configure -D buildtype=debugoptimized
meson configure -D b_sanitize=address,undefined
Results in '-fsanitize=address,undefined ... -O2 -g' that made
compilation to give errors with recent gcc versions.
bernd@t1700bs build-ubuntu>ninja -v
[1/2] ccache gcc -Itest/test_syscalls.p -Itest -I../test -Iinclude -I../include -Ilib -I../lib -I. -I.. -fdiagnostics-color=always -fsanitize=address,undefined -fno-omit-frame-pointer -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wextra -Werror -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -DHAVE_SYMVER_ATTRIBUTE -MD -MQ test/test_syscalls.p/test_syscalls.c.o -MF test/test_syscalls.p/test_syscalls.c.o.d -o test/test_syscalls.p/test_syscalls.c.o -c ../test/test_syscalls.c
FAILED: test/test_syscalls.p/test_syscalls.c.o
ccache gcc -Itest/test_syscalls.p -Itest -I../test -Iinclude -I../include -Ilib -I../lib -I. -I.. -fdiagnostics-color=always -fsanitize=address,undefined -fno-omit-frame-pointer -pipe -D_FILE_OFFSET_BITS=64 -Wall -Winvalid-pch -Wextra -Werror -O2 -g -D_REENTRANT -DHAVE_CONFIG_H -Wno-sign-compare -Wstrict-prototypes -Wmissing-declarations -Wwrite-strings -fno-strict-aliasing -Wno-unused-result -DHAVE_SYMVER_ATTRIBUTE -MD -MQ test/test_syscalls.p/test_syscalls.c.o -MF test/test_syscalls.p/test_syscalls.c.o.d -o test/test_syscalls.p/test_syscalls.c.o -c ../test/test_syscalls.c
In file included from /usr/include/string.h:519,
from ../test/test_syscalls.c:7:
In function ‘strncpy’,
inlined from ‘test_socket’ at ../test/test_syscalls.c:1885:2,
inlined from ‘main’ at ../test/test_syscalls.c:2030:9:
/usr/include/x86_64-linux-gnu/bits/string_fortified.h:95:10: error: ‘__builtin_strncpy’ output may be truncated copying 107 bytes from a string of length 1023 [-Werror=stringop-truncation]
95 |   return __builtin___strncpy_chk (__dest, __src, __len,
|          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
96 |                                   __glibc_objsize (__dest));
|                                   ~~~~~~~~~~~~~~~~~~~~~~~~~
I disagree a bit on the gcc sanity here, as the code was behaving
correctly and even already checked the string length. But sice
the string length is already verified, that length can be used
for the final strncpy.",True,{}
