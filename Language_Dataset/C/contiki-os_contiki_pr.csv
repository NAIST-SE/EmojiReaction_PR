contiki-os/contiki,https://github.com/contiki-os/contiki,1547,2016-03-09T10:38:26Z,2016-03-09T12:24:52Z,2016-03-09T13:15:35Z,MERGED,True,3,3,2,https://github.com/yatch,RPL: fix typos in debug messages,1,[],https://github.com/contiki-os/contiki/pull/1547,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1547,"Two fixes in debug messages:

Removal of a white space between ""RPL"" and "":"" in a couple of message headers in rpl-dag.c
Spelling correction in rpl-timers.c","Two fixes in debug messages:

Removal of a white space between ""RPL"" and "":"" in a couple of message headers in rpl-dag.c
Spelling correction in rpl-timers.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1547,2016-03-09T10:38:26Z,2016-03-09T12:24:52Z,2016-03-09T13:15:35Z,MERGED,True,3,3,2,https://github.com/yatch,RPL: fix typos in debug messages,1,[],https://github.com/contiki-os/contiki/pull/1547,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1547#issuecomment-194272555,"Two fixes in debug messages:

Removal of a white space between ""RPL"" and "":"" in a couple of message headers in rpl-dag.c
Spelling correction in rpl-timers.c",Thanks üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1548,2016-03-10T11:21:01Z,2016-03-11T13:14:26Z,2017-10-27T20:02:59Z,MERGED,True,16,16,2,https://github.com/simonduq,"uip6, icmp6 and ext header handling fixes: traceroute now working!",5,[],https://github.com/contiki-os/contiki/pull/1548,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1548,"This is a collection of fixes required to get traceroute to work.
There were several connected problems:

icmp error messages should return the original incoming packet, but they returned an altered version due to extension header handling and buffer length bugs
the last hop never returned a ""port unreachable"" message","This is a collection of fixes required to get traceroute to work.
There were several connected problems:

icmp error messages should return the original incoming packet, but they returned an altered version due to extension header handling and buffer length bugs
the last hop never returned a ""port unreachable"" message",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1548,2016-03-10T11:21:01Z,2016-03-11T13:14:26Z,2017-10-27T20:02:59Z,MERGED,True,16,16,2,https://github.com/simonduq,"uip6, icmp6 and ext header handling fixes: traceroute now working!",5,[],https://github.com/contiki-os/contiki/pull/1548,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1548#issuecomment-194986489,"This is a collection of fixes required to get traceroute to work.
There were several connected problems:

icmp error messages should return the original incoming packet, but they returned an altered version due to extension header handling and buffer length bugs
the last hop never returned a ""port unreachable"" message","I think this is a great fix - I have also wondered quite a bunch of times why trace route did not work!
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1548,2016-03-10T11:21:01Z,2016-03-11T13:14:26Z,2017-10-27T20:02:59Z,MERGED,True,16,16,2,https://github.com/simonduq,"uip6, icmp6 and ext header handling fixes: traceroute now working!",5,[],https://github.com/contiki-os/contiki/pull/1548,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1548#issuecomment-195069446,"This is a collection of fixes required to get traceroute to work.
There were several connected problems:

icmp error messages should return the original incoming packet, but they returned an altered version due to extension header handling and buffer length bugs
the last hop never returned a ""port unreachable"" message",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1548,2016-03-10T11:21:01Z,2016-03-11T13:14:26Z,2017-10-27T20:02:59Z,MERGED,True,16,16,2,https://github.com/simonduq,"uip6, icmp6 and ext header handling fixes: traceroute now working!",5,[],https://github.com/contiki-os/contiki/pull/1548,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/1548#issuecomment-195358499,"This is a collection of fixes required to get traceroute to work.
There were several connected problems:

icmp error messages should return the original incoming packet, but they returned an altered version due to extension header handling and buffer length bugs
the last hop never returned a ""port unreachable"" message",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,1,https://github.com/contiki-os/contiki/pull/1549,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1549#issuecomment-195090374,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I haven't even started looking at it, but the subject did catch my attention! High prio IMHO",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,3,https://github.com/contiki-os/contiki/pull/1549#issuecomment-195097049,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Fixed some minor errors causing the Travis build to fail on platforms other than the CC2650:

Forgot to include <stdbool.h> in radio-async.h
Misnamed one of the arguments in the doxygen comment for PT_YIELD_ON in pt.h",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/greg-king5,4,https://github.com/contiki-os/contiki/pull/1549#issuecomment-195264860,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","The commit message and the doxygen description of PT_YIELD_ON() are backwards.  That macro executes first, yields second.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,5,https://github.com/contiki-os/contiki/pull/1549#issuecomment-196896630,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I've been working on debugging the latest Travis failure on this branch.
I've found that the memory overflow on Sky builds can be avoided by wrapping the entire phase.c source file in a #if WITH_PHASE_OPTIMIZATION. This is the only source file which could have significantly different code generation on any platform other than the 2650 so this makes sense.
The other build failure is caused because the compiler for the 8051 can't seem to handle directly passing a structure to a function or maybe just not in this specific case for some reason.
Correct me if I'm wrong, but I believe that passing a struct to a function is not a violation of any C standard in which case this should be considered a compiler bug.
Given the circumstances, I believe that the best way to fix this would be to just prevent the 8051 compiler from seeing these function definitions at all (probably using a macro). I would certainly prefer this solution over amending all of the affected functions so that they don't take structs directly as arguments.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,6,https://github.com/contiki-os/contiki/pull/1549#issuecomment-196934154,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I've fixed all of the issues now.
Travis should be green when it completes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/kkrentz,7,https://github.com/contiki-os/contiki/pull/1549#issuecomment-212316499,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",Thanks for sharing this code. I am in the course of implementing an asynchronous radio driver for CC2538 SoCs.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,8,https://github.com/contiki-os/contiki/pull/1549#issuecomment-212448046,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",That's great to hear @kkrentz. Good luck to you.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,9,https://github.com/contiki-os/contiki/pull/1549#issuecomment-214800238,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Added a commit to increase the watchdog timeout. The watchdog will occasionally trigger if using asynchronous ContikiMAC while sending and receiving alot of packets at once. With a higher timeout this doesn't happen any-more.
Also rebased on the latest master and tested all of the changes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/kkrentz,10,https://github.com/contiki-os/contiki/pull/1549#issuecomment-218414784,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Unfortunately, this implementation turned out to be overly complex for my purposes. I just need some clean implementation of ContikiMAC for evaluating some security enhancements. So I actually now have an own implementation of ContikiMAC, too. Probably I can also make it open-source.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223129505,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I think this is a great contribution, generally speaking I thought this was a new MAC one could use alternatively i.e to ContikiMAC, but it seems it touches other modules as well.  Perhaps it would be easier to review and merge otherwise.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,12,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223133081,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Perhaps it would be easier to review and merge otherwise.

Sorry, not entirely clear on what you mean by that. Anything you need me to do here?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/alignan,13,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223136048,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Just thinking aloud, for me is difficult to review as it seems to modify cc2650 specifics, rather than being a separate MAC implementation, but I understand is a WIP and probably most of the proposed changes are required.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,14,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223302577,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",Newlines now added and I've rebased on latest master.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,15,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223318835,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I've now also updated the branch at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test to base on latest master and removed some of the temporary hacks I had added to the CC2650 lpm.c while waiting for #1531 to be merged.
In order to do this I also had to update #1290.
Also, just a reminder that this PR can't actually do anything without #1290.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/kkrentz,16,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223568150,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I have uploaded my reimplementation of ContikiMAC here. It also works asynchronously, but lacks support for bursts and phase-lock at the moment. On the other hand, it includes a mechanism for mitigating denial-of-sleep attacks. This is part of a paper we are going to present at ARES 2016.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,17,https://github.com/contiki-os/contiki/pull/1549#issuecomment-223586171,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","... it includes a mechanism for mitigating denial-of-sleep attacks.

Now that's very interesting. I'll certainly try to look at this when I can find some free time.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,18,https://github.com/contiki-os/contiki/pull/1549#issuecomment-226202981,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",Fixed unpaired bracket in PHASE_DRIFT() thanks to @niklas88 .,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,19,https://github.com/contiki-os/contiki/pull/1549#issuecomment-226283897,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I've completed a rebase of this branch onto the latest master. The branch at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test (includes all of the necessary PRs for this feature to function) has also been updated and seems to be working.
Considering the recent TSCH related additions to the cc26xx/cc13xx radio driver, this was very much a non-trivial operation. I've tested my changes and everything appears to be working but I'm not setup to test TSCH so I'd appreciate if someone who uses TSCH could do a quick check to see if anything is obviously broken.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/niklas88,20,https://github.com/contiki-os/contiki/pull/1549#issuecomment-226503256,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I have tested both your contiki_async_test branch from yesterday as well as the newly rebased one on the cc2650 SensorTag using a sensor collection application based on Rime's collect module (with phase opt, fast sleep and ContikiMAC headers, 2 Hz RDC). First let me say that I'm seeing a pretty big improvement in power used for listening when compared with mainline (from 150 ¬µW to 90 ¬µW average). I also saw huge improvements in phase optimization stability as stock drops so many packets that it's pretty much not useable. However it looks like there is a power consumption regression with the newest changes. I haven't done a git bisect yet because I just noticed it doing power meassurements again. I have attached two plots of the power over time when sending a sensor state every 5 seconds. The third plot is a zoom in of the high power consumption after sending part that isn't happening in yesterdays version. Note that in the second version the first sending seems less in phase but I don't think this is significant.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,21,https://github.com/contiki-os/contiki/pull/1549#issuecomment-226540596,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Thanks for the test data @niklas88!
I hadn't found the time to test power consumption on these recent changes yet so it's not entirely surprising that there is a problem here.
That period of high current after the TX looks to me like it may be the CPU turning on. I hope that this is the case since that's probably an easier problem than anything to-do with the radio.
So my best guess is that this is the CPU coming out of sleep constantly (perhaps due to a rogue rtimer or etimer) or if not that, then maybe the radio isn't properly shut-down after a TX (but then why would there be that gap between the second set of strobes and the subsequent power pulse train) . I also suspect that, in the case of the first set of strobes, the pulse train is actually intersecting with the stobes (and so maybe this has nothing to do with the TX at all).
Unfortunately, I think that this may be a difficult problem to fix and I haven't even tried to reproduce the issue yet. It could take some time before I have this solved.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,22,https://github.com/contiki-os/contiki/pull/1549#issuecomment-226582475,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I've spent a little bit of time now to try and reproduce your issue but I haven't seen any problems so far.
I haven't exactly reproduced your setup, however. I'm using a network with only two nodes (one BR and one remote node), IPv6, 8Hz channel check rate and using ICMP requests to force the remote node to transmit. I've tried both with phase optimization and without.  t'll take me some time to try and reproduce your network configuration more closely.
I've attached my test results for comparison purposes. As you can see, I'm not observing anything like what you've produced here.
Note:
I believe the final graph below is a broadcast transmission (thus explaining why it wasn't properly phase optimized).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/niklas88,23,https://github.com/contiki-os/contiki/pull/1549#issuecomment-226629686,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",Thinking about it a bit more and especially what you're saying about rogue timers I'm not entirely sure that there couldn't also be some code changes in my code triggering this. I did a bigger refactoring before the first test but there might have been some small change in-between. I will look into this some more either on Monday or Tuesday.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/niklas88,24,https://github.com/contiki-os/contiki/pull/1549#issuecomment-227078932,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I've looked into this again the behavior now seems to persists with the master branch so I think it's actually unrelated.
EDIT: After further investigation it looks like this happens with both your current branch and current master but not with master at commit 67e0575
I tried to bisect but several of the TSCH commits don't compile. Also this is my project-conf.h http://pastebin.com/nZNfEDWD",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/niklas88,25,https://github.com/contiki-os/contiki/pull/1549#issuecomment-232877086,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.",@bkozak-scanimetrics did you try combining this with the recent lpm fix? I Realize that hasn't been merged yet but I guess people are just away? I've seen really good results with this code and would love to see this getting merged.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,26,https://github.com/contiki-os/contiki/pull/1549#issuecomment-232963527,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","@bkozak-scanimetrics did you try combining this with the recent lpm fix? I Realize that hasn't been merged yet but I guess people are just away? I've seen really good results with this code and would love to see this getting merged.

I've been busy with other projects so I haven't had the time to try it.
I've just done a quick rebase. There was a single merge conflict but everything auto-resolved. I haven't tested it other than to compile check it but I think there's a pretty good chance that everything just works.
As usual, I've also updated https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test which includes all of the dependencies that haven't yet been merged into mainline.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,27,https://github.com/contiki-os/contiki/pull/1549#issuecomment-233346924,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","I hadn't realized that the lpm fix wasn't merged yet. I've just done another rebase now that the lpm changes are included. Quite a few merge conflicts this time but each one resolved automatically.
The lpm fix is now included in this branch and on https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I don't have enough time to test right at this moment but there's a reasonably good chance that nothing has broken.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/dak664,28,https://github.com/contiki-os/contiki/pull/1549#issuecomment-233921127,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Have you looked at
https://github.com/contiki-os/contiki/wiki/RDC-Phase-optimization? Look
at the number of retries as you reduce the guard time. With proper phase
correction that should drop to zero or one.
On 7/20/2016 4:04 AM, Niklas Schnelle wrote:

@bkozak-scanimetrics https://github.com/bkozak-scanimetrics ok I've
just run a very very limited test. It seems to work in principle but
with both PHASE_CONF_DRIFT_CORRECT and
CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION I'm seeing significant packet
loss.
I'll investigate further, but I wanted to check with you what your
recommended settings are at NETSTACK_CONF_RDC_CHANNEL_CHECK_RATE = 2
maybe I'm simply missing something. Also I'm seeing similar packet
loss on master when running with those settings but basically none
when running without PHASE_OPTIMIZATION
‚Äî
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub
#1549 (comment),
or mute the thread
https://github.com/notifications/unsubscribe-auth/AAkHYvvZMQn6mr-Nsb57lCp8ACPUptEWks5qXdaOgaJpZM4HuN_p.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/niklas88,29,https://github.com/contiki-os/contiki/pull/1549#issuecomment-233926935,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","@dak664 Thanks for the link I'll take a look. I have removed my earlier comment already because it now works with phase optimization and ContikiMAC Async, I had a typo in the project-conf.h so it was still using normal ContikiMAC which in the standard configuration isn't working well with phase optimization for me. I thought that was due to it not being tuned for the CC2650 which I think only uses PLL and doesn't have a crystal, I'm not sure though.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/bkozak-scanimetrics,30,https://github.com/contiki-os/contiki/pull/1549#issuecomment-234085116,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Perhaps I should mention now that, unlike with original ContikiMAC implementation, this driver doesn't limit the STROBE_TIME when it has a phase lock. This means that it shouldn't ever drop packets just because the phase optimization algorithm isn't working (instead it just ends up sending more strobes than it otherwise would).
I've fond that, in practice, the phase optimization algorithm is too imprecise and the clock drift between nodes is too quick for it to make sense to limit strobes. Once the phase lock has drifted too much there is a very severe penalty to correct the situation because of the way in which the CSMA algorithm interacts with the logic which detects loss of phase lock.
In my tests, with strobe time limited (to MAX_PHASE_STROBE_TIME as in the original driver) most CC2650 devices will start dropping packets after only 10 minutes of dead air because the clocks have already drifted too far apart.
Unfortunately, I think a much better phase lock algorithm is required before it will make sense to try limiting strobe time.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/niklas88,31,https://github.com/contiki-os/contiki/pull/1549#issuecomment-271532972,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Seeing as this PR has been inactive since July and that @bkozak-scanimetrics hasn't been active on GitHub in the last few months it looks like this PR needs to be assumed abandoned.
I'm using ContikiMAC in an internal project and have seen real improvements over mainline ContikiMAC especially concerning packet loss so I'm asking what the chance of merging this would be if I were to take over? I'm assuming the biggest hurdle would be CCxxxx specificity and a general lack of interest in ContikiMAC as of late?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/kkrentz,32,https://github.com/contiki-os/contiki/pull/1549#issuecomment-271580753,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Meanwhile, our reimplementation of ContikiMAC is also ready to use. The code is there , but only tested on OpenMotes so far. Like in this PR, our reimplementation of ContikiMAC runs asynchronously. In addition, we added security enhancements, some of which will be presented at EWSN 2017. If my existing PRs got merged, I could try to create a PR for this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1549,2016-03-10T22:46:21Z,,2017-01-11T10:38:03Z,OPEN,False,4530,601,22,https://github.com/bkozak-scanimetrics,Asyncronous / Interrupt Driven ContikiMAC,10,"['nominated', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1549,https://github.com/alignan,33,https://github.com/contiki-os/contiki/pull/1549#issuecomment-271835440,"This pull request adds support for a new version of ContikiMAC which can perform strobe sending and packet reception in the background using interrupts to drive the state transitions. The new driver also contains several other improvements which I will discuss below. The code currently only works on the CC2650 since it relies on the use of a new asynchronous radio driver; platform support can be added by implementing the asynchronous radio driver interface.
In order for this code to operate correctly, the pull-requests #1531 and #1290 must be merged first. For the sake of convenience I have created a branch which can be used as is at https://github.com/bkozak-scanimetrics/contiki/tree/contikimac_async_test
I apologize to the maintainers for making a pull request before this is ready to be merged but I want to start getting some eyeballs on this now since this is a fairly major change. If you think it is appropriate, I could merge all of these PRs into a single request.
To build a project with asynchronous ContikiMAC support, define the macros  NETSTACK_CONF_USE_RFASYNC and RTIMER_CONF_MULTIPLE_ACCESS to true.
I have been using the code for a couple months now and everything has been completely stable. I have not found any major issues.
Major improvements from using the asynchronous driver include:

Strobes can be sent in the background, this makes it much more feasible to operate ContikiMAC with a lower channel check rate since we don't have to block until all strobes are sent.
Lower transmit and receive power consumption through better management of the transceiver
ContikiMAC phase optimization now works well with more accurate traffic timing
Higher maximum TX throughput
Much better performance for burst packet traffic patterns.
Better handling of low level radio / driver errors; the new ContikiMAC driver will generally check all error codes and try to keep operating even in the face of errors.

This new driver does, however, use more memory than the original.
I believe that there is also lots of room for improvement on this code and this it would be an excellent jumping off point for further improvement of ContikiMAC phase optimization, advanced hardware features (such as DMA) etc.
Thank you all in advance for your feedback.","Thanks for bringing this up.  This PR was quite interesting, specially as ContikiMAC is Contiki's default option to NullRDC.  As the holidays are over it would be a good time to kickstart this once again.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,1,https://github.com/contiki-os/contiki/pull/1550,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195355737,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Cool! I will test this as well.
Can you please add the contiki-conf.h additions to the zoul platform as well?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195364744,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Looks excellent! A few warnings make Travis unhappy.
Please also update the TSCH readme file to add the new supported platform(s)!
Thanks :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195364843,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Looking forward to trying on Zoul (I have no cc2538dk),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195377814,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","This is a very desirable feature. Code style fixes required here and there, please uncrustify this. It would be nice to do some interop testing too! :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195408154,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Just wanted to say that I'm currently trying on Zoul.
Worked on the very first attempt!
Now going to take a closer look at timings and interop with jn516x.
Very well done guys!!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195414425,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Same here, working nicely.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195422002,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",I would also rebase please,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195439598,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Two additional things, sorry pile things up:
The examples/ipv6/rpl-tsch test needs to be fixed:
node.co: In function `process_thread_node_process':
node.c:(.text.process_thread_node_process+0x23c): undefined reference to `node_id'
collect2: error: ld returned 1 exit status

Also adding a regression test would be OK?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195439917,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Yes absolutely, node_id is there mostly to enable easy cooja simulations (used in Travis), I need to come up with a better way of identifying the root",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195441304,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","I can make a PR on top to add the zoul config, if I can help out with anything give me a task :-)  When I get back to the office I will try to have time measurements",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195443906,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","I got it to talk to jn516x!! One thing is that with a 32768 Hz timer, the timeslot duration does not divide a 10000usec slot. The slot duration is estimated to 328 ticks which actually is 10010 usec. Enough to disable interop with nodes running at true 10000usec. The sky platform has the same problem btw.
A hack is to force jn516x on 10010usec slots and this works.
But a nicer solution is to use @atiselsts' adaptive time compensation. Simply enable TSCH_CONF_ADAPTIVE_TIMESYNC and set this (copied from jn516x, used in the non-default case where a low-frequency oscillator is enabled):
/* Drift calculated using this formula:
*    ((US_TO_TICKS(10000) * 100) - RTIMER_SECOND) * 1e6 = 976.5625 ppm
*/
#define TSCH_CONF_BASE_DRIFT_PPM -977

This way, the node will compensate its own internal drift of -977 ppm and run true 10000usec slots (well, with a max error one tick, but no accumulating error).
As far as I can tell (assuming jn516x is a ground truth -- it was validated with a logic analyzer) the DELAY_BEFORE constants are not completely off. But real measurements are needed to find the exact numbers. Happy to help out on how to proceed.
One more note: by default, we use SFD timestamps for initial synchronization but afterwards, during TSCH operation, where we switch to rtimer timestamping of whenever NETSTACK_RADIO.pending() becomes true (more accurate on high-frequency rtimer). I tried enabling SFD timestamping even during slot operation, with TSCH_RESYNC_WITH_SFD_TIMESTAMPS. It failed, my guess being that SFD timestamping does not currently work from a rtimer interrupt on cc2538.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,13,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195492003,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","I have the feeling that there could be a problem with the SFD interrupt. We wanted to measure the time between the beginning of the transmit() function until the SFD interrupt was raised but it was raised at the end of the transmission of the complete frame.
Von meinem iPhone gesendet
Am 11.03.2016 um 17:41 schrieb ""Simon Duquennoy"" <notifications@github.commailto:notifications@github.com>:
One more note: by default, we use SFD timestamps for initial synchronization but afterwards, during TSCH operation, where we switch to rtimer timestamping of whenever NETSTACK_RADIO.pending() becomes true (more accurate on high-frequency rtimer). I tried enabling SFD timestamping even during slot operation, with TSCH_RESYNC_WITH_SFD_TIMESTAMPS. It failed, my guess being that SFD timestamping does not currently work from a rtimer interrupt on cc2538.
‚Äî
Reply to this email directly or view it on GitHubhttps://github.com//pull/1550#issuecomment-195443906.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,14,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195513500,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Yes and the problem occurs when receiving from an rtimer interrupt. Almost surely a matter of interrupt priority. At joining time, the reception is not done within an interrupt, that is why timestamping works.
Is there a way on cc2538 to capture SFD timestamp without an interrupt?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,15,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195524514,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Simon, Yes. You can timestamp with the MAC timer: see my inline comment above",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,16,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195545250,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","I missed your comment. That's perfect, exactly what I hoped for!
Le 11 mars 2016 21:02, ""George Oikonomou"" notifications@github.com a
√©crit :

Simon, Yes. You can timestamp with the MAC timer: see my inline comment
above
‚Äî
Reply to this email directly or view it on GitHub
#1550 (comment).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,17,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195685608,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Using the MAC Timer was planned as my next step. I didn't figure out how to synchronize it with rtimer that's why I went with the easier way.
Von meinem iPhone gesendet
Am 11.03.2016 um 21:49 schrieb ""Simon Duquennoy"" <notifications@github.commailto:notifications@github.com>:
I missed your comment. That's perfect, exactly what I hoped for!
Le 11 mars 2016 21:02, ""George Oikonomou"" <notifications@github.commailto:notifications@github.com> a
crit :

Simon, Yes. You can timestamp with the MAC timer: see my inline comment
above
Reply to this email directly or view it on GitHub
#1550 (comment).

Reply to this email directly or view it on GitHubhttps://github.com//pull/1550#issuecomment-195545250.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,18,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195685993,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","The rtimer interrupt can delay the SFD interrupt in the range of milliseconds?
Von meinem iPhone gesendet
Am 11.03.2016 um 20:33 schrieb ""Simon Duquennoy"" <notifications@github.commailto:notifications@github.com>:
Yes and the problem occurs when receiving from an rtimer interrupt. Almost surely a matter of interrupt priority. At joining time, the reception is not done within an interrupt, that is why timestamping works.
Is there a way on cc2538 to capture SFD timestamp without an interrupt?
Reply to this email directly or view it on GitHubhttps://github.com//pull/1550#issuecomment-195513500.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,19,https://github.com/contiki-os/contiki/pull/1550#issuecomment-195701748,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Absolutely: it will delay it by about one packet duration as TSCH
(currently) busy waits from rtimer interrupt until end of Rx. It will then
sleep and wakeup to TX an ACK if requested, then sleep until the next
scheduled slot.
The rtimer interrupt can delay the SFD interrupt in the range of
milliseconds?
Von meinem iPhone gesendet
Am 11.03.2016 um 20:33 schrieb ""Simon Duquennoy"" <notifications@github.com
mailto:notifications@github.com>:
Yes and the problem occurs when receiving from an rtimer interrupt. Almost
surely a matter of interrupt priority. At joining time, the reception is
not done within an interrupt, that is why timestamping works.
Is there a way on cc2538 to capture SFD timestamp without an interrupt?
ÔøΩ
Reply to this email directly or view it on GitHub<
https://github.com/contiki-os/contiki/pull/1550#issuecomment-195513500>.
Wichtiger Hinweis: Diese E-Mail kann Betriebs- oder GeschÔøΩftsgeheimnisse
oder sonstige vertrauliche Informationen enthalten. Sollten Sie diese
E-Mail irrtÔøΩmlich erhalten haben, ist Ihnen eine Kenntnisnahme des Inhalts,
eine VervielfÔøΩltigung oder Weitergabe der E-Mail ausdrÔøΩcklich untersagt.
Bitte benachrichtigen Sie uns und vernichten Sie die empfangene E-Mail.
Vielen Dank. Important Note: This e-mail may contain trade secrets or
privileged, undisclosed or otherwise confidential information. If you have
received this e-mail in error, you are hereby notified that any review,
copying or distribution of it is strictly prohibited. Please inform us
immediately and destroy the original transmittal. Thank you for your
cooperation.
‚Äî
Reply to this email directly or view it on GitHub
#1550 (comment).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,20,https://github.com/contiki-os/contiki/pull/1550#issuecomment-197964818,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","I measured RADIO_DELAY_BEFORE_TX and it is 353us. I don't know how to measure RADIO_DELAY_BEFORE_RX on CC2538 but the CC2538 Users Guide says 192us (page 672, 23.9.2 RX State Timing of the document).
If I use this values I get some ""TSCH:! drop dup"" messages (especially when I reduce RX_CONF_WAIT). That's not the case with the estimated values of 300 and 100us.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,21,https://github.com/contiki-os/contiki/pull/1550#issuecomment-197965710,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Does anyone know how to sync the MAC timer with the rtimer? We didn't manage to get the MAC timer working yet.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,22,https://github.com/contiki-os/contiki/pull/1550#issuecomment-198095471,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","The drop duplicate messages are very confusing..
A way to roughly validate RADIO_DELAY_BEFORE_TX (and RADIO_DELAY_BEFORE_DETECT if it needs to be non-zero) is to look for sync asymmetry, i.e. the node and its time source don't agree on time and perceive a different time error when they receive from one another. Look at the drift observed at the node on Rx (dr, in ticks) and on Unicast Tx, with ACK-based sync (also dr, in ticks). With incorrect timing you typically have the node jump by a few ticks (plus or minus) after a Unicast Tx and back on the next Rx.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,23,https://github.com/contiki-os/contiki/pull/1550#issuecomment-198343589,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Thank you, I haven‚Äôt seen any jumps of dr ticks.
I tested TSCH on CC2538 with a RADIO_DELAY_BEFORE_TX value of 300us and RADIO_DELAY_BEFORE_RX value of 100us extensive and it was very successful (with 17 nodes).
I also tested successfully with RX_CONF_WAIT as small as 500us (only with 2 nodes so far).
I tested the configuration with the RADIO_DELAY_BEFORE_TX with the measured 352us and the RADIO_DELAY_BEFORE_RX with the 192us from datasheet. I sometimes get drop dup messages at the receiver side and they come very infrequent and not always. They are caused because the sender sends the message repeatedly (although there are ACKs sent by the receiver, but I have also seen that there were no ACKs sent sometimes).
It seems like the configuration with 300us and 100us is working a lot better, there I haven‚Äôt seen any drop dups which is very strange I think ‚Ä¶ Could there be still some timing problem so that the sender doesn't receive the ACKs?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,24,https://github.com/contiki-os/contiki/pull/1550#issuecomment-198351442,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Yes, that sounds likely. To find out if ACKs are lost, in the TSCH logs, look for Unicast transmission:

uc-1 means Unicast-data (bc is broadcast, -0 is beacon)
tx
look at the status: e.g. ""st 0 1"" means OK (""0"": OK, ""2"": NOACK, see mac.h), ""1"" here is the tx attempt number, will increase when there are retransmissions",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/atiselsts,25,https://github.com/contiki-os/contiki/pull/1550#issuecomment-198378590,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","You can measure the error between the expected time and the actual time you start receiving ACK, it will give some indication to tune the RADIO_DELAY_BEFORE_RX parameter:
int32_t delta_ack = ack_start_time - (current_slot_start + tsch_timing[tsch_ts_tx_offset] + tx_duration + tsch_timing[tsch_ts_tx_ack_delay]);
TSCH_LOG_ADD(tsch_log_message,  snprintf(log->message, sizeof(log->message),  ""ack error: %d"", delta_ack));",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,26,https://github.com/contiki-os/contiki/pull/1550#issuecomment-200278534,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Update of the pull request: We are using the MAC timer instead of the SFD interrupt now.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,27,https://github.com/contiki-os/contiki/pull/1550#issuecomment-202776996,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Update of the pull request:
I updated RADIO_DELAY_BEFORE_TX to the measured value of 352 micro-seconds. RADIO_DELAY_BEFORE_RX should be 192 micro-seconds as in data sheet (page 672, 23.9.2 RX State Timing of the document: ""The receiver is ready 192 Œºs after RX is enabled [...]"") but then ACKs are not always received. I adjusted RADIO_DELAY_BEFORE_RX to 250 micro-seconds and it works fine (tested with up to 16 nodes and TSCH_CONF_RX_WAIT as small as 600us).
I couldn't figure out why it doesn't work as well with RADIO_DELAY_BEFORE_RX set to 192us.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,28,https://github.com/contiki-os/contiki/pull/1550#issuecomment-209881346,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Thomas, where are we on this one? This will be a great addition once completed, we will need to do some interop testing of course across platforms.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,29,https://github.com/contiki-os/contiki/pull/1550#issuecomment-209891382,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Hello,
The status of TSCH for CC2538:
I tested this port with up to 16 nodes with 6TiSCH minimal schedule and orchestra. This also includes long term testing for 3 days. UDP packets were sent from nodes to the root and from root to nodes with reply from the node. The loss ratio was about 0% to 0,2%.
I only tested with CC2538 nodes and no interoperability testing has been performed yet. @simonduq got it talking to JN516x he said.
What I struggled with was the RADIO_DELAY_BEFORE_TX and RADIO_DELAY_BEFORE_RX values. I measured 352us for RADIO_DELAY_BEFORE_TX and the CC2538 Users Guide says 192us for RADIO_DELAY_BEFORE_RX (page 672, 23.9.2 RX State Timing). I had to increase RADIO_DELAY_BEFORE_RX to 250us to not get ""drop duplicate"" messages by TSCH because of not received ACKs.
Recently I also discovered a problem using the rpl-border-router with TSCH. As soon as TSCH is started on the border-router by the NETSTACK_MAC.on() command the slip_input_callback() isn't called anymore on CC2538. I couldn't really figure out the reason for that yet ...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,30,https://github.com/contiki-os/contiki/pull/1550#issuecomment-209892524,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Recently I also discovered a problem using the rpl-border-router with TSCH. As soon as TSCH is started on the border-router by the NETSTACK_MAC.on() command the slip_input_callback() isn't called anymore on CC2538. I couldn't really figure out the reason for that yet ...

This could be a problem with LPM. Can you try disabling LPM2 on the border router?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,31,https://github.com/contiki-os/contiki/pull/1550#issuecomment-209893740,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Only LPM1 was active (#define LPM_CONF_MAX_PM       1),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,32,https://github.com/contiki-os/contiki/pull/1550#issuecomment-209897125,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","What device are you using as a BR? If it's a CC2538EM, can you try over native USB?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,33,https://github.com/contiki-os/contiki/pull/1550#issuecomment-210468563,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","I'm using a CC2538DK  (I used the SmartRF06EB, I wasn't able to connect the CC2538EM directly to my PC, it wasn't recognized) and our own CC2538 based hardware platform.
If I comment out the command to turn off the rf module in the off() function of the radio driver ( https://github.com/thomas-ha/contiki/blob/tsch-cc2538-port/cpu/cc2538/dev/cc2538-rf.c#L436 ) the slip input callback gets called. I have absolutely no idea what this has to do with the slip input callback but it really is like that. BUT then the slip input callback doesn't allways receive all of the bytes sent over SLIP, so it doesn't work reliable anyway. That's all pretty strange to me.
I have seen that the JN516x platform has implemented its own slip.c Maybe some of these changes are needed for CC2538 too?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,34,https://github.com/contiki-os/contiki/pull/1550#issuecomment-210473640,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","If the radio is off, the LPM module will drop to some low power mode. This will normally gate the clock to the UART and for that reason the callback won't get called (basically bytes won't get received, the UART RX interrupt won't get raised). I am not familiar with how TSCH behaves on BRs, but the logic with ContikiMAC is to keep the radio always on. As a side-effect of that, the chip will never drop to deep sleep and the UART stays active and clocked at all times.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,35,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211239668,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","OK then this might be the problem @g-oikonomou
In TSCH the BR behaves just like other nodes: it follows a schedule and sleeps both between active slots and within an active slot (between Rx/Tx etc).
One more thing: do we have DMA for UART input? If not we might also get drops, as TSCH spends significant time in interrupt.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,36,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211286967,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","If the radio is off, the LPM module will drop to some low power mode. This will normally gate the clock to the UART and for that reason the callback won't get called (basically bytes won't get received, the UART RX interrupt won't get raised). I am not familiar with how TSCH behaves on BRs, but the logic with ContikiMAC is to keep the radio always on. As a side-effect of that, the chip will never drop to deep sleep and the UART stays active and clocked at all times.

Ok, thank you very much @g-oikonomou , I didn't know that. I checked the CC2538 manual and have seen the registers for gating the UART clock. Disabling LPM completely also helps of course.
Then there is still the problem that @simonduq mentioned. Sometimes there are missing bytes in the packet received over the slip interface of the packet isn't received at all. I guess because the UART interrupt is raised too late because of TSCH busy waiting from an rtimer interrupt.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,37,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211293358,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Again: without DMA, UART is not going to work with TSCH. TSCH may spend up to a couple millis in interrupt (e.g. when busy waiting for a Tx to terminate).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,38,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211318553,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","It should be possible to allow PM0 but leave the UART clocked and operational.
A quick (but perhaps dirty) workaround would be to set UART RX interrupt at a higher priority. We have DMA support for the radio and for USB, so the fundamental code is there. The UART driver would need changes of course.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,39,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211397001,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","The border router works with the CC2538EM and slip over USB with DMA (instead of UART).
I will take a look at the UART and DMA.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,40,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211560824,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Just to clarify (or to simply state the obvious). When we enable native USB on the CC2538 (e.g. SLIP over USB), the USB PLL is always on. When the PLL is active, the USB driver prohibits LPM1 or lower. So in our context here, as soon as we enable USB, the Border-Router problem goes away.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,41,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211565841,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Except for the DMA part @g-oikonomou right?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,42,https://github.com/contiki-os/contiki/pull/1550#issuecomment-211567457,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","There is some DMA support in the USB driver, but it's not exactly what we'd be looking for in this context here. However, my gut feeling is that we won't miss bytes over USB purely down to speed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,43,https://github.com/contiki-os/contiki/pull/1550#issuecomment-222953388,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","@thomas-ha could you please update the TSCH readme file to mention the new supported platform?
https://github.com/contiki-os/contiki/blob/master/core/net/mac/tsch/README.md
Other than that this is ready to merge AFAIC",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,44,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223001809,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Yes, done! Thank you for the reminder!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,45,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223028550,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","@g-oikonomou you had some comments on enabling xtal on cc2538, can you say a little more so we can have it enabled by default at least in the tsch example?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,46,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223028660,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",@thomas-ha anything else you want to put in before we merge?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,47,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223033046,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","XTAL is already enabled for the TSCH example in the project-conf.h:
#undef SYS_CTRL_CONF_OSC32K_USE_XTAL
#define SYS_CTRL_CONF_OSC32K_USE_XTAL 1
No, I don't have anything to add,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,48,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223033359,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Ah ok. Good to merge then! Let's wait for Travis to be green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,49,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223033689,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","In the readme there is one missing mention of cc2538dk after ""he easiest is probably to start from one of the existing port""",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,50,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223066232,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Yes we were discussing on skype about how this needs the LF XTAL for the CC2538 or it would not work and we agreed that I'd comment about it, only to realise that you have already applied this change in the project-conf.h. Sorry if I confused!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/joakimeriksson,51,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223070237,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",Any list of platforms that are known to have the XTAL on the CC2538? Re-mote?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/g-oikonomou,52,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223071144,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Pretty certain CC2538DK has it. Will need to double-check, but almost 100%",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/joakimeriksson,53,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223075227,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",I know that I have a few devices without it and the 32768 Hz sleep timer is really not running 32768 but rather 32753 and usually up to 1% off that also. At cold-start it can be as much as 5% off.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,54,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223078723,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","That is annoying. TSCH typically expects clocks with 20-40 ppm. Playing with the guard time and sync interval one can try to handle perhaps a couple hundred ppms.
1% off is 10 000 ppm.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/joakimeriksson,55,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223097333,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",I guess for non deep-sleep devices that can keep the 32MHz (crystal) clock always ticking that could also be used instead of the 32KHz one.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,56,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223102092,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",If you have this available then yes it is an option!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,57,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223105873,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.",The zoul and all based boards like the RE-Mote and Firefly have a 32.768KHz Crystal with +/-20ppm,True,{'THUMBS_UP': ['https://github.com/joakimeriksson']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,58,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223220879,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Ok, I don't know why the Travis check has failed. All I did was changing the Readme",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/alignan,59,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223221133,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","It is unrelated, Travis is currently broken (fixing now!)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/simonduq,60,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223397908,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","merging now, thanks for the contribution!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1550,2016-03-11T11:08:15Z,2016-06-02T19:33:56Z,2016-07-16T16:28:04Z,MERGED,True,191,29,7,https://github.com/thomas-ha,Port of TSCH for CC2538,31,"['enhancement', 'nominated', 'Platform / CPU / ARM']",https://github.com/contiki-os/contiki/pull/1550,https://github.com/thomas-ha,61,https://github.com/contiki-os/contiki/pull/1550#issuecomment-223513134,"This pull request is a port of TSCH for the CC2538 cpu.
The cc2538-rf.c driver was extended with the poll mode. Incoming packets are timestamped with the MAC timer. In the off() function the FIFO is flushed only when there is no complete packet in it otherwise the FIFO is flushed before TSCH reads out the packet. The FIFO is flushed at the end of the read() function.
We tested it with 6TiSCH Minimal Schedule and Orchestra with two and up to 17 nodes.","Thank you for all your help @simonduq , very appreciated!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1553,2016-03-14T12:57:33Z,2016-03-14T14:40:14Z,2017-10-27T20:03:00Z,MERGED,True,15,12,6,https://github.com/simonduq,Fix a number of leftover mentions of aaaa as a prefix (now fd00),2,[],https://github.com/contiki-os/contiki/pull/1553,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1553,"A number of new ""aaaa"" slipped in between the original PR and its merge. This replaces them with the new local prefix ""fd00""","A number of new ""aaaa"" slipped in between the original PR and its merge. This replaces them with the new local prefix ""fd00""",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1553,2016-03-14T12:57:33Z,2016-03-14T14:40:14Z,2017-10-27T20:03:00Z,MERGED,True,15,12,6,https://github.com/simonduq,Fix a number of leftover mentions of aaaa as a prefix (now fd00),2,[],https://github.com/contiki-os/contiki/pull/1553,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1553#issuecomment-196341516,"A number of new ""aaaa"" slipped in between the original PR and its merge. This replaces them with the new local prefix ""fd00""",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1555,2016-03-15T09:02:43Z,2016-03-15T15:13:37Z,2017-10-27T20:03:05Z,MERGED,True,1,1,1,https://github.com/simonduq,Fix doxygen warning,1,[],https://github.com/contiki-os/contiki/pull/1555,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1555,"that one warning slipped in after merging #1387, which was last run in Travis in November. Not sure if this is the cleanest of fixes, simply suppresses the ref to uip_ds6_neighbor_periodic as the function is now compiled out by default.","that one warning slipped in after merging #1387, which was last run in Travis in November. Not sure if this is the cleanest of fixes, simply suppresses the ref to uip_ds6_neighbor_periodic as the function is now compiled out by default.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1557,2016-03-16T17:48:31Z,2016-03-17T09:00:35Z,2016-03-17T10:05:53Z,MERGED,True,2,0,1,https://github.com/remyleone,fix SerialSocketServer when run without GUI,1,[],https://github.com/contiki-os/contiki/pull/1557,https://github.com/remyleone,1,https://github.com/contiki-os/contiki/pull/1557,"I add a problem running Cooja serial socket server without a graphical interface. It created NullPointerException at the initial stage.
Exception in thread ""AWT-EventQueue-0"" java.lang.NullPointerException
    at org.contikios.cooja.serialsocket.SerialSocketServer$6.actionPerformed(SerialSocketServer.java:652)
    at javax.swing.Timer.fireActionPerformed(Timer.java:312)
    at javax.swing.Timer$DoPostEvent.run(Timer.java:244)
    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:312)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:745)
    at java.awt.EventQueue.access$300(EventQueue.java:103)
    at java.awt.EventQueue$3.run(EventQueue.java:706)
    at java.awt.EventQueue$3.run(EventQueue.java:704)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:77)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:715)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)","I add a problem running Cooja serial socket server without a graphical interface. It created NullPointerException at the initial stage.
Exception in thread ""AWT-EventQueue-0"" java.lang.NullPointerException
    at org.contikios.cooja.serialsocket.SerialSocketServer$6.actionPerformed(SerialSocketServer.java:652)
    at javax.swing.Timer.fireActionPerformed(Timer.java:312)
    at javax.swing.Timer$DoPostEvent.run(Timer.java:244)
    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:312)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:745)
    at java.awt.EventQueue.access$300(EventQueue.java:103)
    at java.awt.EventQueue$3.run(EventQueue.java:706)
    at java.awt.EventQueue$3.run(EventQueue.java:704)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:77)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:715)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1557,2016-03-16T17:48:31Z,2016-03-17T09:00:35Z,2016-03-17T10:05:53Z,MERGED,True,2,0,1,https://github.com/remyleone,fix SerialSocketServer when run without GUI,1,[],https://github.com/contiki-os/contiki/pull/1557,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1557#issuecomment-197531191,"I add a problem running Cooja serial socket server without a graphical interface. It created NullPointerException at the initial stage.
Exception in thread ""AWT-EventQueue-0"" java.lang.NullPointerException
    at org.contikios.cooja.serialsocket.SerialSocketServer$6.actionPerformed(SerialSocketServer.java:652)
    at javax.swing.Timer.fireActionPerformed(Timer.java:312)
    at javax.swing.Timer$DoPostEvent.run(Timer.java:244)
    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:312)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:745)
    at java.awt.EventQueue.access$300(EventQueue.java:103)
    at java.awt.EventQueue$3.run(EventQueue.java:706)
    at java.awt.EventQueue$3.run(EventQueue.java:704)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:77)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:715)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)","I hope you ""had"" a problem, not ""add"" ;)
Is the problem completely gone now with this PR or?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1557,2016-03-16T17:48:31Z,2016-03-17T09:00:35Z,2016-03-17T10:05:53Z,MERGED,True,2,0,1,https://github.com/remyleone,fix SerialSocketServer when run without GUI,1,[],https://github.com/contiki-os/contiki/pull/1557,https://github.com/fros4943,3,https://github.com/contiki-os/contiki/pull/1557#issuecomment-197772909,"I add a problem running Cooja serial socket server without a graphical interface. It created NullPointerException at the initial stage.
Exception in thread ""AWT-EventQueue-0"" java.lang.NullPointerException
    at org.contikios.cooja.serialsocket.SerialSocketServer$6.actionPerformed(SerialSocketServer.java:652)
    at javax.swing.Timer.fireActionPerformed(Timer.java:312)
    at javax.swing.Timer$DoPostEvent.run(Timer.java:244)
    at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:312)
    at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:745)
    at java.awt.EventQueue.access$300(EventQueue.java:103)
    at java.awt.EventQueue$3.run(EventQueue.java:706)
    at java.awt.EventQueue$3.run(EventQueue.java:704)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:77)
    at java.awt.EventQueue.dispatchEvent(EventQueue.java:715)
    at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
    at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
    at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
    at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
    at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)",üëç Nice catch!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/rafaeldelucena,1,https://github.com/contiki-os/contiki/pull/1565,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/rafaeldelucena,2,https://github.com/contiki-os/contiki/pull/1565#issuecomment-218207647,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","Hello again guys!
This project still under development, but I like to ask some questions:

What is required for a platform to be accepted? What is the support/maintenance availability is needed?
I have some examples for this platform: do I add the examples in this PR or I create another separate referencing this PR?
Additional information about the platform should be placed in a specific README or just a link to a wiki page with information is enough?
And what is necessary for the platform does not enter the lost list? If it's being maintained and supported it will be considered active?

Platform website (draft): www.attom.io
I appreciate the attention, thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/rafaeldelucena,3,https://github.com/contiki-os/contiki/pull/1565#issuecomment-219037036,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","1, 2 and 3 question are answered here: https://github.com/contiki-os/contiki/blob/master/CONTRIBUTING.md#new-platforms :))",True,{'LAUGH': ['https://github.com/rafaeldelucena']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1565#issuecomment-223813082,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","Sorry for the late response, about 4) there's no general rule, but in overall if a platform has not been updated for more than a year, and does not fit most examples, it would be candidate to vote on moving to the lost platforms.  We expect also platforms to be commercially available and/or used in research/academy, if neither is the case (i.e an experimental platform not continued or no interest shown by their maintainers to further continue) then surely it will make the list.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1565#issuecomment-223813361,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","There are many files without the license included, please add.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/1565#issuecomment-223813463,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","and/or used in research/academy

Those are usually not eligible:

The hardware must be commercially available and of interest to a wide audience. In other words, ports for bespoke hardware built for e.g. a specific project / a single customer / niche markets are more suitable for a Contiki fork.

https://github.com/contiki-os/contiki/wiki/Code-Contributions#new-platforms",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1565#issuecomment-223813590,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","I just restarted Travis failed job, let's wait üòÉ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1565#issuecomment-223813630,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","Yes, @g-oikonomou is right I forgot about that one, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1565,2016-03-23T21:45:33Z,2016-09-13T20:44:45Z,2016-09-13T20:44:45Z,CLOSED,False,2796,0,23,https://github.com/rafaeldelucena,[WIP] AttoM cc13xx platform,22,"['work-in-progress', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1565,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1565#issuecomment-244899520,"Hi guys!
This project is under development by me, @mariobaldini and @rafaelmendes. We are HW and SW engineers from Florian√≥polis, Brazil.
We are building an IoT infrastructure with open source tools, and the Contiki was the choice for the motes and the border router.
I would like to know more about the requirements to make AttoM an official Contiki platform.
Best regards,
Rafael","Hi @rafaeldelucena ,
Something missing here is a Readme file with all relevant info and also information on who will maintain the platform. You can start from this for example:
https://github.com/contiki-os/contiki/blob/master/platform/jn516x/README.md",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1570,2016-03-28T18:26:52Z,2016-03-28T19:10:44Z,2016-03-28T19:10:44Z,MERGED,True,1078,532,16,https://github.com/oliverschmidt,Several retrocomputing changes.,4,[],https://github.com/contiki-os/contiki/pull/1570,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/1570,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1574,2016-03-31T08:10:48Z,2016-03-31T11:36:40Z,2016-03-31T11:36:40Z,MERGED,True,1,0,1,https://github.com/warner83,Fixed a bug into tsch-schedule - tsch_schedule_add_link that causes d‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1574,https://github.com/warner83,1,https://github.com/contiki-os/contiki/pull/1574,‚Ä¶eadlock if a new link cannot be created,‚Ä¶eadlock if a new link cannot be created,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1574,2016-03-31T08:10:48Z,2016-03-31T11:36:40Z,2016-03-31T11:36:40Z,MERGED,True,1,0,1,https://github.com/warner83,Fixed a bug into tsch-schedule - tsch_schedule_add_link that causes d‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1574,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1574#issuecomment-203816267,‚Ä¶eadlock if a new link cannot be created,"Good catch, this was missing indeed. Quickly checked all other lock operations and it seems this was the only missing tsch_release_lock().
The indentation in your PR is wrong as we use spaces, no tab. Please fix, amend and push -f.
Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1574,2016-03-31T08:10:48Z,2016-03-31T11:36:40Z,2016-03-31T11:36:40Z,MERGED,True,1,0,1,https://github.com/warner83,Fixed a bug into tsch-schedule - tsch_schedule_add_link that causes d‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1574,https://github.com/warner83,3,https://github.com/contiki-os/contiki/pull/1574#issuecomment-203821093,‚Ä¶eadlock if a new link cannot be created,"@simonduq, thanks! Done!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1574,2016-03-31T08:10:48Z,2016-03-31T11:36:40Z,2016-03-31T11:36:40Z,MERGED,True,1,0,1,https://github.com/warner83,Fixed a bug into tsch-schedule - tsch_schedule_add_link that causes d‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1574,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1574#issuecomment-203821309,‚Ä¶eadlock if a new link cannot be created,"great, merging as soon as Travis is green! üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1575,2016-03-31T10:53:48Z,2016-06-06T09:39:45Z,2016-06-29T11:21:03Z,MERGED,True,374,4,2,https://github.com/atiselsts,Cooja: add Msp802154BitErrorRadio interface,1,"['Cooja', 'new feature']",https://github.com/contiki-os/contiki/pull/1575,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1575,"This Cooja interface more accurately models bit errors as observed in IEEE 802.15.4-compatible radios, such as CC2420 and CC2520.
Only errors due to signal fading are supported, as opposed to errors to interference. Interesting and quite realistic performance can be observed if this is used together with a dynamic channel fading model.
A usage example is available here. The example includes two .csc files, one using the existing Msp802154Radio and one the new Msp802154BitErrorRadio, but otherwise identical. The BitError example shows corrupted packets detected by the Contiki .c code and occasionally packets being completely lost (due to corruption in the header).
This pull request is based on work done in 2014 but not continued afterwards; maybe someone else finds this useful for their research.","This Cooja interface more accurately models bit errors as observed in IEEE 802.15.4-compatible radios, such as CC2420 and CC2520.
Only errors due to signal fading are supported, as opposed to errors to interference. Interesting and quite realistic performance can be observed if this is used together with a dynamic channel fading model.
A usage example is available here. The example includes two .csc files, one using the existing Msp802154Radio and one the new Msp802154BitErrorRadio, but otherwise identical. The BitError example shows corrupted packets detected by the Contiki .c code and occasionally packets being completely lost (due to corruption in the header).
This pull request is based on work done in 2014 but not continued afterwards; maybe someone else finds this useful for their research.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1575,2016-03-31T10:53:48Z,2016-06-06T09:39:45Z,2016-06-29T11:21:03Z,MERGED,True,374,4,2,https://github.com/atiselsts,Cooja: add Msp802154BitErrorRadio interface,1,"['Cooja', 'new feature']",https://github.com/contiki-os/contiki/pull/1575,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1575#issuecomment-223406481,"This Cooja interface more accurately models bit errors as observed in IEEE 802.15.4-compatible radios, such as CC2420 and CC2520.
Only errors due to signal fading are supported, as opposed to errors to interference. Interesting and quite realistic performance can be observed if this is used together with a dynamic channel fading model.
A usage example is available here. The example includes two .csc files, one using the existing Msp802154Radio and one the new Msp802154BitErrorRadio, but otherwise identical. The BitError example shows corrupted packets detected by the Contiki .c code and occasionally packets being completely lost (due to corruption in the header).
This pull request is based on work done in 2014 but not continued afterwards; maybe someone else finds this useful for their research.","Seems like a good contribution and adds a new feature rather than modifying existing ones, is a nice to have.
It would be great to have this double-checked by someone more involved in Cooja.
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1575,2016-03-31T10:53:48Z,2016-06-06T09:39:45Z,2016-06-29T11:21:03Z,MERGED,True,374,4,2,https://github.com/atiselsts,Cooja: add Msp802154BitErrorRadio interface,1,"['Cooja', 'new feature']",https://github.com/contiki-os/contiki/pull/1575,https://github.com/fros4943,3,https://github.com/contiki-os/contiki/pull/1575#issuecomment-223912487,"This Cooja interface more accurately models bit errors as observed in IEEE 802.15.4-compatible radios, such as CC2420 and CC2520.
Only errors due to signal fading are supported, as opposed to errors to interference. Interesting and quite realistic performance can be observed if this is used together with a dynamic channel fading model.
A usage example is available here. The example includes two .csc files, one using the existing Msp802154Radio and one the new Msp802154BitErrorRadio, but otherwise identical. The BitError example shows corrupted packets detected by the Contiki .c code and occasionally packets being completely lost (due to corruption in the header).
This pull request is based on work done in 2014 but not continued afterwards; maybe someone else finds this useful for their research.","Looks great! Could be extremely useful for radio-near simulations.
To make this new bit error radio more easily available in simulation, the class name may be added to mote types' getAllMoteInterfaceClasses() method.
üëç Merging",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1576,2016-03-31T12:15:39Z,2016-04-01T06:59:36Z,2016-04-01T06:59:36Z,MERGED,True,1,1,1,https://github.com/mguc,JN516x clock module sign error fix,1,[],https://github.com/contiki-os/contiki/pull/1576,https://github.com/mguc,1,https://github.com/contiki-os/contiki/pull/1576,This small fix has a huge impact on the etimer events. The current check is wrong for sure since clock_time_t is unsigned. For further details check my comment on #1265.,This small fix has a huge impact on the etimer events. The current check is wrong for sure since clock_time_t is unsigned. For further details check my comment on #1265.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1576,2016-03-31T12:15:39Z,2016-04-01T06:59:36Z,2016-04-01T06:59:36Z,MERGED,True,1,1,1,https://github.com/mguc,JN516x clock module sign error fix,1,[],https://github.com/contiki-os/contiki/pull/1576,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1576#issuecomment-204276228,This small fix has a huge impact on the etimer events. The current check is wrong for sure since clock_time_t is unsigned. For further details check my comment on #1265.,"Thanks, I also noticed some problems since the switch to tickless, very possibly caused by this bug üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,1,https://github.com/contiki-os/contiki/pull/1579,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1579#issuecomment-204529207,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","That's a nice addition, but how much more work would it be to do this as per the IEEE 802.15.4 standard? (figure 11 of IEEE 802.15.4-2011, non-slotted case)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,3,https://github.com/contiki-os/contiki/pull/1579#issuecomment-204556728,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I haven't had the time to read through the standard but from looking at Figure 11 and reading your comment on #1142 it doesn't sound like this would require any major difficulty.
The major changes that would need to be made are (I think):

Zero backoff_exponent and n->collisions on a NOACK failure
Increment n->transmissions for every macMaxCSMABackoffs consecutive collisions
Only consider n->transmissions when deciding when to abort the transmit attempt

Does this sound right to you?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1579#issuecomment-204571420,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Sounds right to me, except one thing missing: backoff_exponent should be the number of collisions, not the number of transmissions. The exponent increases at every collision until a Tx happens, and is reset before the next attempt (re-enters the state machine in fig 11 at every attempt, max macMaxCSMABackoffs times).
To really match the standard, default_timebase should not default to CLOCK_SECOND / NETSTACK_RDC_CHANNEL_CHECK_RATE but rather aUnitBackoffPeriod (20 symbol times, i.e. 320 usec)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,5,https://github.com/contiki-os/contiki/pull/1579#issuecomment-204597414,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","The current default_timebase does seem to me to be too high to me but If it is too small we could end up with too much wasted energy on CCA checks since the ContikiMAC strobing and CCA mechanism implies a lower probability that the packet is finished sending until a significant portion of a channel check period has passed. If the energy cost is too high we still have to make sure that the exponent truncates at a much larger value than 3 so as to give a reasonable chance that we don't fail out before the packet (or burst of packets) passes.
I think the default_timebase probably needs to be higher than 320 usec for ContikiMAC unless perhaps it is in the non-duty-cycled mode since the CCA doesn't use much extra energy for a radio which is already on.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,6,https://github.com/contiki-os/contiki/pull/1579#issuecomment-204597567,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Otherwise, it makes sense to me to try and match closer to the standard.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1579#issuecomment-204654814,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Absolutely, I only meant the default value of default_timebase, which is for RDCs that do not set a channel_check_interval, i.e. nullrdc. Will keep the current timebase for ContikiMAC.
There should also be no truncation of the backoff anymore, as the standard keeps incrmeenting until macMaxCSMABackoffs, then transmits and resets the backoff.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,8,https://github.com/contiki-os/contiki/pull/1579#issuecomment-205521070,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I've attempted to make the csma code match the 802.15.4 standard more closely. By doing this, we will no longer able to track the total number of collisions and the value of n->transmissions (which is passed up the the higher layers of the stack) takes on a different meaning.
I haven't changed any of the default values for controlling the backoff and make the backoff reset after 3 consecutive collisions (otherwise we would end up with a higher max exponent value than we have now).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,9,https://github.com/contiki-os/contiki/pull/1579#issuecomment-205522831,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",Also added @simonduq's suggestion of setting the default timebase to ~320us if the value of channel_check_interval() is zero. Since 320us is lower than what we can represent on most (all?) platforms this will usually default to 1 clock tick instead.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1579#issuecomment-205686116,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Nice! Thanks :) I will take a very close look and try this asap.
Don't we have most platforms running rtimer at 32768 Hz, i.e. 30.51 usec tick? Note you could use US_TO_RTIMERTICKS when available for usec <-> ticks conversion with rounding to nearest.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,11,https://github.com/contiki-os/contiki/pull/1579#issuecomment-205845710,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Regarding the Travis failure, it looks like the failure was caused because Travis was unable to download some software package when the test started. I don't believe that it is has anything to do with the actual code.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,12,https://github.com/contiki-os/contiki/pull/1579#issuecomment-205852328,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Don't we have most platforms running rtimer at 32768 Hz, i.e. 30.51 usec tick? Note you could use US_TO_RTIMERTICKS when available for usec <-> ticks conversion with rounding to nearest.

Right, I hadn't though of using that approach...
So, just to make sure I have this right, you just want to do the exponent calculation using higher resolution variables then convert to clock ticks so that they can be used by ctimer? Obviously, using the rtimer to directly schedule retransmit events would be better but we can't do that quite yet.
I've made a graph of what would happen if we tried to perform the calculation with rtimer resolution then truncate to clock ticks.  Unfortunately, I don't think that it works very well.

The only real solution that I see is to have a higher resolution on the clock ticks (which is something else that I'm working on and, in fact, better timer resolution on the csma modules was one of my motivations for doing this).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,13,https://github.com/contiki-os/contiki/pull/1579#issuecomment-205853996,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","sorry, my mistake, I forgot the macro was for rtimer but we need ctimer indeed! CLOCK_SECOND / 3125 is probably good enough then",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,14,https://github.com/contiki-os/contiki/pull/1579#issuecomment-211978596,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",What is the status on this?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,15,https://github.com/contiki-os/contiki/pull/1579#issuecomment-211994101,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I don't have any changes planned.
When I get the chance I'll do a rebase to fix Travis but otherwise I don't intend to change anything unless someone has another suggestion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,16,https://github.com/contiki-os/contiki/pull/1579#issuecomment-212000449,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",OK let's see if Travis is happy now :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,17,https://github.com/contiki-os/contiki/pull/1579#issuecomment-212000551,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",I'll take a close look and test this at some point,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,18,https://github.com/contiki-os/contiki/pull/1579#issuecomment-212052024,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","The Travis failure is completely different than the last time.
A quick perusal of the Travis build history for Contiki OS shows I'm not the only one getting a timeout error on the RPL build. The exact output from Travis isn't the same for the failure of this PR as it is in some of the others however.
If we consider also that this exact same test did not fail before the rebase, I think it is reasonable to guess that the problem may not be with this particular PR.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/alignan,19,https://github.com/contiki-os/contiki/pull/1579#issuecomment-212054955,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I just restarted that particular job, let's wait and see",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,20,https://github.com/contiki-os/contiki/pull/1579#issuecomment-212110841,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I've tried this a few times now on my own Travis account and It certainly seems like restarting the build isn't going to help.
I'll take a look into this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,21,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213085055,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","After much experimentation I have found that, in the large rpl network test, packets will almost inevitably get lost if we do either of the following:

Reset the exponentiation after a NOACK or on some number of consecutive collisions
Increment the transmission count after some number of consecutive collisions (thus allowing us to terminate the transmit attempt after a collision).

Essentially, the very flaws that this PR attempts to fix are actually necessary to make the large network test pass.
In my research into this problem, I had found that, at times, we will see a suspicious number of consecutive collisions (up to 24 in some cases) and I suspect that this may be a bug. Otherwise, my only suggestion to fix this problem is to raise the value of the various constants used in the CSMA algorithm when using Cooja and nullrdc (which the large RPL test uses).
As I was studying this code, however, I did also find one minor issue which I will fix soon. In the function collision I will replace
if(n->collisions >= CSMA_MAX_BACKOFF_EXPONENT)
with
if(n->collisions > CSMA_MAX_BACKOFF_EXPONENT)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,22,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213089671,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","In my research into this problem, I had found that, at times, we will see a suspicious number of consecutive collisions (up to 24 in some cases) and I suspect that this may be a bug

To be clear, I suspect that this may be a bug in Cooja.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,23,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213606192,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I did take a look in depth and proposed some improvements. I wanted to PR against your branch @bkozak-scanimetrics but for a reason I don't understand Github doesn't allow me to target your repo with my PR... Please take a look at this, cherry pick if you like it and add your modifs on top!
https://github.com/simonduq/contiki/commits/pr/fix_csma_backoff",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/g-oikonomou,24,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213607917,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I wanted to PR against your branch @bkozak-scanimetrics but for a reason I don't understand Github doesn't allow me to target your repo with my PR.

Did you try starring the target repo?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,25,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213610275,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Thanks @g-oikonomou, it worked :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,26,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213618118,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I did take a look in depth and proposed some improvements.

This all seems reasonable to me. The new random interval for the backoff time is a really big change however; it probably deserves some testing beyond just Travis.
Speaking of Travis, it seems that your PR also fails on 04-rpl-large-network. I still haven't come up with any good solution for this but I'm starting to understand the problem better.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,27,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213621233,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Note the randomness in the backoff was already there https://github.com/contiki-os/contiki/blob/master/core/net/mac/csma.c#L286
The exact parameters/numbers changed a bit though.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,28,https://github.com/contiki-os/contiki/pull/1579#issuecomment-213621315,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","The Travis problem is unrelated to this PR yes, it strikes every now and then, something needs to be done",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,29,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214418725,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I've re-based on your recent fixes for RPL.
As you can see, we are now failing on a completely different test (large RPL). On my own Travis account, the large RPL test passed but the ipv6 test failed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,30,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214420929,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Large RPL is actually dependent on external networks and may fail now and then -- I just restarted the job.
As for ipv6 fragmentation tests, I've also noticed failure lately, but these are more annoying as rerunning normally doesn't help...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,31,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214421247,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",Are you considering this as well? bkozak-scanimetrics#2,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,32,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214423801,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","Are you considering this as well? bkozak-scanimetrics#2

Yes, testing  here. It's having the same issues with IPv6 and Large RPL. I've just restarted both of those tests and we'll see if it passes soon.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,33,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214424615,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I'm now also seeing a failure of the ""slip-radio"" test once I include your changes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/bkozak-scanimetrics,34,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214444318,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","After enough restarts of all the failing builds Travis does eventually pass.
I've add your commit to this branch now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/simonduq,35,https://github.com/contiki-os/contiki/pull/1579#issuecomment-214473320,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",Great! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/alignan,36,https://github.com/contiki-os/contiki/pull/1579#issuecomment-215241203,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",@g-oikonomou are you OK to merge and close #1142?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/g-oikonomou,37,https://github.com/contiki-os/contiki/pull/1579#issuecomment-215256109,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.","I've not followed this one very closely, but if folks think it fixes the problem then who am I to argue? :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1579,2016-04-01T16:50:31Z,2016-04-28T08:24:56Z,2016-04-28T14:14:49Z,MERGED,True,166,161,10,https://github.com/bkozak-scanimetrics,Use collisions for csma backoff and retry,2,[],https://github.com/contiki-os/contiki/pull/1579,https://github.com/alignan,38,https://github.com/contiki-os/contiki/pull/1579#issuecomment-215350219,"This PR fixes #1142
The choice of default value for CSMA_MAX_MAX_COLLISIONS is working for me but is otherwise arbitrary. Please speak up if you know a better value for this constant.
I have some other concerns about the effectiveness of the exponential back-off constants now that collisions are accounted for (and see also my issue at #1571) but I think that this should be good enough for now.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1583,2016-04-05T19:14:56Z,2016-04-05T19:41:52Z,2016-04-05T19:41:52Z,MERGED,True,55,34,1,https://github.com/oliverschmidt,Added compatibility with W5100 shared access.,1,[],https://github.com/contiki-os/contiki/pull/1583,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/1583,"If the setup of socket 0 to 3 with 4+2+1+1KB is detected then the W5100 is not initialized, otherwise it does set up socket 0 and 1 with 4KB each. Either way socket 0 is used - now with 4KB instead of 8KB as before.","If the setup of socket 0 to 3 with 4+2+1+1KB is detected then the W5100 is not initialized, otherwise it does set up socket 0 and 1 with 4KB each. Either way socket 0 is used - now with 4KB instead of 8KB as before.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1585,2016-04-06T12:47:18Z,2016-04-06T12:48:44Z,2016-04-06T12:48:44Z,CLOSED,False,4351,10,22,https://github.com/vhkrishna,Ubimote,3,[],https://github.com/contiki-os/contiki/pull/1585,https://github.com/vhkrishna,1,https://github.com/contiki-os/contiki/pull/1585,Well done,Well done,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1587,2016-04-06T17:04:31Z,2016-04-06T22:53:43Z,2016-04-14T10:45:37Z,MERGED,True,6,6,1,https://github.com/g-oikonomou,Fix failure of ARM-AAPCS travis job,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/1587,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1587,"Up till now we have been installing arm-gcc using apt from the team-gcc-arm-embedded ppa.
As discussed in #1453 and implemented in #1504, we have decided to lock travis to use the specific version of the toolchain that is documented in the READMEs of relevant platforms. However, the PPA no longer hosts this version, apt fails to install arm-gcc and as a result the job fails too.
This pull changes the travis job to wget an installation tarball for the desired version, instead of trying to install via apt.
Fixes #1586","Up till now we have been installing arm-gcc using apt from the team-gcc-arm-embedded ppa.
As discussed in #1453 and implemented in #1504, we have decided to lock travis to use the specific version of the toolchain that is documented in the READMEs of relevant platforms. However, the PPA no longer hosts this version, apt fails to install arm-gcc and as a result the job fails too.
This pull changes the travis job to wget an installation tarball for the desired version, instead of trying to install via apt.
Fixes #1586",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1587,2016-04-06T17:04:31Z,2016-04-06T22:53:43Z,2016-04-14T10:45:37Z,MERGED,True,6,6,1,https://github.com/g-oikonomou,Fix failure of ARM-AAPCS travis job,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/1587,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1587#issuecomment-206575190,"Up till now we have been installing arm-gcc using apt from the team-gcc-arm-embedded ppa.
As discussed in #1453 and implemented in #1504, we have decided to lock travis to use the specific version of the toolchain that is documented in the READMEs of relevant platforms. However, the PPA no longer hosts this version, apt fails to install arm-gcc and as a result the job fails too.
This pull changes the travis job to wget an installation tarball for the desired version, instead of trying to install via apt.
Fixes #1586",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1587,2016-04-06T17:04:31Z,2016-04-06T22:53:43Z,2016-04-14T10:45:37Z,MERGED,True,6,6,1,https://github.com/g-oikonomou,Fix failure of ARM-AAPCS travis job,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/1587,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1587#issuecomment-206596218,"Up till now we have been installing arm-gcc using apt from the team-gcc-arm-embedded ppa.
As discussed in #1453 and implemented in #1504, we have decided to lock travis to use the specific version of the toolchain that is documented in the READMEs of relevant platforms. However, the PPA no longer hosts this version, apt fails to install arm-gcc and as a result the job fails too.
This pull changes the travis job to wget an installation tarball for the desired version, instead of trying to install via apt.
Fixes #1586",Pushed the removal of the tarball and stuff in /tmp as request.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1587,2016-04-06T17:04:31Z,2016-04-06T22:53:43Z,2016-04-14T10:45:37Z,MERGED,True,6,6,1,https://github.com/g-oikonomou,Fix failure of ARM-AAPCS travis job,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/1587,https://github.com/bthebaudeau,4,https://github.com/contiki-os/contiki/pull/1587#issuecomment-206604134,"Up till now we have been installing arm-gcc using apt from the team-gcc-arm-embedded ppa.
As discussed in #1453 and implemented in #1504, we have decided to lock travis to use the specific version of the toolchain that is documented in the READMEs of relevant platforms. However, the PPA no longer hosts this version, apt fails to install arm-gcc and as a result the job fails too.
This pull changes the travis job to wget an installation tarball for the desired version, instead of trying to install via apt.
Fixes #1586",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/ibriano,1,https://github.com/contiki-os/contiki/pull/1589,"If the given local port is 0, we get no replies.","If the given local port is 0, we get no replies.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1589#issuecomment-223772435,"If the given local port is 0, we get no replies.",Could you please explain in a bit more details the intent of this PR?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/ibriano,3,https://github.com/contiki-os/contiki/pull/1589#issuecomment-223958013,"If the given local port is 0, we get no replies.","The idea is that if I want to create a simple-udp connection to act as a client, I don't care about the local port, so I'm passing 0 for it and let it assign a random one. The problem with that is that simple-udp always calls bind with the local port passed, and if that is 0, it ends up with a handler that looks unused.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/vsaw,4,https://github.com/contiki-os/contiki/pull/1589#issuecomment-223982510,"If the given local port is 0, we get no replies.",Please update the documentation in the header file as well.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1589#issuecomment-224208885,"If the given local port is 0, we get no replies.",OK great. Yes please update the doxygen in simple-udp.h!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1589#issuecomment-225977355,"If the given local port is 0, we get no replies.","setting a timeout, will close in a month if nothing happens, merge if the doc is updated accordingly",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/ibriano,7,https://github.com/contiki-os/contiki/pull/1589#issuecomment-225979305,"If the given local port is 0, we get no replies.","Oops, sorry, got sidetracked and forgot to do this. I'll get to it now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/ibriano,8,https://github.com/contiki-os/contiki/pull/1589#issuecomment-225982393,"If the given local port is 0, we get no replies.",And I went to do it and the documentation already says that's the case. I guess I can just reword the commit message to state that?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1589#issuecomment-225983484,"If the given local port is 0, we get no replies.","That is true! I'm fine with merging as is, thanks üëç
(let's wait for another üëç or one month deadline)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1589,2016-04-07T13:41:53Z,2016-06-14T19:30:34Z,2016-06-14T19:30:34Z,MERGED,True,1,1,1,https://github.com/ibriano,Allow creating connections on unspecified local port,1,['timed out'],https://github.com/contiki-os/contiki/pull/1589,https://github.com/alignan,10,https://github.com/contiki-os/contiki/pull/1589#issuecomment-225990554,"If the given local port is 0, we get no replies.",Here you go üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/peretuset,1,https://github.com/contiki-os/contiki/pull/1590,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1590#issuecomment-208297568,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Thanks the lot for bringing this back to life!!
Minor things that need to be addressed:

fix doxygen warnings (the reason why Travis failed)
comply with https://github.com/contiki-os/contiki/wiki/Code-Contributions#new-platforms , in particular

add content to the readme
name at least one long-term maintainer",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1590#issuecomment-208299921,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Oh I forgot one:

add compile non-regression tests (very easy, just add a few lines to https://github.com/contiki-os/contiki/blob/master/regression-tests/18-compile-arm-ports/Makefile)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/peretuset,4,https://github.com/contiki-os/contiki/pull/1590#issuecomment-208892483,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","After a long night banging my head against the wall with Doxygen syntax and some other minor issues, it looks like it is now passing all the CI tests! I have also added the non-regression tests and added content to the readme file. Any further suggestions are welcome!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1590#issuecomment-208935866,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Looks great, fulfills the new platform requirements, and I know this has already been used by many. Gets my üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209285997,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","It would be better and try to comply with Contiki's sensor API (configure, value), even if it needs a bit of rework (in my opinion), then have extended functions for features that do not fit the API.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209349227,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Good to see activity here again.

There are a number of code style inconsistencies in various files, please run this through uncrustify.
The doxygen documentation is terribly broken. There are 3 \defgroup openmote-cc2538. There should be only one and it should be added to group platform. I can see many \addtogroup openmote, but I cannot see the respective defgroup anywhere. The outcome is that the platforms documentation modules are scattered all across the html docs. This should be tidied up.
As Antonio says, unless there is a specific reason to force speed 115200 on the BSL, allowing the default of 1000000 is recommended for faster programming.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,8,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209362396,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Furthermore, the convention for include guards is THIS_H_, so some of those need changed in this pull (don't forget the closing comment). We renamed across the board those that started with __ a while ago and we should try to not introduce new ones.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/peretuset,9,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209667641,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!",Just got through all of your comments and the checks are still passing. Can you double check that the issues are resolved now? Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,10,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209677660,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Pere, thanks. Other than the typo that I flagged inline, all my comments have been addressed and I'd be more than happy to merge this one (at long last!) üëç",True,{'HOORAY': ['https://github.com/peretuset']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,11,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209684543,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/alignan,12,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209859743,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","I just have a comment about making the sensors compatible with current Contiki sensors implementation, but no strong objection about it (it can be done in a new PR, although this normally doesn't happen)... @g-oikonomou mind-tricked me to port all of our sensors a while ago, so perhaps he can comment üò∏",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,13,https://github.com/contiki-os/contiki/pull/1590#issuecomment-209878359,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Even though the sensors API is a little PITA, I always choose to use it and encourage others to do so. When I read the comments I somehow thought this has been done already. Would be nice, but I'm not hugely bothered - support for this platform is long overdue",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/kkrentz,14,https://github.com/contiki-os/contiki/pull/1590#issuecomment-210383427,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","üëç Works, except for some issue with the 6LoWPAN adaption layer. A small change did the trick: kkrentz@eec004d",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/alignan,15,https://github.com/contiki-os/contiki/pull/1590#issuecomment-210385183,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","@kkrentz in any case, it should be:
/* Define our IPv6 prefixes/contexts here */
#define SICSLOWPAN_CONF_MAX_ADDR_CONTEXTS    1
#ifndef SICSLOWPAN_CONF_ADDR_CONTEXT_0
#define SICSLOWPAN_CONF_ADDR_CONTEXT_0 { \
  addr_contexts[0].prefix[0] = UIP_DS6_DEFAULT_PREFIX_0; \
  addr_contexts[0].prefix[1] = UIP_DS6_DEFAULT_PREFIX_1; \
}
#endif

Am I wrong? or is there any other related problem for other platforms as well?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/kkrentz,16,https://github.com/contiki-os/contiki/pull/1590#issuecomment-210393469,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!",This also works - so apparently the problem I experienced was a wrong mapping between context identifier and network prefix,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,17,https://github.com/contiki-os/contiki/pull/1590#issuecomment-211330137,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","@peretuset This pull needs updated to reflect recent changes to 6LoWPAN contexts, as per the discussion above. The preferred approach is the one Antonio mentions, also see #1297
Also, I need some comment on whether you have any plans of updating sensor drivers to use the standard API.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/peretuset,18,https://github.com/contiki-os/contiki/pull/1590#issuecomment-211412157,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!",Done!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/g-oikonomou,19,https://github.com/contiki-os/contiki/pull/1590#issuecomment-211562596,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","I'm merging this. It is still advisable to update sensor drivers to use the Contiki sensors API. But then again, this hardware and respective support have been around for too long already!",True,{'HOORAY': ['https://github.com/zopieux']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1590,2016-04-11T10:39:59Z,2016-04-18T20:26:15Z,2016-04-19T14:00:23Z,MERGED,True,3193,0,26,https://github.com/peretuset,Add OpenMote-CC2538 platform and examples.,2,['new feature'],https://github.com/contiki-os/contiki/pull/1590,https://github.com/peretuset,20,https://github.com/contiki-os/contiki/pull/1590#issuecomment-211933703,"After a long time, the OpenMote-CC2538 platform is finally ready to be merged into the Contiki's main repository. I have tested all the platform-related code and also the examples and they all work allright.
Please review the PR and make suggestions to improve it if required. Thanks!","Super, thanks!
By the way, I have finished moving the sensors drivers to use the Contiki sensors API, so you can expect a new PR soon enough... :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1597,2016-04-13T16:54:52Z,2016-06-03T12:16:15Z,2016-06-03T12:16:15Z,MERGED,True,5,5,1,https://github.com/rgrr,Removed some unnecessary statics in do_event() and process_post().,1,[],https://github.com/contiki-os/contiki/pull/1597,https://github.com/rgrr,1,https://github.com/contiki-os/contiki/pull/1597,"This allows the optimizer to put the corresponding variables into registers.
See also discussion about other static variables:
https://sourceforge.net/p/contiki/mailman/message/35010460/","This allows the optimizer to put the corresponding variables into registers.
See also discussion about other static variables:
https://sourceforge.net/p/contiki/mailman/message/35010460/",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1597,2016-04-13T16:54:52Z,2016-06-03T12:16:15Z,2016-06-03T12:16:15Z,MERGED,True,5,5,1,https://github.com/rgrr,Removed some unnecessary statics in do_event() and process_post().,1,[],https://github.com/contiki-os/contiki/pull/1597,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1597#issuecomment-209544549,"This allows the optimizer to put the corresponding variables into registers.
See also discussion about other static variables:
https://sourceforge.net/p/contiki/mailman/message/35010460/",üëç as soon Travis is green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1597,2016-04-13T16:54:52Z,2016-06-03T12:16:15Z,2016-06-03T12:16:15Z,MERGED,True,5,5,1,https://github.com/rgrr,Removed some unnecessary statics in do_event() and process_post().,1,[],https://github.com/contiki-os/contiki/pull/1597,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1597#issuecomment-223563590,"This allows the optimizer to put the corresponding variables into registers.
See also discussion about other static variables:
https://sourceforge.net/p/contiki/mailman/message/35010460/",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1598,2016-04-14T15:34:35Z,2016-04-19T15:27:15Z,2016-04-19T15:27:15Z,MERGED,True,1,2,3,https://github.com/mguc,JN516x NETSTACK_LLSEC.init and ccm-star fix,2,[],https://github.com/contiki-os/contiki/pull/1598,https://github.com/mguc,1,https://github.com/contiki-os/contiki/pull/1598,"I've been experimenting with the adaptivesec llsec driver and I ran into some issues on the jn516x platform. One problem was, that the first hello message was triggered twice on the jn516x platform (netstack_init + NETSTACK_LLSEC.init), causing the authentication to fail since the sending node updated his hello_challenge on the second init already and the receiving node was still working with the old challenge. Is there a reason, why NETSTACK_LLSEC.init should be called twice here?
The second problem was to replace ccm_star_driver_jn516x by the default ccm_star_driver. Both driver files have the same name. Renaming the platform driver file it to jn516x-ccm-star.c fixed the problem.","I've been experimenting with the adaptivesec llsec driver and I ran into some issues on the jn516x platform. One problem was, that the first hello message was triggered twice on the jn516x platform (netstack_init + NETSTACK_LLSEC.init), causing the authentication to fail since the sending node updated his hello_challenge on the second init already and the receiving node was still working with the old challenge. Is there a reason, why NETSTACK_LLSEC.init should be called twice here?
The second problem was to replace ccm_star_driver_jn516x by the default ccm_star_driver. Both driver files have the same name. Renaming the platform driver file it to jn516x-ccm-star.c fixed the problem.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1598,2016-04-14T15:34:35Z,2016-04-19T15:27:15Z,2016-04-19T15:27:15Z,MERGED,True,1,2,3,https://github.com/mguc,JN516x NETSTACK_LLSEC.init and ccm-star fix,2,[],https://github.com/contiki-os/contiki/pull/1598,https://github.com/neophob,2,https://github.com/contiki-os/contiki/pull/1598#issuecomment-211940065,"I've been experimenting with the adaptivesec llsec driver and I ran into some issues on the jn516x platform. One problem was, that the first hello message was triggered twice on the jn516x platform (netstack_init + NETSTACK_LLSEC.init), causing the authentication to fail since the sending node updated his hello_challenge on the second init already and the receiving node was still working with the old challenge. Is there a reason, why NETSTACK_LLSEC.init should be called twice here?
The second problem was to replace ccm_star_driver_jn516x by the default ccm_star_driver. Both driver files have the same name. Renaming the platform driver file it to jn516x-ccm-star.c fixed the problem.",+1,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1598,2016-04-14T15:34:35Z,2016-04-19T15:27:15Z,2016-04-19T15:27:15Z,MERGED,True,1,2,3,https://github.com/mguc,JN516x NETSTACK_LLSEC.init and ccm-star fix,2,[],https://github.com/contiki-os/contiki/pull/1598,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1598#issuecomment-211978149,"I've been experimenting with the adaptivesec llsec driver and I ran into some issues on the jn516x platform. One problem was, that the first hello message was triggered twice on the jn516x platform (netstack_init + NETSTACK_LLSEC.init), causing the authentication to fail since the sending node updated his hello_challenge on the second init already and the receiving node was still working with the old challenge. Is there a reason, why NETSTACK_LLSEC.init should be called twice here?
The second problem was to replace ccm_star_driver_jn516x by the default ccm_star_driver. Both driver files have the same name. Renaming the platform driver file it to jn516x-ccm-star.c fixed the problem.","good fixes, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1598,2016-04-14T15:34:35Z,2016-04-19T15:27:15Z,2016-04-19T15:27:15Z,MERGED,True,1,2,3,https://github.com/mguc,JN516x NETSTACK_LLSEC.init and ccm-star fix,2,[],https://github.com/contiki-os/contiki/pull/1598,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1598#issuecomment-211978171,"I've been experimenting with the adaptivesec llsec driver and I ran into some issues on the jn516x platform. One problem was, that the first hello message was triggered twice on the jn516x platform (netstack_init + NETSTACK_LLSEC.init), causing the authentication to fail since the sending node updated his hello_challenge on the second init already and the receiving node was still working with the old challenge. Is there a reason, why NETSTACK_LLSEC.init should be called twice here?
The second problem was to replace ccm_star_driver_jn516x by the default ccm_star_driver. Both driver files have the same name. Renaming the platform driver file it to jn516x-ccm-star.c fixed the problem.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1601,2016-04-18T09:28:11Z,2016-04-18T19:06:33Z,2016-04-18T19:06:33Z,MERGED,True,2,2,1,https://github.com/philrhinehart,cc26xx-cc13xx BLE beacon event issue,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1601,https://github.com/philrhinehart,1,https://github.com/contiki-os/contiki/pull/1601,"This pull request fixes an issue in the cc26xx-cc13xx BLE beacon process.
The rf_ble_beacon_process yields the thread using PROCESS_WAIT_EVENT() which allows the process to continue when any event is posted rather than checking that the event timer has expired, which is what we really want. This pull request adds a check for ble_adv_et event timer expiration, which prevents broadcasts from sensor updates, etc. from triggering the BLE beacon.","This pull request fixes an issue in the cc26xx-cc13xx BLE beacon process.
The rf_ble_beacon_process yields the thread using PROCESS_WAIT_EVENT() which allows the process to continue when any event is posted rather than checking that the event timer has expired, which is what we really want. This pull request adds a check for ble_adv_et event timer expiration, which prevents broadcasts from sensor updates, etc. from triggering the BLE beacon.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1601,2016-04-18T09:28:11Z,2016-04-18T19:06:33Z,2016-04-18T19:06:33Z,MERGED,True,2,2,1,https://github.com/philrhinehart,cc26xx-cc13xx BLE beacon event issue,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1601,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1601#issuecomment-211312740,"This pull request fixes an issue in the cc26xx-cc13xx BLE beacon process.
The rf_ble_beacon_process yields the thread using PROCESS_WAIT_EVENT() which allows the process to continue when any event is posted rather than checking that the event timer has expired, which is what we really want. This pull request adds a check for ble_adv_et event timer expiration, which prevents broadcasts from sensor updates, etc. from triggering the BLE beacon.","Discussed here: http://thread.gmane.org/gmane.os.contiki.devel/26826/
üëç Merging this after Travis passes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1602,2016-04-18T09:37:57Z,2016-04-18T11:00:44Z,2016-04-18T11:00:44Z,MERGED,True,12,12,2,https://github.com/philrhinehart,cc26xx-cc13xx oscillator control issue,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1602,https://github.com/philrhinehart,1,https://github.com/contiki-os/contiki/pull/1602,"This pull request fixes an issue in the cc26xx-cc13xx oscillator control which causes occasional faults and device lockup.
When running both ContikiMAC and the BLE beacon process, the ContikiMAC interrupt will occasionally preempt the beacon process while it is modifying the oscillators. This causes occasional bus faults and infinite loops if it happens at just the right time.
This pull request prevents the conflicts by checking that the BLE beacon is not active prior to modifying the oscillators.","This pull request fixes an issue in the cc26xx-cc13xx oscillator control which causes occasional faults and device lockup.
When running both ContikiMAC and the BLE beacon process, the ContikiMAC interrupt will occasionally preempt the beacon process while it is modifying the oscillators. This causes occasional bus faults and infinite loops if it happens at just the right time.
This pull request prevents the conflicts by checking that the BLE beacon is not active prior to modifying the oscillators.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1602,2016-04-18T09:37:57Z,2016-04-18T11:00:44Z,2016-04-18T11:00:44Z,MERGED,True,12,12,2,https://github.com/philrhinehart,cc26xx-cc13xx oscillator control issue,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1602,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1602#issuecomment-211312492,"This pull request fixes an issue in the cc26xx-cc13xx oscillator control which causes occasional faults and device lockup.
When running both ContikiMAC and the BLE beacon process, the ContikiMAC interrupt will occasionally preempt the beacon process while it is modifying the oscillators. This causes occasional bus faults and infinite loops if it happens at just the right time.
This pull request prevents the conflicts by checking that the BLE beacon is not active prior to modifying the oscillators.","Discussed here: http://thread.gmane.org/gmane.os.contiki.devel/26826/
üëç Merging this after Travis passes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/tonnenpinguin,1,https://github.com/contiki-os/contiki/pull/1605,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.","When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/nfi,2,https://github.com/contiki-os/contiki/pull/1605#issuecomment-211867130,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",Good catch but I think the problem is caused by c being a char instead of an int. getopt() returns an int so I think a nicer solution would be to change c to be an int instead of a char.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1605#issuecomment-211886292,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",Also see #982,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/tonnenpinguin,4,https://github.com/contiki-os/contiki/pull/1605#issuecomment-211890120,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",Fair enough. I changed the type of c to int and removed the typecast. I guess that works around the char signedness discussion and as @nfi mentioned should work for linux targets.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1605#issuecomment-212060841,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",This is a fix that we have used since long at Yanzi and in other Contiki projects. So this is a valid fix üëç (also very easy to review ;-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1605#issuecomment-212061642,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",If you squash your commits then üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/tonnenpinguin,7,https://github.com/contiki-os/contiki/pull/1605#issuecomment-212320549,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",Done!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1605,2016-04-19T09:48:24Z,2016-04-20T10:51:44Z,2016-04-20T11:32:19Z,MERGED,True,1,1,1,https://github.com/tonnenpinguin,Add typecast to native border router switch statement,1,[],https://github.com/contiki-os/contiki/pull/1605,https://github.com/nvt,8,https://github.com/contiki-os/contiki/pull/1605#issuecomment-212378499,"When running the native border router on my raspbian installation it would always fail because for some reason the while loop would not consider the statement to be true.
My best guess would be that the -1 value for a char is 0xFF while the same for an int would be 0xFFFFFFFF.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1606,2016-04-19T20:37:41Z,2016-06-01T21:15:27Z,2016-06-01T21:22:13Z,MERGED,True,386,181,7,https://github.com/peretuset,Adapted OpenMote-CC2538 sensor drivers to Contiki sensor API.,3,[],https://github.com/contiki-os/contiki/pull/1606,https://github.com/peretuset,1,https://github.com/contiki-os/contiki/pull/1606,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1606,2016-04-19T20:37:41Z,2016-06-01T21:15:27Z,2016-06-01T21:22:13Z,MERGED,True,386,181,7,https://github.com/peretuset,Adapted OpenMote-CC2538 sensor drivers to Contiki sensor API.,3,[],https://github.com/contiki-os/contiki/pull/1606,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1606#issuecomment-212119060,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,"Thank you Pere. @alignan Antonio, I had a (very quick) look at this and it looks sane. Any thoughts?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1606,2016-04-19T20:37:41Z,2016-06-01T21:15:27Z,2016-06-01T21:22:13Z,MERGED,True,386,181,7,https://github.com/peretuset,Adapted OpenMote-CC2538 sensor drivers to Contiki sensor API.,3,[],https://github.com/contiki-os/contiki/pull/1606,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1606#issuecomment-212125521,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,Happy to merge! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1606,2016-04-19T20:37:41Z,2016-06-01T21:15:27Z,2016-06-01T21:22:13Z,MERGED,True,386,181,7,https://github.com/peretuset,Adapted OpenMote-CC2538 sensor drivers to Contiki sensor API.,3,[],https://github.com/contiki-os/contiki/pull/1606,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1606#issuecomment-219222895,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,This looks pretty reasonable. @peretuset can you please put files through uncrustify? The ADXL driver at least needs a bit of love.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1606,2016-04-19T20:37:41Z,2016-06-01T21:15:27Z,2016-06-01T21:22:13Z,MERGED,True,386,181,7,https://github.com/peretuset,Adapted OpenMote-CC2538 sensor drivers to Contiki sensor API.,3,[],https://github.com/contiki-os/contiki/pull/1606,https://github.com/peretuset,5,https://github.com/contiki-os/contiki/pull/1606#issuecomment-222937687,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,Done it! Let me know if there is anything else that needs love... :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1606,2016-04-19T20:37:41Z,2016-06-01T21:15:27Z,2016-06-01T21:22:13Z,MERGED,True,386,181,7,https://github.com/peretuset,Adapted OpenMote-CC2538 sensor drivers to Contiki sensor API.,3,[],https://github.com/contiki-os/contiki/pull/1606,https://github.com/peretuset,6,https://github.com/contiki-os/contiki/pull/1606#issuecomment-223128821,This PR adapts the OpenMote-CC2538 sensor drivers to the Contiki sensor API.,Thanks Antonio!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1608,2016-04-20T10:50:32Z,2016-04-20T11:36:28Z,2016-04-21T10:15:02Z,MERGED,True,18,31,1,https://github.com/nvt,Remove protected memory from Coffee,1,[],https://github.com/contiki-os/contiki/pull/1608,https://github.com/nvt,1,https://github.com/contiki-os/contiki/pull/1608,"The protected memory structure was used by the sensornet checkpointing module to protect Coffee's internal structures while performing checkpointing. Since sensornet checkpointing has been removed, there is no longer a need for this extra functionality in Coffee.","The protected memory structure was used by the sensornet checkpointing module to protect Coffee's internal structures while performing checkpointing. Since sensornet checkpointing has been removed, there is no longer a need for this extra functionality in Coffee.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1609,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.","This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/nfi,2,https://github.com/contiki-os/contiki/pull/1609#issuecomment-214685755,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",What do you think about adding PRINT6LLADDR() in uip-debug.h that prints a uip_lladdr_t and let PRINTLLADDR() in net-debug.h print a linkaddr_t ? Or keep PRINTLLADDR() in uip-debug.h and add a PRINTLINKADDR() in net-debug.h? Then the cast from linkaddr_t to uip_lladdr_t could be removed in the debug output in code that run without IP.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1609#issuecomment-214713874,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",I'm not even sure why we have two different types to be honest.. what would you think about using linkaddr_t everywhere instead?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/nfi,4,https://github.com/contiki-os/contiki/pull/1609#issuecomment-214722992,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",I think it would be really nice if the link layer addresses could to be merged into one type. I do not think there should be an important reason to have multiple types anymore.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1609#issuecomment-214745634,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.","OK we're on the same page then :)
I implemented your suggestion of keeping the check for NULL addr, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/joakimeriksson,6,https://github.com/contiki-os/contiki/pull/1609#issuecomment-214754525,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",@simonduq we have two for historic reason I would say. I am definitively positive to have just the linkaddr_t instead of two that cause many ugly casts...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1609#issuecomment-223124355,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",Where are we on this one? ready to merge?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1609#issuecomment-223125885,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",yes!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1609,2016-04-20T11:08:14Z,2016-06-01T21:52:34Z,2017-10-27T20:06:30Z,MERGED,True,166,73,15,https://github.com/simonduq,Added net-debug.[ch] to provide debug functions even in the non-IP case,1,[],https://github.com/contiki-os/contiki/pull/1609,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1609#issuecomment-223136234,"This PR moves non IP related debug functions from ip-debug.[ch] to net-debug.[ch], enabling the use macros such as PRINTF and PRINTLLADDR in code that may run without IP.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1610,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1610#issuecomment-212395149,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","We need to wait for #1609 to be merged, right?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1610#issuecomment-212400253,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","I think that would be cleaner, yes. The idea was to give a chance to non-tsch experts to review the non-tsch related part first (#1609)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/pablocorbalan,4,https://github.com/contiki-os/contiki/pull/1610#issuecomment-218237592,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","I have tried the code of this PR and it works nicely. I tested it also with the reliable unicast (runicast) primitive and Contiki Collect and it seems to work fine with all of them. Nice work! üëç
I may test this a bit more extensively (perhaps, even in some testbed). I may also try to create a simple scheduler for Contiki Collect + TSCH. I'll let you know my results!
One question: are the changes of commit 0c79d23 necessary? The functions that were used depend on nbr-table.[ch] but not on IP. I feel that we may make the code a bit more complex just to avoid using the nbr-tablemodule. Also, if we would eventually update Contiki Collect to use the nbr-tablemodule, perhaps, it would make more sense to keep using that module here too.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1610#issuecomment-223682729,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","@pablocorbalan good point regarding the neighbor table for time source selection. Cannot seem to recall why I did this. I was assuming nbr-table was IP-only at some point but this is indeed not true. Will try to look into this again (or if you happen to do, as you mentioned you might use this, please share your conclusions!)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1610#issuecomment-225268155,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","I did as suggested by @pablocorbalan, that is, revert back to using nbr-table for eb-autoselect. A few fixes were needed to get it to work with 2-byte addresses and with other recent changes. This PR is ready IMO (the diff has become very small!)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/pablocorbalan,7,https://github.com/contiki-os/contiki/pull/1610#issuecomment-225372698,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","@simonduq Sorry for the delay! I haven't really found the time to work more on this, so I have no updates. I might push in the future more examples to the rime-tschfolder.
I tried the updated code as well with a runicast application and collectand it also worked fine. This looks great to me with the last changes and using the nbr-table module. Thanks for the update!
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1610#issuecomment-225977521,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609",setting timeout for merging,True,{'THUMBS_UP': ['https://github.com/pablocorbalan']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1610#issuecomment-234945035,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609",merging after timeout,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/remyleone,10,https://github.com/contiki-os/contiki/pull/1610#issuecomment-235243869,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609",It doesn't seem to work with wismote as a target platform: http://pastebin.com/XwxSJcZf,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1610,2016-04-20T11:10:42Z,2016-07-25T12:55:37Z,2017-10-27T20:03:22Z,MERGED,True,206,6,5,https://github.com/simonduq,TSCH with Rime,4,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1610,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1610#issuecomment-235244461,"This PR makes TSCH work with short addresses and Rime. Added new example for Rime/TSCH. Useful for testing TSCH without a full IPv6 stack.
Note that this PR includes #1609","That is right, TSCH is not supported on Wismote. More info about an ongoing porting effort at #1517",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1611,2016-04-20T12:36:23Z,2016-04-21T10:14:43Z,2016-04-21T10:14:49Z,MERGED,True,56,62,2,https://github.com/nvt,Coffee: improve comments and code formatting,1,[],https://github.com/contiki-os/contiki/pull/1611,https://github.com/nvt,1,https://github.com/contiki-os/contiki/pull/1611,"Improved mainly the comments, debug statements and source code formatting. Also changed type of sector indices to cfs_page_t in case uint16_t is too small.","Improved mainly the comments, debug statements and source code formatting. Also changed type of sector indices to cfs_page_t in case uint16_t is too small.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1611,2016-04-20T12:36:23Z,2016-04-21T10:14:43Z,2016-04-21T10:14:49Z,MERGED,True,56,62,2,https://github.com/nvt,Coffee: improve comments and code formatting,1,[],https://github.com/contiki-os/contiki/pull/1611,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1611#issuecomment-212442158,"Improved mainly the comments, debug statements and source code formatting. Also changed type of sector indices to cfs_page_t in case uint16_t is too small.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/nvt,1,https://github.com/contiki-os/contiki/pull/1613,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.","This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1613#issuecomment-213544334,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.","üëç
(don't hesitate to remove even more unused features btw :))",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1613#issuecomment-213560263,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.",Should this be documented elsewhere? I would suggest mentioning this on the wiki as done with the lost platforms.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1613#issuecomment-213562971,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.",good idea :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/1613#issuecomment-214685285,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.","OK, I'm merging this and creating a Wiki page about lost modules.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/1613#issuecomment-214706810,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.",The new page on lost modules can be found here: https://github.com/contiki-os/contiki/wiki/Lost-modules,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1613,2016-04-21T13:23:58Z,2016-04-26T09:40:28Z,2016-04-26T11:38:57Z,MERGED,True,540,1668,12,https://github.com/nvt,Remove Deluge and associated test files.,1,[],https://github.com/contiki-os/contiki/pull/1613,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1613#issuecomment-214713323,"This Deluge implementation was created in 2007 for research paper experiments with ELF module distribution. It has not been used much since then, and the prevalent method of updating software in real IoT products today is full firmware updates that are typically transferred with more reliable bulk transfer protocols. Anyone interested in using it can of course still access it from the repository history and previous Contiki releases.",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1618,2016-04-22T19:46:55Z,2016-04-27T22:12:23Z,2017-10-27T20:06:10Z,MERGED,True,600,600,2,https://github.com/simonduq,Fixes indent in tcpip.c and uip6.c,2,[],https://github.com/contiki-os/contiki/pull/1618,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1618,Nothing but spacing changes: https://github.com/contiki-os/contiki/pull/1618/files?w=1,Nothing but spacing changes: https://github.com/contiki-os/contiki/pull/1618/files?w=1,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1618,2016-04-22T19:46:55Z,2016-04-27T22:12:23Z,2017-10-27T20:06:10Z,MERGED,True,600,600,2,https://github.com/simonduq,Fixes indent in tcpip.c and uip6.c,2,[],https://github.com/contiki-os/contiki/pull/1618,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1618#issuecomment-213566571,Nothing but spacing changes: https://github.com/contiki-os/contiki/pull/1618/files?w=1,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1618,2016-04-22T19:46:55Z,2016-04-27T22:12:23Z,2017-10-27T20:06:10Z,MERGED,True,600,600,2,https://github.com/simonduq,Fixes indent in tcpip.c and uip6.c,2,[],https://github.com/contiki-os/contiki/pull/1618,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1618#issuecomment-213594349,Nothing but spacing changes: https://github.com/contiki-os/contiki/pull/1618/files?w=1,we need to do something about the completely stochastic 04-rpl-large-network....,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1618,2016-04-22T19:46:55Z,2016-04-27T22:12:23Z,2017-10-27T20:06:10Z,MERGED,True,600,600,2,https://github.com/simonduq,Fixes indent in tcpip.c and uip6.c,2,[],https://github.com/contiki-os/contiki/pull/1618,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1618#issuecomment-213594673,Nothing but spacing changes: https://github.com/contiki-os/contiki/pull/1618/files?w=1,"we need to do something about the completely stochastic 04-rpl-large-network....

üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1619,2016-04-22T22:23:17Z,2016-06-01T21:03:50Z,2017-10-27T20:05:56Z,MERGED,True,24,22,14,https://github.com/simonduq,Fix bug in TSCH for platforms with 16-bit rtimer,1,[],https://github.com/contiki-os/contiki/pull/1619,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1619,"On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.","On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1619,2016-04-22T22:23:17Z,2016-06-01T21:03:50Z,2017-10-27T20:05:56Z,MERGED,True,24,22,14,https://github.com/simonduq,Fix bug in TSCH for platforms with 16-bit rtimer,1,[],https://github.com/contiki-os/contiki/pull/1619,https://github.com/greg-king5,2,https://github.com/contiki-os/contiki/pull/1619#issuecomment-213644449,"On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.","I think that you should go further:

Make RTIMER_CLOCK_DIFF() be the only platform-dependent macro.
Redefine RTIMER_CLOCK_LT() to expand RTIMER_CLOCK_DIFF().
Move RTIMER_CLOCK_LT() to outside the preprocessor guard (it will be written in only one place).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1619,2016-04-22T22:23:17Z,2016-06-01T21:03:50Z,2017-10-27T20:05:56Z,MERGED,True,24,22,14,https://github.com/simonduq,Fix bug in TSCH for platforms with 16-bit rtimer,1,[],https://github.com/contiki-os/contiki/pull/1619,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1619#issuecomment-213675670,"On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.","True, will do!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1619,2016-04-22T22:23:17Z,2016-06-01T21:03:50Z,2017-10-27T20:05:56Z,MERGED,True,24,22,14,https://github.com/simonduq,Fix bug in TSCH for platforms with 16-bit rtimer,1,[],https://github.com/contiki-os/contiki/pull/1619,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1619#issuecomment-214747866,"On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.","Done as you suggested, thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1619,2016-04-22T22:23:17Z,2016-06-01T21:03:50Z,2017-10-27T20:05:56Z,MERGED,True,24,22,14,https://github.com/simonduq,Fix bug in TSCH for platforms with 16-bit rtimer,1,[],https://github.com/contiki-os/contiki/pull/1619,https://github.com/greg-king5,5,https://github.com/contiki-os/contiki/pull/1619#issuecomment-215225859,"On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.",Looks good to me. üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1619,2016-04-22T22:23:17Z,2016-06-01T21:03:50Z,2017-10-27T20:05:56Z,MERGED,True,24,22,14,https://github.com/simonduq,Fix bug in TSCH for platforms with 16-bit rtimer,1,[],https://github.com/contiki-os/contiki/pull/1619,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1619#issuecomment-215234425,"On platforms with 16-bit rtimer, the current estimated_drift is wrong when either (but not both) expected_rx_time or rx_start_time has wrapped. This sends the node straight off sync.
The fix introduces a new macro RTIMER_CLOCK_DIFF, defined exactly where RTIMER_CLOCK_LT was already set.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1620,2016-04-22T22:29:14Z,2016-04-27T13:41:24Z,2017-10-27T20:06:12Z,MERGED,True,0,6,1,https://github.com/simonduq,TSCH: remove 'not for us' log,1,[],https://github.com/contiki-os/contiki/pull/1620,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1620,This particular log was mostly creating noise,This particular log was mostly creating noise,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1621,2016-04-22T23:11:30Z,2016-04-25T09:40:36Z,2017-10-27T20:06:05Z,MERGED,True,56,84,14,https://github.com/simonduq,Fix output of RPL tests,1,[],https://github.com/contiki-os/contiki/pull/1621,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1621,In the process of attempting to debug 04-rpl-large-network I fixed the output of RPL Travis tests,In the process of attempting to debug 04-rpl-large-network I fixed the output of RPL Travis tests,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1622,2016-04-23T06:06:13Z,2016-04-25T09:40:25Z,2017-10-27T20:03:08Z,MERGED,True,2,2,2,https://github.com/simonduq,Fixing 04-rpl-large-network,2,[],https://github.com/contiki-os/contiki/pull/1622,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1622,"This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.","This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1622,2016-04-23T06:06:13Z,2016-04-25T09:40:25Z,2017-10-27T20:03:08Z,MERGED,True,2,2,2,https://github.com/simonduq,Fixing 04-rpl-large-network,2,[],https://github.com/contiki-os/contiki/pull/1622,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1622#issuecomment-213728253,"This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.","I have taken a quick look at the test and from what I can see it is too many nodes to hold at a single time in the RPL Root which means that it is impossible for all nodes to have routes downwards at any given time. Having DAO ACK enabled will of course cause problems now and then - not having it on might also cause problems. The test seems to send from a node - mostly upwards (will likely work) and then RPL Root will send downward one hop.
What about trying to setup some documentation per test? It would be very very valuable when they fail to understan what the idea is and if there is specific things such as testing to scale beyond what the Root can store, etc. In this case I am not sure if that is the test or not. If it is - there is 300 / 400 chance that the node that needs its downward route do not get it. But I can be wrong...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1622,2016-04-23T06:06:13Z,2016-04-25T09:40:25Z,2017-10-27T20:03:08Z,MERGED,True,2,2,2,https://github.com/simonduq,Fixing 04-rpl-large-network,2,[],https://github.com/contiki-os/contiki/pull/1622,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1622#issuecomment-213919864,"This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.","OK, I don't know if the intent of this particular test is to check what happens when the root doesn't have enough space for all nodes. If it is I feel like you, we have no way to guarantee things will work. I might also be missing something.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1622,2016-04-23T06:06:13Z,2016-04-25T09:40:25Z,2017-10-27T20:03:08Z,MERGED,True,2,2,2,https://github.com/simonduq,Fixing 04-rpl-large-network,2,[],https://github.com/contiki-os/contiki/pull/1622,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1622#issuecomment-214223843,"This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.","@joakimeriksson do you agree with disabling DAO ACK by default (merging this PR) until we come up with a better solution? (i.e. fixing/adjusting the test if need be, or DAO ACK if the problem lies there)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1622,2016-04-23T06:06:13Z,2016-04-25T09:40:25Z,2017-10-27T20:03:08Z,MERGED,True,2,2,2,https://github.com/simonduq,Fixing 04-rpl-large-network,2,[],https://github.com/contiki-os/contiki/pull/1622,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1622#issuecomment-214233982,"This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.",Sure. As long as it is possible to enable I am fine with that!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1622,2016-04-23T06:06:13Z,2016-04-25T09:40:25Z,2017-10-27T20:03:08Z,MERGED,True,2,2,2,https://github.com/simonduq,Fixing 04-rpl-large-network,2,[],https://github.com/contiki-os/contiki/pull/1622,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1622#issuecomment-214235721,"This PR:

Disables DAO-ACK by default, as it seemed to cause a failure on test 04-rpl-large-network.csc with random seed 1, triggering a new run with seed 5. As this is one of the longest tests, this often triggered a Travis timeout;
Uses a single seed for all simulation tests (instead of two). Now a failure on a single seed will cause a complete failure of the non-regression test.",ok!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/cedric-d,1,https://github.com/contiki-os/contiki/pull/1624,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.","When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1624#issuecomment-216855980,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.","You should consider rebasing, the PR fails on tests that were flaky at the time of your first submission, but are now much more stable",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/cedric-d,3,https://github.com/contiki-os/contiki/pull/1624#issuecomment-218258044,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.","Well... As you can see, regression tests still do not pass. I wonder if I correctly understand them.
I thought that 2 tests (06-exp5438-udp-fragmentation-contikimac-large-sender.csc and 07-exp5438-udp-fragmentation-nullrdc-large-sender.csc) should succeed to transmit big packets with fragmentation and 2 tests (08-exp5438-udp-fragmentation-contikimac-too-large-sender.csc and 09-exp5438-udp-fragmentation-nullrdc-too-large-sender.csc) should fail to transmit too big packets. But in all these 4 tests, the test script is fragmentation-should-receive-none.js, so none of these tests should transmit packets!?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1624#issuecomment-223408986,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.",Travis is happy now,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1624#issuecomment-225278915,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.","I don't like that you had to change the tests, unless there was a flaw in the test (was there?).
Your first commit, that is, your original fix, looked good to me. Simple and with no unwanted side effect. I see no reason Travis would fail on it (the failure was probably on a flaky test). I would suggest to rebase on latest master and remove all commits but the first one (the history needs cleaning anyway as we don't want the merge commit). Happy to support this PR once this is done and if Travis is green.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/cedric-d,6,https://github.com/contiki-os/contiki/pull/1624#issuecomment-225700895,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.","To my mind there are 2 problems with the IPv6 large sender tests:

The buffer size is increased for the sender but not for the receiver which cannot reassemble the packets.
The ""large-sender"" tests check that no packet is received like the ""too-larger-sender"" ones although, with the previous point corrected, they should check that all packets are received.

My first commit alone fails on the ""too-large-sender"" tests: If a packet is too large, it is no more dropped as expected by the tests, it is now truncated and successfully transmitted.
Another way to prevent over-read is to simply skip too big packets. Non-regression tests pass without modification.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1624#issuecomment-225978392,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.",OK I would also be fine with the option of skipping too big packets,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1624#issuecomment-226156381,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1624,2016-04-24T08:05:49Z,2016-06-15T11:08:45Z,2016-06-15T11:25:15Z,MERGED,True,2,4,1,https://github.com/cedric-d,Prevent uIP buffer over-read with big UDP packets,1,[],https://github.com/contiki-os/contiki/pull/1624,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1624#issuecomment-226156872,"When an UDP packet too big to fit in the uIP packet buffer is to be sent, the part fitting in the uIP buffer is copied to it (so no buffer overflow occurs) but uIP actually sends a packet of the original size therefore a buffer over-read occurs.
This modification makes uIP sends only the data copied to the packet buffer. An alternative would be not to send anything and return an error.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1625,2016-04-24T08:29:05Z,2016-04-28T10:01:16Z,2016-04-28T13:16:41Z,MERGED,True,2,1,1,https://github.com/kkrentz,"Fix for ""LLSEC802154_CONF_ENABLED undefined""",1,[],https://github.com/contiki-os/contiki/pull/1625,https://github.com/kkrentz,1,https://github.com/contiki-os/contiki/pull/1625,This is a fix for the issue described in #1425.,This is a fix for the issue described in #1425.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1625,2016-04-24T08:29:05Z,2016-04-28T10:01:16Z,2016-04-28T13:16:41Z,MERGED,True,2,1,1,https://github.com/kkrentz,"Fix for ""LLSEC802154_CONF_ENABLED undefined""",1,[],https://github.com/contiki-os/contiki/pull/1625,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1625#issuecomment-215240345,This is a fix for the issue described in #1425.,Seems like a no brainer üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1625,2016-04-24T08:29:05Z,2016-04-28T10:01:16Z,2016-04-28T13:16:41Z,MERGED,True,2,1,1,https://github.com/kkrentz,"Fix for ""LLSEC802154_CONF_ENABLED undefined""",1,[],https://github.com/contiki-os/contiki/pull/1625,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1625#issuecomment-215374426,This is a fix for the issue described in #1425.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1626,2016-04-24T09:13:15Z,2016-05-03T10:52:11Z,2016-05-04T18:46:14Z,MERGED,True,6,1,1,https://github.com/jnohlgard,core/cfs: Disallow seeking past the end of a file unless it is writable,1,[],https://github.com/contiki-os/contiki/pull/1626,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1626,Files opened with CFS_READ should not allow seeking past the end of the file.,Files opened with CFS_READ should not allow seeking past the end of the file.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1626,2016-04-24T09:13:15Z,2016-05-03T10:52:11Z,2016-05-04T18:46:14Z,MERGED,True,6,1,1,https://github.com/jnohlgard,core/cfs: Disallow seeking past the end of a file unless it is writable,1,[],https://github.com/contiki-os/contiki/pull/1626,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1626#issuecomment-214687033,Files opened with CFS_READ should not allow seeking past the end of the file.,"This looks reasonable, but I had a couple of easy-to-fix source code comments.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1626,2016-04-24T09:13:15Z,2016-05-03T10:52:11Z,2016-05-04T18:46:14Z,MERGED,True,6,1,1,https://github.com/jnohlgard,core/cfs: Disallow seeking past the end of a file unless it is writable,1,[],https://github.com/contiki-os/contiki/pull/1626,https://github.com/jnohlgard,3,https://github.com/contiki-os/contiki/pull/1626#issuecomment-216150384,Files opened with CFS_READ should not allow seeking past the end of the file.,"Addressed comments.
OK to squash?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1626,2016-04-24T09:13:15Z,2016-05-03T10:52:11Z,2016-05-04T18:46:14Z,MERGED,True,6,1,1,https://github.com/jnohlgard,core/cfs: Disallow seeking past the end of a file unless it is writable,1,[],https://github.com/contiki-os/contiki/pull/1626,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/1626#issuecomment-216192369,Files opened with CFS_READ should not allow seeking past the end of the file.,"Thanks, it can be squashed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1626,2016-04-24T09:13:15Z,2016-05-03T10:52:11Z,2016-05-04T18:46:14Z,MERGED,True,6,1,1,https://github.com/jnohlgard,core/cfs: Disallow seeking past the end of a file unless it is writable,1,[],https://github.com/contiki-os/contiki/pull/1626,https://github.com/jnohlgard,5,https://github.com/contiki-os/contiki/pull/1626#issuecomment-216436589,Files opened with CFS_READ should not allow seeking past the end of the file.,squashed,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1626,2016-04-24T09:13:15Z,2016-05-03T10:52:11Z,2016-05-04T18:46:14Z,MERGED,True,6,1,1,https://github.com/jnohlgard,core/cfs: Disallow seeking past the end of a file unless it is writable,1,[],https://github.com/contiki-os/contiki/pull/1626,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/1626#issuecomment-216494113,Files opened with CFS_READ should not allow seeking past the end of the file.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1628,2016-04-25T07:50:59Z,2016-04-25T08:04:13Z,2016-04-25T08:04:13Z,CLOSED,False,12,12,7,https://github.com/vuahoa,Release 3 0,4,[],https://github.com/contiki-os/contiki/pull/1628,https://github.com/vuahoa,1,https://github.com/contiki-os/contiki/pull/1628,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/pablocorbalan,1,https://github.com/contiki-os/contiki/pull/1632,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.","This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1632#issuecomment-215481455,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.","Haven't looked at the code and I'm not familiar with Contiki Collect, but using the neighbor table also there sounds like the way forward. I see no reason to oppose to such contribution, just keep us posted when you have something ready. Having a separate sub-folder for Collect also sounds good.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/niklas88,3,https://github.com/contiki-os/contiki/pull/1632#issuecomment-237525752,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.",I'm interested in this work too since we will be using collect for a development project. Any pointers as to which parts are most work-in-progressy? Giving the code a quick look most changes seem to be quite simple refactoring. Also @simonduq would you be interested in me giving this a more thorough review?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1632#issuecomment-243086210,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.",I'll be ready to review as soon as this converges to a more final version (it is still WIP),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/niklas88,5,https://github.com/contiki-os/contiki/pull/1632#issuecomment-246709321,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.","Ok so even though this pull request seems to have been abandoned by the author I now took a closer look at it. We are thinking of building an internal version of Rime Collect optimized for our use case and I wanted to begin this with cleaning up a bit (e.g. collect_send(), send_queued_packet() and retransmit_current_parent() overlap a lot).
So what I found is that this code works in simulation but not in my testbed, Debugging it, this seems to be due to the parent being 0.0 by default and nbr_tables treating linkaddr_null as a special value. So what I think is happening is that it's not just a valid key that gets used if the passed linkaddr pointer is NULL but because nbr_table_get_from_lladdr() doesn't check the used bit and entry for 0.0 will always be found.
That said, would there be interest in finishing this pull request and if yes, would it be reasonable to change nbr_table_get_from_lladdr()? Because other than these issues it looks to me to be almost finished with all references to collects own table mechanism already gone.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/pablocorbalan,6,https://github.com/contiki-os/contiki/pull/1632#issuecomment-247944389,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.","Hi,
Sorry for all the delay! I have been busy with many things and disconnected from Contiki. Yes, I'd be interested in finishing the PR, but I am not sure how much time I can really spend on it.
When I submitted the PR, I tested the code in Cooja with the collectexample and everything seemed to work, but I never tried the code on a Testbed, that is partially why it is still WIP. I'll try to see if I can do some testing on Flocklaband I'll get back to you. I'll check wether I get the same problems you are mentioning and in such case how to fix them.
In any case, @niklas88 you are more than welcome to make me a Pull Request to my branch to update/improve the code. If you want, we can also talk to see how to speed this up. You can also comment on specific parts of the code you may want to change in case there is something wrong.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/niklas88,7,https://github.com/contiki-os/contiki/pull/1632#issuecomment-250482612,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.","@pablocorbalan so I've looked into this and to me it looks like the nbr_table somehow always has an entry for lladdr = 0.0 that also gets picked as best but only after another neighbor has been seen. I'm still trying to find out how to fix this though and I'm quite a bit confused how this element ends up int the table and why it only gets picked as best once another neighbor has been seen.
As a dirty workaround adding collect_nbr_add(&linkaddr_null, RTMETRIC_MAX)  to collect_open() makes it work in a simple 1 sink 1 node test.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1632,2016-04-27T01:39:59Z,,2016-12-01T12:37:23Z,OPEN,False,361,392,8,https://github.com/pablocorbalan,[WIP] Update Contiki Collect to use the NBR Table module,5,['work-in-progress'],https://github.com/contiki-os/contiki/pull/1632,https://github.com/niklas88,8,https://github.com/contiki-os/contiki/pull/1632#issuecomment-252891153,"This PR updates collect-neighbor to use the nbr-table module. This is basically a code refactoring of Contiki Collect to make it easier to understand its code and maintain it. This should also facilitate to extend Contiki Collect for other applications, e.g., adding a routing table for downwards communications or a link statistics module similar to PR#1403.
This is still work in progress (WIP), but I would prefer to get some feedback from the Contiki maintainers to see if these changes could be accepted in the future (after improving the PR) or if it is preferred to keep the current neighbor list as it is.
The PR also updates all the examples (AFAIK) that depend on Contiki Collect. Moreover, it shortens the collect-neighbor function names. As a consequence, it may be a good idea to also change collect-neighbor.[ch]to collect-nbr.[ch]. I would also prefer to have the Collect code in a folder within the RIME folder to organise the RIME files a bit better.
Please, let me know if you agree with the main idea of the PR and your comments to improve it.",@pablocorbalan Ok digging deeper it turns out this was caused by an uninitialized use of the phase_nbr table when using ContikiMAC-Async which we also use in our current version. With the fix mentioned in this Pull Request I now have this working in hardware and without the workaround mentioned in the previous comment.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1633,2016-04-27T08:48:05Z,,2016-06-11T08:59:01Z,OPEN,False,72,71,5,https://github.com/joakimeriksson,Renamed and moved the update neighbor table function in RPL. ,1,"['Core', 'RPL']",https://github.com/contiki-os/contiki/pull/1633,https://github.com/joakimeriksson,1,https://github.com/contiki-os/contiki/pull/1633,"This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.","This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1633,2016-04-27T08:48:05Z,,2016-06-11T08:59:01Z,OPEN,False,72,71,5,https://github.com/joakimeriksson,Renamed and moved the update neighbor table function in RPL. ,1,"['Core', 'RPL']",https://github.com/contiki-os/contiki/pull/1633,https://github.com/pablocorbalan,2,https://github.com/contiki-os/contiki/pull/1633#issuecomment-215096193,"This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.","The main idea of this PR is very similar to 1400. Should we then merge somehow both PRs? After our discussion back then, I think it could be a good idea to refresh the state of a neighbor after every incoming unicast IP message received as in 1400. That way in the dis_inputand dao_input functions you would not need to worry about refreshing the state.
What do you think about this? I could update 1400 if required.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1633,2016-04-27T08:48:05Z,,2016-06-11T08:59:01Z,OPEN,False,72,71,5,https://github.com/joakimeriksson,Renamed and moved the update neighbor table function in RPL. ,1,"['Core', 'RPL']",https://github.com/contiki-os/contiki/pull/1633,https://github.com/joakimeriksson,3,https://github.com/contiki-os/contiki/pull/1633#issuecomment-215104095,"This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.","It is similar yes - but #1400 will make all incoming packets always keep a neighbor refreshed which is as we also discussed not RFC compliant. In this PR I add the function and call from RPL which is know to do some non compliant tricks already so we are not better nor worse with this fix. The problem with #1400 is that it would need a configuration too allow this non-RFC-compliant refresh (we should in the future also have that in RPL - especially for DIO/DIS). The main thing with this PR is to clean-up some parts of the RPL code that had a function that was badly named and in the wrong module. But I agree - it is adding more or less the same function - maybe we could switch to your suggested name and add configuration for turning on / off the refresh for all packets?
What I have started to do at Yanzi is to allow applications to detect forward progress - e.g. any information in the packet that signals that we do not have a packet stuck in CSMA retransmission or similar. This can be TCP sequence numbers, new payload, timestamps, encryption sequence number or anything else. But we are doing it only at the application layer that knows that it is actually forward progress. We should att this in TCP - which is easy and have some nice examples.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1633,2016-04-27T08:48:05Z,,2016-06-11T08:59:01Z,OPEN,False,72,71,5,https://github.com/joakimeriksson,Renamed and moved the update neighbor table function in RPL. ,1,"['Core', 'RPL']",https://github.com/contiki-os/contiki/pull/1633,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1633#issuecomment-225277070,"This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.","Joakim is there something in this one that will not be covered by #1400 ?
My opinion is we should forward-progress thing aside for now (as it is complex and the problem it solves is not one that is likely to occur nor would have great consequences)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1633,2016-04-27T08:48:05Z,,2016-06-11T08:59:01Z,OPEN,False,72,71,5,https://github.com/joakimeriksson,Renamed and moved the update neighbor table function in RPL. ,1,"['Core', 'RPL']",https://github.com/contiki-os/contiki/pull/1633,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1633#issuecomment-225344588,"This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.","Sure, forward progress is easy to add whenever we think we need it. I think the refresh parts of all unicast packets are ok, as long as we know it is passing via the nbr policy whenever that is active. So merging 1400 would make it possible to remove parts of this PR. I can try to ""rebase"" this if you pull 1400 ASAP.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1633,2016-04-27T08:48:05Z,,2016-06-11T08:59:01Z,OPEN,False,72,71,5,https://github.com/joakimeriksson,Renamed and moved the update neighbor table function in RPL. ,1,"['Core', 'RPL']",https://github.com/contiki-os/contiki/pull/1633,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1633#issuecomment-225345607,"This PR moves the function rpl_icmp6_update_nbr_table from RPL into uip-ds6-nbr so that it is in a more logical module. It is also changed to refresh a neighbor entry only - rather than both refreshing and adding if not already there. This makes the function more easy to understand and also more useful for applications or other modules that know that a neighbor is showing forward progress on the IP layer. This is useful for avoiding neighbor entry to go in to non-reachable state and cause NS to be sent (and packets to be lost).
The new function is uip_ds6_nbr_t *uip_ds6_nbr_refresh(const uip_ipaddr_t *ipaddr) which just refresh a IPv6 neighbor entry.","Sounds good.
Le 11 juin 2016 10:34, ""Joakim Eriksson"" notifications@github.com a
√©crit :

Sure, forward progress is easy to add whenever we think we need it. I
think the refresh parts of all unicast packets are ok, as long as we know
it is passing via the nbr policy whenever that is active. So merging 1400
would make it possible to remove parts of this PR. I can try to ""rebase""
this if you pull 1400 ASAP.
‚Äî
You are receiving this because you commented.
Reply to this email directly, view it on GitHub
#1633 (comment),
or mute the thread
https://github.com/notifications/unsubscribe/ABXCT7ohubXSQrOyNY8A69f38rGq2cWfks5qKnMrgaJpZM4IQuXp
.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1634,2016-04-27T12:06:24Z,2016-04-27T21:47:07Z,2017-10-27T20:05:57Z,MERGED,True,3,3,1,https://github.com/simonduq,DAO ACK fix,2,[],https://github.com/contiki-os/contiki/pull/1634,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1634,This fix makes sure the dao_sequence stored in my_dao_seqno is the same used in the outgoing DAO,This fix makes sure the dao_sequence stored in my_dao_seqno is the same used in the outgoing DAO,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1634,2016-04-27T12:06:24Z,2016-04-27T21:47:07Z,2017-10-27T20:05:57Z,MERGED,True,3,3,1,https://github.com/simonduq,DAO ACK fix,2,[],https://github.com/contiki-os/contiki/pull/1634,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1634#issuecomment-215062660,This fix makes sure the dao_sequence stored in my_dao_seqno is the same used in the outgoing DAO,Nice catch üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1634,2016-04-27T12:06:24Z,2016-04-27T21:47:07Z,2017-10-27T20:05:57Z,MERGED,True,3,3,1,https://github.com/simonduq,DAO ACK fix,2,[],https://github.com/contiki-os/contiki/pull/1634,https://github.com/joakimeriksson,3,https://github.com/contiki-os/contiki/pull/1634#issuecomment-215064349,This fix makes sure the dao_sequence stored in my_dao_seqno is the same used in the outgoing DAO,Looks good to me also! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1635,2016-04-27T12:22:00Z,2016-04-28T12:45:01Z,2017-10-27T20:05:55Z,MERGED,True,3,1,1,https://github.com/simonduq,RPL: do not add K flag to no-path DAO as we discard the ACK anyway,1,[],https://github.com/contiki-os/contiki/pull/1635,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1635,We currently do not retransmit nopath DAOs nor do anything when getting an ACK for them. This PR removes the K flag from nopath DAOs to make sure no ACK is sent.,We currently do not retransmit nopath DAOs nor do anything when getting an ACK for them. This PR removes the K flag from nopath DAOs to make sure no ACK is sent.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1635,2016-04-27T12:22:00Z,2016-04-28T12:45:01Z,2017-10-27T20:05:55Z,MERGED,True,3,1,1,https://github.com/simonduq,RPL: do not add K flag to no-path DAO as we discard the ACK anyway,1,[],https://github.com/contiki-os/contiki/pull/1635,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1635#issuecomment-215411951,We currently do not retransmit nopath DAOs nor do anything when getting an ACK for them. This PR removes the K flag from nopath DAOs to make sure no ACK is sent.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/frank-freihube-rmcan-com,1,https://github.com/contiki-os/contiki/pull/1636,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1636#issuecomment-215411464,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,"This PR introduces a semantic change, since it writes to parts of the buffer that have not been set to the file's contents. Hence, I think it is better if this would be configured with a flag in cfs_coffee_set_io_semantics().
Background regarding trailing zeroes in Coffee:
In order to reduce code complexity, Coffee is designed not to preserve trailing zeroes in files after restarting a system because some kind of end-of-file marker would be required, and this could be costly to update on flash memory. Coffee does, however, preserve the zeroes if the file is re-opened, since it can keep the file size in the struct file object for the file. If cfs_read returns fewer bytes than expected, the caller should handle this condition by inspecting the return value of cfs_read.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/frank-freihube-rmcan-com,3,https://github.com/contiki-os/contiki/pull/1636#issuecomment-215634318,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,"This sounds like a good idea and I changed it so it's configurable.
My workaround does not change anything in the file it only changes the way how an EOF during a read gets handled as it will ensure that some bytes in the destination buffer have an undefined state. Literally it only sets readSize - fileLength bytes to zero.
For example: We are using coffee to write binary data to the flash, most of the time the data is included in some sort of protocol with trailing checksums so we never have zeros at the end of the file.
In one case we are writing a struct with possible zeros in the last bytes. When we read the files we ignore the return value of cfs_read() nearly at all times as we (think we) know how many bytes are in the file because we know how many bytes we've written. We read our data after a restart and now some field is the destination struct (stack variable) have an undefined state because they do not get set by cfs_read().
In this case we would have to do much work because we would have to check the return value at several places.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/frank-freihube-rmcan-com,4,https://github.com/contiki-os/contiki/pull/1636#issuecomment-216132458,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,"Can someone give me a hint why the test fails now?
I made a copy/paste-error in commit 5bd7fc8 but the related test 4038 passed. I fixed the commit with commit 59727ed literally only changing if(fdp->io_flags & 0x2) to if(fdp->io_flags & 0x4) and now test 4039.9 fails. Can someone tell me what 4039.9 is checking?
I found the following FAIL's in the report but I'm not sure what they mean:
Line 430: mv: cannot stat `COOJA.testlog': No such file or directory FAIL
Line 658: 16-sky-ipv6-rpl-collect.1.faillog: FAIL
Line 875: ==> 16-sky-ipv6-rpl-collect.1.faillog <== FAIL
There is also a SimulationCreationException at org.contikios.cooja.Cooja in line 406 ""avax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean""
Might this be the error?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/1636#issuecomment-216192986,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,"The change to use the IO semantics functionality looks good. The Travis error is not related to the changes in this PR, and a separate PR has been made to fix the error. I'll restart this test to see if it goes through now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/frank-freihube-rmcan-com,6,https://github.com/contiki-os/contiki/pull/1636#issuecomment-216202165,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,"Great. It passed now.
Thank you.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1636,2016-04-27T12:59:54Z,2016-05-02T11:52:13Z,2016-05-02T11:52:13Z,MERGED,True,22,2,2,https://github.com/frank-freihube-rmcan-com,Trailing zeros in file leading to unexpected file length get set in destination buffer,3,[],https://github.com/contiki-os/contiki/pull/1636,https://github.com/nvt,7,https://github.com/contiki-os/contiki/pull/1636#issuecomment-216217402,We encountered the problem with trailing zeros in files leading to wrong file size. This fix ensures that all bytes will get set to zero and works fine for us as it ensures that there are no zeros in the buffer on adresses we expected to get set to the content of the file. Also as long as there are enough bytes to read in the file the execution time should't increase at all. In cases that the given size only represents the size of the buffer and there are way less bytes to be read in the file the execution time will slightly increase.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1637,2016-04-27T15:07:46Z,2016-04-27T16:18:47Z,2017-10-27T20:05:54Z,MERGED,True,2,2,1,https://github.com/simonduq,RPL default lifetime,1,[],https://github.com/contiki-os/contiki/pull/1637,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1637,"I'm pretty sure the intended default lifetime was 30 times 60 seconds, not 48 times 96 seconds.","I'm pretty sure the intended default lifetime was 30 times 60 seconds, not 48 times 96 seconds.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1637,2016-04-27T15:07:46Z,2016-04-27T16:18:47Z,2017-10-27T20:05:54Z,MERGED,True,2,2,1,https://github.com/simonduq,RPL default lifetime,1,[],https://github.com/contiki-os/contiki/pull/1637,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1637#issuecomment-215120655,"I'm pretty sure the intended default lifetime was 30 times 60 seconds, not 48 times 96 seconds.",Good catch and you are absolutely correct! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1637,2016-04-27T15:07:46Z,2016-04-27T16:18:47Z,2017-10-27T20:05:54Z,MERGED,True,2,2,1,https://github.com/simonduq,RPL default lifetime,1,[],https://github.com/contiki-os/contiki/pull/1637,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1637#issuecomment-215121138,"I'm pretty sure the intended default lifetime was 30 times 60 seconds, not 48 times 96 seconds.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1638,2016-04-27T15:31:17Z,2016-05-02T08:23:13Z,2016-12-14T09:27:43Z,MERGED,True,488,427,28,https://github.com/joakimeriksson,Fixing Cooja message list to avoid any Swing components when headless,1,[],https://github.com/contiki-os/contiki/pull/1638,https://github.com/joakimeriksson,1,https://github.com/contiki-os/contiki/pull/1638,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1638,2016-04-27T15:31:17Z,2016-05-02T08:23:13Z,2016-12-14T09:27:43Z,MERGED,True,488,427,28,https://github.com/joakimeriksson,Fixing Cooja message list to avoid any Swing components when headless,1,[],https://github.com/contiki-os/contiki/pull/1638,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1638#issuecomment-215137331,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,"Well all I can say is that this is the first PR I see succeeding on the ipv6 test on first try since we switched to single-seed Travis tests.
Re-started the test it to see if we get the same result again :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1638,2016-04-27T15:31:17Z,2016-05-02T08:23:13Z,2016-12-14T09:27:43Z,MERGED,True,488,427,28,https://github.com/joakimeriksson,Fixing Cooja message list to avoid any Swing components when headless,1,[],https://github.com/contiki-os/contiki/pull/1638,https://github.com/joakimeriksson,3,https://github.com/contiki-os/contiki/pull/1638#issuecomment-215139493,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,Sounds good! I think Cooja in general needs to be more headless when it is run in headless. It is quite a risk to create lots of Swing / AWT components when not having a GUI.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1638,2016-04-27T15:31:17Z,2016-05-02T08:23:13Z,2016-12-14T09:27:43Z,MERGED,True,488,427,28,https://github.com/joakimeriksson,Fixing Cooja message list to avoid any Swing components when headless,1,[],https://github.com/contiki-os/contiki/pull/1638,https://github.com/pablocorbalan,4,https://github.com/contiki-os/contiki/pull/1638#issuecomment-215143207,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,This PR includes in the first commit your previous PR 1633. It would be good if you can remove the first commit from this PR.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1638,2016-04-27T15:31:17Z,2016-05-02T08:23:13Z,2016-12-14T09:27:43Z,MERGED,True,488,427,28,https://github.com/joakimeriksson,Fixing Cooja message list to avoid any Swing components when headless,1,[],https://github.com/contiki-os/contiki/pull/1638,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1638#issuecomment-215163059,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,@pablocorbalan good catch - my bad - fixed now!,True,{'THUMBS_UP': ['https://github.com/pablocorbalan']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1638,2016-04-27T15:31:17Z,2016-05-02T08:23:13Z,2016-12-14T09:27:43Z,MERGED,True,488,427,28,https://github.com/joakimeriksson,Fixing Cooja message list to avoid any Swing components when headless,1,[],https://github.com/contiki-os/contiki/pull/1638,https://github.com/fros4943,6,https://github.com/contiki-os/contiki/pull/1638#issuecomment-216136068,This fix make Cooja not use the MessageList class that do have a lot of Swing components that now and then cause sporadic exceptions when running in headless mode. This introduce a text-based version that just prints the messages on standard out - the Text based MessageList is used whenever Cooja is run in headless mode.,"Look great @joakimeriksson!
üëç Merging",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1639,2016-04-27T18:42:12Z,2016-04-28T16:12:34Z,2016-04-28T16:24:57Z,MERGED,True,9,5,1,https://github.com/yatch,Handle the case when log->link is NULL in tsch_log_process_pending,1,[],https://github.com/contiki-os/contiki/pull/1639,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1639,"This PR prevents possible NULL pointer access for log->link in tsch_log_process_pending().
log->link would have NULL if current_link is NULL when tsch_log_prepare_add() is called. This could happen in tsch_slot_operation Protothread. Here is the relevant code block, where the TSCH_LOG_ADD macro expands with tsch_log_prepare_add() when TSCH_LOG_LEVEL is greater than or equal to 2.
if(current_link == NULL || tsch_lock_requested) { /* Skip slot operation if there is no link
                                                      or if there is a pending request for getting the lock */
  /* Issue a log whenever skipping a slot */
  TSCH_LOG_ADD(tsch_log_message,
                  snprintf(log->message, sizeof(log->message),
                      ""!skipped slot %u %u %u"",
                        tsch_locked,
                        tsch_lock_requested,
                        current_link == NULL);
  );","This PR prevents possible NULL pointer access for log->link in tsch_log_process_pending().
log->link would have NULL if current_link is NULL when tsch_log_prepare_add() is called. This could happen in tsch_slot_operation Protothread. Here is the relevant code block, where the TSCH_LOG_ADD macro expands with tsch_log_prepare_add() when TSCH_LOG_LEVEL is greater than or equal to 2.
if(current_link == NULL || tsch_lock_requested) { /* Skip slot operation if there is no link
                                                      or if there is a pending request for getting the lock */
  /* Issue a log whenever skipping a slot */
  TSCH_LOG_ADD(tsch_log_message,
                  snprintf(log->message, sizeof(log->message),
                      ""!skipped slot %u %u %u"",
                        tsch_locked,
                        tsch_lock_requested,
                        current_link == NULL);
  );",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1639,2016-04-27T18:42:12Z,2016-04-28T16:12:34Z,2016-04-28T16:24:57Z,MERGED,True,9,5,1,https://github.com/yatch,Handle the case when log->link is NULL in tsch_log_process_pending,1,[],https://github.com/contiki-os/contiki/pull/1639,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1639#issuecomment-215224640,"This PR prevents possible NULL pointer access for log->link in tsch_log_process_pending().
log->link would have NULL if current_link is NULL when tsch_log_prepare_add() is called. This could happen in tsch_slot_operation Protothread. Here is the relevant code block, where the TSCH_LOG_ADD macro expands with tsch_log_prepare_add() when TSCH_LOG_LEVEL is greater than or equal to 2.
if(current_link == NULL || tsch_lock_requested) { /* Skip slot operation if there is no link
                                                      or if there is a pending request for getting the lock */
  /* Issue a log whenever skipping a slot */
  TSCH_LOG_ADD(tsch_log_message,
                  snprintf(log->message, sizeof(log->message),
                      ""!skipped slot %u %u %u"",
                        tsch_locked,
                        tsch_lock_requested,
                        current_link == NULL);
  );",Great catch! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1640,2016-04-28T15:15:20Z,,2016-06-09T14:11:46Z,OPEN,False,1002,16,28,https://github.com/aguedes,New platform: Intel Quark D2000 Devboard,11,"['nominated', 'x86']",https://github.com/contiki-os/contiki/pull/1640,https://github.com/aguedes,1,https://github.com/contiki-os/contiki/pull/1640,"Hi Folks,
This PR adds support for Intel Quark D2000 Devboard! This board is based on the Intel Quark D2000 SoC and consists of a small form-factor board that includes flash storage, a 6-axis compass/accelerometer, and a temperature sensor. It is shield-compatible with Arduino* Uno and booster-pack. For further information about this board please check [1].
The port relies on the Intel Quark Microcontroller Software Interface (QMSI) [2], which is a hardware abstraction layer for Intel Quark Microcontroller products. QMSI BSP provides several components that are reused by this port such as the bootstrap code, linker script, interrupt system, and device drivers. QMSI BSP is an open source project licensed under the BSD 3-clause license.
In  this initial version, the port supports Contiki‚Äôs clock module, timers (including rtimer) and watchdog, as well as C library APIs such as printf and malloc (and their friends). Contiki applications can access all I/O peripherals available in Intel Quark D2000 SoC (e.g., i2c, spi, pwm, and gpio), through QMSI APIs. BSP-related files are located in platform/quark-d2000-devboard/bsp/ directory. We provide shell scripts that downloads and build the BSP components.
In platform/quark-d2000-devboard/README.md you can find detailed information about this port and instructions on how to build, flash and debug applications.
Regards,
Andre
[1] http://www.intel.com/content/www/us/en/embedded/products/quark/mcu/d2000/overview.html
[2] https://github.com/01org/qmsi","Hi Folks,
This PR adds support for Intel Quark D2000 Devboard! This board is based on the Intel Quark D2000 SoC and consists of a small form-factor board that includes flash storage, a 6-axis compass/accelerometer, and a temperature sensor. It is shield-compatible with Arduino* Uno and booster-pack. For further information about this board please check [1].
The port relies on the Intel Quark Microcontroller Software Interface (QMSI) [2], which is a hardware abstraction layer for Intel Quark Microcontroller products. QMSI BSP provides several components that are reused by this port such as the bootstrap code, linker script, interrupt system, and device drivers. QMSI BSP is an open source project licensed under the BSD 3-clause license.
In  this initial version, the port supports Contiki‚Äôs clock module, timers (including rtimer) and watchdog, as well as C library APIs such as printf and malloc (and their friends). Contiki applications can access all I/O peripherals available in Intel Quark D2000 SoC (e.g., i2c, spi, pwm, and gpio), through QMSI APIs. BSP-related files are located in platform/quark-d2000-devboard/bsp/ directory. We provide shell scripts that downloads and build the BSP components.
In platform/quark-d2000-devboard/README.md you can find detailed information about this port and instructions on how to build, flash and debug applications.
Regards,
Andre
[1] http://www.intel.com/content/www/us/en/embedded/products/quark/mcu/d2000/overview.html
[2] https://github.com/01org/qmsi",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1640,2016-04-28T15:15:20Z,,2016-06-09T14:11:46Z,OPEN,False,1002,16,28,https://github.com/aguedes,New platform: Intel Quark D2000 Devboard,11,"['nominated', 'x86']",https://github.com/contiki-os/contiki/pull/1640,https://github.com/jeez,2,https://github.com/contiki-os/contiki/pull/1640#issuecomment-216234155,"Hi Folks,
This PR adds support for Intel Quark D2000 Devboard! This board is based on the Intel Quark D2000 SoC and consists of a small form-factor board that includes flash storage, a 6-axis compass/accelerometer, and a temperature sensor. It is shield-compatible with Arduino* Uno and booster-pack. For further information about this board please check [1].
The port relies on the Intel Quark Microcontroller Software Interface (QMSI) [2], which is a hardware abstraction layer for Intel Quark Microcontroller products. QMSI BSP provides several components that are reused by this port such as the bootstrap code, linker script, interrupt system, and device drivers. QMSI BSP is an open source project licensed under the BSD 3-clause license.
In  this initial version, the port supports Contiki‚Äôs clock module, timers (including rtimer) and watchdog, as well as C library APIs such as printf and malloc (and their friends). Contiki applications can access all I/O peripherals available in Intel Quark D2000 SoC (e.g., i2c, spi, pwm, and gpio), through QMSI APIs. BSP-related files are located in platform/quark-d2000-devboard/bsp/ directory. We provide shell scripts that downloads and build the BSP components.
In platform/quark-d2000-devboard/README.md you can find detailed information about this port and instructions on how to build, flash and debug applications.
Regards,
Andre
[1] http://www.intel.com/content/www/us/en/embedded/products/quark/mcu/d2000/overview.html
[2] https://github.com/01org/qmsi",@aguedes can you please mark this PR with the x86 label that was recently added ?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1640,2016-04-28T15:15:20Z,,2016-06-09T14:11:46Z,OPEN,False,1002,16,28,https://github.com/aguedes,New platform: Intel Quark D2000 Devboard,11,"['nominated', 'x86']",https://github.com/contiki-os/contiki/pull/1640,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1640#issuecomment-224615518,"Hi Folks,
This PR adds support for Intel Quark D2000 Devboard! This board is based on the Intel Quark D2000 SoC and consists of a small form-factor board that includes flash storage, a 6-axis compass/accelerometer, and a temperature sensor. It is shield-compatible with Arduino* Uno and booster-pack. For further information about this board please check [1].
The port relies on the Intel Quark Microcontroller Software Interface (QMSI) [2], which is a hardware abstraction layer for Intel Quark Microcontroller products. QMSI BSP provides several components that are reused by this port such as the bootstrap code, linker script, interrupt system, and device drivers. QMSI BSP is an open source project licensed under the BSD 3-clause license.
In  this initial version, the port supports Contiki‚Äôs clock module, timers (including rtimer) and watchdog, as well as C library APIs such as printf and malloc (and their friends). Contiki applications can access all I/O peripherals available in Intel Quark D2000 SoC (e.g., i2c, spi, pwm, and gpio), through QMSI APIs. BSP-related files are located in platform/quark-d2000-devboard/bsp/ directory. We provide shell scripts that downloads and build the BSP components.
In platform/quark-d2000-devboard/README.md you can find detailed information about this port and instructions on how to build, flash and debug applications.
Regards,
Andre
[1] http://www.intel.com/content/www/us/en/embedded/products/quark/mcu/d2000/overview.html
[2] https://github.com/01org/qmsi",@aguedes Could you please rebase this PR?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1640,2016-04-28T15:15:20Z,,2016-06-09T14:11:46Z,OPEN,False,1002,16,28,https://github.com/aguedes,New platform: Intel Quark D2000 Devboard,11,"['nominated', 'x86']",https://github.com/contiki-os/contiki/pull/1640,https://github.com/aguedes,4,https://github.com/contiki-os/contiki/pull/1640#issuecomment-224752826,"Hi Folks,
This PR adds support for Intel Quark D2000 Devboard! This board is based on the Intel Quark D2000 SoC and consists of a small form-factor board that includes flash storage, a 6-axis compass/accelerometer, and a temperature sensor. It is shield-compatible with Arduino* Uno and booster-pack. For further information about this board please check [1].
The port relies on the Intel Quark Microcontroller Software Interface (QMSI) [2], which is a hardware abstraction layer for Intel Quark Microcontroller products. QMSI BSP provides several components that are reused by this port such as the bootstrap code, linker script, interrupt system, and device drivers. QMSI BSP is an open source project licensed under the BSD 3-clause license.
In  this initial version, the port supports Contiki‚Äôs clock module, timers (including rtimer) and watchdog, as well as C library APIs such as printf and malloc (and their friends). Contiki applications can access all I/O peripherals available in Intel Quark D2000 SoC (e.g., i2c, spi, pwm, and gpio), through QMSI APIs. BSP-related files are located in platform/quark-d2000-devboard/bsp/ directory. We provide shell scripts that downloads and build the BSP components.
In platform/quark-d2000-devboard/README.md you can find detailed information about this port and instructions on how to build, flash and debug applications.
Regards,
Andre
[1] http://www.intel.com/content/www/us/en/embedded/products/quark/mcu/d2000/overview.html
[2] https://github.com/01org/qmsi","Hi @nvt! Yes, sure. Just pushed a rebased version.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1642,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.","Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/mdlemay,2,https://github.com/contiki-os/contiki/pull/1642#issuecomment-216249506,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.",@alignan or @nvt: Can you please apply the x86 label to this and #1433?  I don't appear to have permission to do that myself.  Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1642#issuecomment-224236387,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.",Ready to merge?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/mdlemay,4,https://github.com/contiki-os/contiki/pull/1642#issuecomment-224295419,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.","Sorry, not yet.  Recent developments in the related LLVM patches necessitated changes to this patch, and I'm waiting for approval for those new LLVM patches.  Should I close this PR for now, or leave it open and post here again after the LLVM patches have been merged?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1642#issuecomment-224295724,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.","Up to you, just ping me and I will try to merge asap üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/mdlemay,6,https://github.com/contiki-os/contiki/pull/1642#issuecomment-224319705,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.","Thanks, @alignan, much appreciated!  I think I'll leave it open for now, since I'm hopeful that I can get the LLVM patches merged soon.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1642,2016-04-30T21:12:15Z,,2016-10-25T18:51:23Z,OPEN,False,377,16,17,https://github.com/mdlemay,X86 support for SafeStack,3,['x86'],https://github.com/contiki-os/contiki/pull/1642,https://github.com/mdlemay,7,https://github.com/contiki-os/contiki/pull/1642#issuecomment-253948293,"Depends on #1433.
Adds support for the LLVM SafeStack pass.  The purpose of the SafeStack pass is to define an unsafe stack that is separate from the main stack so that just variables that are accessed safely are placed on the main stack with return addresses.  This helps to block corruption of return addresses, e.g. as occurs during Return-Oriented Programming (ROP) exploits.  Support for using this in single-threaded mode with Contiki is in a set of LLVM patches that are under review.
However, it is still possible for a stray write to affect the main stack, since it is accessible through the DS and ES segments.  I have another PR ready to submit that adds support for separating the stack and data segments from each other.  It depends on a second set of LLVM patches that are still under review.  I plan to submit that PR if and when the necessary LLVM patches are accepted.
More information on the SafeStack pass is available here: http://clang.llvm.org/docs/SafeStack.html
This PR also adds support for musl libc, since it can be built with LLVM Clang.","@alignan: The compiler patches that this PR depends on just landed in LLVM and Clang, so you can merge this now.  Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,1,https://github.com/contiki-os/contiki/pull/1643,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1643#issuecomment-216341738,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"Hi! cool example!
I would suggest moving to examples/cc2538-common, as this would be also applicable for other cc2538-based platforms.
I like the use-case approach, but in overall I think you should change the text strings to display something more generic (i.e replace tank level with something as user number %u).  This was used for a specific sensor?
Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,3,https://github.com/contiki-os/contiki/pull/1643#issuecomment-216430314,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"Thank you sir for the comments,
I will change the code and change the folder and upload again",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,4,https://github.com/contiki-os/contiki/pull/1643#issuecomment-217617415,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"@alignan
changes have been done, Please look into it",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/greg-king5,5,https://github.com/contiki-os/contiki/pull/1643#issuecomment-217641525,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"I think that the code has a problem with syncronization.  Let's suppose that the process has reached the PROCESS_YIELD(); line.  And, suppose that there is no input event for seven seconds.  The etimer will send its event; the process will continue.  It will see that the event isn't an input message, loop around, and stop at the PROCESS_WAIT_EVENT_UNTIL(); line.  But, the etimer already sent its event.  Therefore, the process will stall until there finally is an input message.  Then, the expired etimer will be processed; and, the code will stop at PROCESS_YIELD();.  But, the input event will be lost!
The simplest fix is to use PROCESS_WAIT_UNTIL(etimer_expired(&et)).  It tests the etimer before it yields; and, it will continue running the process if the timer already has finished.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,6,https://github.com/contiki-os/contiki/pull/1643#issuecomment-218072676,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,thanks for the comments. I will look into it and get back,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,7,https://github.com/contiki-os/contiki/pull/1643#issuecomment-219702288,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"@alignan @greg-king5

serial_line_init() was default being called by cc2538 so i was doing implicitly now i removed that line and still the code works fine.
PROCESS_WAIT_UNTIL(etimer_expired(&et)) has been added
and the array size can be changed dynamically",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,8,https://github.com/contiki-os/contiki/pull/1643#issuecomment-224223241,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,I was facing some problem with travis finally was able to upload the code. i have changed the code now please look at it,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1643#issuecomment-224231461,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"You need to add the test to the Makefile as well, or was this the problem with Travis? If so perhaps it would be better just to mve into its own test-uart folder.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,10,https://github.com/contiki-os/contiki/pull/1643#issuecomment-225518073,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"@alignan
I have uploaded the code again,please look into it",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/greg-king5,11,https://github.com/contiki-os/contiki/pull/1643#issuecomment-226908907,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"As Antonio said earlier, you should put this program's name into the Makefile that is in its directory:
CONTIKI_PROJECT = test-pwm test-uart timer-test
(And, add that Makefile to this Pull Request.)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,12,https://github.com/contiki-os/contiki/pull/1643#issuecomment-228950972,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"@alignan
I have uploaded the code with changes in code ,please look into it",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/alignan,13,https://github.com/contiki-os/contiki/pull/1643#issuecomment-229780771,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"Hi! thanks for updating, but I would like this example to be compiled as well in the regression tests, that's why I would prefer to have the test included in the Makefile.  If you encounter an issue or a failure, then we can test further.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,14,https://github.com/contiki-os/contiki/pull/1643#issuecomment-263237574,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,@alignan Sorry for the delay i have uploaded the code again,True,{'LAUGH': ['https://github.com/akshaypm']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/alignan,15,https://github.com/contiki-os/contiki/pull/1643#issuecomment-263904607,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"Thanks! checked and working OK, just one last thing: please refactor the commit message (avoid all upper-case capitalisation).
üëç  once the message is fixed",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,16,https://github.com/contiki-os/contiki/pull/1643#issuecomment-264095890,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,"Yeah will do that thanks for your comments
‚Ä¶
On Wed, Nov 30, 2016 at 9:06 PM, Antonio Lignan ***@***.***> wrote:
 Thanks! checked and working OK, just one last thing: please refactor the
 commit message (avoid all upper-case capitalisation)

 ‚Äî
 You are receiving this because you authored the thread.
 Reply to this email directly, view it on GitHub
 <#1643 (comment)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/AOc5_wUDcGvKMLqPE7FwmukU32ptn3c0ks5rDZfxgaJpZM4IVRmW>
 .


-- 
AKSHAY.P.M
PROJECT ASSISTANT
ECE DEPT, NETWORKS LAB
INDIAN INSTITUTE OF SCIENCE
BANGALORE-560012
Ph- +91 8892681034
e-mail:akshaypm90@gmail.com",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1643,2016-05-02T11:12:00Z,2016-12-01T10:42:44Z,2016-12-01T10:42:44Z,MERGED,True,111,1,2,https://github.com/akshaypm,Zoul UART example,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1643,https://github.com/akshaypm,17,https://github.com/contiki-os/contiki/pull/1643#issuecomment-264109806,A quick program for testing the UART1 on the RE-mote (Zoul) platform which can be used to interface with sensor having UART interface.,@alignan i made the changes and uploaded again,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/jdede,1,https://github.com/contiki-os/contiki/pull/1644,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.","The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1644#issuecomment-216344980,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.",Does this works also for versions lower than 3.0?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/jdede,3,https://github.com/contiki-os/contiki/pull/1644#issuecomment-216349300,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.","Yes. This is exactly the way how the baudrate is set in the corresponding examples in pyserial even in version 2.7 and earlier.
I tested the code on my old computer with pyserial 2.6 and with one sky and one Z1 node: Works perfectly",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/jdede,4,https://github.com/contiki-os/contiki/pull/1644#issuecomment-216998682,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.",Can anyone restart the Travis CI build to get rid of the red icon? ;-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1644#issuecomment-217008463,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.",Done! the failure is not-related :-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/jdede,6,https://github.com/contiki-os/contiki/pull/1644#issuecomment-217094446,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.","Thanks, I know. But it is ugly anyway- ;-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1644#issuecomment-219222793,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.",Where are we with this one? This seems a bit of a no-brainer?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1644,2016-05-02T16:54:35Z,2016-05-14T14:27:59Z,2016-05-14T14:27:59Z,MERGED,True,6,3,3,https://github.com/jdede,Do not use setBaudrate,1,[],https://github.com/contiki-os/contiki/pull/1644,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1644#issuecomment-219223192,"The the author of the library pyserial removed the command setBaudrate() starting from version 3.0. This PR solves problems caused by that in the bsl by setting the baudrate directly.
pyserial 3.0 is just upcoming for example in Debian stretch.","Forgot about this one, we were waiting for Travis go to apple-happy.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1645,2016-05-02T17:03:15Z,2016-05-04T12:39:29Z,2016-05-04T12:39:29Z,MERGED,True,1,1,1,https://github.com/jdede,Fix broken include,1,[],https://github.com/contiki-os/contiki/pull/1645,https://github.com/jdede,1,https://github.com/contiki-os/contiki/pull/1645,"In case of using IPv4,  contiki-z1-main.c uses a wrong include.","In case of using IPv4,  contiki-z1-main.c uses a wrong include.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1645,2016-05-02T17:03:15Z,2016-05-04T12:39:29Z,2016-05-04T12:39:29Z,MERGED,True,1,1,1,https://github.com/jdede,Fix broken include,1,[],https://github.com/contiki-os/contiki/pull/1645,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1645#issuecomment-216343039,"In case of using IPv4,  contiki-z1-main.c uses a wrong include.","I just restarted the job, let's wait for Travis... good catch üòÑ
Are you actively testing IPv4?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1645,2016-05-02T17:03:15Z,2016-05-04T12:39:29Z,2016-05-04T12:39:29Z,MERGED,True,1,1,1,https://github.com/jdede,Fix broken include,1,[],https://github.com/contiki-os/contiki/pull/1645,https://github.com/jdede,3,https://github.com/contiki-os/contiki/pull/1645#issuecomment-216351991,"In case of using IPv4,  contiki-z1-main.c uses a wrong include.",Not really. Finding it was just a coincidence caused by a copy an paste error for a quick test from my side... ;-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1645,2016-05-02T17:03:15Z,2016-05-04T12:39:29Z,2016-05-04T12:39:29Z,MERGED,True,1,1,1,https://github.com/jdede,Fix broken include,1,[],https://github.com/contiki-os/contiki/pull/1645,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1645#issuecomment-216850097,"In case of using IPv4,  contiki-z1-main.c uses a wrong include.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/jdede,1,https://github.com/contiki-os/contiki/pull/1646,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'","In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1646#issuecomment-216345778,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/jdede,3,https://github.com/contiki-os/contiki/pull/1646#issuecomment-216355930,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'","When going through the code once again, I figured out that the #if makes more sense than an #ifdef. So it works properly even in case of #define NETSTACK_CONF_WITH_IPV4 0.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/greg-king5,4,https://github.com/contiki-os/contiki/pull/1646#issuecomment-216682182,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'","<stdio.h> doesn't need to be included when that function is ""hidden"" (it will give slightly faster building).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/jdede,5,https://github.com/contiki-os/contiki/pull/1646#issuecomment-216805690,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'","Of course, I can do so. ;-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1646#issuecomment-216850956,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1646,2016-05-02T17:16:16Z,2016-05-04T12:41:18Z,2016-05-05T04:22:00Z,MERGED,True,6,2,2,https://github.com/jdede,Fix putchar include when using IPv4,3,[],https://github.com/contiki-os/contiki/pull/1646,https://github.com/greg-king5,7,https://github.com/contiki-os/contiki/pull/1646#issuecomment-217073973,"In case of using IPv4, putchar() is provided by the SLIP device. The missing #ifndef result into an error: multiple definition of 'putchar'","Removing it isn't quite what I meant.
Including <stdio.h> is a double-check that the function definition's prototype is correct.  That check isn't needed when the definition isn't compiled.  Therefore, that #include should have been moved down to a line just below the #if line.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1647,2016-05-02T19:57:45Z,2016-05-03T08:28:59Z,2016-05-03T09:34:39Z,MERGED,True,28,28,14,https://github.com/yatch,Resolve script errors raised during the RPL regression tests on Ubuntu 14.04,1,[],https://github.com/contiki-os/contiki/pull/1647,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1647,"This PR resolves the script errors which prevent you from performing regression tests for RPL on Ubuntu 14.04, which Instant Contiki 3.0 is based on.
The script errors look like this:
...
FATAL [Thread-7] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-7] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92)
...
 FAIL ‡≤†_‡≤†
In this case, the error occurs on evaluating packets.substr(0, num) at the following statement.
packets = packets.substr(0, num) + ""*"";
At this point, packets on the right side is supposed to be ""*"", a String object. Howerver, it is, in fact, a ConsString object which does not have the substr function. packets.substr(0, num) + ""*"" does not produce a String object in the first iteration under the Java environment by openjdk-7-jdk on Ubuntu 14.04.
One of solutions to overcome this error is using the concat function instead of the + operator. This is the key idea of this patch.
packets = packets.substr(0, num).concat(""*"");
With the tip of the master branch, regression-tests/12-rpl/summary would have these results in it after the regression tests.
07-rpl-random-rearrangement.testlog:TEST OK
01-rpl-up-route.1.faillog: FAIL ‡≤†_‡≤†
02-rpl-root-reboot.1.faillog: FAIL ‡≤†_‡≤†
03-rpl-28-hours.1.faillog: FAIL ‡≤†_‡≤†
04-rpl-large-network.1.faillog: FAIL ‡≤†_‡≤†
05-rpl-up-and-down-routes.1.faillog: FAIL ‡≤†_‡≤†
06-rpl-temporary-root-loss.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-0.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-1.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-2.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-3.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-4.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-5.1.faillog: FAIL ‡≤†_‡≤†
09-rpl-probing.1.faillog: FAIL ‡≤†_‡≤†
10-rpl-multi-dodag.1.faillog: FAIL ‡≤†_‡≤†

Applying the patch, all the tests under regression-tests/12-rpl succeed:
01-rpl-up-route.testlog:TEST OK
02-rpl-root-reboot.testlog:TEST OK
03-rpl-28-hours.testlog:TEST OK
04-rpl-large-network.testlog:TEST OK
05-rpl-up-and-down-routes.testlog:TEST OK
06-rpl-temporary-root-loss.testlog:TEST OK
07-rpl-random-rearrangement.testlog:TEST OK
08-rpl-dao-route-loss-0.testlog:TEST OK
08-rpl-dao-route-loss-1.testlog:TEST OK
08-rpl-dao-route-loss-2.testlog:TEST OK
08-rpl-dao-route-loss-3.testlog:TEST OK
08-rpl-dao-route-loss-4.testlog:TEST OK
08-rpl-dao-route-loss-5.testlog:TEST OK
09-rpl-probing.testlog:TEST OK
10-rpl-multi-dodag.testlog:TEST OK

From here, I'd like to provide some background information.
First of all, on Ubuntu 12.04, this error does not occur. packets.substr(0, num) + ""*"" returns a String object. This is why this type of error is not found on Travis CI tests which uses Ubuntu 12.04.
I noticed a difference between Ubuntu 12.04 and 14.04; this is the version of Rhino that is installed with openjdk-7-jdk: 1.7R3 on Ubuntu 12.04 and 1.7R4 on Ubuntu 14.04. Here is the environmental information of my Ubuntu 12.04 machine and 14.04 machine (Instant Contiki 3.0 without apt-get upgrade):
# lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 12.04.5 LTS
Release:        12.04
Codename:       precise
# java -version
java version ""1.7.0_95""
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.12.04.2)
OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16

user@instant-contiki:~/contiki$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty
user@instant-contiki:~/contiki$ java -version
java version ""1.7.0_79""
OpenJDK Runtime Environment (IcedTea 2.5.6) (7u79-2.5.6-0ubuntu1.14.04.1)
OpenJDK Client VM (build 24.79-b02, mixed mode, sharing)
user@instant-contiki:~/contiki$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
According to the release note of Rhino 17R4, there is some improvement on string concatenation. It says:

Make string concatenation with + fast.

It seems like the following feature found in the ConsString document  has been introduced since Rhino 1.7R4.

This string representation is optimized for concatenation using the ""+"" operator. Instead of
immediately copying both components to a new character array, ConsString keeps references to
the original components and only converts them to a String if either toString() is called or a certain
depth level is reached.

The conclusion is that this improvement on the + operator causes the errors raised in the regression tests on Ubuntu 14.04 (Rhino 1.7R4).
Lastly, I'll share a proof-of-concept.
We can get the same error as mentioned above by jrunscript (Rhino 1.7R4/Ubuntu 14.04). In the last part of this example, you can see the concat function works as expected.
$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
$ jrunscript   
js> var packets = ""_________"";
js> packets = packets.substr(0, 0) + ""*"";
*
js> packets = packets.substr(0, 1) + ""*"";
script error: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<STDIN>#1) in <STDIN> at line number 1
js> packets.getClass()
class sun.org.mozilla.javascript.ConsString
js>
$ jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");    
**
This example shows the concat method works on Rhino 1.7R3 (Ubuntu 12.04) in the same way as shown above with Rhino 1.7R4.
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16
# jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");
**","This PR resolves the script errors which prevent you from performing regression tests for RPL on Ubuntu 14.04, which Instant Contiki 3.0 is based on.
The script errors look like this:
...
FATAL [Thread-7] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-7] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92)
...
 FAIL ‡≤†_‡≤†
In this case, the error occurs on evaluating packets.substr(0, num) at the following statement.
packets = packets.substr(0, num) + ""*"";
At this point, packets on the right side is supposed to be ""*"", a String object. Howerver, it is, in fact, a ConsString object which does not have the substr function. packets.substr(0, num) + ""*"" does not produce a String object in the first iteration under the Java environment by openjdk-7-jdk on Ubuntu 14.04.
One of solutions to overcome this error is using the concat function instead of the + operator. This is the key idea of this patch.
packets = packets.substr(0, num).concat(""*"");
With the tip of the master branch, regression-tests/12-rpl/summary would have these results in it after the regression tests.
07-rpl-random-rearrangement.testlog:TEST OK
01-rpl-up-route.1.faillog: FAIL ‡≤†_‡≤†
02-rpl-root-reboot.1.faillog: FAIL ‡≤†_‡≤†
03-rpl-28-hours.1.faillog: FAIL ‡≤†_‡≤†
04-rpl-large-network.1.faillog: FAIL ‡≤†_‡≤†
05-rpl-up-and-down-routes.1.faillog: FAIL ‡≤†_‡≤†
06-rpl-temporary-root-loss.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-0.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-1.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-2.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-3.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-4.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-5.1.faillog: FAIL ‡≤†_‡≤†
09-rpl-probing.1.faillog: FAIL ‡≤†_‡≤†
10-rpl-multi-dodag.1.faillog: FAIL ‡≤†_‡≤†

Applying the patch, all the tests under regression-tests/12-rpl succeed:
01-rpl-up-route.testlog:TEST OK
02-rpl-root-reboot.testlog:TEST OK
03-rpl-28-hours.testlog:TEST OK
04-rpl-large-network.testlog:TEST OK
05-rpl-up-and-down-routes.testlog:TEST OK
06-rpl-temporary-root-loss.testlog:TEST OK
07-rpl-random-rearrangement.testlog:TEST OK
08-rpl-dao-route-loss-0.testlog:TEST OK
08-rpl-dao-route-loss-1.testlog:TEST OK
08-rpl-dao-route-loss-2.testlog:TEST OK
08-rpl-dao-route-loss-3.testlog:TEST OK
08-rpl-dao-route-loss-4.testlog:TEST OK
08-rpl-dao-route-loss-5.testlog:TEST OK
09-rpl-probing.testlog:TEST OK
10-rpl-multi-dodag.testlog:TEST OK

From here, I'd like to provide some background information.
First of all, on Ubuntu 12.04, this error does not occur. packets.substr(0, num) + ""*"" returns a String object. This is why this type of error is not found on Travis CI tests which uses Ubuntu 12.04.
I noticed a difference between Ubuntu 12.04 and 14.04; this is the version of Rhino that is installed with openjdk-7-jdk: 1.7R3 on Ubuntu 12.04 and 1.7R4 on Ubuntu 14.04. Here is the environmental information of my Ubuntu 12.04 machine and 14.04 machine (Instant Contiki 3.0 without apt-get upgrade):
# lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 12.04.5 LTS
Release:        12.04
Codename:       precise
# java -version
java version ""1.7.0_95""
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.12.04.2)
OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16

user@instant-contiki:~/contiki$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty
user@instant-contiki:~/contiki$ java -version
java version ""1.7.0_79""
OpenJDK Runtime Environment (IcedTea 2.5.6) (7u79-2.5.6-0ubuntu1.14.04.1)
OpenJDK Client VM (build 24.79-b02, mixed mode, sharing)
user@instant-contiki:~/contiki$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
According to the release note of Rhino 17R4, there is some improvement on string concatenation. It says:

Make string concatenation with + fast.

It seems like the following feature found in the ConsString document  has been introduced since Rhino 1.7R4.

This string representation is optimized for concatenation using the ""+"" operator. Instead of
immediately copying both components to a new character array, ConsString keeps references to
the original components and only converts them to a String if either toString() is called or a certain
depth level is reached.

The conclusion is that this improvement on the + operator causes the errors raised in the regression tests on Ubuntu 14.04 (Rhino 1.7R4).
Lastly, I'll share a proof-of-concept.
We can get the same error as mentioned above by jrunscript (Rhino 1.7R4/Ubuntu 14.04). In the last part of this example, you can see the concat function works as expected.
$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
$ jrunscript   
js> var packets = ""_________"";
js> packets = packets.substr(0, 0) + ""*"";
*
js> packets = packets.substr(0, 1) + ""*"";
script error: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<STDIN>#1) in <STDIN> at line number 1
js> packets.getClass()
class sun.org.mozilla.javascript.ConsString
js>
$ jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");    
**
This example shows the concat method works on Rhino 1.7R3 (Ubuntu 12.04) in the same way as shown above with Rhino 1.7R4.
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16
# jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");
**",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1647,2016-05-02T19:57:45Z,2016-05-03T08:28:59Z,2016-05-03T09:34:39Z,MERGED,True,28,28,14,https://github.com/yatch,Resolve script errors raised during the RPL regression tests on Ubuntu 14.04,1,[],https://github.com/contiki-os/contiki/pull/1647,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1647#issuecomment-216465357,"This PR resolves the script errors which prevent you from performing regression tests for RPL on Ubuntu 14.04, which Instant Contiki 3.0 is based on.
The script errors look like this:
...
FATAL [Thread-7] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-7] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92)
...
 FAIL ‡≤†_‡≤†
In this case, the error occurs on evaluating packets.substr(0, num) at the following statement.
packets = packets.substr(0, num) + ""*"";
At this point, packets on the right side is supposed to be ""*"", a String object. Howerver, it is, in fact, a ConsString object which does not have the substr function. packets.substr(0, num) + ""*"" does not produce a String object in the first iteration under the Java environment by openjdk-7-jdk on Ubuntu 14.04.
One of solutions to overcome this error is using the concat function instead of the + operator. This is the key idea of this patch.
packets = packets.substr(0, num).concat(""*"");
With the tip of the master branch, regression-tests/12-rpl/summary would have these results in it after the regression tests.
07-rpl-random-rearrangement.testlog:TEST OK
01-rpl-up-route.1.faillog: FAIL ‡≤†_‡≤†
02-rpl-root-reboot.1.faillog: FAIL ‡≤†_‡≤†
03-rpl-28-hours.1.faillog: FAIL ‡≤†_‡≤†
04-rpl-large-network.1.faillog: FAIL ‡≤†_‡≤†
05-rpl-up-and-down-routes.1.faillog: FAIL ‡≤†_‡≤†
06-rpl-temporary-root-loss.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-0.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-1.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-2.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-3.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-4.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-5.1.faillog: FAIL ‡≤†_‡≤†
09-rpl-probing.1.faillog: FAIL ‡≤†_‡≤†
10-rpl-multi-dodag.1.faillog: FAIL ‡≤†_‡≤†

Applying the patch, all the tests under regression-tests/12-rpl succeed:
01-rpl-up-route.testlog:TEST OK
02-rpl-root-reboot.testlog:TEST OK
03-rpl-28-hours.testlog:TEST OK
04-rpl-large-network.testlog:TEST OK
05-rpl-up-and-down-routes.testlog:TEST OK
06-rpl-temporary-root-loss.testlog:TEST OK
07-rpl-random-rearrangement.testlog:TEST OK
08-rpl-dao-route-loss-0.testlog:TEST OK
08-rpl-dao-route-loss-1.testlog:TEST OK
08-rpl-dao-route-loss-2.testlog:TEST OK
08-rpl-dao-route-loss-3.testlog:TEST OK
08-rpl-dao-route-loss-4.testlog:TEST OK
08-rpl-dao-route-loss-5.testlog:TEST OK
09-rpl-probing.testlog:TEST OK
10-rpl-multi-dodag.testlog:TEST OK

From here, I'd like to provide some background information.
First of all, on Ubuntu 12.04, this error does not occur. packets.substr(0, num) + ""*"" returns a String object. This is why this type of error is not found on Travis CI tests which uses Ubuntu 12.04.
I noticed a difference between Ubuntu 12.04 and 14.04; this is the version of Rhino that is installed with openjdk-7-jdk: 1.7R3 on Ubuntu 12.04 and 1.7R4 on Ubuntu 14.04. Here is the environmental information of my Ubuntu 12.04 machine and 14.04 machine (Instant Contiki 3.0 without apt-get upgrade):
# lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 12.04.5 LTS
Release:        12.04
Codename:       precise
# java -version
java version ""1.7.0_95""
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.12.04.2)
OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16

user@instant-contiki:~/contiki$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty
user@instant-contiki:~/contiki$ java -version
java version ""1.7.0_79""
OpenJDK Runtime Environment (IcedTea 2.5.6) (7u79-2.5.6-0ubuntu1.14.04.1)
OpenJDK Client VM (build 24.79-b02, mixed mode, sharing)
user@instant-contiki:~/contiki$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
According to the release note of Rhino 17R4, there is some improvement on string concatenation. It says:

Make string concatenation with + fast.

It seems like the following feature found in the ConsString document  has been introduced since Rhino 1.7R4.

This string representation is optimized for concatenation using the ""+"" operator. Instead of
immediately copying both components to a new character array, ConsString keeps references to
the original components and only converts them to a String if either toString() is called or a certain
depth level is reached.

The conclusion is that this improvement on the + operator causes the errors raised in the regression tests on Ubuntu 14.04 (Rhino 1.7R4).
Lastly, I'll share a proof-of-concept.
We can get the same error as mentioned above by jrunscript (Rhino 1.7R4/Ubuntu 14.04). In the last part of this example, you can see the concat function works as expected.
$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
$ jrunscript   
js> var packets = ""_________"";
js> packets = packets.substr(0, 0) + ""*"";
*
js> packets = packets.substr(0, 1) + ""*"";
script error: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<STDIN>#1) in <STDIN> at line number 1
js> packets.getClass()
class sun.org.mozilla.javascript.ConsString
js>
$ jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");    
**
This example shows the concat method works on Rhino 1.7R3 (Ubuntu 12.04) in the same way as shown above with Rhino 1.7R4.
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16
# jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");
**","Awesome, I've been annoyed with this issue many times! Thanks for investigating and fixing. üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1647,2016-05-02T19:57:45Z,2016-05-03T08:28:59Z,2016-05-03T09:34:39Z,MERGED,True,28,28,14,https://github.com/yatch,Resolve script errors raised during the RPL regression tests on Ubuntu 14.04,1,[],https://github.com/contiki-os/contiki/pull/1647,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1647#issuecomment-216466400,"This PR resolves the script errors which prevent you from performing regression tests for RPL on Ubuntu 14.04, which Instant Contiki 3.0 is based on.
The script errors look like this:
...
FATAL [Thread-7] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-7] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: javax.script.ScriptException: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92) in <Unknown sourceat line number 92
...
Caused by: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<Unknown source>#92)
...
 FAIL ‡≤†_‡≤†
In this case, the error occurs on evaluating packets.substr(0, num) at the following statement.
packets = packets.substr(0, num) + ""*"";
At this point, packets on the right side is supposed to be ""*"", a String object. Howerver, it is, in fact, a ConsString object which does not have the substr function. packets.substr(0, num) + ""*"" does not produce a String object in the first iteration under the Java environment by openjdk-7-jdk on Ubuntu 14.04.
One of solutions to overcome this error is using the concat function instead of the + operator. This is the key idea of this patch.
packets = packets.substr(0, num).concat(""*"");
With the tip of the master branch, regression-tests/12-rpl/summary would have these results in it after the regression tests.
07-rpl-random-rearrangement.testlog:TEST OK
01-rpl-up-route.1.faillog: FAIL ‡≤†_‡≤†
02-rpl-root-reboot.1.faillog: FAIL ‡≤†_‡≤†
03-rpl-28-hours.1.faillog: FAIL ‡≤†_‡≤†
04-rpl-large-network.1.faillog: FAIL ‡≤†_‡≤†
05-rpl-up-and-down-routes.1.faillog: FAIL ‡≤†_‡≤†
06-rpl-temporary-root-loss.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-0.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-1.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-2.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-3.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-4.1.faillog: FAIL ‡≤†_‡≤†
08-rpl-dao-route-loss-5.1.faillog: FAIL ‡≤†_‡≤†
09-rpl-probing.1.faillog: FAIL ‡≤†_‡≤†
10-rpl-multi-dodag.1.faillog: FAIL ‡≤†_‡≤†

Applying the patch, all the tests under regression-tests/12-rpl succeed:
01-rpl-up-route.testlog:TEST OK
02-rpl-root-reboot.testlog:TEST OK
03-rpl-28-hours.testlog:TEST OK
04-rpl-large-network.testlog:TEST OK
05-rpl-up-and-down-routes.testlog:TEST OK
06-rpl-temporary-root-loss.testlog:TEST OK
07-rpl-random-rearrangement.testlog:TEST OK
08-rpl-dao-route-loss-0.testlog:TEST OK
08-rpl-dao-route-loss-1.testlog:TEST OK
08-rpl-dao-route-loss-2.testlog:TEST OK
08-rpl-dao-route-loss-3.testlog:TEST OK
08-rpl-dao-route-loss-4.testlog:TEST OK
08-rpl-dao-route-loss-5.testlog:TEST OK
09-rpl-probing.testlog:TEST OK
10-rpl-multi-dodag.testlog:TEST OK

From here, I'd like to provide some background information.
First of all, on Ubuntu 12.04, this error does not occur. packets.substr(0, num) + ""*"" returns a String object. This is why this type of error is not found on Travis CI tests which uses Ubuntu 12.04.
I noticed a difference between Ubuntu 12.04 and 14.04; this is the version of Rhino that is installed with openjdk-7-jdk: 1.7R3 on Ubuntu 12.04 and 1.7R4 on Ubuntu 14.04. Here is the environmental information of my Ubuntu 12.04 machine and 14.04 machine (Instant Contiki 3.0 without apt-get upgrade):
# lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 12.04.5 LTS
Release:        12.04
Codename:       precise
# java -version
java version ""1.7.0_95""
OpenJDK Runtime Environment (IcedTea 2.6.4) (7u95-2.6.4-0ubuntu0.12.04.2)
OpenJDK 64-Bit Server VM (build 24.95-b01, mixed mode)
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16

user@instant-contiki:~/contiki$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description:    Ubuntu 14.04.3 LTS
Release:    14.04
Codename:   trusty
user@instant-contiki:~/contiki$ java -version
java version ""1.7.0_79""
OpenJDK Runtime Environment (IcedTea 2.5.6) (7u79-2.5.6-0ubuntu1.14.04.1)
OpenJDK Client VM (build 24.79-b02, mixed mode, sharing)
user@instant-contiki:~/contiki$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
According to the release note of Rhino 17R4, there is some improvement on string concatenation. It says:

Make string concatenation with + fast.

It seems like the following feature found in the ConsString document  has been introduced since Rhino 1.7R4.

This string representation is optimized for concatenation using the ""+"" operator. Instead of
immediately copying both components to a new character array, ConsString keeps references to
the original components and only converts them to a String if either toString() is called or a certain
depth level is reached.

The conclusion is that this improvement on the + operator causes the errors raised in the regression tests on Ubuntu 14.04 (Rhino 1.7R4).
Lastly, I'll share a proof-of-concept.
We can get the same error as mentioned above by jrunscript (Rhino 1.7R4/Ubuntu 14.04). In the last part of this example, you can see the concat function works as expected.
$ jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 4 2013 08 27
$ jrunscript   
js> var packets = ""_________"";
js> packets = packets.substr(0, 0) + ""*"";
*
js> packets = packets.substr(0, 1) + ""*"";
script error: sun.org.mozilla.javascript.EcmaError: TypeError: Cannot find function substr in object *. (<STDIN>#1) in <STDIN> at line number 1
js> packets.getClass()
class sun.org.mozilla.javascript.ConsString
js>
$ jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");    
**
This example shows the concat method works on Rhino 1.7R3 (Ubuntu 12.04) in the same way as shown above with Rhino 1.7R4.
# jrunscript -q
Language ECMAScript 1.7 implemention ""Rhino"" Rhino 1.7 release 3 2012 02 16
# jrunscript
js> var packets = ""_________"";
js> packets = packets.substr(0, 0).concat(""*"");
*
js> packets = packets.substr(0, 1).concat(""*"");
**",Thanks for the thoughtful explanation and fix üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1651,2016-05-04T17:15:45Z,2016-05-12T15:01:16Z,2016-05-21T07:50:58Z,MERGED,True,4,4,1,https://github.com/jnohlgard,"oma-lwm2m: Use sv for string value, bv for boolean",1,[],https://github.com/contiki-os/contiki/pull/1651,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1651,"This fixes JSON parsing errors when reading entire instances from the Leshan example server web GUI.
http://dev_devtoolkit.openmobilealliance.org/IoT/LWM2M10/doc/TS/index.html#!Documents/json.htm","This fixes JSON parsing errors when reading entire instances from the Leshan example server web GUI.
http://dev_devtoolkit.openmobilealliance.org/IoT/LWM2M10/doc/TS/index.html#!Documents/json.htm",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1651,2016-05-04T17:15:45Z,2016-05-12T15:01:16Z,2016-05-21T07:50:58Z,MERGED,True,4,4,1,https://github.com/jnohlgard,"oma-lwm2m: Use sv for string value, bv for boolean",1,[],https://github.com/contiki-os/contiki/pull/1651,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1651#issuecomment-216981403,"This fixes JSON parsing errors when reading entire instances from the Leshan example server web GUI.
http://dev_devtoolkit.openmobilealliance.org/IoT/LWM2M10/doc/TS/index.html#!Documents/json.htm",Looks like good improvements! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1651,2016-05-04T17:15:45Z,2016-05-12T15:01:16Z,2016-05-21T07:50:58Z,MERGED,True,4,4,1,https://github.com/jnohlgard,"oma-lwm2m: Use sv for string value, bv for boolean",1,[],https://github.com/contiki-os/contiki/pull/1651,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1651#issuecomment-216987050,"This fixes JSON parsing errors when reading entire instances from the Leshan example server web GUI.
http://dev_devtoolkit.openmobilealliance.org/IoT/LWM2M10/doc/TS/index.html#!Documents/json.htm","üëç
Travis failure is unrelated, restarting anyway",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1651,2016-05-04T17:15:45Z,2016-05-12T15:01:16Z,2016-05-21T07:50:58Z,MERGED,True,4,4,1,https://github.com/jnohlgard,"oma-lwm2m: Use sv for string value, bv for boolean",1,[],https://github.com/contiki-os/contiki/pull/1651,https://github.com/joakimeriksson,4,https://github.com/contiki-os/contiki/pull/1651#issuecomment-218222718,"This fixes JSON parsing errors when reading entire instances from the Leshan example server web GUI.
http://dev_devtoolkit.openmobilealliance.org/IoT/LWM2M10/doc/TS/index.html#!Documents/json.htm",Yes this failure seems totally unrelated.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1651,2016-05-04T17:15:45Z,2016-05-12T15:01:16Z,2016-05-21T07:50:58Z,MERGED,True,4,4,1,https://github.com/jnohlgard,"oma-lwm2m: Use sv for string value, bv for boolean",1,[],https://github.com/contiki-os/contiki/pull/1651,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/1651#issuecomment-218784910,"This fixes JSON parsing errors when reading entire instances from the Leshan example server web GUI.
http://dev_devtoolkit.openmobilealliance.org/IoT/LWM2M10/doc/TS/index.html#!Documents/json.htm",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1652,2016-05-04T17:21:02Z,2016-05-30T13:33:08Z,2016-06-07T08:08:10Z,MERGED,True,82,27,1,https://github.com/jnohlgard,oma-lwm2m: Use Accept header to determine writer object,1,[],https://github.com/contiki-os/contiki/pull/1652,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1652,"depends on #1651 - merged
This simplifies using Copper for debugging LWM2M resources since it lets us look at the variables in plain text.
Also changes the decision to use the provided Accept header instead of Content-Format header to determine if we are sending an APPLICATION_LINK_FORMAT or LWM2M_JSON response for dumping entire service instances.","depends on #1651 - merged
This simplifies using Copper for debugging LWM2M resources since it lets us look at the variables in plain text.
Also changes the decision to use the provided Accept header instead of Content-Format header to determine if we are sending an APPLICATION_LINK_FORMAT or LWM2M_JSON response for dumping entire service instances.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1652,2016-05-04T17:21:02Z,2016-05-30T13:33:08Z,2016-06-07T08:08:10Z,MERGED,True,82,27,1,https://github.com/jnohlgard,oma-lwm2m: Use Accept header to determine writer object,1,[],https://github.com/contiki-os/contiki/pull/1652,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1652#issuecomment-222296612,"depends on #1651 - merged
This simplifies using Copper for debugging LWM2M resources since it lets us look at the variables in plain text.
Also changes the decision to use the provided Accept header instead of Content-Format header to determine if we are sending an APPLICATION_LINK_FORMAT or LWM2M_JSON response for dumping entire service instances.",Looks like a very nice improvement - gets a üëç from me.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1652,2016-05-04T17:21:02Z,2016-05-30T13:33:08Z,2016-06-07T08:08:10Z,MERGED,True,82,27,1,https://github.com/jnohlgard,oma-lwm2m: Use Accept header to determine writer object,1,[],https://github.com/contiki-os/contiki/pull/1652,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1652#issuecomment-222493556,"depends on #1651 - merged
This simplifies using Copper for debugging LWM2M resources since it lets us look at the variables in plain text.
Also changes the decision to use the provided Accept header instead of Content-Format header to determine if we are sending an APPLICATION_LINK_FORMAT or LWM2M_JSON response for dumping entire service instances.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1653,2016-05-04T17:25:04Z,2016-05-04T20:13:13Z,2016-05-21T07:51:08Z,MERGED,True,1,1,1,https://github.com/jnohlgard,"ipso-temperature: Use ""Cel"" for degrees celsius",1,[],https://github.com/contiki-os/contiki/pull/1653,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1653,"Like the IPSO documentation says
http://unitsofmeasure.org/
https://loinc.org/usage/units","Like the IPSO documentation says
http://unitsofmeasure.org/
https://loinc.org/usage/units",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1653,2016-05-04T17:25:04Z,2016-05-04T20:13:13Z,2016-05-21T07:51:08Z,MERGED,True,1,1,1,https://github.com/jnohlgard,"ipso-temperature: Use ""Cel"" for degrees celsius",1,[],https://github.com/contiki-os/contiki/pull/1653,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1653#issuecomment-216982592,"Like the IPSO documentation says
http://unitsofmeasure.org/
https://loinc.org/usage/units",Nice - thanks for taking the effort to improve the LWM2M code! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1653,2016-05-04T17:25:04Z,2016-05-04T20:13:13Z,2016-05-21T07:51:08Z,MERGED,True,1,1,1,https://github.com/jnohlgard,"ipso-temperature: Use ""Cel"" for degrees celsius",1,[],https://github.com/contiki-os/contiki/pull/1653,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1653#issuecomment-216987364,"Like the IPSO documentation says
http://unitsofmeasure.org/
https://loinc.org/usage/units",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1654,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1654#issuecomment-218222325,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651",Did you test with Leshan or Wakaama? I think it looks good - nice to see progress on the LWM2M codebase.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/jnohlgard,3,https://github.com/contiki-os/contiki/pull/1654#issuecomment-218388848,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651",@joakimeriksson I used Copper for testing the service response. The Leshan server is still using OMA TLV formatted responses with this PR.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/nfi,4,https://github.com/contiki-os/contiki/pull/1654#issuecomment-219022895,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","Nice to see improved JSON support for LWM2M! The JSON writer looks good except that I think that the snprinf returns the number of characters not counting the null character at the end. This means that it should be len >= outlen instead of len > outlen when checking for truncated output.
This issue is also present in other parts of Contiki.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/jnohlgard,5,https://github.com/contiki-os/contiki/pull/1654#issuecomment-220764992,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","The reason for the greater than rather than greater than or equal is that the CoAP response payload will not contain the trailing null byte and uses the length of the response to determine which bytes to copy, so no trailing null byte is necessary here.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/nfi,6,https://github.com/contiki-os/contiki/pull/1654#issuecomment-220770082,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","I aggree that the trailing null byte should not be necessary here but the problem is that different implementations of snprintf() handles this differently. Modern implementations tend to always add the trailing null byte, discarding the last ""real"" byte if needed.
Example compiled with gcc:

static char buf[5];
int ret = snprintf(buf, 4, ""abcd"");
printf(""ret=%d s='%s'\n"", ret, but);
=> ret=4 s='abc'",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/jnohlgard,7,https://github.com/contiki-os/contiki/pull/1654#issuecomment-220847894,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","@nfi Yes, you are correct, the output may have been corrupted if the buffer is filled since the last letter may have been replaced by a null byte.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/jnohlgard,8,https://github.com/contiki-os/contiki/pull/1654#issuecomment-220848010,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","Corrected the output length checks.
OK to squash?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/nfi,9,https://github.com/contiki-os/contiki/pull/1654#issuecomment-222133681,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","Thanks for the update. I think this looks good and is ready to squash, but please remove the extra space after if (code style).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/jnohlgard,10,https://github.com/contiki-os/contiki/pull/1654#issuecomment-222292066,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","rebased, squashed. #1652 should be reviewed and merged before merging this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1654#issuecomment-223380067,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651","#1652 has been merged already, restarting the travis job.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1654,2016-05-04T18:45:05Z,2016-06-03T12:53:27Z,2016-06-07T08:08:03Z,MERGED,True,312,31,4,https://github.com/jnohlgard,oma-lwm2m: Add JSON writer,2,[],https://github.com/contiki-os/contiki/pull/1654,https://github.com/nvt,12,https://github.com/contiki-os/contiki/pull/1654#issuecomment-223570767,"A minimal JSON writer for LWM2M resources.
Depends on #1652, #1651",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1656,2016-05-05T14:50:54Z,2016-05-12T14:49:16Z,2016-05-12T15:17:23Z,MERGED,True,21,30,1,https://github.com/mgrella,Update to stm32nucleo-spirit1 platform README file.,1,[],https://github.com/contiki-os/contiki/pull/1656,https://github.com/mgrella,1,https://github.com/contiki-os/contiki/pull/1656,"Added github accounts of the maintainers (now STclab is an organization account), a Documentation section pointing to resources on ST website. Other small fixes in other sections.","Added github accounts of the maintainers (now STclab is an organization account), a Documentation section pointing to resources on ST website. Other small fixes in other sections.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1656,2016-05-05T14:50:54Z,2016-05-12T14:49:16Z,2016-05-12T15:17:23Z,MERGED,True,21,30,1,https://github.com/mgrella,Update to stm32nucleo-spirit1 platform README file.,1,[],https://github.com/contiki-os/contiki/pull/1656,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1656#issuecomment-218780974,"Added github accounts of the maintainers (now STclab is an organization account), a Documentation section pointing to resources on ST website. Other small fixes in other sections.","The failed test (large-rpl) is not related this PR, which is only a readme update.
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1656,2016-05-05T14:50:54Z,2016-05-12T14:49:16Z,2016-05-12T15:17:23Z,MERGED,True,21,30,1,https://github.com/mgrella,Update to stm32nucleo-spirit1 platform README file.,1,[],https://github.com/contiki-os/contiki/pull/1656,https://github.com/mgrella,3,https://github.com/contiki-os/contiki/pull/1656#issuecomment-218787554,"Added github accounts of the maintainers (now STclab is an organization account), a Documentation section pointing to resources on ST website. Other small fixes in other sections.",Thank you!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1657,2016-05-09T16:19:11Z,2016-05-12T14:15:45Z,2016-05-12T19:46:18Z,MERGED,True,2,2,2,https://github.com/tscheffl,Fix for IPv6 compilation and linkage errors,1,[],https://github.com/contiki-os/contiki/pull/1657,https://github.com/tscheffl,1,https://github.com/contiki-os/contiki/pull/1657,"Two errors have been spotted, when IPv6 is enabled in the ravenusb
Project-Makefile:
#CONTIKI_NO_NET=1
CONTIKI_WITH_IPV6=1
The compile error results from a variable name mismatch in cdc_task.c
The variable r is undeclared and should be renamed to route
The linker also fails with undefined references
This has been mediated by adding core/net to Modules in the
Project-Makefile.","Two errors have been spotted, when IPv6 is enabled in the ravenusb
Project-Makefile:
#CONTIKI_NO_NET=1
CONTIKI_WITH_IPV6=1
The compile error results from a variable name mismatch in cdc_task.c
The variable r is undeclared and should be renamed to route
The linker also fails with undefined references
This has been mediated by adding core/net to Modules in the
Project-Makefile.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1657,2016-05-09T16:19:11Z,2016-05-12T14:15:45Z,2016-05-12T19:46:18Z,MERGED,True,2,2,2,https://github.com/tscheffl,Fix for IPv6 compilation and linkage errors,1,[],https://github.com/contiki-os/contiki/pull/1657,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1657#issuecomment-218770438,"Two errors have been spotted, when IPv6 is enabled in the ravenusb
Project-Makefile:
#CONTIKI_NO_NET=1
CONTIKI_WITH_IPV6=1
The compile error results from a variable name mismatch in cdc_task.c
The variable r is undeclared and should be renamed to route
The linker also fails with undefined references
This has been mediated by adding core/net to Modules in the
Project-Makefile.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1660,2016-05-12T19:36:14Z,2016-05-19T11:14:18Z,2016-05-19T15:08:37Z,MERGED,True,2,2,2,https://github.com/yatch,Fix the path for wpcapslip in testscript for Instant Contiki,1,[],https://github.com/contiki-os/contiki/pull/1660,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1660,"This PR resolves errors raised on executing two of the regression tests, 20-ip64 and 21-large-rpl, under Instant Contiki (a non Travis environment).
Here are error messages you'll see with the tests:
user@instant-contiki:~/contiki$ make -C regression-tests/20-ip64 RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/20-ip64'
Running test 01-cooja-ip64-http-socket with random Seed 1: .... INFO [main] (Cooja.java:1781) - 
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#34) in <Unknown source> at line number 34
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more

...
user@instant-contiki:~/contiki$ make -C regression-tests/21-large-rpl RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/21-large-rpl'
Running test 01-cooja-http-socket-50 with random Seed 1: ...... INFO [main] (Cooja.java:1781) -
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#40) in <Unknown source> at line number 40
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more
...","This PR resolves errors raised on executing two of the regression tests, 20-ip64 and 21-large-rpl, under Instant Contiki (a non Travis environment).
Here are error messages you'll see with the tests:
user@instant-contiki:~/contiki$ make -C regression-tests/20-ip64 RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/20-ip64'
Running test 01-cooja-ip64-http-socket with random Seed 1: .... INFO [main] (Cooja.java:1781) - 
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#34) in <Unknown source> at line number 34
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more

...
user@instant-contiki:~/contiki$ make -C regression-tests/21-large-rpl RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/21-large-rpl'
Running test 01-cooja-http-socket-50 with random Seed 1: ...... INFO [main] (Cooja.java:1781) -
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#40) in <Unknown source> at line number 40
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more
...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1660,2016-05-12T19:36:14Z,2016-05-19T11:14:18Z,2016-05-19T15:08:37Z,MERGED,True,2,2,2,https://github.com/yatch,Fix the path for wpcapslip in testscript for Instant Contiki,1,[],https://github.com/contiki-os/contiki/pull/1660,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1660#issuecomment-218970445,"This PR resolves errors raised on executing two of the regression tests, 20-ip64 and 21-large-rpl, under Instant Contiki (a non Travis environment).
Here are error messages you'll see with the tests:
user@instant-contiki:~/contiki$ make -C regression-tests/20-ip64 RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/20-ip64'
Running test 01-cooja-ip64-http-socket with random Seed 1: .... INFO [main] (Cooja.java:1781) - 
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#34) in <Unknown source> at line number 34
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more

...
user@instant-contiki:~/contiki$ make -C regression-tests/21-large-rpl RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/21-large-rpl'
Running test 01-cooja-http-socket-50 with random Seed 1: ...... INFO [main] (Cooja.java:1781) -
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#40) in <Unknown source> at line number 40
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more
...",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1660,2016-05-12T19:36:14Z,2016-05-19T11:14:18Z,2016-05-19T15:08:37Z,MERGED,True,2,2,2,https://github.com/yatch,Fix the path for wpcapslip in testscript for Instant Contiki,1,[],https://github.com/contiki-os/contiki/pull/1660,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1660#issuecomment-220295227,"This PR resolves errors raised on executing two of the regression tests, 20-ip64 and 21-large-rpl, under Instant Contiki (a non Travis environment).
Here are error messages you'll see with the tests:
user@instant-contiki:~/contiki$ make -C regression-tests/20-ip64 RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/20-ip64'
Running test 01-cooja-ip64-http-socket with random Seed 1: .... INFO [main] (Cooja.java:1781) - 
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#34) in <Unknown source> at line number 34
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more

...
user@instant-contiki:~/contiki$ make -C regression-tests/21-large-rpl RUNALL=yes summary
make: Entering directory `/home/user/contiki/regression-tests/21-large-rpl'
Running test 01-cooja-http-socket-50 with random Seed 1: ...... INFO [main] (Cooja.java:1781) -
(snip)
FATAL [Thread-5] (LogScriptEngine.java:312) - Test script error, terminating Cooja.
FATAL [Thread-5] (LogScriptEngine.java:313) - Script error:
java.lang.reflect.UndeclaredThrowableException
    at com.sun.proxy.$Proxy5.run(Unknown Source)
    at org.contikios.cooja.plugins.LogScriptEngine$4.run(LogScriptEngine.java:300)
    at java.lang.Thread.run(Thread.java:745)
Caused by: java.security.PrivilegedActionException: javax.script.ScriptException: sun.org.mozilla.javascript.WrappedException: Wrapped java.io.IOException: Cannot run program ""sh"" (in directory ""../../wpcapslip""): error=2, No such file or directory (<Unknown source>#40) in <Unknown source> at line number 40
    at java.security.AccessController.doPrivileged(Native Method)
    at com.sun.script.util.InterfaceImplementor$InterfaceImplementorInvocationHandler.invoke(InterfaceImplementor.java:67)
    ... 3 more
...",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1661,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1661#issuecomment-218970183,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","Wow. That is awesome. I never looked very closely at Cooja motes and wasn't really sure how feasible this would be to be honest ;) I will review this is more details at some point, but what I can say now: (1) the feature is super-great (2) the modifications to core TSCH are minor enough to be acceptable (3) we need to think about running some of the Travis tests with TSCH enabled.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/1661#issuecomment-219023386,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","@simonduq Thanks. By the way, it seems Orchestra also works well with MAKE_WITH_ORCHESTRA=1. :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1661#issuecomment-223773708,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","Ok I tried and it works very nicely for me. I'm fine with the changes to core. Did not review changes to Cooja motes. I'm concerned with side-effects on regression tests as you mention above. Is there a way to somehow make all changes conditional, and make sure things are just like before as long as TSCH is not enabled?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/1661#issuecomment-223986060,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","@simonduq Thank you for your trying!
With regard to the regression test, I ran the Travis test again on this branch last night. It succeeded without any failure. I got all green three times in a row so far. The low success rate I experienced before may be due to my bad luck...?
Your idea, making the changes conditional is definitely one of options. It could be sufficient to target the changes related only to clock and timer for the conditional compilation. But my initial impression is that it would not be easy because the changes are not only in the C part but also in Java part....
In any case, I'll take a closer look at RPL behaviors after rebase.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1661#issuecomment-224209081,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","Sounds good, thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/yatch,7,https://github.com/contiki-os/contiki/pull/1661#issuecomment-227786885,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","I confirmed there are a couple of behavioral differences between the master branch and this PR branch, pr-tsch-cooja-mote. My conclusion is that they are not bugs.
Here is what I did.
First of all, I made some measurements on the following concerns about regression test results.

Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took
longer time than before. And success rate of
regression-tests/21-large-rpl/01-cooja-http-socket-50 was low.

I ran the test of regression-tests/12-rpl/04-rpl-large-network and measured the execution time twenty times on a local machine with master and pr-tsch-cooja-mote respectively. Here is the result, where each number represents the number of seconds. As I experienced before, pr-tsch-cooja-mote took more time than master.




min
max
mean




master
543.297
627.602
583.065


pr-tsch-cooja-mote
623.192
663.696
638.712



Next, I ran regression-tests/21-large-rpl/01-cooja-http-socket-50 on Travis with my account to see any difference of success rate between master and pr-tsch-cooja-mote. The result is that both of them succeeded ten out of ten times. Now, I think some external condition were not good for the test last month when I sent this PR.
Then, I focused on 04-rpl-large-network. I applied the patch of #1502 to both of master and pr-tsch-cooja-mote and examined packets captured during the test of 04-rpl-large-network. There are two findings.
The first thing is that I saw several nodes of the master case sent DIS packets later than the same nodes of the pr-tsch-cooja-mote case. This is because etimer of the master branch occasionally expires later than its expiration. This happens if a packet is received  before the expiration. This is not the case with pr-tsch-cooja-mote.
The other thing is also related to packet reception. I saw a certain node of the pr-tsch-cooja-mote case missed an ACK frame, on the other hand, the same node of the master case received the ACK frame sent at the exact same timing. The packet reception affects the ACK waiting logic in nullrdc of the master branch, and this causes such a difference.
These things happen basically because the Cooja mote of the master branch ignores the microsecond part of time. To confirm my theory, I applied the following patch to pr-tsch-cooja-mote and ran 04-rpl-large-network with it.
diff --git a/core/net/mac/nullrdc.c b/core/net/mac/nullrdc.c
index 7ba62a4..eecad42 100644
--- a/core/net/mac/nullrdc.c
+++ b/core/net/mac/nullrdc.c
@@ -155,9 +155,17 @@ send_one_packet(mac_callback_t sent, void *ptr)
           rtimer_clock_t wt;

           /* Check for ack */
+#if CONTIKI_TARGET_COOJA
+          wt = clock_time();
+#else
           wt = RTIMER_NOW();
+#endif
           watchdog_periodic();
+#if CONTIKI_TARGET_COOJA
+          while(RTIMER_CLOCK_LT(clock_time(), wt + ACK_WAIT_TIME / 1000)) {
+#else
           while(RTIMER_CLOCK_LT(RTIMER_NOW(), wt + ACK_WAIT_TIME)) {
+#endif
 #if CONTIKI_TARGET_COOJA || CONTIKI_TARGET_COOJA_IP64
             simProcessRunValue = 1;
             cooja_mt_yield();
diff --git a/tools/cooja/java/org/contikios/cooja/contikimote/interfaces/ContikiClock.java b/tools/cooja/java/org/contikios/cooja/contikimote/interfaces/ContikiClock.java
index 97cbc61..6715193 100644
--- a/tools/cooja/java/org/contikios/cooja/contikimote/interfaces/ContikiClock.java
+++ b/tools/cooja/java/org/contikios/cooja/contikimote/interfaces/ContikiClock.java
@@ -157,7 +157,7 @@ public class ContikiClock extends Clock implements ContikiMoteInterface, PolledB

     /* Request tick next wakeup time for Etimer */
     long etimerNextExpirationTime = (long)moteMem.getInt32ValueOf(""simEtimerNextExpirationTime"") * Simulation.MILLISECOND;
-    long etimerTimeToNextExpiration = etimerNextExpirationTime - moteTime;
+    long etimerTimeToNextExpiration = etimerNextExpirationTime - (moteTime / 1000) * 1000;
     if (etimerTimeToNextExpiration <= 0) {
       /* logger.warn(mote.getID() + "": Event timer already expired, but has been delayed: "" + etimerTimeToNextExpiration); */
       /* Wake up in one millisecond to handle a missed Etimer task


I got a packet capture file which has the exact same packet interval with the master case. And, the execution time of the patched pr-tsch-cooja-mote is close to master.




min
max
mean




master
543.297
627.602
583.065


pr-tsch-cooja-mote
623.192
663.696
638.712


patched
541.892
619.882
597.646



To compare the number of packets of 04-rpl-large-network, master is 33,828 packets, pr-tsch-cooja-mote is 37,281 packets. I believe the behavioral differences in nullrdc and in etimer cause more packets in the case of pr-tsch-cooja-mote. More packets lead more events to handle, then longer execution time. This can explain why pr-tsch-cooja-mote takes longer time to run 04-rpl-large-network than master.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1661#issuecomment-227994228,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.",Thanks a lot for this in-depth analysis!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1661#issuecomment-244894424,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","üëç , setting a timeout for merging.
Cooja experts, shout if you don't want this merged. Am happy with the PR because of the added feature and the fact Travis still passes makes me confident this does not break the Cooja mote.
@yatch , rebase needed",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/yatch,10,https://github.com/contiki-os/contiki/pull/1661#issuecomment-244946908,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.",@simonduq Rebased :-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1661,2016-05-12T22:38:00Z,2016-11-23T10:59:29Z,2020-06-24T18:02:18Z,MERGED,True,514,104,17,https://github.com/yatch,TSCH on Cooja mote ,11,"['Cooja', 'Core', 'timed out', 'fix required: needs-rebase']",https://github.com/contiki-os/contiki/pull/1661,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1661#issuecomment-262484671,"Introduction
This PR aims to port TSCH to the Cooja mote platform.
Three major changes are made:

re-implement rtimer as a 1 MHz timer to comply with the resolution requirement of TSCH, 32 KHz or higher
add the radio features required for TSCH, including the polling mode
add Cooja mote dependent code in the TSCH logic to manage busy waiting

This PR includes a sample simulation file, examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc, which is based on rpl-tsch.csc.
To run TSCH on Cooja motes, you need to disable the simulated turnaround feature implemented in cooja-radio.c with the COOJA_CONF_SIMULATE_TURNAROUND macro that is newly introduced. In examples/ipv6/rpl-tsch/project-conf.h, the following lines are appended.
#if CONTIKI_TARGET_COOJA
#define COOJA_CONF_SIMULATE_TURNAROUND 0
#endif /* CONTIKI_TARGET_COOJA */
Concerns / Disadvantages
There are three concerns:
Firstly, this PR apparently changes the etimer and rtimer logics of the Cooja mote platform, which are very fundamental parts in the Contiki system. Such changes may cause unexpected system behaviors which are not covered by the regression tests.
One noteworthy change is rtimer_rach_now(). The function does not call cooja_mt_yield() any more. If there is any code expecting to advance the time by calling rtimer_arch_now(), it needs to be resolved.
Speaking of the regression tests, I noticed regression-tests/12-rpl/04-rpl-large-network took longer time than before. And success rate of regression-tests/21-large-rpl/01-cooja-http-socket-50 was low. These things may be caused by the changes.
Secondly, Cooja mote dependent code is introduced into the TSCH module. I tried to keep from modifying the module; but I could not find a good way to realize busy waiting on the platform... I borrowed the idea in core/net/mac/nullrdc.c that is to set 1 to simProcessRunValue and to call cooja_mt_yield() in a busy loop. This works in most cases except for BUSYWAIT_UNTIL_ABS(cond, t0, offset) with 0 for cond.
This type of BUSYWAIT_UNTIL_ABS() is used in the TSCH_SCHEDULE_AND_YIELD macro. Essentially, the macro makes a process sleep for offset - RTIMER_GUARD with rtimer_set and wait actively until its target time with BUSYWAIT_UNTIL_ABS(0, ref_time, offset). Since BUSYWAIT_UNTIL_ABS(0, ref_time, offset) does not work well as mentioned before, RTIMER_GUARD is set to 0 for the Cooja platform to wake up on the exact time it expects.
Lastly, I decided to disable the simulated turnaround implemented around cooja-radio.c#L204 for TSCH because it causes desynchronizaion. If the feature is important to TSCH as well, it needs another way.
Screenshot

Memo
Things I noticed during the implementation.
Transmission duration calculation in ContikiRadio
The comment at ContikiRadio.java#L357 seems obsolete.
356       /* Calculate transmission duration (us) */
357       /* XXX Currently floored due to millisecond scheduling! */
358       long duration = (int) (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps));
359       transmissionEndTime = now + Math.max(1, duration);
In addition, (Simulation.MILLISECOND*((8 * size /*bits*/) / RADIO_TRANSMISSION_RATE_kbps)) produces microseconds to send the bits unless I am mistaken... I'm also not sure why casting with int is used there instead of long.
Handling subsequent tasks passed to rtimer_set
Why next_rtimer is updated at rtimer.c#L83 regardless of first...? When multiple tasks are set with rtimer_set at a certain tick, the last task passed to the function would be executed at the expiration of the first task. I might overlook something.
66 int
67 rtimer_set(struct rtimer *rtimer, rtimer_clock_t time,
68            rtimer_clock_t duration,
69            rtimer_callback_t func, void *ptr)
70 {
71   int first = 0;
...
75   if(next_rtimer == NULL) {
76     first = 1;
77   }
...
83   next_rtimer = rtimer;
84
85   if(first == 1) {
86     rtimer_arch_schedule(time);
87   }
88   return RTIMER_OK;
89 }
This is related to #814.","Merging after timeout, thanks for the awesome contrib!!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1663,2016-05-13T17:05:29Z,2016-05-14T15:05:23Z,2016-05-14T15:11:11Z,MERGED,True,16,0,1,https://github.com/pablocorbalan,Add upload script to Makefile.launchpad,1,[],https://github.com/contiki-os/contiki/pull/1663,https://github.com/pablocorbalan,1,https://github.com/contiki-os/contiki/pull/1663,"This PR simply adds the upload command to the Makefile of the CC2650 Launchpad addressing the comment of @joakimeriksson on the already merged #1485 pull request. I also confirm that the BSL script worked for me on Mac OS X without any problem after addressing the changes described by @g-oikonomou and also setting the SET_CCFG_BL_CONFIG_BL_LEVEL to 0x0 in the ccfg.c file.
I have set 115200 as predefined baud rate for the script.","This PR simply adds the upload command to the Makefile of the CC2650 Launchpad addressing the comment of @joakimeriksson on the already merged #1485 pull request. I also confirm that the BSL script worked for me on Mac OS X without any problem after addressing the changes described by @g-oikonomou and also setting the SET_CCFG_BL_CONFIG_BL_LEVEL to 0x0 in the ccfg.c file.
I have set 115200 as predefined baud rate for the script.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1663,2016-05-13T17:05:29Z,2016-05-14T15:05:23Z,2016-05-14T15:11:11Z,MERGED,True,16,0,1,https://github.com/pablocorbalan,Add upload script to Makefile.launchpad,1,[],https://github.com/contiki-os/contiki/pull/1663,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1663#issuecomment-219157455,"This PR simply adds the upload command to the Makefile of the CC2650 Launchpad addressing the comment of @joakimeriksson on the already merged #1485 pull request. I also confirm that the BSL script worked for me on Mac OS X without any problem after addressing the changes described by @g-oikonomou and also setting the SET_CCFG_BL_CONFIG_BL_LEVEL to 0x0 in the ccfg.c file.
I have set 115200 as predefined baud rate for the script.","Thank you, Pablo, this is something I've meant to do since Joakim's comment, so it's great that you have.
The script should be intelligent enough to default to baud rate 500000 for this board, so I think the -b harms more than it helps. Can you try without it please?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1663,2016-05-13T17:05:29Z,2016-05-14T15:05:23Z,2016-05-14T15:11:11Z,MERGED,True,16,0,1,https://github.com/pablocorbalan,Add upload script to Makefile.launchpad,1,[],https://github.com/contiki-os/contiki/pull/1663,https://github.com/pablocorbalan,3,https://github.com/contiki-os/contiki/pull/1663#issuecomment-219172222,"This PR simply adds the upload command to the Makefile of the CC2650 Launchpad addressing the comment of @joakimeriksson on the already merged #1485 pull request. I also confirm that the BSL script worked for me on Mac OS X without any problem after addressing the changes described by @g-oikonomou and also setting the SET_CCFG_BL_CONFIG_BL_LEVEL to 0x0 in the ccfg.c file.
I have set 115200 as predefined baud rate for the script.",@g-oikonomou I have removed the -b 115200option. The script also works nicely with the default baud rate 500000.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1663,2016-05-13T17:05:29Z,2016-05-14T15:05:23Z,2016-05-14T15:11:11Z,MERGED,True,16,0,1,https://github.com/pablocorbalan,Add upload script to Makefile.launchpad,1,[],https://github.com/contiki-os/contiki/pull/1663,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1663#issuecomment-219176095,"This PR simply adds the upload command to the Makefile of the CC2650 Launchpad addressing the comment of @joakimeriksson on the already merged #1485 pull request. I also confirm that the BSL script worked for me on Mac OS X without any problem after addressing the changes described by @g-oikonomou and also setting the SET_CCFG_BL_CONFIG_BL_LEVEL to 0x0 in the ccfg.c file.
I have set 115200 as predefined baud rate for the script.","Many thanks, I'll merge this one.
Moving forward (not in this pull, but in the future), I want to have this entire block in Makefile.srf06-cc26xx, it is currently duplicated in too many makefiles, The board-specific Makefiles will simply set a make variable to signal that they support the .upload target. Default = no I'd suggest.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1663,2016-05-13T17:05:29Z,2016-05-14T15:05:23Z,2016-05-14T15:11:11Z,MERGED,True,16,0,1,https://github.com/pablocorbalan,Add upload script to Makefile.launchpad,1,[],https://github.com/contiki-os/contiki/pull/1663,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1663#issuecomment-219225193,"This PR simply adds the upload command to the Makefile of the CC2650 Launchpad addressing the comment of @joakimeriksson on the already merged #1485 pull request. I also confirm that the BSL script worked for me on Mac OS X without any problem after addressing the changes described by @g-oikonomou and also setting the SET_CCFG_BL_CONFIG_BL_LEVEL to 0x0 in the ccfg.c file.
I have set 115200 as predefined baud rate for the script.","Oh yay, it passed!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1665,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.","The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1665#issuecomment-219238821,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.","In fact, I cannot see why this should be in the platform makefile instead of the CPU makefile (since it's a CPU feature, common to all chips of both families).
I've thus moved the logic to cpu/cc26xx-cc13xx/Makefile.cc26xx-cc13xx (hence the close and re-open). This is now ready for your review.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/pablocorbalan,3,https://github.com/contiki-os/contiki/pull/1665#issuecomment-219435803,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.","George, this looks good to me! I was in fact implementing your suggestion in a similar way, see this. But your changes look better! I see no problem to move the logic to the CPU Makefile. You will need to adapt #1666 to also include BOARD_SUPPORTS_BSL = 1in the CC1310 Makefile.
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/atiselsts,4,https://github.com/contiki-os/contiki/pull/1665#issuecomment-219458995,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.","Hi George, would you mind also including login target? Otherwise üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1665#issuecomment-219682578,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.","You will need to adapt #1666 to also include BOARD_SUPPORTS_BSL = 1 in the CC1310 Makefile.

@pablocorbalan I am fairly certain this is not required ;)

Hi George, would you mind also including login target?

@atiselsts Can you open a pull on my repo on top of contrib/cc26xx-bsl. The .upload target should probably also be in the CPU makefile (?)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/pablocorbalan,6,https://github.com/contiki-os/contiki/pull/1665#issuecomment-219690752,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.","Sorry, my mistake! I didn't realize that #1666 uses the same launchpad subfolder, that's why it is not required. Cool!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1665#issuecomment-220159821,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.",I've added Atis' commit that enables the login make target for all CC26xx/CC13xx boards and I've updated the title of this pull accordingly,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1665,2016-05-14T18:19:55Z,2016-06-01T21:37:29Z,2016-06-13T11:06:25Z,MERGED,True,41,30,3,https://github.com/g-oikonomou,Consolidate .upload for all CC26xx/CC13xx boards and add login make target,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1665,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1665#issuecomment-223132562,"The block that controls the .upload target is unnecessarily replicated in multiple sub-board Makefiles. This was originally done because the SmartRF and the Launchpad can be programmed with the c2538-bsl script, whereas the sensortag cannot.
This commit moves the cc2538-bsl / .upload target logic to the top level platform Makefile (platform/srf06-cc26xx/Makefile.srf06-cc26xx). Board makefiles simply set the make variable BOARD_SUPPORTS_BSL to 1 to signal that they can be programmed by the BSL script. If BOARD_SUPPORTS_BSL is not equal to 1, trying to use the .upload target will return an error message.
For example:
$ make BOARD=sensortag/cc2650 cc26xx-demo.upload
using saved target 'srf06-cc26xx'
This board cannot be programmed with the ROM bootloader and therefore does not support the .upload target.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1666,2016-05-14T19:42:10Z,2016-06-01T13:41:45Z,2016-06-13T11:06:19Z,MERGED,True,209,3,6,https://github.com/g-oikonomou,Add support for the CC1310 LaunchPad (LAUNCHXL-CC1310),4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1666,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1666,"This pull request adds support for TI's CC1310 Launchpad.
We support LEDs and Buttons and also the LP's external flash. Examples under examples/cc26xx should work off-the-shelf.
According to the CC1310LP design files, the flash on it is the same as the flash on the CC2650 LP (MX25R8035F 8Mbit). However, the flash on some CC1310 LPs reportedly identifies itself as the 16Mbit one (MX25R1635F) instead. Instruction sets are identical, we simply need to tell the driver to recognize this part's Device ID. Thus, this pull also extends the driver to support this part, in case any user happens to have one of those launchpads.
Build with BOARD=launchpad/cc1310.
This pull also adds a travis test for the CC1310 LP build.","This pull request adds support for TI's CC1310 Launchpad.
We support LEDs and Buttons and also the LP's external flash. Examples under examples/cc26xx should work off-the-shelf.
According to the CC1310LP design files, the flash on it is the same as the flash on the CC2650 LP (MX25R8035F 8Mbit). However, the flash on some CC1310 LPs reportedly identifies itself as the 16Mbit one (MX25R1635F) instead. Instruction sets are identical, we simply need to tell the driver to recognize this part's Device ID. Thus, this pull also extends the driver to support this part, in case any user happens to have one of those launchpads.
Build with BOARD=launchpad/cc1310.
This pull also adds a travis test for the CC1310 LP build.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1666,2016-05-14T19:42:10Z,2016-06-01T13:41:45Z,2016-06-13T11:06:19Z,MERGED,True,209,3,6,https://github.com/g-oikonomou,Add support for the CC1310 LaunchPad (LAUNCHXL-CC1310),4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1666,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1666#issuecomment-222995333,"This pull request adds support for TI's CC1310 Launchpad.
We support LEDs and Buttons and also the LP's external flash. Examples under examples/cc26xx should work off-the-shelf.
According to the CC1310LP design files, the flash on it is the same as the flash on the CC2650 LP (MX25R8035F 8Mbit). However, the flash on some CC1310 LPs reportedly identifies itself as the 16Mbit one (MX25R1635F) instead. Instruction sets are identical, we simply need to tell the driver to recognize this part's Device ID. Thus, this pull also extends the driver to support this part, in case any user happens to have one of those launchpads.
Build with BOARD=launchpad/cc1310.
This pull also adds a travis test for the CC1310 LP build.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1667,2016-05-15T10:22:05Z,2016-06-04T20:47:24Z,2016-06-04T20:47:25Z,MERGED,True,833,0,6,https://github.com/alignan,AT driver (master) and example,1,"['enhancement', 'timed out']",https://github.com/contiki-os/contiki/pull/1667,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1667,"This PR includes support to implement AT commands to interact with the nodes, allowing to drive devices over UART ports (USB and alike).  An example shows how to implement an AT-based API.","This PR includes support to implement AT commands to interact with the nodes, allowing to drive devices over UART ports (USB and alike).  An example shows how to implement an AT-based API.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1667,2016-05-15T10:22:05Z,2016-06-04T20:47:24Z,2016-06-04T20:47:25Z,MERGED,True,833,0,6,https://github.com/alignan,AT driver (master) and example,1,"['enhancement', 'timed out']",https://github.com/contiki-os/contiki/pull/1667,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1667#issuecomment-223771779,"This PR includes support to implement AT commands to interact with the nodes, allowing to drive devices over UART ports (USB and alike).  An example shows how to implement an AT-based API.","Is this ready? If yes, happy to merge now (this cannot break anything)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1667,2016-05-15T10:22:05Z,2016-06-04T20:47:24Z,2016-06-04T20:47:25Z,MERGED,True,833,0,6,https://github.com/alignan,AT driver (master) and example,1,"['enhancement', 'timed out']",https://github.com/contiki-os/contiki/pull/1667,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1667#issuecomment-223774243,"This PR includes support to implement AT commands to interact with the nodes, allowing to drive devices over UART ports (USB and alike).  An example shows how to implement an AT-based API.",Ready!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1667,2016-05-15T10:22:05Z,2016-06-04T20:47:24Z,2016-06-04T20:47:25Z,MERGED,True,833,0,6,https://github.com/alignan,AT driver (master) and example,1,"['enhancement', 'timed out']",https://github.com/contiki-os/contiki/pull/1667,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1667#issuecomment-223777454,"This PR includes support to implement AT commands to interact with the nodes, allowing to drive devices over UART ports (USB and alike).  An example shows how to implement an AT-based API.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1670,2016-05-19T13:59:44Z,2016-05-23T13:22:36Z,2016-10-03T06:44:53Z,MERGED,True,5,0,1,https://github.com/jnohlgard,oma-lwm2m: Handle text/plain floatfix numbers without decimal point,1,[],https://github.com/contiki-os/contiki/pull/1670,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1670,Fixes bug: If no decimal point is present then the entire number is treated as the decimal part instead of as the integer part,Fixes bug: If no decimal point is present then the entire number is treated as the decimal part instead of as the integer part,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1670,2016-05-19T13:59:44Z,2016-05-23T13:22:36Z,2016-10-03T06:44:53Z,MERGED,True,5,0,1,https://github.com/jnohlgard,oma-lwm2m: Handle text/plain floatfix numbers without decimal point,1,[],https://github.com/contiki-os/contiki/pull/1670,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1670#issuecomment-220590301,Fixes bug: If no decimal point is present then the entire number is treated as the decimal part instead of as the integer part,Nice catch and fix. Just a little style issue with a extra space after the if. Please fix that and it should be good to be pulled.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1670,2016-05-19T13:59:44Z,2016-05-23T13:22:36Z,2016-10-03T06:44:53Z,MERGED,True,5,0,1,https://github.com/jnohlgard,oma-lwm2m: Handle text/plain floatfix numbers without decimal point,1,[],https://github.com/contiki-os/contiki/pull/1670,https://github.com/jnohlgard,3,https://github.com/contiki-os/contiki/pull/1670#issuecomment-220764477,Fixes bug: If no decimal point is present then the entire number is treated as the decimal part instead of as the integer part,removed space after if,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1670,2016-05-19T13:59:44Z,2016-05-23T13:22:36Z,2016-10-03T06:44:53Z,MERGED,True,5,0,1,https://github.com/jnohlgard,oma-lwm2m: Handle text/plain floatfix numbers without decimal point,1,[],https://github.com/contiki-os/contiki/pull/1670,https://github.com/nfi,4,https://github.com/contiki-os/contiki/pull/1670#issuecomment-220770332,Fixes bug: If no decimal point is present then the entire number is treated as the decimal part instead of as the integer part,"Nice, I think this looks good now.  I think Travis failed for unrelated reasons.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1670,2016-05-19T13:59:44Z,2016-05-23T13:22:36Z,2016-10-03T06:44:53Z,MERGED,True,5,0,1,https://github.com/jnohlgard,oma-lwm2m: Handle text/plain floatfix numbers without decimal point,1,[],https://github.com/contiki-os/contiki/pull/1670,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/1670#issuecomment-220978494,Fixes bug: If no decimal point is present then the entire number is treated as the decimal part instead of as the integer part,üëç Travis succeeded now. Merging.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1672,2016-05-20T11:54:33Z,2016-05-22T12:37:34Z,2017-10-27T20:05:49Z,MERGED,True,40,13,2,https://github.com/simonduq,Various Orchestra fixes,5,[],https://github.com/contiki-os/contiki/pull/1672,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1672,"This PR includes a number of fixes to Orchestra, including a fix to #1671","This PR includes a number of fixes to Orchestra, including a fix to #1671",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1672,2016-05-20T11:54:33Z,2016-05-22T12:37:34Z,2017-10-27T20:05:49Z,MERGED,True,40,13,2,https://github.com/simonduq,Various Orchestra fixes,5,[],https://github.com/contiki-os/contiki/pull/1672,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/1672#issuecomment-220709017,"This PR includes a number of fixes to Orchestra, including a fix to #1671","Is there any possibility that new_time_source() in orchestra-rule-eb-per-time-source.c has NULL for old or new? If it is the case, I think it would be better to add NULL checks there. Here is an example:
uint16_t old_ts = old != NULL ? get_node_timeslot(&old->addr) : 0xffff
uint16_t new_ts = new != NULL ? get_node_timeslot(&new->addr) : 0xffff",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1672,2016-05-20T11:54:33Z,2016-05-22T12:37:34Z,2017-10-27T20:05:49Z,MERGED,True,40,13,2,https://github.com/simonduq,Various Orchestra fixes,5,[],https://github.com/contiki-os/contiki/pull/1672,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1672#issuecomment-220764403,"This PR includes a number of fixes to Orchestra, including a fix to #1671","Good point, will fix",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1672,2016-05-20T11:54:33Z,2016-05-22T12:37:34Z,2017-10-27T20:05:49Z,MERGED,True,40,13,2,https://github.com/simonduq,Various Orchestra fixes,5,[],https://github.com/contiki-os/contiki/pull/1672,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1672#issuecomment-220764434,"This PR includes a number of fixes to Orchestra, including a fix to #1671","(or feel free to PR on my branch, your suggested fix is exactly what we need)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1672,2016-05-20T11:54:33Z,2016-05-22T12:37:34Z,2017-10-27T20:05:49Z,MERGED,True,40,13,2,https://github.com/simonduq,Various Orchestra fixes,5,[],https://github.com/contiki-os/contiki/pull/1672,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/1672#issuecomment-220768737,"This PR includes a number of fixes to Orchestra, including a fix to #1671","@simonduq OK, I'll send a PR later :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1672,2016-05-20T11:54:33Z,2016-05-22T12:37:34Z,2017-10-27T20:05:49Z,MERGED,True,40,13,2,https://github.com/simonduq,Various Orchestra fixes,5,[],https://github.com/contiki-os/contiki/pull/1672,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1672#issuecomment-220830208,"This PR includes a number of fixes to Orchestra, including a fix to #1671",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1673,2016-05-23T11:58:04Z,2016-06-03T17:46:31Z,2016-06-03T22:39:11Z,MERGED,True,5,5,2,https://github.com/njh,Changed read-only pointers to const in enc28j60,1,[],https://github.com/contiki-os/contiki/pull/1673,https://github.com/njh,1,https://github.com/contiki-os/contiki/pull/1673,"I have changed the ptr argument passed to init/send/write to const in the enc28j60 driver.
I made the change because I was passing a const from my own code, which was causing a compiler error.","I have changed the ptr argument passed to init/send/write to const in the enc28j60 driver.
I made the change because I was passing a const from my own code, which was causing a compiler error.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1673,2016-05-23T11:58:04Z,2016-06-03T17:46:31Z,2016-06-03T22:39:11Z,MERGED,True,5,5,2,https://github.com/njh,Changed read-only pointers to const in enc28j60,1,[],https://github.com/contiki-os/contiki/pull/1673,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1673#issuecomment-223561436,"I have changed the ptr argument passed to init/send/write to const in the enc28j60 driver.
I made the change because I was passing a const from my own code, which was causing a compiler error.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1673,2016-05-23T11:58:04Z,2016-06-03T17:46:31Z,2016-06-03T22:39:11Z,MERGED,True,5,5,2,https://github.com/njh,Changed read-only pointers to const in enc28j60,1,[],https://github.com/contiki-os/contiki/pull/1673,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1673#issuecomment-223646009,"I have changed the ptr argument passed to init/send/write to const in the enc28j60 driver.
I made the change because I was passing a const from my own code, which was causing a compiler error.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1673,2016-05-23T11:58:04Z,2016-06-03T17:46:31Z,2016-06-03T22:39:11Z,MERGED,True,5,5,2,https://github.com/njh,Changed read-only pointers to const in enc28j60,1,[],https://github.com/contiki-os/contiki/pull/1673,https://github.com/njh,4,https://github.com/contiki-os/contiki/pull/1673#issuecomment-223711442,"I have changed the ptr argument passed to init/send/write to const in the enc28j60 driver.
I made the change because I was passing a const from my own code, which was causing a compiler error.",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1674,2016-05-24T08:53:22Z,2016-05-24T08:53:28Z,2016-05-24T08:53:30Z,MERGED,True,1,1,1,https://github.com/alignan,Fixed typo in button definition,1,['bug'],https://github.com/contiki-os/contiki/pull/1674,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1674,"No brainer, fixes a typo in PLATFORM_HAS_BUTTON","No brainer, fixes a typo in PLATFORM_HAS_BUTTON",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/tidyjiang8,1,https://github.com/contiki-os/contiki/pull/1676,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/bkozak-scanimetrics,2,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221286386,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","Hello @tidyjiang8,
What is the trouble you were having with etimer_next_expiration_time?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/tidyjiang8,3,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221287971,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","Hi  @bkozak-scanimetrics ,
I think it's better to update time before return next_expiration, because there is an interval between the moment when calling update_time() and the moment when calling etimer_next_expiration_time. Or, doesn't it need ? Why ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/greg-king5,4,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221305490,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","update_time() adds now only because it is subtracted from tdist while the function looks for the earliest expiration time.  In other words, the effect of the current time is removed from the expiration time.  update_time() is called whenever any etimers are changed; therefore, next_expiration always is accurate.  This patch isn't needed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/bkozak-scanimetrics,5,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221305502,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","Ok, I think I get the issue. The next_expiration value may refer to a timer that has already expired by the time that you run etimer_expiration_time().
If you read the discussion on #1265 you'll see why it might not be possible to call update_time() from etimer_next_expiration_time() on some platforms.
What is the reason that you need a more accurate next expiration value? Perhaps you can run the etimer process from your application before calling etimer_expiration_time() in order to first deal with expired timers?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/greg-king5,6,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221329375,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","I want to point out that next_expiration and etimer_next_expiration_time() aren't good choices of names.  They are not what those names imply.  They don't refer to the ""next time""; they refer to the next etimer.  And, they don't refer to the next etimer that will expire; they refer to the next etimer that will send an event to a process.  [The function should have been called etimer_next_event_time().]",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/greg-king5,7,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221354202,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","After looking at update_time(), I have concluded that even the etimer_pending() test isn't needed in etimer_next_expiration_time().  If etimer_process() initiates next_expiration to zero when it initiates timerlist, then the variable always will be zero when there are no pending etimers.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/greg-king5,8,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221376548,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.",Forget two of my comments -- I had forgotten that etimer_next_expiration_time() might be called by ISRs.  They might run between an etimer change and a call to update_time().,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1676,2016-05-24T13:23:28Z,2016-05-25T02:30:29Z,2016-05-25T02:30:29Z,CLOSED,False,5,1,1,https://github.com/tidyjiang8,update time before return etimer next expiration time,1,[],https://github.com/contiki-os/contiki/pull/1676,https://github.com/tidyjiang8,9,https://github.com/contiki-os/contiki/pull/1676#issuecomment-221449305,"To get more precise etimer next expiration time, call update_time() to update time before return next_expiration.","I see, Thanks all.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1677,2016-05-24T17:59:26Z,2016-09-06T14:50:12Z,2016-10-03T06:45:08Z,MERGED,True,51,0,1,https://github.com/jnohlgard,oma-lwm2m: Add functionality to send object instance list as core link format,2,[],https://github.com/contiki-os/contiki/pull/1677,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1677,"Adds a response to the top level lwm2m object to list all its instances as corelf.
Useful in conjunction with Copper to get the instance list directly without going through an LWM2M server. (Copper automatically adds the new elements to the resource list when it receives a response with content type set to application/link-format)","Adds a response to the top level lwm2m object to list all its instances as corelf.
Useful in conjunction with Copper to get the instance list directly without going through an LWM2M server. (Copper automatically adds the new elements to the resource list when it receives a response with content type set to application/link-format)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1677,2016-05-24T17:59:26Z,2016-09-06T14:50:12Z,2016-10-03T06:45:08Z,MERGED,True,51,0,1,https://github.com/jnohlgard,oma-lwm2m: Add functionality to send object instance list as core link format,2,[],https://github.com/contiki-os/contiki/pull/1677,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1677#issuecomment-223561221,"Adds a response to the top level lwm2m object to list all its instances as corelf.
Useful in conjunction with Copper to get the instance list directly without going through an LWM2M server. (Copper automatically adds the new elements to the resource list when it receives a response with content type set to application/link-format)",@nfi can you take a look?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1677,2016-05-24T17:59:26Z,2016-09-06T14:50:12Z,2016-10-03T06:45:08Z,MERGED,True,51,0,1,https://github.com/jnohlgard,oma-lwm2m: Add functionality to send object instance list as core link format,2,[],https://github.com/contiki-os/contiki/pull/1677,https://github.com/jnohlgard,3,https://github.com/contiki-os/contiki/pull/1677#issuecomment-224208925,"Adds a response to the top level lwm2m object to list all its instances as corelf.
Useful in conjunction with Copper to get the instance list directly without going through an LWM2M server. (Copper automatically adds the new elements to the resource list when it receives a response with content type set to application/link-format)","This PR does not implement the whole Discover operation in the LWM2M TS, it only returns the object instances, no resources, but it is a step in the right direction IMO.
The specification states this regarding the Discover operation (GET with Accept: application/link-format):

5.4.2 Discover
The ‚ÄúDiscover‚Äù operation is used to discover LWM2M Attributes attached to an Object, Object Instances, and Resources. This operation can be used to discover which Resources are implemented for a given Object Instance. The returned payload is a list of application/link-format CoRE Links [RFC6690] for each targeted Object, Object Instance, or Resource, along with their attached Attributes.
The ‚ÄúDiscover‚Äù operation has the following parameters:



Parameter
Required
Default Value
Notes




Object ID
Yes
-
Indicates the Object.


Object Instance ID
No
-
Indicates the Object Instance.


Resource ID
No
-
Indicates the Resource.



If Object ID is only specified, the LWM2M Client MUST respond to the ‚ÄúDiscover‚Äù operation with the list of Object Instances and the list of their respective Resources implemented by the LWM2M Client for that Object. In addition the list of Attributes which have be assigned to this Object level (see section 5.3.1.1) are also returned.
For example:

when the ‚ÄúDiscover‚Äù operation targets an Object with Object ID of 3, the response to the operation could be:
</3>;pmin=10, </3/0/1>, <3/0/2>, </3/0/3>, </3/0/4>, <3/0/6>,<3/0/7>,<3/0/8>,<3/0/11>,<3/0/16>
which means that the LWM2M Client implements the Device Info Object (Instance 0)with Resource IDs of 1,2,3, 4 6,7,8,11,and 16 among the Resources of Devive Info Object, with an R-Attributes assigned to the Object level.
when the ‚ÄúDiscover‚Äùoperation targets an Object ID and Object Instance ID only, the list of Attributes assigned to that Object Instance MUST be reported, and the list of implemented Resources and their attached Attribute MUST be returned in the response as well. For example: if Object ID is 3 and Object Instance ID is 0, then
</3/0>;pmax=60, </3/0/1>, <3/0/2>, </3/0/3>, </3/0/4>, <3/0/6>;dim=8, <3/0/7>;dim=8; gt=50;lt=42.2,<3/0/8>;dim=8,<3/0/11>,<3/0/16>
means that regarding the Device Info Object Instance, an R-Attribute has been assigned to this Instance level. And the LWM2M Client implements the multiple Resources 6,7, and 8 with a dimension of 8 and supports 2 additional Notification parameters for Ressource 7
when the ‚ÄúDiscover‚Äùoperation targets an Object ID, Object Instance ID and Resource ID, the attributes of that Resource MUST be returned. In addition, the R-Attributes inherited from upper levels (Object and Object Instance level) are also reported for that Resource (The rules of Section 5.3.1.1 apply) For example: if Object ID is 3, Object Instance ID is 2, and Resource ID is 7, then
</3/2/7>;dim=8;pmin=10;pmax=60;gt=50;lt=42.2 with pmin assigned at the Object level, and pmax assigned at the Object Instance level

If a Resource, an Object Instance, or an Object has attributes for multiple LWM2M Servers, then one link is returned for each and the ep= attribute is used to indicate the Short Server ID of the LWM2M Server. For example: if Object ID is 3 and Object Instance ID is 0, and Resource ID is 7 with two Observe operations from two Servers, then
</3/0/7>;ep=1;dim=8;gt=50;lt=42.2,
</3/0/7>;ep=2;dim=8;pmax=300;gt=80;lt=75.5",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1677,2016-05-24T17:59:26Z,2016-09-06T14:50:12Z,2016-10-03T06:45:08Z,MERGED,True,51,0,1,https://github.com/jnohlgard,oma-lwm2m: Add functionality to send object instance list as core link format,2,[],https://github.com/contiki-os/contiki/pull/1677,https://github.com/nfi,4,https://github.com/contiki-os/contiki/pull/1677#issuecomment-244974996,"Adds a response to the top level lwm2m object to list all its instances as corelf.
Useful in conjunction with Copper to get the instance list directly without going through an LWM2M server. (Copper automatically adds the new elements to the resource list when it receives a response with content type set to application/link-format)",This looks reasonable to me.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1677,2016-05-24T17:59:26Z,2016-09-06T14:50:12Z,2016-10-03T06:45:08Z,MERGED,True,51,0,1,https://github.com/jnohlgard,oma-lwm2m: Add functionality to send object instance list as core link format,2,[],https://github.com/contiki-os/contiki/pull/1677,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/1677#issuecomment-244975099,"Adds a response to the top level lwm2m object to list all its instances as corelf.
Useful in conjunction with Copper to get the instance list directly without going through an LWM2M server. (Copper automatically adds the new elements to the resource list when it receives a response with content type set to application/link-format)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1678,2016-05-25T02:33:22Z,2016-05-25T03:03:14Z,2016-05-25T03:03:14Z,CLOSED,False,0,0,0,https://github.com/tidyjiang8,fix the chameleon raw hdrsize bug,2,[],https://github.com/contiki-os/contiki/pull/1678,https://github.com/tidyjiang8,1,https://github.com/contiki-os/contiki/pull/1678,fix the bug #1675,fix the bug #1675,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1678,2016-05-25T02:33:22Z,2016-05-25T03:03:14Z,2016-05-25T03:03:14Z,CLOSED,False,0,0,0,https://github.com/tidyjiang8,fix the chameleon raw hdrsize bug,2,[],https://github.com/contiki-os/contiki/pull/1678,https://github.com/tidyjiang8,2,https://github.com/contiki-os/contiki/pull/1678#issuecomment-221461459,fix the bug #1675,It's an operation error.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1679,2016-05-25T02:52:42Z,2016-06-03T12:40:12Z,2016-06-03T12:40:12Z,MERGED,True,1,4,1,https://github.com/tidyjiang8,fix the bug about chameleon raw hdrsize,1,[],https://github.com/contiki-os/contiki/pull/1679,https://github.com/tidyjiang8,1,https://github.com/contiki-os/contiki/pull/1679,"Fix the bug #1675.
If the length of some packet attribute is larger than 8, chameleon raw module's hdrsize() will return an incorrect header size.
This patch make the hdrsize() compatiblie with underlying packet attribute that the length is larger than 8.","Fix the bug #1675.
If the length of some packet attribute is larger than 8, chameleon raw module's hdrsize() will return an incorrect header size.
This patch make the hdrsize() compatiblie with underlying packet attribute that the length is larger than 8.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1679,2016-05-25T02:52:42Z,2016-06-03T12:40:12Z,2016-06-03T12:40:12Z,MERGED,True,1,4,1,https://github.com/tidyjiang8,fix the bug about chameleon raw hdrsize,1,[],https://github.com/contiki-os/contiki/pull/1679,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1679#issuecomment-223560981,"Fix the bug #1675.
If the length of some packet attribute is larger than 8, chameleon raw module's hdrsize() will return an incorrect header size.
This patch make the hdrsize() compatiblie with underlying packet attribute that the length is larger than 8.",@atiselsts do you agree with the fix?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1679,2016-05-25T02:52:42Z,2016-06-03T12:40:12Z,2016-06-03T12:40:12Z,MERGED,True,1,4,1,https://github.com/tidyjiang8,fix the bug about chameleon raw hdrsize,1,[],https://github.com/contiki-os/contiki/pull/1679,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/1679#issuecomment-223566861,"Fix the bug #1675.
If the length of some packet attribute is larger than 8, chameleon raw module's hdrsize() will return an incorrect header size.
This patch make the hdrsize() compatiblie with underlying packet attribute that the length is larger than 8.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1682,2016-05-25T15:39:39Z,2016-05-25T16:02:37Z,2017-10-27T20:05:47Z,MERGED,True,1,1,1,https://github.com/simonduq,Fix tsch-log bug,1,[],https://github.com/contiki-os/contiki/pull/1682,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1682,This fixes a bug in the logging of TSCH security level,This fixes a bug in the logging of TSCH security level,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1682,2016-05-25T15:39:39Z,2016-05-25T16:02:37Z,2017-10-27T20:05:47Z,MERGED,True,1,1,1,https://github.com/simonduq,Fix tsch-log bug,1,[],https://github.com/contiki-os/contiki/pull/1682,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1682#issuecomment-221623515,This fixes a bug in the logging of TSCH security level,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1683,2016-05-27T02:43:15Z,2016-06-04T05:59:50Z,2016-06-04T05:59:50Z,MERGED,True,1,0,1,https://github.com/msolters,Fix IPv6 HTTP URL parsing,1,"['enhancement', 'Core']",https://github.com/contiki-os/contiki/pull/1683,https://github.com/msolters,1,https://github.com/contiki-os/contiki/pull/1683,"Currently, http-socket uses a parse_url method which only works correctly with IPv4 hosts (e.g. http://192.168.1.1:3000).  When using an IPv6 host (e.g. http://[abcd::1]:3000), the port number is not parsed due to a pointer increment error, which leads to the algorithm assuming a default port of 80 even when the user code has specified otherwise.  This fix provides full URL parsing for IPv6 hosts, and does not break IPv4 functionality.","Currently, http-socket uses a parse_url method which only works correctly with IPv4 hosts (e.g. http://192.168.1.1:3000).  When using an IPv6 host (e.g. http://[abcd::1]:3000), the port number is not parsed due to a pointer increment error, which leads to the algorithm assuming a default port of 80 even when the user code has specified otherwise.  This fix provides full URL parsing for IPv6 hosts, and does not break IPv4 functionality.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1683,2016-05-27T02:43:15Z,2016-06-04T05:59:50Z,2016-06-04T05:59:50Z,MERGED,True,1,0,1,https://github.com/msolters,Fix IPv6 HTTP URL parsing,1,"['enhancement', 'Core']",https://github.com/contiki-os/contiki/pull/1683,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1683#issuecomment-223518787,"Currently, http-socket uses a parse_url method which only works correctly with IPv4 hosts (e.g. http://192.168.1.1:3000).  When using an IPv6 host (e.g. http://[abcd::1]:3000), the port number is not parsed due to a pointer increment error, which leads to the algorithm assuming a default port of 80 even when the user code has specified otherwise.  This fix provides full URL parsing for IPv6 hosts, and does not break IPv4 functionality.","ah ok, took me a while, but this seems correct to me indeed! Need to increment to move beyond the final ""]""
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1683,2016-05-27T02:43:15Z,2016-06-04T05:59:50Z,2016-06-04T05:59:50Z,MERGED,True,1,0,1,https://github.com/msolters,Fix IPv6 HTTP URL parsing,1,"['enhancement', 'Core']",https://github.com/contiki-os/contiki/pull/1683,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1683#issuecomment-223738730,"Currently, http-socket uses a parse_url method which only works correctly with IPv4 hosts (e.g. http://192.168.1.1:3000).  When using an IPv6 host (e.g. http://[abcd::1]:3000), the port number is not parsed due to a pointer increment error, which leads to the algorithm assuming a default port of 80 even when the user code has specified otherwise.  This fix provides full URL parsing for IPv6 hosts, and does not break IPv4 functionality.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1684,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/NickTompkins123,2,https://github.com/contiki-os/contiki/pull/1684#issuecomment-223358383,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","Would you be willing to show a demo as well for DIO23 on the launchpad?
Also how fast can this be called? I am looking at sampling at 20kHz....",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1684#issuecomment-223362002,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","You are catching me unawares here, Nick. What's on the LP's DIO_23?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/NickTompkins123,4,https://github.com/contiki-os/contiki/pull/1684#issuecomment-223364044,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","Nothing it just happens to be a common pin people setup for an ADC giving the examples that we can find for the 7x7 CC2650 launchpad...
I guess I am more or less curious about how to use the driver in the normal cc26xx-demo project for the launchpad",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/tonnenpinguin,5,https://github.com/contiki-os/contiki/pull/1684#issuecomment-223380618,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","If you're looking for data like the maximum ADC sample size, most answers lie within the technical reference manual published on Texas Instruments CC2650 product page (it's 200kS/s, restrictions apply).
Also, I'm pretty sure if you want to achieve this kind of sample rate you'll want to have a look at TIs cc26xxware documentation and implement the code necessary on your own, as you'll want to use continuous triggering and probably the adc fifo buffer as well.
Unfortunatly Texas Instruments for some reason unknown decided to make your life harder as it should have to be and does not provide a downloadlink on their page anymore. You have to download the whole TI-RTOS in order to get a copy of the cc26xxware documentation. Please note, that the current cc26xxware shipped with TI-RTOS is not the same as in the contiki submodule, so there might be some differences (consult the changelog for more info)
One last thing, for info about how to setup the new ADC sensor implementation you can also consult other platform's examples as as of this pull request the sensor uses contikis standard sensor interface.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/NickTompkins123,6,https://github.com/contiki-os/contiki/pull/1684#issuecomment-223390379,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.",If I were to create a timer using Contiki could I get a timer at a rate of 20kHz?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/tonnenpinguin,7,https://github.com/contiki-os/contiki/pull/1684#issuecomment-223535696,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","Realistically, no.
You would have to use a rtimer, which has 65536 tics per second on cc2650 (see RTIMER_ARCH_SECOND), however, the minimum amount of tics for any rtimer is 8, which gets you well below your desired sample rate.
Also I assume that the ADC won't be fast enough in manual trigger mode.
That being said, this discussion has nothing to do with the actual PR so if you have any further questions I would like to refer you to the contiki mailing list!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1684#issuecomment-224233173,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.",@g-oikonomou ready to merge?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/g-oikonomou,9,https://github.com/contiki-os/contiki/pull/1684#issuecomment-224264803,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.","Yeah, I'm happy with that one as is. @atiselsts any comments here?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/atiselsts,10,https://github.com/contiki-os/contiki/pull/1684#issuecomment-224266633,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1684,2016-05-29T13:59:58Z,2016-06-07T12:36:28Z,2016-06-13T11:06:12Z,MERGED,True,707,77,15,https://github.com/g-oikonomou,"Add CC13xx/CC26xx AUX controller module, ADC support, ALS driver and example",8,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1684,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1684#issuecomment-224266970,"A number of users have tried to use the CC26xx ADC with little success. There are two stumbling points:

Our LPM module unconditionally powers down the AUX domain when entering deep sleep.
The CCxxware OSC module unconditionally powers down AUX after every oscillator switch. This means that any radio on/off cycle will leave AUX powered down.

ADC sits within AUX and the two conditions above will make ADC inaccessible, even if the user has previously initialised it correctly.
This pull request adds a controller for the AUX domain and its module clocks. Code modules that require access to the AUX domain should now register themselves as consumers and specify the clocks within AUX that they need.
The controller provides a function that can be used to request AUX power down, either conditionally or unconditionally. We change our LPM logic to manipulate AUX through this function:

When we want to shut down the device, we request an unconditional AUX power down.
When we enter deep sleep, we request a conditional AUX power down. The AUX controller will power down the domain only if there are no registered consumers.

Because of this logic, consumer modules must unregister themselves when they no longer require AUX access, in order to allow lowest possible consumption under deep sleep.
Moving forward, this AUX power management logic will make our life easier when we come to the point of adding support for the sensor controller.
This pull changes our oscillator management module to manipulate AUX clocks through the controller.
With all of this in place, we can now actually use ADC, so this pull also adds two ADC examples:

A generic adc_sensor that can be used to perform a single-shot conversion on any ADC channel
A driver for the SmartRF06EB Ambient Light Sensor, demonstrated in the cc26xx simple demo.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1686,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.","This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222389768,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.","Travis fails because:

the tests do not build for avr-raven (unimplemented CFS API: probably missing setting to enable it),
test-coffee times out on sky + Cooja (it takes between 70 and 80 s on Firefly, so maybe the timeout should just be increased for sky, especially given the fact that the test fixes make it run longer).

I'll look into it.
@alignan In the README, you say that the examples do not build for sky because of a ROM overflow, but test-coffee actually builds fine with Travis, so are you referring to test-cfs or example-coffee, or is this comment no longer valid?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222475559,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",This comment is no longer valid,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222480489,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",Everything is working for the Zoul/RE-mote üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222492920,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",Nice work! Increasing the timeout for the Sky test should be fine; the test took 159 seconds when running it in MSPsim.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/bthebaudeau,6,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222562327,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.","Fixed.
I've also:

removed from the README the obsolete note about the ROM overflow for sky,
added to the README a note about the file system overflow for some of the examples for avr-raven,
added the build of cfs-coffee/sky to the regression tests.

Hopefully, Travis should now pass, though it has just failed in 21-large-rpl because of a simulation timeout, which seems completely unrelated. Perhaps it's just because Travis lags from time to time. I've just restarted it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222735981,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.","Please also include the openmote as well, is another cc2538-based platform.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/bthebaudeau,8,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222839700,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",Done.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/bthebaudeau,9,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222847308,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.","The first run of Travis timed out again in 21-large-rpl:
https://travis-ci.org/contiki-os/contiki/builds/134265866
Then I restarted the build, and the request has been accepted and the build created, but it does not start, even after several hours:
https://travis-ci.org/contiki-os/contiki/builds/134274432
https://travis-ci.org/contiki-os/contiki/builds/134305034
https://travis-ci.org/contiki-os/contiki/requests",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/nvt,10,https://github.com/contiki-os/contiki/pull/1686#issuecomment-222975147,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",I restarted the Travis tests now; let's hope for better luck this time.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/bthebaudeau,11,https://github.com/contiki-os/contiki/pull/1686#issuecomment-223105466,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.","@nvt Thanks. It has now passed.
@alignan You can now merge if this is OK for you.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1686,2016-05-29T22:09:16Z,2016-06-01T20:00:13Z,2016-06-01T20:08:26Z,MERGED,True,178,92,14,https://github.com/bthebaudeau,Unified CFS/Coffee examples,12,['enhancement'],https://github.com/contiki-os/contiki/pull/1686,https://github.com/alignan,12,https://github.com/contiki-os/contiki/pull/1686#issuecomment-223107206,"This PR aims at providing common CFS and Coffee examples for all the platforms supporting Coffee.
The examples are moved from sky to a common cfs-coffee example folder.
This PR supersedes #1490.",My pleasure üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1687,2016-05-30T08:49:49Z,2016-06-09T14:28:27Z,2016-06-09T14:34:48Z,MERGED,True,4,4,1,https://github.com/tsparber,rpl-ext-header: Use 8-octet unit for HBHO length,1,['Core'],https://github.com/contiki-os/contiki/pull/1687,https://github.com/tsparber,1,https://github.com/contiki-os/contiki/pull/1687,"According to RFC 2460 the length field of the Hop-by-Hop options header uses a 8-octet unit (multiple of 8 byte). This is also correctly handled in uip6.c, but not when setting up the header.
In a normal configuration the RPL_HOP_BY_HOP_LEN define is 8, so the current implementation works, but it is a bit misleading.
This fix is needed, when RPL_HOP_BY_HOP_LEN is more than 8. For example when adding extra elements to the uip_ext_hdr_opt_rpl for a custom header extension (eq. tracing packets).","According to RFC 2460 the length field of the Hop-by-Hop options header uses a 8-octet unit (multiple of 8 byte). This is also correctly handled in uip6.c, but not when setting up the header.
In a normal configuration the RPL_HOP_BY_HOP_LEN define is 8, so the current implementation works, but it is a bit misleading.
This fix is needed, when RPL_HOP_BY_HOP_LEN is more than 8. For example when adding extra elements to the uip_ext_hdr_opt_rpl for a custom header extension (eq. tracing packets).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1687,2016-05-30T08:49:49Z,2016-06-09T14:28:27Z,2016-06-09T14:34:48Z,MERGED,True,4,4,1,https://github.com/tsparber,rpl-ext-header: Use 8-octet unit for HBHO length,1,['Core'],https://github.com/contiki-os/contiki/pull/1687,https://github.com/tsparber,2,https://github.com/contiki-os/contiki/pull/1687#issuecomment-224632155,"According to RFC 2460 the length field of the Hop-by-Hop options header uses a 8-octet unit (multiple of 8 byte). This is also correctly handled in uip6.c, but not when setting up the header.
In a normal configuration the RPL_HOP_BY_HOP_LEN define is 8, so the current implementation works, but it is a bit misleading.
This fix is needed, when RPL_HOP_BY_HOP_LEN is more than 8. For example when adding extra elements to the uip_ext_hdr_opt_rpl for a custom header extension (eq. tracing packets).","Rebased as #1508 has been merged
I'm not sure whether to use >> 3 or / 8, as the rest of rpl-ext-header.c is also sometimes using the shift to express the division and sometimes the division directly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1687,2016-05-30T08:49:49Z,2016-06-09T14:28:27Z,2016-06-09T14:34:48Z,MERGED,True,4,4,1,https://github.com/tsparber,rpl-ext-header: Use 8-octet unit for HBHO length,1,['Core'],https://github.com/contiki-os/contiki/pull/1687,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1687#issuecomment-224703660,"According to RFC 2460 the length field of the Hop-by-Hop options header uses a 8-octet unit (multiple of 8 byte). This is also correctly handled in uip6.c, but not when setting up the header.
In a normal configuration the RPL_HOP_BY_HOP_LEN define is 8, so the current implementation works, but it is a bit misleading.
This fix is needed, when RPL_HOP_BY_HOP_LEN is more than 8. For example when adding extra elements to the uip_ext_hdr_opt_rpl for a custom header extension (eq. tracing packets).","Now that you mention it I think I prefer >> 3, even though I guess/hope most compilers would compile the code to a shift anyway.
Happy with this PR regardless, thanks for the fix üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1687,2016-05-30T08:49:49Z,2016-06-09T14:28:27Z,2016-06-09T14:34:48Z,MERGED,True,4,4,1,https://github.com/tsparber,rpl-ext-header: Use 8-octet unit for HBHO length,1,['Core'],https://github.com/contiki-os/contiki/pull/1687,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/1687#issuecomment-224911867,"According to RFC 2460 the length field of the Hop-by-Hop options header uses a 8-octet unit (multiple of 8 byte). This is also correctly handled in uip6.c, but not when setting up the header.
In a normal configuration the RPL_HOP_BY_HOP_LEN define is 8, so the current implementation works, but it is a bit misleading.
This fix is needed, when RPL_HOP_BY_HOP_LEN is more than 8. For example when adding extra elements to the uip_ext_hdr_opt_rpl for a custom header extension (eq. tracing packets).",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1688,2016-05-30T08:56:15Z,2016-06-03T08:12:02Z,2016-06-03T20:18:49Z,MERGED,True,1,1,1,https://github.com/tsparber,Fixed rssi-scanner example,1,['nominated'],https://github.com/contiki-os/contiki/pull/1688,https://github.com/tsparber,1,https://github.com/contiki-os/contiki/pull/1688,"Fixes  #1664
(Tested using sky platform)","Fixes  #1664
(Tested using sky platform)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1688,2016-05-30T08:56:15Z,2016-06-03T08:12:02Z,2016-06-03T20:18:49Z,MERGED,True,1,1,1,https://github.com/tsparber,Fixed rssi-scanner example,1,['nominated'],https://github.com/contiki-os/contiki/pull/1688,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1688#issuecomment-222921853,"Fixes  #1664
(Tested using sky platform)","üëç but for me it seems like a hack, I have this change done in my personal branch but somehow doesn't seem ""correct"".  Nevertheless is an example currently broken, and I haven't had the time to fix properly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1688,2016-05-30T08:56:15Z,2016-06-03T08:12:02Z,2016-06-03T20:18:49Z,MERGED,True,1,1,1,https://github.com/tsparber,Fixed rssi-scanner example,1,['nominated'],https://github.com/contiki-os/contiki/pull/1688,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1688#issuecomment-223517751,"Fixes  #1664
(Tested using sky platform)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/kqorany,1,https://github.com/contiki-os/contiki/pull/1689,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.","ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1689#issuecomment-223800592,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.","I'm OK with the PR, includes a new feature and probably won't break anything, but I would recommend to squash into a single commit.  I cannot review further as I'm not familiar with Mullticast, @g-oikonomou perhaps?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/kqorany,3,https://github.com/contiki-os/contiki/pull/1689#issuecomment-223857907,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.",Thanks @alignan for your comments. I am looking forward to the feedback of @g-oikonomou,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1689#issuecomment-223916125,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.","Travis CI fails:
Building example 06: ipv6/multicast/ for target cc2530dk
ipv6/multicast/ cc2530dk: FAIL ‡≤†.‡≤†
from type 'struct rpl_dag generic* fixed'
to type 'int fixed'
../../../core/net/ipv6/multicast/esmrf.c:153: error 20: Undefined identifier 'dag_t'
../../../core/net/ipv6/multicast/esmrf.c:153: error 27: Pointer required
../../../core/net/ipv6/multicast/esmrf.c:153: error 78: incompatible types
from type 'void'
to type 'const-void generic* fixed'
../../../core/net/ipv6/multicast/esmrf.c:258: warning 85: in function mcast_fwd unreferenced function argument : 'p'
make[1]: *** [obj_cc2530dk/esmrf.rel] Error 1
make[1]: Leaving directory `/home/travis/build/contiki-os/contiki/examples/ipv6/multicast'
make: Leaving directory `/home/travis/build/contiki-os/contiki/regression-tests/14-compile-8051-ports'",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/kqorany,5,https://github.com/contiki-os/contiki/pull/1689#issuecomment-224003301,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.","Actually, I did not understand the problem. This is not the case locally. If you could guide me, this will be appreciated.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1689#issuecomment-224234750,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.","Check Travis log for details:
Building example 06: ipv6/multicast/ for target cc2530dk
ipv6/multicast/ cc2530dk: FAIL ‡≤†.‡≤†
from type 'struct rpl_dag generic* fixed'
to type 'int fixed'
../../../core/net/ipv6/multicast/esmrf.c:153: error 20: Undefined identifier 'dag_t'
../../../core/net/ipv6/multicast/esmrf.c:153: error 27: Pointer required
../../../core/net/ipv6/multicast/esmrf.c:153: error 78: incompatible types
from type 'void'
to type 'const-void generic* fixed'
../../../core/net/ipv6/multicast/esmrf.c:258: warning 85: in function mcast_fwd unreferenced function argument : 'p'
make[1]: *** [obj_cc2530dk/esmrf.rel] Error 1
make[1]: Leaving directory `/home/travis/build/contiki-os/contiki/examples/ipv6/multicast'
make: Leaving directory `/home/travis/build/contiki-os/contiki/regression-tests/14-compile-8051-ports'

Fails to build the test for the cc2530dk target.
As this is a change in a common library for several platforms, please make sure this is fixed.
Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/kqorany,7,https://github.com/contiki-os/contiki/pull/1689#issuecomment-224399917,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.",The Travis checks have passed successfully. Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1689#issuecomment-224405117,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.","Great!
Now just one last thing, please squash your commits into a single one and edit the commit message:
Add files via upload
Add files via upload
Delete Makefile
Delete project-conf.h
Delete multicast(ESMRF).csc
Delete root.c
Delete sink.c
Delete source.c
Update esmrf.c
Update esmrf.c
update the coding style",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1689,2016-05-30T22:11:47Z,2016-06-28T22:23:30Z,2016-06-28T22:23:30Z,MERGED,True,498,0,5,https://github.com/kqorany,A new multicast engine called ESMRF for RPL,1,"['Core', 'fix required: needs-rebase', 'new feature', 'Network']",https://github.com/contiki-os/contiki/pull/1689,https://github.com/kqorany,9,https://github.com/contiki-os/contiki/pull/1689#issuecomment-224442457,"ESMRF is an enhanced version of the SMRF engine with the aim of resolving the sending limitation of SMRF to allow any node within the DODAG to send multicast traffic up and down the RPL tree. you could find all details in the following paper https://drive.google.com/file/d/0B69lRSPVb6vDZ3AwWHk1S25sNGc/view?usp=sharing
The main idea of ESMRF is the multicast-on-behalf service which gives the RPL root the ability to forward the multicast traffic on behalf of the original sources. We demonstrated that ESMRF has the same performance with the SMRF in case the root of RPL is the source of multicast traffic and provides a promising performance in the case of the leaf nodes are  the source of multicast traffic in which case SMRF totally fails to deliver any multicast packets.",The squashing and editing are done,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1690,2016-05-31T11:03:56Z,2016-06-13T18:48:56Z,2016-06-13T18:48:56Z,CLOSED,False,125,125,41,https://github.com/cquijano,New cc26xxware,2,[],https://github.com/contiki-os/contiki/pull/1690,https://github.com/cquijano,1,https://github.com/contiki-os/contiki/pull/1690,"As part os a debug, I upgraded cc26xxware. Use it as you prefer ( you can simply ignore it ), but if you are going to updated it, it could be a starting point.
Remember update the cc26xxware submodule:","As part os a debug, I upgraded cc26xxware. Use it as you prefer ( you can simply ignore it ), but if you are going to updated it, it could be a starting point.
Remember update the cc26xxware submodule:",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1690,2016-05-31T11:03:56Z,2016-06-13T18:48:56Z,2016-06-13T18:48:56Z,CLOSED,False,125,125,41,https://github.com/cquijano,New cc26xxware,2,[],https://github.com/contiki-os/contiki/pull/1690,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1690#issuecomment-222803436,"As part os a debug, I upgraded cc26xxware. Use it as you prefer ( you can simply ignore it ), but if you are going to updated it, it could be a starting point.
Remember update the cc26xxware submodule:","In principle this is a welcome change. However, this should only ever touch cc13xx/cc26xx files.
Please clean up the pull request to remove all unrelated changes and I'll review.
Cheers.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1690,2016-05-31T11:03:56Z,2016-06-13T18:48:56Z,2016-06-13T18:48:56Z,CLOSED,False,125,125,41,https://github.com/cquijano,New cc26xxware,2,[],https://github.com/contiki-os/contiki/pull/1690,https://github.com/cquijano,3,https://github.com/contiki-os/contiki/pull/1690#issuecomment-223046848,"As part os a debug, I upgraded cc26xxware. Use it as you prefer ( you can simply ignore it ), but if you are going to updated it, it could be a starting point.
Remember update the cc26xxware submodule:","Thanks @g-oikonomou , now I am focused on my new custom board based on cc2650, As soon as I can find some time I will clean the pull request.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1690,2016-05-31T11:03:56Z,2016-06-13T18:48:56Z,2016-06-13T18:48:56Z,CLOSED,False,125,125,41,https://github.com/cquijano,New cc26xxware,2,[],https://github.com/contiki-os/contiki/pull/1690,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1690#issuecomment-225672887,"As part os a debug, I upgraded cc26xxware. Use it as you prefer ( you can simply ignore it ), but if you are going to updated it, it could be a starting point.
Remember update the cc26xxware submodule:",I've pretty much completed the port to .16941 for both CCxxwares. Closing this.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1691,2016-05-31T20:13:07Z,2016-06-01T12:30:22Z,2016-06-01T12:30:22Z,CLOSED,False,7552,0,37,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,3,[],https://github.com/contiki-os/contiki/pull/1691,https://github.com/casaroli,1,https://github.com/contiki-os/contiki/pull/1691,we fixed the adding of the [ and ] characters to the Host: of the http request.,we fixed the adding of the [ and ] characters to the Host: of the http request.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1691,2016-05-31T20:13:07Z,2016-06-01T12:30:22Z,2016-06-01T12:30:22Z,CLOSED,False,7552,0,37,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,3,[],https://github.com/contiki-os/contiki/pull/1691,https://github.com/tonnenpinguin,2,https://github.com/contiki-os/contiki/pull/1691#issuecomment-222953173,we fixed the adding of the [ and ] characters to the Host: of the http request.,"I think some unintended commits (adding a new platform) may have made their way into this pr,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1691,2016-05-31T20:13:07Z,2016-06-01T12:30:22Z,2016-06-01T12:30:22Z,CLOSED,False,7552,0,37,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,3,[],https://github.com/contiki-os/contiki/pull/1691,https://github.com/casaroli,3,https://github.com/contiki-os/contiki/pull/1691#issuecomment-222969475,we fixed the adding of the [ and ] characters to the Host: of the http request.,"Oh. This is true.
I gonna fix it today.
Sorry for the confusion.
On qua, 1 de jun de 2016 at 07:25 Berni notifications@github.com wrote:

I think some unintended commits (adding a new platform) may have made
their way into this pr,
‚Äî
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub
#1691 (comment),
or mute the thread
https://github.com/notifications/unsubscribe/ADszaNVBxAlnLtV_XweQdIAJWkNZtaImks5qHV38gaJpZM4Iq6SY
.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1692,2016-05-31T23:50:54Z,2016-06-03T08:10:36Z,2016-06-03T12:21:55Z,MERGED,True,13,6,1,https://github.com/pablocorbalan,RIME: Extend unicast example to include a sent callback.,1,['enhancement'],https://github.com/contiki-os/contiki/pull/1692,https://github.com/pablocorbalan,1,https://github.com/contiki-os/contiki/pull/1692,"This PR simply adds a packet sent callback to the unicast connection used in the example to better illustrate the possibilities of the unicast primitive. Every time a packet is sent the callback is called and prints the linkaddr_t destination, the MAC status of the message sent, and the link layer number of transmissions of the packet. The PR also removes some unneeded headers for the example.","This PR simply adds a packet sent callback to the unicast connection used in the example to better illustrate the possibilities of the unicast primitive. Every time a packet is sent the callback is called and prints the linkaddr_t destination, the MAC status of the message sent, and the link layer number of transmissions of the packet. The PR also removes some unneeded headers for the example.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1692,2016-05-31T23:50:54Z,2016-06-03T08:10:36Z,2016-06-03T12:21:55Z,MERGED,True,13,6,1,https://github.com/pablocorbalan,RIME: Extend unicast example to include a sent callback.,1,['enhancement'],https://github.com/contiki-os/contiki/pull/1692,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1692#issuecomment-223411914,"This PR simply adds a packet sent callback to the unicast connection used in the example to better illustrate the possibilities of the unicast primitive. Every time a packet is sent the callback is called and prints the linkaddr_t destination, the MAC status of the message sent, and the link layer number of transmissions of the packet. The PR also removes some unneeded headers for the example.","Thanks! I have been using this also in a separate branch.
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1692,2016-05-31T23:50:54Z,2016-06-03T08:10:36Z,2016-06-03T12:21:55Z,MERGED,True,13,6,1,https://github.com/pablocorbalan,RIME: Extend unicast example to include a sent callback.,1,['enhancement'],https://github.com/contiki-os/contiki/pull/1692,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1692#issuecomment-223517488,"This PR simply adds a packet sent callback to the unicast connection used in the example to better illustrate the possibilities of the unicast primitive. Every time a packet is sent the callback is called and prints the linkaddr_t destination, the MAC status of the message sent, and the link layer number of transmissions of the packet. The PR also removes some unneeded headers for the example.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1695,2016-06-01T11:47:02Z,2016-06-01T21:34:42Z,2016-06-01T21:34:44Z,MERGED,True,0,0,1,https://github.com/alignan,Fixed CC2538/PIC labels being swapped,1,"['bug', 'documentation']",https://github.com/contiki-os/contiki/pull/1695,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1695,Simply updating the RE-Mote front pin-out image with the JTAG's PIC/CC2538 being swapped,Simply updating the RE-Mote front pin-out image with the JTAG's PIC/CC2538 being swapped,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1695,2016-06-01T11:47:02Z,2016-06-01T21:34:42Z,2016-06-01T21:34:44Z,MERGED,True,0,0,1,https://github.com/alignan,Fixed CC2538/PIC labels being swapped,1,"['bug', 'documentation']",https://github.com/contiki-os/contiki/pull/1695,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1695#issuecomment-222976407,Simply updating the RE-Mote front pin-out image with the JTAG's PIC/CC2538 being swapped,"Thanks for the very quick response to this! Is the new image ""broken"" or is it just my browser that shows only the upper parts?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1695,2016-06-01T11:47:02Z,2016-06-01T21:34:42Z,2016-06-01T21:34:44Z,MERGED,True,0,0,1,https://github.com/alignan,Fixed CC2538/PIC labels being swapped,1,"['bug', 'documentation']",https://github.com/contiki-os/contiki/pull/1695,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1695#issuecomment-222976641,Simply updating the RE-Mote front pin-out image with the JTAG's PIC/CC2538 being swapped,I though it was my VM browser... pushing a new one again :-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1695,2016-06-01T11:47:02Z,2016-06-01T21:34:42Z,2016-06-01T21:34:44Z,MERGED,True,0,0,1,https://github.com/alignan,Fixed CC2538/PIC labels being swapped,1,"['bug', 'documentation']",https://github.com/contiki-os/contiki/pull/1695,https://github.com/joakimeriksson,4,https://github.com/contiki-os/contiki/pull/1695#issuecomment-222977821,Simply updating the RE-Mote front pin-out image with the JTAG's PIC/CC2538 being swapped,Looks perfect now! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/casaroli,1,https://github.com/contiki-os/contiki/pull/1696,sorry I had to create a new PR.,sorry I had to create a new PR.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/vsaw,2,https://github.com/contiki-os/contiki/pull/1696#issuecomment-222982937,sorry I had to create a new PR.,"This is actually not related to your code but I was wondering if you might fix this as well to make your pull-request more robust:
The problem is that the parse_url might not \0 terminate the host string. The way I see it: If it is passed an URL, where the host is longer than MAX_HOSTLEN, then the host string will not be terminated.
Two things should be done to fix this.

parse_url  should check if the host fits into the destination buffer and return the error value 0 if it did not.
Your code should consider using memchr and first check for the \0 termination before looking for IPv6 addresses.

Ideally parse_url   should also get the size of the host buffer to remove the assumption that the host and path buffers have a certain size.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/casaroli,3,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223606588,sorry I had to create a new PR.,"@vsaw thanks for the comments.
I now included a check for the \0 char but I think it was simpler to add just after the parsing.
I also changed the my functions to use memchr instead of strchr.
What do you think?
BR",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/vsaw,4,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223755933,sorry I had to create a new PR.,"I'd still prefer having parse_url fixed as this is an IMHO unsafe function if used wrong.
But at least your code is now fixed üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223772019,sorry I had to create a new PR.,Looks good to me except for code style: please remove spaces between if and (,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/casaroli,6,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223774764,sorry I had to create a new PR.,"Fixed code style.
@vsaw The first check fixes exactly the parse_url function. I don't see a problem anymore. Is there anything I could do better for that fix?
BR",True,{'THUMBS_UP': ['https://github.com/leoribg']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/vsaw,7,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223776844,sorry I had to create a new PR.,"Your code invokes it correctly. The danger I see with parse_url is that it is invoked in two more place which might not take all the precaution you did.
Therefore I would have loved seeing a more ""defensive"" behaviour of parse_url, so that it becomes easier to use the function correctly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223777435,sorry I had to create a new PR.,"I feel this is a fair concern @vsaw but could go in a different PR, what do you think?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/vsaw,9,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223799192,sorry I had to create a new PR.,@simonduq Sure.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/alignan,10,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223800317,sorry I had to create a new PR.,Could you please create an issue about parse_url being unsafe? just to keep this up.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/vsaw,11,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223801307,sorry I had to create a new PR.,@alignan Done. See #1707,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/alignan,12,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223801949,sorry I had to create a new PR.,"@vsaw Thanks!
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1696,2016-06-01T12:30:50Z,2016-06-05T10:46:59Z,2016-06-05T10:46:59Z,MERGED,True,13,0,1,https://github.com/casaroli,fix ipv6 http socket host handling as in RFC2732,5,"['bug', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1696,https://github.com/simonduq,13,https://github.com/contiki-os/contiki/pull/1696#issuecomment-223806199,sorry I had to create a new PR.,Thanks! üëç,True,{'THUMBS_UP': ['https://github.com/leoribg']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1698,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.","With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223137216,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.","Seems more like a hack than a fix, but if this helps reducing the PR failing due to unrelated reasons, I'm OK.  Is there an issue created about the large-rpl test failing? perhaps it would be better to have a reminder about it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/bthebaudeau,3,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223158736,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.","Yes: issue #1630.
A few stats about the passing large-rpl tests (simulation speeds biased with test overhead):

https://travis-ci.org/contiki-os/contiki/jobs/134587493: Test ended at simulation time: 1591131808 Elapsed time 16 min 57 sec -> simulation speed ~= 1.5645347178,
https://travis-ci.org/contiki-os/contiki/jobs/134582158: Test ended at simulation time: 2141630920 Elapsed time 20 min 21 sec -> simulation speed ~= 1.75399747748,
https://travis-ci.org/contiki-os/contiki/jobs/134581046: Test ended at simulation time: 2087087576 Elapsed time 20 min 20 sec -> simulation speed ~= 1.71072752131,
https://travis-ci.org/contiki-os/contiki/jobs/134578810: Test ended at simulation time: 2295955272 Elapsed time 21 min 47 sec -> simulation speed ~= 1.75666049885,
https://travis-ci.org/contiki-os/contiki/jobs/134561389: Test ended at simulation time: 1062261272 Elapsed time 11 min 42 sec -> simulation speed ~= 1.51319269516.

Most of the failing ones have reached 95% of the test upon timeout.
That's why increasing the simulated timeout from 40 min to 50 min should hopefully do the trick. If the test is effective (without any bug), that could be enough, unless we want to make it more efficient. I have not looked into it, so I can't say. @simonduq or @joakimeriksson would know.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223260008,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.",Thanks for the explanation! please rebase to see if Travis is happy now,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223397588,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.","I'm not really sure, but isn't the test stopped by a Travis timeout rather than Cooja? This is what the variable end simulation time hints me. I don't know the details of this test but I know it involves connecting to an external server (contiki-os.org) and might sometimes suffer from bad network/server conditions.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/bthebaudeau,6,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223419829,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.","According to the excerpts of the log below, it looks more like a timeout inside the simulation than like a Travis timeout:
https://travis-ci.org/contiki-os/contiki/jobs/134433249:
INFO [Thread-5] (LogScriptEngine.java:375) - Timeout event @ 2400000000
INFO [Thread-4] (LogScriptEngine.java:309) - Test script finished
INFO [Thread-5] (Simulation.java:311) - Simulation main loop stopped, system time: 1464790311810    Duration: 1278385 ms    Simulated time 2400000 ms   Ratio 1.8773687113037152

Data compelete 11, heard 49 in total
TEST TIMEOUT
TEST FAILED
Test ended at simulation time: 2400000000

With this PR, the test can now succeed beyond the previous simulation timeout:
https://travis-ci.org/contiki-os/contiki/jobs/134852929:
Data compelete 18, heard 50 in total
TEST OK
Test ended at simulation time: 2438535008

But Travis had another issue this time:
https://travis-ci.org/contiki-os/contiki/jobs/134852924:
$ WGET=""travis_retry wget --continue --tries=20 --waitretry=10 --retry-connrefused --no-dns-cache --timeout 300""
$ sudo apt-get -qq update
W: Failed to fetch http://downloads-distro.mongodb.org/repo/debian-sysvinit/dists/dist/10gen/i18n/Translation-en_US  Unable to connect to downloads-distro.mongodb.org:http:
W: Failed to fetch http://downloads-distro.mongodb.org/repo/debian-sysvinit/dists/dist/10gen/i18n/Translation-en  Unable to connect to downloads-distro.mongodb.org:http:
E: Some index files failed to download. They have been ignored, or old ones used instead.
The command ""sudo apt-get -qq update"" failed and exited with 100 during .

This issue seems to be temporary, so I restart Travis.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/bthebaudeau,7,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223438595,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.",Travis is happy!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1698,2016-06-01T21:40:19Z,2016-06-03T08:10:59Z,2016-06-03T23:32:39Z,MERGED,True,1,1,1,https://github.com/bthebaudeau,21-large-rpl: Avoid frequent timeout in Travis CI,1,['travis'],https://github.com/contiki-os/contiki/pull/1698,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1698#issuecomment-223506076,"With a timeout set to 40 min, this test often failed at about 95% of the script, causing many spurious pull request test failures. Increase the timeout to 50 min.",Ah ok I got confused with the previous post. Looks good then! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1701,2016-06-02T08:54:32Z,2016-06-02T10:02:50Z,2016-06-02T23:04:41Z,MERGED,True,7,10,4,https://github.com/alignan,Fix broken nrf52dk Travis build,3,[],https://github.com/contiki-os/contiki/pull/1701,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1701,"Fixes #1699, in summary:

Updated PPA source
Moved nrf52dk regression tests as it was overlapping a previous directory
Reverted the rtimer width redefinition and disabled timer-test from regression tests
Removed outdated address print","Fixes #1699, in summary:

Updated PPA source
Moved nrf52dk regression tests as it was overlapping a previous directory
Reverted the rtimer width redefinition and disabled timer-test from regression tests
Removed outdated address print",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1701,2016-06-02T08:54:32Z,2016-06-02T10:02:50Z,2016-06-02T23:04:41Z,MERGED,True,7,10,4,https://github.com/alignan,Fix broken nrf52dk Travis build,3,[],https://github.com/contiki-os/contiki/pull/1701,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1701#issuecomment-223248887,"Fixes #1699, in summary:

Updated PPA source
Moved nrf52dk regression tests as it was overlapping a previous directory
Reverted the rtimer width redefinition and disabled timer-test from regression tests
Removed outdated address print",Merging already as Travis CI is holding back,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,1,https://github.com/contiki-os/contiki/pull/1703,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1703#issuecomment-223546789,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Please also include the cc2538dk and zoul, it should be pretty much the same as the openmote-cc2538.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1703#issuecomment-223548054,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","There is a frequency hopping block in core/lib/iq-seeder.c, is this part of the commit also? are you implementing frequency hop as well? sorry for asking something obvious,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,4,https://github.com/contiki-os/contiki/pull/1703#issuecomment-223561297,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Thanks for your comments. I will try to address them.
Concerning iq-seeder.c - that thing is responsible for generating a cryptographic seed at start up. For this purpose, I currently use I/Q LSBs as an entropy source. Yet, I/Q LSBs are potentially vulnerable to eavesdropping and interference. While I think it should be hard to launch successful attacks on this, channel hopping is intended to further complicate attacks. However, I am currently working on a seeder that is more secure than this one.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,5,https://github.com/contiki-os/contiki/pull/1703#issuecomment-223749757,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",I applied the changes you suggested. Travis should pass after a restart.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,6,https://github.com/contiki-os/contiki/pull/1703#issuecomment-223897994,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I think it is also a good idea to remove noncoresec entirely, isn't it?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225607298,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I'm testing using 2 nodes with the broadcast application running, I have a couple of questions (sorry in advance if this is something obvious):

I only receive packets on one node, not in both as expected
Using a generic sniffer I see the Test payload on the open, is this expected?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,8,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225625024,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Thanks for testing. Indeed, it is expected that you see Test since the security level of the example is set to 2. Just change the security level to 5,6, or 7 to enable encryption. However, you should actually receive packets on both nodes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225628270,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Thanks for the fast response.  I don't have a concrete preference, but to try to follow how an user would test the application based on what is documented.  I think just adding a note about enabling back TCP should do.  I will continue testing, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bthebaudeau,10,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225736642,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Building examples/llsec/ipv6-demos/rpl-border-router for Zoul Firefly generates a lot of warnings.
Nothing is received with examples/llsec/ipv6-demos/simple-udp-rpl on my Zoul Firefly boards, whereas examples/ipv6/simple-udp-rpl works fine.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/vamsi-chikati,11,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225765951,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Is llsec supposed to be working on all platforms, theoretically?
We had limited success testing earlier version of llsec in econotag. If you
could confirm, we'll try testing on econotag.
14 ‡∞ú‡±Ç‡∞®‡±ç 2016 4:49 AM‡∞®, ""Beno√Æt Th√©baudeau"" notifications@github.com
‡∞µ‡±ç‡∞∞‡∞æ‡∞∏‡∞ø‡∞®‡∞¶‡∞ø:

Building examples/llsec/ipv6-demos/rpl-border-router for Zoul Firefly
generates a lot of warnings.
Nothing is received with examples/llsec/ipv6-demos/simple-udp-rpl on my
Zoul Firefly boards, whereas examples/ipv6/simple-udp-rpl works fine.
‚Äî
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub
#1703 (comment), or
mute the thread
https://github.com/notifications/unsubscribe/AH4a2iO8zLH-1GyxkCwgbWy3Pllk2pH7ks5qLeVngaJpZM4ItY88
.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,12,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225830552,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@bthebaudeau Regarding examples/llsec/ipv6-demos/simple-udp-rpl, you may just have to wait for a little while until session key establishment is done. To see what is going on, you can enable debugging in akes.c. Concerning examples/llsec/ipv6-demos/rpl-border-router, I only tried this one on TelosB motes, yet. What is also on my TODO list is making SLIP work. I will see what I can do.
@vamsi-chikati Porting the adaptivesec_driver to econtags requires implementing an aes_128_driver, as well as a csprng_seeder. However, I actually could implement a general csprng_seeder that is configured with a static seed at compilation time to ease porting to other platforms.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,13,https://github.com/contiki-os/contiki/pull/1703#issuecomment-225835349,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",@kkrentz send me an email and we'll fix your lack of RE-Motes üòâ,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bthebaudeau,14,https://github.com/contiki-os/contiki/pull/1703#issuecomment-226644100,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz With DEBUG set to 1 in akes.c, examples/llsec/ipv6-demos/simple-udp-rpl works fine, so there is probably a timing issue.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/g-oikonomou,15,https://github.com/contiki-os/contiki/pull/1703#issuecomment-226697671,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hi folks. The bullets in the OP are things that need solved. However, I am finding it very difficult to understand the reasoning behind some of the commits proposed here. This includes  all the pub-sub business and also the reboot app.
I cannot immediately understand why we need an LLsec-specific border router example. All project-conf.h files in those examples are very messy, with those #if 0 blocks.
I see that you enclose entire .c files inside #if guards. Is this really required? In other words, will the file fail to compile if those macros are not set?
I am finding it difficult to understand how you are deriving pairwise keys. Is this some sort of key agreement? If so, is this something well-established? Is this something that you have designed / published yourself?
For channel-hopping in the respective seeder, best not hard-code channels in [11, 26], since we are getting traction with sub-ghz radios. Perhaps get min/max through the radio API (RADIO_CONST_CHANNEL_MIN, RADIO_CONST_CHANNEL_MAX).
Generally speaking, security and crypto are things difficult to understand (and to therefore configure properly based on requirements). In this context, some documentation would be nice :) That's a general comment that applies to what we already have on master by the way.
Lastly, perhaps of zero consequence, those ""Your Name committed"" don't look very nice",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,16,https://github.com/contiki-os/contiki/pull/1703#issuecomment-227119936,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","demos: I could remove the demos since I think that the description on https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec is sufficient for getting started
reboot app: It is part of the demos, which is why I could remove it, too
pub-sub: This is a flexible way to handle incoming 802.15.4 MAC command frames. The way it works is that you register for 802.15.4 MAC command frames. Subsequently, you get called upon receipt of a command frame and report report back if you consumed it.
pairwise keys: The key derivation process is pretty common. It derives a pairwise session key from two random numbers, which are contributed by both sides. Our whole key establishment scheme is explained in a paper, which is linked at the bottom of  https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.
seeder: I could do this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,17,https://github.com/contiki-os/contiki/pull/1703#issuecomment-229966358,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Updates:

I removed all the demo files.
I updated the README.
When adapting the current rpl-border-router example according to my README, the rpl-border-router now works on Sky-, Re-, and Open-Motes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,18,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230032450,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@g-oikonomou I was able to remove a couple of #if guards, but removing the remaining ones would cause compiler errors and warnings.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bthebaudeau,19,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230183291,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I've tested this update with examples/ipv6/simple-udp-rpl/broadcast-example.c on my Zoul Firefly boards:

If this example is unchanged, it works fine.
If I follow the instructions from your README:

I still get a range or timing issue with #define NETSTACK_CONF_RDC contikimac_driver.
The boards keep resetting with #define NETSTACK_CONF_RDC nullrdc_driver.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bthebaudeau,20,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230360156,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",I confirm that examples/ipv6/simple-udp-rpl/broadcast-example.c now works fine with nullrdc_driver following your latest changes (f315bd1).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,21,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230465663,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",@bthebaudeau Is there anything left that does not work for you?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bthebaudeau,22,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230593571,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz Now, my Zoul Firefly boards can successfully send and receive messages with all the supported adaptivesec configurations. However, I still have the feeling that using adaptivesec with ContikiMAC leads to less reliable transmissions than adaptivesec with nullrdc, or nullsec with ContikiMAC. This is only a feeling, because the reliability of transmissions changes from time to time, and my boards lack antennae. I've selected a channel supposed to be free, but there may be uncontrolled remote emitters on any channel from time to time. So I can't say for sure. If someone has a couple of motes with proper antennae, he or she can compare the adaptivesec and nullsec transmission ranges in an open field environment with ContikiMAC.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,23,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230744476,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@bthebaudeau I also encountered reliability issues with ContikiMAC, but they seem to be independent of adaptivesec. This is one reason why I began to work on a re-implementation of ContikiMAC, as I told you already. For the time being, it might help to switch on CSMA and/or the ContikiMAC framer (which adds padding bytes to short frames).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bthebaudeau,24,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230900550,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",@kkrentz Thanks: it works much better with your latest additions to the Troubleshooting section. Everything seems to be fine now.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,25,https://github.com/contiki-os/contiki/pull/1703#issuecomment-230916707,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I can confirm also it is working nicely for the RE-Mote platform and generally the CC2538 platforms.  The troubleshooting section is a great addition, thanks!
@g-oikonomou any additional comment? have your remarks been addressed?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,26,https://github.com/contiki-os/contiki/pull/1703#issuecomment-249881770,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I removed channel hopping from iq-seeder.c and added more comments to it.
I revised csprng.c to suit the needs of other seeders that I am currently testing.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/simonduq,27,https://github.com/contiki-os/contiki/pull/1703#issuecomment-249908814,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Two comments:

I don't like the name of the module neighbor, which says little about what the module does. Something in the naming should convey the security aspect. Else things just get confusing, sounds like a neighbor management module.
Are you 100% confident about the safety of your use of nbr-table indexes outside of the module, via nbr_table_index_from_item? Indexes are really intended as an internal thing only. Between two consecutive calls, one has no guarantee that a neighbor hasn't changed index. It might have been discarded and re-added at a different index. The safe way to identify a neighbor is with its MAC address.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,28,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250124907,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I renamed neighbor.c to akes-nbr.c
I renamed single.c to akes-single.c
I turned over to using my own indices.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/simonduq,29,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250145513,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/simonduq,30,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250174872,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","OK this looks like colliding with #1739
Which suppresses sequence numbers in broadcast to reduce the seqno wrapping pace",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,31,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250199916,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I see. It should be fine by now. Of course, setting the sequence number at the LLSEC layer is debatable, but, at least, the LLSEC layer is a common place for doing this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/simonduq,32,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250200459,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","works for me, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,33,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250714534,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Since suppressing the sequence numbers of broadcast frames is TSCH specific, I have added the configuration switches FRAME802154_CONF_SUPPR_UNICAST_SEQNO and FRAME802154_CONF_SUPPR_BROADCAST_SEQNO to frame802154.h. They default to what is required by TSCH. (614c8a4)
For setting sequence numbers, I have added two functions to the mac-sequence module. Now I can just call these functions from within nullsec and adaptivesec instead of implementing this twice. (614c8a4)
Lastly, there was a bug in frame802154.h. (5038583)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,34,https://github.com/contiki-os/contiki/pull/1703#issuecomment-250963557,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I revised the suppression of sequence numbers once more. Now, framer-802154.c has a new function for setting sequence numbers. This function also takes care of not setting sequence numbers if suppression is enabled. Here is a link to that function. As a result, the suppression of sequence numbers is handled locally within framer-802154.c, which is somewhat nicer.
I turned adaptivesec into a MODULE, which has to be included from Makefiles if needed. This avoids compiling adaptivesec-related files every time.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,35,https://github.com/contiki-os/contiki/pull/1703#issuecomment-259707081,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",rebased and merged,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/alignan,36,https://github.com/contiki-os/contiki/pull/1703#issuecomment-264144849,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",What's the status of this?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,37,https://github.com/contiki-os/contiki/pull/1703#issuecomment-265138644,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",This is ready to get merged from my perspective ;),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/sonvoque,38,https://github.com/contiki-os/contiki/pull/1703#issuecomment-275972873,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Dear kkrentz!
Do you have any stable branch for this adaptivesec? I still get some warnings and errors when compiling the code?
[sudo] password for user:
CC        ../../../cpu/cc2538/./ieee-addr.c
CC        ../../../core/net/llsec/adaptivesec/akes.c
../../../core/net/llsec/adaptivesec/akes.c:57:0: warning: ""DEBUG"" redefined
#define DEBUG 0
^
In file included from ../../../platform/cc2538dk/./contiki-conf.h:16:0,
from ../../../core/./net/mac/frame802154.h:68,
from ../../../core/./net/llsec/adaptivesec/adaptivesec.h:43,
from ../../../core/./net/llsec/adaptivesec/akes.h:43,
from ../../../core/net/llsec/adaptivesec/akes.c:40:
./project-conf.h:95:0: note: this is the location of the previous definition
#define DEBUG DEBUG_NONE
^
../../../core/net/llsec/adaptivesec/akes.c: In function 'prepare_update_command':
../../../core/net/llsec/adaptivesec/akes.c:90:35: warning: passing argument 1 of 'adaptivesec_add_security_header' from incompatible pointer type [-Wincompatible-pointer-types]
adaptivesec_add_security_header(&entry->refs[status]->anti_replay_info);
^
In file included from ../../../core/./net/llsec/adaptivesec/akes.h:43:0,
from ../../../core/net/llsec/adaptivesec/akes.c:40:
../../../core/./net/llsec/adaptivesec/adaptivesec.h:133:6: note: expected 'struct anti_replay_info *' but argument is of type 'struct anti_replay_info **'
void adaptivesec_add_security_header(struct anti_replay_info *receiver_info);
^
In file included from ../../../core/./net/llsec/adaptivesec/adaptivesec.h:44:0,
from ../../../core/./net/llsec/adaptivesec/akes.h:43,
from ../../../core/net/llsec/adaptivesec/akes.c:40:
../../../core/net/llsec/adaptivesec/akes.c:129:84: error: request for member 'my_unicast_counter' in something not a structure or union
ounter.u32 = LLSEC802154_HTONL(entry->refs[status]->anti_replay_info.my_unicast
^
../../../core/./net/llsec/llsec802154.h:87:31: note: in definition of macro 'LLSEC802154_HTONL'
#define LLSEC802154_HTONL(n) (n)
^
../../../core/net/llsec/adaptivesec/akes.c:132:47: error: 'anti_replay_my_broadcast_counter' undeclared (first use in this function)
reordered_counter.u32 = LLSEC802154_HTONL(anti_replay_my_broadcast_counter)
^
../../../core/./net/llsec/llsec802154.h:87:31: note: in definition of macro 'LLSEC802154_HTONL'
#define LLSEC802154_HTONL(n) (n)
^
../../../core/net/llsec/adaptivesec/akes.c:132:47: note: each undeclared identifier is reported only once for each function it appears in
reordered_counter.u32 = LLSEC802154_HTONL(anti_replay_my_broadcast_counter)
^
../../../core/./net/llsec/llsec802154.h:87:31: note: in definition of macro 'LLSEC802154_HTONL'
#define LLSEC802154_HTONL(n) (n)
^
../../../core/net/llsec/adaptivesec/akes.c: In function 'on_hello':
../../../core/net/llsec/adaptivesec/akes.c:226:5: warning: implicit declaration of function 'anti_replay_restore_counter' [-Wimplicit-function-declaration]
anti_replay_restore_counter(&entry->permanent->anti_replay_info);
^
../../../core/net/llsec/adaptivesec/akes.c: In function 'on_helloack':
../../../core/net/llsec/adaptivesec/akes.c:347:3: warning: implicit declaration of function 'anti_replay_parse_counter' [-Wimplicit-function-declaration]
anti_replay_parse_counter(payload + ILOS_WAKE_UP_COUNTER_LEN + AKES_NBR_CHALL
^
../../../Makefile.include:240: recipe for target 'obj_cc2538dk/akes.o' failed
make: *** [obj_cc2538dk/akes.o] Error 1
Thanks
Vo Que Son",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,39,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276046873,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Currently, my ""master"" branch only works for OpenMotes. However, this branch should compile flawlessly if you follow the instructions of the README. If not, please send me your project-conf.h and TARGET platform.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/sonvoque,40,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276059055,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Dear Krentz!
I have cloned your master branch and followed the guideline in README.
My project-conf.h:
#ifndef PROJECT_CONF_H_
#define PROJECT_CONF_H_
#ifndef WITH_NON_STORING
#define WITH_NON_STORING 0 /* Set this to run with non-storing mode /
#endif / WITH_NON_STORING */
#undef NBR_TABLE_CONF_MAX_NEIGHBORS
#undef UIP_CONF_MAX_ROUTES
#ifdef TEST_MORE_ROUTES
/* configure number of neighbors and routes /
#define NBR_TABLE_CONF_MAX_NEIGHBORS     10
#define UIP_CONF_MAX_ROUTES   30
#else
/ configure number of neighbors and routes /
#define NBR_TABLE_CONF_MAX_NEIGHBORS     10
#define UIP_CONF_MAX_ROUTES   10
#endif / TEST_MORE_ROUTES */
#undef NETSTACK_CONF_RDC
#define NETSTACK_CONF_RDC     nullrdc_driver
#undef NULLRDC_CONF_802154_AUTOACK
#define NULLRDC_CONF_802154_AUTOACK       1
/* Define as minutes */
#define RPL_CONF_DEFAULT_LIFETIME_UNIT   60
/* 10 minutes lifetime of routes */
#define RPL_CONF_DEFAULT_LIFETIME        10
#define RPL_CONF_DEFAULT_ROUTE_INFINITE_LIFETIME 1
#if WITH_NON_STORING
#undef RPL_NS_CONF_LINK_NUM
#define RPL_NS_CONF_LINK_NUM 		40 /* Number of links maintained at the root. Can be set to 0 at non-root nodes. /
#undef UIP_CONF_MAX_ROUTES
#define UIP_CONF_MAX_ROUTES 		0 / No need for routes /
#undef RPL_CONF_MOP
#define RPL_CONF_MOP RPL_MOP_NON_STORING / Mode of operation*/
#endif /* WITH_NON_STORING */
/* son define */
#ifndef UIP_CONF_ROUTER
#define UIP_CONF_ROUTER  			1
#endif
#define UIP_CONF_IPV6_RPL  			1
/* ND and Routing */
#define UIP_CONF_ND6_SEND_RA        0
#define UIP_CONF_IP_FORWARD         0
/* Low Power Mode */
#define LPM_CONF_ENABLE       		0		/**< Set to 0 to disable LPM entirely */
#define LPM_CONF_MAX_PM       		0
/* RF parameters define*/
#define CC2538_RF_CONF_CHANNEL    	26
#define CC2538_RF_CONF_TX_POWER		0xFF	// +7dBm
#define CC2538_RF_CONF_AUTOACK 		0
#ifndef DEBUG
#define DEBUG DEBUG_NONE
#endif
#ifndef STARTUP_CONF_VERBOSE
#define STARTUP_CONF_VERBOSE        0 /**< Set to 0 to decrease startup verbosity */
#endif
#undef ADAPTIVESEC_CONF_UNICAST_SEC_LVL
#define ADAPTIVESEC_CONF_UNICAST_SEC_LVL 2
#undef ADAPTIVESEC_CONF_BROADCAST_SEC_LVL
#define ADAPTIVESEC_CONF_BROADCAST_SEC_LVL 2
#undef LLSEC802154_CONF_USES_AUX_HEADER
#define LLSEC802154_CONF_USES_AUX_HEADER 0
#undef NBR_TABLE_CONF_MAX_NEIGHBORS
#define NBR_TABLE_CONF_MAX_NEIGHBORS 14
#define SINGLE_CONF_KEY { 0x00 , 0x01 , 0x02 , 0x03 , 
0x04 , 0x05 , 0x06 , 0x07 , 
0x08 , 0x09 , 0x0A , 0x0B , 
0x0C , 0x0D , 0x0E , 0x0F }
#undef PACKETBUF_CONF_WITH_UNENCRYPTED_BYTES
#define PACKETBUF_CONF_WITH_UNENCRYPTED_BYTES 1
#undef CSPRNG_CONF_SEEDER
#define CSPRNG_CONF_SEEDER iq_seeder
#endif
the platform I used is a CC2538-based mote (cloned from CC2538DK from TI).
I compile with: make TARGET=cc2538dk
My target is to integrate the adaptivesec module with my app.
Thank you much
Kind regards
Vo Que Son",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,41,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276062154,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","My master branch is currently tied to OpenMotes. Anyway, it might work if you add #include ""net/llsec/adaptivesec/noncoresec-autoconf.h"" to your project-conf.h somewhere near the end.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/sonvoque,42,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276093550,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Dear Krentz!
thank you much. I will try to modify your code to adapt to CC2538DK because OpenMote also uses CC2538 chip
Kind regards
Vo Que Son",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/sonvoque,43,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276277487,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Dear Krentz!
I have compiled successfully the Border-Router and an UDP-echo-server apps.
I also enable DEBUG 1 in all files of adaptivesec.
This is the debug messages from Border-Router:
Contiki-2.6-4258-g76848c8
TI SmartRF06 + cc2538EM
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: External reset
Net: sicslowpan
LLSEC: adaptivesec
MAC: CSMA
RDC: nullrdc
Rime configured with address 00:12:4b:00:05:af:84:06
akes: broadcasting HELLO
*** Address:aaaa::1 => aaaa:0000:0000:0000
Got configuration message of type P
Setting prefix aaaa::
Server IPv6 addresses:
aaaa::212:4b00:5af:8406
fe80::212:4b00:5af:8406
akes: broadcasting HELLO
akes: broadcasting HELLO
and the messages from the udp-echo-server node:
Contiki-2.6-4258-g76848c8
TI SmartRF06 + cc2538EM
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: External reset
Net: sicslowpan
LLSEC: adaptivesec
MAC: CSMA
RDC: nullrdc
Rime configured with address 00:12:4b:00:05:af:85:70
akes: broadcasting HELLO
akes: broadcasting HELLO
akes: broadcasting HELLO
I saw that your branch is using Contiki 2.6 when we have Contiki 3.0 now.
It seams that 2 nodes only broadcast HELLO without receiving anything.
I believe that my HW platform is similar to OpenMote
Do you have any hints for me?
Danke schoen.
Vo Que Son",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,44,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276307958,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","My guess is that this is because you are using nullrdc, which is not compatible with my modified version of cc2538-rf.c at the moment. Try using secrdc instead. You can find another README with instructions in net/mac/contikimac.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,45,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276750344,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I am trying to get this adaptivesec working on the nxp JN5168 platform, so far without success. I tried with nullrdc and also contikimac, without success, no traffic seems to get through.
My setup is a border router talking to a mote with slip-radio, and several motes running the fw with adaptivesec enabled. Is the adaptive sec too tied to a particular architecture (cc2538 maybe) ? If it is, what would be needed to bring it up on a different architecture (jn516x) ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,46,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276752230,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","This branch is not tied to any particular platform. What you should do, however, is implement a hardware-accelerated AES-128 driver for your platform. If no traffic gets through, it may be simply because you are too impatient. It takes a little while until session keys are established. To see what is going on, enable DEBUG in akes.c.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,47,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276756889,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","thanks, I was afraid of that. We initially do a broadcast on each frequency to find which frequency other motes are using, and wait only about 250 ms before changing frequency and doing another broadcast. What do you consider a little while, in the order of 100 of milliseconds, or several seconds ?
I will look at akes.c too...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,48,https://github.com/contiki-os/contiki/pull/1703#issuecomment-276897877,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","It may take up to 30s. This is on purpose to prevent HELLO flood attacks.

2017-02-01 20:32 GMT+01:00 bschwand <notifications@github.com>:
‚Ä¶
 thanks, I was afraid of that. We initially do a broadcast on each
 frequency to find which frequency other motes are using, and wait only
 about 250 ms before changing frequency and doing another broadcast. What do
 you consider a little while, in the order of 100 of milliseconds, or
 several seconds ?
 I will look at akes.c too...

 ‚Äî
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#1703 (comment)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/ABPxfHUycnLVP8WF5NKFX093YkpOtT-Nks5rYN3CgaJpZM4ItY88>
 .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,49,https://github.com/contiki-os/contiki/pull/1703#issuecomment-277075085,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I changed my app so only one channel is used, and we wait as long as desired but still nothing gets through.
I see in one of the comments above that you could make SLIP work. Is that still not working ?
That might explain why I get no results, as my setup is a native border router communicating over SLIP with a mote running slip-radio, then a network of other independent motes.
I enabled DEBUG in all adaptivesec files, I also dump in adaptivesec.c input() the type of frame received. The debug log shows the HELLO messages are sent in akes, but the frames coming in input() are of type 0x00 for the slip-radio and of type 0x02, 0x05 for the other motes which is pretty weird.
I only enabled sec level 1 to debug.
Not much seems to go on, here is an example session log
adaptivesec,input: got a frame type 0x05
adaptivesec,input: got a frame type 0x02
akes-trickle: Doubling interval size
akes-trickle: I=60s t=40s
akes-trickle: Broadcasting HELLO
akes: broadcasting HELLO
akes-trickle: Doubling interval size
akes-trickle: I=120s t=67s
adaptivesec,input: got a frame type 0x05
akes-trickle: Broadcasting HELLO
akes: broadcasting HELLO
akes-trickle: Doubling interval size
akes-trickle: I=240s t=171s
adaptivesec,input: got a frame type 0x05
akes-trickle: Broadcasting HELLO
akes: broadcasting HELLO
Any suggestions ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,50,https://github.com/contiki-os/contiki/pull/1703#issuecomment-277076892,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","one more thing, you said above:
My guess is that this is because you are using nullrdc, which is not compatible with my modified version of cc2538-rf.c at the moment. Try using secrdc instead. You can find another README with instructions in net/mac/contikimac.
I do not see any other README in that location, nor any reference to secrdc, so I realized the master branch of your contiki fork has more, newer stuff... I will try with that again !",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,51,https://github.com/contiki-os/contiki/pull/1703#issuecomment-277079355,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",My master branch is not suitable for your platform. What RDC layer are you using?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,52,https://github.com/contiki-os/contiki/pull/1703#issuecomment-277177726,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Nullrdc,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,53,https://github.com/contiki-os/contiki/pull/1703#issuecomment-277434620,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Usually you should see akes: Received HELLO if something gets through. I do not know where adaptivesec,input: got a frame type is printed. I suggest you to place some additional printfs to trace down whether HELLOs arrive and where they are discarded. When using nullrdc, I observed that motes sometimes detect preambles within radio noise, which causes them to receive garbage frames. So incoming frames are not necessarily valid.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,54,https://github.com/contiki-os/contiki/pull/1703#issuecomment-277454108,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","the message is part of additional trace I am adding to figure where the packet comes and goes.
it is in the input() function of adaptivesec.c . I assume received frames would go through that function, identified by frame type and acted on. But here the frame type is never right. I used a sniffer and verified with binary dumps that the HELLO message and the packet received do match. However in input() the frame type from the packet attributes, which should have been parsed in the framer if I get it right, are not what the dump and the sniffer shows (i.e. the packet dump shows a CMD frame type, but the corresponding attribute is not set.) So I think there is something going on with the framer. I will continue tracing where packets come and how they are processed until I figure it out... thanks for the suggestions. always welcome.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,55,https://github.com/contiki-os/contiki/pull/1703#issuecomment-278323905,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I got the adaptivesec layer working for my purposes (a native border router, talking over slip serial to a mote running slip-radio, in a ipv6 6lowpan network to other motes)
Overall, this is what I had to do:

Enable adaptivesec in slip-radio and the motes
Enable LLSEC802154_CONF_ENABLED in the native border router (and no adaptive sec, as this is handled by the slip-radio)
the slip-net.c slipnet_input() must be modified to use the total packet length and also copy all data in the uip buffer like here:


+#if ENABLE_ADAPT_SEC
+  uip_len = packetbuf_totlen();
+#else
   uip_len = packetbuf_datalen();
+#endif

+#if ENABLE_ADAPT_SEC
+  memcpy(uip_buf, packetbuf_hdrptr(), uip_len);
+#else
   packetbuf_copyto(uip_buf);
+#endif


slip-radio needs to include the no_framer declaration

+#if ENABLE_ADAPT_SEC
+extern const struct framer         no_framer;
+#endif



slip-radio in the slip_radio_cmd_handler() has to use the adaptivesec_framer parse()

+#if ENABLE_ADAPT_SEC
+      adaptivesec_framer.parse();
+#else
       no_framer.parse();
+#endif

Some of those fixes might be due to not setting correctly framers and al, or simply that this setup is a little unusual as the NBR and radio mote are separate.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,56,https://github.com/contiki-os/contiki/pull/1703#issuecomment-285704905,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I think I might have found a bug in this..
akes.c :
122 generate_pairwise_key(uint8_t *result, uint8_t *shared_secret)
123 {
124   ADAPTIVESEC_SET_KEY(shared_secret);
125   AES_128.encrypt(result);
126 }
ADAPTIVE_SET_KEY() is defined in adaptivesec.h
50 #if AKES_NBR_KEY_LEN == 16
51 #define ADAPTIVESEC_SET_KEY(key)      CCM_STAR.set_key(key)
52 #else /* AKES_NBR_KEY_LEN == 16 /
53 #define ADAPTIVESEC_SET_KEY(key)      aes_128_set_padded_key(key, AKES_NBR_KEY_LEN)
54 #endif / AKES_NBR_KEY_LEN == 16 */
so for a key len of 16, we set the key in the CCM_STAR driver, but encrypt with the AES driver.
Any comment on that ? is that right ?
just as an update, I tested using 2 different shared keys on different motes, and they nonetheless negociate session keys. Am I misunderstanding something or this should be impossible ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,57,https://github.com/contiki-os/contiki/pull/1703#issuecomment-285856607,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",You are right. Thanks for pointing this out. I added a fix and rebased.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,58,https://github.com/contiki-os/contiki/pull/1703#issuecomment-285950874,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","my local fix was to not use the ADAPTIVESEC_SET_KEY anymore as it is only used in two places, and in each of those it made sense to appropriately set the key for AES128 or CCM_STAR engine.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,59,https://github.com/contiki-os/contiki/pull/1703#issuecomment-286169227,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Okay. I did it your way and fixed the key length.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/msolters,60,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292690559,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hi @bschwand, I too have a debian host (ARM v7) tied to a SLIP radio (CC2650).
I will be trying to replicate your success as documented here.  In my case, however, I will be using 6LBR (not the native border router as found in Contiki).  It seems that this does not matter, however, as the adaptivesec is apparently something that only the SLIP radio knows about?
Why is it necessary to enable LLSEC in the border router?  Is this still necessary, after the recent commits?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/msolters,61,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292693704,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I've managed to compile slip-radio.bin

For the CC2650
With the adaptivesec module
With @bschwand 's suggested changes in slip-radio.c and slip-net.c
The following configuration overriding the project-conf.h of the SLIP radio, and the node leafs that I am using to test traffic:

#define ENABLE_ADAPT_SEC 1

#undef ADAPTIVESEC_CONF_UNICAST_SEC_LVL
#define ADAPTIVESEC_CONF_UNICAST_SEC_LVL 2
#undef ADAPTIVESEC_CONF_BROADCAST_SEC_LVL
#define ADAPTIVESEC_CONF_BROADCAST_SEC_LVL 2


#define SINGLE_CONF_KEY { 0x00 , 0x01 , 0x02 , 0x03 , \
                          0x04 , 0x05 , 0x06 , 0x07 , \
                          0x08 , 0x09 , 0x0A , 0x0B , \
                          0x0C , 0x0D , 0x0E , 0x0F }

#undef CSPRNG_CONF_SEEDER
#define CSPRNG_CONF_SEEDER iq_seeder

#undef NETSTACK_CONF_FRAMER
#define NETSTACK_CONF_FRAMER contikimac_framer
#undef CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER
#define CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER adaptivesec_framer
#undef ADAPTIVESEC_CONF_DECORATED_FRAMER
#define ADAPTIVESEC_CONF_DECORATED_FRAMER framer_802154

#include ""net/llsec/adaptivesec/noncoresec-autoconf.h""
The result: SLIP radio does communicate as I expect (I get a MAC address, 6LBR starts up fine).  However, I never see my node appear as a ""sensor"" under 6LBR, and the SLIP traffic is as follows:
Wireless input, generally a good sign that traffic is at least occuring and on the right channels.
2017-04-08 0:13:42.798159: PACKET: PF: wireless_input
2017-04-08 0:13:42.798251: PACKET: PF: wireless_input : broadcast
2017-04-08 0:13:42.798370: PACKET: PF: wireless_input: processing frame

Every time one of the nodes sends a CoAP request to a server on the SLIP's native host, I see this:
2017-04-08 0:13:45.186270: PACKET: PF: bridge_output: Sending packet to Broadcast
2017-04-08 0:13:45.186471: PACKET: PF: wireless_output: sending packet
2017-04-08 0:13:45.186682: PACKET: BR-RDC: write: 80 (sid: 0, cb: 1)
2017-04-08 0:13:45.186775: DUMP: BR-RDC: 
         7a3b3a1a 9b01c1b4 1efb0100 90f00000 
         aaaa0000 00000000 02124b00 07904a01 
         040e0008 0c0a0700 01000001 001e0100 
         081e4040 00000000 00000000 00000000 
         aaaa0000 00000000 00000000 00000000 
         
2017-04-08 0:13:45.189374: PACKET: SLIP: write: 108
2017-04-08 0:13:45.189443: DUMP: SLIP: 
         21530003 0a00580b 00010e00 0141d858 
         cdabffff 014a9007 004b1200 7a3b3a1a 
         9b01c1b4 1efb0100 90f00000 aaaa0000 
         00000000 02124b00 07904a01 040e0008 
         0c0a0700 01000001 001e0100 081e4040 
         00000000 00000000 00000000 aaaa0000 
         00000000 00000000 00000000 
2017-04-08 0:13:45.340795: PACKET: SLIP: read: 5
2017-04-08 0:13:45.341021: DUMP: SLIP: 
         21520000 01
2017-04-08 0:13:45.341409: PACKET: SCMD: Packet data report for sid:0 st:0 tx:1
2017-04-08 0:13:45.341517: PACKET: BR-RDC: sid ack: 0 (0, 1)
2017-04-08 0:13:53.964694: PACKET: PF: bridge_output: Sending packet to Broadcast
2017-04-08 0:13:53.964931: PACKET: PF: wireless_output: sending packet
2017-04-08 0:13:53.965099: PACKET: BR-RDC: write: 80 (sid: 1, cb: 1)

I think this is a fantastic alternative to LLSEC, but I must be missing something to make it work through a SLIP radio still.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,62,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292731399,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I once had SLIP running, but unlike suggested here I ran adaptivesec natively. Anyway, I was not satisfied with this solution because it was incompatible with my reimplementation of ContikiMAC. BTW, I am currently trying to accelerate session key establishment (while preserving AKES' HELLO flood defense).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/msolters,63,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292743608,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Thanks!
Will you please clarify what you mean by running adaptivesec ""natively""?  You were running adaptivesec on the host machine, or on the SLIP radio attached to the host machine?
As a separate request, do you think you can provide an opinion as to the best choices for the following defines, which are the default for the Contiki slip-radio project-conf.h:
/* configuration for the slipradio/network driver */
#undef NETSTACK_CONF_MAC
#define NETSTACK_CONF_MAC     nullmac_driver

#undef NETSTACK_CONF_RDC
#define NETSTACK_CONF_RDC     contikimac_driver

#undef NETSTACK_CONF_NETWORK
#define NETSTACK_CONF_NETWORK slipnet_driver

#undef NETSTACK_CONF_FRAMER
#define NETSTACK_CONF_FRAMER no_framer
In your opinion (or best guess), what should those be set to for adaptivesec to execute successfully on the SLIP radio?  At this time I'm just assuming RDC is acceptable across the mesh, to keep things simple.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,64,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292794148,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Here is a preliminary solution: https://github.com/kkrentz/contiki/commits/akes-tests. I changed slip-radio to implement everything from RDC to LLSEC - no_framer is no more. This simplifies matters a lot.,True,"{'HEART': ['https://github.com/msolters'], 'THUMBS_UP': ['https://github.com/msolters']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,65,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292798272,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@msolters
""Why is it necessary to enable LLSEC in the border router? Is this still necessary, after the recent commits?""
if I remember correctly, this had to do with enabling LLSEC AUX headers. We need certain llsec related headers in the packets and having it at the border router level already made it so the packets can get parsed correctly. Otherwise you are correct, adaptive sec is only enabled in the nodes and the slip-radio with this setup.
I also had to change the max payload size, so that the fragmenter (6cslowpan) makes fragment small enough that the additional security headers do not cause the fragments to go over the maximum 802.15.4 frame size.
Also, for debugging I recommend enabling DEBUG in akes.c and akes-nbr.c and also akes-trickle.c
Most of the fixes I made, were because of log generated that way !",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/msolters,66,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292799055,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Thank you so much to both of you!  I have now a working setup with 6LBR+SLIP communicating to nodes, with adaptivesec on the SLIP radio and the nodes (cetic/6lbr#115 (comment)).
It seemed the magic ingredient was using the csma_driver on both sides.
However, I will definitely be taking a look at the akes-tests branch!  It seems a much more robust approach.  @bschwand I will definitely consider those payload sizes moving forward.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/msolters,67,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292803355,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hi @kkrentz, unfortunately the SLIP radio in the akes-tests branch does not work with 6LBR; I just get the following error over and over:
2017-04-09 14:27:18.618695: ERROR: BR-RDC: br-rdc: send failed, slip ack timeout (7)

This seems a like a serial-specific problem, rather than a networking one.
Specifically, this error is triggered whenever a node with adaptivesec enabled sends 802.15.4 traffic.
I'm also seeing a lot of these:
2017-04-09 15:13:33.086840: ERROR: BR-RDC: br-rdc: failed to parse 75",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,68,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292808174,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","In my branch, the PRINTF br-rdc: failed to parse no longer exists. Maybe you need recompile something.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/msolters,69,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292809423,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Yes, I believe these error messages are germane to 6LBR, and not printed by the SLIP radio itself.  Nevertheless, one result here is that the SLIP radio in akes-tests is incompatible with 6LBR as it stands.
Nevertheless, adaptivesec does work fine with 6LBR when using the ""vanilla"" Contiki SLIP radio, after being modified as per @bschwand.  I'm going to revert back to that setup to continue testing, as it is the only functional configuration I can manage with this hardware.
I understand, of course, that this PR is a Contiki-specific offering, and no support or compatibility with 6LBR was offered or implied.  But, it is one of the most popular BRs in use, and I think it would certainly help to have adaptivesec play nicely with 6LBR as a lot of developers use it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/bschwand,70,https://github.com/contiki-os/contiki/pull/1703#issuecomment-292863084,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@msolters : enable debug in framer-80215 and maybe hexdump the packets to find out where the packets are dumped instead of forwarded. When I added several changes for HW mac and ACK support on our platform, the packets were not parsed correctly because of additional fields. Debugging what happened in the framer allowed to find the issue.",True,{'THUMBS_UP': ['https://github.com/msolters']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,71,https://github.com/contiki-os/contiki/pull/1703#issuecomment-297027144,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I appended some minor fixes. The acceleration of AKES is not part of these fixes, but will be released in the near future ...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,72,https://github.com/contiki-os/contiki/pull/1703#issuecomment-300139842,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",AKES works quicker now. Security is preserved.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,73,https://github.com/contiki-os/contiki/pull/1703#issuecomment-305727436,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",I have added more documentation on crypto as suggested by @g-oikonomou.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/wdimmit,74,https://github.com/contiki-os/contiki/pull/1703#issuecomment-308238888,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I am attempting to bring this patch set up on a pair of cc1350 Launchpads.  For testing, I'm using the rpl-udp demo, with one server and one client node.   I've modified the project-conf.h file to use contikimac and csma along with the other suggested settings.  I've tested with both security level 2 & 5. I've also enabled DEBUG in all files in the adaptivesec directory.
If I include noncoresec-autoconf.h to use a group-level key, everything works as expected and sessions generally are fully established within a few seconds.
If I include coresec-autoconf.h I see the pairwise and group keys logged with in a second or so of booting the second board.  After that, the two boards continue to acknowledge HELLOs from each other, but always report akes: No need to start a new session after HELLOACKs.  The one error I do see pretty frequently is coresec-strategy: Inauthentic broadcast.  No application-level traffic ever flows between the nodes.
Is there any basic reason pairwise encrypted communication would not work on a cc1350?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,75,https://github.com/contiki-os/contiki/pull/1703#issuecomment-308374446,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","My guess is that this is because of the unreliability of the current ContikiMAC implementation. This problem aggravates when using coresec since each broadcast frame is then preceded with an ANNOUNCE frame, which must also arrive. For comparison, you may try nullrdc.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/wdimmit,76,https://github.com/contiki-os/contiki/pull/1703#issuecomment-308487380,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz On your suggestion I have just tested a number of configurations using nullrdc.  Sadly, all have failed in similar fashion. The biggest difference compared with ContikiMAC seems to be that these two lines always appear together in the debugging output with nullrdc:
coresec-strategy: Received ANNOUNCE
coresec-strategy: Inauthentic broadcast
Enabling or disabling CSMA did not seem to have any impact.  The relevant portion of my project-conf.h file for a recent attempt is here: https://gist.github.com/wdimmit/bac8b6af2be62c7177c9a2323b747e80",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,77,https://github.com/contiki-os/contiki/pull/1703#issuecomment-308964558,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I tried your configuration using OpenMotes and Cooja, but did not encounter any problems. Maybe this issue is really specific to cc1350, which is strange since noncoresec works on your platform. If you use a hardware-implemented AES-128 driver, you may try a software-implemented AES-128 instead.
#undef AES_128_CONF
#define AES_128_CONF aes_128_driver",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/Johan-Henry,78,https://github.com/contiki-os/contiki/pull/1703#issuecomment-331127343,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hi @kkrentz
I am experimenting with a slip radio - native border router setup on cc2538 chips. I have tried some of the modifications as mentioned by bschwand and msolters here, but have not quite gotten to a solid solution with adaptive sec implemented (my normal border router on chip solution works much better).
I am curious about your ""preliminary solution: https://github.com/kkrentz/contiki/commits/akes-tests"", mentioned here, however that link does not seem to work. Do you perhaps have some other link or reference that I can have a look at?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,79,https://github.com/contiki-os/contiki/pull/1703#issuecomment-331144992,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@Johan-Henry I moved my ""preliminary solution"" to https://github.com/kkrentz/contiki/commits/secrdc-demos. My preliminary solution seems to work, but not as reliable as compared to using ""examples/ipv6/rpl-border-router"". Maybe this is true for the current implementation, as well.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,80,https://github.com/contiki-os/contiki/pull/1703#issuecomment-358495966,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hello, I have a setup where there are some leaf nodes which directly communicate with the border router. The border router then sends the data on mqtt through http format.
I have used adaptivesec and have enabled the security level to 1 for both broadcast and unicast packets. However, is it possible to dynamically decide security level for different kinds of unicast packets?
One unicast packet could use security level 1 and the other 4( authentication and encryption). Is it possible to add this feature? I saw that if the security levels mismatch, the packet is not discarded in adaptivesec as was done in noncoresec.
Could some one please give a way through in this?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,81,https://github.com/contiki-os/contiki/pull/1703#issuecomment-358657681,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hi there, in principle that is possible, but I did not implement that.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,82,https://github.com/contiki-os/contiki/pull/1703#issuecomment-358889562,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Thanks for your quick reply. Will it be correct if change the adaptivesec_get_sec_lvl to give the security level according to the one set by the user for unicast packets? I have not tested yet. Do you see any other implications?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,83,https://github.com/contiki-os/contiki/pull/1703#issuecomment-359157464,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","In effect, that function is just used to check whether encryption is necessary or not. It should be feasible to adapt this function to encrypt only a subset of unicast frames. If you also want to adjust the length of message integrity codes (MICs) at runtime, things get more complicated since I use the statically configured MIC length everywhere.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,84,https://github.com/contiki-os/contiki/pull/1703#issuecomment-359607983,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Thanks for the answer. Will secrdc be working with potr_enabled on cc26xx-cc13xx cpu?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,85,https://github.com/contiki-os/contiki/pull/1703#issuecomment-359722297,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","This will not work out of the box because secrdc uses my own custom radio interface (core/dev/radio-async.h), which is only implemented for cc2538, yet (cpu/cc2538/dev/cc2538-rf-async.c). I am not planning to implement further radio_async_drivers, but I do plan to implement another MAC protocol on top of this interface (coordinated sampled listening).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,86,https://github.com/contiki-os/contiki/pull/1703#issuecomment-367928533,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hello,
I am trying to establish communication between two nodes. One of them acting as a border router to ip connection. I am establishing adaptivesec and giving the following settings in the project_conf for both the nodes.
LEAF NODE
#define NETSTACK_CONF_MAC 						csma_driver
//#define NETSTACK_CONF_RDC 					nullrdc_driver
#define NETSTACK_CONF_RDC 						contikimac_driver
#define NETSTACK_CONF_RDC_CHANNEL_CHECK_RATE 	8
#define UIP_CONF_TCP							0
//#define RPL_CONF_LEAF_ONLY               	    1
#define RPL_CONF_PROBING_INTERVAL           	(600 * CLOCK_SECOND)
#define UIP_CONF_ROUTER 						0
#define NETSTACK_CONF_WITH_IPV6					1
#define UIP_CONF_IP_FORWARD                 	0
#define CC26XX_UART_CONF_ENABLE             	0                               //Enable/Disable UART I/O
#define RF_CHANNEL	           					26
// configurations for security feature
// Enable the security level
// Currently enabling authentication only for unicast and
// broadcast communication
#undef ADAPTIVESEC_CONF_UNICAST_SEC_LVL
#define ADAPTIVESEC_CONF_UNICAST_SEC_LVL 5
#undef ADAPTIVESEC_CONF_BROADCAST_SEC_LVL
#define ADAPTIVESEC_CONF_BROADCAST_SEC_LVL 5
// Enable pairwise keys
#include ""net/llsec/adaptivesec/coresec-autoconf.h""
#undef NETSTACK_CONF_FRAMER
#define NETSTACK_CONF_FRAMER contikimac_framer
#undef CONTIKIMAC_FRAMER_CONF_ENABLED
#define CONTIKIMAC_FRAMER_CONF_ENABLED 1
#undef CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER
#define CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER adaptivesec_framer
#undef ADAPTIVESEC_CONF_DECORATED_FRAMER
#define ADAPTIVESEC_CONF_DECORATED_FRAMER framer_802154
#undef SINGLE_CONF_KEY
#define SINGLE_CONF_KEY { 0x10 , 0x21 , 0x32 , 0x43 , 
0x54 , 0x65 , 0x76 , 0x87 , 
0x98 , 0xA9 , 0xBA , 0xCB , 
0xCC , 0xDD , 0xED , 0xFC }
BORDER_ROUTER
/* Comment this out to use Radio Duty Cycle (RDC) and save energy */
//#define NETSTACK_CONF_RDC          			nullrdc_driver
#define NETSTACK_CONF_RDC 						contikimac_driver
#define NETSTACK_CONF_RDC_CHANNEL_CHECK_RATE 	16
#define QUEUEBUF_CONF_NUM          				4
#define UIP_CONF_BUFFER_SIZE       				256
#define UIP_CONF_RECEIVE_WINDOW    				60
#define RF_CHANNEL	           					26
// configurations for security feature
// Enable the security level
// Currently enabling authentication only for unicast and
// broadcast communication
#undef ADAPTIVESEC_CONF_UNICAST_SEC_LVL
#define ADAPTIVESEC_CONF_UNICAST_SEC_LVL 5
#undef ADAPTIVESEC_CONF_BROADCAST_SEC_LVL
#define ADAPTIVESEC_CONF_BROADCAST_SEC_LVL 5
// Enable pairwise keys
#include ""net/llsec/adaptivesec/coresec-autoconf.h""
#undef NETSTACK_CONF_FRAMER
#define NETSTACK_CONF_FRAMER contikimac_framer
#undef CONTIKIMAC_FRAMER_CONF_ENABLED
#define CONTIKIMAC_FRAMER_CONF_ENABLED 1
#undef CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER
#define CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER adaptivesec_framer
#undef ADAPTIVESEC_CONF_DECORATED_FRAMER
#define ADAPTIVESEC_CONF_DECORATED_FRAMER framer_802154
#undef SINGLE_CONF_KEY
#define SINGLE_CONF_KEY { 0x10 , 0x21 , 0x32 , 0x43 , 
0x54 , 0x65 , 0x76 , 0x87 , 
0x98 , 0xA9 , 0xBA , 0xCB , 
0xCC , 0xDD , 0xED , 0xFC }
But I am seeing on the wireshark that there are lot of exchanges of RIT Data Request and DSME information request, but no acknowledgements or any data exchange
Can you suggest what can be wrong here",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,87,https://github.com/contiki-os/contiki/pull/1703#issuecomment-367969494,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",Will adaptivesec work on cpus like cc26xx-cc13xx??,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,88,https://github.com/contiki-os/contiki/pull/1703#issuecomment-368823699,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","The reason why you see RIT Data Requests and DSME information requests maybe is that adaptivesec uses some command IDs that are in use. Another problem probably is that the ContikiMAC framer adds a non-compliant byte for handling its padding bytes. These things could be fixed by switching to reserved command IDs and moving ContikiMAC's padding data to an information element (IE).
If you want to run adaptivesec on cc26xx-cc13xx, you will have to implement an appropriate csprng_seeder. However, I had just uploaded an improved null_seeder, which suffices if you configure adaptivesec to exclusively use pairwise session keys. The csprng_seeder is mainly required to generate secret group session keys and improves the opaqueness of pairwise session keys.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/firmwareguru,89,https://github.com/contiki-os/contiki/pull/1703#issuecomment-385508845,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","AdaptiveSec seems to be already available on cetic/6lbr, why is it taking so long to get integrated into Contiki mainline?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,90,https://github.com/contiki-os/contiki/pull/1703#issuecomment-385770340,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","I, meanwhile, ported adaptivesec, along with my implementations of ContikiMAC and CSL to Contiki-NG https://github.com/kkrentz/contiki-ng. I will create a new pull request there.",True,{'THUMBS_UP': ['https://github.com/amitbhanja']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/firmwareguru,91,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386406549,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Excellent kkrentz. Your efforts to bring Contiki towards IIoT-level robustness are invaluable.  I have a couple of comment-questions:


Where do we sit with bringing adaptive key exchange and compromise resliency to TSCH?


I notice no references between your papers and this one:
Cryptographic Key Exchange in IPv6-Based Low Power,
Lossy Networks
Panagiotis Ilia, George Oikonomou, Theo Tryfonas








I'm sure you're aware of it, however.
How does your system compare?
I would like to see a system based on ECC/PKI on the TI 13x2 platforms.  However if your system is just as compromise resilient without any central key distribution system, then fine by me.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,92,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386503324,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz , thanks for the update. Please also inform us if you could, about the new pull request in contiki-ng.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,93,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386503745,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",@kkrentz will the CSL work for cc26xx-cc13xx cpu drivers?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,94,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386793863,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@firmwareguru I have little hope that we can add compromise resilience to TSCH anytime soon. Even if TSCH was changed to use pairwise keys, its time synchronization could still be attacked by compromised nodes. Because of this, I rather added channel hopping (and other nice features) to CSL. Regarding the paper, I think I saw this paper a long time ago. They are using unauthenticated ECDH and hence do not prevent unauthorized nodes from joining the network. Another limitation is that ECDH is quite energy- and time-consuming. By contrast, our system ensures authorization and avoids public-key cryptography.
@amitbhanja For the time being, I only implemented a driver for the CC2538: https://github.com/kkrentz/contiki-ng/blob/master/arch/cpu/cc2538/dev/cc2538-rf-async.c.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,95,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386796133,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz , Thanks for the info. I was actually trying the adaptivesec (https://github.com/kkrentz/contiki) with rpl-border-router. The border router is on cc1310 and sensortag on cc1350. I enabled the prints of the security module.
#include ""net/llsec/adaptivesec/coresec-autoconf.h""
#define AKES_SINGLE_CONF_KEY { 0x12 , 0x37 , 0x59 , 0x65 , 
0xC4 , 0xD5 , 0x8A , 0x76 , 
0x19 , 0xE7 , 0xA9 , 0x98 , 
0x1D , 0x51 , 0xCB , 0xFE }
#undef CSPRNG_CONF_SEEDER
#define CSPRNG_CONF_SEEDER null_seeder
#undef CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION
#define CONTIKIMAC_CONF_WITH_PHASE_OPTIMIZATION 1
#undef NETSTACK_CONF_FRAMER
#define NETSTACK_CONF_FRAMER contikimac_framer
#undef CONTIKIMAC_FRAMER_CONF_ENABLED
#define CONTIKIMAC_FRAMER_CONF_ENABLED 1
#undef CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER
#define CONTIKIMAC_FRAMER_CONF_DECORATED_FRAMER adaptivesec_framer
#undef ADAPTIVESEC_CONF_DECORATED_FRAMER
#define ADAPTIVESEC_CONF_DECORATED_FRAMER framer_802154
I tried the above with both phase optimization and without that. However, I always get the prints of the ACK being received. But then a series of Invalid ACK prints, which I believe is because the entry becomes permanent and then it is not any more tentative. There has been occasions of ACK was not acknowledged prints. This i believe is because of no mac layer acknowledgments being sent. Would this be an issue?
but after that, I dont see the sicslowpan connection getting through. Dont see any sicslowpan input prints on either side.
Could you give some idea about what could be the issue?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,96,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386803154,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","This sounds like the ACK is not being acknowledged, although it was received successfully ...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/firmwareguru,97,https://github.com/contiki-os/contiki/pull/1703#issuecomment-386922673,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@amitbhanja I am looking at using adaptivesec + contikimac + cc13xx too; please update here any advances or resolutions, as will I.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/firmwareguru,98,https://github.com/contiki-os/contiki/pull/1703#issuecomment-388148470,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz CSL-MAC: A low power channel hopping MAC with adaptive security and compromise resiliency?  Sounds great.  Where is it, and how can we get it rolled into here, or Contiki-NG, which seems to have only TSCH as the MAC layer??",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,99,https://github.com/contiki-os/contiki/pull/1703#issuecomment-388607007,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.",I opened a PR for merging CSL into Contiki-NG contiki-ng/contiki-ng#506,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,100,https://github.com/contiki-os/contiki/pull/1703#issuecomment-406943543,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hello @kkrentz , I have been using the adaptivesec protocol from ur github repository https://github.com/kkrentz/contiki. Thanks a lot for providing this. It is working fine. I have a setup with border router and 6 nodes. The nodes send data every 1 minute. There is a mechanism I implemented which deletes the parent from the neighbor list if UPDATE ACK is not received after two checks of update interval. After about 2 days, it has been observed that even though node is sending HELLO message with a different session key than what was present due to deletion of the border router from neighbor table, the border router is identifying it as new session with permanent neighbor but the HELLO ACK being sent is not received at the node.  This is creating issue with starting a new session with the border router.
Could you give any tip about why it is happening?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,101,https://github.com/contiki-os/contiki/pull/1703#issuecomment-406973096,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hello,

thanks for using adaptivesec. It may happen that a HELLOACK is silently
discarded because there is no need to start a new session. Maybe this
mechanism interferes with your deletion of parents. I do not know what you
are trying to achieve, but, normally, it is unnecessary to delete neighbors
by hand since akes-delete.c already takes care of deleting uncommunicative
neighbors. To trace down the problem, it would be useful to have the DEBUG
output of akes.c. Also, I would need to know what MAC protocol, platform,
and seeder you are using.

That said, I meanwhile ported adaptivesec to Contiki-NG and
actually stopped maintaining my Contiki repository. You can find the
latest version there: https://github.com/kkrentz/contiki-ng,
https://github.com/kkrentz/contiki-ng/wiki/CSL. As Contiki-NG also contains
a lot of other fixes to Contiki, it probably makes sense for you to move to
Contiki-NG, too.

Kind Regards

Konrad

2018-07-23 7:31 GMT+02:00 Amit Bhanja <notifications@github.com>:
‚Ä¶
 Hello @kkrentz <https://github.com/kkrentz> , I have been using the
 adaptivesec protocol from ur github repository https://github.com/kkrentz/
 contiki. Thanks a lot for providing this. It is working fine. I have a
 setup with border router and 6 nodes. The nodes send data every 1 minute.
 There is a mechanism I implemented which deletes the parent from the
 neighbor list if UPDATE ACK is not received after two checks of update
 interval. After about 2 days, it has been observed that even though node is
 sending HELLO message with a different session key than what was present
 due to deletion of the border router from neighbor table, the border router
 is identifying it as new session with permanent neighbor but the HELLO ACK
 being sent is not received at the node. This is creating issue with
 starting a new session with the border router.
 Could you give any tip about why it is happening?

 ‚Äî
 You are receiving this because you were mentioned.
 Reply to this email directly, view it on GitHub
 <#1703 (comment)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/ABPxfI47E78gUJUXviKQnteuJYpZn8jrks5uJV-XgaJpZM4ItY88>
 .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,102,https://github.com/contiki-os/contiki/pull/1703#issuecomment-408311296,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","Hi @kkrentz ,
Thanks for your quick response.
Mysetup: a node connecting to the border router. Trying to keep the radio off most of the time. Only on during the initial setup and then when data is being sent.
MAC: Contikimac along with CSMA. Channel check rate is 8.
However, I might have confused in the previous post. I am not deleting any entry on my own from the application layer. The only thing i did is added a callback to determine which neighbor has been deleted. If the neighbor is the preferred parent from RPL, I just reset the akes trickle timer , change the adaptivesec group key and reset the rpl timers. I do this because my node keeps the RADIO off most of the time, but when it knows that preferred parent has been deleted, it keeps the radio on. I checked that the restarts of the border router work properly. But after some time i see this issue.
The HELLO message from the node is received at the border router and it determines that a new session has started and sends the HELLO ACK. But nothing is received at the node. In fact, nothing is received at the node (although the radio is on) after the deletion of the border router happens due to the akes-delete thread. Please see the logs below of akes.
From the node:
Line 1: akes-delete: #permanent = 1
Line 4: akes-delete: Sent UPDATE
Line 44: AKES: deleted preferred parent
Line 45: adaptivesec_group_key = 6ffe9215bdf060a9e8f998e053619a11akes-trickle: Resetting Trickle
Line 53: akes-delete Setting update check timer
Line 54: akes-trickle: I=30s t=27s
Line 136: akes-trickle: Broadcasting HELLO
Line 139: akes: broadcasting HELLO
Line 148: akes-trickle: I=60s t=55s
Line 299: akes-trickle: Broadcasting HELLO
Line 302: akes: broadcasting HELLO
Line 316: akes-trickle: I=120s t=75s
Line 513: akes-trickle: Broadcasting HELLO
Line 516: akes: broadcasting HELLO
Line 641: akes-trickle: I=240s t=238s
Line 878: akes-delete: #permanent = 0
Line 879: akes-delete Setting update check timer
Line 1279: akes-trickle: Broadcasting HELLO
Line 1282: akes: broadcasting HELLO
Line 1286: akes-trickle: I=480s t=287s
Line 1682: akes-delete: #permanent = 0
Line 1683: akes-delete Setting update check timer
Line 2049: akes-trickle: Broadcasting HELLO
Line 2052: akes: broadcasting HELLO
Line 2482: akes-delete: #permanent = 0
Line 2483: akes-delete Setting update check timer
Line 2569: akes-trickle: I=960s t=504s
Line 3294: akes-delete: #permanent = 0
Line 3295: akes-delete Setting update check timer
Line 3924: akes-trickle: Broadcasting HELLO
Line 3927: akes: broadcasting HELLO
Line 4097: akes-delete: #permanent = 0
Line 4098: akes-delete Setting update check timer
Line 4904: akes-delete: #permanent = 0
Line 4905: akes-delete Setting update check timer
Line 5151: akes-trickle: I=1920s t=1390s
Line 5712: akes-delete: #permanent = 0
Line 5713: akes-delete Setting update check timer
Line 6516: akes-delete: #permanent = 0
Line 6517: akes-delete Setting update check timer
Line 7322: akes-delete: #permanent = 0
Line 7323: akes-delete Setting update check timer
From the border router:
Jul 27 08:54:19 raspberrypi bert[341]: akes: Received UPDATE from 00:12:4b:00:18:00:82:8f
Jul 27 08:54:20 raspberrypi bert[341]: His unicast counter 271
Jul 27 08:54:20 raspberrypi bert[341]: Received Counter 272
Jul 27 08:54:20 raspberrypi bert[341]: His unicast counter 272
Jul 27 08:54:20 raspberrypi bert[341]: Received Counter 272
Jul 27 08:54:20 raspberrypi bert[341]: akes-nbr: prolonging
Jul 27 08:54:20 raspberrypi bert[341]: akes-nbr: prolonged
Jul 27 08:54:20 raspberrypi bert[341]: Sending UPDATE ACK to 00:12:4b:00:18:00:82:8f
Jul 27 08:54:20 raspberrypi bert[341]: Setting unicast counter 503
Jul 27 08:55:02 raspberrypi bert[341]: akes: Received HELLO from 00:12:4b:00:18:00:82:8f
Jul 27 08:55:02 raspberrypi bert[341]: Deleting neighbor Status 1 00:12:4b:00:18:00:85:0d
Jul 27 08:55:02 raspberrypi bert[341]: noncoresec-strategy: Inauthentic frame
Jul 27 08:55:02 raspberrypi bert[341]: akes: Starting new session with permanent neighbor
Jul 27 08:55:02 raspberrypi bert[341]: akes: Will send HELLOACK in 2s
Jul 27 08:55:05 raspberrypi bert[341]: akes: Sending HELLOACK to 00:12:4b:00:18:00:82:8f
Jul 27 08:55:05 raspberrypi bert[341]: Setting unicast counter 504
Jul 27 08:56:00 raspberrypi bert[341]: akes: Received HELLO from 00:12:4b:00:18:00:82:8f
Jul 27 08:56:00 raspberrypi bert[341]: Deleting neighbor Status 1 00:12:4b:00:18:00:82:8f
Jul 27 08:56:00 raspberrypi bert[341]: noncoresec-strategy: Inauthentic frame
Jul 27 08:56:00 raspberrypi bert[341]: akes: Starting new session with permanent neighbor
Jul 27 08:56:00 raspberrypi bert[341]: akes: Will send HELLOACK in 1s
Jul 27 08:56:02 raspberrypi bert[341]: akes: Sending HELLOACK to 00:12:4b:00:18:00:82:8f
Jul 27 08:56:02 raspberrypi bert[341]: Setting unicast counter 505
Jul 27 08:57:20 raspberrypi bert[341]: akes: Received HELLO from 00:12:4b:00:18:00:82:8f
Jul 27 08:57:20 raspberrypi bert[341]: Deleting neighbor Status 1 00:12:4b:00:18:00:82:8f
Jul 27 08:57:20 raspberrypi bert[341]: noncoresec-strategy: Inauthentic frame
Jul 27 08:57:20 raspberrypi bert[341]: akes: Starting new session with permanent neighbor
Jul 27 08:57:20 raspberrypi bert[341]: akes: Will send HELLOACK in 1s
Jul 27 08:57:21 raspberrypi bert[341]: akes: Sending HELLOACK to 00:12:4b:00:18:00:82:8f
Jul 27 08:57:21 raspberrypi bert[341]: Setting unicast counter 506
Jul 27 08:59:09 raspberrypi bert[341]: akes: Received HELLO from 00:12:4b:00:16:7c:46:51
Jul 27 08:59:09 raspberrypi bert[341]: Deleting neighbor Status 1 00:12:4b:00:18:00:82:8f
Jul 27 08:59:09 raspberrypi bert[341]: noncoresec-strategy: Inauthentic frame
Jul 27 08:59:09 raspberrypi bert[341]: akes: Starting new session with permanent neighbor
Jul 27 08:59:09 raspberrypi bert[341]: akes: Will send HELLOACK in 2s
Jul 27 09:02:03 raspberrypi bert[341]: akes: Received HELLO from 00:12:4b:00:18:00:82:8f
Jul 27 09:02:03 raspberrypi bert[341]: Deleting neighbor Status 1 00:12:4b:00:16:7c:46:32
Jul 27 09:02:03 raspberrypi bert[341]: noncoresec-strategy: Inauthentic frame
Jul 27 09:02:03 raspberrypi bert[341]: akes: Starting new session with permanent neighbor
Jul 27 09:02:03 raspberrypi bert[341]: akes: Will send HELLOACK in 0s
Jul 27 09:02:03 raspberrypi bert[341]: akes: Sending HELLOACK to 00:12:4b:00:18:00:82:8f
Jul 27 09:02:03 raspberrypi bert[341]: Setting unicast counter 529
Jul 27 09:02:12 raspberrypi bert[341]: Setting unicast counter 530
Jul 27 09:02:12 raspberrypi bert[341]: Sending UPDATE to 00:12:4b:00:18:00:82:8f
Jul 27 09:02:13 raspberrypi bert[341]: akes-delete: Sent UPDATE
Jul 27 09:02:28 raspberrypi bert[341]: Deleting neighbor Status 0 00:12:4b:00:18:00:82:8f
Jul 27 09:18:29 raspberrypi bert[341]: akes: Received HELLO from 00:12:4b:00:18:00:82:8f
Jul 27 09:18:29 raspberrypi bert[341]: Deleting neighbor Status 1 00:12:4b:00:16:7c:46:32
Jul 27 09:18:29 raspberrypi bert[341]: akes: Will send HELLOACK in 2s
Jul 27 09:18:32 raspberrypi bert[341]: akes: Sending HELLOACK to 00:12:4b:00:18:00:82:8f
Jul 27 09:18:32 raspberrypi bert[341]: Setting unicast counter 544
I have some prints at the input of adaptivesec to check if any packet has been received.
I will try enabling prints at the possible error in contikimac or framer802154 parser.
Kindly please provide your inputs.
I will try to move to contiki-ng meanwhile.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/kkrentz,103,https://github.com/contiki-os/contiki/pull/1703#issuecomment-408338546,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","The problem seems to be outside of adaptivesec. It could be due to ContikiMAC, which is known to suffer from some timing issues. Besides, I have also encountered a lot of trouble with CSMA in the past. If you are using a CC2538-based platform, you may try my CSL implementation https://github.com/kkrentz/contiki-ng/wiki/CSL instead.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1703,2016-06-03T10:11:27Z,,2018-08-06T07:09:10Z,OPEN,False,4625,516,71,https://github.com/kkrentz,Adaptive 802.15.4 Security,19,"['enhancement', 'Core', 'nominated']",https://github.com/contiki-os/contiki/pull/1703,https://github.com/amitbhanja,104,https://github.com/contiki-os/contiki/pull/1703#issuecomment-410609847,"Currently, the noncoresec_driver has various problems:

At some point, nodes cannot accept further neighbors because anti-replay data of disappeared neighbors is never deleted.
If a node reboots, its frame counter starts over. This causes neighbors to consider a rebooted node's frames as replayed and also ensues a nonce reuse in 802.15.4 security.
Moreover, if a node reboots, its anti-replay data gets lost, thus exposing rebooted nodes to replay attacks.

This pull request adds the adaptivesec_driver, which avoids the problems above by establishing session keys. For usage details, see https://github.com/kkrentz/contiki/tree/adaptivesec/core/net/llsec/adaptivesec.","@kkrentz , thanks a lot for your advice. I am actually using srf06-cc26xx platform. What settings would you suggest to enable in contiki-ng for proper working? I am observing in the original contiki version that after using security, there have been issues of sometimes no packet being received at the gateway. Upon restarting those nodes, packets are being received. It seems to be issues with contikimac along with radio driver.
Well , I will test with contiki-ng. Please recommend what settings to do for cc26xx platforms.
Using null-seeder now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1704,2016-06-03T10:25:08Z,2016-06-24T23:30:16Z,2016-06-30T15:10:33Z,MERGED,True,4,2,1,https://github.com/kkrentz,One fix to CC2538 hardware security,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1704,https://github.com/kkrentz,1,https://github.com/contiki-os/contiki/pull/1704,"First, I adapted the cc2538_aes_128_driver to reboot if an error occurs. I also considered handling errors, but I think that this would result in a lot of rarely tested code. After all, I have never actually encountered errors when calling cc2538_aes_128_driver. Nevertheless, I am afraid that an attacker may provoke errors and then bad things may happen.","First, I adapted the cc2538_aes_128_driver to reboot if an error occurs. I also considered handling errors, but I think that this would result in a lot of rarely tested code. After all, I have never actually encountered errors when calling cc2538_aes_128_driver. Nevertheless, I am afraid that an attacker may provoke errors and then bad things may happen.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1704,2016-06-03T10:25:08Z,2016-06-24T23:30:16Z,2016-06-30T15:10:33Z,MERGED,True,4,2,1,https://github.com/kkrentz,One fix to CC2538 hardware security,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1704,https://github.com/kkrentz,2,https://github.com/contiki-os/contiki/pull/1704#issuecomment-228292814,"First, I adapted the cc2538_aes_128_driver to reboot if an error occurs. I also considered handling errors, but I think that this would result in a lot of rarely tested code. After all, I have never actually encountered errors when calling cc2538_aes_128_driver. Nevertheless, I am afraid that an attacker may provoke errors and then bad things may happen.","@bthebaudeau #1737 fixes my reboot issue, too. Also thanks for pointing out the casting bug in my RF driver.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1704,2016-06-03T10:25:08Z,2016-06-24T23:30:16Z,2016-06-30T15:10:33Z,MERGED,True,4,2,1,https://github.com/kkrentz,One fix to CC2538 hardware security,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1704,https://github.com/bthebaudeau,3,https://github.com/contiki-os/contiki/pull/1704#issuecomment-228488366,"First, I adapted the cc2538_aes_128_driver to reboot if an error occurs. I also considered handling errors, but I think that this would result in a lot of rarely tested code. After all, I have never actually encountered errors when calling cc2538_aes_128_driver. Nevertheless, I am afraid that an attacker may provoke errors and then bad things may happen.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1705,2016-06-03T11:28:12Z,2016-06-03T19:59:25Z,2017-10-27T20:03:17Z,MERGED,True,5,4,2,https://github.com/simonduq,Platform nrf52dk: use RTIMER_CLOCK_DIFF instead of RTIMER_CLOCK_LT,3,[],https://github.com/contiki-os/contiki/pull/1705,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1705,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1705,2016-06-03T11:28:12Z,2016-06-03T19:59:25Z,2017-10-27T20:03:17Z,MERGED,True,5,4,2,https://github.com/simonduq,Platform nrf52dk: use RTIMER_CLOCK_DIFF instead of RTIMER_CLOCK_LT,3,[],https://github.com/contiki-os/contiki/pull/1705,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1705#issuecomment-223562411,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,"I just tested this and now there is no warnings, thanks for the fix (also @greg-king5 for the suggestion).  Could you please also un-comment the code, and add back the test-timer to the nrf52dk regression test?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1705,2016-06-03T11:28:12Z,2016-06-03T19:59:25Z,2017-10-27T20:03:17Z,MERGED,True,5,4,2,https://github.com/simonduq,Platform nrf52dk: use RTIMER_CLOCK_DIFF instead of RTIMER_CLOCK_LT,3,[],https://github.com/contiki-os/contiki/pull/1705,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1705#issuecomment-223563434,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,done,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1705,2016-06-03T11:28:12Z,2016-06-03T19:59:25Z,2017-10-27T20:03:17Z,MERGED,True,5,4,2,https://github.com/simonduq,Platform nrf52dk: use RTIMER_CLOCK_DIFF instead of RTIMER_CLOCK_LT,3,[],https://github.com/contiki-os/contiki/pull/1705,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1705#issuecomment-223563836,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,Thanks! let's wait for Travis but üëç from me,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1705,2016-06-03T11:28:12Z,2016-06-03T19:59:25Z,2017-10-27T20:03:17Z,MERGED,True,5,4,2,https://github.com/simonduq,Platform nrf52dk: use RTIMER_CLOCK_DIFF instead of RTIMER_CLOCK_LT,3,[],https://github.com/contiki-os/contiki/pull/1705,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1705#issuecomment-223594080,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,any idea what might be going on here @alignan ?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1705,2016-06-03T11:28:12Z,2016-06-03T19:59:25Z,2017-10-27T20:03:17Z,MERGED,True,5,4,2,https://github.com/simonduq,Platform nrf52dk: use RTIMER_CLOCK_DIFF instead of RTIMER_CLOCK_LT,3,[],https://github.com/contiki-os/contiki/pull/1705,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1705#issuecomment-223645748,addresses https://github.com/contiki-os/contiki/pull/1701/files/7dd2f1144bfd56a2374839482646231cb926c95e#r65634049,"There is a typo, the test is timer-test, sorry!
Building example 01: hello-world/ for target nrf52dk
hello-world/ nrf52dk: OK
Building example 02: nrf52dk/coap-demo/ coap-server for target nrf52dk
nrf52dk/coap-demo/ nrf52dk: OK
Building example 03: nrf52dk/coap-demo/ coap-client SERVER_IPV6_ADDR=ffff for target nrf52dk
nrf52dk/coap-demo/ nrf52dk: OK
Building example 04: nrf52dk/mqtt-demo/ for target nrf52dk
nrf52dk/mqtt-demo/ nrf52dk: OK
Building example 05: nrf52dk/blink-hello/ for target nrf52dk
nrf52dk/blink-hello/ nrf52dk: OK
Building example 06: nrf52dk/timer-test/ for target nrf52dk
nrf52dk/timer-test/ nrf52dk: OK",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1706,2016-06-03T11:32:22Z,2016-06-03T13:13:08Z,2016-06-03T13:13:08Z,MERGED,True,192,197,7,https://github.com/oliverschmidt,Make use of new cl65 option --print-target-path.,1,[],https://github.com/contiki-os/contiki/pull/1706,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/1706,The new cl65 option --print-target-path allows to get rid of CC65_HOME altogether.,The new cl65 option --print-target-path allows to get rid of CC65_HOME altogether.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1708,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224233895,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,Travis unhappy üòû,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224264409,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,I think the failure was related to bad RNG quality on msp430. Tried to fix that by changing random_rand() to random_rand() >> 2 - not using the lowest-order bits usually gives better results.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/atiselsts,4,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224560264,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,"I addressed your comments. Changed parameter names and commented tsch_radio_on and tsch_radio_off functions, hopefully clearer now.
Randomization in scanning stage is reverted back to the one-second-per channel behavior, only now the scan duration is configurable. Looked like randomization helps to join the network faster, but this needs more investigation.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224560714,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,"OK, thanks! I wish we add a general definition of CLOCK_LT at some point, will help for features such as what you had with random scanning times.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224561048,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,"Could you change the commit log for this?
bcab9d6",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/atiselsts,7,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224564631,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,"Now I had an idea that having an enum argument for tsch_radio_on and tsch_radio_off makes the calling code easier to read - updated the code, what do you think?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1708#issuecomment-224565467,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,"Right, I forgot about this part. Yes, I like this much more!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1708#issuecomment-225631567,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/g-oikonomou,10,https://github.com/contiki-os/contiki/pull/1708#issuecomment-225672410,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,@simonduq are you happy for this to get merged?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1708,2016-06-06T22:04:14Z,2016-06-13T18:58:02Z,2016-06-29T11:21:28Z,MERGED,True,161,55,6,https://github.com/atiselsts,TSCH enhancements,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1708,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1708#issuecomment-225675263,This patch fixes some minor bugs and prepares TSCH code for a port to the CC2650 platform.,Yep sure!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1709,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/atiselsts,2,https://github.com/contiki-os/contiki/pull/1709#issuecomment-225721794,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","Now that #1708 and #1684 have been merged, how about reviewing this? I rebased to the latest Contiki master just now. Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1709#issuecomment-225732385,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","Atis, thanks for your efforts with this!
I went through most of it and it looks great. I know I still owe you taking a look at fast RF startup and I'd also like to see what logic you decided to use for CCA (OR vs AND).
Other than that, superb.
Closes #1615",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1709#issuecomment-225811070,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.",Great contribution. Now that #1708 is in I'm fine with this PR getting merged as it doesn't touch core.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1709#issuecomment-225972156,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.",My objections about the changes to the UART driver have been addressed and I'm happy with the node_id thing as Atis says. I'll merge this when travis goes green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1709#issuecomment-225972908,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","I like the idea of node_id being standard, happy to merge a PR on that",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1709#issuecomment-225975238,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.",Now we have TSCH supported on all major platforms! Let's make it the default MAC ;),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/niklas88,8,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227132825,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","I'm seeing a regression in power consumption with these changes. I'm using a TI SensorTag with a simple RIME Collect app for collecting sensor data. In the first figure power consumption is plotted with a version before the TSCH changes, the second is with them and the third figure is a zoom in of the higher power consumption area in the second.(Actually these specific graphs are from the ContikiMAC-Async branch because I didn't save the plots in the master branch but they look basically the same except for less efficient channel probing and worse phase opt).
I've tried with all sensor reading disabled so it's not an interference with that.



My project-conf.h looks like this:  http://pastebin.com/0JBthp66
I've tried bisecting but got compile errors at several of the commits so that only narrowed it down to the following.
The first bad commit could be any of:
97c1cfc
e19fbc9
25c5f0b
3a99639
80aa30c
a47fb72
54e4b5f
95b6665
ac6f800
d85667d
e233c3f",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/atiselsts,9,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227235930,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","Dear Niklas, the patchset introduces an ""early wakeup"" logic for
CC26xx. The lpm.c code exits deep sleep mode 1 ms before the actual
wakeup is requested in order to initialize HF crystal oscillator so
that it can be used soon enough after the start of a TSCH timeslot.
That means spending 1ms extra time before each wakeup in what Contiki
calls ""sleep mode"" (not deep sleep) with >1 mA current consumption.
The new logic is enabled by default. Add this to project-conf.h to disable it:
#define CC2650_FAST_RADIO_STARTUP     0
Would be great if you could verify that this fixes the problem for you

there are also some other changes and bugfixes in lpm.c file and the
IEEE mode radio driver.

I agree that this is unfortunate that this change affects completely
unrelated applications. The problem is that there is no easy way to
produce different default CC26xx platform's configs for TSCH
applications and for non-TSCH applications - there is no compile-time
constant that tells whether TSCH is enabled. There is also no way to
tell before a wakeup whether the radio is actually going to be used
immediately after it, so the code in lpm.c just assumes the worst case
and always starts the HF crystal oscillator.
On Mon, Jun 20, 2016 at 3:50 PM, Niklas Schnelle
notifications@github.com wrote:

I'm seeing a regression in power consumption with these changes. I'm using a
TI SensorTag with a simple RIME Collect app for collecting sensor data. In
the first figure power consumption is plotted with a version before the TSCH
changes, the second is with them and the third figure is a zoom in of the
higher power consumption area in the second. I've tried with all sensor
reading disabled so it's not an interference with that.
My project-conf.h looks like this: http://pastebin.com/0JBthp66
I've tried bisecting but got compile errors at several of the commits so
that only narrowed it down to the following.
The first bad commit could be any of:
97c1cfc
e19fbc9
25c5f0b
3a99639
80aa30c
a47fb72
54e4b5f
95b6665
ac6f800
d85667d
e233c3f
‚Äî
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub, or mute the thread.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/bkozak-scanimetrics,10,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227250617,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","I've just had a quick look at the changes that have been made to lpm.c and I think I know what @niklas88's problem is.
The updated lpm code appears to have removed the default sleep period that I had added to reduce power consumption when no etimers are running.
You can see the relevant changes on this diff (scroll down to the removed line 452 to see the code which had been removed).
This will only tend to affect RIME code since we'll usually have at least one etimer scheduled at all times when running IPv6. @niklas88 is running RIME so this is probably his issue. If you add back the else clause that was removed with this PR then you should see the problem go away.
Although the code under CC2650_FAST_RADIO_STARTUP is likely to increase power consumption also, I don't believe that it is the cause of your issue.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/niklas88,11,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227364806,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","Thanks all for looking into this. Unfortunately both suggestions didn't fix the problem.
I used the following diff for @bkozak-scanimetrics hint:
http://pastebin.com/RhtxX4TL
Unfortunately I'm not sure I can  share my code publicly even though I'd consider it a pretty trivial derivative mix of example-collect.c and cc26xx-demo.c. As for no etimers running. In my design there are two processes. One has an explicit etimer with a period of 5 seconds which triggers sensor readouts. After all sensor data is retrieved (the sensors_events have fired and the data been read) this process posts to another process which sends all sensor data as a single message via collect_send().
I guess I could share the raw power usage data though if that helps.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227377063,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","@atiselsts don't be afraid of adding some platform-specific config for tsch in the tsch example's project-conf for now. This is how we do it currently. Ofc in the long run we need something better, e.g. a platform specific conf file included after project-conf, or a make flag.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/atiselsts,13,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227401918,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","I will look into energy consumption and try to prepare a patch in the next
week when I have access to hardware again. One problem in your setup is
CC2650_FAST_RADIO_STARTUP for sure; if there is something else we need to
find out.
Simon, now that I think about it, I still would like to avoid the need to
have application-specific config to get TSCH running. Not particularly
new-user friendly, and does not scale with the number of platforms.
I feel that a better option is either to reduce the ""early wakeup"" time as
much as possible (it's definitely possible to go below 1ms, but we need
longer-term experiments to confirms that there's no bad effect on PDR), or
to have slightly nonstandard timing. Using 15 ms TSCH slots was one
solution, but reducing the TSCH guard time size just a little (say, to 2ms
instead of 2.2ms) for CC26xx would also allow help. That way CC26xx could
get rid of CC2650_FAST_RADIO_STARTUP as the default config option. (It
would still keep this setting as an option, as some applications may need
it.)
Getting rid of the FAST_STARTUP trick also means better energy efficiency
for TSCH applications. Interestingly, 6tisch RFCs actually talk about 1ms
guard time instead of 2.2 ms. Given that TSCH syncs on EBs, and EB period
in Contiki is just 4 seconds, 2.2ms long guard time is not really needed
for reliability by default; the only reason to have it is ""because the IEEE
802.15.4 standard says so"" in my opinion. If having it makes stuff much
worse on a specific platform, it makes sense to ignore this recommendation
on that platform.
On Tue, Jun 21, 2016 at 11:41 AM, Simon Duquennoy notifications@github.com
wrote:

@atiselsts https://github.com/atiselsts don't be afraid of adding some
platform-specific config for tsch in the tsch example's project-conf for
now. This is how we do it currently. Ofc in the long run we need something
better, e.g. a platform specific conf file included after project-conf, or
a make flag.
‚Äî
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub
#1709 (comment),
or mute the thread
https://github.com/notifications/unsubscribe/ADnwYS9HA01bNW9lqJWgtRcv-dvPzuykks5qN6OvgaJpZM4IvXqB
.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/bkozak-scanimetrics,14,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227454576,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","One has an explicit etimer with a period of 5 seconds which triggers sensor readouts.

In that case, I think I may see the issue. It's still sort of in the same vein as the last issue I pointed out. The issue will occur whenever you have no etimer which is set to expire at less than 1 second (i.e. MAX_SLEEP_TIME) into the future.
If you trace the logic in setup_sleep_mode(), you'll find that with a 5 second etimer, you won't end up setting a wakeup interrupt at all. This will cause you to wake up on the next clock tick.
See the code snippet from setup_sleep_mode() below with my comments added:
next_etimer = soc_rtc_last_isr_time() + (until_next_etimer * (RTIMER_SECOND / CLOCK_SECOND));
    if(RTIMER_CLOCK_LT(next_etimer, now + STANDBY_MIN_DURATION)) {
      soc_rtc_schedule_one_shot(AON_RTC_CH1, now + MINIMAL_SAFE_SCHEDULE);
      return LPM_MODE_SLEEP;
    }
    /* With a 5 second etimer, you'll end up in this conditional here. The variable
        max_sleep is set one second into the future. */
    if(RTIMER_CLOCK_LT(max_sleep, next_etimer)) {

      /* *next_timer holds the time of the next clock tick, this will be
          less than max sleep so you'll skip this */
      if(RTIMER_CLOCK_LT(max_sleep, *next_timer)) {
        soc_rtc_schedule_one_shot(AON_RTC_CH1, max_sleep);
      }
    } else {
      soc_rtc_schedule_one_shot(AON_RTC_CH1, next_etimer);
    }

    /* then we end up here without having scheduled AON_RTC_CH1.
       the CH1 interrupt will remain set to the next clock tick in 512 RTC ticks. 
       There are no more opportunities to set CH1 after this. */

    if(RTIMER_CLOCK_LT(next_etimer, *next_timer)) {
      *next_timer = next_etimer;
    }
Once again, this is something that is unlikely to occur with IPv6 since we will most often have some etimer scheduled at a point less than 1 second into the future.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/bkozak-scanimetrics,15,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227458702,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","Simon, now that I think about it, I still would like to avoid the need to have application-specific config to get TSCH running.

I'm not at all familiar with the TSCH code so, forgive me if I say something stupid, but would it not be better to avoid doing this in lpm.c altogether? Having to pay the cost of the early wakeup on every single sleep cycle seems wasteful.
Surely this fast wakeup can be accomplished by setting an rtimer to occur 1ms before your planned radio turn on then using a reigstered lpm module to stay awake until the actual time slot. If you're already using an rtimer then #1290 will allow you to set more than one.
Again, forgive me if I've misunderstood something about the problem. Perhaps the issue is that you don't know for sure when you will next need to turn on the radio?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/niklas88,16,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227491877,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","@bkozak-scanimetrics your reasoning makes sense to me, so does this mean the DEFAULT_SLEEP_TIME else needs to be somewhere else to actually work as compared with the change I tried?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/bkozak-scanimetrics,17,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227496862,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","DEFAULT_SLEEP_TIME else needs to be somewhere else to actually work as compared with the change I tried?

That'll work, but you could also leave the other DEFAULT_SLEEP_TIME you added before since that one covers the seperate case where no etimers are set.
It should fix your issue if you add your else clause after
      if(RTIMER_CLOCK_LT(max_sleep, *next_timer)) {
        soc_rtc_schedule_one_shot(AON_RTC_CH1, max_sleep);
      }
which is at line 307 of the current lpm.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/atiselsts,18,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227529847,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","Billy, I believe you have now found the problem - let's wait for the
results. Somehow missed the fact the CH1 interrupts are generated by
default on each tick.
The code can in `setup_sleep_mode` can be simplified as a result - it
should always reschedule the CH1 interrupt before sleeping.

With regards to the design decisions behind all this, I think Simon is the
best person to answer and explain that. I believe the main constraints are
to keep the core TSCH code platform-independent and to not schedule any
timers related to a specific timeslot before the start of that timeslot
(i.e. do not occupy the previous timeslot, as it might be busy).
‚Äã",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/bkozak-scanimetrics,19,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227532885,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.","I believe the main constraints are to keep the core TSCH code platform-independent

Right, completely slipped my mind that the lpm modules aren't platform independent.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1709,2016-06-06T22:12:19Z,2016-06-15T09:28:58Z,2016-06-29T11:21:26Z,MERGED,True,636,211,11,https://github.com/atiselsts,TSCH port for CC26xx  ,14,"['Platform / CPU / ARM / CC13xx-CC26xx', 'new feature']",https://github.com/contiki-os/contiki/pull/1709,https://github.com/niklas88,20,https://github.com/contiki-os/contiki/pull/1709#issuecomment-227666550,"This pull request adds a full-featured (HW timetamps, polling mode, etc.) TSCH port on CC26xx. This port has been tested for several months in a small testbed with custom CC26xx SoC based devices at the University of Bristol.
Depends on #1708 and #1684 (#1708 is used as the base branch, and some cherry-picked commits included from #1684).
Fixes #1615.",Good news everyone! I've just done a power consumption test with the suggested changes and it seems to indeed solve the problem. I used both the older change as well as the new one. I guess however that since this makes the setup_sleep function pretty convoluted it would be best to get it properly organized? I'd of course be happy to test such changes.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1710,2016-06-07T01:38:56Z,2016-06-08T22:06:10Z,2016-06-08T22:06:10Z,CLOSED,False,110,14,4,https://github.com/casaroli,cc26xx ieee mode rf driver: fixes and features required for TSCH,9,[],https://github.com/contiki-os/contiki/pull/1710,https://github.com/casaroli,1,https://github.com/contiki-os/contiki/pull/1710,"these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.","these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1710,2016-06-07T01:38:56Z,2016-06-08T22:06:10Z,2016-06-08T22:06:10Z,CLOSED,False,110,14,4,https://github.com/casaroli,cc26xx ieee mode rf driver: fixes and features required for TSCH,9,[],https://github.com/contiki-os/contiki/pull/1710,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1710#issuecomment-224233433,"these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.",Does this conflicts with #1709 ?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1710,2016-06-07T01:38:56Z,2016-06-08T22:06:10Z,2016-06-08T22:06:10Z,CLOSED,False,110,14,4,https://github.com/casaroli,cc26xx ieee mode rf driver: fixes and features required for TSCH,9,[],https://github.com/contiki-os/contiki/pull/1710,https://github.com/casaroli,3,https://github.com/contiki-os/contiki/pull/1710#issuecomment-224272882,"these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.","Yes. I saw the #1709 just after my PR. I guess it fixes all in #1710.
I did not drop it yet so I we can use for comparison.
I gonna test #1709 and then I drop my PR.
BR
On ter, 7 de jun de 2016 at 06:53 Antonio Lignan notifications@github.com
wrote:

Does this conflicts with #1709
#1709 ?
‚Äî
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub
#1710 (comment),
or mute the thread
https://github.com/notifications/unsubscribe/ADszaDgJB8wF-JTDyKOv5pkaHZ5m7NnSks5qJT-IgaJpZM4IveT6
.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1710,2016-06-07T01:38:56Z,2016-06-08T22:06:10Z,2016-06-08T22:06:10Z,CLOSED,False,110,14,4,https://github.com/casaroli,cc26xx ieee mode rf driver: fixes and features required for TSCH,9,[],https://github.com/contiki-os/contiki/pull/1710,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1710#issuecomment-224274430,"these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.","Thanks! sorry for any inconvenience, and please comment!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1710,2016-06-07T01:38:56Z,2016-06-08T22:06:10Z,2016-06-08T22:06:10Z,CLOSED,False,110,14,4,https://github.com/casaroli,cc26xx ieee mode rf driver: fixes and features required for TSCH,9,[],https://github.com/contiki-os/contiki/pull/1710,https://github.com/atiselsts,5,https://github.com/contiki-os/contiki/pull/1710#issuecomment-224293541,"these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.","Looks like amazing coincidence.
Thanks @casaroli - I saw two things in your pull request that I had missed:

avoiding setting packetbuf attributes while in interrupt context
expanding RX_BUF_SIZE by 4 bytes to make room for timestamp.

I took the liberty to update my PR with these changes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1710,2016-06-07T01:38:56Z,2016-06-08T22:06:10Z,2016-06-08T22:06:10Z,CLOSED,False,110,14,4,https://github.com/casaroli,cc26xx ieee mode rf driver: fixes and features required for TSCH,9,[],https://github.com/contiki-os/contiki/pull/1710,https://github.com/casaroli,6,https://github.com/contiki-os/contiki/pull/1710#issuecomment-224325064,"these are features required by the TSCH port.
the (non-tsch) examples seem to still be working after these changes.","Hello Atis,
I am glad it helped somehow!
BR
On ter, 7 de jun de 2016 at 11:15 Atis Elsts notifications@github.com
wrote:

Looks like amazing coincidence.
Thanks @casaroli https://github.com/casaroli - I saw two things in your
pull request that I had missed:

avoiding setting packetbuf attributes while in interrupt context
expanding RX_BUF_SIZE by 4 bytes to make room for timestamp.

I took the liberty to update my PR with these changes.
‚Äî
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub
#1710 (comment),
or mute the thread
https://github.com/notifications/unsubscribe/ADszaE-XeatqqxGbHlrtBbG5HFU3hqQEks5qJXz0gaJpZM4IveT6
.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1711,2016-06-08T07:36:34Z,2016-06-28T22:55:02Z,2016-06-28T22:55:02Z,MERGED,True,2,2,1,https://github.com/xukai871105,One fix to sensorTag board_i2c.c,2,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1711,https://github.com/xukai871105,1,https://github.com/contiki-os/contiki/pull/1711,"According to ‚ÄúCC1310, CC26XX Simplelink Wireless MCU Technical Reference Manual‚Äù In Figure 21-10 In Master RECEIVE With Repeated Start Condition. After reading len-1 bytes from slave device(such as mpu9250), CC13XX/CC26XX should write 101 to I2C_MCTRL firstly(ti_lib_i2c_master_control(I2C0_BASE, I2C_MASTER_CMD_BURST_RECEIVE_FINISH)),then read the data from I2C_MDR(ti_lib_i2c_master_data_get(I2C0_BASE)).There is something wrong in board_i2c.c board_i2c_read() and board_i2c_write_read()
On sensorTag platform mpu9250 works fine.But when we monitor the I2Cbus, we find that mpu9250 gives one more byte and CC2650 sends I2C_STOP at a worng time.
We have done the test on PN7120(NFC controller from NXP), new board_i2c_read() and board_i2c_write_read work fine.","According to ‚ÄúCC1310, CC26XX Simplelink Wireless MCU Technical Reference Manual‚Äù In Figure 21-10 In Master RECEIVE With Repeated Start Condition. After reading len-1 bytes from slave device(such as mpu9250), CC13XX/CC26XX should write 101 to I2C_MCTRL firstly(ti_lib_i2c_master_control(I2C0_BASE, I2C_MASTER_CMD_BURST_RECEIVE_FINISH)),then read the data from I2C_MDR(ti_lib_i2c_master_data_get(I2C0_BASE)).There is something wrong in board_i2c.c board_i2c_read() and board_i2c_write_read()
On sensorTag platform mpu9250 works fine.But when we monitor the I2Cbus, we find that mpu9250 gives one more byte and CC2650 sends I2C_STOP at a worng time.
We have done the test on PN7120(NFC controller from NXP), new board_i2c_read() and board_i2c_write_read work fine.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1711,2016-06-08T07:36:34Z,2016-06-28T22:55:02Z,2016-06-28T22:55:02Z,MERGED,True,2,2,1,https://github.com/xukai871105,One fix to sensorTag board_i2c.c,2,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1711,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1711#issuecomment-224550765,"According to ‚ÄúCC1310, CC26XX Simplelink Wireless MCU Technical Reference Manual‚Äù In Figure 21-10 In Master RECEIVE With Repeated Start Condition. After reading len-1 bytes from slave device(such as mpu9250), CC13XX/CC26XX should write 101 to I2C_MCTRL firstly(ti_lib_i2c_master_control(I2C0_BASE, I2C_MASTER_CMD_BURST_RECEIVE_FINISH)),then read the data from I2C_MDR(ti_lib_i2c_master_data_get(I2C0_BASE)).There is something wrong in board_i2c.c board_i2c_read() and board_i2c_write_read()
On sensorTag platform mpu9250 works fine.But when we monitor the I2Cbus, we find that mpu9250 gives one more byte and CC2650 sends I2C_STOP at a worng time.
We have done the test on PN7120(NFC controller from NXP), new board_i2c_read() and board_i2c_write_read work fine.",This looks reasonable. We're looking into it.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1712,2016-06-08T11:37:04Z,2016-06-08T12:03:46Z,2016-06-08T12:03:46Z,CLOSED,False,9093,0,72,https://github.com/tqhuy812,CoAP_server-RPL_br-TSCH_minimal,4,[],https://github.com/contiki-os/contiki/pull/1712,https://github.com/tqhuy812,1,https://github.com/contiki-os/contiki/pull/1712,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1714,2016-06-09T13:58:34Z,2016-06-13T18:45:46Z,2016-06-13T18:45:47Z,MERGED,True,306,1,4,https://github.com/alignan,Added generic relay driver for the zoul-based platforms,1,"['enhancement', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1714,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1714,This is a simple driver I often get asked to provide.  It basically allows to connect a common relay module (such as this one from Phidget or this one from Seeedstudio).,This is a simple driver I often get asked to provide.  It basically allows to connect a common relay module (such as this one from Phidget or this one from Seeedstudio).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/1715,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1715#issuecomment-224932543,,"Cool :)
Two things:

please add the new supported platforms to the TSCH readme (several locations within the file)
regarding the node-id problem in rpl-tsch, I'm not particularly keen on keeping it as it is. We could for instance replace it with a hardcoded coordinator address, set by default to the MAC address of node 1 in Cooja for z1 nodes (because this is what is used for the regression tests)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1715#issuecomment-224933300,,"Great contrib! I thought this was already included in the previous CC2538/TSCH commit, so great to have üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/sumanpanchal,4,https://github.com/contiki-os/contiki/pull/1715#issuecomment-225429519,,"@simonduq @alignan
I have done all the necessary changes as per your suggestion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1715#issuecomment-225438566,,"üëç from me, @simonduq?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1715#issuecomment-225503203,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1715,2016-06-09T15:27:04Z,2016-06-13T07:03:16Z,2016-06-13T07:17:00Z,MERGED,True,38,21,3,https://github.com/sumanpanchal,TSCH port for Zolertia ReMote/Zoul.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'Network']",https://github.com/contiki-os/contiki/pull/1715,https://github.com/sumanpanchal,7,https://github.com/contiki-os/contiki/pull/1715#issuecomment-225505295,,Thanks @simonduq and @alignan :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1718,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc","Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225396055,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225396729,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc",üëç !,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/bthebaudeau,4,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225399752,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc","Thanks for having restarted https://travis-ci.org/contiki-os/contiki/jobs/136978910. It has now passed. The Java VM had segfaulted, so it was unrelated to the previous large-rpl timeouts.
https://travis-ci.org/contiki-os/contiki/jobs/136978924 has failed because of a missing public key issue with ppa:team-gcc-arm-embedded/ppa for nrf52dk. It worked previously, so it must be a temporary issue. Can you please restart this build job? If it still fails, the following commands can be added, or wget can be used instead.
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys D1FAA6ECF64D33B0
sudo apt-get update",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225400091,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc","I've restarted the job. You should be able to do so yourself if you log in travis with your GH credentials.
Switching to wget is probably a good idea, as we recently found out (#1587)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225400125,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc",And this is now all green.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/bthebaudeau,7,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225400299,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc","I've restarted the job.

Thanks.

You should be able to do so yourself if you log in travis with your GH credentials.

Indeed. I've just noticed this. I just had to authorize Travis to access my account for contiki-os.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1718,2016-06-11T21:37:17Z,2016-06-11T23:27:31Z,2016-06-12T15:33:08Z,MERGED,True,244,1,8,https://github.com/bthebaudeau,Print CC2538 info on boot,3,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1718,https://github.com/mistergomes,8,https://github.com/contiki-os/contiki/pull/1718#issuecomment-225443738,"Print the following SoC information upon startup with STARTUP_CONF_VERBOSE:

chip ID,
revision,
Flash memory size,
SRAM size,
enabled hardware features (AES/SHA, ECC/RSA),
system clock frequency,
I/O clock frequency,
reset cause.

This makes it possible to have most useful information at hand without having to search for it. This can also be useful for debug logs.
With these changes, the first lines printed on boot look like this:
Contiki-3.x-2605-g9845973
Zolertia Firefly platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: POR
Rime configured with address 0f:0c
 Net: Rime
 MAC: CSMA
 RDC: nullrdc","I used to print other info as well,
Like the panid and the radio channel.
It's very useful.
Cheers.
On Sunday, 12 June 2016, Beno√Æt Th√©baudeau notifications@github.com wrote:

I've restarted the job.
Thanks.
You should be able to do so yourself if you log in travis with your GH
credentials.
Indeed. I've just noticed this. I just had to authorize Travis to access
my account for contiki-os.
‚Äî
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub
#1718 (comment),
or mute the thread
https://github.com/notifications/unsubscribe/AKUAA4hg6HwYWNv33jbq7fZt3cARo_f9ks5qK0W0gaJpZM4Izpc-
.



Research Fellow / PhD Student
Embedded Systems Research Group, Centro Algoritmi  (
http://algoritmi.uminho.pt)
Industrial Systems Engineering, AIT (http://www.ise.ait.ac.th/)
Department of Computer Science - Aerospace Information Technology, W√ºrzburg
University (http://www.uni-wuerzburg.de/en/ueber/university/)
Phone: (+351) 253 510 686",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/jcook,1,https://github.com/contiki-os/contiki/pull/1719,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.","RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1719#issuecomment-244893780,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.",The intent of this block was to enable deleting the default route by simply passing a null argument. Closing. Please re-open if I missed something!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/greg-king5,3,https://github.com/contiki-os/contiki/pull/1719#issuecomment-244969328,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.","rpl_set_default_route() replaces an old default-route.  It does that by deleting the old route -- unconditionally; then, adding a new route -- conditionally.  There is no point in trying to delete the old route twice.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1719#issuecomment-244972219,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.","Right, so I was indeed missing something! Makes sense.
Sorry.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1719#issuecomment-244972353,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.",üëç if Travis is green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/MohamedSeliem,6,https://github.com/contiki-os/contiki/pull/1719#issuecomment-245093991,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.","i do not think removing the else statement will do the fix,
you may try this:
int rpl_set_default_route(rpl_instance_t *instance, uip_ipaddr_t *from)
{
if(from != NULL) {
PRINTF(""RPL: Adding default route through "");
PRINT6ADDR(from);
PRINTF(""\n"");
uip_ds6_defrt_rm(instance->def_route); //first remove the old route
instance->def_route = uip_ds6_defrt_add(from,
RPL_DEFAULT_ROUTE_INFINITE_LIFETIME ? 0 : RPL_LIFETIME(instance, instance->default_lifetime));    // add the new route assuming it has value that is not equal to null
if(instance->def_route == NULL) {
return 0;     // however the new def_route is equal null return 0 to indicate that the default route is not added
}
} else {
// in case from is equal to null, then we need to remove the def_route
PRINTF(""RPL: Removing default route\n"");
if(instance->def_route != NULL) {
uip_ds6_defrt_rm(instance->def_route);
} else {
PRINTF(""RPL: Not actually removing default route, since instance had no default route\n"");
}
}
return 1;
}",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/greg-king5,7,https://github.com/contiki-os/contiki/pull/1719#issuecomment-245283753,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.","Why would it not work?  After simply removing that redundant else-block, the old code will continue to do the same thing that your code does; but, it is smaller:

If there is an old route, then remove it.
If a new route was requested, then attempt to add it.
Return ""false"" if that attempt failed.
Return ""true"" if the attempt succeeded, or a delete was requested.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/MohamedSeliem,8,https://github.com/contiki-os/contiki/pull/1719#issuecomment-245419380,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/jcook,9,https://github.com/contiki-os/contiki/pull/1719#issuecomment-245483154,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.",@simonduq so you will merge this change?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1719#issuecomment-245508145,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.","waiting for another pair of eyes from the merge team to validate, see the merging policy:
https://github.com/contiki-os/contiki/blob/master/CONTRIBUTING.md#pull-request-merging-policy",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1719,2016-06-12T04:49:02Z,2016-09-09T14:48:01Z,2016-09-09T14:48:01Z,MERGED,True,0,7,1,https://github.com/jcook,RPL: Remove useless `else' block as def_route will be removed before if ex‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/1719,https://github.com/nvt,11,https://github.com/contiki-os/contiki/pull/1719#issuecomment-245935341,"RPL: Remove useless `else' block as def_route will be removed before if existed.
Keep this logic will bring confusion.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,1,https://github.com/contiki-os/contiki/pull/1720,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225438610,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225556046,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,"Why doing this only for this particular instance of RPL_IS_NON_STORING? Why not do it for the RPL_IS_STORING above?
The purpose of RPL_IS_NON_STORING is to yield simple code that does the compile-time and run-time check. If the other code locations with RPL_IS_NON_STORING don't cause any problem with Clang I'm confident there is a cleaner solution.
How adding a variable instance assigned at the beginning of the function instead? Let it be NULL if dag is NULL.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,4,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225587588,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,"Assigning a runtime variable will not help that function will still be problematic. I can do it like this:
 if(RPL_WITH_STORING && dag != NULL && RPL_IS_STORING(dag->instance)) {
   rpl_purge_routes();
 }
 if(RPL_WITH_NON_STORING && dag != NULL && RPL_IS_NON_STORING(dag->instance)) {
   rpl_ns_periodic();
 }

To make it more ""fair"" between storing and non storing but it needs to be at compile time - clang seems not be the best at figuring out the truth value of the DEFINE RPL_IS_NON_STORING()... It is obviously always false but clang seems to fail seeing that here. (purge_routes are there even in non-storing).
(I like this alternative better as it do not include any nasty #if expressions.)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225588148,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,but RPL_WITH_NON_STORING is checked in RPL_IS_NON_STORING so I don't really understand,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,6,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225588325,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Neither do I. Ask the clang team ;-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225588777,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,"Have you tried:
struct rpl_instance *instance = dag != NULL dag->instance : NULL;
if(RPL_IS_STORING(instance)) {
  rpl_purge_routes();
}
if(RPL_IS_NON_STORING(instance)) {
  rpl_ns_periodic();
}",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,8,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225592917,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Clang is intestesting... Changed the PR a bit now. Since it just needs not to evaluate the dag in the same if... That seems to solve the problem - thanks for the suggestion.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225596025,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Yep there are many other instances of if(RPL_IS_NON_STORING()) so I found it odd you'd only need to fix this one.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,10,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225596365,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Likely due to combining it with something more. I guess we should have a OS-X machine with clang under control of Travis somewhere ;-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225597314,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Can't we do it in Linux?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,12,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225599364,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,"Yes, I guess the same clang as I am running on OS-X should be possible to install in linux also.
(Apple LLVM version 7.3.0 (clang-703.0.31)
Target: x86_64-apple-darwin15.5.0
Thread model: posix).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,13,https://github.com/contiki-os/contiki/pull/1720#issuecomment-225611710,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,"Also fails with this:
Ubuntu clang version 3.5.0-4ubuntu2~trusty2 (tags/RELEASE_350/final) (based on LLVM 3.5.0)
Target: i386-pc-linux-gnu
Thread model: posix
So - yes will also work fine ""failing"" in linux.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,14,https://github.com/contiki-os/contiki/pull/1720#issuecomment-226094961,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,Another message list failure in Cooja - I do think we should add a class method in Simulator that know the visibility - otherwise we will have to throw in that argument in all methods... (Simulator.hasGUI() or similar).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,15,https://github.com/contiki-os/contiki/pull/1720#issuecomment-226115690,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,annoying yes... restarted the job,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/joakimeriksson,16,https://github.com/contiki-os/contiki/pull/1720#issuecomment-226117802,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,I will try to do another Cooja PR during the weekend (if I get the time).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1720,2016-06-12T11:46:49Z,2016-06-15T08:27:58Z,2016-06-15T08:27:58Z,MERGED,True,7,5,1,https://github.com/joakimeriksson,Fix for compilation with clang - issue reported by Olaf Bergmann,1,[],https://github.com/contiki-os/contiki/pull/1720,https://github.com/simonduq,17,https://github.com/contiki-os/contiki/pull/1720#issuecomment-226121688,Clang seems not to discover that the statement is always false (while GCC does) and therefore complains about lack of the function called within the always false block e.g. rpl_ns_periodic();. Olaf Bergmann reported it to me and I got the same problem compiling with clang on my OS-X. This fix the issue.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/1721,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1721#issuecomment-225517202,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),how about the readme file? ;),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1721#issuecomment-225517310,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"(I'm fine if you simplify and use ""cc2538-based platforms"")",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1721#issuecomment-225553908,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233159994,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"@sumanpanchal where are we on this one? This seems pretty straightforward considering that the RF driver supports TSCH in the first place.
@peretuset any thoughts here?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/peretuset,6,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233166756,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"@g-oikonomou, I agree with @simonduq that we should simply state cc2538-based platforms since all of them will support TSCH out of the box once the driver supports it. Do we want to use this PR to do it? Or shall we open a new one?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233185398,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"No strong opinion, may as well use this one if suitable.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233198000,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"Fine either way, but the PR needs a rebase now",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233198093,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"Rename the PR and make the change for all cc2538 platforms, no need to further delay this",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/peretuset,10,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233204176,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"@sumanpanchal, please follow @alignan suggestion in order to complete the PR.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/sumanpanchal,11,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233638478,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"Dear All,
I have done all the necessary changes as per suggestion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233657599,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"Hello,
There still needs to be some conflicts, have rebased on the latest master?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/sumanpanchal,13,https://github.com/contiki-os/contiki/pull/1721#issuecomment-233737000,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),"@simonduq
I have rebased on the latest master now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/alignan,14,https://github.com/contiki-os/contiki/pull/1721#issuecomment-234555507,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),Thanks @sumanpanchal!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/peretuset,15,https://github.com/contiki-os/contiki/pull/1721#issuecomment-234567533,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1721,2016-06-12T15:23:09Z,2016-07-22T14:56:43Z,2016-07-22T15:37:17Z,MERGED,True,15,6,5,https://github.com/sumanpanchal,TSCH port for CC2538 based platforms.,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1721,https://github.com/sumanpanchal,16,https://github.com/contiki-os/contiki/pull/1721#issuecomment-234577505,Have tested rpl-tsch example using two openmote-cc2538. It works.!! :),Welcome üòÑ,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1723,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.","I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1723#issuecomment-225595214,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.","I confirm this is a bug, and not the only one. It is something I had seen and fixed before but forgot to upstream it seems.
I think the test should be:
if((fcf->dest_addr_mode == 0) == (fcf->src_addr_mode == 0)) {
(because we don't want equality, we only want both 0 or both non-0)
Then, the next if if(fcf->dest_addr_mode == 0 && fcf->dest_addr_mode == 1) { should basically be removed together with its content.
The third one should also become:
if(fcf->dest_addr_mode == 0 && fcf->src_addr_mode == 0) {",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/jnohlgard,3,https://github.com/contiki-os/contiki/pull/1723#issuecomment-225777463,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.",I rewrote the conditions based on table 2a in IEEE 802.15.4e-2012,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1723#issuecomment-229020330,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/jnohlgard,5,https://github.com/contiki-os/contiki/pull/1723#issuecomment-230303157,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.",OK to squash?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1723#issuecomment-230304149,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.","Yes, please do",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/jnohlgard,7,https://github.com/contiki-os/contiki/pull/1723#issuecomment-230322371,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.",squashed,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1723,2016-06-13T13:43:47Z,2016-07-05T16:10:21Z,2016-10-03T06:45:14Z,MERGED,True,6,18,1,https://github.com/jnohlgard,core/net/mac/frame802154: Fix typo in PAN ID compression condition,1,"['bug', 'timed out']",https://github.com/contiki-os/contiki/pull/1723,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1723#issuecomment-230323958,"I stumbled upon this warning when trying out the new GCC 6.1 release:
../../../contiki/core/net/mac/frame802154.c: In function ‚Äòframe802154_has_panid‚Äô:
../../../contiki/core/net/mac/frame802154.c:151:30: warning: self-comparison always evaluates to true [-Wtautological-compare]
       if(fcf->dest_addr_mode == fcf->dest_addr_mode) {
                              ^~

I believe this is a typo and that the correct fix is the supplied PR, but please validate this independently.",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1724,2016-06-13T16:35:11Z,2016-06-15T16:56:10Z,2016-06-15T16:56:10Z,MERGED,True,40,65,4,https://github.com/nvt,Coffee: minor enhancements,2,"['enhancement', 'Core', 'CFS']",https://github.com/contiki-os/contiki/pull/1724,https://github.com/nvt,1,https://github.com/contiki-os/contiki/pull/1724,"Simplify Coffee by changing certain CPP conditionals to C conditionals, which should be possible for the compiler to optimize based on their constant values.
Remove the I/O semantics conditional because it is good to have consistent API across Coffee ports.
Change the struct cfs_dir internal variable name to something more sensible.
Minor clean up of the source code.","Simplify Coffee by changing certain CPP conditionals to C conditionals, which should be possible for the compiler to optimize based on their constant values.
Remove the I/O semantics conditional because it is good to have consistent API across Coffee ports.
Change the struct cfs_dir internal variable name to something more sensible.
Minor clean up of the source code.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1724,2016-06-13T16:35:11Z,2016-06-15T16:56:10Z,2016-06-15T16:56:10Z,MERGED,True,40,65,4,https://github.com/nvt,Coffee: minor enhancements,2,"['enhancement', 'Core', 'CFS']",https://github.com/contiki-os/contiki/pull/1724,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1724#issuecomment-226169915,"Simplify Coffee by changing certain CPP conditionals to C conditionals, which should be possible for the compiler to optimize based on their constant values.
Remove the I/O semantics conditional because it is good to have consistent API across Coffee ports.
Change the struct cfs_dir internal variable name to something more sensible.
Minor clean up of the source code.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/bkozak-scanimetrics,1,https://github.com/contiki-os/contiki/pull/1725,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1725#issuecomment-225671511,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",Looks great! This will need thorough review and testing but I believe this is well worth it. Feels good to see such a streamlined tcpip_ipv6_output()!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/bkozak-scanimetrics,3,https://github.com/contiki-os/contiki/pull/1725#issuecomment-225900060,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",Fixed some typos and removed some unnecessary temporary vars thanks to @greg-king5,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/bkozak-scanimetrics,4,https://github.com/contiki-os/contiki/pull/1725#issuecomment-226286610,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","Made change suggested by @greg-king5 in udp_new()

You can change that expression into an initializer of the variable's definition",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1725#issuecomment-229788398,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","I like it as well, I haven't tested but the code looks OK and Travis is happy üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1725#issuecomment-229882884,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",Very very nice. I reviewed this and left a few comments. Happy to üëç after they are answered/addressed,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/bkozak-scanimetrics,7,https://github.com/contiki-os/contiki/pull/1725#issuecomment-230356403,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","Hello @simonduq,
Regarding your comments of the form:

I would prefer having this block conditioned by [SOME MACRO] rather than the entire the body of [SOME STATIC FUNCTION]

For the most part it isn't possible to have the condition in [SOME MACRO] instead of [SOME STATIC FUNCTION], you would actually need to have the conditional both at the function call site and around the entire function (i.e. not just the body but also the signature and enclosing block) .
This is because:

The compiler will (probably) emit unused static function warnings when the preprocessor makes the function call(s) disappear.
Some of the functions, variables and/or struct members used in [SOME STATIC FUNCTION] may not be available when [SOME MACRO] is false (or undefined).

There are several other ways to work around number one (like adding compiler specific pragmas for instance), but with number two we still need some preprocessor conditionals inside of [SOME STATIC FUNCTION].
Personally I think it is kind of ugly to add redundant preprocessor conditionals (and also to wrap entire functions in preprocessor conditionals), but if you are ok with this approach then I'll go ahead and do it.
Regarding the rest of your comments, I think that they make good sense and I'll implement your suggestions.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1725#issuecomment-230413312,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","Great case for your current approach, I agree. True that what I was suggesting isn't ideal for static functions.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/bkozak-scanimetrics,9,https://github.com/contiki-os/contiki/pull/1725#issuecomment-230793048,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",I've now added in the remainder of @simonduq's suggestions.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1725#issuecomment-230868177,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",Sorry for the unclarify of my comment on init_appstate. Can you please take a look at my latest comment?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/bkozak-scanimetrics,11,https://github.com/contiki-os/contiki/pull/1725#issuecomment-231098333,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","oops sorry for being unclear, the naming suggestion init_appstate was for the function name (replaces setup_appstate), not for the parameter.

That does make more sense than what I did.
The function name is now changed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1725#issuecomment-231107696,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1725,2016-06-13T18:20:59Z,,2016-11-27T21:26:26Z,OPEN,False,253,216,1,https://github.com/bkozak-scanimetrics,Refactor tcpip,2,"['enhancement', 'Core', 'Network']",https://github.com/contiki-os/contiki/pull/1725,https://github.com/arurke,13,https://github.com/contiki-os/contiki/pull/1725#issuecomment-263148722,"This PR performs some re-factoring of tcpip.c, mainly focused on tcpip_ipv6_output().
The main purpose of this PR is to prepare for the changes proposed in #1186. As per the discussion on #1186, these commits were originally part of #1186 but were split apart.
These commits accomplish the following:

Improve the readability of tcpip_ipv6_output() so as to make future modifications to this function easier.
Reduce the size of generated code, esp. on the 6502 platforms where it is easy to run out of memory.","@bkozak-scanimetrics If you want to resolve the conflicts I can test this on my nodes. Kind of interested in the functionality of #1186, which depends on this one - so will contribute what I can to get this merged",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/arthurfabre,1,https://github.com/contiki-os/contiki/pull/1726,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.","This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/arthurfabre,2,https://github.com/contiki-os/contiki/pull/1726#issuecomment-225882917,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.","Just found a bug with the BSL_ADDRESS generation, I'll push a fix when I've got it sorted.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/arthurfabre,3,https://github.com/contiki-os/contiki/pull/1726#issuecomment-225893555,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.","Should be fixed now - there was some weird behavior with the eval used to create the BSL_ADDRESS_ARG, I've turned it into a shell variable now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1726#issuecomment-228442530,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.","I've tested and works great! üòÑ
Works better if updating the cc2538-bsl, as the extra sorting operations adds a small delay and sometimes it overran the on-board PIC timing to put the CC2538 ready to be flashed.
I have mixed feelings as I prefer to keep the PORT argument, so when specified it just flashes one mote, and when PORT is not defined then use MOTES.  I know defining MOTES=/dev/ttyUSBx when compiling does the same effect, but this is a concern mostly based on not breaking the existing documentation and scripts relying on PORT, also commonly used for the cc13xx/cc26xx platforms.
Please add:
### If PORT is defined, override to keep backward compatibility
ifdef PORT      
  MOTES = $(PORT)
endif

Before this line:
### Check the BSL script exists

Thanks,, great job!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/arthurfabre,5,https://github.com/contiki-os/contiki/pull/1726#issuecomment-228708969,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.","Updated with all the changes you mentioned :)
Also changed the MOTES, MOTELIST, and SERIALDUMP variables to not be recursively expanded (so make only runs the $(shell) command once).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1726#issuecomment-228709382,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.","Sweet, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1726,2016-06-14T11:02:35Z,2016-06-30T10:13:42Z,2016-06-30T10:13:42Z,MERGED,True,31,23,1,https://github.com/arthurfabre,zoul: Add support for flashing to multiple devices,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1726,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1726#issuecomment-228709420,"This adds support for flashing to multiple devices, by implementing the
$MOTES option used by the Z1.
This replaces the $PORT interface, as it only allowed flashing to one
device at a time, and the $MOTES interface was still used for other
tasks (such as getting a list of connected devices).
A foreach loop is used to dynamically create an upload rule per device
that needs to be flashed.
The ""main"" upload rule depends on the device specific ones.
This allows for parallel flashing.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1727,2016-06-14T22:04:26Z,2016-07-16T22:34:53Z,2016-07-16T22:34:58Z,MERGED,True,533,0,6,https://github.com/g-oikonomou,Add CC13xx/CC26xx TRNG Support,5,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1727,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1727,"This pull request adds support for the CC13xx/CC26xx hardware RNG.
The hardware has 24 free-running oscillators (FROs) and generates random numbers by sampling them. The longer we let the hardware sample the FROs, the more entropy we will get in our random number. Thus, the hardware can generate low-entropy random numbers super quickly, or it can generate high-entropy random numbers, but this takes longer.
In this context, the driver can work in two modes:

Synchronous mode: We issue a request to the hardware to generate a new, minimum-entropy random number and we block till it's ready. This function is thread-safe and can be called from inside an interrupt context. It is recommended to use this mode when a low-entropy number is required and therefore generation can be performed quickly.
Asynchronous: We issue a request to the RNG to generate a number with configurable degree of entropy and we return immediately. Once the number is ready, the caller will be notified through a callback. This mode is recommended for random numbers of higher entropy. This call should not be made from within an interrupt context. While generation is in progress, the driver will allow CM3 to sleep, but it will prohibit Deep Sleep.

Only one asynchronous generation can be in progress at any given point in time. If a request is made while a previous one is still in progress, the new request will be rejected.
Before an asynchronous generation starts, the driver will cache a small number of randoms. If a synchronous request is made while an asynchronous generation is in progress, the synchronous call will return one of those cached numbers. The number of randoms to be cached is configurable through SOC_TRNG_CONF_CACHE_LEN.
Asynchronous mode accepts the samples argument, which basically controls the amount of time the RNG will spend sampling the FROs. Minimum entropy can be achieved when samples is SOC_TRNG_REFILL_CYCLES_MIN and this will take about 1.5usecs to generate a number. Increasing the value of samples will increase entropy, but it will also increase latency. Maximum entropy is achieved when the value of samples is 0 (SOC_TRNG_REFILL_CYCLES_MAX), in which case generation takes approximately 350msec.
The intended usage is for synchronous mode to be used when we need a low-entropy number very quickly. These numbers are suitable for retransmission back-offs etc, but not suitable for crypto operations. When a high-entropy number is required, it is recommended to use asynchronous mode.
With all of this in place, this pull also implements the random API. random_rand() will use synchronous mode and will return the 2 LS bytes of the generated number.
Closes #1238","This pull request adds support for the CC13xx/CC26xx hardware RNG.
The hardware has 24 free-running oscillators (FROs) and generates random numbers by sampling them. The longer we let the hardware sample the FROs, the more entropy we will get in our random number. Thus, the hardware can generate low-entropy random numbers super quickly, or it can generate high-entropy random numbers, but this takes longer.
In this context, the driver can work in two modes:

Synchronous mode: We issue a request to the hardware to generate a new, minimum-entropy random number and we block till it's ready. This function is thread-safe and can be called from inside an interrupt context. It is recommended to use this mode when a low-entropy number is required and therefore generation can be performed quickly.
Asynchronous: We issue a request to the RNG to generate a number with configurable degree of entropy and we return immediately. Once the number is ready, the caller will be notified through a callback. This mode is recommended for random numbers of higher entropy. This call should not be made from within an interrupt context. While generation is in progress, the driver will allow CM3 to sleep, but it will prohibit Deep Sleep.

Only one asynchronous generation can be in progress at any given point in time. If a request is made while a previous one is still in progress, the new request will be rejected.
Before an asynchronous generation starts, the driver will cache a small number of randoms. If a synchronous request is made while an asynchronous generation is in progress, the synchronous call will return one of those cached numbers. The number of randoms to be cached is configurable through SOC_TRNG_CONF_CACHE_LEN.
Asynchronous mode accepts the samples argument, which basically controls the amount of time the RNG will spend sampling the FROs. Minimum entropy can be achieved when samples is SOC_TRNG_REFILL_CYCLES_MIN and this will take about 1.5usecs to generate a number. Increasing the value of samples will increase entropy, but it will also increase latency. Maximum entropy is achieved when the value of samples is 0 (SOC_TRNG_REFILL_CYCLES_MAX), in which case generation takes approximately 350msec.
The intended usage is for synchronous mode to be used when we need a low-entropy number very quickly. These numbers are suitable for retransmission back-offs etc, but not suitable for crypto operations. When a high-entropy number is required, it is recommended to use asynchronous mode.
With all of this in place, this pull also implements the random API. random_rand() will use synchronous mode and will return the 2 LS bytes of the generated number.
Closes #1238",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1727,2016-06-14T22:04:26Z,2016-07-16T22:34:53Z,2016-07-16T22:34:58Z,MERGED,True,533,0,6,https://github.com/g-oikonomou,Add CC13xx/CC26xx TRNG Support,5,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1727,https://github.com/atiselsts,2,https://github.com/contiki-os/contiki/pull/1727#issuecomment-230271292,"This pull request adds support for the CC13xx/CC26xx hardware RNG.
The hardware has 24 free-running oscillators (FROs) and generates random numbers by sampling them. The longer we let the hardware sample the FROs, the more entropy we will get in our random number. Thus, the hardware can generate low-entropy random numbers super quickly, or it can generate high-entropy random numbers, but this takes longer.
In this context, the driver can work in two modes:

Synchronous mode: We issue a request to the hardware to generate a new, minimum-entropy random number and we block till it's ready. This function is thread-safe and can be called from inside an interrupt context. It is recommended to use this mode when a low-entropy number is required and therefore generation can be performed quickly.
Asynchronous: We issue a request to the RNG to generate a number with configurable degree of entropy and we return immediately. Once the number is ready, the caller will be notified through a callback. This mode is recommended for random numbers of higher entropy. This call should not be made from within an interrupt context. While generation is in progress, the driver will allow CM3 to sleep, but it will prohibit Deep Sleep.

Only one asynchronous generation can be in progress at any given point in time. If a request is made while a previous one is still in progress, the new request will be rejected.
Before an asynchronous generation starts, the driver will cache a small number of randoms. If a synchronous request is made while an asynchronous generation is in progress, the synchronous call will return one of those cached numbers. The number of randoms to be cached is configurable through SOC_TRNG_CONF_CACHE_LEN.
Asynchronous mode accepts the samples argument, which basically controls the amount of time the RNG will spend sampling the FROs. Minimum entropy can be achieved when samples is SOC_TRNG_REFILL_CYCLES_MIN and this will take about 1.5usecs to generate a number. Increasing the value of samples will increase entropy, but it will also increase latency. Maximum entropy is achieved when the value of samples is 0 (SOC_TRNG_REFILL_CYCLES_MAX), in which case generation takes approximately 350msec.
The intended usage is for synchronous mode to be used when we need a low-entropy number very quickly. These numbers are suitable for retransmission back-offs etc, but not suitable for crypto operations. When a high-entropy number is required, it is recommended to use asynchronous mode.
With all of this in place, this pull also implements the random API. random_rand() will use synchronous mode and will return the 2 LS bytes of the generated number.
Closes #1238","üëç
I like that after reboot random_rand() does not return the same sequence of numbers anymore.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1728,2016-06-16T05:23:47Z,2016-06-16T05:24:00Z,2016-06-16T05:24:40Z,CLOSED,False,3467,194,45,https://github.com/msolters,CoAP OTA,276,[],https://github.com/contiki-os/contiki/pull/1728,https://github.com/msolters,1,https://github.com/contiki-os/contiki/pull/1728,"Rewrote the OTA mechanism with a few major changes:

OTA uses CoAP instead of HTTP
OTA download buffer only has a 1Kb SRAM footprint (instead of 4Kb)
OTA feature is repackaged as a Contiki app
Can now write firmware to external flash in units smaller than a full flash page","Rewrote the OTA mechanism with a few major changes:

OTA uses CoAP instead of HTTP
OTA download buffer only has a 1Kb SRAM footprint (instead of 4Kb)
OTA feature is repackaged as a Contiki app
Can now write firmware to external flash in units smaller than a full flash page",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1728,2016-06-16T05:23:47Z,2016-06-16T05:24:00Z,2016-06-16T05:24:40Z,CLOSED,False,3467,194,45,https://github.com/msolters,CoAP OTA,276,[],https://github.com/contiki-os/contiki/pull/1728,https://github.com/msolters,2,https://github.com/contiki-os/contiki/pull/1728#issuecomment-226391172,"Rewrote the OTA mechanism with a few major changes:

OTA uses CoAP instead of HTTP
OTA download buffer only has a 1Kb SRAM footprint (instead of 4Kb)
OTA feature is repackaged as a Contiki app
Can now write firmware to external flash in units smaller than a full flash page",Sorry meant to merge to my fork.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1729,2016-06-17T09:29:51Z,2016-06-20T08:38:29Z,2016-06-20T08:45:13Z,CLOSED,False,7,2,2,https://github.com/arthurfabre,CC2538: Fix external flash support,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1729,https://github.com/arthurfabre,1,https://github.com/contiki-os/contiki/pull/1729,"External flash is supported through the COFFEE_CONF_CUSTOM_PORT macro,
which when used disables the program flash based Coffee.
The linker script directly uses COFFEE_START and COFFEE_SIZE to reserve
space for the program flash based Coffee.
Consequently, space is reserved in program flash even for external flash
chips, and things break when the linker script attempts to reserve
several MB of space.
This change adds a new macro, CC2538_FLASH_OFFSET, that is used by the
linker script.
If the program flash based Coffee is used, it is set to COFFEE_SIZE,
else set to 0.","External flash is supported through the COFFEE_CONF_CUSTOM_PORT macro,
which when used disables the program flash based Coffee.
The linker script directly uses COFFEE_START and COFFEE_SIZE to reserve
space for the program flash based Coffee.
Consequently, space is reserved in program flash even for external flash
chips, and things break when the linker script attempts to reserve
several MB of space.
This change adds a new macro, CC2538_FLASH_OFFSET, that is used by the
linker script.
If the program flash based Coffee is used, it is set to COFFEE_SIZE,
else set to 0.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1729,2016-06-17T09:29:51Z,2016-06-20T08:38:29Z,2016-06-20T08:45:13Z,CLOSED,False,7,2,2,https://github.com/arthurfabre,CC2538: Fix external flash support,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1729,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1729#issuecomment-226838158,"External flash is supported through the COFFEE_CONF_CUSTOM_PORT macro,
which when used disables the program flash based Coffee.
The linker script directly uses COFFEE_START and COFFEE_SIZE to reserve
space for the program flash based Coffee.
Consequently, space is reserved in program flash even for external flash
chips, and things break when the linker script attempts to reserve
several MB of space.
This change adds a new macro, CC2538_FLASH_OFFSET, that is used by the
linker script.
If the program flash based Coffee is used, it is set to COFFEE_SIZE,
else set to 0.","Thanks. That was on my TODO list, but for different reasons (OTA FW upgrade). There may be other things to take into consideration. I'll think about that and I'll come back to you, probably this weekend.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1729,2016-06-17T09:29:51Z,2016-06-20T08:38:29Z,2016-06-20T08:45:13Z,CLOSED,False,7,2,2,https://github.com/arthurfabre,CC2538: Fix external flash support,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1729,https://github.com/bthebaudeau,3,https://github.com/contiki-os/contiki/pull/1729#issuecomment-227024948,"External flash is supported through the COFFEE_CONF_CUSTOM_PORT macro,
which when used disables the program flash based Coffee.
The linker script directly uses COFFEE_START and COFFEE_SIZE to reserve
space for the program flash based Coffee.
Consequently, space is reserved in program flash even for external flash
chips, and things break when the linker script attempts to reserve
several MB of space.
This change adds a new macro, CC2538_FLASH_OFFSET, that is used by the
linker script.
If the program flash based Coffee is used, it is set to COFFEE_SIZE,
else set to 0.","I see the following issues with these changes:

They break the current behavior if COFFEE_CONF_START is used to place Coffee after the beginning of the flash memory.
The introduced definitions should not be in cfs-coffee-arch.h, because they are unrelated, but rather in flash.h.
The naming must reflect the fact that it's not a general flash definition, but one related to firmware placement.
We need to be able to easily choose alternative firmware locations in flash memory, for OTA or whatever.

So how about the following commit?
bthebaudeau@8a273a2",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1729,2016-06-17T09:29:51Z,2016-06-20T08:38:29Z,2016-06-20T08:45:13Z,CLOSED,False,7,2,2,https://github.com/arthurfabre,CC2538: Fix external flash support,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1729,https://github.com/arthurfabre,4,https://github.com/contiki-os/contiki/pull/1729#issuecomment-227082111,"External flash is supported through the COFFEE_CONF_CUSTOM_PORT macro,
which when used disables the program flash based Coffee.
The linker script directly uses COFFEE_START and COFFEE_SIZE to reserve
space for the program flash based Coffee.
Consequently, space is reserved in program flash even for external flash
chips, and things break when the linker script attempts to reserve
several MB of space.
This change adds a new macro, CC2538_FLASH_OFFSET, that is used by the
linker script.
If the program flash based Coffee is used, it is set to COFFEE_SIZE,
else set to 0.",That works for our use-case and seems a bit neater :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1729,2016-06-17T09:29:51Z,2016-06-20T08:38:29Z,2016-06-20T08:45:13Z,CLOSED,False,7,2,2,https://github.com/arthurfabre,CC2538: Fix external flash support,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1729,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1729#issuecomment-227083560,"External flash is supported through the COFFEE_CONF_CUSTOM_PORT macro,
which when used disables the program flash based Coffee.
The linker script directly uses COFFEE_START and COFFEE_SIZE to reserve
space for the program flash based Coffee.
Consequently, space is reserved in program flash even for external flash
chips, and things break when the linker script attempts to reserve
several MB of space.
This change adds a new macro, CC2538_FLASH_OFFSET, that is used by the
linker script.
If the program flash based Coffee is used, it is set to COFFEE_SIZE,
else set to 0.",Just to keep this on the list üò∏,True,{'THUMBS_UP': ['https://github.com/arthurfabre']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1730,2016-06-17T14:45:11Z,2016-07-06T07:17:39Z,2016-07-06T07:17:39Z,MERGED,True,32,15,3,https://github.com/groessler,Some 6502 target changes,2,[],https://github.com/contiki-os/contiki/pull/1730,https://github.com/groessler,1,https://github.com/contiki-os/contiki/pull/1730,"platform/atarixl/Makefile.atarixl: put two more objects into high memory
platform/atarixl/contiki-conf.h: define WWW_CONF_WGET_EXEC
tools/6502/Makefile: add 'clean' target; remove unused CONTIKI define","platform/atarixl/Makefile.atarixl: put two more objects into high memory
platform/atarixl/contiki-conf.h: define WWW_CONF_WGET_EXEC
tools/6502/Makefile: add 'clean' target; remove unused CONTIKI define",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1730,2016-06-17T14:45:11Z,2016-07-06T07:17:39Z,2016-07-06T07:17:39Z,MERGED,True,32,15,3,https://github.com/groessler,Some 6502 target changes,2,[],https://github.com/contiki-os/contiki/pull/1730,https://github.com/oliverschmidt,2,https://github.com/contiki-os/contiki/pull/1730#issuecomment-230696710,"platform/atarixl/Makefile.atarixl: put two more objects into high memory
platform/atarixl/contiki-conf.h: define WWW_CONF_WGET_EXEC
tools/6502/Makefile: add 'clean' target; remove unused CONTIKI define",The failing Travis CI jobs are not related to the changes in this pull request.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1732,2016-06-20T11:06:36Z,2016-06-24T16:44:16Z,2016-06-24T23:36:44Z,MERGED,True,19,2,2,https://github.com/bthebaudeau,cc2538: Add configuration for firmware location,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1732,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1732,"Introduce FLASH_CONF_FW_ADDR and FLASH_CONF_FW_SIZE in order to make it possible to place the firmware anywhere, regardless of Coffee, and without having to write a custom linker script. Also, handle the default values properly in order to fix the link breakage reported by @arthurfabre with COFFEE_CONF_CUSTOM_PORT.
Closes #1731.","Introduce FLASH_CONF_FW_ADDR and FLASH_CONF_FW_SIZE in order to make it possible to place the firmware anywhere, regardless of Coffee, and without having to write a custom linker script. Also, handle the default values properly in order to fix the link breakage reported by @arthurfabre with COFFEE_CONF_CUSTOM_PORT.
Closes #1731.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1732,2016-06-20T11:06:36Z,2016-06-24T16:44:16Z,2016-06-24T23:36:44Z,MERGED,True,19,2,2,https://github.com/bthebaudeau,cc2538: Add configuration for firmware location,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1732,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1732#issuecomment-227113947,"Introduce FLASH_CONF_FW_ADDR and FLASH_CONF_FW_SIZE in order to make it possible to place the firmware anywhere, regardless of Coffee, and without having to write a custom linker script. Also, handle the default values properly in order to fix the link breakage reported by @arthurfabre with COFFEE_CONF_CUSTOM_PORT.
Closes #1731.","Looks sweet, I will test locally and update.  Please @arthurfabre could you test as well?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1732,2016-06-20T11:06:36Z,2016-06-24T16:44:16Z,2016-06-24T23:36:44Z,MERGED,True,19,2,2,https://github.com/bthebaudeau,cc2538: Add configuration for firmware location,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1732,https://github.com/arthurfabre,3,https://github.com/contiki-os/contiki/pull/1732#issuecomment-227115481,"Introduce FLASH_CONF_FW_ADDR and FLASH_CONF_FW_SIZE in order to make it possible to place the firmware anywhere, regardless of Coffee, and without having to write a custom linker script. Also, handle the default values properly in order to fix the link breakage reported by @arthurfabre with COFFEE_CONF_CUSTOM_PORT.
Closes #1731.","I merged this in to our branch this morning, and the generated linker script / binaries are as expected.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1732,2016-06-20T11:06:36Z,2016-06-24T16:44:16Z,2016-06-24T23:36:44Z,MERGED,True,19,2,2,https://github.com/bthebaudeau,cc2538: Add configuration for firmware location,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1732,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1732#issuecomment-228397268,"Introduce FLASH_CONF_FW_ADDR and FLASH_CONF_FW_SIZE in order to make it possible to place the firmware anywhere, regardless of Coffee, and without having to write a custom linker script. Also, handle the default values properly in order to fix the link breakage reported by @arthurfabre with COFFEE_CONF_CUSTOM_PORT.
Closes #1731.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1734,2016-06-21T13:21:58Z,2016-06-28T22:22:08Z,2016-06-29T09:50:09Z,MERGED,True,27,26,13,https://github.com/yatch,Fix the source address selection for multicast packets,4,[],https://github.com/contiki-os/contiki/pull/1734,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1734,"This PR fixes an issue that a link-local address is used as the source address of a packet destined to a routable multicast address. You can see this issue with examples/ipv6/multicast/multicast.csc. Multicast packets to ff1e::89:abcd have a link-local address, fe80::212:7401:1:101, as their source address. After applying the change, their source address become fd00::212:7401:1:101.
I found this issue has been reported with Issue #1292. As per @g-oikonomou comment on #1292, I replaced UIP_CONF_IPV6_MULTICAST with UIP_IPV6_MULTICAST. In addition, I renamed RPL_CONF_MULTICAST to RPL_WITH_MULTICAST because it doesn't seem to be a user configuration, either.","This PR fixes an issue that a link-local address is used as the source address of a packet destined to a routable multicast address. You can see this issue with examples/ipv6/multicast/multicast.csc. Multicast packets to ff1e::89:abcd have a link-local address, fe80::212:7401:1:101, as their source address. After applying the change, their source address become fd00::212:7401:1:101.
I found this issue has been reported with Issue #1292. As per @g-oikonomou comment on #1292, I replaced UIP_CONF_IPV6_MULTICAST with UIP_IPV6_MULTICAST. In addition, I renamed RPL_CONF_MULTICAST to RPL_WITH_MULTICAST because it doesn't seem to be a user configuration, either.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1737,2016-06-23T20:59:56Z,2016-06-24T22:14:29Z,2016-06-24T23:22:53Z,MERGED,True,7,8,2,https://github.com/bthebaudeau,cc2538: aes: Fix possibly missing result available status,2,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1737,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1737,"Depending on the use case and on the timings, auth_crypt_check_status() sometimes never reported an available result, leading to a deadlock of any protothread waiting for this event, and to a WDT reset if a protothread was polling it.
This was caused by aes_auth_crypt_start() clearing the result available interrupt after operations that may rightfully trigger it, leading to a missed interrupt.
This PR also fixes build errors discovered in noncoresec with DEBUG set to 1 while investigating this issue. Even if noncoresec is removed soon, it's better to fix this in the meantime.","Depending on the use case and on the timings, auth_crypt_check_status() sometimes never reported an available result, leading to a deadlock of any protothread waiting for this event, and to a WDT reset if a protothread was polling it.
This was caused by aes_auth_crypt_start() clearing the result available interrupt after operations that may rightfully trigger it, leading to a missed interrupt.
This PR also fixes build errors discovered in noncoresec with DEBUG set to 1 while investigating this issue. Even if noncoresec is removed soon, it's better to fix this in the meantime.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1737,2016-06-23T20:59:56Z,2016-06-24T22:14:29Z,2016-06-24T23:22:53Z,MERGED,True,7,8,2,https://github.com/bthebaudeau,cc2538: aes: Fix possibly missing result available status,2,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1737,https://github.com/kkrentz,2,https://github.com/contiki-os/contiki/pull/1737#issuecomment-228293227,"Depending on the use case and on the timings, auth_crypt_check_status() sometimes never reported an available result, leading to a deadlock of any protothread waiting for this event, and to a WDT reset if a protothread was polling it.
This was caused by aes_auth_crypt_start() clearing the result available interrupt after operations that may rightfully trigger it, leading to a missed interrupt.
This PR also fixes build errors discovered in noncoresec with DEBUG set to 1 while investigating this issue. Even if noncoresec is removed soon, it's better to fix this in the meantime.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1737,2016-06-23T20:59:56Z,2016-06-24T22:14:29Z,2016-06-24T23:22:53Z,MERGED,True,7,8,2,https://github.com/bthebaudeau,cc2538: aes: Fix possibly missing result available status,2,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1737,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1737#issuecomment-228475456,"Depending on the use case and on the timings, auth_crypt_check_status() sometimes never reported an available result, leading to a deadlock of any protothread waiting for this event, and to a WDT reset if a protothread was polling it.
This was caused by aes_auth_crypt_start() clearing the result available interrupt after operations that may rightfully trigger it, leading to a missed interrupt.
This PR also fixes build errors discovered in noncoresec with DEBUG set to 1 while investigating this issue. Even if noncoresec is removed soon, it's better to fix this in the meantime.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1738,2016-06-24T09:25:35Z,2016-08-16T12:48:21Z,2017-10-27T20:03:30Z,MERGED,True,16,1,1,https://github.com/simonduq,mac-seqno: add a lifetime to sequence numbers in history,1,[],https://github.com/contiki-os/contiki/pull/1738,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1738,"Without a lifetime, there are cases where node B receives from A with seqno N, then does not hear anything for an arbitrary period of time, and then hears a new, different packet with seqno N again (seqnos wrap quick given they are a single byte).
This PR adds a configurable lifetime for received seqnos in history.","Without a lifetime, there are cases where node B receives from A with seqno N, then does not hear anything for an arbitrary period of time, and then hears a new, different packet with seqno N again (seqnos wrap quick given they are a single byte).
This PR adds a configurable lifetime for received seqnos in history.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1738,2016-06-24T09:25:35Z,2016-08-16T12:48:21Z,2017-10-27T20:03:30Z,MERGED,True,16,1,1,https://github.com/simonduq,mac-seqno: add a lifetime to sequence numbers in history,1,[],https://github.com/contiki-os/contiki/pull/1738,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1738#issuecomment-240091258,"Without a lifetime, there are cases where node B receives from A with seqno N, then does not hear anything for an arbitrary period of time, and then hears a new, different packet with seqno N again (seqnos wrap quick given they are a single byte).
This PR adds a configurable lifetime for received seqnos in history.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1739,2016-06-24T09:28:38Z,2016-08-16T12:49:21Z,2017-10-27T20:03:26Z,MERGED,True,26,57,4,https://github.com/simonduq,Improved TSCH sequence number handling,2,[],https://github.com/contiki-os/contiki/pull/1739,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1739,"This PR does two things, in TSCH:

move from ad-hoc seqno handling to the generic and standard-compliant mac-sequence module
use sequence numbers only for unicast packets. We suppress it in broadcast. This has two benefits, (1) slows down the pace at which seqnos wrap and (2) save one byte in broadcast frames.

Together with #1738 this avoids spurious duplicate drops.","This PR does two things, in TSCH:

move from ad-hoc seqno handling to the generic and standard-compliant mac-sequence module
use sequence numbers only for unicast packets. We suppress it in broadcast. This has two benefits, (1) slows down the pace at which seqnos wrap and (2) save one byte in broadcast frames.

Together with #1738 this avoids spurious duplicate drops.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1739,2016-06-24T09:28:38Z,2016-08-16T12:49:21Z,2017-10-27T20:03:26Z,MERGED,True,26,57,4,https://github.com/simonduq,Improved TSCH sequence number handling,2,[],https://github.com/contiki-os/contiki/pull/1739,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1739#issuecomment-240091475,"This PR does two things, in TSCH:

move from ad-hoc seqno handling to the generic and standard-compliant mac-sequence module
use sequence numbers only for unicast packets. We suppress it in broadcast. This has two benefits, (1) slows down the pace at which seqnos wrap and (2) save one byte in broadcast frames.

Together with #1738 this avoids spurious duplicate drops.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1740,2016-06-24T09:29:34Z,2016-09-05T14:33:48Z,2017-10-27T20:03:23Z,MERGED,True,21,8,3,https://github.com/simonduq,TSCH minor enhancements,4,[],https://github.com/contiki-os/contiki/pull/1740,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1740,A series of minor fixes / new features as described in the commit logs,A series of minor fixes / new features as described in the commit logs,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1740,2016-06-24T09:29:34Z,2016-09-05T14:33:48Z,2017-10-27T20:03:23Z,MERGED,True,21,8,3,https://github.com/simonduq,TSCH minor enhancements,4,[],https://github.com/contiki-os/contiki/pull/1740,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1740#issuecomment-244760639,A series of minor fixes / new features as described in the commit logs,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1741,2016-06-24T09:33:02Z,2016-11-25T15:53:33Z,2017-10-27T20:03:27Z,MERGED,True,43,12,5,https://github.com/simonduq,TSCH adaptive control traffic,3,['timed out'],https://github.com/contiki-os/contiki/pull/1741,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1741,"This PR brings adaptive control and synchronization traffic for TSCH:

Enables adaptive time-sync by default (now thoroughly tested)
Maps the EB period from the RPL DIO period => reduces beaconing as the topology converges
Increases the keep-alive timeout as soon as we have gathered enough info for precise drift compensation","This PR brings adaptive control and synchronization traffic for TSCH:

Enables adaptive time-sync by default (now thoroughly tested)
Maps the EB period from the RPL DIO period => reduces beaconing as the topology converges
Increases the keep-alive timeout as soon as we have gathered enough info for precise drift compensation",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1741,2016-06-24T09:33:02Z,2016-11-25T15:53:33Z,2017-10-27T20:03:27Z,MERGED,True,43,12,5,https://github.com/simonduq,TSCH adaptive control traffic,3,['timed out'],https://github.com/contiki-os/contiki/pull/1741,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1741#issuecomment-262968474,"This PR brings adaptive control and synchronization traffic for TSCH:

Enables adaptive time-sync by default (now thoroughly tested)
Maps the EB period from the RPL DIO period => reduces beaconing as the topology converges
Increases the keep-alive timeout as soon as we have gathered enough info for precise drift compensation","@g-oikonomou @atiselsts any thoghts?
setting a timeout for merging in case you have no concern",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1741,2016-06-24T09:33:02Z,2016-11-25T15:53:33Z,2017-10-27T20:03:27Z,MERGED,True,43,12,5,https://github.com/simonduq,TSCH adaptive control traffic,3,['timed out'],https://github.com/contiki-os/contiki/pull/1741,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1741#issuecomment-262982256,"This PR brings adaptive control and synchronization traffic for TSCH:

Enables adaptive time-sync by default (now thoroughly tested)
Maps the EB period from the RPL DIO period => reduces beaconing as the topology converges
Increases the keep-alive timeout as soon as we have gathered enough info for precise drift compensation",No concerns here!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1741,2016-06-24T09:33:02Z,2016-11-25T15:53:33Z,2017-10-27T20:03:27Z,MERGED,True,43,12,5,https://github.com/simonduq,TSCH adaptive control traffic,3,['timed out'],https://github.com/contiki-os/contiki/pull/1741,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1741#issuecomment-262982730,"This PR brings adaptive control and synchronization traffic for TSCH:

Enables adaptive time-sync by default (now thoroughly tested)
Maps the EB period from the RPL DIO period => reduces beaconing as the topology converges
Increases the keep-alive timeout as soon as we have gathered enough info for precise drift compensation",Shall we just merge then? I give it üëç 	:):),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1743,2016-06-24T20:12:11Z,2016-06-24T22:12:18Z,2016-06-24T22:12:25Z,MERGED,True,1,1,1,https://github.com/alignan,Updated cc2538-bsl to version 2.1 (c6100a7),1,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1743,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1743,Bring in the latest changes in v2.1,Bring in the latest changes in v2.1,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1743,2016-06-24T20:12:11Z,2016-06-24T22:12:18Z,2016-06-24T22:12:25Z,MERGED,True,1,1,1,https://github.com/alignan,Updated cc2538-bsl to version 2.1 (c6100a7),1,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1743,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1743#issuecomment-228450553,Bring in the latest changes in v2.1,@JelmerT @g-oikonomou are you OK with updating?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1743,2016-06-24T20:12:11Z,2016-06-24T22:12:18Z,2016-06-24T22:12:25Z,MERGED,True,1,1,1,https://github.com/alignan,Updated cc2538-bsl to version 2.1 (c6100a7),1,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1743,https://github.com/JelmerT,3,https://github.com/contiki-os/contiki/pull/1743#issuecomment-228475051,Bring in the latest changes in v2.1,üëç  good for me,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1745,2016-06-24T22:05:53Z,2016-06-30T07:47:16Z,2016-06-30T08:33:49Z,MERGED,True,123,76,1,https://github.com/alignan,Minor changes to z1/contiki-conf.h,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1745,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1745,"Minor changes:

Moved project-conf.h inclusion to the top of contiki-conf.h, as configurable parameters are defined beforehand, thus requiring to #undef first.
Made common parameters overridable
Added BOARD_STRING platform definition","Minor changes:

Moved project-conf.h inclusion to the top of contiki-conf.h, as configurable parameters are defined beforehand, thus requiring to #undef first.
Made common parameters overridable
Added BOARD_STRING platform definition",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1745,2016-06-24T22:05:53Z,2016-06-30T07:47:16Z,2016-06-30T08:33:49Z,MERGED,True,123,76,1,https://github.com/alignan,Minor changes to z1/contiki-conf.h,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1745,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1745#issuecomment-229585678,"Minor changes:

Moved project-conf.h inclusion to the top of contiki-conf.h, as configurable parameters are defined beforehand, thus requiring to #undef first.
Made common parameters overridable
Added BOARD_STRING platform definition",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1745,2016-06-24T22:05:53Z,2016-06-30T07:47:16Z,2016-06-30T08:33:49Z,MERGED,True,123,76,1,https://github.com/alignan,Minor changes to z1/contiki-conf.h,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1745,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1745#issuecomment-229592164,"Minor changes:

Moved project-conf.h inclusion to the top of contiki-conf.h, as configurable parameters are defined beforehand, thus requiring to #undef first.
Made common parameters overridable
Added BOARD_STRING platform definition","I think this might cause problems with all project-conf.h files that assume they are included after this contiki-conf.h, as the latter sometimes sets some flags without ifndef. I feel we need to agree on a config architecture and stick to it in all examples and platforms, else this soon getting messy.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1745,2016-06-24T22:05:53Z,2016-06-30T07:47:16Z,2016-06-30T08:33:49Z,MERGED,True,123,76,1,https://github.com/alignan,Minor changes to z1/contiki-conf.h,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1745,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1745#issuecomment-229595534,"Minor changes:

Moved project-conf.h inclusion to the top of contiki-conf.h, as configurable parameters are defined beforehand, thus requiring to #undef first.
Made common parameters overridable
Added BOARD_STRING platform definition","Agree, I changed this to follow how the RE-Mote and newer platforms like the srf06-cc26xx does it, as I think it is better implemented (it is ugly to #undef a CONF_XXX value from a project-conf.h).
At the moment at least it should be easy to spot as it will yield a lot of warnings üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1745,2016-06-24T22:05:53Z,2016-06-30T07:47:16Z,2016-06-30T08:33:49Z,MERGED,True,123,76,1,https://github.com/alignan,Minor changes to z1/contiki-conf.h,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1745,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1745#issuecomment-229596494,"Minor changes:

Moved project-conf.h inclusion to the top of contiki-conf.h, as configurable parameters are defined beforehand, thus requiring to #undef first.
Made common parameters overridable
Added BOARD_STRING platform definition","Yes true, at least easy to spot :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1746,2016-06-26T12:53:24Z,2016-06-28T15:15:45Z,2016-06-28T15:15:49Z,MERGED,True,8,6,1,https://github.com/g-oikonomou,Disable CC2650_FAST_RADIO_STARTUP by default,1,[],https://github.com/contiki-os/contiki/pull/1746,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1746,"CC2650_FAST_RADIO_STARTUP is required for TSCH, but it currently breaks ContikiMAC. We set the default value to the one that will work with the default choice of RDC.
I'm also moving the define to a place in contiki-conf.h closer to where the user will look in order to configure the RDC driver.
Fixes #1744","CC2650_FAST_RADIO_STARTUP is required for TSCH, but it currently breaks ContikiMAC. We set the default value to the one that will work with the default choice of RDC.
I'm also moving the define to a place in contiki-conf.h closer to where the user will look in order to configure the RDC driver.
Fixes #1744",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1746,2016-06-26T12:53:24Z,2016-06-28T15:15:45Z,2016-06-28T15:15:49Z,MERGED,True,8,6,1,https://github.com/g-oikonomou,Disable CC2650_FAST_RADIO_STARTUP by default,1,[],https://github.com/contiki-os/contiki/pull/1746,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1746#issuecomment-229081321,"CC2650_FAST_RADIO_STARTUP is required for TSCH, but it currently breaks ContikiMAC. We set the default value to the one that will work with the default choice of RDC.
I'm also moving the define to a place in contiki-conf.h closer to where the user will look in order to configure the RDC driver.
Fixes #1744","This fix has been confirmed by the person who reported the bug, so I'm merging this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1748,2016-06-27T16:08:25Z,2016-06-28T22:19:56Z,2016-06-28T22:19:56Z,CLOSED,False,4,0,1,https://github.com/atiselsts,CC26xx: Make sure UART buffers are flushed before sleeping,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1748,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1748,This fixes a problem with corrupted characters occasionally appearing in UART output.,This fixes a problem with corrupted characters occasionally appearing in UART output.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1748,2016-06-27T16:08:25Z,2016-06-28T22:19:56Z,2016-06-28T22:19:56Z,CLOSED,False,4,0,1,https://github.com/atiselsts,CC26xx: Make sure UART buffers are flushed before sleeping,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1748,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1748#issuecomment-229081982,This fixes a problem with corrupted characters occasionally appearing in UART output.,"And now I can see why you were getting garbage chars...
How about clocking the UART during sleep by changing the driver instead of adding peripheral-specific awareness to the LPM module? I'm just thinking this may open a can of worms, now we do this for the UART, next we may do it for SPI or GPTs and the story goes.
What do you think?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1748,2016-06-27T16:08:25Z,2016-06-28T22:19:56Z,2016-06-28T22:19:56Z,CLOSED,False,4,0,1,https://github.com/atiselsts,CC26xx: Make sure UART buffers are flushed before sleeping,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1748,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/1748#issuecomment-229102162,This fixes a problem with corrupted characters occasionally appearing in UART output.,"I see your point. Adding this line in cc26xx_uart_init() does seem to be an alternative way to solve this problem:
ti_lib_prcm_peripheral_deep_sleep_enable(PRCM_PERIPH_UART0);
I measured energy consumption with a multimeter after this change, did not detect any difference in either deep sleep or sleep mode.
There are some more calls to ti_lib_prcm_peripheral_sleep_enable() / ti_lib_prcm_peripheral_sleep_disable() in the driver which now can be removed. But not sure about this line, should keep it or remove it?:
https://github.com/contiki-os/contiki/blob/master/cpu/cc26xx-cc13xx/dev/cc26xx-uart.c#L234",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1748,2016-06-27T16:08:25Z,2016-06-28T22:19:56Z,2016-06-28T22:19:56Z,CLOSED,False,4,0,1,https://github.com/atiselsts,CC26xx: Make sure UART buffers are flushed before sleeping,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1748,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1748#issuecomment-229201801,This fixes a problem with corrupted characters occasionally appearing in UART output.,"After some discussion with Atis, this needs a little more work. Closing for now as this is a ""don't merge"" at the moment.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1749,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.","Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1749#issuecomment-229211427,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.",This sounds like a good idea. üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1749#issuecomment-229784714,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.","I like the idea, but it would be even better if fixing tunslip as well, or providing a new script that makes actual use of the checksum check, else it would be just unused.  Any chance to update this PR?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1749#issuecomment-229787582,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.","Out of curiosity, is there a standard way of doing this? (maybe this is?)
Have you tried H/W flow control or S/W flow control? Very reliable in my experience (and supported by existing tools, even already in tunslip6)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/atiselsts,5,https://github.com/contiki-os/contiki/pull/1749#issuecomment-231809094,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.","Updated the patch after #920 was merged, and added the change for tunslip6 as well.
Not sure if flow control can replace this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/neophob,6,https://github.com/contiki-os/contiki/pull/1749#issuecomment-240018547,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.",any plans to merge this?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1749,2016-06-27T16:38:25Z,,2017-03-14T20:04:30Z,OPEN,False,143,14,3,https://github.com/atiselsts,Add checksum to SLIP packets when SLIP_CRC_ON is defined,2,[],https://github.com/contiki-os/contiki/pull/1749,https://github.com/atiselsts,7,https://github.com/contiki-os/contiki/pull/1749#issuecomment-286542933,"Helps to avoid invalid packets when the underlying serial connection is not reliable. Unlike the IP checksum, this covers not only the header, but also the body of a packet.
This feature is disabled by default and the patch add Contiki side code only. Modifications in Contiki's tunslip code are necessary to enable and use this feature. We have tested it only using a custom Python script instead of tunslip for the host side.","For our project I have updated this to a 16 bit CRC, let me know if you're interested.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1750,2016-06-27T20:29:11Z,2016-06-29T08:38:17Z,2016-06-29T12:09:09Z,MERGED,True,28,32,1,https://github.com/yatch,Improve RPL extension headers handling,4,['bug'],https://github.com/contiki-os/contiki/pull/1750,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1750,"This PR addresses mainly two bugs in rpl-ext-header.c.

The system crashes or falls into an infinite loop when it encounters an unsupported protocol header
(roughly speaking).
A RPL header to be processed is not handled properly unless it comes just after an IPv6 header.

You can confirm the first one with a packet unsupported by Contiki. For example, on sending a simple UDP-Lite packet to a mote running on Cooja, Cooja crashes by SIGSEGV. When the mote runs with Non-Storing mode enabled, Cooja stalls because the mote does not release CPU.
For the second bug, I used a packet which had a Destination Options header followed by a RPL Routing header. The Destination Options header had only one PadN option. Contiki was not able to find the RPL Routing header.","This PR addresses mainly two bugs in rpl-ext-header.c.

The system crashes or falls into an infinite loop when it encounters an unsupported protocol header
(roughly speaking).
A RPL header to be processed is not handled properly unless it comes just after an IPv6 header.

You can confirm the first one with a packet unsupported by Contiki. For example, on sending a simple UDP-Lite packet to a mote running on Cooja, Cooja crashes by SIGSEGV. When the mote runs with Non-Storing mode enabled, Cooja stalls because the mote does not release CPU.
For the second bug, I used a packet which had a Destination Options header followed by a RPL Routing header. The Destination Options header had only one PadN option. Contiki was not able to find the RPL Routing header.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1750,2016-06-27T20:29:11Z,2016-06-29T08:38:17Z,2016-06-29T12:09:09Z,MERGED,True,28,32,1,https://github.com/yatch,Improve RPL extension headers handling,4,['bug'],https://github.com/contiki-os/contiki/pull/1750,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1750#issuecomment-229020252,"This PR addresses mainly two bugs in rpl-ext-header.c.

The system crashes or falls into an infinite loop when it encounters an unsupported protocol header
(roughly speaking).
A RPL header to be processed is not handled properly unless it comes just after an IPv6 header.

You can confirm the first one with a packet unsupported by Contiki. For example, on sending a simple UDP-Lite packet to a mote running on Cooja, Cooja crashes by SIGSEGV. When the mote runs with Non-Storing mode enabled, Cooja stalls because the mote does not release CPU.
For the second bug, I used a packet which had a Destination Options header followed by a RPL Routing header. The Destination Options header had only one PadN option. Contiki was not able to find the RPL Routing header.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1750,2016-06-27T20:29:11Z,2016-06-29T08:38:17Z,2016-06-29T12:09:09Z,MERGED,True,28,32,1,https://github.com/yatch,Improve RPL extension headers handling,4,['bug'],https://github.com/contiki-os/contiki/pull/1750,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/1750#issuecomment-229292208,"This PR addresses mainly two bugs in rpl-ext-header.c.

The system crashes or falls into an infinite loop when it encounters an unsupported protocol header
(roughly speaking).
A RPL header to be processed is not handled properly unless it comes just after an IPv6 header.

You can confirm the first one with a packet unsupported by Contiki. For example, on sending a simple UDP-Lite packet to a mote running on Cooja, Cooja crashes by SIGSEGV. When the mote runs with Non-Storing mode enabled, Cooja stalls because the mote does not release CPU.
For the second bug, I used a packet which had a Destination Options header followed by a RPL Routing header. The Destination Options header had only one PadN option. Contiki was not able to find the RPL Routing header.","Haven't tested it yet, but üëç from me too",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1751,2016-06-28T22:05:24Z,2016-07-16T13:45:56Z,2016-07-16T13:45:56Z,MERGED,True,107,59,1,https://github.com/atiselsts,CC26xx: fix a regression in and refactor LPM code,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1751,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1751,This addresses all three points of issue #1736,This addresses all three points of issue #1736,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1751,2016-06-28T22:05:24Z,2016-07-16T13:45:56Z,2016-07-16T13:45:56Z,MERGED,True,107,59,1,https://github.com/atiselsts,CC26xx: fix a regression in and refactor LPM code,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1751,https://github.com/bkozak-scanimetrics,2,https://github.com/contiki-os/contiki/pull/1751#issuecomment-229512398,This addresses all three points of issue #1736,"Looks to me like it'll work. I don't have a setup to reproduce #1736 so I haven't tested it.
I'm sure @niklas88 will be able to confirm that this fixes the problem though.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1751,2016-06-28T22:05:24Z,2016-07-16T13:45:56Z,2016-07-16T13:45:56Z,MERGED,True,107,59,1,https://github.com/atiselsts,CC26xx: fix a regression in and refactor LPM code,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1751,https://github.com/niklas88,3,https://github.com/contiki-os/contiki/pull/1751#issuecomment-229578515,This addresses all three points of issue #1736,"Indeed, it seems like the power regression is gone and the code works well in my setup. üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1752,2016-06-28T22:18:01Z,2016-06-28T23:46:02Z,2016-06-28T23:46:17Z,CLOSED,False,13,0,1,https://github.com/g-oikonomou,Add CCxxware macros for cpu.h,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1752,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1752,Allows us to do things such as enquire the current state of the global interrupt enable/disable flag,Allows us to do things such as enquire the current state of the global interrupt enable/disable flag,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1752,2016-06-28T22:18:01Z,2016-06-28T23:46:02Z,2016-06-28T23:46:17Z,CLOSED,False,13,0,1,https://github.com/g-oikonomou,Add CCxxware macros for cpu.h,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1752,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1752#issuecomment-229216530,Allows us to do things such as enquire the current state of the global interrupt enable/disable flag,"How about switching all the Cortex-M3 platforms to the following?
https://github.com/contiki-os/contiki/blob/master/cpu/arm/common/CMSIS/core_cm3.h
https://github.com/contiki-os/contiki/blob/master/cpu/arm/common/CMSIS/core_cmFunc.h
https://github.com/contiki-os/contiki/blob/master/cpu/arm/common/CMSIS/core_cmInstr.h",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1752,2016-06-28T22:18:01Z,2016-06-28T23:46:02Z,2016-06-28T23:46:17Z,CLOSED,False,13,0,1,https://github.com/g-oikonomou,Add CCxxware macros for cpu.h,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1752,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1752#issuecomment-229217445,Allows us to do things such as enquire the current state of the global interrupt enable/disable flag,Apparently we had those already...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1753,2016-06-28T22:25:14Z,2016-06-30T20:53:45Z,2016-06-30T20:58:39Z,MERGED,True,1,0,1,https://github.com/g-oikonomou,Add missing include,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1753,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1753,A bit of a pedantic no-brainer here.,A bit of a pedantic no-brainer here.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1753,2016-06-28T22:25:14Z,2016-06-30T20:53:45Z,2016-06-30T20:58:39Z,MERGED,True,1,0,1,https://github.com/g-oikonomou,Add missing include,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1753,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1753#issuecomment-229785625,A bit of a pedantic no-brainer here.,Why is this even waiting for reviewing? üòº,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1753,2016-06-28T22:25:14Z,2016-06-30T20:53:45Z,2016-06-30T20:58:39Z,MERGED,True,1,0,1,https://github.com/g-oikonomou,Add missing include,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1753,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1753#issuecomment-229785665,A bit of a pedantic no-brainer here.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1754,2016-06-28T22:29:09Z,2016-07-16T18:47:16Z,2016-07-16T18:47:17Z,MERGED,True,14,4,1,https://github.com/atiselsts,CC26xx: change default TSCH guard time to 1.8ms,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1754,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1754,"This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1","This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1754,2016-06-28T22:29:09Z,2016-07-16T18:47:16Z,2016-07-16T18:47:17Z,MERGED,True,14,4,1,https://github.com/atiselsts,CC26xx: change default TSCH guard time to 1.8ms,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1754,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1754#issuecomment-229786427,"This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1","I agree in general that 2.2 ms is long, and I've worked with e.g 0.6 ms guards with no problems, but why introduce a change for this specific platform?
BTW in RFC 7554 my understanding is +/- 1ms, that is, a 2 ms guard (that's what I get from the calculations that follow the statement -- I can be wrong)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1754,2016-06-28T22:29:09Z,2016-07-16T18:47:16Z,2016-07-16T18:47:17Z,MERGED,True,14,4,1,https://github.com/atiselsts,CC26xx: change default TSCH guard time to 1.8ms,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1754,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/1754#issuecomment-230101020,"This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1","@simonduq the other platforms* do not have such a long system / radio wakeup time, so a long guard time is not a problem for them.
The fact is that since #1746 has been merged, the rpl-tsch example is broken for CC26xx platform. We need to fix it somehow, and I'm not happy to have CC26XX specific config in the example for the reasons I explained.
Good point about the RFC, I'm really not sure.
[*] - Except JN516x, which also does these ""early wakeups"" for the same reason, and where guard time reduction could be an alternative solution - but would require some tinkering with the platform's code.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1754,2016-06-28T22:29:09Z,2016-07-16T18:47:16Z,2016-07-16T18:47:17Z,MERGED,True,14,4,1,https://github.com/atiselsts,CC26xx: change default TSCH guard time to 1.8ms,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1754,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1754#issuecomment-230252357,"This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1","Right, I see!
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1754,2016-06-28T22:29:09Z,2016-07-16T18:47:16Z,2016-07-16T18:47:17Z,MERGED,True,14,4,1,https://github.com/atiselsts,CC26xx: change default TSCH guard time to 1.8ms,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1754,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1754#issuecomment-233131082,"This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1",@simonduq @atiselsts where are we on this one guys? Happy to merge?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1754,2016-06-28T22:29:09Z,2016-07-16T18:47:16Z,2016-07-16T18:47:17Z,MERGED,True,14,4,1,https://github.com/atiselsts,CC26xx: change default TSCH guard time to 1.8ms,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1754,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1754#issuecomment-233142604,"This change enables to run TSCH on CC26xx without application-specific configuration settings (i.e. without setting CC2650_FAST_RADIO_STARTUP to 1).
It fixes two real problems:

The early wakeup due to CC2650_FAST_RADIO_STARTUP requires additional energy compared to the ""normal"" wakeup at the start of an active TSCH slot.
Since CC2650_FAST_RADIO_STARTUP is not the default setting, it means that TSCH applications have to be explicitly ported to CC26xx by adding an application-specific setting. This is potentially confusing to new users. It is also not a good design since this approach would not scale well (in terms of more platforms).

The change introduces slightly ""nonstandard"" TSCH guard times for this platform. Numerous experiments have shown that slightly reducing the TSCH guard time while keeping the other Contiki TSCH configuration settings unchanged (or even changed, but not extensively) does not have bad effects on interoperability and packet delivery rate, but instead helps to save energy. For example, the 6tisch RFC 7554 talks about even smaller 1ms guard time: https://datatracker.ietf.org/doc/rfc7554/?include_text=1",fine with me!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1755,2016-06-28T22:36:07Z,2016-06-29T22:51:04Z,2016-06-29T22:51:04Z,MERGED,True,0,7,2,https://github.com/atiselsts,CC26xx: always request HF crystal oscillator at radio on(),1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1755,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1755,"This fixes a problem that appears when CC2650_FAST_RADIO_STARTUP is set to 1: radio on() could occasionally be called without requesting HF crystal oscillator before trying to use it, leading to reboots.
This change unconditionally requested the HF crystal oscillator in on(), which is very fast in case the oscillator already has been requested before and is ready.","This fixes a problem that appears when CC2650_FAST_RADIO_STARTUP is set to 1: radio on() could occasionally be called without requesting HF crystal oscillator before trying to use it, leading to reboots.
This change unconditionally requested the HF crystal oscillator in on(), which is very fast in case the oscillator already has been requested before and is ready.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1755,2016-06-28T22:36:07Z,2016-06-29T22:51:04Z,2016-06-29T22:51:04Z,MERGED,True,0,7,2,https://github.com/atiselsts,CC26xx: always request HF crystal oscillator at radio on(),1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1755,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1755#issuecomment-229208284,"This fixes a problem that appears when CC2650_FAST_RADIO_STARTUP is set to 1: radio on() could occasionally be called without requesting HF crystal oscillator before trying to use it, leading to reboots.
This change unconditionally requested the HF crystal oscillator in on(), which is very fast in case the oscillator already has been requested before and is ready.","This is basically a proper fix for #1744 in a sense that CC2650_FAST_RADIO_STARTUP set to 1 will not break ContikiMAC. We still leave it as 0 for ContikiMAC builds, since it's not required there, but this pull does improve the logic of things.
Extensively discussed with Atis earlier, so I'll merge this when Travis goes green.
Thanks üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1756,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1756#issuecomment-229209036,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",Shameless ping @jimmycmlo this could be a fix for #1659,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/arurke,3,https://github.com/contiki-os/contiki/pull/1756#issuecomment-229626233,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","I have tested this for a day on our platform which is comparable to srf06/cc13xx. I have a cc1310 SLIP + two nodes (cc1310 and cc1350) which transmits a UDP frame every second. My only metric at the moment is packet loss at reception, and of ~80000 I have 0 packets lost - a good sign.
Regarding RSSI and #1659. I see no difference before/after this PR. So at first glance it looks like it is not fixed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1756#issuecomment-229785223,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","Thanks Andreas, that's very useful. All devices in your setup are your custom boards, right? No standard launchpads or anything like that?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/arurke,5,https://github.com/contiki-os/contiki/pull/1756#issuecomment-229791083,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","The HW I am using now are EM cards. The platform/board files are slight modified for pins, sensors etc., cannot imagine it having any impact here. SLIP is vanilla.
Still going strong, 120k no loss.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/arurke,6,https://github.com/contiki-os/contiki/pull/1756#issuecomment-230444189,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",Got my hands on a cc1310 launchpad. Tested this yesterday and overnight - no problems experienced in my simple setup.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/tj57,7,https://github.com/contiki-os/contiki/pull/1756#issuecomment-232286804,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","I have tested yesterday with SMARTRF06 + CC1310EM devices, slip-radio and cc26xx-web-demo example. It works very unstable, I can't check RSSI.
In older version of Contiki eg, from June 5 I have very stable 400ms ping times, tested over 24h.
You can check my ping log. Do you have any idea how to debug it ?

64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=90 ttl=63 time=5384 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=91 ttl=63 time=10126 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=92 ttl=63 time=15386 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=93 ttl=63 time=19251 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=94 ttl=63 time=22877 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=95 ttl=63 time=27762 ms
ping: sendmsg: Network is unreachable
ping: sendmsg: Network is unreachable
ping: sendmsg: Network is unreachable
...
ping: sendmsg: Network is unreachable
ping: sendmsg: Network is unreachable
ping: sendmsg: Network is unreachable
ping: sendmsg: Network is unreachable
ping: sendmsg: Network is unreachable
From fe80::20c:29ff:fe82:52d3 icmp_seq=343 Destination unreachable: Address unreachable
From fe80::20c:29ff:fe82:52d3 icmp_seq=344 Destination unreachable: Address unreachable
From 2001:db8:2:0:2040:1821:87ed:be4b icmp_seq=345 Destination unreachable: Address unreachable
From 2001:db8:2:0:2040:1821:87ed:be4b icmp_seq=346 Destination unreachable: Address unreachable
From 2001:db8:2:0:2040:1821:87ed:be4b icmp_seq=347 Destination unreachable: Address unreachable
From 2001:db8:2:0:2040:1821:87ed:be4b icmp_seq=348 Destination unreachable: Address unreachable
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=349 ttl=63 time=4896 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=350 ttl=63 time=8887 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=351 ttl=63 time=13625 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=352 ttl=63 time=18364 ms
64 bytes from 2001:db8:2:0:212:4b00:a29:486a: icmp_seq=353 ttl=63 time=21238 ms
ping: sendmsg: Network is unreachable",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,8,https://github.com/contiki-os/contiki/pull/1756#issuecomment-232765267,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",this fixes #1775,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,9,https://github.com/contiki-os/contiki/pull/1756#issuecomment-233157091,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","I am now putting this forward for proper consideration to merge. I have tested using the web demo with:

CC1310 Border Router + CC1350 mesh node
6lbr + CC265EM + CC2650LP

The problems reported above by @tj57 should be fixed by #1783 and should be unrelated to this pull.",True,{'THUMBS_UP': ['https://github.com/leojrfs']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,10,https://github.com/contiki-os/contiki/pull/1756#issuecomment-233158213,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","i tested with 6lbr + 3x CC2650LP
its working fine",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,11,https://github.com/contiki-os/contiki/pull/1756#issuecomment-233158474,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",Testing with CC2650STK now. Looks good.,True,{'THUMBS_UP': ['https://github.com/leojrfs']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,12,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238107332,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",@g-oikonomou what is the status on this?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,13,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238109955,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","From my PoV, either waiting for a community member to yell ""This doesn't work!"" or for someone to merge it :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,14,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238113866,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","sorry for my innocent question because im confused, but aren't you the maintainer for this?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,15,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238114038,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","That is correct, but I don't like unilaterally merging my own pulls. Not unless they are of trivial scope and the team have had a chance to comment.
Having said all this, have you tried using this? Any experiences? Feedback most welcome!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,16,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238114361,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","yes, this solves #1775 that I reported some time ago, so I've been using your PR ever since.
The main branches have this problem reported in the issue.
Not being able to read gpios makes it a bit issue for me (app and driver specific), for example it makes it impossible to use it with a OneWire device.
There is nothing wrong that i can point with this ""update"", only issues solved.
Thats my experience üòÉ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,17,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238114455,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/casaroli,18,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238114511,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","Heelo Leo,
Coul you please clarify what you mean by not being able to read gpios?
Thanks!
On Sunday, 7 August 2016, Leo Soares notifications@github.com wrote:

yes, this solves #1775 #1775
that I reported some time ago, so I've been using you PR because the main
branches have this problem reported in the issue. Not being able to read
gpios makes it a bit issue for me (app and driver specific), for example it
makes it impossible for me to use it with a OneWire device.
There is nothing wrong that i can point with this ""update"", only issues
solved.
Thats my experience üòÉ
‚Äî
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub
#1756 (comment),
or mute the thread
https://github.com/notifications/unsubscribe-auth/ADszaCwG5hDoYcE45elo8XOcMqKnAI5Qks5qdmTpgaJpZM4JAnRz
.


Marco Casaroli",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,19,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238114634,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","Hello!
On the master branch ti_lib_gpio_pin_read() returns values like 4 and 20, no matter the real level.
with this pr, it works fine again",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,20,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238114735,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!",Please see my latest comment under #1775,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/g-oikonomou,21,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238115165,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","I should add, TI have changed said API in newer CCxxware versions: There is now one function to read a single pin that always returns 0 or 1 (GPIO_readDio) and a separate function to read multiple pins (GPIO_readMultiDio), which behaves like the old GPIOPinRead() and returns the combined value.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/leojrfs,22,https://github.com/contiki-os/contiki/pull/1756#issuecomment-238115436,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","@g-oikonomou I see now, thank you!
anyways, if this is merging any time soon, maybe its better for me to wait.
sorry for the trouble üòâ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1756,2016-06-28T22:49:47Z,2016-08-16T13:44:41Z,2016-08-16T13:44:49Z,MERGED,True,476,331,33,https://github.com/g-oikonomou,Update to latest TI CC13xxware/CC26xxware,16,"['enhancement', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1756,https://github.com/alignan,23,https://github.com/contiki-os/contiki/pull/1756#issuecomment-240105756,"This pull request updates Contiki CC13xx/CC26xx platforms to use TI's latest releases of CC13xxware & CC26xxware.
We update to the following versions:

CC26xxware: v2.24.02.17202
CC13xxware: v2.04.02.17240

These are the versions distributed with TI RTOS 2.20.00.06 (22 Jun 2016 release).
We have been pulling CCxxwares as sub-modules, which have so far been hosted under g-oikonomou/cc26xxware & g-oikonomou/cc13xxware. Since these repos are primarily meant as an origin for the Contiki submodule, it made more sense to host them under contiki-os/. I have therefore created the respective repos and pushed the code therein.
There are two important changes that I'd like to point out here:

TI have re-worked the GPIO API by a lot. This will break user applications that use GPIO and you will need to update things.
TI have now made ccfg.c configurable! We can now therefore enable/disable ROM bootloader support from our contiki-conf.h or project-conf.h without need of modifications to CCxxware sources. The platform default is ROM bootloader off, but our examples explicitly set it on for development/debugging purposes. Bootloader pin and level is now being configured in board.h. Changes to cc2538-bsl's README to follow after this has been merged.

This pull request changes Contiki's submodule URLs for both CCxxwares so they will from now on get pulled from contiki-os/. In order to update your local copy, you will likely need to run git submodule sync.
As you will notice in the CCxxware origins, there are incremental updates: There are commits that bring both repos to version .16941 before the final commit that updates to latest. I have tested .16941 with the following boards:

sensortag/cc2650
launchpad/cc2650
launchpad/cc1310
srf06/cc26xx
srf06/cc13xx

Changes between .16941 and latest seem inconsequential at first glance (from a Contiki perspective at least), but I'd very much appreciate community help with testing for various board/chip combos. Please post in this thread with success/failure reports. Thanks!","No one screaming and running with the head on fire
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1757,2016-06-29T15:08:44Z,2016-07-01T13:39:17Z,2017-10-27T20:03:32Z,MERGED,True,67,2,1,https://github.com/simonduq,RPL border HTTP server: support for non-storing,1,[],https://github.com/contiki-os/contiki/pull/1757,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1757,"With this PR, the BR will include the list of (RPL non-storing) links in its HTTP response.","With this PR, the BR will include the list of (RPL non-storing) links in its HTTP response.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1757,2016-06-29T15:08:44Z,2016-07-01T13:39:17Z,2017-10-27T20:03:32Z,MERGED,True,67,2,1,https://github.com/simonduq,RPL border HTTP server: support for non-storing,1,[],https://github.com/contiki-os/contiki/pull/1757,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1757#issuecomment-229948856,"With this PR, the BR will include the list of (RPL non-storing) links in its HTTP response.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1759,2016-06-30T20:41:52Z,2016-06-30T20:43:31Z,2016-06-30T20:44:30Z,CLOSED,False,13,13,7,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,2,[],https://github.com/contiki-os/contiki/pull/1759,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1759,"IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1759,2016-06-30T20:41:52Z,2016-06-30T20:43:31Z,2016-06-30T20:44:30Z,CLOSED,False,13,13,7,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,2,[],https://github.com/contiki-os/contiki/pull/1759,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1759#issuecomment-229783268,"IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","You had some unwanted commits in your PR, please fix and create a new PR anytime, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1760,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/vsaw,2,https://github.com/contiki-os/contiki/pull/1760#issuecomment-229927990,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","I really appreciate the work implementing RFC 6775. This is a very useful feature for many nodes and networks.
However it seems the pull-request was based on an outdated version of ContikiOS. E.g. you have included an outdated version of tcpip.c. Contiki's current version of tcpip.c was moved to a different folder and received some fixes/refactoring in the mean time.
As far as I can see, the bulk of your work should be portable to the current contiki codebase. Would you mind trying a rebase, and if this fails, a manual port?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1760#issuecomment-229969690,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.",I am trying manual port now. i will try rebase after Travis build ends. any feed will be gladly appreciated.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/1760#issuecomment-229991659,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.",Please refrain from pushing until you have completed your work; many e-mails get sent about commits to this PR otherwise.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1760#issuecomment-230165249,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","i need to delete all old commits except the last one (fixing issues). when i do rebase, it did not work.
any help will be greatly appreciated. thanks in advance and sorry for disturbance.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/darkopetrovic,6,https://github.com/contiki-os/contiki/pull/1760#issuecomment-230252956,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","The ND optimization should definitively be part of the contiki codebase.
I've noticed that you have implemented the code from https://github.com/lcmaqueda/6lowpan-nd. I did the same and found that it can work well. But I switched then to the ND optimisation implemented in the 6lbr project.
In the first implementation, the registrations are stored in a list and handled by dedicated functions (add, remove, lookup, ...). The new states introduced by RFC6775 for the Neighbor Cache Management (Garbage-collectible, Registered and Tentative) are then assigned to these registrations. However, these new types of Neighbor Cache Entries must instead remplace those in RFC4861 (Incomplete, Reachable, Stale, ...) which is not really the case with this implementation.
In the 6lbr project, the new types are assigned to the neighbor cache entries and the implementation is much easier to understand I think.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,7,https://github.com/contiki-os/contiki/pull/1760#issuecomment-230271248,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","First, i would like to thank you for your interest in implementing ND optimizations and our work.
second, i confirm that My implementation is based on  https://github.com/lcmaqueda/6lowpan-nd. however i would like to mention that this implementation is obsolete considering that it  implements a draft from the RFC 6775 not the RFC it self.
Moreover, The  code lake the implementation of mean points in the optimization such as:
a. No implementation for the processing procedure for Address registration process header. Also when creating NA in response no ARO included. This will lead to obvious failure in the address registration mechanism.
b.  the implementation of scheduled RA message does not contain destination which is must be set to the source of solicitation message.
c. implementing event timers to control the transmission of ND protocol messages, which is essential to construct the ND tables(neighbours, prefix list, registration list, and default router list)
d.  RFC 6775 omit the use of periodic RA messages, and only depend on transmission solicited RA message.
e.  The implementation of Ra transmissions  message  Only depend on receiving Rs message.
Also, when i skimmed through the 6lbr project. i did not see the above points are covered.
Finally, i would like to excerpt from the RFC 6775 some parts which clears things about Neighbor cache entries and the most prominent feature of the optimizations:
1- ""The most important part of the optimizations is the evolved host-to-
router interaction that allows for sleeping nodes and avoids using
multicast Neighbor Discovery messages except for the case of a host
finding an initial set of default routers, and redoing such
determination when that set of routers have become unreachable""
2- "" Note that the type of the NCE is orthogonal to the states specified
in [RFC4861].""
orthogonal by means that entry will keep the state  (Incomplete, Reachable, Stale, ...) and orthogonal choose state from (Garbage-collectible, Registered and Tentative). then as you mentioned the replacement won't be correct.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/darkopetrovic,8,https://github.com/contiki-os/contiki/pull/1760#issuecomment-230312712,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","It seems to me that the points you mentionned are covered by the implementation from the 6lbr project, at least as I tested them so far.
For me with this optimized standard there is no more host-to-host interaction when using sleeping devices, therefore the use of the precedent states (Incomplete, Reachable, ...) are no more required for a sleeping host to perform Address Resolution. The host send NS only for registration and to perform NUD with the routers. Howerver, on the router side, I guess this later use the new types with the sleeping device when the ARO option is present, and the others when not. Meaning that orthogonal means that the new types doesn't affect the old ones. But this means that both protocol cohabits on the router.
This is what I understand, maybe I'm wrong :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,9,https://github.com/contiki-os/contiki/pull/1760#issuecomment-230327714,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","i closed this pull request, and will start all over again as i made major changes in the code to be compatible with contiki v 3.0.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,10,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247008740,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.",#1765 updates this pull  request.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247009818,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","Cannot you push -f to this branch again, so as to update this rather than open a new one?
So much better to keep track of the discussion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,12,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247011895,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","sorry, i can not as i deleted this branch when i created the new one.
if you can guide me, i will be glad to do it.
thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/simonduq,13,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247013513,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","I would simply push to the branch again and then look for the ""reopen"" button on the web",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,14,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247019901,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","when i try doing what you mentioned i get this message.
remote: Permission to contiki-os/contiki.git denied to MohamedSeliem.
fatal: unable to access 'https://github.com/contiki-os/contiki.git/': The requested URL returned error: 403
as i mentioned, i deleted the branch from my repository.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/simonduq,15,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247020530,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","do not attempt to push on contiki-is/contiki, target your own repo instead",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/MohamedSeliem,16,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247050766,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","excuse me, but i can not push to my own repo, as i do not have a branch that will commit the changes to this PR.
pushing to my repo will update the new PR #1765 , it is already opened for 2 months.
i will refer to this PR  to keep track of the discussion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1760,2016-06-30T22:50:00Z,2016-07-04T16:52:52Z,2016-09-14T15:42:03Z,CLOSED,False,0,0,0,https://github.com/MohamedSeliem,Implementation of optimized neighbor discovery based on RFC 6775,0,[],https://github.com/contiki-os/contiki/pull/1760,https://github.com/simonduq,17,https://github.com/contiki-os/contiki/pull/1760#issuecomment-247056478,"the commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. that makes makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
you could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf.","ah ok I see you were using your master, then well, not sure if we can re-open this one indeed",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1761,2016-07-01T06:10:32Z,2016-07-01T11:38:10Z,2016-07-01T11:38:10Z,MERGED,True,0,2,1,https://github.com/MohamedSeliem,remove duplicate include,1,[],https://github.com/contiki-os/contiki/pull/1761,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1761,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1761,2016-07-01T06:10:32Z,2016-07-01T11:38:10Z,2016-07-01T11:38:10Z,MERGED,True,0,2,1,https://github.com/MohamedSeliem,remove duplicate include,1,[],https://github.com/contiki-os/contiki/pull/1761,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1761#issuecomment-229879730,,a bit of pedantic change.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1761,2016-07-01T06:10:32Z,2016-07-01T11:38:10Z,2016-07-01T11:38:10Z,MERGED,True,0,2,1,https://github.com/MohamedSeliem,remove duplicate include,1,[],https://github.com/contiki-os/contiki/pull/1761,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1761#issuecomment-229883022,,could you please rebase and squash this into a single commit?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1761,2016-07-01T06:10:32Z,2016-07-01T11:38:10Z,2016-07-01T11:38:10Z,MERGED,True,0,2,1,https://github.com/MohamedSeliem,remove duplicate include,1,[],https://github.com/contiki-os/contiki/pull/1761,https://github.com/MohamedSeliem,4,https://github.com/contiki-os/contiki/pull/1761#issuecomment-229908571,,Done,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1761,2016-07-01T06:10:32Z,2016-07-01T11:38:10Z,2016-07-01T11:38:10Z,MERGED,True,0,2,1,https://github.com/MohamedSeliem,remove duplicate include,1,[],https://github.com/contiki-os/contiki/pull/1761,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1761#issuecomment-229925528,,thanks! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1763,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1","change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1763#issuecomment-230345313,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1",What test did you run that caused this error? I'm wondering about why it was not shown in the regression tests.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1763#issuecomment-230348813,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1","this error appears when i run (01-compile-base) regression test locally. specifically, the error appears in (ipv6/rpl-tsch/z1 , ipv6/rpl-tsch/z1:MAKE_WITH_ORCHESTRA=1) fail logs.
I think  it was not detected by travis check as it appears as warning. however in local regression tests:
cc1: warnings being treated as errors.
In general, Uninitialized variables make a program non-deterministic. Each time the program runs, it may behave differently. Unrelated changes to operating environment, time of day, phase of the moon and permutations of such affect how and when these daemons manifest. The program may run a million times before the defect presents, them may do it every time, or run another million.
So Initializing a variable can prevent bugs. especially, If the variable is a reference type, initializing it can prevent null reference errors down the line.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1763#issuecomment-230353255,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1","Hello,

I would expect a modern compiler to find out that the variable is never used unless initialized. It is used only if busy_wait != 0, which happens only busy_wait_time is also set. What compiler version are you using? mspgcc 4.7.2 recommended.
Travis compiles with -Werror enabled so it would notice such a warning.
I wouldn't be happy with the fix anyway, as the variable has no reason to be static. If initialization were needed, I'd simply set it to 0.

Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1763#issuecomment-230355994,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1","I use gcc-4.7 (Ubuntu/Linaro 4.7.2-22ubuntu4) 4.7.2.
i do not know about travis, but i think initialization were needed. primarily, i though about set it to 0. then, i thought if the variable is defined to be static, it will by automatically set to 0 at initialization, besides it will  keeps its value between invocations.
i agree with  simonduq , it'd be simply set to 0.
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/1763#issuecomment-233160029,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1",@simonduq any advances here?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1763,2016-07-02T11:53:23Z,2016-07-17T19:07:38Z,2016-07-17T19:07:38Z,CLOSED,False,2,1,1,https://github.com/MohamedSeliem,Bug fix for uninitialized variable,3,[],https://github.com/contiki-os/contiki/pull/1763,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1763#issuecomment-233198195,"change is made to busy_wait_time to be static.
this will solve the problem of
../../../core/net/mac/tsch/tsch-slot-operation.c: In function ‚Äòtsch_get_lock‚Äô:
../../../core/net/mac/tsch/tsch-slot-operation.c:192:20: error: ‚Äòbusy_wait_time‚Äô may be used uninitialized in this function
make[1]: *** [obj_z1/tsch-slot-operation.o] Error 1",I don't see the point of the PR as there is no warning on an up-to-date msp430-gcc.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1764,2016-07-04T16:25:10Z,2016-07-15T17:50:34Z,2016-07-15T17:50:37Z,MERGED,True,459,1,4,https://github.com/alignan,Added DHT22 sensor to Zoul-based platforms,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1764,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1764,"This PR adds the DHT22 (the same as AM2302) sensor driver and test example, widely used and sold by different vendors, such as Grove, Adafruit, Sparkfun, etc.","This PR adds the DHT22 (the same as AM2302) sensor driver and test example, widely used and sold by different vendors, such as Grove, Adafruit, Sparkfun, etc.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1765,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247009762,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@vsaw , i need your feedback and comments on this.
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247051272,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","a previous discussion,was conducted in a old version of this PR, can be found here #1760",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/vsaw,4,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247102432,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","The files core/net/ipv6/uip-6lowpan-nd6.c looks like a copy of core/net/ipv6/uip-nd6.c. I have not run a diff on these two files so I don't know what you have added. Still can you explain why you created a new file and not edited the existing core/net/ipv6/uip-nd6.c
The pull request is is still in a state that makes it very hard to review your contribution to ContikiOS. But I very much encourage you to keep working on it as it seems like it's just a matter of cleaning things up, especially since Travis seems to like your pull-request.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247109008,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@vsaw Thank you for your comment, but let me clear things a little bit here.
RFC 6775 optimize neighbor discovery protocol (RFC 4861) by adding some features to make it practical in LoWPAN networks.
RFC 6775 suggests 3 new optional headers which will be attached to  ND messages, such as:
1- Address Registration Option (ARO): attached to (NS, NA)
2- 6LoWPAN context optional header (6CO):attached to (RA)
3- Authoritative border router (abro): attached to (RA)
each one of those options is used for specified purpose. for example, ARO used by host node to register its address with preferred default router, this will allow host nodes to sleep as specified in the RFC.
Besides, the RFC 6775 adds new constants and modified some other constants.
so, in my implementation i wanted to keep the old ND (4861) and the same time implement the optimized version (6775). consequently, core/net/ipv6/uip-6lowpan-nd6.c will be similar to core/net/ipv6/uip-nd6.c but with the extra added logic to implement the RFC 6775 features.
e.g. in uip-nd6-ns-output, you will find the processing of the ARO (new option header) and the modification to ND processes such as DAD, NUD, address resolution.
Conclusion, this implementation keeps the old ND and make the new implementation elective.
Finally, please let me know if you have any other comments, i'll really appreciate it.
Regards",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/vsaw,6,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247160042,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","Hi @MohamedSeliem
thank you very much for taking the time to reply to my remarks. This makes your intentions clear to me and I agree that making the RFC 6775 optional and keeping the current RFC 4861 based implementation in place is a good thing!
I just wonder if this can be achieved in a way that is easier to maintain. I primarily wonder if it can be oden without introducing a separate C file, but instead by using the compile time configuration like UIP_CONF_IPV6_LOWPAN_ND inside the current uip-nd6.c. This could be very similar to how UIP_ND6_SEND_NA is used.
A clean implementation of that feature would also add it to the list of configurable options in core/contiki-default-conf.h.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,7,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247166923,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","Nothing can not be achieved :)
however, it will be very complex to follow or to maintain. as RFC 6775 updates old ND, and the methodology of creating and processing ND messages are a little bit different.
e.g. NS, NA messages have new ARO option, and this option might be included or not in the message based on its purpose. merging such behavior with the old ND may be confusing.
another level of complexity, when we think about that in 6lowpan ND, we have 3 types of nodes:
6ln, 6lr, and 6lbr ; and each one have different in managing its data structure.
finally, in my opinion it will be very complex to combine the old and new ND in the same file , so that leaves us with only 2 options:
1- give up on old ND and   start to rely on optimized ND (not reliable solution)
2- implement the new optimized ND keeping the old one for now, untill we ready to move forward towards a mature version of optimized 6lowpan-ND.
Thanks for your time",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/vsaw,8,https://github.com/contiki-os/contiki/pull/1765#issuecomment-247168213,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@MohamedSeliem I see, in that case I propose to get a separate set of opinions on what should be done in order to achieve consensus.
@simonduq @adamdunkels Anyone care to weigh in?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/kelsayed,9,https://github.com/contiki-os/contiki/pull/1765#issuecomment-248570921,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf",I believe the best option would be to have a compilation flag or #define that will allow using the new optimized ND or the current one. Is this possible @MohamedSeliem?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,10,https://github.com/contiki-os/contiki/pull/1765#issuecomment-248572103,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@kelsayed yes of course, in this implementation, we define UIP_CONF_IPV6_LOWPAN_ND  flag.
By setting this flag to 1, it will enable the optimized ND functions, while setting it to zero will keep the basic ND.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,11,https://github.com/contiki-os/contiki/pull/1765#issuecomment-266179601,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@yatch i need your feedback and comments on this.
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/yatch,12,https://github.com/contiki-os/contiki/pull/1765#issuecomment-266250601,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@MohamedSeliem OK; let me leave some (general) comments:

It'd be nice if you could explain concisely in the pull-request message which features of RFC 6775 are supported. You can edit the pull-request message anytime you want.
Can you provide any sample simulation file to see how your code work? It would be helpful for others to understand the PR.
You might want to check the Contiki code style written in https://github.com/contiki-os/contiki/wiki/Code-Contributions . The other contents in the wiki page are also useful.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/sumantgupta1984,13,https://github.com/contiki-os/contiki/pull/1765#issuecomment-294704344,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf",Please provide permission to pull the code,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,14,https://github.com/contiki-os/contiki/pull/1765#issuecomment-295757888,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@sumantgupta1984  you can get the code by forking a clone from this link:
https://github.com/MohamedSeliem/contiki",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/tuvok,15,https://github.com/contiki-os/contiki/pull/1765#issuecomment-383078805,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","Hi guys, what is the current status here?
Any plans to merge this?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/kelsayed,16,https://github.com/contiki-os/contiki/pull/1765#issuecomment-386872989,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf",@MohamedSeliem Could you apply the recommendation of @yatch to have the PR moving forward.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/tuvok,17,https://github.com/contiki-os/contiki/pull/1765#issuecomment-390189693,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","I just noticed there is a bug in uip-6lowpan-nd6.h here, it has these definitions:
#define UIP_ND6_OPT_DNSSL               31 #define UIP_ND6_OPT_ARO			32 #define UIP_ND6_OPT_6CO			33 #define UIP_ND6_OPT_ABRO		34
the values starting with ARO are off by one:
https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml#icmpv6-parameters-5",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/MohamedSeliem,18,https://github.com/contiki-os/contiki/pull/1765#issuecomment-390199882,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@kelsayed Sure I will do, However, we still need Contiki member to weigh in for reviewing process.
@simonduq @nvt @adamdunkels anyone planning to move forward to with optimized ND 6775 implementation?
@tuvok Thank you for reporting this, please feel free to contact me if you found any other bugs to fix.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/simonduq,19,https://github.com/contiki-os/contiki/pull/1765#issuecomment-390202541,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@MohamedSeliem I'm no longer active here sorry, moved on to Contiki-NG.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1765,2016-07-04T17:19:40Z,,2018-05-18T14:25:38Z,OPEN,False,2388,8,9,https://github.com/MohamedSeliem,Implementation of 6LoWPAN-ND [RFC 6775],5,[],https://github.com/contiki-os/contiki/pull/1765,https://github.com/tuvok,20,https://github.com/contiki-os/contiki/pull/1765#issuecomment-390224138,"The commit of this pull is to update the neighbor discovery files to implement the new optimized version of neighbor discovery which suggested by IETF in RFC 6775.
IPv6 Neighbor Discovery (ND) based on RFC4861 was developed primarily for wired traffic on the shared medium. Its heavily use the multicast transmission in periodic router-advertisement multicast addresses with router solicitation, neighbor solicitation, address resolution, and duplicate-address detection. While periodic multicast signaling and solicited-node multicast signaling are useful for network stability in the standard Ethernet-based shared network, the limited-lifetime, battery-operated devices in the IEEE 802.15.4 network conserve energy with less signaling and by sending broadcast messages only once in a while. That makes it inefficient and sometimes impractical for IPv6 over Low power Wireless Personal Area Networks (6LoWPAN).
(https://tools.ietf.org/html/rfc6775) optimizes multicast messages to uni-cast messages. It eliminates the need for relatively expensive address resolution by sending a neighbor registration option along with a neighbor solicitation; it supports sleepy nodes in the networks; and it optimizes the protocol constants while eliminating periodic router-advertisement messages.
You could find all details in the following paper http://eece.cu.edu.eg/~akhattab/files/ND.pdf","@MohamedSeliem
The ARO option seems to be created incorrectly too, the last line of the function:
memcpy(&(((uip_nd6_opt_aro*)aro)->eui64), uip_lladdr, UIP_LLADDR_LEN);
just copies the lladdr, but the eui64 is 8 bytes not 6, different format:
http://packetlife.net/blog/2008/aug/4/eui-64-ipv6/",True,{'THUMBS_UP': ['https://github.com/MohamedSeliem']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1767,2016-07-05T11:26:35Z,2016-07-15T19:10:57Z,2017-10-27T20:03:34Z,MERGED,True,1,0,1,https://github.com/simonduq,"RPL: added missing return, to not join instances with unsupported MOP",1,"['bug', 'Network']",https://github.com/contiki-os/contiki/pull/1767,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1767,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1767,2016-07-05T11:26:35Z,2016-07-15T19:10:57Z,2017-10-27T20:03:34Z,MERGED,True,1,0,1,https://github.com/simonduq,"RPL: added missing return, to not join instances with unsupported MOP",1,"['bug', 'Network']",https://github.com/contiki-os/contiki/pull/1767,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1767#issuecomment-230453459,,üëç once Travis is happy,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1767,2016-07-05T11:26:35Z,2016-07-15T19:10:57Z,2017-10-27T20:03:34Z,MERGED,True,1,0,1,https://github.com/simonduq,"RPL: added missing return, to not join instances with unsupported MOP",1,"['bug', 'Network']",https://github.com/contiki-os/contiki/pull/1767,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1767#issuecomment-233044484,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/mguc,1,https://github.com/contiki-os/contiki/pull/1768,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1768#issuecomment-230710654,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,"Nice catch.
As an alternative fix, hat would you think of keeping the handler, but in exception_handler, in case of E_EXC_SYSCALL, return at the end of the function? (right before #if EXCEPTION_STALLS_SYSTEM)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/mguc,3,https://github.com/contiki-os/contiki/pull/1768#issuecomment-230788173,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,"Yes, this is possible too. In this case the stack will be printed twice. Do you know if the exception can be triggered by other functions except for vAHI_SwReset()? According to the data sheet this exception is generated by the instructions b.trap and b.sys.

The b.trap and b.sys instructions allow processor exceptions to be generated by software.
A system call exception will be generated when the b.sys instruction is executed. This exception can, for example, be used to enable a task to switch the processor into supervisor mode when a real time operating system is in use. (See Section 3 for further details.)
The b.trap instruction is commonly used for trapping errors and for debugging.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1768#issuecomment-230800843,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,I don't know more than what you found :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1768#issuecomment-233160077,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,This needs a code style fix @mguc but otherwise looks like a no-brainer (@simonduq ?),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1768#issuecomment-233198085,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,"Right @mguc , the if block is still not compliant with Contiki code style. Space needed between ( and {",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1768#issuecomment-244765577,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,@mguc ready to merge as soon as you fix the code style!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1768,2016-07-05T14:54:48Z,2016-09-05T18:50:35Z,2016-09-05T18:50:35Z,MERGED,True,4,0,1,https://github.com/mguc,JN516x: Exception handler causing infinite loop,5,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1768,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1768#issuecomment-244798602,This issue was reported some time ago (jn516x platform: Software Reset raising exception) and I ran into it. By removing the exception handler for SYSCALLs the JN516x restarts as expected.,Thanks! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1769,2016-07-06T17:22:07Z,2016-11-11T08:01:32Z,2016-11-11T08:01:32Z,MERGED,True,8,0,1,https://github.com/jnohlgard,rest-engine: Allow adding periodic resources after starting REST engine,3,"['enhancement', 'timed out', 'CoAP']",https://github.com/contiki-os/contiki/pull/1769,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1769,"Without this fix, the timers for periodic resources added after the REST engine was already running were never started. As a result, any observe requests over CoAP were never updated after the initial GET.","Without this fix, the timers for periodic resources added after the REST engine was already running were never started. As a result, any observe requests over CoAP were never updated after the initial GET.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1769,2016-07-06T17:22:07Z,2016-11-11T08:01:32Z,2016-11-11T08:01:32Z,MERGED,True,8,0,1,https://github.com/jnohlgard,rest-engine: Allow adding periodic resources after starting REST engine,3,"['enhancement', 'timed out', 'CoAP']",https://github.com/contiki-os/contiki/pull/1769,https://github.com/jnohlgard,2,https://github.com/contiki-os/contiki/pull/1769#issuecomment-231523541,"Without this fix, the timers for periodic resources added after the REST engine was already running were never started. As a result, any observe requests over CoAP were never updated after the initial GET.",@greg-king5 I updated the PR to set the timer from rest_activate_resource instead of polling the process.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1769,2016-07-06T17:22:07Z,2016-11-11T08:01:32Z,2016-11-11T08:01:32Z,MERGED,True,8,0,1,https://github.com/jnohlgard,rest-engine: Allow adding periodic resources after starting REST engine,3,"['enhancement', 'timed out', 'CoAP']",https://github.com/contiki-os/contiki/pull/1769,https://github.com/greg-king5,3,https://github.com/contiki-os/contiki/pull/1769#issuecomment-231577909,"Without this fix, the timers for periodic resources added after the REST engine was already running were never started. As a result, any observe requests over CoAP were never updated after the initial GET.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1769,2016-07-06T17:22:07Z,2016-11-11T08:01:32Z,2016-11-11T08:01:32Z,MERGED,True,8,0,1,https://github.com/jnohlgard,rest-engine: Allow adding periodic resources after starting REST engine,3,"['enhancement', 'timed out', 'CoAP']",https://github.com/contiki-os/contiki/pull/1769,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1769#issuecomment-257994966,"Without this fix, the timers for periodic resources added after the REST engine was already running were never started. As a result, any observe requests over CoAP were never updated after the initial GET.","üëç
Merging in a week if there is no objection, thanks for the patience!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1769,2016-07-06T17:22:07Z,2016-11-11T08:01:32Z,2016-11-11T08:01:32Z,MERGED,True,8,0,1,https://github.com/jnohlgard,rest-engine: Allow adding periodic resources after starting REST engine,3,"['enhancement', 'timed out', 'CoAP']",https://github.com/contiki-os/contiki/pull/1769,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1769#issuecomment-259902347,"Without this fix, the timers for periodic resources added after the REST engine was already running were never started. As a result, any observe requests over CoAP were never updated after the initial GET.","And a week has passed, happy to merge",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1770,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places","this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1770#issuecomment-233047410,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places","Unfortunately, I do not find this change acceptable in its current state; the new text is not written properly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1770#issuecomment-233049348,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places","So, what are the kind of changes do you suggest to be written properly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/1770#issuecomment-233051491,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places","If you keep the original text, you can simply add a line at the end of the block comment saying that ""The routing table definitions can be found in uip-ds6-route.h.""",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1770#issuecomment-233102463,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places",Done.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/MohamedSeliem,6,https://github.com/contiki-os/contiki/pull/1770#issuecomment-236382481,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places",@nvt  any progress here ?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1770#issuecomment-244765270,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places","no need for two commits here, could you please squash them?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1770,2016-07-07T10:04:28Z,2016-09-06T09:04:33Z,2016-09-06T09:04:33Z,CLOSED,False,3,0,1,https://github.com/MohamedSeliem,Fix uip-ds.h tables configuration comment,2,[],https://github.com/contiki-os/contiki/pull/1770,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1770#issuecomment-244892312,"this PR to update uip-ds.h comments, this small change is made to ease the track of Tables implementation places",now replaced with #1849,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1771,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table","UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1771#issuecomment-232934776,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table","This simple fix, set the maximum number of neighbor entries  in the neighbor table as defined in the project configuration file for (ipv6/ multicast example)
and without this fix, the defined value of the neighbor entries  in the neighbor table will be set to the default value as defined in (ipv6/ nbr-table.h)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1771#issuecomment-233161850,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table",@g-oikonomou  can i got your feed back on this.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1771#issuecomment-233201390,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table","You are right, those are the old defines. You probably want to be using
NBR_TABLE_CONF_MAX_NEIGHBORS and UIP_CONF_MAX_ROUTES",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1771#issuecomment-233321010,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table","great.
I do not think we have a problem in case of (UIP_CONF_DS6_ROUTE_NBU), as routing table defined it
/* Routing table /
#ifndef UIP_CONF_MAX_ROUTES
#ifdef UIP_CONF_DS6_ROUTE_NBU
#define UIP_DS6_ROUTE_NB UIP_CONF_DS6_ROUTE_NBU
#else / UIP_CONF_DS6_ROUTE_NBU /
#define UIP_DS6_ROUTE_NB 4
#endif / UIP_CONF_DS6_ROUTE_NBU /
#else / UIP_CONF_MAX_ROUTES /
#define UIP_DS6_ROUTE_NB UIP_CONF_MAX_ROUTES
#endif / UIP_CONF_MAX_ROUTES */
even though, updating to recent macros is a good way to move forward.
P.s. I redefined the Macros of nbr table, to avoid such a problem (a hidden, or unwilling used (UIP_CONF_DS6_NBR_NBU) ).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/MohamedSeliem,6,https://github.com/contiki-os/contiki/pull/1771#issuecomment-236382525,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table",@g-oikonomou any progress here?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1771#issuecomment-244765017,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table","I would rather fully retire the two old macros, by:

reverting the change to nbr-table.h
removing all definitions of UIP_CONF_DS6_NBR_NBU and UIP_CONF_DS6_ROUTE_NBU (not only in the multicast example)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1771,2016-07-07T11:03:26Z,2016-09-06T09:04:37Z,2016-09-06T09:04:37Z,CLOSED,False,12,7,2,https://github.com/MohamedSeliem,Modify obsolete  macro related to neighbor cache table size,5,[],https://github.com/contiki-os/contiki/pull/1771,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1771#issuecomment-244892327,"UIP_CONF_DS6_NBR_NBU, the number of elements in neighbor cache requested by the user in contiki configuration, is obsolete.
NBR_TABLE_CONF_MAX_NEIGHBOR is the latest Macro which is related to neighbor cache table",now replaced with #1849,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1776,2016-07-15T11:26:20Z,2016-07-15T14:51:51Z,2016-07-15T14:51:51Z,MERGED,True,0,247,1,https://github.com/herjulf,Removed unused file platform/avr-rss2/dev/ds18b20.c,1,[],https://github.com/contiki-os/contiki/pull/1776,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/1776,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1777,2016-07-15T15:49:08Z,2016-07-15T18:30:06Z,2016-07-15T18:30:07Z,MERGED,True,4,216,1,https://github.com/herjulf,Fix README.md not reference GPL,1,[],https://github.com/contiki-os/contiki/pull/1777,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/1777,Fix README.md not reference GPL,Fix README.md not reference GPL,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1777,2016-07-15T15:49:08Z,2016-07-15T18:30:06Z,2016-07-15T18:30:07Z,MERGED,True,4,216,1,https://github.com/herjulf,Fix README.md not reference GPL,1,[],https://github.com/contiki-os/contiki/pull/1777,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1777#issuecomment-233031171,Fix README.md not reference GPL,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1778,2016-07-16T16:40:13Z,2016-07-16T23:22:21Z,2016-07-16T23:24:23Z,MERGED,True,66,66,1,https://github.com/g-oikonomou,Improve code style of the CC2538 RF driver,4,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1778,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1778,"This pull request:

Changes get_sfd_timestamp() and mac_timer_init() to static.
Improves the code style of the CC2538 RF driver.","This pull request:

Changes get_sfd_timestamp() and mac_timer_init() to static.
Improves the code style of the CC2538 RF driver.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1778,2016-07-16T16:40:13Z,2016-07-16T23:22:21Z,2016-07-16T23:24:23Z,MERGED,True,66,66,1,https://github.com/g-oikonomou,Improve code style of the CC2538 RF driver,4,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1778,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1778#issuecomment-233156264,"This pull request:

Changes get_sfd_timestamp() and mac_timer_init() to static.
Improves the code style of the CC2538 RF driver.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1779,2016-07-16T16:53:21Z,2016-07-16T19:02:44Z,2016-07-16T19:02:44Z,MERGED,True,10,21,1,https://github.com/atiselsts,CC26xx: enable MCU sleeping while transmitting if and only if not in poll mode,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1779,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1779,"This pull request fixes the current, invalid logic in CC26xx IEEE mode radio driver, which messed up the global interrupt state.","This pull request fixes the current, invalid logic in CC26xx IEEE mode radio driver, which messed up the global interrupt state.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1779,2016-07-16T16:53:21Z,2016-07-16T19:02:44Z,2016-07-16T19:02:44Z,MERGED,True,10,21,1,https://github.com/atiselsts,CC26xx: enable MCU sleeping while transmitting if and only if not in poll mode,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/1779,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1779#issuecomment-233145016,"This pull request fixes the current, invalid logic in CC26xx IEEE mode radio driver, which messed up the global interrupt state.",üëç I'll merge this when travis goes green.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1780,2016-07-16T16:59:37Z,2016-08-12T10:09:12Z,2016-08-16T11:08:10Z,MERGED,True,0,2,1,https://github.com/g-oikonomou,Don't flush the CC2538 RF RX FIFO unconditionally,1,"['bug', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1780,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1780,"After reading a frame, read() checks the status of the RX FIFO:

If an overflow is detected, the FIFO gets flushed
If there are more frames in the FIFO, the cc2538_rf_process will get polled again in order to read out the next frame.
#1550 changed read(), which now performs the above check for non-poll mode, but it then flushes the FIFO unconditionally. Therefore, if there are two or more frames in the FIFO, they will get flushed before the cc2538_rf_process has had a chance to read them out. This results in missed frames.

Reproducing this is trivial: Build a CC2538 sniffer and see how it will never show you .15.4 ACK frames. ACK reception completes while read() is still streaming the previous captured frame to the host. Upon completion, the FIFO will get flushed and the ACK will get lost.
This pull proposes removing the unconditional flush and reverting to the original logic for non-TSCH operation.
Pinging @thomas-ha here for input regarding poll mode.
This pull sits on top of #1778.","After reading a frame, read() checks the status of the RX FIFO:

If an overflow is detected, the FIFO gets flushed
If there are more frames in the FIFO, the cc2538_rf_process will get polled again in order to read out the next frame.
#1550 changed read(), which now performs the above check for non-poll mode, but it then flushes the FIFO unconditionally. Therefore, if there are two or more frames in the FIFO, they will get flushed before the cc2538_rf_process has had a chance to read them out. This results in missed frames.

Reproducing this is trivial: Build a CC2538 sniffer and see how it will never show you .15.4 ACK frames. ACK reception completes while read() is still streaming the previous captured frame to the host. Upon completion, the FIFO will get flushed and the ACK will get lost.
This pull proposes removing the unconditional flush and reverting to the original logic for non-TSCH operation.
Pinging @thomas-ha here for input regarding poll mode.
This pull sits on top of #1778.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1780,2016-07-16T16:59:37Z,2016-08-12T10:09:12Z,2016-08-16T11:08:10Z,MERGED,True,0,2,1,https://github.com/g-oikonomou,Don't flush the CC2538 RF RX FIFO unconditionally,1,"['bug', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1780,https://github.com/thomas-ha,2,https://github.com/contiki-os/contiki/pull/1780#issuecomment-235833294,"After reading a frame, read() checks the status of the RX FIFO:

If an overflow is detected, the FIFO gets flushed
If there are more frames in the FIFO, the cc2538_rf_process will get polled again in order to read out the next frame.
#1550 changed read(), which now performs the above check for non-poll mode, but it then flushes the FIFO unconditionally. Therefore, if there are two or more frames in the FIFO, they will get flushed before the cc2538_rf_process has had a chance to read them out. This results in missed frames.

Reproducing this is trivial: Build a CC2538 sniffer and see how it will never show you .15.4 ACK frames. ACK reception completes while read() is still streaming the previous captured frame to the host. Upon completion, the FIFO will get flushed and the ACK will get lost.
This pull proposes removing the unconditional flush and reverting to the original logic for non-TSCH operation.
Pinging @thomas-ha here for input regarding poll mode.
This pull sits on top of #1778.","Sorry, that was a fault from my side to flush the queue here.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1780,2016-07-16T16:59:37Z,2016-08-12T10:09:12Z,2016-08-16T11:08:10Z,MERGED,True,0,2,1,https://github.com/g-oikonomou,Don't flush the CC2538 RF RX FIFO unconditionally,1,"['bug', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1780,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1780#issuecomment-239410116,"After reading a frame, read() checks the status of the RX FIFO:

If an overflow is detected, the FIFO gets flushed
If there are more frames in the FIFO, the cc2538_rf_process will get polled again in order to read out the next frame.
#1550 changed read(), which now performs the above check for non-poll mode, but it then flushes the FIFO unconditionally. Therefore, if there are two or more frames in the FIFO, they will get flushed before the cc2538_rf_process has had a chance to read them out. This results in missed frames.

Reproducing this is trivial: Build a CC2538 sniffer and see how it will never show you .15.4 ACK frames. ACK reception completes while read() is still streaming the previous captured frame to the host. Upon completion, the FIFO will get flushed and the ACK will get lost.
This pull proposes removing the unconditional flush and reverting to the original logic for non-TSCH operation.
Pinging @thomas-ha here for input regarding poll mode.
This pull sits on top of #1778.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1781,2016-07-16T17:19:38Z,2016-07-16T18:46:09Z,2016-07-16T18:46:09Z,MERGED,True,4,5,2,https://github.com/atiselsts,TSCH: add RADIO_DELAY_BEFORE_DETECT to rx guard time when waiting for a packet to be received,1,[],https://github.com/contiki-os/contiki/pull/1781,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/1781,"This essentially fixes the guard time for ACK packets in TSCH. The default guard time led to a large number of missed ACKs because the first call to receiving_packet() returns with 352 usec delay on CC26xx, and the unadjusted ACK guard time is just 400 usec.","This essentially fixes the guard time for ACK packets in TSCH. The default guard time led to a large number of missed ACKs because the first call to receiving_packet() returns with 352 usec delay on CC26xx, and the unadjusted ACK guard time is just 400 usec.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1781,2016-07-16T17:19:38Z,2016-07-16T18:46:09Z,2016-07-16T18:46:09Z,MERGED,True,4,5,2,https://github.com/atiselsts,TSCH: add RADIO_DELAY_BEFORE_DETECT to rx guard time when waiting for a packet to be received,1,[],https://github.com/contiki-os/contiki/pull/1781,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1781#issuecomment-233142880,"This essentially fixes the guard time for ACK packets in TSCH. The default guard time led to a large number of missed ACKs because the first call to receiving_packet() returns with 352 usec delay on CC26xx, and the unadjusted ACK guard time is just 400 usec.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1782,2016-07-16T19:22:49Z,2016-08-16T11:07:46Z,2016-08-16T11:07:50Z,CLOSED,False,20,0,1,https://github.com/g-oikonomou,Document CC13xx prop mode sniffer support,1,"['documentation', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1782,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1782,Document how to build a sub-ghz sniffer using CC13xx devices.,Document how to build a sub-ghz sniffer using CC13xx devices.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1782,2016-07-16T19:22:49Z,2016-08-16T11:07:46Z,2016-08-16T11:07:50Z,CLOSED,False,20,0,1,https://github.com/g-oikonomou,Document CC13xx prop mode sniffer support,1,"['documentation', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1782,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1782#issuecomment-240072350,Document how to build a sub-ghz sniffer using CC13xx devices.,Obsolete,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1783,2016-07-16T23:14:16Z,2016-08-17T13:06:07Z,2016-08-17T13:06:09Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Adjust ContikiMAC timings for CC13xx PROP mode,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1783,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1783,"#1684 slightly varied RF startup time and, as a result, threw ContikiMAC timing configuration off. This manifests itself with very poor CC13xx PROP mode radio performance, as documented in #1747.
This pull fixes this bug by slightly increasing ContikiMAC's inter-packet interval. This gives the receiver a little more time to respond with an ACK to unicast frames.
Fixes #1747","#1684 slightly varied RF startup time and, as a result, threw ContikiMAC timing configuration off. This manifests itself with very poor CC13xx PROP mode radio performance, as documented in #1747.
This pull fixes this bug by slightly increasing ContikiMAC's inter-packet interval. This gives the receiver a little more time to respond with an ACK to unicast frames.
Fixes #1747",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1784,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1784#issuecomment-233159317,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.",Sits on top of #1756,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1784#issuecomment-250322988,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","üëç  from me, if no objections I'm merging this by the end of the week",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/tussock-cam,4,https://github.com/contiki-os/contiki/pull/1784#issuecomment-252136290,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.",Has there been any work on adding support for CC1350 launchpad? I need to get this going and don't want to duplicate effort! Do you have a mental plan of what needs to be done?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1784#issuecomment-252190211,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","I just rebased this one. We have done some (a lot of) work on the CC1350LP, yes. The antenna switch is one thing that's still not finalised.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/tussock-cam,6,https://github.com/contiki-os/contiki/pull/1784#issuecomment-253403913,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","I've started to have a look at this, too. Have you had a lot of luck with the prop-mode driver? I've been getting ERROR_SYNTH_PROG when trying to use 863.125 MHz. Works fine at 868 MHz. Haven't been able to figure it out yet, do you have any ideas?
Also a little confused about the modesel (rf_core_set_modesel) for CC1310/CC1350. Going off the values listed here  https://e2e.ti.com/support/wireless_connectivity/proprietary_2-4_ghz/f/964/t/51971 (copied below) it seems that the CC1310 is in IEEE 802.15.4/BLE mode, and the CC1350 is Proprietary/BLE. Seems a little weird if the CC1310 is in 802.15.4 mode, but I can't find much official documentation for the configuration values.
0h = Unknown: None of the known protocols are supported.
1h = Bluetooth Low Energy is supported
2h = IEEE 802.15.4 is supported
3h = IEEE 802.15.4 and Bluetooth Low Energy are supported
4h = Proprietary Protocols are supported
5h = Bluetooth Low Energy and Proprietary Protocols are supported
6h = IEEE 802.15.4 and Proprietary Protocols are supported.
7h = Bluetooth Low Energy, IEEE 802.15.4, and Proprietary Protocols are supported.

I've also noticed that smartrf_settings_cmd_prop_radio_div_setup.formatConf.whitenMode is set to 0x07 for the CC13xx chips, which SmartRF lists as unknown (it's the 802.15.4 whitener).
I'm pretty new to the rf-core stuff, so sorry if I'm missing something..",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1784#issuecomment-253440346,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","I've been getting ERROR_SYNTH_PROG when trying to use 863.125 MHz

It's been a while since I played around with this, but I don't remember having a problem like this. Are you using a US launchpad? Those synth errors can be related to overrides.

Also a little confused about the modesel

Join the club :) the values we're using were provided by TI. The info you pasted from that thread makes it look as though modesel may be a bitmask.
We control the whitener from within the prop mode driver and it can be configured through PROP_MODE_CONF_DW (https://github.com/contiki-os/contiki/blob/master/cpu/cc26xx-cc13xx/rf-core/prop-mode.c#L98). So basically the value in smartrf-settings is not ultimately used.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1784#issuecomment-253440820,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","I'm ready to merge, would you prefer to keep the conversation here and wait until findings may be added, or do you prefer to deal with this later?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/tussock-cam,9,https://github.com/contiki-os/contiki/pull/1784#issuecomment-253622643,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","Are you using a US launchpad? Those synth errors can be related to overrides.

Yeah, I am. I guess that makes sense, it seems to work from SmartRF studio, though.

Join the club :) the values we're using were provided by TI. The info you pasted from that thread makes it look as though modesel may be a bitmask.

Well that's confusing! I'll just treat them as magic and hope for the best :)

We control the whitener from within the prop mode driver

Ah, I should've noticed that. Thanks!

I'm ready to merge, would you prefer to keep the conversation here and wait until findings may be added, or do you prefer to deal with this later?

I think George has cleared most things up, so happy to merge. Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1784,2016-07-17T01:02:31Z,2016-10-18T10:04:49Z,2016-11-06T20:53:12Z,MERGED,True,33,2,4,https://github.com/g-oikonomou,Add CC1350 support,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1784,https://github.com/g-oikonomou,10,https://github.com/contiki-os/contiki/pull/1784#issuecomment-258709752,"This pull adds support for the CC1350.
We only focus on CPU capability here.
Board support to follow in a separate pull request. We've got a little bit of work to do before we can properly support CC1350 boards, eg the brand new CC1350 LP (LAUNCHXL-CC1350). The main reason for this is that we need to make RF front-end / bias more configurable and we also need a clever way to support antenna switches, which is what the CC1350LP uses.","@tussock-cam see early CC1350LP work in this branch https://github.com/g-oikonomou/contiki/tree/contrib/cc1350/lp-and-st
Feel free to report back!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1786,2016-07-17T19:04:18Z,,2016-10-28T18:00:07Z,OPEN,False,51,38,22,https://github.com/g-oikonomou,Discuss: Provide a reason with calls to channel_clear(),4,"['enhancement', 'Discussion', 'work-in-progress', 'Network']",https://github.com/contiki-os/contiki/pull/1786,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1786,"On a number of occasions I've found it desirable to know (within the RF driver) the reason why channel_clear() was called by the RDC layer.
This function is called in two contexts:

For collision avoidance before TX
For incoming frame detection

Knowing the reason could be used to change the CCA logic depending on what we are trying to achieve. For example, if using energy level as a criterion, we can use a different threshold for each scenario. Or we can switch between OR and AND logic when we are using both Correlator-based and Energy-based CCA.
I thought I'd put it on the table, this is what it might look like. I'll provide examples for Cc13xx/CC26xx IEEE and PROP modes once I've had some feedback.
Looking forward to reading your thoughts.","On a number of occasions I've found it desirable to know (within the RF driver) the reason why channel_clear() was called by the RDC layer.
This function is called in two contexts:

For collision avoidance before TX
For incoming frame detection

Knowing the reason could be used to change the CCA logic depending on what we are trying to achieve. For example, if using energy level as a criterion, we can use a different threshold for each scenario. Or we can switch between OR and AND logic when we are using both Correlator-based and Energy-based CCA.
I thought I'd put it on the table, this is what it might look like. I'll provide examples for Cc13xx/CC26xx IEEE and PROP modes once I've had some feedback.
Looking forward to reading your thoughts.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1786,2016-07-17T19:04:18Z,,2016-10-28T18:00:07Z,OPEN,False,51,38,22,https://github.com/g-oikonomou,Discuss: Provide a reason with calls to channel_clear(),4,"['enhancement', 'Discussion', 'work-in-progress', 'Network']",https://github.com/contiki-os/contiki/pull/1786,https://github.com/kkrentz,2,https://github.com/contiki-os/contiki/pull/1786#issuecomment-256987201,"On a number of occasions I've found it desirable to know (within the RF driver) the reason why channel_clear() was called by the RDC layer.
This function is called in two contexts:

For collision avoidance before TX
For incoming frame detection

Knowing the reason could be used to change the CCA logic depending on what we are trying to achieve. For example, if using energy level as a criterion, we can use a different threshold for each scenario. Or we can switch between OR and AND logic when we are using both Correlator-based and Energy-based CCA.
I thought I'd put it on the table, this is what it might look like. I'll provide examples for Cc13xx/CC26xx IEEE and PROP modes once I've had some feedback.
Looking forward to reading your thoughts.","I agree that multiple CCA thresholds may be needed. However, configuring these thresholds at the RADIO layer seems difficult because every RDC layer has its particularities. Moreover, RADIO layers probably do not have sufficient context information for ""self-configuring"" CCA thresholds. Instead, I suggest that RDC layers (self-)configure CCA thresholds by themselves. This way, RADIO layers remain simple. We might even replace channel_clear with get_rssi to free RADIO layers from managing CCA thresholds entirely.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1787,2016-07-17T19:21:00Z,2017-04-24T15:02:48Z,2017-04-24T15:02:55Z,MERGED,True,5,7,1,https://github.com/g-oikonomou,Use `ccaInfo.ccaState` to decide whether CCA is complete,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1787,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1787,"This commit changes the logic of get_cca_info() in the CC26xx IEEE mode driver. We now use the command's return status bits to determine whether the radio's CCA monitoring function has completed, instead of drawing conclusions based on RSSI readings.
The logic that dictates whether CCA will signal an IDLE or BUSY channel is unchanged.","This commit changes the logic of get_cca_info() in the CC26xx IEEE mode driver. We now use the command's return status bits to determine whether the radio's CCA monitoring function has completed, instead of drawing conclusions based on RSSI readings.
The logic that dictates whether CCA will signal an IDLE or BUSY channel is unchanged.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1787,2016-07-17T19:21:00Z,2017-04-24T15:02:48Z,2017-04-24T15:02:55Z,MERGED,True,5,7,1,https://github.com/g-oikonomou,Use `ccaInfo.ccaState` to decide whether CCA is complete,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1787,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1787#issuecomment-287490745,"This commit changes the logic of get_cca_info() in the CC26xx IEEE mode driver. We now use the command's return status bits to determine whether the radio's CCA monitoring function has completed, instead of drawing conclusions based on RSSI readings.
The logic that dictates whether CCA will signal an IDLE or BUSY channel is unchanged.",I'll merge this in a month unless I receive an objection.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1789,2016-07-18T09:32:02Z,2016-07-24T14:18:56Z,2016-07-24T14:18:56Z,MERGED,True,6,6,3,https://github.com/tidyjiang8,Update comments: RFC3513 is obsoleted by RFC4921,1,['documentation'],https://github.com/contiki-os/contiki/pull/1789,https://github.com/tidyjiang8,1,https://github.com/contiki-os/contiki/pull/1789,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1789,2016-07-18T09:32:02Z,2016-07-24T14:18:56Z,2016-07-24T14:18:56Z,MERGED,True,6,6,3,https://github.com/tidyjiang8,Update comments: RFC3513 is obsoleted by RFC4921,1,['documentation'],https://github.com/contiki-os/contiki/pull/1789,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1789#issuecomment-234779813,,Documentation change here. I'm merging this üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1792,2016-07-20T22:37:16Z,2016-07-20T22:38:09Z,2016-11-26T11:00:18Z,CLOSED,False,547,112,22,https://github.com/sasodani,2016 06 16/pr tsch cooja mote with modification,13,[],https://github.com/contiki-os/contiki/pull/1792,https://github.com/sasodani,1,https://github.com/contiki-os/contiki/pull/1792,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1793,2016-07-22T17:26:41Z,2016-07-22T20:02:20Z,2016-07-23T03:26:22Z,MERGED,True,1,1,1,https://github.com/sumanpanchal,Minor data type correction.,1,[],https://github.com/contiki-os/contiki/pull/1793,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/1793,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1793,2016-07-22T17:26:41Z,2016-07-22T20:02:20Z,2016-07-23T03:26:22Z,MERGED,True,1,1,1,https://github.com/sumanpanchal,Minor data type correction.,1,[],https://github.com/contiki-os/contiki/pull/1793,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1793#issuecomment-234642066,,"Technically speaking, this change is useless, but it's cleaner, so üëç. Thanks.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1793,2016-07-22T17:26:41Z,2016-07-22T20:02:20Z,2016-07-23T03:26:22Z,MERGED,True,1,1,1,https://github.com/sumanpanchal,Minor data type correction.,1,[],https://github.com/contiki-os/contiki/pull/1793,https://github.com/sumanpanchal,3,https://github.com/contiki-os/contiki/pull/1793#issuecomment-234696341,,@bthebaudeau Thanks!!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1794,2016-07-24T02:44:51Z,2016-08-16T10:57:43Z,2016-08-16T11:08:04Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Fix PROP mode channel switching,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1794,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1794,"If NETSTACK_CONF_RADIO.set_value(RADIO_PARAM_CHANNEL, ...) is called when radio is on, it will fail to apply the channel change, because it won't re-send CMD_PROP_RADIO_DIV_SETUP and CMD_PROP_FS. This commit fixes this condition, by making sure the correct commands are sent to the radio.","If NETSTACK_CONF_RADIO.set_value(RADIO_PARAM_CHANNEL, ...) is called when radio is on, it will fail to apply the channel change, because it won't re-send CMD_PROP_RADIO_DIV_SETUP and CMD_PROP_FS. This commit fixes this condition, by making sure the correct commands are sent to the radio.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1794,2016-07-24T02:44:51Z,2016-08-16T10:57:43Z,2016-08-16T11:08:04Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Fix PROP mode channel switching,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1794,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1794#issuecomment-240070492,"If NETSTACK_CONF_RADIO.set_value(RADIO_PARAM_CHANNEL, ...) is called when radio is on, it will fail to apply the channel change, because it won't re-send CMD_PROP_RADIO_DIV_SETUP and CMD_PROP_FS. This commit fixes this condition, by making sure the correct commands are sent to the radio.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1795,2016-07-24T12:47:46Z,2016-08-16T12:47:17Z,2016-08-16T13:27:06Z,MERGED,True,1180,959,53,https://github.com/g-oikonomou,Add generic sensniff example and remove legacy sniffers,27,"['enhancement', 'new feature']",https://github.com/contiki-os/contiki/pull/1795,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1795,"This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.","This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.",True,{'THUMBS_UP': ['https://github.com/sgiannoulis']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1795,2016-07-24T12:47:46Z,2016-08-16T12:47:17Z,2016-08-16T13:27:06Z,MERGED,True,1180,959,53,https://github.com/g-oikonomou,Add generic sensniff example and remove legacy sniffers,27,"['enhancement', 'new feature']",https://github.com/contiki-os/contiki/pull/1795,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/1795#issuecomment-236428966,"This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.","A much more elegant solution indeed. Tested on my cc1350 in PROP mode, works fine when combined with #1794.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1795,2016-07-24T12:47:46Z,2016-08-16T12:47:17Z,2016-08-16T13:27:06Z,MERGED,True,1180,959,53,https://github.com/g-oikonomou,Add generic sensniff example and remove legacy sniffers,27,"['enhancement', 'new feature']",https://github.com/contiki-os/contiki/pull/1795,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1795#issuecomment-239463039,"This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.","Great job! thanks for the work put into making sensniff more generic.  I can confirm works on the RE-Mote for both 2.4GHz and 868MHz.   I would suggest having sensniff as submodule, despise the reasons against if any, I think it would be appreciated generally, and easier to work with.
üëç  after the minor change requested in my inline comment, and after travis is happy.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1795,2016-07-24T12:47:46Z,2016-08-16T12:47:17Z,2016-08-16T13:27:06Z,MERGED,True,1180,959,53,https://github.com/g-oikonomou,Add generic sensniff example and remove legacy sniffers,27,"['enhancement', 'new feature']",https://github.com/contiki-os/contiki/pull/1795,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1795#issuecomment-239469804,"This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.","Ooops not sure how that one escaped me. Update now. Regarding adding as submodule, perhaps one day :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1795,2016-07-24T12:47:46Z,2016-08-16T12:47:17Z,2016-08-16T13:27:06Z,MERGED,True,1180,959,53,https://github.com/g-oikonomou,Add generic sensniff example and remove legacy sniffers,27,"['enhancement', 'new feature']",https://github.com/contiki-os/contiki/pull/1795,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1795#issuecomment-239612785,"This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.","We have just opened up Yanzi's codebase for the Sparrow application layer - there is a significantly updated serial radio there including support for sniffing, RSSI scanning, etc. There is also a 3D RSSI scanner demo as an example there.
Documentation is not fully done yet but there is some there.
https://github.com/sics-iot/sparrow
Maybe we should try to make a ""grand"" combined super-duper sniffer/serial-radio/RSSI scanner thing to avoid fragmentation?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1795,2016-07-24T12:47:46Z,2016-08-16T12:47:17Z,2016-08-16T13:27:06Z,MERGED,True,1180,959,53,https://github.com/g-oikonomou,Add generic sensniff example and remove legacy sniffers,27,"['enhancement', 'new feature']",https://github.com/contiki-os/contiki/pull/1795,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1795#issuecomment-240070586,"This pull adds a generic sensniff example.
This implements the latest version of sensniff's serial line protocol and allows us to send commands from the host to the device to e.g. retrieve min/max/current channel or to change channel at runtime.
To test you will need to update your copy of sensniff to its latest version.
This example will work with any radio that implements the extended NETSTACK radio API. More specifically, we need to be able to turn off frame filtering and automatic h/w ACKs by calling NETSTACK_RADIO.set_value(RADIO_PARAM_RX_MODE, 0). For full functionality, this example needs the radio to also support:
NETSTACK_RADIO.get_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MIN, ...)
NETSTACK_RADIO.get_value(RADIO_CONST_CHANNEL_MAX, ...)

With the approach proposed here, we no longer need to bother with changing the RF driver at all (unless required to implement the above functionality). Basically the example is meant to work with zero changes to platform/CPU code.
I have also added support for quite a few platforms. I aimed for some of the popular ones, but also to cover a wide range of radios and CPUs in order to make it easier to add new ones:

zoul (tested on remote over UART as well as USB)
srf06-cc26xx (tested CC2650EM, CC1310EM, CC1310LP, CC2650LP)
CC2538DK (tested UART as well as USB)
CC2530DK (Srf05+CC2530EM, CC2531 USB dongle)
Z1 (untested)
jn516x (untested)
openmote-cc2538 (untested)
ev-aducrf101mkxz (untested)

The example should work with platforms equipped with the following radios:

CC1200 (tested with zoul/remote)
CC13xx/CC26xx IEEE and PROP modes
CC2538
CC2420 (untested)
jn516x radio (untested)
aducrf101 radio (untested)

The CC2520 RF driver doesn't support the extended API and cannot be supported as things stand. Perhaps this could be part of the future ToDo list.
I should add, I did not even look into any of the avr-based devices.
Assuming the radio is supported, adding support for new platforms is now trivial and requires minimal code replication. Literally all we need is a new directory with one or two header files and a small number of defines.
This example obsoletes platform- , cpu-, radio-specific implementations and examples, so I am removing them all.","Normally I prefer to merge working applications now rather than wait for a newer one that would supersedes it.  That said, I have been testing sparrow and it is working great! so I hope to see more of it in Contiki üòÑ
I keep my üëç  if @g-oikonomou addresses my suggestion",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1797,2016-07-26T13:24:25Z,2016-08-08T09:38:38Z,2016-10-03T06:45:19Z,MERGED,True,1,1,1,https://github.com/jnohlgard,core/net/rpl: Fix function declaration isn‚Äôt a prototype,1,[],https://github.com/contiki-os/contiki/pull/1797,https://github.com/jnohlgard,1,https://github.com/contiki-os/contiki/pull/1797,"Fixes
In file included from ../../../contiki/core/net/rpl/rpl-private.h:48:0,
                 from ../../../contiki/core/net/mac/tsch/tsch-rpl.c:42:
../../../contiki/core/net/rpl/rpl-ns.h:70:1: warning: function declaration isn‚Äôt a prototype [-Wstrict-prototypes]
 void rpl_ns_periodic();
 ^~~~","Fixes
In file included from ../../../contiki/core/net/rpl/rpl-private.h:48:0,
                 from ../../../contiki/core/net/mac/tsch/tsch-rpl.c:42:
../../../contiki/core/net/rpl/rpl-ns.h:70:1: warning: function declaration isn‚Äôt a prototype [-Wstrict-prototypes]
 void rpl_ns_periodic();
 ^~~~",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1797,2016-07-26T13:24:25Z,2016-08-08T09:38:38Z,2016-10-03T06:45:19Z,MERGED,True,1,1,1,https://github.com/jnohlgard,core/net/rpl: Fix function declaration isn‚Äôt a prototype,1,[],https://github.com/contiki-os/contiki/pull/1797,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1797#issuecomment-238188269,"Fixes
In file included from ../../../contiki/core/net/rpl/rpl-private.h:48:0,
                 from ../../../contiki/core/net/mac/tsch/tsch-rpl.c:42:
../../../contiki/core/net/rpl/rpl-ns.h:70:1: warning: function declaration isn‚Äôt a prototype [-Wstrict-prototypes]
 void rpl_ns_periodic();
 ^~~~",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1798,2016-07-28T15:40:41Z,2016-07-30T10:51:39Z,2016-07-30T10:51:39Z,CLOSED,False,1,1,1,https://github.com/marcas756,Make set_bits_in_byte() static,1,[],https://github.com/contiki-os/contiki/pull/1798,https://github.com/marcas756,1,https://github.com/contiki-os/contiki/pull/1798,"Will not link otherwise on compilers supporting inline (e.g. on native linux) :
contiki-native.a(chameleon-bitop): In Funktion `set_bits':
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:192: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:202: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:208: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:212: Nicht definierter Verweis auf `set_bits_in_byte'
collect2: error: ld returned 1 exit status
make: *** [multi-threading.native] Fehler 1
../../Makefile.include:280: die Regel f√ºr Ziel ‚Äûmulti-threading.native‚Äú scheiterte","Will not link otherwise on compilers supporting inline (e.g. on native linux) :
contiki-native.a(chameleon-bitop): In Funktion `set_bits':
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:192: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:202: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:208: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:212: Nicht definierter Verweis auf `set_bits_in_byte'
collect2: error: ld returned 1 exit status
make: *** [multi-threading.native] Fehler 1
../../Makefile.include:280: die Regel f√ºr Ziel ‚Äûmulti-threading.native‚Äú scheiterte",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1800,2016-07-30T04:56:54Z,2016-07-30T04:58:21Z,2016-07-30T04:58:21Z,CLOSED,False,0,0,0,https://github.com/marcas756,Merge pull request #1 from contiki-os/master,1,[],https://github.com/contiki-os/contiki/pull/1800,https://github.com/marcas756,1,https://github.com/contiki-os/contiki/pull/1800,Update,Update,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1800,2016-07-30T04:56:54Z,2016-07-30T04:58:21Z,2016-07-30T04:58:21Z,CLOSED,False,0,0,0,https://github.com/marcas756,Merge pull request #1 from contiki-os/master,1,[],https://github.com/contiki-os/contiki/pull/1800,https://github.com/marcas756,2,https://github.com/contiki-os/contiki/pull/1800#issuecomment-236342841,Update,oops,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1801,2016-07-30T10:46:02Z,,2016-07-30T12:12:28Z,OPEN,False,20,1,1,https://github.com/marcas756,Introduce SIGSTKSZ from sigstack.h to avoid segmentation fault,1,[],https://github.com/contiki-os/contiki/pull/1801,https://github.com/marcas756,1,https://github.com/contiki-os/contiki/pull/1801,"Only refers to linux native cpu architecture
The value SIGSTKSZ is a Linux system default specifying the number of bytes
that would be used to cover the usual case when manually allocating an
alternate stack area (also see sigstack.h on your system).
In computing an alternate stack size, a program should add that amount to its
stack requirements to allow for the system implementation overhead.","Only refers to linux native cpu architecture
The value SIGSTKSZ is a Linux system default specifying the number of bytes
that would be used to cover the usual case when manually allocating an
alternate stack area (also see sigstack.h on your system).
In computing an alternate stack size, a program should add that amount to its
stack requirements to allow for the system implementation overhead.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1802,2016-07-30T11:00:16Z,2016-09-05T14:50:25Z,2016-09-05T19:32:49Z,MERGED,True,1,1,1,https://github.com/marcas756,Make set_bits_in_byte() static (like for get_bits_in_byte),1,[],https://github.com/contiki-os/contiki/pull/1802,https://github.com/marcas756,1,https://github.com/contiki-os/contiki/pull/1802,"Make set_bits_in_byte() static (like done yet  for get_bits_in_byte) ...
Will fail to link on my system otherwise :
contiki-native.a(chameleon-bitop): In Funktion `set_bits':
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:192: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:202: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:208: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:212: Nicht definierter Verweis auf `set_bits_in_byte'
collect2: error: ld returned 1 exit status
make: *** [multi-threading.native] Fehler 1
../../Makefile.include:280: die Regel f√ºr Ziel ‚Äûmulti-threading.native‚Äú scheiterte","Make set_bits_in_byte() static (like done yet  for get_bits_in_byte) ...
Will fail to link on my system otherwise :
contiki-native.a(chameleon-bitop): In Funktion `set_bits':
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:192: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:202: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:208: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:212: Nicht definierter Verweis auf `set_bits_in_byte'
collect2: error: ld returned 1 exit status
make: *** [multi-threading.native] Fehler 1
../../Makefile.include:280: die Regel f√ºr Ziel ‚Äûmulti-threading.native‚Äú scheiterte",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1802,2016-07-30T11:00:16Z,2016-09-05T14:50:25Z,2016-09-05T19:32:49Z,MERGED,True,1,1,1,https://github.com/marcas756,Make set_bits_in_byte() static (like for get_bits_in_byte),1,[],https://github.com/contiki-os/contiki/pull/1802,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1802#issuecomment-244763989,"Make set_bits_in_byte() static (like done yet  for get_bits_in_byte) ...
Will fail to link on my system otherwise :
contiki-native.a(chameleon-bitop): In Funktion `set_bits':
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:192: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:202: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:208: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:212: Nicht definierter Verweis auf `set_bits_in_byte'
collect2: error: ld returned 1 exit status
make: *** [multi-threading.native] Fehler 1
../../Makefile.include:280: die Regel f√ºr Ziel ‚Äûmulti-threading.native‚Äú scheiterte",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1802,2016-07-30T11:00:16Z,2016-09-05T14:50:25Z,2016-09-05T19:32:49Z,MERGED,True,1,1,1,https://github.com/marcas756,Make set_bits_in_byte() static (like for get_bits_in_byte),1,[],https://github.com/contiki-os/contiki/pull/1802,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1802#issuecomment-244764205,"Make set_bits_in_byte() static (like done yet  for get_bits_in_byte) ...
Will fail to link on my system otherwise :
contiki-native.a(chameleon-bitop): In Funktion `set_bits':
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:192: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:202: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:208: Nicht definierter Verweis auf `set_bits_in_byte'
/home/blackdigi/workspace-cdt/contiki/examples/multi-threading//../../core/net/rime/chameleon-bitopt.c:212: Nicht definierter Verweis auf `set_bits_in_byte'
collect2: error: ld returned 1 exit status
make: *** [multi-threading.native] Fehler 1
../../Makefile.include:280: die Regel f√ºr Ziel ‚Äûmulti-threading.native‚Äú scheiterte",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1804,2016-07-31T22:33:40Z,2016-08-09T13:19:28Z,2016-08-09T13:19:28Z,MERGED,True,88,27,2,https://github.com/mdlemay,galileo: Add support for containerized build environment,1,[],https://github.com/contiki-os/contiki/pull/1804,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1804,"This patch adds a Dockerfile for building a container configured as a
build environment for Intel Galileo boards.  This patch also provides
documentation for using the containerized build environment.  Finally, it
streamlines the instructions for booting Contiki on Galileo and includes
other documentation refinements.","This patch adds a Dockerfile for building a container configured as a
build environment for Intel Galileo boards.  This patch also provides
documentation for using the containerized build environment.  Finally, it
streamlines the instructions for booting Contiki on Galileo and includes
other documentation refinements.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1804,2016-07-31T22:33:40Z,2016-08-09T13:19:28Z,2016-08-09T13:19:28Z,MERGED,True,88,27,2,https://github.com/mdlemay,galileo: Add support for containerized build environment,1,[],https://github.com/contiki-os/contiki/pull/1804,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1804#issuecomment-238549845,"This patch adds a Dockerfile for building a container configured as a
build environment for Intel Galileo boards.  This patch also provides
documentation for using the containerized build environment.  Finally, it
streamlines the instructions for booting Contiki on Galileo and includes
other documentation refinements.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1805,2016-08-01T00:06:59Z,2016-08-08T09:39:42Z,2016-08-08T09:39:42Z,MERGED,True,1,1,1,https://github.com/mdlemay,galileo: Build link-stats.c when IPv6 is enabled,1,[],https://github.com/contiki-os/contiki/pull/1805,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1805,This is required by the IPv6 implementation in Contiki OS.,This is required by the IPv6 implementation in Contiki OS.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1805,2016-08-01T00:06:59Z,2016-08-08T09:39:42Z,2016-08-08T09:39:42Z,MERGED,True,1,1,1,https://github.com/mdlemay,galileo: Build link-stats.c when IPv6 is enabled,1,[],https://github.com/contiki-os/contiki/pull/1805,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1805#issuecomment-238188487,This is required by the IPv6 implementation in Contiki OS.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1807,2016-08-02T16:07:45Z,2016-08-02T20:28:23Z,2016-08-02T20:28:24Z,MERGED,True,5,0,1,https://github.com/simonduq,Updated TSCH readme,1,['documentation'],https://github.com/contiki-os/contiki/pull/1807,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1807,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1809,2016-08-03T14:24:29Z,2016-08-03T15:06:53Z,2017-10-27T20:03:39Z,MERGED,True,4,4,5,https://github.com/simonduq,Fixes https://github.com/contiki-os/contiki/issues/1808,1,[],https://github.com/contiki-os/contiki/pull/1809,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1809,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1809,2016-08-03T14:24:29Z,2016-08-03T15:06:53Z,2017-10-27T20:03:39Z,MERGED,True,4,4,5,https://github.com/simonduq,Fixes https://github.com/contiki-os/contiki/issues/1808,1,[],https://github.com/contiki-os/contiki/pull/1809,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1809#issuecomment-237264892,,"I'm merging this as-is. Then, as you suggest, we should have a closer look at #1661
Fixes #1808",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1810,2016-08-03T16:12:31Z,2016-08-08T09:36:55Z,2016-08-08T09:36:55Z,MERGED,True,45,16,5,https://github.com/mdlemay,x86: Support configurable UART baud rate and fix initialization,2,[],https://github.com/contiki-os/contiki/pull/1810,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1810,"The first patch extends the Intel Quark X1000 SoC UART initialization API to accept a numeric baud rate specification.  This is useful for projects that require configuring a serial port with a particular baud rate.
The second patch fixes UART system call authorization initialization for applications that initialize both UARTs.","The first patch extends the Intel Quark X1000 SoC UART initialization API to accept a numeric baud rate specification.  This is useful for projects that require configuring a serial port with a particular baud rate.
The second patch fixes UART system call authorization initialization for applications that initialize both UARTs.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1810,2016-08-03T16:12:31Z,2016-08-08T09:36:55Z,2016-08-08T09:36:55Z,MERGED,True,45,16,5,https://github.com/mdlemay,x86: Support configurable UART baud rate and fix initialization,2,[],https://github.com/contiki-os/contiki/pull/1810,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1810#issuecomment-238187860,"The first patch extends the Intel Quark X1000 SoC UART initialization API to accept a numeric baud rate specification.  This is useful for projects that require configuring a serial port with a particular baud rate.
The second patch fixes UART system call authorization initialization for applications that initialize both UARTs.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/arurke,1,https://github.com/contiki-os/contiki/pull/1813,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/1813#issuecomment-238403159,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","I would also like to suggest moving the board-i2c files into the common-folder.
Also adding a write_single_read() function as this is the most common usage (at least in my experience). Alternatively move the sensor-common.* files as well, but I am having trouble understanding the need to do all the copying in sensor_common_write_reg()...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1813#issuecomment-238404701,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","I'm not following you here, Andreas",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/arurke,4,https://github.com/contiki-os/contiki/pull/1813#issuecomment-238408337,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","The PR or the comments?
Regarding the PR. I had trouble finding doc. for exactly what the different
master control commands do, but I (and Ron I guess) believe data_put puts
data into master reg. and I2C_MASTER_CMD_BURST_SEND_CONT does the actual
transmission.
Before this PR the I2C_MASTER_CMD_BURST_SEND_CONT command would not be
executed after the last byte is put into the reg. if more than 1 byte was
being transmitted.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/arurke,5,https://github.com/contiki-os/contiki/pull/1813#issuecomment-238681725,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","Digging deeper I think I am following why you are not following.
In board_i2c_write() it seems I2C_MASTER_CMD_BURST_RECEIVE_FINISH will indeed transmit whatever is in the i2c master register. So me extrapolating Ron's report onto board_i2c_write() seems incorrect. (removed it from PR)
However in board_i2c_write_read() there are no such finish command. The command after the writes are setting slave address and I2C_MASTER_CMD_BURST_RECEIVE_START. If these does not cause the byte in the register to be transmitted (which my crude testing indicates they do not), I believe it is a bug.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/1813#issuecomment-239298617,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","Andreas, I have only found the time to look at this very superficially, so it's probably me :) However, just double-checking, could this be in any way related with #1711?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1813#issuecomment-239316171,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","OK I think I'm with you now.
Those I2C_MASTER_CMD_xxx manipulate the ACK, START, STOP, RUN bits of the MCTRL register. A transmission or reception of a byte is executed by setting the RUN bit here.
For the first byte of a burst TX transaction we want START and RUN, but not STOP. For intermediate bytes we want simply RUN, for the last byte we want RUN and STOP. This will basically send the I2C start condition before the first byte and the stop condition after the last one.
It appears as though we are missing a trigger of the RUN for the last TX byte. This should be a _BURST_SEND_CONT and not a _FINISH, since we do not want the stop condition sent between direction changes. Thus, your recommended change seems valid to me.
Have a look at 21.3.5 of revision F of the TRM (SWCU117F), those flow charts make it nicely clear.
Regarding moving the file to somewhere more central, the reason it is located where it currently is, is because the MPU's I2C pins on the sensortag are connected to different DIOs than the I2C pins of all other sensors. Hence this interface selection in board_i2c_select(). If we were to move it, we should also come up with a more generic fashion that would allow boards to specify number of I2C interfaces and corresponding pins. If we were to move it as-is, it would fail to compile due to those sensortag-specific defines.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/arurke,8,https://github.com/contiki-os/contiki/pull/1813#issuecomment-240567534,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","Regarding i2c (and spi):
Could we make the libraries be almost agnostic to the pins (except storing the current selected), and let the application be responsible for using them correctly? e.g. having functions such as:
board_i2c_select(uint8_t sda_pin, uint8_t scl_pin, uint8_t address)
    selects and stores current pins
board_i2c_write/read/etc()
    acts on the current pins
board_i2c_deselect() and/or close()
   deselects/closes the current pins

And identically
board_spi_select(uint32_t bit_rate, uint8_t clk_pin, uint8_t miso_pin, uint8_t mosi_pin)
board_spi_write/read/flush()
board_spi_deselect() and/or close()

This would be completely generic and we don't have to worry about storing away lists of ports pr board - at the expense of slightly uglier code (having to specify pins instead of I2C_INTERFACE_0 etc.) and slightly more responsibility to the application (not messing up pins)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1813,2016-08-08T22:46:46Z,2016-08-11T22:47:42Z,2016-08-30T19:10:56Z,MERGED,True,6,10,1,https://github.com/arurke,Cc26xx/cc13xx I2C fix,2,[],https://github.com/contiki-os/contiki/pull/1813,https://github.com/arurke,9,https://github.com/contiki-os/contiki/pull/1813#issuecomment-243547138,"Fixes I2C multiple-write bug, as reported by Ron Segal: https://sourceforge.net/p/contiki/mailman/message/34633862/
plus minor opt.","As I made the comment on a closed thread I am not sure if a notif. is sent out or not, so please allow me to tag your name @g-oikonomou
You are of course perfectly welcome not to respond :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1815,2016-08-10T03:04:01Z,2016-08-11T13:14:35Z,2016-08-11T20:58:12Z,MERGED,True,4,4,4,https://github.com/bthebaudeau,doxygen: Fix orphan modules,1,['documentation'],https://github.com/contiki-os/contiki/pull/1815,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1815,Fix a few typos that made some doxygen modules become orphans.,Fix a few typos that made some doxygen modules become orphans.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1815,2016-08-10T03:04:01Z,2016-08-11T13:14:35Z,2016-08-11T20:58:12Z,MERGED,True,4,4,4,https://github.com/bthebaudeau,doxygen: Fix orphan modules,1,['documentation'],https://github.com/contiki-os/contiki/pull/1815,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1815#issuecomment-238754100,Fix a few typos that made some doxygen modules become orphans.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1815,2016-08-10T03:04:01Z,2016-08-11T13:14:35Z,2016-08-11T20:58:12Z,MERGED,True,4,4,4,https://github.com/bthebaudeau,doxygen: Fix orphan modules,1,['documentation'],https://github.com/contiki-os/contiki/pull/1815,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1815#issuecomment-239156987,Fix a few typos that made some doxygen modules become orphans.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1816,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.","This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1816#issuecomment-239317247,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.","üëç Not a lot to say here :)
Suggest additional pair of eyes to look at changes in core before merging this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1816#issuecomment-242047092,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.","The code seems OK, it has took me quite a while and probably understood half of it, great stuff!
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/bthebaudeau,4,https://github.com/contiki-os/contiki/pull/1816#issuecomment-256170932,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.","Thanks for your reviews. This PR has been inactive for more than two months. Any core reviewer willing to comment? ""I approve this PR. If nobody disapproves within one month, I will merge it.""
I will send an update to fix the conflicts caused by the changes made to the master branch since this PR.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1816#issuecomment-256193683,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.",I'm taking your word for it üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1816#issuecomment-256567956,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.","Rebase and merge, ACK and go üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1816,2016-08-10T03:13:32Z,2016-11-24T22:28:05Z,2016-11-24T22:28:09Z,MERGED,True,11379,5969,67,https://github.com/bthebaudeau,Cortex-M and CC2538 multi-threading,10,"['bug', 'enhancement', 'Core', 'nominated', 'documentation', 'timed out', 'Platform / CPU / ARM', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1816,https://github.com/bthebaudeau,7,https://github.com/contiki-os/contiki/pull/1816#issuecomment-262851514,"This PR:

updates CMSIS-CORE,
switches the CC2538 code base to CMSIS-CORE,
fixes a few things in core/sys/mt,
adds a common Cortex-M mtarch implementation,
enables the Cortex-M mtarch implementation on CC2538.

See the commit messages and the documentation in the code for more details.",Final timeout. Merging.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1819,2016-08-11T21:54:52Z,2016-08-11T22:48:04Z,2016-08-11T23:10:19Z,MERGED,True,30,2,3,https://github.com/bthebaudeau,CC2538: Use the 32.768-kHz crystal if present,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1819,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1819,"Enable the 32.768-kHz crystal on all the CC2538 platforms where it is present in order to get a better time accuracy.
This should avoid new cases of #1817 for in-tree platforms.","Enable the 32.768-kHz crystal on all the CC2538 platforms where it is present in order to get a better time accuracy.
This should avoid new cases of #1817 for in-tree platforms.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1819,2016-08-11T21:54:52Z,2016-08-11T22:48:04Z,2016-08-11T23:10:19Z,MERGED,True,30,2,3,https://github.com/bthebaudeau,CC2538: Use the 32.768-kHz crystal if present,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1819,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1819#issuecomment-239316583,"Enable the 32.768-kHz crystal on all the CC2538 platforms where it is present in order to get a better time accuracy.
This should avoid new cases of #1817 for in-tree platforms.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1820,2016-08-12T11:22:25Z,2016-08-12T12:38:12Z,2016-08-12T13:08:35Z,MERGED,True,2,0,1,https://github.com/alignan,Zoul: added firefly to motelist targets,1,"['enhancement', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1820,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1820,This PR adds the Firefly to the motelist's targets list.,This PR adds the Firefly to the motelist's targets list.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1821,2016-08-12T11:44:40Z,2016-09-05T14:28:53Z,2016-09-05T14:28:53Z,CLOSED,False,226,0,4,https://github.com/kaleemullah360,radio-mod lib very usefull for cc2420 radio configs in multihop or mesh network,1,[],https://github.com/contiki-os/contiki/pull/1821,https://github.com/kaleemullah360,1,https://github.com/contiki-os/contiki/pull/1821,"RADIO MOD
CC2420 Radio Configurations Library.
Problem:

Tired of setting custom Channel and Transmission ranges in number of nodes?
Often forget to change Channel or Transmission range in one of node in network and wonder why it is not functioning?
want to set Channel and Transmission ranges in single step for whole network?, also want to set a quit different configurations for one or more nodes ?

Solution:
Include the library in your application and set the desired channel and TX power for your network thats it!.
Abstract
The RADIO MOD library uses very small code footprints. Very light weight and usefull when creating multi hops or mesh network.
This library enhance the cc2420 radio methods. it uses cc2420_set_txpower(radioChannel_tx_power);, cc2420_set_channel(radioChannel);.
Setup:
Include the library in your application Makefile
APPS += config-radio
call the methods with approperiate settings.
Global Configurations:

Change the channel or TX power of all the nodes which includes this library.

In file
~/Contiki/app/config-radio/cc2420-radio.c

Change the values of following variables.
uint8_t radioChannel = 26;          // default channel
uint8_t radioChannel_tx_power = 31; // default power

in your application add these method.
set_cc2420_txpower(0);  // setting zero will use predefined configurations in `cc2420-radio.c` file
set_cc2420_channel(0);  // I want all the motes use the channel 26 defined in library.

Local Configurations:

Change the channel or TX power of only that node which includes this library.

in your application add these method with custom values.
set_cc2420_txpower(3);  // I want TX power to be 3 at mote B
set_cc2420_channel(15); // I want channel 15 to used at mote B

Usage
Case 1:

zero is passed in power/channel function i.e set_cc2420_txpower(0); will use predefined channel number in cc2420-radio lib

Case 2:

a custom value is passed in power/channel function i.e set_cc2420_txpower(13); will use channel 13.

Case 3:

not using both/eithere of power/channel setting function will set Contiki OS default configurations i.e channel 26, tx power 31.","RADIO MOD
CC2420 Radio Configurations Library.
Problem:

Tired of setting custom Channel and Transmission ranges in number of nodes?
Often forget to change Channel or Transmission range in one of node in network and wonder why it is not functioning?
want to set Channel and Transmission ranges in single step for whole network?, also want to set a quit different configurations for one or more nodes ?

Solution:
Include the library in your application and set the desired channel and TX power for your network thats it!.
Abstract
The RADIO MOD library uses very small code footprints. Very light weight and usefull when creating multi hops or mesh network.
This library enhance the cc2420 radio methods. it uses cc2420_set_txpower(radioChannel_tx_power);, cc2420_set_channel(radioChannel);.
Setup:
Include the library in your application Makefile
APPS += config-radio
call the methods with approperiate settings.
Global Configurations:

Change the channel or TX power of all the nodes which includes this library.

In file
~/Contiki/app/config-radio/cc2420-radio.c

Change the values of following variables.
uint8_t radioChannel = 26;          // default channel
uint8_t radioChannel_tx_power = 31; // default power

in your application add these method.
set_cc2420_txpower(0);  // setting zero will use predefined configurations in `cc2420-radio.c` file
set_cc2420_channel(0);  // I want all the motes use the channel 26 defined in library.

Local Configurations:

Change the channel or TX power of only that node which includes this library.

in your application add these method with custom values.
set_cc2420_txpower(3);  // I want TX power to be 3 at mote B
set_cc2420_channel(15); // I want channel 15 to used at mote B

Usage
Case 1:

zero is passed in power/channel function i.e set_cc2420_txpower(0); will use predefined channel number in cc2420-radio lib

Case 2:

a custom value is passed in power/channel function i.e set_cc2420_txpower(13); will use channel 13.

Case 3:

not using both/eithere of power/channel setting function will set Contiki OS default configurations i.e channel 26, tx power 31.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1821,2016-08-12T11:44:40Z,2016-09-05T14:28:53Z,2016-09-05T14:28:53Z,CLOSED,False,226,0,4,https://github.com/kaleemullah360,radio-mod lib very usefull for cc2420 radio configs in multihop or mesh network,1,[],https://github.com/contiki-os/contiki/pull/1821,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1821#issuecomment-239792076,"RADIO MOD
CC2420 Radio Configurations Library.
Problem:

Tired of setting custom Channel and Transmission ranges in number of nodes?
Often forget to change Channel or Transmission range in one of node in network and wonder why it is not functioning?
want to set Channel and Transmission ranges in single step for whole network?, also want to set a quit different configurations for one or more nodes ?

Solution:
Include the library in your application and set the desired channel and TX power for your network thats it!.
Abstract
The RADIO MOD library uses very small code footprints. Very light weight and usefull when creating multi hops or mesh network.
This library enhance the cc2420 radio methods. it uses cc2420_set_txpower(radioChannel_tx_power);, cc2420_set_channel(radioChannel);.
Setup:
Include the library in your application Makefile
APPS += config-radio
call the methods with approperiate settings.
Global Configurations:

Change the channel or TX power of all the nodes which includes this library.

In file
~/Contiki/app/config-radio/cc2420-radio.c

Change the values of following variables.
uint8_t radioChannel = 26;          // default channel
uint8_t radioChannel_tx_power = 31; // default power

in your application add these method.
set_cc2420_txpower(0);  // setting zero will use predefined configurations in `cc2420-radio.c` file
set_cc2420_channel(0);  // I want all the motes use the channel 26 defined in library.

Local Configurations:

Change the channel or TX power of only that node which includes this library.

in your application add these method with custom values.
set_cc2420_txpower(3);  // I want TX power to be 3 at mote B
set_cc2420_channel(15); // I want channel 15 to used at mote B

Usage
Case 1:

zero is passed in power/channel function i.e set_cc2420_txpower(0); will use predefined channel number in cc2420-radio lib

Case 2:

a custom value is passed in power/channel function i.e set_cc2420_txpower(13); will use channel 13.

Case 3:

not using both/eithere of power/channel setting function will set Contiki OS default configurations i.e channel 26, tx power 31.",The extended radio API already makes it possible to change the power and channel through any radio driver that supports it.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1821,2016-08-12T11:44:40Z,2016-09-05T14:28:53Z,2016-09-05T14:28:53Z,CLOSED,False,226,0,4,https://github.com/kaleemullah360,radio-mod lib very usefull for cc2420 radio configs in multihop or mesh network,1,[],https://github.com/contiki-os/contiki/pull/1821,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1821#issuecomment-244759656,"RADIO MOD
CC2420 Radio Configurations Library.
Problem:

Tired of setting custom Channel and Transmission ranges in number of nodes?
Often forget to change Channel or Transmission range in one of node in network and wonder why it is not functioning?
want to set Channel and Transmission ranges in single step for whole network?, also want to set a quit different configurations for one or more nodes ?

Solution:
Include the library in your application and set the desired channel and TX power for your network thats it!.
Abstract
The RADIO MOD library uses very small code footprints. Very light weight and usefull when creating multi hops or mesh network.
This library enhance the cc2420 radio methods. it uses cc2420_set_txpower(radioChannel_tx_power);, cc2420_set_channel(radioChannel);.
Setup:
Include the library in your application Makefile
APPS += config-radio
call the methods with approperiate settings.
Global Configurations:

Change the channel or TX power of all the nodes which includes this library.

In file
~/Contiki/app/config-radio/cc2420-radio.c

Change the values of following variables.
uint8_t radioChannel = 26;          // default channel
uint8_t radioChannel_tx_power = 31; // default power

in your application add these method.
set_cc2420_txpower(0);  // setting zero will use predefined configurations in `cc2420-radio.c` file
set_cc2420_channel(0);  // I want all the motes use the channel 26 defined in library.

Local Configurations:

Change the channel or TX power of only that node which includes this library.

in your application add these method with custom values.
set_cc2420_txpower(3);  // I want TX power to be 3 at mote B
set_cc2420_channel(15); // I want channel 15 to used at mote B

Usage
Case 1:

zero is passed in power/channel function i.e set_cc2420_txpower(0); will use predefined channel number in cc2420-radio lib

Case 2:

a custom value is passed in power/channel function i.e set_cc2420_txpower(13); will use channel 13.

Case 3:

not using both/eithere of power/channel setting function will set Contiki OS default configurations i.e channel 26, tx power 31.",No further discussion in this PR -- closing.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1822,2016-08-12T12:11:45Z,2016-09-05T14:48:54Z,2016-09-05T15:07:43Z,MERGED,True,0,4,1,https://github.com/yatch,Make it easier to use the Non-Storing mode with the rpl-udp example,1,[],https://github.com/contiki-os/contiki/pull/1822,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1822,"In examples/ipv6/rpl-udp, the Non-Storing mode is not enabled properly by make MAKE_WITH_NON_STORING=1. You have to set 1 to RPL_CONF_WITH_NON_STORING in project-conf.h manually as well.
This PR fixes this situation. The solution is removing the RPL_CONF_WITH_NON_STORING definition block of project-conf.h.
According to the following block of core/net/rpl/rpl-private.h, we don't need to set RPL_CONF_WITH_NON_STORING explicitly if RPL_CONF_MOP is RPL_MOP_NON_STORING. For the rpl-udp example, RPL_MOP_NON_STORING is set to RPL_CONF_MOP if WITH_NON_STORING is 1, and this is the case when make runs with MAKE_WITH_NON_STORING=1.
    202 /* RPL Mode of operation */
    203 #ifdef  RPL_CONF_MOP
    204 #define RPL_MOP_DEFAULT                 RPL_CONF_MOP
    205 #else /* RPL_CONF_MOP */
    206 #if RPL_WITH_MULTICAST
    207 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_MULTICAST
    208 #else
    209 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_NO_MULTICAST
    210 #endif /* RPL_WITH_MULTICAST */
    211 #endif /* RPL_CONF_MOP */
    212
   (snip)
    223 /*
    224  * Embed support for non-storing mode
    225  */
    226 #ifdef RPL_CONF_WITH_NON_STORING
    227 #define RPL_WITH_NON_STORING RPL_CONF_WITH_NON_STORING
    228 #else /* RPL_CONF_WITH_NON_STORING */
    229 /* By default: embed support for non-storing if and only if the configured MOP is non-storing */
    230 #define RPL_WITH_NON_STORING (RPL_MOP_DEFAULT == RPL_MOP_NON_STORING)
    231 #endif /* RPL_CONF_WITH_NON_STORING */","In examples/ipv6/rpl-udp, the Non-Storing mode is not enabled properly by make MAKE_WITH_NON_STORING=1. You have to set 1 to RPL_CONF_WITH_NON_STORING in project-conf.h manually as well.
This PR fixes this situation. The solution is removing the RPL_CONF_WITH_NON_STORING definition block of project-conf.h.
According to the following block of core/net/rpl/rpl-private.h, we don't need to set RPL_CONF_WITH_NON_STORING explicitly if RPL_CONF_MOP is RPL_MOP_NON_STORING. For the rpl-udp example, RPL_MOP_NON_STORING is set to RPL_CONF_MOP if WITH_NON_STORING is 1, and this is the case when make runs with MAKE_WITH_NON_STORING=1.
    202 /* RPL Mode of operation */
    203 #ifdef  RPL_CONF_MOP
    204 #define RPL_MOP_DEFAULT                 RPL_CONF_MOP
    205 #else /* RPL_CONF_MOP */
    206 #if RPL_WITH_MULTICAST
    207 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_MULTICAST
    208 #else
    209 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_NO_MULTICAST
    210 #endif /* RPL_WITH_MULTICAST */
    211 #endif /* RPL_CONF_MOP */
    212
   (snip)
    223 /*
    224  * Embed support for non-storing mode
    225  */
    226 #ifdef RPL_CONF_WITH_NON_STORING
    227 #define RPL_WITH_NON_STORING RPL_CONF_WITH_NON_STORING
    228 #else /* RPL_CONF_WITH_NON_STORING */
    229 /* By default: embed support for non-storing if and only if the configured MOP is non-storing */
    230 #define RPL_WITH_NON_STORING (RPL_MOP_DEFAULT == RPL_MOP_NON_STORING)
    231 #endif /* RPL_CONF_WITH_NON_STORING */",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1822,2016-08-12T12:11:45Z,2016-09-05T14:48:54Z,2016-09-05T15:07:43Z,MERGED,True,0,4,1,https://github.com/yatch,Make it easier to use the Non-Storing mode with the rpl-udp example,1,[],https://github.com/contiki-os/contiki/pull/1822,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1822#issuecomment-244763851,"In examples/ipv6/rpl-udp, the Non-Storing mode is not enabled properly by make MAKE_WITH_NON_STORING=1. You have to set 1 to RPL_CONF_WITH_NON_STORING in project-conf.h manually as well.
This PR fixes this situation. The solution is removing the RPL_CONF_WITH_NON_STORING definition block of project-conf.h.
According to the following block of core/net/rpl/rpl-private.h, we don't need to set RPL_CONF_WITH_NON_STORING explicitly if RPL_CONF_MOP is RPL_MOP_NON_STORING. For the rpl-udp example, RPL_MOP_NON_STORING is set to RPL_CONF_MOP if WITH_NON_STORING is 1, and this is the case when make runs with MAKE_WITH_NON_STORING=1.
    202 /* RPL Mode of operation */
    203 #ifdef  RPL_CONF_MOP
    204 #define RPL_MOP_DEFAULT                 RPL_CONF_MOP
    205 #else /* RPL_CONF_MOP */
    206 #if RPL_WITH_MULTICAST
    207 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_MULTICAST
    208 #else
    209 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_NO_MULTICAST
    210 #endif /* RPL_WITH_MULTICAST */
    211 #endif /* RPL_CONF_MOP */
    212
   (snip)
    223 /*
    224  * Embed support for non-storing mode
    225  */
    226 #ifdef RPL_CONF_WITH_NON_STORING
    227 #define RPL_WITH_NON_STORING RPL_CONF_WITH_NON_STORING
    228 #else /* RPL_CONF_WITH_NON_STORING */
    229 /* By default: embed support for non-storing if and only if the configured MOP is non-storing */
    230 #define RPL_WITH_NON_STORING (RPL_MOP_DEFAULT == RPL_MOP_NON_STORING)
    231 #endif /* RPL_CONF_WITH_NON_STORING */","thxs, that was a left-over from an earlier version üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1823,2016-08-14T12:44:34Z,2016-09-05T14:23:04Z,2016-09-05T14:23:04Z,CLOSED,False,1,1,1,None,Fix duplicate register definition warnings for atmega256rfr2 + rf230bb,1,[],https://github.com/contiki-os/contiki/pull/1823,None,1,https://github.com/contiki-os/contiki/pull/1823,"I am working on a platform using the said combination and the build produces a bunch of
warnings about duplicate register definitions. Judging by the comment above the definitions it seems to me that someone forgot to exclude them from the radio registermap.
I am not sure if the attached simple fix is valid for all the toolchain versions but it works for me
using the recent avr-libc. Update: it is not.","I am working on a platform using the said combination and the build produces a bunch of
warnings about duplicate register definitions. Judging by the comment above the definitions it seems to me that someone forgot to exclude them from the radio registermap.
I am not sure if the attached simple fix is valid for all the toolchain versions but it works for me
using the recent avr-libc. Update: it is not.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1823,2016-08-14T12:44:34Z,2016-09-05T14:23:04Z,2016-09-05T14:23:04Z,CLOSED,False,1,1,1,None,Fix duplicate register definition warnings for atmega256rfr2 + rf230bb,1,[],https://github.com/contiki-os/contiki/pull/1823,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1823#issuecomment-244758402,"I am working on a platform using the said combination and the build produces a bunch of
warnings about duplicate register definitions. Judging by the comment above the definitions it seems to me that someone forgot to exclude them from the radio registermap.
I am not sure if the attached simple fix is valid for all the toolchain versions but it works for me
using the recent avr-libc. Update: it is not.","I'm closing since this did not pass the compilation test, and has not been updated. We can re-open it if you at some point would like to provide another fix for the warnings.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1824,2016-08-15T01:36:00Z,2016-08-16T07:47:09Z,2016-08-16T19:18:56Z,MERGED,True,1,3,1,https://github.com/bthebaudeau,cc2538: uart: Fix garbled output occurring upon lpm_enter(),1,"['bug', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1824,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1824,"lpm_enter() must not enter PM1+ if the UART is transmitting. Otherwise, the UART clock gets disabled, and its TX is broken.
The commit b8b54a0 from #408 had already partially fixed this issue, but it could still occur while transmitting stop bits because, contrary to UART_FR.BUSY, UART_FR.TXFE takes only the data bits into account, not the stop bits.","lpm_enter() must not enter PM1+ if the UART is transmitting. Otherwise, the UART clock gets disabled, and its TX is broken.
The commit b8b54a0 from #408 had already partially fixed this issue, but it could still occur while transmitting stop bits because, contrary to UART_FR.BUSY, UART_FR.TXFE takes only the data bits into account, not the stop bits.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1826,2016-08-16T12:24:55Z,2016-08-17T15:33:08Z,2016-08-17T15:33:10Z,MERGED,True,2,2,2,https://github.com/alignan,Zoul: fixed voltage divider relationship,1,"['bug', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1826,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1826,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1826,2016-08-16T12:24:55Z,2016-08-17T15:33:08Z,2016-08-17T15:33:10Z,MERGED,True,2,2,2,https://github.com/alignan,Zoul: fixed voltage divider relationship,1,"['bug', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1826,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1826#issuecomment-240115731,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1827,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?","This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1827#issuecomment-243080737,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?",Yes it is (micromac is the name of the NXP lib that exposes radio capabilities),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1827#issuecomment-244761931,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?",do you want to add this to jn516x too then?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1827#issuecomment-244902878,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?","Yes of course, I will add the jn516x as well, I will take another check and try to include more platforms as well",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1827#issuecomment-256568108,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?","Sorry for the delay ( I hate October...), I will update the PR today",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1827#issuecomment-262796917,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?",ping? ;),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1827#issuecomment-262916732,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?","Updated, sorry for the very looong reply",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1827#issuecomment-262941747,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?",üëç setting timeout for merging,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1827,2016-08-16T13:17:23Z,2016-11-25T20:11:20Z,2016-11-25T20:11:22Z,MERGED,True,24,0,6,https://github.com/alignan,Harmonize RF_CHANNEL definition,1,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1827,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1827#issuecomment-263017809,"This PR brings back the RF_CHANNEL configuration parameter to newly platforms missing this, towards having a common channel definition to avoid platform-specific overrides.
@simonduq  MICROMAC_CONF_CHANNEL is the jn516x channel definition?",No reason to wait longer üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1828,2016-08-16T13:35:04Z,2016-08-25T08:54:17Z,2016-08-25T08:54:17Z,MERGED,True,60,20,5,https://github.com/alignan,Z1: cleaned up non-required libraries from builds and moved SENSORS d‚Ä¶,1,['enhancement'],https://github.com/contiki-os/contiki/pull/1828,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1828,‚Ä¶eclaration to its own file,‚Ä¶eclaration to its own file,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1828,2016-08-16T13:35:04Z,2016-08-25T08:54:17Z,2016-08-25T08:54:17Z,MERGED,True,60,20,5,https://github.com/alignan,Z1: cleaned up non-required libraries from builds and moved SENSORS d‚Ä¶,1,['enhancement'],https://github.com/contiki-os/contiki/pull/1828,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1828#issuecomment-240666565,‚Ä¶eclaration to its own file,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1828,2016-08-16T13:35:04Z,2016-08-25T08:54:17Z,2016-08-25T08:54:17Z,MERGED,True,60,20,5,https://github.com/alignan,Z1: cleaned up non-required libraries from builds and moved SENSORS d‚Ä¶,1,['enhancement'],https://github.com/contiki-os/contiki/pull/1828,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1828#issuecomment-240672887,‚Ä¶eclaration to its own file,"Oops, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1830,2016-08-19T12:16:20Z,2016-08-19T12:18:34Z,2016-08-19T12:18:34Z,CLOSED,False,72165,154,444,https://github.com/ngovanmao,main_master,643,[],https://github.com/contiki-os/contiki/pull/1830,https://github.com/ngovanmao,1,https://github.com/contiki-os/contiki/pull/1830,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1832,2016-08-22T13:36:09Z,,2017-09-05T09:27:44Z,OPEN,False,281,0,4,https://github.com/sumanpanchal,TI ADS7828 test application with Zolertia Remote.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1832,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/1832,"Test application to expand ADC channels using TI ADS7828 on Zolertia Remote and read sensor data using Remote I2C interface.
ADS7828 Datasheet: http://www.ti.com/lit/ds/symlink/ads7828.pdf","Test application to expand ADC channels using TI ADS7828 on Zolertia Remote and read sensor data using Remote I2C interface.
ADS7828 Datasheet: http://www.ti.com/lit/ds/symlink/ads7828.pdf",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1832,2016-08-22T13:36:09Z,,2017-09-05T09:27:44Z,OPEN,False,281,0,4,https://github.com/sumanpanchal,TI ADS7828 test application with Zolertia Remote.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1832,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1832#issuecomment-258003943,"Test application to expand ADC channels using TI ADS7828 on Zolertia Remote and read sensor data using Remote I2C interface.
ADS7828 Datasheet: http://www.ti.com/lit/ds/symlink/ads7828.pdf","Sorry for taking so long to answer, my intention was to make a PR on top of your contribution to show you my comments, but I got tangled with lots of work.
I like the contribution and the module itself, but I'm normally against having the sensor/actuator implementation in the same example application, as this difficult its reuse.  I would suggest separating the ADS7828 driver in platforms/zoul/dev/, and provide a test example using the ADS7828 with Contiki's sensor's API.
See the examples in platforms/zoul/dev for guidance, I will be happy to chip in anytime.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1832,2016-08-22T13:36:09Z,,2017-09-05T09:27:44Z,OPEN,False,281,0,4,https://github.com/sumanpanchal,TI ADS7828 test application with Zolertia Remote.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1832,https://github.com/sumanpanchal,3,https://github.com/contiki-os/contiki/pull/1832#issuecomment-274810830,"Test application to expand ADC channels using TI ADS7828 on Zolertia Remote and read sensor data using Remote I2C interface.
ADS7828 Datasheet: http://www.ti.com/lit/ds/symlink/ads7828.pdf","@alignan
Thanks for the feedback. I have updated the code as per your suggestion. Please look into it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1832,2016-08-22T13:36:09Z,,2017-09-05T09:27:44Z,OPEN,False,281,0,4,https://github.com/sumanpanchal,TI ADS7828 test application with Zolertia Remote.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1832,https://github.com/sumanpanchal,4,https://github.com/contiki-os/contiki/pull/1832#issuecomment-327097681,"Test application to expand ADC channels using TI ADS7828 on Zolertia Remote and read sensor data using Remote I2C interface.
ADS7828 Datasheet: http://www.ti.com/lit/ds/symlink/ads7828.pdf","@alignan
Please provide your feedback so it can be merge.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1832,2016-08-22T13:36:09Z,,2017-09-05T09:27:44Z,OPEN,False,281,0,4,https://github.com/sumanpanchal,TI ADS7828 test application with Zolertia Remote.,1,"['new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1832,https://github.com/msloth,5,https://github.com/contiki-os/contiki/pull/1832#issuecomment-327122301,"Test application to expand ADC channels using TI ADS7828 on Zolertia Remote and read sensor data using Remote I2C interface.
ADS7828 Datasheet: http://www.ti.com/lit/ds/symlink/ads7828.pdf","I don't have the hardware to test it, but I added a couple of suggestions on how to improve look and form of the code.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1833,2016-08-23T19:06:01Z,2016-09-05T14:18:26Z,2016-09-05T14:18:26Z,MERGED,True,96,94,1,https://github.com/sumanpanchal,CC2520: Added offset to calculate correct RSSI value,1,[],https://github.com/contiki-os/contiki/pull/1833,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/1833,"In CC2520 datasheet (http://www.ti.com/lit/ds/symlink/cc2520.pdf), according to section 5.7
Real RSSI = Register value - offset
where offset = 76 dBm","In CC2520 datasheet (http://www.ti.com/lit/ds/symlink/cc2520.pdf), according to section 5.7
Real RSSI = Register value - offset
where offset = 76 dBm",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1833,2016-08-23T19:06:01Z,2016-09-05T14:18:26Z,2016-09-05T14:18:26Z,MERGED,True,96,94,1,https://github.com/sumanpanchal,CC2520: Added offset to calculate correct RSSI value,1,[],https://github.com/contiki-os/contiki/pull/1833,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1833#issuecomment-244757516,"In CC2520 datasheet (http://www.ti.com/lit/ds/symlink/cc2520.pdf), according to section 5.7
Real RSSI = Register value - offset
where offset = 76 dBm",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1834,2016-08-23T20:13:32Z,2016-09-05T14:13:20Z,2016-09-05T14:13:20Z,MERGED,True,868,81,13,https://github.com/mdlemay,galileo: Simplify GPIO APIs and add support for gen. 1,4,[],https://github.com/contiki-os/contiki/pull/1834,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1834,Simplifies the GPIO APIs for Intel Galileo boards to permit users to specify board-level pin numbers rather than CPU-level pin numbers.  The API functions perform the board-to-CPU pin number translation internally.  Also adds support for GPIO and pinmuxing on first generation boards.,Simplifies the GPIO APIs for Intel Galileo boards to permit users to specify board-level pin numbers rather than CPU-level pin numbers.  The API functions perform the board-to-CPU pin number translation internally.  Also adds support for GPIO and pinmuxing on first generation boards.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1834,2016-08-23T20:13:32Z,2016-09-05T14:13:20Z,2016-09-05T14:13:20Z,MERGED,True,868,81,13,https://github.com/mdlemay,galileo: Simplify GPIO APIs and add support for gen. 1,4,[],https://github.com/contiki-os/contiki/pull/1834,https://github.com/mdlemay,2,https://github.com/contiki-os/contiki/pull/1834#issuecomment-241862553,Simplifies the GPIO APIs for Intel Galileo boards to permit users to specify board-level pin numbers rather than CPU-level pin numbers.  The API functions perform the board-to-CPU pin number translation internally.  Also adds support for GPIO and pinmuxing on first generation boards.,"@jeez, @aguedes, @ricardotk: Will any of you be able to review these?  Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1834,2016-08-23T20:13:32Z,2016-09-05T14:13:20Z,2016-09-05T14:13:20Z,MERGED,True,868,81,13,https://github.com/mdlemay,galileo: Simplify GPIO APIs and add support for gen. 1,4,[],https://github.com/contiki-os/contiki/pull/1834,https://github.com/aguedes,3,https://github.com/contiki-os/contiki/pull/1834#issuecomment-244252868,Simplifies the GPIO APIs for Intel Galileo boards to permit users to specify board-level pin numbers rather than CPU-level pin numbers.  The API functions perform the board-to-CPU pin number translation internally.  Also adds support for GPIO and pinmuxing on first generation boards.,"LGTM, @mdlemay! üëç",True,{'HOORAY': ['https://github.com/mdlemay']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1834,2016-08-23T20:13:32Z,2016-09-05T14:13:20Z,2016-09-05T14:13:20Z,MERGED,True,868,81,13,https://github.com/mdlemay,galileo: Simplify GPIO APIs and add support for gen. 1,4,[],https://github.com/contiki-os/contiki/pull/1834,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/1834#issuecomment-244756429,Simplifies the GPIO APIs for Intel Galileo boards to permit users to specify board-level pin numbers rather than CPU-level pin numbers.  The API functions perform the board-to-CPU pin number translation internally.  Also adds support for GPIO and pinmuxing on first generation boards.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1835,2016-08-23T20:17:56Z,2016-12-08T19:12:45Z,2016-12-08T19:12:45Z,MERGED,True,9,0,1,https://github.com/mdlemay,galileo: Add general protection exception handler,1,[],https://github.com/contiki-os/contiki/pull/1835,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1835,"This patch adds a general protection exception handler that prints a
message indicating the faulting instruction and the error code. This is
useful when debugging general protection exceptions.","This patch adds a general protection exception handler that prints a
message indicating the faulting instruction and the error code. This is
useful when debugging general protection exceptions.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1835,2016-08-23T20:17:56Z,2016-12-08T19:12:45Z,2016-12-08T19:12:45Z,MERGED,True,9,0,1,https://github.com/mdlemay,galileo: Add general protection exception handler,1,[],https://github.com/contiki-os/contiki/pull/1835,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1835#issuecomment-265827196,"This patch adds a general protection exception handler that prints a
message indicating the faulting instruction and the error code. This is
useful when debugging general protection exceptions.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1836,2016-08-23T20:21:55Z,2016-09-09T14:55:05Z,2016-09-09T14:55:05Z,MERGED,True,53,2,2,https://github.com/mdlemay,galileo: Add process to perform DHCP configuration,1,[],https://github.com/contiki-os/contiki/pull/1836,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1836,"This patch adds a process that is started automatically to request DHCP
configuration.  It also moves the IP configuration ahead of autostart processes
in case some autostart process depends on the IP configuration.","This patch adds a process that is started automatically to request DHCP
configuration.  It also moves the IP configuration ahead of autostart processes
in case some autostart process depends on the IP configuration.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1836,2016-08-23T20:21:55Z,2016-09-09T14:55:05Z,2016-09-09T14:55:05Z,MERGED,True,53,2,2,https://github.com/mdlemay,galileo: Add process to perform DHCP configuration,1,[],https://github.com/contiki-os/contiki/pull/1836,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1836#issuecomment-245937431,"This patch adds a process that is started automatically to request DHCP
configuration.  It also moves the IP configuration ahead of autostart processes
in case some autostart process depends on the IP configuration.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1837,2016-08-24T12:28:46Z,2016-08-31T10:00:31Z,2016-08-31T10:00:34Z,MERGED,True,393,8,7,https://github.com/Zolertia,Zoul: generic servo driver,1,[],https://github.com/contiki-os/contiki/pull/1837,https://github.com/Zolertia,1,https://github.com/contiki-os/contiki/pull/1837,"This PR adds a basic servo driver using the PWM library

There are still suggestions open in #1505 to improve the PWM driver, but this PR doesn't significantly prevents so.","This PR adds a basic servo driver using the PWM library

There are still suggestions open in #1505 to improve the PWM driver, but this PR doesn't significantly prevents so.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1837,2016-08-24T12:28:46Z,2016-08-31T10:00:31Z,2016-08-31T10:00:34Z,MERGED,True,393,8,7,https://github.com/Zolertia,Zoul: generic servo driver,1,[],https://github.com/contiki-os/contiki/pull/1837,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1837#issuecomment-242321360,"This PR adds a basic servo driver using the PWM library

There are still suggestions open in #1505 to improve the PWM driver, but this PR doesn't significantly prevents so.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1838,2016-08-24T14:35:49Z,2016-08-25T22:00:59Z,2016-08-25T22:01:02Z,MERGED,True,2,1,1,https://github.com/alignan,Zoul: fix TMP102 value conversion,1,"['bug', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1838,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1838,Updates the value conversion by discarding the non-used bits.,Updates the value conversion by discarding the non-used bits.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1838,2016-08-24T14:35:49Z,2016-08-25T22:00:59Z,2016-08-25T22:01:02Z,MERGED,True,2,1,1,https://github.com/alignan,Zoul: fix TMP102 value conversion,1,"['bug', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1838,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1838#issuecomment-242321316,Updates the value conversion by discarding the non-used bits.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1844,2016-08-31T10:00:02Z,2016-08-31T15:04:44Z,2016-08-31T15:04:51Z,MERGED,True,373,2,4,https://github.com/alignan,Zoul: added driver to control an AC light dimmer with zero-crossing,2,"['enhancement', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1844,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1844,"This PR adds support for an AC light dimmer using a zero-crossing trigger.  The specific AC dimming module is the Krida Electronic's AC dimmer module.

The timings were verified using a logic analyser, for a 50Hz AC frequency.","This PR adds support for an AC light dimmer using a zero-crossing trigger.  The specific AC dimming module is the Krida Electronic's AC dimmer module.

The timings were verified using a logic analyser, for a 50Hz AC frequency.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1844,2016-08-31T10:00:02Z,2016-08-31T15:04:44Z,2016-08-31T15:04:51Z,MERGED,True,373,2,4,https://github.com/alignan,Zoul: added driver to control an AC light dimmer with zero-crossing,2,"['enhancement', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1844,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1844#issuecomment-243793876,"This PR adds support for an AC light dimmer using a zero-crossing trigger.  The specific AC dimming module is the Krida Electronic's AC dimmer module.

The timings were verified using a logic analyser, for a 50Hz AC frequency.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1845,2016-09-01T08:29:48Z,2016-09-01T08:30:03Z,2016-09-14T07:08:29Z,CLOSED,False,2,2,1,https://github.com/mfabregas,MSP430/F2xxx: fix ubr msb byte being hardcoded to zero,1,[],https://github.com/contiki-os/contiki/pull/1845,https://github.com/mfabregas,1,https://github.com/contiki-os/contiki/pull/1845,"This PR request fixes UART0 initialization with a hard-coded UBR's MSB register to zero, preventing baudrates like 9600 from properly being configured.  Tested for 115200 and 9600 baud rates, using any of the Z1 test examples with putty configured for the tested baudrates.","This PR request fixes UART0 initialization with a hard-coded UBR's MSB register to zero, preventing baudrates like 9600 from properly being configured.  Tested for 115200 and 9600 baud rates, using any of the Z1 test examples with putty configured for the tested baudrates.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1846,2016-09-01T08:31:18Z,2016-09-14T07:08:25Z,2016-09-14T07:08:33Z,MERGED,True,2,2,1,https://github.com/alignan,MSP430/F2xxx: fix ubr msb byte being hardcoded to zero,1,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1846,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1846,"This PR request fixes UART0 initialization with a hard-coded UBR's MSB register to zero, preventing baudrates like 9600 from properly being configured. Tested for 115200 and 9600 baud rates, using any of the Z1 test examples with putty configured for the tested baudrates.","This PR request fixes UART0 initialization with a hard-coded UBR's MSB register to zero, preventing baudrates like 9600 from properly being configured. Tested for 115200 and 9600 baud rates, using any of the Z1 test examples with putty configured for the tested baudrates.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1846,2016-09-01T08:31:18Z,2016-09-14T07:08:25Z,2016-09-14T07:08:33Z,MERGED,True,2,2,1,https://github.com/alignan,MSP430/F2xxx: fix ubr msb byte being hardcoded to zero,1,"['bug', 'Platform / CPU']",https://github.com/contiki-os/contiki/pull/1846,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1846#issuecomment-246925228,"This PR request fixes UART0 initialization with a hard-coded UBR's MSB register to zero, preventing baudrates like 9600 from properly being configured. Tested for 115200 and 9600 baud rates, using any of the Z1 test examples with putty configured for the tested baudrates.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1848,2016-09-05T13:54:15Z,2016-09-06T06:50:08Z,2016-09-06T06:50:08Z,MERGED,True,3,3,1,https://github.com/afonsomota,fix misplaced bracket causing compilation error when probing is disabled,2,[],https://github.com/contiki-os/contiki/pull/1848,https://github.com/afonsomota,1,https://github.com/contiki-os/contiki/pull/1848,"When configuring a project to not use RPL parent probing (ex: we set RPL_CONF_WITH_PROBING to 0 in our project configuration), a misplaced bracket causes a compilation error in function rpl_select_parent of the file core/net/rpl/rpl-dag.c.","When configuring a project to not use RPL parent probing (ex: we set RPL_CONF_WITH_PROBING to 0 in our project configuration), a misplaced bracket causes a compilation error in function rpl_select_parent of the file core/net/rpl/rpl-dag.c.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1848,2016-09-05T13:54:15Z,2016-09-06T06:50:08Z,2016-09-06T06:50:08Z,MERGED,True,3,3,1,https://github.com/afonsomota,fix misplaced bracket causing compilation error when probing is disabled,2,[],https://github.com/contiki-os/contiki/pull/1848,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1848#issuecomment-244761379,"When configuring a project to not use RPL parent probing (ex: we set RPL_CONF_WITH_PROBING to 0 in our project configuration), a misplaced bracket causes a compilation error in function rpl_select_parent of the file core/net/rpl/rpl-dag.c.",that seems correct to me but please also fix the new indentation of the block,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1848,2016-09-05T13:54:15Z,2016-09-06T06:50:08Z,2016-09-06T06:50:08Z,MERGED,True,3,3,1,https://github.com/afonsomota,fix misplaced bracket causing compilation error when probing is disabled,2,[],https://github.com/contiki-os/contiki/pull/1848,https://github.com/afonsomota,3,https://github.com/contiki-os/contiki/pull/1848#issuecomment-244771809,"When configuring a project to not use RPL parent probing (ex: we set RPL_CONF_WITH_PROBING to 0 in our project configuration), a misplaced bracket causes a compilation error in function rpl_select_parent of the file core/net/rpl/rpl-dag.c.","Sorry, should have done it from the start. The new commit does the fix.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1848,2016-09-05T13:54:15Z,2016-09-06T06:50:08Z,2016-09-06T06:50:08Z,MERGED,True,3,3,1,https://github.com/afonsomota,fix misplaced bracket causing compilation error when probing is disabled,2,[],https://github.com/contiki-os/contiki/pull/1848,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1848#issuecomment-244864164,"When configuring a project to not use RPL parent probing (ex: we set RPL_CONF_WITH_PROBING to 0 in our project configuration), a misplaced bracket causes a compilation error in function rpl_select_parent of the file core/net/rpl/rpl-dag.c.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1849,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU","update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244796231,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU","@simonduq  i combined the modifications in #1770 #1771 , and squashed them in one commit based on your comments.
""removing all definitions of UIP_CONF_DS6_NBR_NBU and UIP_CONF_DS6_ROUTE_NBU (not only in the multicast example)"" :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244798453,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",Looks good to me except for some unwanted indentation change in comments,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/MohamedSeliem,4,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244798580,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",already fixed ;),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244798705,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",did you push? the diff still shows a change in indent,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244799102,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU","No sorry, what I mean is the space you removed before the * in uip-ds6.h, lines 54 to 60.
Please rebase after that to avoid unnecessary commits (just use ""fixup""). Then just push -f",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/MohamedSeliem,7,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244800074,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",Thank you.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1849#issuecomment-244800232,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",Great. Thanks. üëç if Travis is green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/MohamedSeliem,9,https://github.com/contiki-os/contiki/pull/1849#issuecomment-245966052,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",@simonduq so any plans to merge these changes soon?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1849#issuecomment-245988101,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",see https://github.com/contiki-os/contiki/blob/master/CONTRIBUTING.md#pull-request-merging-policy,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/MohamedSeliem,11,https://github.com/contiki-os/contiki/pull/1849#issuecomment-245988999,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU","okay, Thanks.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1849,2016-09-05T17:58:59Z,2016-09-12T12:25:59Z,2016-09-12T12:25:59Z,MERGED,True,14,16,6,https://github.com/MohamedSeliem,"Make UIP_CONF_DS6_ROUTE_NBU and DS6_NBR_NBU, DS6_ROUTE_NBU obsolete",1,[],https://github.com/contiki-os/contiki/pull/1849,https://github.com/nvt,12,https://github.com/contiki-os/contiki/pull/1849#issuecomment-246331421,"update uip-ds.h comments, this small change is made to ease the track of Tables implementation places
remove definition of UIP_CONF_DS6_ROUTE_NBU
retire 2 old macros DS6_NBR_NBU, DS6_ROUTE_NBU",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1851,2016-09-06T09:25:35Z,2016-09-14T05:53:14Z,2016-09-14T05:53:14Z,MERGED,True,8,2,1,https://github.com/kqorany,Referring to the ESMRF engine that was recently merged,1,['documentation'],https://github.com/contiki-os/contiki/pull/1851,https://github.com/kqorany,1,https://github.com/contiki-os/contiki/pull/1851,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1852,2016-09-06T09:50:12Z,2016-09-07T13:50:15Z,2016-09-07T13:50:15Z,CLOSED,False,351007,32,370,https://github.com/niwotahao,Port efm32,8,[],https://github.com/contiki-os/contiki/pull/1852,https://github.com/niwotahao,1,https://github.com/contiki-os/contiki/pull/1852,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1852,2016-09-06T09:50:12Z,2016-09-07T13:50:15Z,2016-09-07T13:50:15Z,CLOSED,False,351007,32,370,https://github.com/niwotahao,Port efm32,8,[],https://github.com/contiki-os/contiki/pull/1852,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1852#issuecomment-245286280,,"Please check the rules for new platforms:
https://github.com/contiki-os/contiki/wiki/Code-Contributions#new-platforms
Please add some text in the PR to motivate the addition of this new platform. Please avoid changes to apps and core files (acceptable only if strictly needed). Am also unsure about the whole set of emf-related header files, which seem like standard lib rather than contiki-specific, it might be a better choice to keep these outside of the contiki tree. Please rebase on master (not 2.7 nor 3.0). I invite you to submit a new PR once all the requirements are met.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1854,2016-09-08T19:16:00Z,2016-12-08T19:18:50Z,2016-12-08T19:18:50Z,MERGED,True,16,4,1,https://github.com/mdlemay,x86: Fix section alignment for EFI binaries,1,[],https://github.com/contiki-os/contiki/pull/1854,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1854,"This patch fixes the section alignment specification in the linker script for
the Intel Quark X1000 SoC so that the UEFI GenFw program generates correct EFI
binaries.  See the added comment in quarkX1000.ld for details.","This patch fixes the section alignment specification in the linker script for
the Intel Quark X1000 SoC so that the UEFI GenFw program generates correct EFI
binaries.  See the added comment in quarkX1000.ld for details.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1854,2016-09-08T19:16:00Z,2016-12-08T19:18:50Z,2016-12-08T19:18:50Z,MERGED,True,16,4,1,https://github.com/mdlemay,x86: Fix section alignment for EFI binaries,1,[],https://github.com/contiki-os/contiki/pull/1854,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1854#issuecomment-265828839,"This patch fixes the section alignment specification in the linker script for
the Intel Quark X1000 SoC so that the UEFI GenFw program generates correct EFI
binaries.  See the added comment in quarkX1000.ld for details.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1855,2016-09-10T08:57:22Z,2016-12-08T19:08:59Z,2016-12-08T19:08:59Z,MERGED,True,23,29,2,https://github.com/MohamedSeliem,"DAD: Remove useless ""if"" that tests if the source address is unspecified",2,[],https://github.com/contiki-os/contiki/pull/1855,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1855,"No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .","No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1855,2016-09-10T08:57:22Z,2016-12-08T19:08:59Z,2016-12-08T19:08:59Z,MERGED,True,23,29,2,https://github.com/MohamedSeliem,"DAD: Remove useless ""if"" that tests if the source address is unspecified",2,[],https://github.com/contiki-os/contiki/pull/1855,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1855#issuecomment-262687250,"No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .","@simonduq any feedback on this
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1855,2016-09-10T08:57:22Z,2016-12-08T19:08:59Z,2016-12-08T19:08:59Z,MERGED,True,23,29,2,https://github.com/MohamedSeliem,"DAD: Remove useless ""if"" that tests if the source address is unspecified",2,[],https://github.com/contiki-os/contiki/pull/1855,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1855#issuecomment-262796821,"No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .",looks good to me üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1855,2016-09-10T08:57:22Z,2016-12-08T19:08:59Z,2016-12-08T19:08:59Z,MERGED,True,23,29,2,https://github.com/MohamedSeliem,"DAD: Remove useless ""if"" that tests if the source address is unspecified",2,[],https://github.com/contiki-os/contiki/pull/1855,https://github.com/MohamedSeliem,4,https://github.com/contiki-os/contiki/pull/1855#issuecomment-263926065,"No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .",@nvt @simonduq any plans to merge this soon.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1855,2016-09-10T08:57:22Z,2016-12-08T19:08:59Z,2016-12-08T19:08:59Z,MERGED,True,23,29,2,https://github.com/MohamedSeliem,"DAD: Remove useless ""if"" that tests if the source address is unspecified",2,[],https://github.com/contiki-os/contiki/pull/1855,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1855#issuecomment-263931583,"No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .",see https://github.com/contiki-os/contiki/blob/master/CONTRIBUTING.md#pull-request-merging-policy,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1855,2016-09-10T08:57:22Z,2016-12-08T19:08:59Z,2016-12-08T19:08:59Z,MERGED,True,23,29,2,https://github.com/MohamedSeliem,"DAD: Remove useless ""if"" that tests if the source address is unspecified",2,[],https://github.com/contiki-os/contiki/pull/1855,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/1855#issuecomment-265826280,"No need to do the unspecified address twice.
if UIP_ND6_DEF_MAXDADNS > 0
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
   ..........

else /* UIP_ND6_DEF_MAXDADNS > 0 */
if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) {
  /* DAD CASE */
  goto discard; 

endif /* UIP_ND6_DEF_MAXDADNS > 0 */
this logic will bring confusion, especially when someone try to understand the implementation of other ND functions (NUD, address resolution)  .",Looks reasonable. üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1856,2016-09-12T03:27:53Z,2016-09-15T10:17:00Z,2016-09-15T10:17:01Z,CLOSED,False,0,0,0,https://github.com/yongli3,use the arm-none-eabi toolchain by default,0,[],https://github.com/contiki-os/contiki/pull/1856,https://github.com/yongli3,1,https://github.com/contiki-os/contiki/pull/1856,Signed-off-by: Yong Li sdliyong@gmail.com,Signed-off-by: Yong Li sdliyong@gmail.com,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1856,2016-09-12T03:27:53Z,2016-09-15T10:17:00Z,2016-09-15T10:17:01Z,CLOSED,False,0,0,0,https://github.com/yongli3,use the arm-none-eabi toolchain by default,0,[],https://github.com/contiki-os/contiki/pull/1856,https://github.com/yongli3,2,https://github.com/contiki-os/contiki/pull/1856#issuecomment-246236280,Signed-off-by: Yong Li sdliyong@gmail.com,"Since the InstantContiki does not include the arm-elf toolchain, we need to change it",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1857,2016-09-13T06:51:27Z,2016-09-14T05:52:02Z,2016-09-14T05:52:02Z,MERGED,True,1004,119,53,https://github.com/alignan,Zoul: RE-Mote revision B,7,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1857,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1857,"The new RE-Mote revision B is an update on the revision A, comprising improves in manufacturing and simplifications some of the RE-Mote features, like the power management block.  The revision B also exposes more pins in the side connectors, increasing the number of ADC channels available (shared with the microSD) with selectable resistors, etc.
A full list of the changes from revision A to B can be browsed in the Wiki page","The new RE-Mote revision B is an update on the revision A, comprising improves in manufacturing and simplifications some of the RE-Mote features, like the power management block.  The revision B also exposes more pins in the side connectors, increasing the number of ADC channels available (shared with the microSD) with selectable resistors, etc.
A full list of the changes from revision A to B can be browsed in the Wiki page",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1859,2016-09-13T13:40:28Z,2016-09-23T06:30:21Z,2016-09-23T06:30:23Z,MERGED,True,1162,143,53,https://github.com/alignan,Zoul: RTCC with trigger selection and second-based time increase,9,"['enhancement', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1859,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1859,"This PR adds two RTCC functionalities:

Allows to select which pin to trigger upon an interrupt (INT1 or INT2)
Allows to increment a date using seconds, useful to schedule an alarm interrupt

These features are used in the shutdown mode of the RE-Mote revision B (see #1857), which will be implemented in a next PR","This PR adds two RTCC functionalities:

Allows to select which pin to trigger upon an interrupt (INT1 or INT2)
Allows to increment a date using seconds, useful to schedule an alarm interrupt

These features are used in the shutdown mode of the RE-Mote revision B (see #1857), which will be implemented in a next PR",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1859,2016-09-13T13:40:28Z,2016-09-23T06:30:21Z,2016-09-23T06:30:23Z,MERGED,True,1162,143,53,https://github.com/alignan,Zoul: RTCC with trigger selection and second-based time increase,9,"['enhancement', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1859,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1859#issuecomment-249113391,"This PR adds two RTCC functionalities:

Allows to select which pin to trigger upon an interrupt (INT1 or INT2)
Allows to increment a date using seconds, useful to schedule an alarm interrupt

These features are used in the shutdown mode of the RE-Mote revision B (see #1857), which will be implemented in a next PR","Platform specific, merging üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1860,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859","This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1860#issuecomment-248384971,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859",Arrrgh the Doxygen warning is driving me crazy xD,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1860#issuecomment-248389526,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859","you might need to add these lines at the end of this file ""test-power-mgmt.c ""
/**

@}
@}
*/",True,{'THUMBS_UP': ['https://github.com/alignan']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1860#issuecomment-248732738,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859","You are right, I forgot about this... thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1860#issuecomment-248741732,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859","you are welcome.
i looked into the Doxygen build of this PR, ""ASSERT: ""tok==TK_WHITESPACE"" in ..\src\docparser.cpp (4718)""
i think this is a bug in Doxygen when doing this in the documented code:
/**

\exception \c text
*/
void foo();

so in my opinion you need to  remove all the ""\c"" commands from your comments, in the ""power-mgmt.h"" file, and i hope it will work this time.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1860#issuecomment-249012482,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859",Thanks again!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/MohamedSeliem,7,https://github.com/contiki-os/contiki/pull/1860#issuecomment-249014183,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859",I'm glad it worked out!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1860,2016-09-14T07:36:45Z,2016-09-23T06:30:56Z,2016-09-23T06:30:59Z,MERGED,True,959,27,13,https://github.com/alignan,Zoul: power management driver for the RE-Mote revision B,3,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1860,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1860#issuecomment-249113465,"This PR adds support for the RE-Mote revision B power management block, allowing to:

Measure the voltage level of external batteries connected to the RE-Mote via its nanowatt PIC
Shutdown mode: powers down the whole board (CC2538, CC1200, sensors, components, etc), but the nanowatt PIC and the RTCC, allowing to reduce the current draw to 150nA
Configures the shutdown mode's awake trigger: a soft shutdown using the nanowatt PIC's timer, or a hard shutdown by configuring first the RTCC, using its INT2 trigger
Read back the shutdown cycle counter, allowing the application space to trigger specific routines
Retrieve the firmware version of the nanowatt PIC

A test application is included to verify the shutdown operation.
Depends on #1859","Platform specific, merging üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1861,2016-09-15T10:20:00Z,,2016-09-15T10:20:00Z,OPEN,False,8,7,1,https://github.com/yongli3,use the arm-none-eabi toolchain by default,1,[],https://github.com/contiki-os/contiki/pull/1861,https://github.com/yongli3,1,https://github.com/contiki-os/contiki/pull/1861,"Since the InstantContiki does not include the arm-elf toolchain, we need to change it
Signed-off-by: Yong Li sdliyong@gmail.com","Since the InstantContiki does not include the arm-elf toolchain, we need to change it
Signed-off-by: Yong Li sdliyong@gmail.com",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/1863,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1863#issuecomment-250193677,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Cool! this is a nice sensor, I will test it on the RE-Mote and add support for it as well",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,3,https://github.com/contiki-os/contiki/pull/1863#issuecomment-250254460,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",Yes and bigger brother BME680 will come later with support for various gases. The application seems to indoor climate.  We're using SHT25 in some installations and can hopefully compare.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1863#issuecomment-250317146,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",There is an interesting comparisson here,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,5,https://github.com/contiki-os/contiki/pull/1863#issuecomment-251054316,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Hi,
Tried to address the issues in the last commits. Below is another sensor comparison.
Here",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1863#issuecomment-251055001,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",I just have received a BME280 from MikroElektronika so I will test shortly üòÑ,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,7,https://github.com/contiki-os/contiki/pull/1863#issuecomment-251055885,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",Excellent..,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,8,https://github.com/contiki-os/contiki/pull/1863#issuecomment-255339333,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Hello,
Did you have a chance to test yet?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1863#issuecomment-256567577,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Hello! I got the sensor and I'm to test now, sorry for the delay but October is the project-closure month, so bear with me through this hellish week üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,10,https://github.com/contiki-os/contiki/pull/1863#issuecomment-256603639,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",No problem with the delay. was just curios.. Take care.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1863#issuecomment-258105832,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Please check this pull request on top of you branch:
herjulf#1
It contains a platform-compliant implementation for the I2C, and some minor fixes.  I tested with the RE-Mote and it is working correctly using the standard API:
Contiki-3.x-2929-g07e7c08
Zolertia RE-Mote revision B platform
CC2538: ID: 0xb964, rev.: PG2.0, Flash: 512 KiB, SRAM: 32 KiB, AES/SHA: 1, ECC/RSA: 1
System clock: 16000000 Hz
I/O clock: 16000000 Hz
Reset cause: CLD or software reset
Rime configured with address 60:f3
 Net: Rime
 MAC: CSMA
 RDC: nullrdc
temperature = 25 humidity = 35 pressure = 10102
temperature = 25 humidity = 36 pressure = 10101
temperature = 25 humidity = 36 pressure = 10102

However I haven't tested for your platform, would you mind checking?
I rebased before committing thus the number of commits, sorry about that! üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,12,https://github.com/contiki-os/contiki/pull/1863#issuecomment-258438592,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.","Thanks, I'm traveling this week so I can't test. The changes could be addressed and nice to see the follow-up work. Cheers.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/herjulf,13,https://github.com/contiki-os/contiki/pull/1863#issuecomment-260138899,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",Tried to update according to the comments...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1863,2016-09-16T13:03:00Z,2016-11-30T10:57:45Z,2016-11-30T10:57:45Z,CLOSED,False,622,8,11,https://github.com/herjulf,Support for Bosch environmental sensor BME280,8,"['new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1863,https://github.com/alignan,14,https://github.com/contiki-os/contiki/pull/1863#issuecomment-263844866,"Contiki implementation of the Bosch Sensortec BME280 environmental sensor. BME280 is compact and fast and includes temp, RH, and pressure. The implementation follows the Contiki device API and uses I2C. This PR implements ""Weather Mode"" which uses forced one-shot mode no oversampling nor filters and reads all T/RH/P in one read. Implementation is  according to datasheet Rev 1.1.
The PR also updates examples/avr-rss2/hello-sensors/ to use the BME280.",Superseded by #1957,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1864,2016-09-17T06:18:56Z,2016-10-24T12:41:23Z,2016-10-24T12:41:23Z,MERGED,True,14,8,1,https://github.com/sumanpanchal,Wismote: Added support for Battery voltage measurement,1,[],https://github.com/contiki-os/contiki/pull/1864,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/1864,Have added Wismote battery voltage measurement support. Tested with test-battery.c example code and it works fine.,Have added Wismote battery voltage measurement support. Tested with test-battery.c example code and it works fine.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1864,2016-09-17T06:18:56Z,2016-10-24T12:41:23Z,2016-10-24T12:41:23Z,MERGED,True,14,8,1,https://github.com/sumanpanchal,Wismote: Added support for Battery voltage measurement,1,[],https://github.com/contiki-os/contiki/pull/1864,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1864#issuecomment-255729163,Have added Wismote battery voltage measurement support. Tested with test-battery.c example code and it works fine.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/yschroeder,1,https://github.com/contiki-os/contiki/pull/1866,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.","This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1866#issuecomment-248730459,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.",Cool! I can relate to the problems you found üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/yschroeder,3,https://github.com/contiki-os/contiki/pull/1866#issuecomment-252192213,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.",Have you reviewed the code? Do you think this can be merged?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1866#issuecomment-258381217,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.","Tested in Linux and works as intended üëç
Could someone test for OSX?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1866#issuecomment-258381427,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.",Probably it would make sense to rebuild the OS binaries before merging,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/yschroeder,6,https://github.com/contiki-os/contiki/pull/1866#issuecomment-258399109,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.","Yes, but the binaries should be built by a member of the project right? Also I cannot build or test for OS X.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1866#issuecomment-258401045,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.","I can build the linux one, but no OSX on my side either... perhaps @g-oikonomou?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/g-oikonomou,8,https://github.com/contiki-os/contiki/pull/1866#issuecomment-263888687,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.",It builds fine on El Capitan,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/g-oikonomou,9,https://github.com/contiki-os/contiki/pull/1866#issuecomment-263900809,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.","So I tested this with a Zolertia Firefly. I am getting identical behaviour with master and with this PR:
$ make login
using saved target 'zoul'
../../../tools/sky/serialdump-macos -b115200 /dev/tty.SLAB_USBtoUART
connecting to /dev/tty.SLAB_USBtoUART (115200) [OK]
??P???P???P?could not read: Device not configured
make: *** [login] Error 255

So as far as I'm concerned this doesn't break OS X, but it fixes other stuff so looks good.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1866,2016-09-20T12:40:16Z,2016-12-04T12:17:39Z,2016-12-04T12:17:39Z,MERGED,True,16,0,1,https://github.com/yschroeder,Improved serialdump.c,3,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/1866,https://github.com/alignan,10,https://github.com/contiki-os/contiki/pull/1866#issuecomment-263901336,"This PR fixes some issues we found when working with serialdump on our own Contiki fork.
First, it adresses the issue that serialdump sometimes injects newlines while running. This results from not configured c_iflag in terminos. Depending on your system it might be configured to replace carriage returns with newlines or vice versa. This results in excessive newlines in the terminal output and wrong output when transferring binary data. While at it I made sure to initialize all c_iflag values to make it work reproducible.
Second, it makes serialdump terminate when the serial device gets disconnected, e.g. when the USB cable is unplugged. The original behaviour was that serialdump runs indefinitely without recovering even when replugging the USB device.
Third, serialdump exits cleanly (returns 0) when terminated via SIGINT (ctrl-c). This is especially handy when used via make login as make will not assume anymore that the build failed.","I will rebuild the linux binary on a separate PR, so üëç  from me",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1867,2016-09-21T12:33:38Z,2016-11-30T15:37:49Z,2016-11-30T15:37:49Z,MERGED,True,1,0,1,https://github.com/MohamedSeliem,update uart1.c to include Special function registers bits definitions,1,[],https://github.com/contiki-os/contiki/pull/1867,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1867,"including ""sfr-bits.h"" to define PERCFG_U1CFG, and UCSR_MODE.","including ""sfr-bits.h"" to define PERCFG_U1CFG, and UCSR_MODE.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1867,2016-09-21T12:33:38Z,2016-11-30T15:37:49Z,2016-11-30T15:37:49Z,MERGED,True,1,0,1,https://github.com/MohamedSeliem,update uart1.c to include Special function registers bits definitions,1,[],https://github.com/contiki-os/contiki/pull/1867,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1867#issuecomment-262687131,"including ""sfr-bits.h"" to define PERCFG_U1CFG, and UCSR_MODE.","@simonduq any feedback on this
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1867,2016-09-21T12:33:38Z,2016-11-30T15:37:49Z,2016-11-30T15:37:49Z,MERGED,True,1,0,1,https://github.com/MohamedSeliem,update uart1.c to include Special function registers bits definitions,1,[],https://github.com/contiki-os/contiki/pull/1867,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1867#issuecomment-262795840,"including ""sfr-bits.h"" to define PERCFG_U1CFG, and UCSR_MODE.",can you explain why this is needed?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1867,2016-09-21T12:33:38Z,2016-11-30T15:37:49Z,2016-11-30T15:37:49Z,MERGED,True,1,0,1,https://github.com/MohamedSeliem,update uart1.c to include Special function registers bits definitions,1,[],https://github.com/contiki-os/contiki/pull/1867,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1867#issuecomment-262801748,"including ""sfr-bits.h"" to define PERCFG_U1CFG, and UCSR_MODE.",I'll have a look at this one. Self-assigning,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1867,2016-09-21T12:33:38Z,2016-11-30T15:37:49Z,2016-11-30T15:37:49Z,MERGED,True,1,0,1,https://github.com/MohamedSeliem,update uart1.c to include Special function registers bits definitions,1,[],https://github.com/contiki-os/contiki/pull/1867,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1867#issuecomment-262832547,"including ""sfr-bits.h"" to define PERCFG_U1CFG, and UCSR_MODE.","if you tried to use the uart1 of a cc2530, you will find 2 errors at compilation.
../../../cpu/cc253x/dev/uart1.c:34: error 20: Undefined identifier 'PERCFG_U1CFG'
../../../cpu/cc253x/dev/uart1.c:57: error 20: Undefined identifier 'UCSR_MODE'
because PERCFG_U1CFG, and UCSR_MODE are used without being defined.
PERCFG_U1CFG,  UCSR_MODE  are defined in the sfr-bits.h and used in configuring uart0.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1868,2016-09-21T17:35:43Z,2016-09-21T18:24:20Z,2016-09-21T18:24:20Z,CLOSED,False,55325,196,330,https://github.com/giatuyentiensinh,Nct contiki,10,[],https://github.com/contiki-os/contiki/pull/1868,https://github.com/giatuyentiensinh,1,https://github.com/contiki-os/contiki/pull/1868,this branch for nct laboratory on the HUST,this branch for nct laboratory on the HUST,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1869,2016-09-22T09:11:54Z,2016-09-22T10:26:11Z,2016-10-25T13:47:35Z,MERGED,True,13,6,1,https://github.com/nfi,Added support in Cooja to include Wismote and Z1 motes when exporting simulations,1,"['enhancement', 'Cooja']",https://github.com/contiki-os/contiki/pull/1869,https://github.com/nfi,1,https://github.com/contiki-os/contiki/pull/1869,Cooja lacked support for including Wismote and Z1 motes when exporting simulations as executable JAR files. Earlier Cooja only supported Tmote Sky motes and this PR adds support also for Wismote and Z1 motes.,Cooja lacked support for including Wismote and Z1 motes when exporting simulations as executable JAR files. Earlier Cooja only supported Tmote Sky motes and this PR adds support also for Wismote and Z1 motes.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1869,2016-09-22T09:11:54Z,2016-09-22T10:26:11Z,2016-10-25T13:47:35Z,MERGED,True,13,6,1,https://github.com/nfi,Added support in Cooja to include Wismote and Z1 motes when exporting simulations,1,"['enhancement', 'Cooja']",https://github.com/contiki-os/contiki/pull/1869,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1869#issuecomment-248864347,Cooja lacked support for including Wismote and Z1 motes when exporting simulations as executable JAR files. Earlier Cooja only supported Tmote Sky motes and this PR adds support also for Wismote and Z1 motes.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1870,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1870#issuecomment-248864497,,Cool! I will test and add a few things to the PR üòÑ,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249025418,,"In the CC1200 I had to increase the waiting time to swap back to RX up to i.e RTIMER_SECOND in earlier tests, I added something like:
#if CC1200_RF_CFG == cc1200_868_fsk_1_2kbps
    BUSYWAIT_UNTIL_STATE(STATE_RX, RTIMER_SECOND/2);
#else
    BUSYWAIT_UNTIL_STATE(STATE_RX, RTIMER_SECOND/100);
#endif",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249027339,,"I had to refactor the BUSYWAIT_UNTIL macro as:
#define BUSYWAIT_UNTIL(cond, max_time) \
  do { \
    rtimer_clock_t t0; \
    t0 = RTIMER_NOW(); \
    while(!(cond) && RTIMER_CLOCK_LT(RTIMER_NOW(), t0 + (max_time))) { \
      watchdog_periodic(); \
    } \
  } while(0)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249119865,,"#if CC1200_RF_CFG == cc1200_868_fsk_1_2kbps won't work unfortunately so we need to add one more field to cc1200_rf_cfg_t instead. What is this particular busy wait exactly waiting for? At first I thought we wanted to use tx_pkt_lifetime but no, as the packet transmission is already over when reaching there..",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249122386,,"I found out that it takes a bit longer to actually swap back to RX after transmitting a packet, enabling the interruptions earlier gave me some problems at that time, as we were returning the rf_flags ahead of time",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249123980,,"OK, I basically added a new field tx_rx_turnaround",True,{'HOORAY': ['https://github.com/alignan']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249163566,,üëç and merge as soon as you approve,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1870,2016-09-22T09:29:51Z,2016-09-23T11:13:26Z,2016-09-23T11:13:26Z,MERGED,True,157,20,5,https://github.com/simonduq,CC1200 added config for 1.2 kbps,5,['enhancement'],https://github.com/contiki-os/contiki/pull/1870,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1870#issuecomment-249165338,,thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1871,2016-09-22T14:55:52Z,2016-09-23T11:34:49Z,2016-09-23T11:34:49Z,MERGED,True,2,2,1,https://github.com/gkelly,rpl: fix debugging PRINTF in find_removable_dio,1,[],https://github.com/contiki-os/contiki/pull/1871,https://github.com/gkelly,1,https://github.com/contiki-os/contiki/pull/1871,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1871,2016-09-22T14:55:52Z,2016-09-23T11:34:49Z,2016-09-23T11:34:49Z,MERGED,True,2,2,1,https://github.com/gkelly,rpl: fix debugging PRINTF in find_removable_dio,1,[],https://github.com/contiki-os/contiki/pull/1871,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1871#issuecomment-249169122,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1873,2016-09-22T20:31:22Z,2016-09-23T06:31:41Z,2016-09-23T06:31:41Z,MERGED,True,5,5,1,https://github.com/MohamedSeliem,Doxygen Fix,1,[],https://github.com/contiki-os/contiki/pull/1873,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1873,"this minor fixation to avoid Doxygen bug, which appears when doing this in the documented code:
/**
/* \exception \c text
*/
void foo();","this minor fixation to avoid Doxygen bug, which appears when doing this in the documented code:
/**
/* \exception \c text
*/
void foo();",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1873,2016-09-22T20:31:22Z,2016-09-23T06:31:41Z,2016-09-23T06:31:41Z,MERGED,True,5,5,1,https://github.com/MohamedSeliem,Doxygen Fix,1,[],https://github.com/contiki-os/contiki/pull/1873,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1873#issuecomment-249113541,"this minor fixation to avoid Doxygen bug, which appears when doing this in the documented code:
/**
/* \exception \c text
*/
void foo();",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1874,2016-09-23T09:13:16Z,2016-09-28T15:01:19Z,2016-09-28T15:01:23Z,MERGED,True,488,0,6,https://github.com/alignan,Zoul: added new Firefly revision A,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1874,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1874,"This PR adds support for the new revision of the Firefly platform (namely revision A), it comprises more or less the same features as the Firefly, with a different pin-out, and the following improvements:

A USB type A connector instead of Micro-USB to directly connect to devices i.e Raspberry Pi, BeagleBone Black, USB hubs, etc
On-board 2.4GHz ceramic chip antenna
Compatible with 2xAA/AAA battery holders
Improvements in the RF impedance matching","This PR adds support for the new revision of the Firefly platform (namely revision A), it comprises more or less the same features as the Firefly, with a different pin-out, and the following improvements:

A USB type A connector instead of Micro-USB to directly connect to devices i.e Raspberry Pi, BeagleBone Black, USB hubs, etc
On-board 2.4GHz ceramic chip antenna
Compatible with 2xAA/AAA battery holders
Improvements in the RF impedance matching",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1874,2016-09-23T09:13:16Z,2016-09-28T15:01:19Z,2016-09-28T15:01:23Z,MERGED,True,488,0,6,https://github.com/alignan,Zoul: added new Firefly revision A,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1874,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1874#issuecomment-250193287,"This PR adds support for the new revision of the Firefly platform (namely revision A), it comprises more or less the same features as the Firefly, with a different pin-out, and the following improvements:

A USB type A connector instead of Micro-USB to directly connect to devices i.e Raspberry Pi, BeagleBone Black, USB hubs, etc
On-board 2.4GHz ceramic chip antenna
Compatible with 2xAA/AAA battery holders
Improvements in the RF impedance matching","Platform specific, merging üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1875,2016-09-25T00:41:57Z,2016-09-27T15:04:23Z,2016-09-27T15:04:23Z,MERGED,True,5,2,1,https://github.com/mdlemay,galileo: Omit DHCP code when IPv6 is enabled,1,[],https://github.com/contiki-os/contiki/pull/1875,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1875,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1875,2016-09-25T00:41:57Z,2016-09-27T15:04:23Z,2016-09-27T15:04:23Z,MERGED,True,5,2,1,https://github.com/mdlemay,galileo: Omit DHCP code when IPv6 is enabled,1,[],https://github.com/contiki-os/contiki/pull/1875,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1875#issuecomment-249892223,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1876,2016-09-26T15:41:10Z,2016-09-27T12:25:59Z,2016-09-27T12:53:47Z,CLOSED,False,1,0,1,https://github.com/naguirre,stf06-cc26xx: Enable input chars in serial input process for srf06-cc‚Ä¶,1,"['invalid', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1876,https://github.com/naguirre,1,https://github.com/contiki-os/contiki/pull/1876,‚Ä¶26xx platform,‚Ä¶26xx platform,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1876,2016-09-26T15:41:10Z,2016-09-27T12:25:59Z,2016-09-27T12:53:47Z,CLOSED,False,1,0,1,https://github.com/naguirre,stf06-cc26xx: Enable input chars in serial input process for srf06-cc‚Ä¶,1,"['invalid', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1876,https://github.com/naguirre,2,https://github.com/contiki-os/contiki/pull/1876#issuecomment-249849690,‚Ä¶26xx platform,Ok ! Make sense. Thanks for the info !,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1877,2016-09-28T14:55:58Z,2016-09-28T21:05:17Z,2016-09-28T21:05:20Z,MERGED,True,0,0,2,https://github.com/alignan,Zoul: updated pin-out images,1,"['documentation', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1877,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1877,"Zoul's back pin-out image was rotated and incorrect, fixing and adjusting both images to same pan-out","Zoul's back pin-out image was rotated and incorrect, fixing and adjusting both images to same pan-out",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1877,2016-09-28T14:55:58Z,2016-09-28T21:05:17Z,2016-09-28T21:05:20Z,MERGED,True,0,0,2,https://github.com/alignan,Zoul: updated pin-out images,1,"['documentation', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1877,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1877#issuecomment-250299390,"Zoul's back pin-out image was rotated and incorrect, fixing and adjusting both images to same pan-out",Merging üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/pernin,1,https://github.com/contiki-os/contiki/pull/1879,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1879#issuecomment-253208946,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.",I didn't get the point with instance->dio_intcurrent >= instance->dio_intmin + instance->dio_intdoubl: when is this supposed to happen and why do we want not to suppress in such case?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/pernin,3,https://github.com/contiki-os/contiki/pull/1879#issuecomment-253215095,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","Probably this condition can be seen as a forcing, but RFCs aren't fully clear.
I introduced this condition in my work (and so I have proposed it) after a lot of tests and observations on the network with a fairly large number of nodes (> 40).
If you don't want to set the default route lifetime to infinite (in this way the network can be more dynamic), but at the same time you want to use the DIO sending suppression (that in any case with the original condition can't be disabled), after some time the root stops to send its DIO (cause it receives DIOs from nodes) and when the default route lifetime expires the nodes remove their default route. In this case, they continue to send DIOs, and the root continues to receive DIOs: so the root will not send DIO anymore, and nodes will never know who is the root! Until the network contains a few nodes, this is not a problem, because the DIO sending suppression happens rarely, but if you have lot of nodes the suppression interveins very often!
The condition I've proposed plans to send a DIO in anycase when the DIO timer expires and the root has already reached the maximum of DIO timer doubling. So in this case we don't suppress the sending, but this happens very rarely (we are at the maximum of doubling!).
The other possible change is the increase of the threshold for the suppression, by multiplying it to the number of doubling (the longer the interval, the greater the number of received DIO). But this probably goes against RFC that talks about a ""constant"" for the threshold of the suppression.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1879#issuecomment-253216079,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","Sounds like a hack to me, and not rfc-compliant.
But I like the new condition instance->dio_redundancy == 0, this was definitely a bug.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/pernin,5,https://github.com/contiki-os/contiki/pull/1879#issuecomment-253220382,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","Probably it is so, but RFC aren't clear at all (RFC only talk about a ""k"" that is configured starting from DIORedundancyConstant).
In my opinion, remains the fact that in any case a mechanism to allow nodes to know the root after ending their default route lifetime is needed.
Thankyou for your feedback.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1879#issuecomment-253221353,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","To sum up, I will support this PR if it get simplified significantly:

single commit that fixes the case of redundancy == 0
no extra feature on dio_intcurrent nor the commented code",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262484457,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.",where are we on this?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/pernin,8,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262492172,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.",I'm using the changes I proposed on my network for over a month and I noticed good improvement in stability. I have not made any further changes to those proposed.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262494613,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","OK but this is not just a stability issue, but rather code style and standard compliance.
Are you intending to make the changes or not?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/pernin,10,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262498725,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","Yes, today I will change the code following your comment of 12 October. Sorry for the late

To sum up, I will support this PR if it get simplified significantly:
single commit that fixes the case of redundancy == 0
no extra feature on dio_intcurrent nor the commented code",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262615222,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","Great, thanks so much!
Would be awesome if you could squash all commits into a single one :) (interactive rebase followed by push -f)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/pernin,12,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262734927,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.",It's embarrassing but I could not run the interactive rebase! I used the git reset feature. Please check if it is all ok.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/simonduq,13,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262753335,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.","Thanks!
üëç setting timeout for merging",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1879,2016-09-30T08:15:25Z,2016-11-25T15:15:08Z,2016-11-25T15:15:08Z,MERGED,True,1,1,1,https://github.com/pernin,Change on DIO trickle timer condition for DIO sending,1,"['enhancement', 'RPL', 'timed out']",https://github.com/contiki-os/contiki/pull/1879,https://github.com/nvt,14,https://github.com/contiki-os/contiki/pull/1879#issuecomment-262976786,"The two changes are into the condition for the transmission of DIO. The third is commented in the code.

The first is to be compliant to the RFC6550 that says: ""In RPL, when k (i.e. DIORedundancyConstant) has the value of 0x00, this is to be treated as a redundancy constant of infinity in RPL, i.e., Trickle never suppresses messages). So, when the  instance->dio_redundancy is equal to 0, we can't suppress DIO transmission. This is the way to allow user to disable DIO suppression.
If we don't want to set the default route lifetime to infinite, in the case of a very large network (nodes > 40), there will be a high probability that instance->dio_counter is greater than instance->dio_redundancy. In this case the node will not send DIO anymore in the future (more so if this node is the root). So, other nodes will not receive anymore DIO from this node, and this node will be removed from the NB list. So, when we reach the maximum doubling of DIO interval, it is recommended to send DIO anyway to keep other nodes updated about this node.
Another possible change alternative to this is to multiply instance->dio_redundancy to the difference between actual interval and minimum interval (the longer the interval, the more numerous will be the received DIO... we can't keep the redundancy constant to a ""constant"" value!!!!).

In any case it is recommended to keep the RPL_CONF_DIO_REDUNDANCY high (>= nodes) when the network contains a large number of nodes.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1882,2016-10-03T12:09:26Z,2017-02-08T16:09:23Z,2017-02-08T16:12:42Z,CLOSED,False,23,1,1,https://github.com/kkrentz,OpenMote: Convenient flashing via OpenUSBs,1,[],https://github.com/contiki-os/contiki/pull/1882,https://github.com/kkrentz,1,https://github.com/contiki-os/contiki/pull/1882,"Using OpenUSBs (aka OpenBattery2), OpenMotes can now be flashed without enabling the bootloader backdoor manually. It works fine with these changes.","Using OpenUSBs (aka OpenBattery2), OpenMotes can now be flashed without enabling the bootloader backdoor manually. It works fine with these changes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1882,2016-10-03T12:09:26Z,2017-02-08T16:09:23Z,2017-02-08T16:12:42Z,CLOSED,False,23,1,1,https://github.com/kkrentz,OpenMote: Convenient flashing via OpenUSBs,1,[],https://github.com/contiki-os/contiki/pull/1882,https://github.com/zhitaoh,2,https://github.com/contiki-os/contiki/pull/1882#issuecomment-257871586,"Using OpenUSBs (aka OpenBattery2), OpenMotes can now be flashed without enabling the bootloader backdoor manually. It works fine with these changes.",This sounds very useful to me. But what is OpenUSB/OpenBattery2?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1882,2016-10-03T12:09:26Z,2017-02-08T16:09:23Z,2017-02-08T16:12:42Z,CLOSED,False,23,1,1,https://github.com/kkrentz,OpenMote: Convenient flashing via OpenUSBs,1,[],https://github.com/contiki-os/contiki/pull/1882,https://github.com/kkrentz,3,https://github.com/contiki-os/contiki/pull/1882#issuecomment-259445795,"Using OpenUSBs (aka OpenBattery2), OpenMotes can now be flashed without enabling the bootloader backdoor manually. It works fine with these changes.","They are not officially released, yet, but I happen to have prototypes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1882,2016-10-03T12:09:26Z,2017-02-08T16:09:23Z,2017-02-08T16:12:42Z,CLOSED,False,23,1,1,https://github.com/kkrentz,OpenMote: Convenient flashing via OpenUSBs,1,[],https://github.com/contiki-os/contiki/pull/1882,https://github.com/kkrentz,4,https://github.com/contiki-os/contiki/pull/1882#issuecomment-278372698,"Using OpenUSBs (aka OpenBattery2), OpenMotes can now be flashed without enabling the bootloader backdoor manually. It works fine with these changes.",Superseded by #2023,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1883,2016-10-03T14:00:58Z,2016-10-12T13:05:24Z,2016-10-12T13:05:24Z,MERGED,True,56,31,6,https://github.com/zhitaoh,fix comment with 6LoWPAN typo and break long lines,1,[],https://github.com/contiki-os/contiki/pull/1883,https://github.com/zhitaoh,1,https://github.com/contiki-os/contiki/pull/1883,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1883,2016-10-03T14:00:58Z,2016-10-12T13:05:24Z,2016-10-12T13:05:24Z,MERGED,True,56,31,6,https://github.com/zhitaoh,fix comment with 6LoWPAN typo and break long lines,1,[],https://github.com/contiki-os/contiki/pull/1883,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1883#issuecomment-253207666,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1885,2016-10-08T00:53:07Z,,2016-12-04T14:56:00Z,OPEN,False,175,113,11,https://github.com/arurke,Cc26xx/cc13xx generic I2C library,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1885,https://github.com/arurke,1,https://github.com/contiki-os/contiki/pull/1885,"This PR modify the existing sensortag-specific board-i2c library to become generic and move it to /common/i2c.[c|h]. Usage is similar as before, i.e. user must call i2c_select() before i2c operations and should call i2c_deselect() afterwards. Added possibility to specify bus speed: i2c_select() now requires SCL & SDA pin IOID, bus speed (normal or fast), slave address and pin pull (internal pull to set at shutdown/deselect).
Usage of underlying I2C functions has been mostly carried over from the board-specific version. As I don't feel 100 % confident on the TI I2C library any reviews are welcome - in particular i2c_deselect() which has a somewhat different approach than the previous version.
Updated sensortag sensors to use the new library. Also added i2c_write_single_read_multi() for reading registers, which is a common task - this could replace sensor_common_read_reg() in sensor-common.c.
Tested on cc2650 sensortag.","This PR modify the existing sensortag-specific board-i2c library to become generic and move it to /common/i2c.[c|h]. Usage is similar as before, i.e. user must call i2c_select() before i2c operations and should call i2c_deselect() afterwards. Added possibility to specify bus speed: i2c_select() now requires SCL & SDA pin IOID, bus speed (normal or fast), slave address and pin pull (internal pull to set at shutdown/deselect).
Usage of underlying I2C functions has been mostly carried over from the board-specific version. As I don't feel 100 % confident on the TI I2C library any reviews are welcome - in particular i2c_deselect() which has a somewhat different approach than the previous version.
Updated sensortag sensors to use the new library. Also added i2c_write_single_read_multi() for reading registers, which is a common task - this could replace sensor_common_read_reg() in sensor-common.c.
Tested on cc2650 sensortag.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1885,2016-10-08T00:53:07Z,,2016-12-04T14:56:00Z,OPEN,False,175,113,11,https://github.com/arurke,Cc26xx/cc13xx generic I2C library,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1885,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/1885#issuecomment-252427013,"This PR modify the existing sensortag-specific board-i2c library to become generic and move it to /common/i2c.[c|h]. Usage is similar as before, i.e. user must call i2c_select() before i2c operations and should call i2c_deselect() afterwards. Added possibility to specify bus speed: i2c_select() now requires SCL & SDA pin IOID, bus speed (normal or fast), slave address and pin pull (internal pull to set at shutdown/deselect).
Usage of underlying I2C functions has been mostly carried over from the board-specific version. As I don't feel 100 % confident on the TI I2C library any reviews are welcome - in particular i2c_deselect() which has a somewhat different approach than the previous version.
Updated sensortag sensors to use the new library. Also added i2c_write_single_read_multi() for reading registers, which is a common task - this could replace sensor_common_read_reg() in sensor-common.c.
Tested on cc2650 sensortag.","Thanks a lot @tonnenpinguin ! I made some changes to deselect() to make it consistent, simpler and a tiny bit more efficient.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1889,2016-10-15T21:41:03Z,2016-10-16T11:12:24Z,2016-10-16T11:12:24Z,MERGED,True,715,31,23,https://github.com/oliverschmidt,Several retrotarget changes,5,[],https://github.com/contiki-os/contiki/pull/1889,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/1889,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1895,2016-10-19T13:12:57Z,2016-10-28T21:42:18Z,2016-10-28T21:42:18Z,MERGED,True,2,2,2,https://github.com/alignan,cpu/cc2538: CCA threshold was fixed,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1895,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1895,Minor change to allow the CCA threshold to be overriden,Minor change to allow the CCA threshold to be overriden,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1895,2016-10-19T13:12:57Z,2016-10-28T21:42:18Z,2016-10-28T21:42:18Z,MERGED,True,2,2,2,https://github.com/alignan,cpu/cc2538: CCA threshold was fixed,1,"['enhancement', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1895,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1895#issuecomment-257035944,Minor change to allow the CCA threshold to be overriden,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1896,2016-10-19T13:49:22Z,2016-10-27T07:29:49Z,2016-10-27T07:29:51Z,MERGED,True,285,248,4,https://github.com/alignan,Renamed driver and reworked to support both TSL2561/TSL2563,1,"['enhancement', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1896,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1896,"This PR extends the existing light sensor driver to support both TSL2563 and TSL2561, the later one used in Seeedstudio's grove digital light sensor and currently tested.","This PR extends the existing light sensor driver to support both TSL2563 and TSL2561, the later one used in Seeedstudio's grove digital light sensor and currently tested.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1896,2016-10-19T13:49:22Z,2016-10-27T07:29:49Z,2016-10-27T07:29:51Z,MERGED,True,285,248,4,https://github.com/alignan,Renamed driver and reworked to support both TSL2561/TSL2563,1,"['enhancement', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1896,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1896#issuecomment-256567730,"This PR extends the existing light sensor driver to support both TSL2563 and TSL2561, the later one used in Seeedstudio's grove digital light sensor and currently tested.",Merging now üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1897,2016-10-19T16:35:07Z,2016-11-02T20:40:42Z,2016-11-02T20:40:42Z,MERGED,True,1,1,1,https://github.com/mdlemay,galileo: Shrink pinmux array,1,"['enhancement', 'x86']",https://github.com/contiki-os/contiki/pull/1897,https://github.com/mdlemay,1,https://github.com/contiki-os/contiki/pull/1897,"The pins array in galileo-gen2-pinmux.c:galileo_brd_to_cpu_gpio_pin is
unnecessarily large.  This patch reduces its size.","The pins array in galileo-gen2-pinmux.c:galileo_brd_to_cpu_gpio_pin is
unnecessarily large.  This patch reduces its size.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1897,2016-10-19T16:35:07Z,2016-11-02T20:40:42Z,2016-11-02T20:40:42Z,MERGED,True,1,1,1,https://github.com/mdlemay,galileo: Shrink pinmux array,1,"['enhancement', 'x86']",https://github.com/contiki-os/contiki/pull/1897,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1897#issuecomment-257992041,"The pins array in galileo-gen2-pinmux.c:galileo_brd_to_cpu_gpio_pin is
unnecessarily large.  This patch reduces its size.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,1,https://github.com/contiki-os/contiki/pull/1898,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1898#issuecomment-255364069,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,Sounds amazing! Will review whenever I find the time. One comment now: please check code style vs Contiki guidelines. Thanks :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,3,https://github.com/contiki-os/contiki/pull/1898#issuecomment-255530562,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,@simonduq  Updated the files and solved the build issues. Please let me know if any more modifications required.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1898#issuecomment-256636663,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"That's cool. I was about to look into 6P and SF0 when I saw your PR. :-)
I just noticed the mode bits (file permissions) of tsch.h have been changed somehow...

core/net/mac/tsch/tsch.h 100644 ‚Üí 100755",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,5,https://github.com/contiki-os/contiki/pull/1898#issuecomment-256712981,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,@yatch Thanks a lot for reviewing the code. Made the changes as suggested.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1898#issuecomment-257415754,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"Although I'm in the middle of reading your code, honestly, I think there is some room for improvement. I'll send a PR to your branch when it's ready....",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,7,https://github.com/contiki-os/contiki/pull/1898#issuecomment-257498540,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,@yatch Thanks for the reply. Kindly point out the areas for updation.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,8,https://github.com/contiki-os/contiki/pull/1898#issuecomment-257507887,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@shalurajendran From the point of view of structure, it seems sixtop does too many things. It has a Scheduling Function in it as well as the 6top processing. It would be better for sixtop to do only the 6top processing and to have more primitive APIs rather than sixtop_add_links() and sixtop_remove_link(). The Scheduling Function part could be defined separately as a SF implementation using sixtop APIs.
In addition, from the coding aspect, I saw some redundant code which, I guess, is result of copy-and-past from the existing code. For example, an assignment for nested_mlme_len is not necessary in the following code block which is a part of frame802154e_parse_information_elements() in frame802154e-ie.c. If you want to print the length of a 6top IE, you can refer to len directly instead. Another specific comment on this code block is that this case block could do more useful things than just debug printing, by the way.
          case PAYLOAD_IE_SIXTOP:
            /* Now expect 'len' bytes of Sixtop sub-IEs */
            nested_mlme_len = len;
            PRINTF(""frame802154e: entering Sixtop ie with len %u\n"", nested_mlme_len);
            return 0;     /* Sixtop IE detected, return success(0) */   
That's my two cents....",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,9,https://github.com/contiki-os/contiki/pull/1898#issuecomment-257777008,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@yatch Thank you. Now I got it.
The current version includes only sixtop implementation. The scheduling function decides when to add/delete cells based on its algorithm, this is not implemented right now.
Second one, as you suggested we could use the variable len itself. A new variable is not required since further parsing is done at sixtop layer.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,10,https://github.com/contiki-os/contiki/pull/1898#issuecomment-259477001,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@shalurajendran I've sent a PR to the branch, shalurajendran#1. It's eventually become a huge change... The PR aims to untangle 6P and a (sample) schedule function which reside in sixtop.c.
I can see the schedule function there. One of obvious parts is the code starting at L733 of sixtop.c. This block reads the CellList field values out of the buffer. However, the CellList field is defined to be opaque to 6P. In other words, 6P has no idea how to handle with the field. Here is an excerpt from draft-ietf-6tisch-6top-protocol-02.
CellList:  A list of 0, 1 or multiple 6P Cells.  The CellList is an
           opaque set of bytes, sent unmodified to the SF.  The
           RECOMMENDED format of each 6P Cell is defined in Section 4.2.5.
           The SF MAY redefine the format of the CellList field.

In my PR, your schedule function is implemented in sixtop-sf-simple.c. And, 6P message manipulation is done in sixtop-6p.c.
Regarding of redundant code, you will find in the PR what I thought was redundant, but I can give you another example here. From L133, the sixtop module builds an IEEE 802.15.4 frame to be sent. However, it doesn't necessarily have to do by itself. It can use APIs provided by the lower layer. In this case, it can use send_packet() of TSCH, instead.
By the way, you code helped me understand 6P deeply! Thanks a lot :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,11,https://github.com/contiki-os/contiki/pull/1898#issuecomment-259679177,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@yatch  Good work!!! Seems more change...
Need to go through in detail and will get back...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262472907,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"I left some comments at shalurajendran#1
Please ping me when this is merged so I can do a full review of this PR!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,13,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262474821,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@simonduq Thanks! I'll check your comments soon!!
It's still at the ""work-in-progress"" stage. For example, it doesn't have the schedule generation management as you noticed. I'll push other changes made in the local repo if @shalurajendran  is happy for the structural changes. :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,14,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262761009,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@simonduq Thanks for the inputs...
Surely will let you know once it is done.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,15,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262764078,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@yatch Ofcourse, happy to merge your PR.;)
A few suggestions :


For more readability, it would be better to use either ‚Äúcell‚Äù or ‚Äúlink‚Äù in function and variable names. May be we could use ‚Äúlink‚Äù, since it is already been utilized for TSCH implementation. Similarly for the case of ‚Äúdelete‚Äù / ‚Äùremove‚Äù.


The keywords listed below may be replaced as referred in the draft 6top-protocol-01.
PAYLOAD_IE_IANA_IETF  	 ->  	IANA_IETF_IE_GROUP_ID
SIXTOP_6P_SUBIE_ID		->	IANA_6TOP_SUBIE_ID
SIXTOP_6P_VERSION		->	IANA_6TOP_6P_VERSION


The add and delete functions in the structure of sixtop_sf_t may be referred as given in sixtop-sf-simple.c, to avoid confusion


A small typo at line 506 of sixtop.c.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/simonduq,16,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262766484,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"For context: link is used in IEEE 802.15.4-2015, while cell is used in IETF 6TiSCH. Not sure what is the best option in our case, maybe stick to link in TSCH and cell in 6TiSCH?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,17,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262775332,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@shalurajendran Thanks  for the comments.
With regard to link/cell, I'm in favor of using ""cell"" there, in 6TiSCH, and using ""link"" in TSCH as the latter one in @simonduq comment.
Another thing is IANA_ prefix. I guess this prefix will be gone when values for the constants are assigned by IANA. So, I'd keep them without ""IANA_"" prefix.
I'll make some updates.... hopefully soon...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,18,https://github.com/contiki-os/contiki/pull/1898#issuecomment-262865089,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"Ok, we could fix it to be ""cell"" for sixtop files.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/shalurajendran,19,https://github.com/contiki-os/contiki/pull/1898#issuecomment-263533720,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,@yatch Please find the modified Copyright statement and update the files.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1898,2016-10-21T11:48:44Z,,2016-11-30T06:36:29Z,OPEN,False,1655,15,12,https://github.com/shalurajendran,Contiki-6top : Added 6top (6TiSCH Operation Sublayer) Implementation ,22,[],https://github.com/contiki-os/contiki/pull/1898,https://github.com/yatch,20,https://github.com/contiki-os/contiki/pull/1898#issuecomment-263533923,Handles 2-step 6top transaction on a basic RPL + TSCH network. The current implementation supports dynamic cell negotiation (addition/deletion) with one-hop neighbor. Tested working with Z1 platform on Cooja simulator using the example code node-sixtop.c (examples/ipv6/rpl-tsch-sixtop/).,"@shalurajendran OK, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1903,2016-10-25T09:40:47Z,2016-10-25T11:23:43Z,2016-10-25T12:47:51Z,MERGED,True,1,1,1,https://github.com/morphal,Fixed debug PRINTF definition in mqtt client,1,[],https://github.com/contiki-os/contiki/pull/1903,https://github.com/morphal,1,https://github.com/contiki-os/contiki/pull/1903,Fixed copy-paste typo in debug PRINTF definition of mqtt client,Fixed copy-paste typo in debug PRINTF definition of mqtt client,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/darbyShaw,1,https://github.com/contiki-os/contiki/pull/1904,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/kkrentz,2,https://github.com/contiki-os/contiki/pull/1904#issuecomment-256555916,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","Apparently, these changes conflict with mine. In #880, I adapted the framer_802154 to also parse and create beacon frames. In #1703, I added support for processing command frames.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/ENIGH,3,https://github.com/contiki-os/contiki/pull/1904#issuecomment-257773741,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","Hello
I search to make a small example by beacon just transmission and reception how can i do that please?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/hxyzha,4,https://github.com/contiki-os/contiki/pull/1904#issuecomment-258084011,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","Hi,
Please in #250  ( powerSource) did it give as the power level in the node please ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/kkrentz,5,https://github.com/contiki-os/contiki/pull/1904#issuecomment-259449700,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","@ENIGH for creating beacon frames you can do something like this:
packetbuf_clear();
packetbuf_set_attr(PACKETBUF_ATTR_FRAME_TYPE, FRAME802154_BEACONFRAME);
/* set further packetbuf attributes */
/* write payload */
paketbuf_set_datalen(x);
NETSTACK_LLSEC.send(NULL, NULL);
For processing beacon frames, you can insert some code into nullsec.c:
if(packetbuf_attr(PACKETBUF_ATTR_FRAME_TYPE) == FRAME802154_BEACONFRAME) {
  /* process beacon frame */
}
Processing command frames is more convenient thanks to my cmd-broker.c. In akes.c, you can see how I send and receive command frames.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/ENIGH,6,https://github.com/contiki-os/contiki/pull/1904#issuecomment-260248384,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","@kkrentz
Thanks sir but how can i exploit it with an examples ?
I would make an example in which PAN send beacon frame in which it gives SO and BO value to other node of network  that is what i search",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/kkrentz,7,https://github.com/contiki-os/contiki/pull/1904#issuecomment-260274133,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","Sorry, but I do not understand what you want exactly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/ENIGH,8,https://github.com/contiki-os/contiki/pull/1904#issuecomment-260284266,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","@kkrentz
At first step i want that PANcoor send BO and SO value in the beacon frame to other node
https://github.com/contiki-os/contiki/pull/1904/files#diff-a5c6067d8fa8e56903d7e037399ce294R657
https://github.com/contiki-os/contiki/pull/1904/files#diff-a5c6067d8fa8e56903d7e037399ce294R658
10a2bce#diff-1d8138bcf9107b0b4f3ebc91a5402fc2R201
10a2bce#diff-1d8138bcf9107b0b4f3ebc91a5402fc2R202
At the secont step other node wil receive this BO and SO and i will see its effects at the powertrace",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1904,2016-10-25T14:00:00Z,,2016-11-23T10:57:33Z,OPEN,False,207,4,2,https://github.com/darbyShaw,Creation and Parsing of 802.15.4 Beacon and Command frames.,2,[],https://github.com/contiki-os/contiki/pull/1904,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1904#issuecomment-262484286,"The following code changes cater to the creation and parsing
of 802.15.4 beacon and command frames.","Hello,
Please make sure the code complies with https://github.com/contiki-os/contiki/blob/master/doc/code-style.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1905,2016-10-25T15:16:34Z,2016-10-26T11:12:47Z,2016-10-26T11:12:47Z,MERGED,True,3,0,3,https://github.com/nfi,Fixed compiler warnings for CC2538-based platforms,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1905,https://github.com/nfi,1,https://github.com/contiki-os/contiki/pull/1905,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1905,2016-10-25T15:16:34Z,2016-10-26T11:12:47Z,2016-10-26T11:12:47Z,MERGED,True,3,0,3,https://github.com/nfi,Fixed compiler warnings for CC2538-based platforms,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1905,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1905#issuecomment-256167582,,"Regarding the first commit, there is indeed an issue, but putting #ifs everywhere is the wrong way of handling this. The root cause of these warnings is the way the LPM functions are disabled in lpm.h. See #1906.
Regarding the second commit, did you actually get warnings or anything wrong? This change does not seem to be required, maybe because <string.h> is already #included somewhere in the other #includes, but I agree that the code is cleaner with it because of the calls to memcpy() and the like.
So if you drop your first commit, I'd be glad to merge this PR with only the second commit, and we'll use #1906.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1905,2016-10-25T15:16:34Z,2016-10-26T11:12:47Z,2016-10-26T11:12:47Z,MERGED,True,3,0,3,https://github.com/nfi,Fixed compiler warnings for CC2538-based platforms,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1905,https://github.com/nfi,3,https://github.com/contiki-os/contiki/pull/1905#issuecomment-256172951,,"Nice way of solving the LPM issue in #1906. I have removed the first commit.
For the second remaining commit, I got warnings in another CC2538 based platform I am working on about memcpy. But it is not a big issue and it can be avoided by including string.h globally in the platform contiki-conf.h. So whatever you would prefer. It was the LPM issue I really wanted solved.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1905,2016-10-25T15:16:34Z,2016-10-26T11:12:47Z,2016-10-26T11:12:47Z,MERGED,True,3,0,3,https://github.com/nfi,Fixed compiler warnings for CC2538-based platforms,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1905,https://github.com/bthebaudeau,4,https://github.com/contiki-os/contiki/pull/1905#issuecomment-256193143,,"üëç Thanks. Waiting for Travis to pass, and you'll be all set.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1906,2016-10-25T20:27:22Z,2016-10-31T20:38:16Z,2016-10-31T20:38:22Z,MERGED,True,12,5,1,https://github.com/bthebaudeau,cc2538: lpm: Fix build warnings with LPM_CONF_ENABLE == 0,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1906,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1906,"Some arguments passed to the functions disabled with LPM_CONF_ENABLE == 0 could trigger build warnings because they became unused with this configuration option. Disable these functions by using empty static inline functions instead of empty macros, so that the function arguments are always considered by the compiler as used, without having to #if-out code in many places.","Some arguments passed to the functions disabled with LPM_CONF_ENABLE == 0 could trigger build warnings because they became unused with this configuration option. Disable these functions by using empty static inline functions instead of empty macros, so that the function arguments are always considered by the compiler as used, without having to #if-out code in many places.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1906,2016-10-25T20:27:22Z,2016-10-31T20:38:16Z,2016-10-31T20:38:22Z,MERGED,True,12,5,1,https://github.com/bthebaudeau,cc2538: lpm: Fix build warnings with LPM_CONF_ENABLE == 0,1,['Platform / CPU / ARM / CC2538'],https://github.com/contiki-os/contiki/pull/1906,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1906#issuecomment-257413556,"Some arguments passed to the functions disabled with LPM_CONF_ENABLE == 0 could trigger build warnings because they became unused with this configuration option. Disable these functions by using empty static inline functions instead of empty macros, so that the function arguments are always considered by the compiler as used, without having to #if-out code in many places.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1911,2016-10-27T22:28:51Z,,2016-12-15T10:19:51Z,OPEN,False,5,2,1,https://github.com/tussock-cam,CC13xx/CC26xx Check GPIO interrupt is enabled before calling its handler,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1911,https://github.com/tussock-cam,1,https://github.com/contiki-os/contiki/pull/1911,"I have an interrupt that I enable/disable as necessary, but with my test setup the pin is always receiving the edges that would generate an interrupt if enabled. When I press a button (which has its interrupt enabled), the interrupt handler checks the event flags and calls all interrupts with active events. Because my edge events happen so frequently (~10 kHz) it will sometimes mark my disabled interrupt as having an event, and so its handler will be called.
This pull request checks that the interrupt is actually enabled before calls its handler.","I have an interrupt that I enable/disable as necessary, but with my test setup the pin is always receiving the edges that would generate an interrupt if enabled. When I press a button (which has its interrupt enabled), the interrupt handler checks the event flags and calls all interrupts with active events. Because my edge events happen so frequently (~10 kHz) it will sometimes mark my disabled interrupt as having an event, and so its handler will be called.
This pull request checks that the interrupt is actually enabled before calls its handler.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/nenadilic84,1,https://github.com/contiki-os/contiki/pull/1913,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.","Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1913#issuecomment-257181160,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.",Thanks @nenadilic84 for the PR! I will begin to review shortly,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/nenadilic84,3,https://github.com/contiki-os/contiki/pull/1913#issuecomment-257804593,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.","@alignan, thanks a lot for the feedback. I'll start addressing the issues.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1913#issuecomment-258372952,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.","Cool!  working now üòÑ
016-11-04 09:34:51,100 - Thread-1   - coapthon.client.coap - DEBUG - send_datagram - From None, To ('aaaa::212:4b00:60d:60f3', 5683), CON-23680, PUT-None, [Uri-Path: firmware, Content-Type: 42, Block1: 13058, ] ...0 bytes
2016-11-04 09:34:51,113 - Thread-1   - coapthon.layers.messagelayer - DEBUG - receive_response - From ('aaaa::212:4b00:60d:60f3', 5683), To None, ACK-23680, BAD_REQUEST-None, [] NoPayload...9 bytes
Dveice secefully updated",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/jamesmunns,5,https://github.com/contiki-os/contiki/pull/1913#issuecomment-262432821,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.","@nenadilic84 @alignan updated the relayr base with @nenadilic84 's newest changes.
Please feel free to ping me directly if you need another refresh :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1913#issuecomment-263845359,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.","Hello! thanks @jamesmunns for the update üòÑ
I'm currently refactoring the PR to allow using different wrappers (UDP, MQTT, etc), I will publish my changes on top of this PR for your review as well.
Cheers!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1913,2016-10-28T16:18:29Z,,2017-01-30T03:15:15Z,OPEN,False,843,0,12,https://github.com/nenadilic84,Zoul-OTA-Firmware-Update: Initial add,2,"['nominated', 'new feature', 'Platform / CPU / ARM / CC2538', 'tools']",https://github.com/contiki-os/contiki/pull/1913,https://github.com/sonvoque,7,https://github.com/contiki-os/contiki/pull/1913#issuecomment-275972268,"Hi,
the PR adds an example on how the OTA firmware update can be performed using CoAP as an application protocol. It has been tested on Zoul's RE-Mote board, but the same should apply on any CC2538 MCU. This also can be a conversation started on how to make a generic OTA for contiki in the future.
Any feedback is highly appreciated.",cool. It should be nice if this can be merged to Contiki OS master,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1914,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1914#issuecomment-260217073,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","This seems sensible to me at first glance. I'll have to read the references provided here, but perhaps @simonduq @nvt can comment?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1914#issuecomment-262484022,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","Thanks, looks good, except for the src_pan_id statement which is really hard to maintain. See comment.
Also, great that you provide a unit test. Would be awesome if you could add it to Travis (automated tests directly from github)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1914#issuecomment-262485659,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","OK, I'll try the Travis thing; in that case, I should move the test code under the regression-test directory, shouldn't I? Which directory is the best to put them? Or better to create a new one with a name like ""25-ieee802154""? Hmm, there are two directories which have ""23-"" prefix. These numbers may have some meanings...?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1914#issuecomment-262494219,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","No meaning in the numbers, this is just for ordering. The duplicate 23 is a mistake, probably from two PRs that were issued and merged concurrently. We should fix this.
For yours, I would add ""25-ieee802154 yes! Thanks :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1914#issuecomment-262577662,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","I've updated this PR:

addressed the comment by @simonduq ; rewrote the src_pan_id statement
moved the unit-test under the regression-tests directory, refined it to be executed by Cooja, and made the test done by Travis

I did several force-pushes over a short time; they may have bothered you.... Sorry about that...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1914#issuecomment-262616223,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>",Excellent! üëç for me (assuming Travis passes),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1914#issuecomment-262795573,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>",setting timeout for merging,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/nvt,9,https://github.com/contiki-os/contiki/pull/1914#issuecomment-264927390,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>",Nice to see such a complete PR with references and a unit test! Could you clarify whether the changed behavior is intended for the same frame version as the previous code? Now the 802.15.4-2015 table is applied when fcf->frame_version == FRAME802154_IEEE802154E_2012.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1914#issuecomment-264953063,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","My two cents would be that we keep FRAME802154_IEEE802154E_2012 as version 0b10, because the version was introduced in 15.4e-2012. Now 15.4-2015 added some fixes, but the frame version is still 0b10.
@yatch what do you think?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/yatch,11,https://github.com/contiki-os/contiki/pull/1914#issuecomment-264999163,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>","@nvt Thanks for the comment. I added some text to the commit log for the clarification (and rebased). Table 7-2 of IEEE 802.15.4-2015 that was referred in the code is for frame version 0b10, which is the value of  FRAME802154_IEEE802154E_2012. ""IEEE 802.15.4-2015"" in the phrase of ""Table 7-2 of IEEE 802.15.4-2015"" is not the frame version but something like document version. It may be confusing.
@simonduq Speaking of FRAME802154_IEEE802154E_2012, I agree with you; keeping it as it is in this PR.
As a matter of fact, I was about to change it to FRAME802154_IEEE802154 or FRAME802154_IEEE802154_2015 to see Table 7-4 of IEEE 802.15.4-2015 which provides the summary of frame versions: ""IEEE Std 802.15.4-2003"", ""IEEE Std 802.15.4-2006"", and ""IEEE 802.15.4."" But, on second thought, I did not. I thought it needs a separate discussion on changing FRAME802154_IEEE802154E_2012 in the community.
FRAME802154_IEEE802154E_2012 has no practical issue, by the way  :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1914,2016-10-31T15:23:01Z,2016-12-08T17:37:59Z,2016-12-08T17:43:01Z,MERGED,True,530,12,9,https://github.com/yatch,frame802154: comply with IEEE 802.15.4-2015 on PAN ID Field Handling,2,"['enhancement', 'Core', 'timed out', 'Network']",https://github.com/contiki-os/contiki/pull/1914,https://github.com/nvt,12,https://github.com/contiki-os/contiki/pull/1914#issuecomment-265803357,"Summary
frame802154_has_panid()  is not fully compliant with IEEE 802.15.4-2015 [1] for frames of the frame version 0b10. This is because the current implementation is based on Table 2a in IEEE 802.15.4e-2012 [2], which ""cannot specify all aspects of how the PAN ID Compression field is to be used"", according to a document [3].
For example, in the case where the source address is an extended address, the destination is a short address, and the PAN ID Compression is 0, the Source PAN ID is present as per IEEE 802.15.4-2015. On the other hand, as per IEEE 802.15.4e-2012, the Source PAN ID is not present, which is the case where the Source address is present, the Destination address is present, and PAN ID Compression is 0.
This PR aims for rewriting frame802154_has_panid() with reference to Table 7-2 of IEEE 802.15.4-2015.
This is related to #1723.
[1] IEEE 802.15.4-2015 https://standards.ieee.org/findstds/standard/802.15.4-2015.html
[2] IEEE 802.15.4e-2012 https://standards.ieee.org/findstds/standard/802.15.4e-2012.html
[3] Proper PAN ID Field Settings for 802.15.4-2015: https://mentor.ieee.org/802.15/dcn/15/15-15-0911-01-0mag-proper-pan-id-field-settings-for-802-15-4-2015.docx
Notice
This may affect interopeability with previous versions of Contiki, although keeping the current implementation could cause an issue on communication with an other implementation.
Test
The test code has moved under ""regression-tests/25-ieee802154/"".  You can run the test as follows:
$ cd regression-tests/25-ieee802154
$ make
Running test 01-panid-handling with random Seed 1: ...... OK
The following information is obsolete:
<obsolete>
With examples/unit-test/frame802154, you can test frame802154_has_panid(). Run make under the directory. You'll have an executable file named test.native.
Here is the result of test.native with the current implementation of 'frame802154_has_panid()`:
$ ./test.native
Contiki-3.x-2925-g672d603 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
........E
FAILED   - PAN ID Cmpr Handing (frame-ver: 0b10): at test index 8
After applying the patch, the test called ""PAN ID Cmpr Handing (frame-ver: 0b10)"" passed.
$ ./test.native
Contiki-3.x-2928-ge68a530 started with IPV6, RPL
Rime started with address 1.2.3.4.5.6.7.8
MAC nullmac RDC nullrdc NETWORK sicslowpan
Tentative link-local IPv6 address fe80:0000:0000:0000:0302:0304:0506:0708
Run unit-test

---
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b00)
............
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b01)
..................
SUCEEDED - PAN ID Cmpr Handing (frame-ver: 0b10)

</obsolete>",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1917,2016-11-01T08:16:57Z,2016-11-01T08:18:32Z,2016-11-01T08:19:32Z,CLOSED,False,61901,79,231,https://github.com/IOTWSN,Iot workshop,30,[],https://github.com/contiki-os/contiki/pull/1917,https://github.com/IOTWSN,1,https://github.com/contiki-os/contiki/pull/1917,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1917,2016-11-01T08:16:57Z,2016-11-01T08:18:32Z,2016-11-01T08:19:32Z,CLOSED,False,61901,79,231,https://github.com/IOTWSN,Iot workshop,30,[],https://github.com/contiki-os/contiki/pull/1917,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1917#issuecomment-257511539,,This is a branch from my fork not likely to be merged,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/adamdunkels,1,https://github.com/contiki-os/contiki/pull/1918,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/adamdunkels,2,https://github.com/contiki-os/contiki/pull/1918#issuecomment-257996498,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","@alignan : pushed a bunch of fixes to your comments - didn't squash the commits, to make it easier to see them as separate commits, but will rebase once reviewed and ready for merge.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/joakimeriksson,3,https://github.com/contiki-os/contiki/pull/1918#issuecomment-257997900,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.",quick question - is there a reason not to put the websocket code as an app - similar to er-coap and other higher layer protocols (otherwise - very nice new feature!)?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/adamdunkels,4,https://github.com/contiki-os/contiki/pull/1918#issuecomment-257998884,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","Not really, except that the websocket protocol isn't really meant to be used on its own, unlike coap and friends. It always needs something running on top of it. So in that sense it is almost a transport protocol, so makes sense to put it next to the other transport protocols. But there is no really strong reason either way.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1918#issuecomment-257999732,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","Yes, true. But even CoAP needs something on top - like LWM2M or some kind of JSON formats - but I agree - web socket is very similar to plain TCP in a sense - just better att sneaking through firewalls.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1918#issuecomment-258010978,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/1918#issuecomment-263018196,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.",ping?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/joakimeriksson,8,https://github.com/contiki-os/contiki/pull/1918#issuecomment-263702960,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.",I would suggest using the 30-days single merger rule here - to get the code in even if these fairly minor issues are not fixed. Otherwise it might be stuck for a while which to me would be sad. I would like to make use of the code myself ;-). From what I can see it will not break any already existing functionality.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1918#issuecomment-263704910,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","My requests were addressed so I'm happy as it is, but I was waiting for comments on #1918 (review), but yeah let's set a timeout and move this further.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/g-oikonomou,10,https://github.com/contiki-os/contiki/pull/1918#issuecomment-264706871,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","We want to be merging this one folks, I have not looked at it closely but it strikes me as though most comments have been addressed @alignan ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1918#issuecomment-264738717,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","My comments were addressed, yes... but curious about #1918 (review)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/g-oikonomou,12,https://github.com/contiki-os/contiki/pull/1918#issuecomment-264738828,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","I think it may have merit, but I think this is too major a feature to keep on hold till it gets addressed, plus it can be addressed by others. I say üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1918,2016-11-02T14:15:08Z,2016-12-05T05:46:43Z,2016-12-05T05:46:43Z,MERGED,True,1494,4,10,https://github.com/adamdunkels,Contiki websocket client,11,"['timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1918,https://github.com/alignan,13,https://github.com/contiki-os/contiki/pull/1918#issuecomment-264772550,"This PR adds support for the websocket protocol (RFC 6455).
The websocket protocol is a lightweight framing protocol that runs over HTTP or HTTPS that allows maintaining an active connection over an HTTP/HTTPS transaction. The protocol is primarily intended as a way to communicate between a web browser and a web server, but because it runs over the standard HTTP/HTTPS protocol, it can pass through most firewalls and even many HTTP/HTTPS proxies. Websocket server software exists for most server-side frameworks such as node.js.
The intended use case for this code is for a device behind a Contiki ip64 NAT gateway to connect to a server on the Internet. It only works with IPv6 and if a client asks to connect to an IPv4 address, the code converts it to an IPv6 address to make it pass through the ip64 gateway. The Thingsquare system uses this code to connect to mesh devices to a backend server in the cloud.
This PR adds:

Websocket client code, with support for sending and receiving data, custom HTTP/HTTPS headers (e.g. for sending cookies), user-supplied websocket subprotocols, per-request configurable port numbers, multiple len bytes, ping/pong opcodes, binary and text message formats, connection to URLs with either a direct IP address or a hostname. The code works well even if the websocket frames are split across multiple TCP segments.
Support for going through CONNECT-proxies.
Pluggable HTTP/HTTPS clients, with the HTTP client included in this PR.
Contiki client example code.
Really tiny node.js example websocket server code example.
Small bug fix to the tcp-socket.c code.","Ok, agree... This could be addressed in a future PR üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/cquijano,1,https://github.com/contiki-os/contiki/pull/1919,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.","This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258002593,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.",I thought support for iBeacons required royalties paid to Apple. Has this changed?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/adamdunkels,3,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258003835,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.","Apple are being Apple:y about everything, including the iBeacon brand. It is possible to send BLE beacons with a format that matches that of Apple's iBeacons, but who knows what Apple will do if you do. In any case, iBeacons haven't really picket up much traction. There are alternative BLE beacon formats that aren't as locked down as Apple's, such as @scottjenson's Eddystone format (https://github.com/google/eddystone).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/scottjenson,4,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258033768,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.",Please let me know what you were trying to do with iBeacon support and if it makes sense to add Physical Web support as well. I can see how broadcasting and receiving Eddystone-URL packets with Contiki could be useful. We have lots of sample implementations over at our repo,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/cquijano,5,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258297706,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.","You can ignore this pull request, I added support for Eddystone-UID beacons on new pull request #1921",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/scottjenson,6,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258315676,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.",Any reason you didn't add Eddystone-URL while you were at it? It's no more work.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/cquijano,7,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258396966,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.","At this point, I only need the Eddystone-UID Beacon for our application. I know that have Eddystone-URL could be interesting if I have time I will  do it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1919,2016-11-02T20:51:43Z,2016-11-05T17:39:37Z,2018-08-16T09:39:31Z,CLOSED,False,57,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add iBeacon support,2,[],https://github.com/contiki-os/contiki/pull/1919,https://github.com/g-oikonomou,8,https://github.com/contiki-os/contiki/pull/1919#issuecomment-258628787,"This commit add support for iBeacons
To enable it, you must define:
#define IBEACON_CONF_ENABLED     1
#define IBEACON_CONF_UUID { 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF }

Of course with a valid UUID.","I'm closing this
#1921",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1920,2016-11-03T13:52:05Z,,2016-11-04T09:46:08Z,OPEN,False,109,3,3,https://github.com/alignan,zoul/remote-revb: initialize unused pins to minimize current draw (WIP),1,"['enhancement', 'work-in-progress', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1920,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1920,"This is a work in progress to reduce the current draw from pins not used, please feel free to drop any comment or suggestion!
Testing with the examples/zolertia/zoul/zoul-demo with the following changes:

NETSTACK_MAC.off(1); in L128 commented out
PROCESS_YIELD(); in L145 changed to PROCESS_WAIT_EVENT_UNTIL(0)
NullRDC commented out in project-conf.h

So far in PM2 the current drops from 2.73mA to 0.672mA, but some work is still required.  There is around 500uA consumed by the XTAL oscillator (32KHz), as gatting the pads reduces the current consumption to 50uA.  Dropping to PM3 yields around 32uA.
The values are measured on the battery input of the RE-Mote.","This is a work in progress to reduce the current draw from pins not used, please feel free to drop any comment or suggestion!
Testing with the examples/zolertia/zoul/zoul-demo with the following changes:

NETSTACK_MAC.off(1); in L128 commented out
PROCESS_YIELD(); in L145 changed to PROCESS_WAIT_EVENT_UNTIL(0)
NullRDC commented out in project-conf.h

So far in PM2 the current drops from 2.73mA to 0.672mA, but some work is still required.  There is around 500uA consumed by the XTAL oscillator (32KHz), as gatting the pads reduces the current consumption to 50uA.  Dropping to PM3 yields around 32uA.
The values are measured on the battery input of the RE-Mote.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1920,2016-11-03T13:52:05Z,,2016-11-04T09:46:08Z,OPEN,False,109,3,3,https://github.com/alignan,zoul/remote-revb: initialize unused pins to minimize current draw (WIP),1,"['enhancement', 'work-in-progress', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1920,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1920#issuecomment-258160384,"This is a work in progress to reduce the current draw from pins not used, please feel free to drop any comment or suggestion!
Testing with the examples/zolertia/zoul/zoul-demo with the following changes:

NETSTACK_MAC.off(1); in L128 commented out
PROCESS_YIELD(); in L145 changed to PROCESS_WAIT_EVENT_UNTIL(0)
NullRDC commented out in project-conf.h

So far in PM2 the current drops from 2.73mA to 0.672mA, but some work is still required.  There is around 500uA consumed by the XTAL oscillator (32KHz), as gatting the pads reduces the current consumption to 50uA.  Dropping to PM3 yields around 32uA.
The values are measured on the battery input of the RE-Mote.",note to self: Scheduling a rtimer spikes the current consumption to almost 8mA,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1920,2016-11-03T13:52:05Z,,2016-11-04T09:46:08Z,OPEN,False,109,3,3,https://github.com/alignan,zoul/remote-revb: initialize unused pins to minimize current draw (WIP),1,"['enhancement', 'work-in-progress', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/1920,https://github.com/bthebaudeau,3,https://github.com/contiki-os/contiki/pull/1920#issuecomment-258277384,"This is a work in progress to reduce the current draw from pins not used, please feel free to drop any comment or suggestion!
Testing with the examples/zolertia/zoul/zoul-demo with the following changes:

NETSTACK_MAC.off(1); in L128 commented out
PROCESS_YIELD(); in L145 changed to PROCESS_WAIT_EVENT_UNTIL(0)
NullRDC commented out in project-conf.h

So far in PM2 the current drops from 2.73mA to 0.672mA, but some work is still required.  There is around 500uA consumed by the XTAL oscillator (32KHz), as gatting the pads reduces the current consumption to 50uA.  Dropping to PM3 yields around 32uA.
The values are measured on the battery input of the RE-Mote.","Yes, a tickless implementation would help (as previously discussed).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1921,2016-11-03T22:49:13Z,,2017-02-09T16:42:41Z,OPEN,False,66,4,2,https://github.com/cquijano,cc26xx-cc13xx: Add eddystone UID beacon support,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1921,https://github.com/cquijano,1,https://github.com/contiki-os/contiki/pull/1921,"This commit add support for Eddystone beacons
To enable it, you must define:
#define EDDYSTONE_CONF_UUID {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a}
#define EDDYSTONE_CONF_ENABLED 1","This commit add support for Eddystone beacons
To enable it, you must define:
#define EDDYSTONE_CONF_UUID {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a}
#define EDDYSTONE_CONF_ENABLED 1",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1924,2016-11-06T19:48:47Z,2016-12-04T22:55:31Z,2016-12-11T16:52:50Z,MERGED,True,2,2,2,https://github.com/g-oikonomou,Update to latest CC13xxware/CC26xxware,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1924,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1924,"This pull updates the CC13xx/CC26xx ports to use the latest versions of TI's CC13xxware and CC26xxware respectively.
Recent changes in both xxwares are exclusively internal and there are no API changes. Therefore it appears we don't need to make any modifications to Contiki's sources.
Can I ask the community to please help test this pull?
Cheers","This pull updates the CC13xx/CC26xx ports to use the latest versions of TI's CC13xxware and CC26xxware respectively.
Recent changes in both xxwares are exclusively internal and there are no API changes. Therefore it appears we don't need to make any modifications to Contiki's sources.
Can I ask the community to please help test this pull?
Cheers",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1924,2016-11-06T19:48:47Z,2016-12-04T22:55:31Z,2016-12-11T16:52:50Z,MERGED,True,2,2,2,https://github.com/g-oikonomou,Update to latest CC13xxware/CC26xxware,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1924,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/1924#issuecomment-259208860,"This pull updates the CC13xx/CC26xx ports to use the latest versions of TI's CC13xxware and CC26xxware respectively.
Recent changes in both xxwares are exclusively internal and there are no API changes. Therefore it appears we don't need to make any modifications to Contiki's sources.
Can I ask the community to please help test this pull?
Cheers","Tested it for ~24h on one CC1310 EM node. Transmitting a frame directly to sink every sec - my metrics are basically lost frames and unknown restarts. Both are comparable to our other nodes running earlier cc13xxware.
(RSSI on received from sink seems to be the same as well (ref. the 10dB problem))",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1924,2016-11-06T19:48:47Z,2016-12-04T22:55:31Z,2016-12-11T16:52:50Z,MERGED,True,2,2,2,https://github.com/g-oikonomou,Update to latest CC13xxware/CC26xxware,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1924,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/1924#issuecomment-260200319,"This pull updates the CC13xx/CC26xx ports to use the latest versions of TI's CC13xxware and CC26xxware respectively.
Recent changes in both xxwares are exclusively internal and there are no API changes. Therefore it appears we don't need to make any modifications to Contiki's sources.
Can I ask the community to please help test this pull?
Cheers","Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP
Something else that I'm not telling you about :)

From my PoV this is ready for consideration and merging.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1924,2016-11-06T19:48:47Z,2016-12-04T22:55:31Z,2016-12-11T16:52:50Z,MERGED,True,2,2,2,https://github.com/g-oikonomou,Update to latest CC13xxware/CC26xxware,1,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1924,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1924#issuecomment-264738490,"This pull updates the CC13xx/CC26xx ports to use the latest versions of TI's CC13xxware and CC26xxware respectively.
Recent changes in both xxwares are exclusively internal and there are no API changes. Therefore it appears we don't need to make any modifications to Contiki's sources.
Can I ask the community to please help test this pull?
Cheers",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1931,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/aparvizi,2,https://github.com/contiki-os/contiki/pull/1931#issuecomment-260687413,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","HI,
I Test CC1350LP_US, cc26XX webdemo with 6lbr :
(on BBB & raspberry pi)
in IEEE mode :

6lbr up , no problem.
web_demo cc1350LP_US connected to 6lbr and get IP's , but no PING .

(6lbr router on BBB & RPI with same config work FINE with CC2650 & ST & CC2358+PA)
on prob mode:

6lbr up , no problem.
web_demo cc1350LP_US not connected & stay in blink, not works;

regards,
a.Parvizi",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1931#issuecomment-264738598,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","Looks good, but I haven't tested myself, waiting for someone else to confirm it is working, @jonnteolsson, @aparvizi ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1931#issuecomment-264738758,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","Thanks Antonio, this one works on all my kit and also @arurke reports positive results in #1659, but we are doing some more testing internally over the next couple of days!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/jonnteolsson,5,https://github.com/contiki-os/contiki/pull/1931#issuecomment-264867327,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","I will test this in the coming days and get back to you.
‚Ä¶
-Jonas

From: George Oikonomou [mailto:notifications@github.com]
Sent: 5. desember 2016 00:00
To: contiki-os/contiki
Cc: Olsson, Jonas; Mention
Subject: Re: [contiki-os/contiki] Use TI-Provided CC13xx/CC26xx RF API (#1931)


Thanks Antonio, this one works on all my kit and also @arurke<https://github.com/arurke> reports positive results in #1659<#1659>, but we are doing some more testing internally over the next couple of days!

‚Äî
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub<#1931 (comment)>, or mute the thread<https://github.com/notifications/unsubscribe-auth/ADIbdufIeCavoI3ZfgrjgUoEQGM_rwtaks5rE0XdgaJpZM4KwwGD>.

Texas Instruments Norway AS, Postboks 264 Sk√∏yen, Hoffsveien 70 C, NO-0213 Oslo, Norway. Org. NO 980499480 MVA",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/jonnteolsson,6,https://github.com/contiki-os/contiki/pull/1931#issuecomment-264962436,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","Looks good, tested with CC1350LaunchPad (EU), CC1310LaunchPad (EU) and CC1350SensorTag (US) defualt RF configuration. All looks good, RSSI as expected and stable.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/1931#issuecomment-266309178,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","All discussions here as well as under #1932 indicate this is ready to merge.
In addition to the boards listed in the OP, this has also been tested with CC1310EM, CC1350LP and CC1350STK",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/EduardoMolinaTomas,8,https://github.com/contiki-os/contiki/pull/1931#issuecomment-268775664,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","Maybe is a dumb question but, what board definition have I to use to compile codes for CC1350 devices (sensor tag and launch pad)?
For instance for CC2650 Launchpad I use BOARD=launchpad/cc2650, but as far as I know I can't use BOARD=launchpad/cc1350.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/g-oikonomou,9,https://github.com/contiki-os/contiki/pull/1931#issuecomment-268862118,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","@EduardoMolinaTomas to get support for the CC1350LP, you need #1932 (which sits on top of this PR here)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/arurke,10,https://github.com/contiki-os/contiki/pull/1931#issuecomment-273926069,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","Tested this a bit separately (with one custom cc1310 board + cc1310em as SLIP). No adverse effects seen, and RSSI improved > 10 db. Regarding adverse effect, judging from the updated timings I reckon one should expect ~10 % reduced max. throughput?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/g-oikonomou,11,https://github.com/contiki-os/contiki/pull/1931#issuecomment-273939096,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924","@arurke Andreas these updated timings are required because with all the new patching of the RF core the startup time increases a little bit. So perhaps somewhat lower throughput compared to what we have now, but remove the timing chances and performance will go very south.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1931,2016-11-13T17:50:30Z,2017-04-24T14:33:15Z,2017-04-24T14:33:18Z,MERGED,True,151,3476,18,https://github.com/g-oikonomou,Use TI-Provided CC13xx/CC26xx RF API,12,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1931,https://github.com/g-oikonomou,12,https://github.com/contiki-os/contiki/pull/1931#issuecomment-287490482,"Originally, TI were not shipping RF API headers with CCxxwares, so we had to distribute those through Contiki (files under cpu/cc26xx-cc13xx/rf-core/api/).
This changed a while ago. CCxxwares now include API headers for common commands, BLE mode and PROP mode (CC13xxware only). Headers for IEEE mode are not included in CCxxwares yet.
This pull changes our CC13xx/CC26xx ports to use CCxxware-provided headers where possible.
Tested with:

CC2650 STK
SmarfRF + CC2650EM
CC1310LP

Sits on top of #1924",I'll merge this in a month unless I receive an objection.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1932,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,2,https://github.com/contiki-os/contiki/pull/1932#issuecomment-260685085,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","HI,
I Test CC1350LP_US, cc26XX webdemo with 6lbr :
(on BBB & raspberry pi)
in IEEE mode :

6lbr up , no problem.
web_demo cc1350LP_US connected to 6lbr and get IP's , but no PING .

(6lbr router on BBB & RPI with same config work FINE with CC2650 & ST & CC2358+PA)
on prob mode:

6lbr up , no problem.
web_demo cc1350LP_US not connected & stay in blink, not works;

regards,
a.Parvizi",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/tussock-cam,3,https://github.com/contiki-os/contiki/pull/1932#issuecomment-260779770,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Ignore my previous comment, I shouldn't have just looked at the diff :)
rf-switch stuff works well on my custom board, haven't tested on launchpad.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1932#issuecomment-260779939,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",Bah you removed it before I could reply! :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1932#issuecomment-260780059,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",Tell us about your board. Does it have a switch too? Is it 1350-based?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/tussock-cam,6,https://github.com/contiki-os/contiki/pull/1932#issuecomment-260781627,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","It's cc1350 based but has a different switch than the launchpad. We don't have power control over it, so just select/deselect. This setup works nicely for that, though, and lets us enable high impedence when we don't care, which saves a bit of power! Much nicer than my quick little patch to set it high/low when needed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/jesse-tussock,7,https://github.com/contiki-os/contiki/pull/1932#issuecomment-260829867,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",@g-oikonomou Just following on from @tussock-cam We are using the CC1350 with a SKY13354-368LF switch. It is currently only in prototype. We have made 30 units and are using them in a number of proof of concept projects.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,8,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264675849,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Hi folks, there is new stuff for you to test here.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/tussock-cam,9,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264749962,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","I haven't had a chance to test the new changes, but figure this is probably an okay spot to post this..
ccxxwares produces a heap of warnings about unused functions which makes it difficult to find useful warnings in the output. We can silence these by using -isystem $(TI_XXWARE) etc. in Makefile.cc26xx-cc13xx. I've never used -isystem before so not too sure what goes on behind the scenes, but it does seem to change the order things happen in. Comments in the Makefile indicate that we need these included first, so I'm not sure if this would affect that.
If -isystem works okay, I think this would be a useful change to improve signal-to-noise :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,10,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264773664,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",I'm not sure what warnings you are referring to. Both my local installation as well as Travis agree that this build is warning-free.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,11,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264832440,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","hi,
i test cc1350LP-US, with RPL_BORDER_ROUTER and cc26xx-web-demo, on prob mode, it's ok,
i want test both mode with 6lbr and RPL, and  send reports  ASAP.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,12,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264857682,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","CC1350LP_us  ( prefix fd00) , it's ok, in both mode with 6LBR and RPL.
the problem is in rssi;
rssi is -70 with 30cm distance between  2 node.
the rf config is:
#define DOT_15_4G_CONF_FREQUENCY_BAND_ID DOT_15_4G_FREQUENCY_BAND_915
#define RF_CORE_CONF_CHANNEL                 25
other setting it's default setting.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,13,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264857921,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",That's too low :( Both devices US Launchpads?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,14,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264858982,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","yes,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,15,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264859347,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","with TI EASYLINK, the rssi is -20.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/jonnteolsson,16,https://github.com/contiki-os/contiki/pull/1932#issuecomment-264963997,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","All looks good for CC13xx, tested on CC1310LaunchPad, CC1350LaunchPad and CC1350SensorTag.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/andrewbrannan,17,https://github.com/contiki-os/contiki/pull/1932#issuecomment-265169720,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",Works great with the CC1310 LP.  I've seen the same issue as @aparvizi with the CC1350_EU LP.  Boards 30cm apart shows -70dBm.  Switching one with a CC1310LP increases RSSI to -45dBm.  With two CC1310 LP the RSSIs are around -20dBm.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,18,https://github.com/contiki-os/contiki/pull/1932#issuecomment-265509664,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",@aparvizi @stringr9 we think we may be onto something that could be causing the RSSI problems with the CC1350LP. I pushed a couple of commits and planning to test first chance. Can you please test too?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/andrewbrannan,19,https://github.com/contiki-os/contiki/pull/1932#issuecomment-265522323,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",No change on my end with the 1350 LP unfortunately.  Still seeing ~-70dBm when 30cm apart.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,20,https://github.com/contiki-os/contiki/pull/1932#issuecomment-265553205,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","also, no change.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,21,https://github.com/contiki-os/contiki/pull/1932#issuecomment-265584405,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",OK well we're suspecting the RF switch manipulation here...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,22,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266241579,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","More commits added to make overrides even more configurable. Most importantly: I just realised that TX power values used in CMD_PROP_DIV_RADIO_SETUP differ across boards, so I've reworked the driver to allow the board code to provide correct values. Fallback to defaults possible.
I am seeing very very sane RSSI values here using CC1310 (LP and EM) and CC1350 (LP and STK) devices in the same testbed. STK values are somewhat lower.
@aparvizi @stringr9 @jonnteolsson @tussock-cam can you confirm please?
Fixes #1659",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,23,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266241651,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Shamelessly also pinging @Johan-Henry, @arurke and @jimmycmlo",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/arurke,24,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266249473,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",Do you expect any changes to cc1310em? I do not have any cc1350 LP/STK.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,25,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266249596,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",For EM the RSSI values should be comparable to those observed when using SmartRF studio,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,26,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266276914,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Dear g-oikonomou ,
I test on cc1350-lp-US , in 6LBR, both side is cc1350-lp-US,
worked fine, with stable ping.
i will send full report after finish all test.
Thank you.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/aparvizi,27,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266280996,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","in prob mode with 30 cm distance:
rssi:-17
in 30 meter distance with 3 Walls:
rssi:-54
(ping time for both is attached):



in IEEE mode:
in 30 meter distance with 3 Walls:
rssi:-80
(but, ping time is good)-all attached:",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/jonnteolsson,28,https://github.com/contiki-os/contiki/pull/1932#issuecomment-266306538,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Finally it looks good on all targets!
Test setup:
rpl-border-router and cc26xx-demo, both with rssi printed in read_frame();
all targets very close to each other (few centimeters)
Results:
BR cc1350lp <-> cc1350lp, -14dBm in both directions
BR cc1350lp <-> cc1350stk, -16dBm on LP, -25dBm on STK (this is as expected due to single ended configuration on stk)
BR cc1350lp <-> cc1310lp, -14dBm in both directions",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/andrewbrannan,29,https://github.com/contiki-os/contiki/pull/1932#issuecomment-268595117,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Testing RSSIs on CC1310/50 LPs look good!  Similar values to @jonnteolsson above.
Unfortunately I'm encountering some kind of issue with contikimac on this branch that's severely limiting range.   Testing using CC1310 LPs.  Findings summarised in this table:



Commit
RDC
Range for PER > 20%
RSSI




a6b14a0
contikimac
20m
-50


a6b14a0
nullrdc
260m
-95


edec34f
contikimac
140m
-93


edec34f
nullrdc
265m
-93



I conducted the tests with a simple modification of the simple-udp-rpl examples to calculate PER of received packets.  Can be found here.  For the problematic test at 20m, the RSSI of the rx'd packets that did get through seemed fine (~-50) but only a fraction of the packets were getting through to the receiver.  At 30m no packets were received at all.
Sounds like @aparvizi was able to get 30m  without any issues so I'm hoping this is an oversight on my part, but I ran the exact same example on both commits with no other changes so it's hard to see how.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/EduardoMolinaTomas,30,https://github.com/contiki-os/contiki/pull/1932#issuecomment-272417991,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","First I apologize you in case this wouldn't were te correct place to ask this question.
I've working with this branch since is the only one which works with CC1350 correctly. In my case y only have CC1350 Launchpads as development kits due CC1350 is not available yet to my country.
Despite of this, for my project requirements I had to made a custom board based on CC1350 sensortag whitout all sensors included in order to reduce the board size to minimum. The schematic is the same.
This custom boards seem to comunicate correctly with Launchpads using Smart RF Studio from Texas Instrumens. Also I compiled some test codes from code composer and both sub 1Ghz and BLE seems to be ok.
Unfortunately I can't make it work under Contiki.
The only changes I've made was to comment some initializations related with I2C in ""board.c"" files from ""...\contiki\platform\srf06-cc26xx\sensortag"" as I don't have this peripherals connected. By this way I'm able to run some test codes, for instance a simple led blinking.
I've tried to cc26xx-web-demo and a modified code which only acts as 6lbr client whitout success. However, these codes compiled and tested on their counterparts CC1350 Launchpads are working right.
I wonder if it would be possible to have any advice of what I'm doing wrong.
Besides I'm trying Rime examples and I found interesting due its simplicity. Where I could get more information about this topic and Contiki in general?
Thank you in advance for your time.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/rifotu,31,https://github.com/contiki-os/contiki/pull/1932#issuecomment-272685001,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931","Hello,
I tried this pull request with the below setup
2x CC1350 ST  with web-demo firmware  (nullrdc driver setting in project-conf.h)
2x CC1310 LP  with web-demo firmware (default driver) latest contiki master branch commit: cf2b249..)
6LBR (1.4.1) with a CC1310 Launchpad slip radio (latest contiki master branch commit: cf2b249...)
The systems works but I faced some problems, I would be happy if you can comment on this.


Range of CC1350 ST's are problematic. Can't take them further than 6 meters from Slip Radio


When moving around CC1350 ST, sometimes they lose connection to 6LBR and can't reestablish the connection no matter how close I place them to 6LBR. I have to do a manual restart to solve this.


ps If I don't change to nullrdc driver then accessing the web page on CC1350 ST works once out of 10 tries. do you see the same behaviour?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/jesse-tussock,32,https://github.com/contiki-os/contiki/pull/1932#issuecomment-276258511,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",@g-oikonomou The latest code here fixes our synth calibration issues. Presumably related to the tx power refactor. Seems to be working well now.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1932,2016-11-13T21:05:18Z,2017-04-24T14:34:22Z,2017-04-24T14:34:28Z,MERGED,True,1415,3598,61,https://github.com/g-oikonomou,Add support for the CC1350 LP and Sensortag,27,"['enhancement', 'timed out', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/1932,https://github.com/g-oikonomou,33,https://github.com/contiki-os/contiki/pull/1932#issuecomment-287490515,"This pull adds support for two additional CC13xx boards:

CC1350LP
CC1350STK

Sits on top of #1931",I'll merge this in a month unless I receive an objection.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,1,https://github.com/contiki-os/contiki/pull/1934,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1934#issuecomment-262480198,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Thanks for the contribution!
Before we can take a closer look, please make sure to pass all Travis tests, to cleanup the diff (e.g. the changes to the rpl-udp don't seem intended). Also, as this is an new feature of an important core module (RPL), I will ask for an extra Travis test that ensures non-regression on the new feature. Please ping us when this is done so we can provide detailed feedback.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,3,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263808762,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Hi! I have done most of what you ask (cleanup diffs, pass all regression tests). I have one question about the extra Travis test.
Does it have to be a regression test on the specific implementation of the security features?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263818582,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Thanks! Great that you got Travis to pass. Yes, I meant a test of the new security feature. But before you spend time on this, it may be a good to get a feel what the PR exactly adds:

what is implemented exactly?
what does this bring compared to using link-layer security?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263819096,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"please also note the code style is a bit off, at least in rpl-icmp.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,6,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263822474,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"This PR implements part of RFC 6550 Section 10:


Authenticity, Integrity and (optionally) confidentiality are implemented over RPL messages: RPL messages are enlarged with a MAC at the end of the packet and optionally are encrypted using CCM* library.


The MAC covers the entire IPv6 packet, i.e. IP header, ICMP header, Security Section of RPL messages and the RPL payload.


The RPL secure message use different ICMP6 type codes


The messages are protected by using a 128 bit key shared between all the network nodes, and different security levels are implemented


While link-layer security protects every type of packets, this implementation is compliant to RFC 6550 and only RPL messages are protected.


I changed the CCM-star interface because RPL optionally encrypts, it can only add a MAC for integrity and authentication. The mic function in the interface was already implemented (aead itself uses it), but it was private; with this change the function is now public and I can use it in this implementation avoiding useless encryption when not needed. That's why tests are still passed, I think.
About code style, I actually forgot to use the beautifier on rpl-icmp.c. I will update soon to fix this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263828165,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Right, interesting. If you're familiar with IPsec, I'm curious, what are the differences in terms of protection with IPsec AH?
As for adea, 2 things:
(1) right, but other implementations of ccm-star (in cc2538 and jn516x) also need to implement your interface now
(2) if I'm not mistaken aead can also compute mic without encrypting any payload (look at the a and b parameters)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,8,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263828412,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Speaking about the RPL Security vs Link layer security there's another important difference:
Link layer security mechanisms are link layer specific, RPL security is not.
Example scenario:


In a DODAG two different link layer are used (like Bluetooth and 802.15.4).


RPL security mechanism protects its messages despite the link layer. Otherwise, i have to set two different link layer security mechanisms.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263832073,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Yes, that is a good point. How about IPsec AH?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,10,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263861099,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"The suggestion about CCM* star library was really good, I didn't think on that possibility so I make that  function public, I will revert the changes on that library.
Speaking about IpSec, I'm not very familiar with it, but RPLSec protects only RPL messages, in order to protect the routing protocol state.
IpSec protects every IP packet. If we don't need it, in order to protect RPL state we suffer of a greater computational cost.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1934#issuecomment-263871859,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Right. I need to take a closer look at RPLsec and will then review this PR at some point.
Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/mcr,12,https://github.com/contiki-os/contiki/pull/1934#issuecomment-271582706,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"IPsec AH is largely dead.  IPsec AH made a fundemental mistake: if the SPI is unknown then the entire packet is discarded, rather than continuing to process as if there was no security. That makes it hard to implement listening for DIOs, but not authenticating them until you have the key.  Plus RPL really needs asymmetric methods to do security well. (and 6550 security team didn't know IPsec... le sigh).
As for differences against l2 security: it crosses link types, which might matter if two nodes have two paths, across two link types.  Also while symmetric methods can't work with A=1 to protect node identity (you need assymetric methods), the symmetric methods do keep non-router (host) nodes from impersonating routers. (this is not important at this point in contiki and RPL evolution, but it will matter).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/simonduq,13,https://github.com/contiki-os/contiki/pull/1934#issuecomment-271586406,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,Thanks for the input @mcr !,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,14,https://github.com/contiki-os/contiki/pull/1934#issuecomment-272420670,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"Hi! Thanks for you answer @mcr! The basic features about security section in rfc 6550 are quite clear, yes.
By the way, I'm working on an improvement of this implementation, where a standard-compliant replay protection mechanism is deployed. In this work I had more doubts, that are not clarified in the rfc.
One of this is about this sentence:

If the received message counter
value is non-zero and less than the maintained incoming counter
watermark, a potential packet replay is indicated and the node MUST
discard the incoming packet.

Why a received counter equal to the watermark is accepted?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/mcr,15,https://github.com/contiki-os/contiki/pull/1934#issuecomment-272469983,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"arenantonio92 <notifications@github.com> wrote:
 If I understood your first question, you're asking if I can enable
 security in RPL with_RPL_SECURITY_ macro without setting the
 preinstalled key through_RPL_CONF_SECURITY_K_ macro. The answer is
 yes. If someone forgets to set the key, a default key is set in
 rpl-conf.h, to prevent possible uncorrect behaviours.

No, I mean: Can I compile the security in, but not enable it until the
key is set *at runtime*.
 Speaking about the second question, I think Contiki assumes that nodes
 have only one network interface, but I might be wrong. Anyway, in this
 implementation if security is enabled, nodes drop non-recurring
 packets.

Contiki nodes regularly have two interfaces: the second one being a SLIP
interface to a host, or an ethernet interface.   I have run RPL with
two interfaces as well.

If you don't have two interfaces, then you can't run RPL on different media,
so one of the points of RPL security goes away!
‚Ä¶
--
]               Never tell me the odds!                 | ipv6 mesh networks [
]   Michael Richardson, Sandelman Software Works        | network architect  [
]     mcr@sandelman.ca  http://www.sandelman.ca/        |   ruby on rails    [",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,16,https://github.com/contiki-os/contiki/pull/1934#issuecomment-273608773,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"No, I mean: Can I compile the security in, but not enable it until the
key is set at runtime.

Not in this version.
We are planning to develop a version which allows for authenticated mode (A=1). In this mode, setting and enabling a key at runtime is needed, so we will probably develop this feature.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1934,2016-11-14T14:12:01Z,,2017-05-29T13:27:34Z,OPEN,False,2507,281,17,https://github.com/arenantonio92,RPL: Basic security features implementation,25,[],https://github.com/contiki-os/contiki/pull/1934,https://github.com/arenantonio92,17,https://github.com/contiki-os/contiki/pull/1934#issuecomment-304661091,Implementation of basic security features over RPL. The current implementation supports only secure preinstalled mode. Example code (with a README) is provided examples/ivp6/rpl-sec,"A light replay protection mechanism has been added to the project. The mechanism is very similar to the 802.15.4 replay protection one. In particular:
1- The first message of a new neighbor is always processed, and a local copy of the current value of the incoming counter is stored.
2- After this first message, the next ones are checked on counter value, i.e. packets are processed iff the incoming counter is greater then the stored local copy.
3- Packets with incoming counter equal to 0xffff are always discarded
Also, CC messages are implemented.

In case of reboot, a node restarts with its secure counter equal to zero. If neighbor nodes have a local copy for the counter of rebooted node, they send a CC response with the value of their local copy. In this way the rebooted node can resync its counter the latest value used.
In case of interOS interactions, if a CC request is received, nodes send a CC response as defined in RFC6550.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1935,2016-11-14T18:59:18Z,,2017-01-10T09:43:07Z,OPEN,False,7,0,1,https://github.com/arthurfabre,ContikiMac: Schedule next cycle after last CCA check,1,[],https://github.com/contiki-os/contiki/pull/1935,https://github.com/arthurfabre,1,https://github.com/contiki-os/contiki/pull/1935,"After the last CCA check, ContikiMac schedules another wake up and
yields.
When it wakes up again, it just schedules the next cycle check.
This wastes power and time, so once we are done with the last CCA check,
we immediately schedule the next cycle check and yield.
This saves us from performing an extra yield / sleep / wakeup cycle.
On a power meter, the 3rd spike seen after the first 2 CCA checks
disappears. On a muntjac (remote-like platform), this reduces our average power consumption by
~0.4mA.","After the last CCA check, ContikiMac schedules another wake up and
yields.
When it wakes up again, it just schedules the next cycle check.
This wastes power and time, so once we are done with the last CCA check,
we immediately schedule the next cycle check and yield.
This saves us from performing an extra yield / sleep / wakeup cycle.
On a power meter, the 3rd spike seen after the first 2 CCA checks
disappears. On a muntjac (remote-like platform), this reduces our average power consumption by
~0.4mA.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1935,2016-11-14T18:59:18Z,,2017-01-10T09:43:07Z,OPEN,False,7,0,1,https://github.com/arthurfabre,ContikiMac: Schedule next cycle after last CCA check,1,[],https://github.com/contiki-os/contiki/pull/1935,https://github.com/arthurfabre,2,https://github.com/contiki-os/contiki/pull/1935#issuecomment-268120851,"After the last CCA check, ContikiMac schedules another wake up and
yields.
When it wakes up again, it just schedules the next cycle check.
This wastes power and time, so once we are done with the last CCA check,
we immediately schedule the next cycle check and yield.
This saves us from performing an extra yield / sleep / wakeup cycle.
On a power meter, the 3rd spike seen after the first 2 CCA checks
disappears. On a muntjac (remote-like platform), this reduces our average power consumption by
~0.4mA.",Any update on this? The Travis checks failed due to a org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.awt.Color which I doubt was caused by this change.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1935,2016-11-14T18:59:18Z,,2017-01-10T09:43:07Z,OPEN,False,7,0,1,https://github.com/arthurfabre,ContikiMac: Schedule next cycle after last CCA check,1,[],https://github.com/contiki-os/contiki/pull/1935,https://github.com/niklas88,3,https://github.com/contiki-os/contiki/pull/1935#issuecomment-271530228,"After the last CCA check, ContikiMac schedules another wake up and
yields.
When it wakes up again, it just schedules the next cycle check.
This wastes power and time, so once we are done with the last CCA check,
we immediately schedule the next cycle check and yield.
This saves us from performing an extra yield / sleep / wakeup cycle.
On a power meter, the 3rd spike seen after the first 2 CCA checks
disappears. On a muntjac (remote-like platform), this reduces our average power consumption by
~0.4mA.",Seeing as ContikiMAC-Async seems to have been abandoned I'm thinking of switching back to mainline ContikiMAC and would be interested in this change as well. It seems to me there is a bit of interest in very low power operations and consequently reviews for ContikiMAC currently so I think such small step changes would be especially welcome. Let me know if additional testing would help bring things along.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1936,2016-11-15T12:58:57Z,,2017-06-02T05:26:08Z,OPEN,False,3020,17,19,https://github.com/spoerk,Add IPv6 over BLE support for SensorTag CC26xx platform,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Network']",https://github.com/contiki-os/contiki/pull/1936,https://github.com/spoerk,1,https://github.com/contiki-os/contiki/pull/1936,"This pull request adds IPv6 over BLE support according to the RFC 7886 standard for the Texas Instruments SensorTag CC2650.
This PR adds a BLE implementation of the radio layer for the SensorTag CC2650.
A hardware-independent MAC layer implementation for IPv6 over BLE that implements packet fragmentation/reassembly is also included.","This pull request adds IPv6 over BLE support according to the RFC 7886 standard for the Texas Instruments SensorTag CC2650.
This PR adds a BLE implementation of the radio layer for the SensorTag CC2650.
A hardware-independent MAC layer implementation for IPv6 over BLE that implements packet fragmentation/reassembly is also included.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1936,2016-11-15T12:58:57Z,,2017-06-02T05:26:08Z,OPEN,False,3020,17,19,https://github.com/spoerk,Add IPv6 over BLE support for SensorTag CC26xx platform,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Network']",https://github.com/contiki-os/contiki/pull/1936,https://github.com/adamdunkels,2,https://github.com/contiki-os/contiki/pull/1936#issuecomment-260635716,"This pull request adds IPv6 over BLE support according to the RFC 7886 standard for the Texas Instruments SensorTag CC2650.
This PR adds a BLE implementation of the radio layer for the SensorTag CC2650.
A hardware-independent MAC layer implementation for IPv6 over BLE that implements packet fragmentation/reassembly is also included.","This looks cool! Can this be used to make a smartphone act as a bridge into an IPv6 / 802.15.4 network, or is it intended only as a point-to-point connection to a single cc26xx device? The example seems to indicate that it needs a special hardware solution on the other side (a Raspberry Pi with an nRF dongle?).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1936,2016-11-15T12:58:57Z,,2017-06-02T05:26:08Z,OPEN,False,3020,17,19,https://github.com/spoerk,Add IPv6 over BLE support for SensorTag CC26xx platform,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Network']",https://github.com/contiki-os/contiki/pull/1936,https://github.com/spoerk,3,https://github.com/contiki-os/contiki/pull/1936#issuecomment-260640071,"This pull request adds IPv6 over BLE support according to the RFC 7886 standard for the Texas Instruments SensorTag CC2650.
This PR adds a BLE implementation of the radio layer for the SensorTag CC2650.
A hardware-independent MAC layer implementation for IPv6 over BLE that implements packet fragmentation/reassembly is also included.","This IPv6 over BLE stack works with every IPv6 over BLE border router that is compliant to the RFC 7668 standard.
I only included the Raspberry Pi BR with BLE/USB-Dongle because the same border router was used for #1469, and because I used it to test my IPv6 over BLE stack.
Therefore, it is absolutely possible to use a smartphone as a bridge into another IPv6 network.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1936,2016-11-15T12:58:57Z,,2017-06-02T05:26:08Z,OPEN,False,3020,17,19,https://github.com/spoerk,Add IPv6 over BLE support for SensorTag CC26xx platform,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Network']",https://github.com/contiki-os/contiki/pull/1936,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1936#issuecomment-260661332,"This pull request adds IPv6 over BLE support according to the RFC 7886 standard for the Texas Instruments SensorTag CC2650.
This PR adds a BLE implementation of the radio layer for the SensorTag CC2650.
A hardware-independent MAC layer implementation for IPv6 over BLE that implements packet fragmentation/reassembly is also included.","Oh wow, I'll definitely look at the platform side of this one!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1936,2016-11-15T12:58:57Z,,2017-06-02T05:26:08Z,OPEN,False,3020,17,19,https://github.com/spoerk,Add IPv6 over BLE support for SensorTag CC26xx platform,10,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'Network']",https://github.com/contiki-os/contiki/pull/1936,https://github.com/LanshunNie,5,https://github.com/contiki-os/contiki/pull/1936#issuecomment-305692929,"This pull request adds IPv6 over BLE support according to the RFC 7886 standard for the Texas Instruments SensorTag CC2650.
This PR adds a BLE implementation of the radio layer for the SensorTag CC2650.
A hardware-independent MAC layer implementation for IPv6 over BLE that implements packet fragmentation/reassembly is also included.","This looks great. Can this be used to support point-to-point communication between CC26xx devices? If it can, how to do collision avoidance such as LBT? Thanks spoerk.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1938,2016-11-17T09:56:26Z,2016-11-30T13:24:48Z,2016-11-30T13:24:48Z,MERGED,True,1,1,1,https://github.com/makrog,Fixed checking of the cc1200 GPIO0 pin status.,1,['bug'],https://github.com/contiki-os/contiki/pull/1938,https://github.com/makrog,1,https://github.com/contiki-os/contiki/pull/1938,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1938,2016-11-17T09:56:26Z,2016-11-30T13:24:48Z,2016-11-30T13:24:48Z,MERGED,True,1,1,1,https://github.com/makrog,Fixed checking of the cc1200 GPIO0 pin status.,1,['bug'],https://github.com/contiki-os/contiki/pull/1938,https://github.com/msloth,2,https://github.com/contiki-os/contiki/pull/1938#issuecomment-261208136,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,"Semantically, the original seems to be right, since return value should rather indicate pin being high or low, not return a pin bitfield. Looking at the zoul arch file for example, it returns
GPIO_READ_PIN(CC1200_GDO0_PORT_BASE, CC1200_GDO0_PIN_MASK);
So I'd say instead of your proposed change, do either change the cc1200-arch's to return strictly 0/1 for low/high, or simply check for 0/non-zero in cc1200.c.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1938,2016-11-17T09:56:26Z,2016-11-30T13:24:48Z,2016-11-30T13:24:48Z,MERGED,True,1,1,1,https://github.com/makrog,Fixed checking of the cc1200 GPIO0 pin status.,1,['bug'],https://github.com/contiki-os/contiki/pull/1938,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1938#issuecomment-261208627,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,"Yup, I think that would be preferable to avoid having cpu-specific in the driver.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1938,2016-11-17T09:56:26Z,2016-11-30T13:24:48Z,2016-11-30T13:24:48Z,MERGED,True,1,1,1,https://github.com/makrog,Fixed checking of the cc1200 GPIO0 pin status.,1,['bug'],https://github.com/contiki-os/contiki/pull/1938,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1938#issuecomment-263130543,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,"Thanks for making the change, just fix the space missing between the operator and ready to merge üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1938,2016-11-17T09:56:26Z,2016-11-30T13:24:48Z,2016-11-30T13:24:48Z,MERGED,True,1,1,1,https://github.com/makrog,Fixed checking of the cc1200 GPIO0 pin status.,1,['bug'],https://github.com/contiki-os/contiki/pull/1938,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1938#issuecomment-263838046,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,"The travis error is not related to the PR, I just restarted the job and once it is green I will merge",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1938,2016-11-17T09:56:26Z,2016-11-30T13:24:48Z,2016-11-30T13:24:48Z,MERGED,True,1,1,1,https://github.com/makrog,Fixed checking of the cc1200 GPIO0 pin status.,1,['bug'],https://github.com/contiki-os/contiki/pull/1938,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1938#issuecomment-263872393,Driver of cc1200 was mistakenly comparing gpio0 pin high status with 1. When the pin is high you should compare it with the pin number.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1939,2016-11-17T19:43:25Z,2016-12-10T17:32:39Z,2016-12-10T22:44:44Z,MERGED,True,39691,97,44,https://github.com/bthebaudeau,"Add global SD/MMC and FAT support, with RE-Mote as an example",10,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1939,https://github.com/bthebaudeau,1,https://github.com/contiki-os/contiki/pull/1939,"FatFs is used.
Tested on RE-Mote rev. B.","FatFs is used.
Tested on RE-Mote rev. B.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1939,2016-11-17T19:43:25Z,2016-12-10T17:32:39Z,2016-12-10T22:44:44Z,MERGED,True,39691,97,44,https://github.com/bthebaudeau,"Add global SD/MMC and FAT support, with RE-Mote as an example",10,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1939,https://github.com/bthebaudeau,2,https://github.com/contiki-os/contiki/pull/1939#issuecomment-263222206,"FatFs is used.
Tested on RE-Mote rev. B.",Rework done.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1939,2016-11-17T19:43:25Z,2016-12-10T17:32:39Z,2016-12-10T22:44:44Z,MERGED,True,39691,97,44,https://github.com/bthebaudeau,"Add global SD/MMC and FAT support, with RE-Mote as an example",10,"['nominated', 'timed out', 'new feature']",https://github.com/contiki-os/contiki/pull/1939,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1939#issuecomment-263223207,"FatFs is used.
Tested on RE-Mote rev. B.","Great!
üëç
Setting the timeout to merge",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1947,2016-11-25T10:30:26Z,,2016-11-28T11:01:32Z,OPEN,False,27,10,3,https://github.com/kown7,Contiki IPv6 and default router lost,3,[],https://github.com/contiki-os/contiki/pull/1947,https://github.com/kown7,1,https://github.com/contiki-os/contiki/pull/1947,See routing issues discussed in #1945,See routing issues discussed in #1945,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1948,2016-11-25T14:05:10Z,2016-11-25T15:13:02Z,2016-11-25T15:13:02Z,MERGED,True,1,1,1,https://github.com/zhitaoh,correct shell arguments,1,[],https://github.com/contiki-os/contiki/pull/1948,https://github.com/zhitaoh,1,https://github.com/contiki-os/contiki/pull/1948,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1948,2016-11-25T14:05:10Z,2016-11-25T15:13:02Z,2016-11-25T15:13:02Z,MERGED,True,1,1,1,https://github.com/zhitaoh,correct shell arguments,1,[],https://github.com/contiki-os/contiki/pull/1948,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1948#issuecomment-262966711,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1948,2016-11-25T14:05:10Z,2016-11-25T15:13:02Z,2016-11-25T15:13:02Z,MERGED,True,1,1,1,https://github.com/zhitaoh,correct shell arguments,1,[],https://github.com/contiki-os/contiki/pull/1948,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1948#issuecomment-262976332,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1949,2016-11-25T15:37:59Z,2016-12-01T15:27:38Z,2017-10-27T20:05:38Z,MERGED,True,18,8,1,https://github.com/simonduq,RPL non-storing: more conservative DTSN update,1,[],https://github.com/contiki-os/contiki/pull/1949,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1949,"This is as per RFC 6550, section 9.6: in non-storing mode, only the root triggers DTSN updates.","This is as per RFC 6550, section 9.6: in non-storing mode, only the root triggers DTSN updates.",True,{'THUMBS_UP': ['https://github.com/yatch']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1949,2016-11-25T15:37:59Z,2016-12-01T15:27:38Z,2017-10-27T20:05:38Z,MERGED,True,18,8,1,https://github.com/simonduq,RPL non-storing: more conservative DTSN update,1,[],https://github.com/contiki-os/contiki/pull/1949,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1949#issuecomment-264202784,"This is as per RFC 6550, section 9.6: in non-storing mode, only the root triggers DTSN updates.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1950,2016-11-25T21:50:34Z,2016-12-05T17:40:28Z,2016-12-05T22:39:26Z,MERGED,True,15,8,3,https://github.com/yatch,Miscellaneous updates for tsch-cooja-mote,3,[],https://github.com/contiki-os/contiki/pull/1950,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1950,"Two updates to resolve issues arising when running examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc.
One update on README.md of TSCH

add cooja as supported platform
correct Rx mode requirements","Two updates to resolve issues arising when running examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc.
One update on README.md of TSCH

add cooja as supported platform
correct Rx mode requirements",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1950,2016-11-25T21:50:34Z,2016-12-05T17:40:28Z,2016-12-05T22:39:26Z,MERGED,True,15,8,3,https://github.com/yatch,Miscellaneous updates for tsch-cooja-mote,3,[],https://github.com/contiki-os/contiki/pull/1950,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1950#issuecomment-263237416,"Two updates to resolve issues arising when running examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc.
One update on README.md of TSCH

add cooja as supported platform
correct Rx mode requirements",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1950,2016-11-25T21:50:34Z,2016-12-05T17:40:28Z,2016-12-05T22:39:26Z,MERGED,True,15,8,3,https://github.com/yatch,Miscellaneous updates for tsch-cooja-mote,3,[],https://github.com/contiki-os/contiki/pull/1950,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1950#issuecomment-264921838,"Two updates to resolve issues arising when running examples/ipv6/rpl-tsch/rpl-tsch-cooja.csc.
One update on README.md of TSCH

add cooja as supported platform
correct Rx mode requirements",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1952,2016-11-27T15:23:38Z,2016-11-28T08:37:00Z,2016-11-28T08:37:00Z,MERGED,True,4,4,1,https://github.com/arurke,Move RF_CHANNEL check in cc13xx/cc26xx such that it applies for cc13xx prop mode ,1,[],https://github.com/contiki-os/contiki/pull/1952,https://github.com/arurke,1,https://github.com/contiki-os/contiki/pull/1952,RF_CHANNEL added by #1827 will not be applied to CC13xx prop mode since it is checked after the RF_CORE_CONF_CHANNEL definition. This PR moves it above the prop mode section.,RF_CHANNEL added by #1827 will not be applied to CC13xx prop mode since it is checked after the RF_CORE_CONF_CHANNEL definition. This PR moves it above the prop mode section.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1952,2016-11-27T15:23:38Z,2016-11-28T08:37:00Z,2016-11-28T08:37:00Z,MERGED,True,4,4,1,https://github.com/arurke,Move RF_CHANNEL check in cc13xx/cc26xx such that it applies for cc13xx prop mode ,1,[],https://github.com/contiki-os/contiki/pull/1952,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1952#issuecomment-263212075,RF_CHANNEL added by #1827 will not be applied to CC13xx prop mode since it is checked after the RF_CORE_CONF_CHANNEL definition. This PR moves it above the prop mode section.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/1954,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263847064,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","It's an interesting topic, which is similar to what I discussed somewhere else :-)
With regard to the change, I'm in favor of keeping the current value, 10, for the default RPL_DIO_REDUNDANCY because it's the default value defined in RFC 6550, even though ""it is unclear what the basis of this suggestion is.""
The comment that you added is useful. That would be a nice guideline for RPL_CONF_DIO_REDUNDANCY configuration.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263862026,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.",Is the discussion you already had on the topic available online by any chance?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263881153,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","Yes, here is the mail related to the discussion:
https://mailarchive.ietf.org/arch/msg/roll/-CtpgAUTiU0OXJdPtXFEuYghC5I
While your observation and the discussion are in different contexts, I see the common between them, that is both disable the suppression mechanism in order to propagate information quickly.
By the way, in my opinion, the DTSN case is a bug in RFC 6550... From the point of view of the DAO Triggering mechanism, it makes no sense for DAO parents of a child node to suppress their DIOs because of DIOs from other nodes. In the other view, if the Non-Storing mode is used, I cannot see any reason that RFC 6550 forces child nodes to take DTSN changes only from their DAO parents. In the Non-Storing mode, (typically) only the root increments DTSN, which is a global value in the network.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263884119,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","Thanks for the link.
I share your concern. In general, I'm doubtful about the usefulness of suppression on DIOs, because each DIO contains different information, related to the sender, which is unlike what Trickle was originally designed for (dissemination). With DIOs, suppressing means losing content (children don't get rank update, nor DTSN increments etc). This is why I would disable it by default in Contiki, regardless of the default in RFC 6550 (RFC 5706 points out that defaults are getting less and less needed anyway).
Good point on non-storing with DTSN being global and no need to wait for an update from the preferred parent, indeed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263887043,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","I agree with you on the gap between what RFC 6550 does and the original idea of Trickle timer.
Just out of curiosity, what happened in the network bootstrap? A good amount of nodes were not able to receive DIOs from their expected preferred parents because of DIO suppression?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263889959,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","What happened is the BR would not see DAOs from all nodes before a very long time. First DAOs would come in quick and then the convergence would virtually almost never end (maybe 90% of nodes discovered after 1h). The problem occurred both in storing and non-storing if I remember right.
What I believe was exactly going on is:
(1) all nodes would receive some DIO and join;
(2) they would then send a DAO;
(3) many DAOs get lost because at bootstrap there are too many of them (was without DAO-ACK);
(4) subsequent DTSN increment were unfruitful because of DIO suppression. At a network density of 70-80, the k=10 would basically suppress most DIOs, and some nodes have to wait many iterations until finally hearing from their parent (and the iterations take longer and longer due to interval doubling...).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/yatch,8,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263895205,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","Thanks for the information. In that case, I would enable DAO-ACK if possible (I like DAO-ACK). If DAO-ACK is disabled, it may be better to set DAO sending interval short. But, short DAO interval could cause congestion...
Anyway, DAO is independent of the issue found at (4). Still, there is surely something needed to make the DTSN thing succeed in such an environment.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1954#issuecomment-263897731,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","Yes, DAO-ACK would have helped!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1954,2016-11-28T15:17:11Z,2017-10-27T20:05:36Z,2017-10-27T20:05:36Z,CLOSED,False,9,4,1,https://github.com/simonduq,Disable DIO suppression by default,1,[],https://github.com/contiki-os/contiki/pull/1954,https://github.com/nvt,10,https://github.com/contiki-os/contiki/pull/1954#issuecomment-265830375,"This might be controversial, so discussions are highly welcome here :)
The rationale is that in Contiki, nodes have a single DAO parent, and can only notice DTSN increment from that one particular parent. This means that DTSN increments triggered by the route struggle to propagate. The problem gets more pronounced in denser network.
In large IoT-LAB deployments, such as Grenoble (352 nodes, 6-7 hops diameter), the network even fails to bootstrap in the first place. Disabling redundancy enables quick convergence and swift maintenance. When the signaling traffic gets too heavy, decreasing the Trickle frequency also helps.
Note that this is only the default value; Nodes will adopt whichever value is advertised by the BR, i.e. they will still be able to adapt to networks with specific Trickle-redundancy needs.","I think that we can disable the suppression by default if the given advantages are clear, and no counter-examples are shown where keeping the RFC-recommended value is better.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1956,2016-11-29T17:54:55Z,2016-11-29T18:56:07Z,2016-11-29T18:56:07Z,CLOSED,False,13963,88,129,https://github.com/zitouni,Zolertia workshop,47,[],https://github.com/contiki-os/contiki/pull/1956,https://github.com/zitouni,1,https://github.com/contiki-os/contiki/pull/1956,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1957,2016-11-30T10:57:29Z,2016-12-10T17:37:21Z,2016-12-11T20:59:46Z,MERGED,True,857,10,17,https://github.com/alignan,sensors: bme280 weather sensor,9,"['nominated', 'timed out', 'new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1957,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/1957,"This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf","This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1957,2016-11-30T10:57:29Z,2016-12-10T17:37:21Z,2016-12-11T20:59:46Z,MERGED,True,857,10,17,https://github.com/alignan,sensors: bme280 weather sensor,9,"['nominated', 'timed out', 'new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1957,https://github.com/herjulf,2,https://github.com/contiki-os/contiki/pull/1957#issuecomment-263865082,"This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf",Thanks a lot for fixing and making the PR much more generic with the arch I2C design. This PR passed my platform test but there seems to some fail for regression error.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1957,2016-11-30T10:57:29Z,2016-12-10T17:37:21Z,2016-12-11T20:59:46Z,MERGED,True,857,10,17,https://github.com/alignan,sensors: bme280 weather sensor,9,"['nominated', 'timed out', 'new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1957,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1957#issuecomment-263867241,"This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf","It is not related to the PR, but to Travis failing to set up th Nordic environment, I just restarted the job.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1957,2016-11-30T10:57:29Z,2016-12-10T17:37:21Z,2016-12-11T20:59:46Z,MERGED,True,857,10,17,https://github.com/alignan,sensors: bme280 weather sensor,9,"['nominated', 'timed out', 'new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1957,https://github.com/herjulf,4,https://github.com/contiki-os/contiki/pull/1957#issuecomment-263869181,"This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf",Right. It passed.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1957,2016-11-30T10:57:29Z,2016-12-10T17:37:21Z,2016-12-11T20:59:46Z,MERGED,True,857,10,17,https://github.com/alignan,sensors: bme280 weather sensor,9,"['nominated', 'timed out', 'new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1957,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1957#issuecomment-263871906,"This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf","üëç
Setting a timeout to merge, but another thumbs-up is welcome to have this sooner",True,{'THUMBS_UP': ['https://github.com/herjulf']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1957,2016-11-30T10:57:29Z,2016-12-10T17:37:21Z,2016-12-11T20:59:46Z,MERGED,True,857,10,17,https://github.com/alignan,sensors: bme280 weather sensor,9,"['nominated', 'timed out', 'new feature', 'sensor/actuator']",https://github.com/contiki-os/contiki/pull/1957,https://github.com/herjulf,6,https://github.com/contiki-os/contiki/pull/1957#issuecomment-266307465,"This PR sits on top of #1863 and includes small architecture fixes, and a patch submitted by @herjulf","Thanks! Happy to see this improved and finalized.
Cool.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1958,2016-11-30T14:27:06Z,,2016-12-05T17:39:16Z,OPEN,False,1,1,1,https://github.com/Stamper-repo,Fixed buffer-overflow in asking for command for ping6 app,1,[],https://github.com/contiki-os/contiki/pull/1958,https://github.com/Stamper-repo,1,https://github.com/contiki-os/contiki/pull/1958,"Buffer command is only 20 characters big. Malicious input could be much larger and overflow the buffer, corrupting memory.","Buffer command is only 20 characters big. Malicious input could be much larger and overflow the buffer, corrupting memory.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1958,2016-11-30T14:27:06Z,,2016-12-05T17:39:16Z,OPEN,False,1,1,1,https://github.com/Stamper-repo,Fixed buffer-overflow in asking for command for ping6 app,1,[],https://github.com/contiki-os/contiki/pull/1958,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/1958#issuecomment-264921537,"Buffer command is only 20 characters big. Malicious input could be much larger and overflow the buffer, corrupting memory.","This application could probably be removed, but restricting the input to stay within bounds is good while it is kept.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1960,2016-12-01T12:27:22Z,2016-12-01T15:30:46Z,2016-12-01T15:30:46Z,MERGED,True,1,24,6,https://github.com/pablocorbalan,Remove definitions of outdated RPL_CONF_OF,1,[],https://github.com/contiki-os/contiki/pull/1960,https://github.com/pablocorbalan,1,https://github.com/contiki-os/contiki/pull/1960,"The way to configure the RPL Objective Function to be used has changed and now uses the definitions of  RPL_CONF_SUPPORTED_OFS and RPL_CONF_OF_OCP. Previously, to change the objective function RPL_CONF_OF was used. This definition is not used anymore.
This PR removes the outdated definitions of RPL_CONF_OF from several platforms and the er-rest-example. Note that this should not affect the platforms because MRHOF is by default the objective function of RPL.
For more information see the appearance of RPL_CONF_OFin the code:
https://github.com/contiki-os/contiki/search?utf8=‚úì&q=RPL_CONF_OF
And also the discussion in issue #1955.","The way to configure the RPL Objective Function to be used has changed and now uses the definitions of  RPL_CONF_SUPPORTED_OFS and RPL_CONF_OF_OCP. Previously, to change the objective function RPL_CONF_OF was used. This definition is not used anymore.
This PR removes the outdated definitions of RPL_CONF_OF from several platforms and the er-rest-example. Note that this should not affect the platforms because MRHOF is by default the objective function of RPL.
For more information see the appearance of RPL_CONF_OFin the code:
https://github.com/contiki-os/contiki/search?utf8=‚úì&q=RPL_CONF_OF
And also the discussion in issue #1955.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1960,2016-12-01T12:27:22Z,2016-12-01T15:30:46Z,2016-12-01T15:30:46Z,MERGED,True,1,24,6,https://github.com/pablocorbalan,Remove definitions of outdated RPL_CONF_OF,1,[],https://github.com/contiki-os/contiki/pull/1960,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1960#issuecomment-264198772,"The way to configure the RPL Objective Function to be used has changed and now uses the definitions of  RPL_CONF_SUPPORTED_OFS and RPL_CONF_OF_OCP. Previously, to change the objective function RPL_CONF_OF was used. This definition is not used anymore.
This PR removes the outdated definitions of RPL_CONF_OF from several platforms and the er-rest-example. Note that this should not affect the platforms because MRHOF is by default the objective function of RPL.
For more information see the appearance of RPL_CONF_OFin the code:
https://github.com/contiki-os/contiki/search?utf8=‚úì&q=RPL_CONF_OF
And also the discussion in issue #1955.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1960,2016-12-01T12:27:22Z,2016-12-01T15:30:46Z,2016-12-01T15:30:46Z,MERGED,True,1,24,6,https://github.com/pablocorbalan,Remove definitions of outdated RPL_CONF_OF,1,[],https://github.com/contiki-os/contiki/pull/1960,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1960#issuecomment-264198859,"The way to configure the RPL Objective Function to be used has changed and now uses the definitions of  RPL_CONF_SUPPORTED_OFS and RPL_CONF_OF_OCP. Previously, to change the objective function RPL_CONF_OF was used. This definition is not used anymore.
This PR removes the outdated definitions of RPL_CONF_OF from several platforms and the er-rest-example. Note that this should not affect the platforms because MRHOF is by default the objective function of RPL.
For more information see the appearance of RPL_CONF_OFin the code:
https://github.com/contiki-os/contiki/search?utf8=‚úì&q=RPL_CONF_OF
And also the discussion in issue #1955.","only minor comment is you might want to set of0 on the rest example, as initially intended. But doesn't matter much IMO",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1960,2016-12-01T12:27:22Z,2016-12-01T15:30:46Z,2016-12-01T15:30:46Z,MERGED,True,1,24,6,https://github.com/pablocorbalan,Remove definitions of outdated RPL_CONF_OF,1,[],https://github.com/contiki-os/contiki/pull/1960,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1960#issuecomment-264203724,"The way to configure the RPL Objective Function to be used has changed and now uses the definitions of  RPL_CONF_SUPPORTED_OFS and RPL_CONF_OF_OCP. Previously, to change the objective function RPL_CONF_OF was used. This definition is not used anymore.
This PR removes the outdated definitions of RPL_CONF_OF from several platforms and the er-rest-example. Note that this should not affect the platforms because MRHOF is by default the objective function of RPL.
For more information see the appearance of RPL_CONF_OFin the code:
https://github.com/contiki-os/contiki/search?utf8=‚úì&q=RPL_CONF_OF
And also the discussion in issue #1955.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1961,2016-12-01T14:24:32Z,2016-12-02T14:41:32Z,2016-12-02T15:43:19Z,MERGED,True,0,7,1,https://github.com/jdede,Do not initialize and use the wrong UART (z1),1,[],https://github.com/contiki-os/contiki/pull/1961,https://github.com/jdede,1,https://github.com/contiki-os/contiki/pull/1961,"In contrast to the sky mote, z1 uses uart0. This leads to a link error when compiling the rpl-udp/udp-client.c example.
As the uart is initialized in the corresponding contiki-<platform>-main.c file, the corresponding include and initialization in udp-client.c are unnecessary and can be removed.","In contrast to the sky mote, z1 uses uart0. This leads to a link error when compiling the rpl-udp/udp-client.c example.
As the uart is initialized in the corresponding contiki-<platform>-main.c file, the corresponding include and initialization in udp-client.c are unnecessary and can be removed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1962,2016-12-01T18:36:31Z,2016-12-02T08:52:48Z,2016-12-02T08:52:48Z,MERGED,True,14,0,7,https://github.com/MohamedSeliem,update contiki-conf to avoid redfintion of UIP_CONF_RECEIVE_WINDOW ,2,['enhancement'],https://github.com/contiki-os/contiki/pull/1962,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1962,"in case of compiling any example that contains the definition of UIP_CONF_RECEIVE_WINDOW over Z1 mote.
i receive this warning:
In file included from ../../../core/./contiki.h:38:0,
from ../../../core/./contiki-net.h:37,
from httpd-simple.c:43:
../../../platform/z1/./contiki-conf.h:225:0: warning: ""UIP_CONF_RECEIVE_WINDOW"" redefined
./project-conf.h:60:0: note: this is the location of the previous definition","in case of compiling any example that contains the definition of UIP_CONF_RECEIVE_WINDOW over Z1 mote.
i receive this warning:
In file included from ../../../core/./contiki.h:38:0,
from ../../../core/./contiki-net.h:37,
from httpd-simple.c:43:
../../../platform/z1/./contiki-conf.h:225:0: warning: ""UIP_CONF_RECEIVE_WINDOW"" redefined
./project-conf.h:60:0: note: this is the location of the previous definition",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1962,2016-12-01T18:36:31Z,2016-12-02T08:52:48Z,2016-12-02T08:52:48Z,MERGED,True,14,0,7,https://github.com/MohamedSeliem,update contiki-conf to avoid redfintion of UIP_CONF_RECEIVE_WINDOW ,2,['enhancement'],https://github.com/contiki-os/contiki/pull/1962,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1962#issuecomment-264404012,"in case of compiling any example that contains the definition of UIP_CONF_RECEIVE_WINDOW over Z1 mote.
i receive this warning:
In file included from ../../../core/./contiki.h:38:0,
from ../../../core/./contiki-net.h:37,
from httpd-simple.c:43:
../../../platform/z1/./contiki-conf.h:225:0: warning: ""UIP_CONF_RECEIVE_WINDOW"" redefined
./project-conf.h:60:0: note: this is the location of the previous definition",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1963,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important","Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264426426,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important","Oh, Travis failed with the following error message:
Exception in thread ""main"" java.lang.UnsupportedClassVersionError: org/contikios/cooja/Cooja : Unsupported major.minor version 52.0

I don't think the changes by this PR cause the failure, though...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264428474,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important",thanks üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264429147,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important","I just restarted Travis, as soon as is it green üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264430806,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important",I'm afraid it's not getting green #1965,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264633458,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important",rebased to see if Travis turns to green.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264634018,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important","thanks, should work now :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/yatch,8,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264640076,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important","Ooh, it hit another problem which should not be related to this particular PR... And, it's SIGSEGV...! (>_<)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1963,2016-12-01T22:41:01Z,2016-12-05T12:40:36Z,2016-12-05T15:12:47Z,MERGED,True,26,15,1,https://github.com/yatch,Update doc/code-style.c,1,[],https://github.com/contiki-os/contiki/pull/1963,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1963#issuecomment-264844296,"Here are changes:

mention Uncrustify (tools/code-style/uncrustify.cfg) instead of GNU Indent : reflect cbdd7f2
add a missing argument of code_style_example_function(): \param c in doxygen comment
make the function return 0 or 1 as per doxygen comment: \return, \retval 0, and \retval 1 in doxygen comment
replace tab with spaces
correct case() to switch() in a comment: I guess it's typo...
add an indentation example for switch statement: it's missing, but important",Green after re-run (the failed test is stochastic),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/kaleemullah360,1,https://github.com/contiki-os/contiki/pull/1964,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1964#issuecomment-264401546,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","Hello!
Interesting PR, very comprehensive... but where did you obtain those values? we need a valid reference other than an anonymous guy üòÖ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/kaleemullah360,3,https://github.com/contiki-os/contiki/pull/1964#issuecomment-264510679,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","@alignan thank you.
actually my friend (who is also working in contiki OS) gave me the PA_Level table, he also got this from somewhere, but I'll try to find its reference, cause its important to mention valid reference.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1964#issuecomment-264633991,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002",please rebase now that #1965 is resolved,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1964#issuecomment-264796232,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","Ugh - 166 commits xD
You should definitely just rebase your contribution, as opposite to pushing your updated branch",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/kaleemullah360,6,https://github.com/contiki-os/contiki/pull/1964#issuecomment-264801589,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002",yes @alignan I tried rebase this branch patch-2 and viewed lots of commits instead of one.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1964#issuecomment-264881929,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","Hello,
Here's how you should approach it:
(1) pull latest master
(2) checkout to a new branch
(3) cherry-pick the relevant commit
(4) push (force) to this branch",True,"{'HOORAY': ['https://github.com/alignan'], 'LAUGH': ['https://github.com/kaleemullah360'], 'THUMBS_UP': ['https://github.com/kaleemullah360']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/kaleemullah360,8,https://github.com/contiki-os/contiki/pull/1964#issuecomment-265116413,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","thanks @simonduq , your directions are pretty easy. finally cherry-picked the commit after latest pull and put it ahead the upstream/master. üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1964#issuecomment-265117167,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","thanks, looks good!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/nvt,10,https://github.com/contiki-os/contiki/pull/1964#issuecomment-272092924,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","I think that we should either provide all power levels in the array, or just those listed in the CC2420 datasheet. Adding just power level 5 seems like an arbitrary selection. According to a TI employee in the thread https://e2e.ti.com/support/wireless_connectivity/low_power_rf_tools/f/155/p/254105/889361, the power levels in between those listed in the datasheet can be used.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1964#issuecomment-272119146,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","Yes! I agree with @nvt about this, that's why I wanted to have a reference listed somewhere.  If you modify the PR and include the other values, I would be ready to merge.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1964,2016-12-02T07:25:07Z,,2017-01-13T14:37:37Z,OPEN,False,1,0,1,https://github.com/kaleemullah360,Added TX  Level 5 in CC2420,1,[],https://github.com/contiki-os/contiki/pull/1964,https://github.com/kaleemullah360,12,https://github.com/contiki-os/contiki/pull/1964#issuecomment-272455878,"In Zolertia Z1, TI CC2420 Radio Transceiver, there are different level of TX power ranges defined in dev/cc2420/cc2420.c:105.
So added PA_Level 5 considering it important for learner like me. Issue #1937
also with reference of this table, computed by some other guy.



Power (dBm)
PA_LEVEL
Power (mW)




0
31
1.0000


-0.0914
30
0.9792


-0.3008
29
0.9331


-0.6099
28
0.8690


-1.0000
27
0.7943


-1.4526
26
0.7157


-1.9492
25
0.6384


-2.4711
24
0.5661


-3.0000
23
0.5012


-3.5201
22
0.4446


-4.0275
21
0.3956


-4.5212
20
0.3531


-5.0000
19
0.3162


-5.4670
18
0.2840


-5.9408
17
0.2546


-6.4442
16
0.2268


-7.0000
15
0.1995


-7.6277
14
0.1727


-8.3343
13
0.1467


-9.1238
12
0.1224


-10.0000
11
0.1000


-10.9750
10
0.0799


-12.0970
9
0.0617


-13.4200
8
0.0455


-15.0000
7
0.0316


-16.8930
6
0.0205


-19.1530
5
0.0122


-21.8370
4
0.0066


-25.0000
3
0.0032


-28.6970
2
0.0013


-32.9840
1
0.0005


-37.9170
0
0.0002","@alignan , I found that table reference. [Tinyos-help] Output Power levels CC2420
We can add all the listed values. cause I observed difference in TX level 3 with 5 with 7,
I've performed experiments at different levels due to distance limits.
PA_Level Table Reference
The PA-Level Table listed at the end of page.
Power (dBm)	

0	-0.0914	-0.3008	-0.6099	-1.0000	-1.4526	-1.9492	-2.4711	-3.0000	-3.5201	-4.0275	-4.5212	-5.0000	-5.4670	-5.9408	-6.4442	-7.0000	-7.6277	-8.3343	-9.1238	-10.0000	-10.9750	-12.0970	-13.4200	-15.0000	-16.8930	-19.1530	-21.8370	-25.0000	-28.6970	-32.9840	-37.9170

PA_LEVEL	

31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0

Power (mW)	

1.0000	0.9792	0.9331	0.8690	0.7943	0.7157	0.6384	0.5661	0.5012	0.4446	0.3956	0.3531	0.3162	0.2840	0.2546	0.2268	0.1995	0.1727	0.1467	0.1224	0.1000	0.0799	0.0617	0.0455	0.0316	0.0205	0.0122	0.0066	0.0032	0.0013	0.0005	0.0002",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1966,2016-12-02T15:53:37Z,2016-12-03T11:13:40Z,2016-12-03T11:25:05Z,MERGED,True,4,0,1,https://github.com/yatch,travis: workaround for the Java issue on Travis CI,1,[],https://github.com/contiki-os/contiki/pull/1966,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1966,"The Travis test has been failing since 1st of December. https://travis-ci.org/contiki-os/contiki/builds
I found the warning and error in a Travis Job log shown below, that appeared in failed tests:
(snip)
    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.7
    [javac] 1 warning
(snip)
Running test 01-cooja-http-socket-50 with random Seed 1: Exception in thread ""main"" java.lang.UnsupportedClassVersionError: org/contikios/cooja/Cooja : Unsupported major.minor version 52.0

I assume this issue is related to travis-ci/travis-ci#6928. This PR applies the workaround to make Travis green.
Related Issues:
#1965
travis-ci/travis-ci#6928","The Travis test has been failing since 1st of December. https://travis-ci.org/contiki-os/contiki/builds
I found the warning and error in a Travis Job log shown below, that appeared in failed tests:
(snip)
    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.7
    [javac] 1 warning
(snip)
Running test 01-cooja-http-socket-50 with random Seed 1: Exception in thread ""main"" java.lang.UnsupportedClassVersionError: org/contikios/cooja/Cooja : Unsupported major.minor version 52.0

I assume this issue is related to travis-ci/travis-ci#6928. This PR applies the workaround to make Travis green.
Related Issues:
#1965
travis-ci/travis-ci#6928",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1966,2016-12-02T15:53:37Z,2016-12-03T11:13:40Z,2016-12-03T11:25:05Z,MERGED,True,4,0,1,https://github.com/yatch,travis: workaround for the Java issue on Travis CI,1,[],https://github.com/contiki-os/contiki/pull/1966,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1966#issuecomment-264632723,"The Travis test has been failing since 1st of December. https://travis-ci.org/contiki-os/contiki/builds
I found the warning and error in a Travis Job log shown below, that appeared in failed tests:
(snip)
    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.7
    [javac] 1 warning
(snip)
Running test 01-cooja-http-socket-50 with random Seed 1: Exception in thread ""main"" java.lang.UnsupportedClassVersionError: org/contikios/cooja/Cooja : Unsupported major.minor version 52.0

I assume this issue is related to travis-ci/travis-ci#6928. This PR applies the workaround to make Travis green.
Related Issues:
#1965
travis-ci/travis-ci#6928",thanks! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1966,2016-12-02T15:53:37Z,2016-12-03T11:13:40Z,2016-12-03T11:25:05Z,MERGED,True,4,0,1,https://github.com/yatch,travis: workaround for the Java issue on Travis CI,1,[],https://github.com/contiki-os/contiki/pull/1966,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1966#issuecomment-264632949,"The Travis test has been failing since 1st of December. https://travis-ci.org/contiki-os/contiki/builds
I found the warning and error in a Travis Job log shown below, that appeared in failed tests:
(snip)
    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.7
    [javac] 1 warning
(snip)
Running test 01-cooja-http-socket-50 with random Seed 1: Exception in thread ""main"" java.lang.UnsupportedClassVersionError: org/contikios/cooja/Cooja : Unsupported major.minor version 52.0

I assume this issue is related to travis-ci/travis-ci#6928. This PR applies the workaround to make Travis green.
Related Issues:
#1965
travis-ci/travis-ci#6928",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1967,2016-12-02T17:02:56Z,2016-12-04T11:46:07Z,2016-12-04T11:46:07Z,MERGED,True,35,33,9,https://github.com/MohamedSeliem,Fix the leftover mentions of aaaa as a prefix to be UIP_DS6_DEFAULT_PREFIX (now fd00),3,['enhancement'],https://github.com/contiki-os/contiki/pull/1967,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1967,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1967,2016-12-02T17:02:56Z,2016-12-04T11:46:07Z,2016-12-04T11:46:07Z,MERGED,True,35,33,9,https://github.com/MohamedSeliem,Fix the leftover mentions of aaaa as a prefix to be UIP_DS6_DEFAULT_PREFIX (now fd00),3,['enhancement'],https://github.com/contiki-os/contiki/pull/1967,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1967#issuecomment-264511649,,üëç  as soon as Travis is green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1967,2016-12-02T17:02:56Z,2016-12-04T11:46:07Z,2016-12-04T11:46:07Z,MERGED,True,35,33,9,https://github.com/MohamedSeliem,Fix the leftover mentions of aaaa as a prefix to be UIP_DS6_DEFAULT_PREFIX (now fd00),3,['enhancement'],https://github.com/contiki-os/contiki/pull/1967,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1967#issuecomment-264515605,,"@simonduq @alignan
in cpu/native/net/tapdev6.c
addreq6.ifra_addr.sin6_addr.__u6_addr.__u6_addr16[0] = UIP_HTONS(0xAAAA);
msg.dst.sin6_addr.__u6_addr.__u6_addr16[0] = UIP_HTONS(0xAAAA);
in cpu/mc1322x/tests/autoack-rx.c
*MACA_MACPANID = 0xaaaa;
i think i should fix these too, what do u think??",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1967,2016-12-02T17:02:56Z,2016-12-04T11:46:07Z,2016-12-04T11:46:07Z,MERGED,True,35,33,9,https://github.com/MohamedSeliem,Fix the leftover mentions of aaaa as a prefix to be UIP_DS6_DEFAULT_PREFIX (now fd00),3,['enhancement'],https://github.com/contiki-os/contiki/pull/1967,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1967#issuecomment-264633979,,please rebase now that #1965 is resolved,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1967,2016-12-02T17:02:56Z,2016-12-04T11:46:07Z,2016-12-04T11:46:07Z,MERGED,True,35,33,9,https://github.com/MohamedSeliem,Fix the leftover mentions of aaaa as a prefix to be UIP_DS6_DEFAULT_PREFIX (now fd00),3,['enhancement'],https://github.com/contiki-os/contiki/pull/1967,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/1967#issuecomment-264667658,,And also squash the two commits with the same commit message,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1967,2016-12-02T17:02:56Z,2016-12-04T11:46:07Z,2016-12-04T11:46:07Z,MERGED,True,35,33,9,https://github.com/MohamedSeliem,Fix the leftover mentions of aaaa as a prefix to be UIP_DS6_DEFAULT_PREFIX (now fd00),3,['enhancement'],https://github.com/contiki-os/contiki/pull/1967,https://github.com/MohamedSeliem,6,https://github.com/contiki-os/contiki/pull/1967#issuecomment-264678145,,üëç done.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1969,2016-12-03T23:27:02Z,2016-12-04T11:45:04Z,2016-12-04T13:41:59Z,MERGED,True,6,6,2,https://github.com/g-oikonomou,Fix minor typo,1,['Core'],https://github.com/contiki-os/contiki/pull/1969,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1969,"The correct spelling of ""DETECTECT"" is ""DETECTED"" :)","The correct spelling of ""DETECTECT"" is ""DETECTED"" :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1969,2016-12-03T23:27:02Z,2016-12-04T11:45:04Z,2016-12-04T13:41:59Z,MERGED,True,6,6,2,https://github.com/g-oikonomou,Fix minor typo,1,['Core'],https://github.com/contiki-os/contiki/pull/1969,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1969#issuecomment-264699053,"The correct spelling of ""DETECTECT"" is ""DETECTED"" :)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1971,2016-12-04T16:20:14Z,,2017-03-18T14:25:20Z,OPEN,False,3,3,3,https://github.com/MohamedSeliem,Fix wrong GPIO port direction for SPI master,1,[],https://github.com/contiki-os/contiki/pull/1971,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1971,"This is  a bug, although apparently a harmless one in typical conditions (as the SPI bus still works).

the MOSI and SCK pins are actually set as outputs, even though the code appears to say something else.","This is  a bug, although apparently a harmless one in typical conditions (as the SPI bus still works).

the MOSI and SCK pins are actually set as outputs, even though the code appears to say something else.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1971,2016-12-04T16:20:14Z,,2017-03-18T14:25:20Z,OPEN,False,3,3,3,https://github.com/MohamedSeliem,Fix wrong GPIO port direction for SPI master,1,[],https://github.com/contiki-os/contiki/pull/1971,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1971#issuecomment-271791643,"This is  a bug, although apparently a harmless one in typical conditions (as the SPI bus still works).

the MOSI and SCK pins are actually set as outputs, even though the code appears to say something else.",@g-oikonomou can you look at this please.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1971,2016-12-04T16:20:14Z,,2017-03-18T14:25:20Z,OPEN,False,3,3,3,https://github.com/MohamedSeliem,Fix wrong GPIO port direction for SPI master,1,[],https://github.com/contiki-os/contiki/pull/1971,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1971#issuecomment-287500125,"This is  a bug, although apparently a harmless one in typical conditions (as the SPI bus still works).

the MOSI and SCK pins are actually set as outputs, even though the code appears to say something else.","@g-oikonomou please give me your feed back on this,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1971,2016-12-04T16:20:14Z,,2017-03-18T14:25:20Z,OPEN,False,3,3,3,https://github.com/MohamedSeliem,Fix wrong GPIO port direction for SPI master,1,[],https://github.com/contiki-os/contiki/pull/1971,https://github.com/atiselsts,4,https://github.com/contiki-os/contiki/pull/1971#issuecomment-287536961,"This is  a bug, although apparently a harmless one in typical conditions (as the SPI bus still works).

the MOSI and SCK pins are actually set as outputs, even though the code appears to say something else.","@MohamedSeliem it's not as simple.
First of all, to me it looks like the code on Sky is already correct in terms of functionality, it's just the names of the pins that are wrong (a double bug cancelling out?). See this discussion: https://sourceforge.net/p/contiki/mailman/message/33197414/
Second, this code has been in Contiki for so long and so widely used, I would be very careful when applying this change - even though it's correct, it may still break someones system in an obscure way.
On the other hand, this issue crops up periodically (see also #1929) and I think it's embarrassing to have such a problem in a very core part of Contiki.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1971,2016-12-04T16:20:14Z,,2017-03-18T14:25:20Z,OPEN,False,3,3,3,https://github.com/MohamedSeliem,Fix wrong GPIO port direction for SPI master,1,[],https://github.com/contiki-os/contiki/pull/1971,https://github.com/MohamedSeliem,5,https://github.com/contiki-os/contiki/pull/1971#issuecomment-287549512,"This is  a bug, although apparently a harmless one in typical conditions (as the SPI bus still works).

the MOSI and SCK pins are actually set as outputs, even though the code appears to say something else.",@atiselsts thanks for this insightful response. üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1972,2016-12-04T17:03:41Z,2017-03-18T13:50:53Z,2017-03-18T14:07:02Z,MERGED,True,4,4,1,https://github.com/MohamedSeliem,update httpd_cgi to enable the compilation of webserver-ipv6 example,1,[],https://github.com/contiki-os/contiki/pull/1972,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/1972,"this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô","this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1972,2016-12-04T17:03:41Z,2017-03-18T13:50:53Z,2017-03-18T14:07:02Z,MERGED,True,4,4,1,https://github.com/MohamedSeliem,update httpd_cgi to enable the compilation of webserver-ipv6 example,1,[],https://github.com/contiki-os/contiki/pull/1972,https://github.com/MohamedSeliem,2,https://github.com/contiki-os/contiki/pull/1972#issuecomment-264797111,"this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô",@g-oikonomou can you look at this please.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1972,2016-12-04T17:03:41Z,2017-03-18T13:50:53Z,2017-03-18T14:07:02Z,MERGED,True,4,4,1,https://github.com/MohamedSeliem,update httpd_cgi to enable the compilation of webserver-ipv6 example,1,[],https://github.com/contiki-os/contiki/pull/1972,https://github.com/MohamedSeliem,3,https://github.com/contiki-os/contiki/pull/1972#issuecomment-287500065,"this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô","@g-oikonomou please give me your feed back on this,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1972,2016-12-04T17:03:41Z,2017-03-18T13:50:53Z,2017-03-18T14:07:02Z,MERGED,True,4,4,1,https://github.com/MohamedSeliem,update httpd_cgi to enable the compilation of webserver-ipv6 example,1,[],https://github.com/contiki-os/contiki/pull/1972,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1972#issuecomment-287547577,"this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô",Fixes #1541,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1972,2016-12-04T17:03:41Z,2017-03-18T13:50:53Z,2017-03-18T14:07:02Z,MERGED,True,4,4,1,https://github.com/MohamedSeliem,update httpd_cgi to enable the compilation of webserver-ipv6 example,1,[],https://github.com/contiki-os/contiki/pull/1972,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/1972#issuecomment-287547901,"this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô","Looks like I jumped the gun on this one.
Removing those i variables causes new errors. I'm reverting this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1972,2016-12-04T17:03:41Z,2017-03-18T13:50:53Z,2017-03-18T14:07:02Z,MERGED,True,4,4,1,https://github.com/MohamedSeliem,update httpd_cgi to enable the compilation of webserver-ipv6 example,1,[],https://github.com/contiki-os/contiki/pull/1972,https://github.com/MohamedSeliem,6,https://github.com/contiki-os/contiki/pull/1972#issuecomment-287548509,"this simple change fixes the bug reported in #1541.
../../apps/webserver/httpd.h:63:9: note: expected ‚Äòuip_ip6addr_t‚Äô but argument is of type ‚Äòunion uip_ipaddr_t *‚Äô","Removing  i variable from make_addresses() function that makes the error.
This was not present when pull request had created.
Thanks for reverting it back. üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1973,2016-12-04T19:41:49Z,2016-12-25T18:42:19Z,2017-03-18T13:19:33Z,MERGED,True,41,1,6,https://github.com/g-oikonomou,Add sensniff as a submodule,5,"['enhancement', 'timed out', 'tools']",https://github.com/contiki-os/contiki/pull/1973,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/1973,"This pull adds sensniff as a submodule.
This allows us to invoke the script with the correct command line arguments (e.g. baudrate) by running make sniff from inside the example dir.
This pull also:

Specifies correct baudrate for jn516x
Specifies default baudrate for CC2538DK when not using native USB
Extends documentation

I'm not feeling too strongly about this, but it has been asked of me so I thought I'd knock something together. What do you think?","This pull adds sensniff as a submodule.
This allows us to invoke the script with the correct command line arguments (e.g. baudrate) by running make sniff from inside the example dir.
This pull also:

Specifies correct baudrate for jn516x
Specifies default baudrate for CC2538DK when not using native USB
Extends documentation

I'm not feeling too strongly about this, but it has been asked of me so I thought I'd knock something together. What do you think?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1973,2016-12-04T19:41:49Z,2016-12-25T18:42:19Z,2017-03-18T13:19:33Z,MERGED,True,41,1,6,https://github.com/g-oikonomou,Add sensniff as a submodule,5,"['enhancement', 'timed out', 'tools']",https://github.com/contiki-os/contiki/pull/1973,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1973#issuecomment-264737214,"This pull adds sensniff as a submodule.
This allows us to invoke the script with the correct command line arguments (e.g. baudrate) by running make sniff from inside the example dir.
This pull also:

Specifies correct baudrate for jn516x
Specifies default baudrate for CC2538DK when not using native USB
Extends documentation

I'm not feeling too strongly about this, but it has been asked of me so I thought I'd knock something together. What do you think?","I'm happy to finally have this as a sub-module üëç
Perhaps adding the --non-interactive flag?
Setting a timeout to merge, if anyone wants to merge sooner or provide additional feedback it would be most welcomed",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1973,2016-12-04T19:41:49Z,2016-12-25T18:42:19Z,2017-03-18T13:19:33Z,MERGED,True,41,1,6,https://github.com/g-oikonomou,Add sensniff as a submodule,5,"['enhancement', 'timed out', 'tools']",https://github.com/contiki-os/contiki/pull/1973,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1973#issuecomment-266475398,"This pull adds sensniff as a submodule.
This allows us to invoke the script with the correct command line arguments (e.g. baudrate) by running make sniff from inside the example dir.
This pull also:

Specifies correct baudrate for jn516x
Specifies default baudrate for CC2538DK when not using native USB
Extends documentation

I'm not feeling too strongly about this, but it has been asked of me so I thought I'd knock something together. What do you think?","Couldn't it be added directly to the tools directory since the firmware part is already in the source tree? Having it as a module would be fine too, however.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1973,2016-12-04T19:41:49Z,2016-12-25T18:42:19Z,2017-03-18T13:19:33Z,MERGED,True,41,1,6,https://github.com/g-oikonomou,Add sensniff as a submodule,5,"['enhancement', 'timed out', 'tools']",https://github.com/contiki-os/contiki/pull/1973,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/1973#issuecomment-267490054,"This pull adds sensniff as a submodule.
This allows us to invoke the script with the correct command line arguments (e.g. baudrate) by running make sniff from inside the example dir.
This pull also:

Specifies correct baudrate for jn516x
Specifies default baudrate for CC2538DK when not using native USB
Extends documentation

I'm not feeling too strongly about this, but it has been asked of me so I thought I'd knock something together. What do you think?","Nicolas, I do strongly prefer using a submodule here so that users can easily (locally) checkout newer/older versions from the origin repo (e.g. for debugging) without having to manually copy files between repos.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1976,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1976#issuecomment-264954198,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1976#issuecomment-264954755,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'",related: any thought on that one? javax.swing.plaf.BorderUIResource cannot be cast to java.awt.Color,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1976#issuecomment-265001004,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","Unfortunately, I have no idea on javax.swing.plaf.BorderUIResource cannot be cast to java.awt.Color. In fact, I know little about Java... (>_<)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266248245,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","@simonduq See this one, #1987 !! I've opened a PR on a related issue with javax.swing.plaf.BorderUIResource cannot be cast to java.awt.Color :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266409032,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'",thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266409485,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","wow I forgot that PR was actually out there, unmerged :p",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266410444,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","ah ok I see it is a new one, now I'm confused. I was recalling another PR from @joakimeriksson fixing a similar Travis Cooja bug",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/yatch,9,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266411726,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","Yes, it's new; @joakimeriksson opened #1987 after exchange some messages on my PR.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266412984,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'","Right, I see. Great that you're keeping track also as ""related PRs/issues"" :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/simonduq,11,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266413220,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'",setting a timeout for merging this one,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1976,2016-12-05T17:10:57Z,2016-12-12T16:06:16Z,2016-12-12T16:20:51Z,MERGED,True,1,1,1,https://github.com/yatch,"Resolve  ""unmatched single quote"" error in Travis CI failed tests",1,['timed out'],https://github.com/contiki-os/contiki/pull/1976,https://github.com/nvt,12,https://github.com/contiki-os/contiki/pull/1976#issuecomment-266470651,"In some failed tests, e.g. this one, the ""unmatched single quote"" error by xargs is found:
==== Files used for simulation (sha1sum) ====
xargs: unmatched single quote; by default quotes are special to xargs unless you use the -0 option
FAIL ‡≤†_‡≤†

This error is caused by a missing single quotation mark at the end of the file path of a Cooja image in Cooja.log. Here is an example:
[17:43:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype483.cooja

This PR adds the missing single quotation mark as shown below:
[17:49:16 - main] [ContikiMoteType.java:404] [INFO] - (snip) code/obj_cooja/mtype740.cooja'",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1978,2016-12-06T11:43:25Z,2016-12-23T17:31:48Z,2016-12-25T13:21:44Z,MERGED,True,22,2,1,https://github.com/makrog,Added NullRDC and ContikiMAC timings for Zolertia RE-Mote.,2,['enhancement'],https://github.com/contiki-os/contiki/pull/1978,https://github.com/makrog,1,https://github.com/contiki-os/contiki/pull/1978,CC1200 SubGHz 50 Kbps mode.,CC1200 SubGHz 50 Kbps mode.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1978,2016-12-06T11:43:25Z,2016-12-23T17:31:48Z,2016-12-25T13:21:44Z,MERGED,True,22,2,1,https://github.com/makrog,Added NullRDC and ContikiMAC timings for Zolertia RE-Mote.,2,['enhancement'],https://github.com/contiki-os/contiki/pull/1978,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/1978#issuecomment-265818439,CC1200 SubGHz 50 Kbps mode.,Thanks for the contribution and testing!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1978,2016-12-06T11:43:25Z,2016-12-23T17:31:48Z,2016-12-25T13:21:44Z,MERGED,True,22,2,1,https://github.com/makrog,Added NullRDC and ContikiMAC timings for Zolertia RE-Mote.,2,['enhancement'],https://github.com/contiki-os/contiki/pull/1978,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1978#issuecomment-269021999,CC1200 SubGHz 50 Kbps mode.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1978,2016-12-06T11:43:25Z,2016-12-23T17:31:48Z,2016-12-25T13:21:44Z,MERGED,True,22,2,1,https://github.com/makrog,Added NullRDC and ContikiMAC timings for Zolertia RE-Mote.,2,['enhancement'],https://github.com/contiki-os/contiki/pull/1978,https://github.com/makrog,4,https://github.com/contiki-os/contiki/pull/1978#issuecomment-269122508,CC1200 SubGHz 50 Kbps mode.,Alright!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1981,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",True,{'THUMBS_UP': ['https://github.com/algoragit']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/1981#issuecomment-267846131,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",@simonduq Thank you for the review. I guess I'll have time to work on this PR the latter half of this week..!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/1981#issuecomment-270908554,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","@simonduq Just pushed the snapshot of the branch including updates to address your comments. Now it uses nbr-table to maintain sixp_nbr. In addition, it does not use any structure to parse or create a 6P packet.
Thank you for your review. I'll test this code with implementing SF0.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1981#issuecomment-270913390,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",Please let me know when this is ready for a final review.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/1981#issuecomment-270913646,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",@simonduq Sure!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/remyleone,6,https://github.com/contiki-os/contiki/pull/1981#issuecomment-284719282,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",Me too :-) I want to perform 6P interop testing between Contiki and OpenWSN.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,7,https://github.com/contiki-os/contiki/pull/1981#issuecomment-284960046,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","@SIben I'll write here something to share, although I've been too busy to write 6P code lately...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1981#issuecomment-284975676,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","My recommendation is not to set the bar high when it comes to more features: stick to what you have now, when you're happy with the code quality I'll review and once this is merged more features can be added later. Else the PR might become huge and take many months to get merged..",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,9,https://github.com/contiki-os/contiki/pull/1981#issuecomment-285234330,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",@simonduq Thank you for the comment! I got it.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,10,https://github.com/contiki-os/contiki/pull/1981#issuecomment-296240097,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","I'm sorry that it takes so long... I think I can update the branch next week. Basically, this update doesn't have any functional additions but only refactoring things. Stay tuned... üìª",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,11,https://github.com/contiki-os/contiki/pull/1981#issuecomment-299775632,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","I think it's ready for code review. Major changes since the last push, January are:

API clean-ups
Change file structure; introducing sixp-pkt.[ch], sixp-nbr.[ch], sixp-trans.[ch], and sixtop-conf.h
Introduce regression tests for the 6top and 6P implementation (regression-tests/26-6tisch)
Bugfix; append Payload Termination IE after 6top IE Content (follows https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol-03#section-4.2.1)
Add nbr_table_is_register(). This change, a78fbe8, would be a separate PR.

sf-simple is implemented under examples/ipv6/rpl-tsch-sixtop/ and works as before.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1981#issuecomment-300083699,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",Wonderful! Am having busy days at the moment but will find the time to review eventually. BTW there seems to be a conflict with master.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,13,https://github.com/contiki-os/contiki/pull/1981#issuecomment-300085443,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","@simonduq Thanks. On my side, super busy days have gone üòÑ
With regard to the conflict, I'm aware of it and, of course, it needs to be resolved. I may push some minor changes in near future. In such a case, I won't do force-push so that we can see what changes are made after ""ready for review"".
I'm working on draft-04 support right now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/sumanpanchal,14,https://github.com/contiki-os/contiki/pull/1981#issuecomment-302665883,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0",Simulation error with three node network.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/yatch,15,https://github.com/contiki-os/contiki/pull/1981#issuecomment-303613085,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","@sumanpanchal Thank you for your testing! That example, rpl-tsch-sixtop, supports only a two-node network. It's not been tested with other setting such as having three nodes.
It seems invalid memory access occurred in your test; ""Assertion failed"" messages in the log could help, by the way.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1981,2016-12-08T13:37:24Z,,2017-07-12T21:37:24Z,OPEN,False,10231,14,44,https://github.com/yatch,6TiSCH Operation Sublayer (6top),39,[],https://github.com/contiki-os/contiki/pull/1981,https://github.com/awolokita,16,https://github.com/contiki-os/contiki/pull/1981#issuecomment-314904650,"Summary
This PR aims to add 6TiSCH Operation Sublayer (6top) on Contiki.
The original work was done by Shalu Rajendran and Lijo Thomas. Some enhancements have been made, including supporting draft-03 of 6P.
The status of code is work-in-progress. Please note that the code structures or APIs may be changed. As a matter of fact, sixtop_sf_t is going to have new members, sixtop.h will have new wrapper APIs for TSCH slotframe and link operations.
At this moment, there is no Schedule Function (SF) shipped with these changes. You may have to implement your own SF for dynamic cell allocation. Currently, I'm implementing SF0 on this code base.
While there are many commits remaining on the branch, they would be squashed at some point.
How to Play
An example code is provided under example/ipv6/rpl-tsch-sixtop:

rpl-tsch-sixtop-z1.csc: a simulation file; a good place to start
sf-simple.[ch]: a sample/simple SF implementation (no cell/bandwitdh estimation)
node-sixtop.c: a node process using sf-simple to allocate/deallocate cells

References

The original PR by @shalurajendran : #1898
IETF 6TiSCH Working Group: https://datatracker.ietf.org/wg/6tisch
6top Protocol (6P): https://tools.ietf.org/html/draft-ietf-6tisch-6top-protocol
6top SF0: https://tools.ietf.org/html/draft-ietf-6tisch-6top-sf0","Hi @yatch,thanks for all your work into 6top. This req has been quiet for a little while now. Are you still working on this? It would be fantastic to have this functionality!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1982,2016-12-08T18:46:26Z,2016-12-09T15:09:32Z,2016-12-09T15:09:32Z,MERGED,True,0,2,1,https://github.com/nvt,Always enable the I/O semantics function in Coffee.,1,[],https://github.com/contiki-os/contiki/pull/1982,https://github.com/nvt,1,https://github.com/contiki-os/contiki/pull/1982,There is no good reason to leave out this function by default anymore.,There is no good reason to leave out this function by default anymore.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1984,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1984#issuecomment-274026390,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400",Is nbr_table_update_lladdr still needed then?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/1984#issuecomment-274041086,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","The NULL entry in the neighbor table and the fact that there could be only a single instance of a MAC address have many unexpected consequences and it's great to see them slowly solved.
Currently I'm testing your code with more complex setup and and still have a few problems (that are also present in current Contiki). They all boils down to the fact that an IPv6 interface has several IP addresses, in most common setup two : the link local address and the global address.
What I have observed is sometimes two nodes first exchange with their link-local addresses, so in the neighbor table the MAC address is associated with the link-local. However, when their gobal address is tentatively used the address resolution fails.
In current Contiki it fails when the the NA is received, nbr_table_update_lladdr() detect a duplicate entry and therefore the NA is dropped and the neighbor entry for the global address stays associated with the NULL MAC address. This ends up with an endless exchange of NS/NA messages.
With the current PR, this still fails but for different reasons : The NS/NA exchange is correctly done for the global address, but the entry in the neighbor table stays in INCOMPLETE state and so can not be used. This is due to the condition of unicity in uip_ds6_nbr_update_lladdr(). In a neighbor with the same MAC address exists, we abort the table update.
As modifying the neighbor table to support more than one entry with the same MAC is not trivial, I tried a simpler workaround : Instead of aborting the update in uip_ds6_nbr_update_lladdr() when a duplicate is detected, I instead removed the duplicated entry before updating the new one. The rationale is that if we can not store all the IP addresses related to a MAC address, at least keep the last used one as it's probably the address the node will use for next messages. This workaround solves the issue and does not seems to have unwanted side effect, but more testing would be welcome.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1984#issuecomment-274050488,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","@simonduq That's a good question. nbr_table_update_lladdr is not needed any more, I guess. No caller of the function is found in this branch. If I miss something, I would get a linker error anyway. I'll remove the function later.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/1984#issuecomment-274254169,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","Updated the branch.

extend the regression test by adding ping tests to global IPv6 addresses
remove nbr_table_update_lladdr()

@laurentderu
Thank you for your detailed feedback! I've updated the regression test. I believe it reproduces the issue you pointed out. Here is an excerpt of a log file generated by the test with enabling debug print.
01:28.943       ID:2    Adding neighbor with ip addr fd00::201:1:1:1 link addr (NULL LL addr) state 0
01:28.943       ID:2    Sending NS to ff02::1:ff01:1 from fd00::202:2:2:2 with target address fd00::201:1:1:1
01:28.947       ID:1    Received NS from fd00::202:2:2:2 to ff02::1:ff01:1 with target address fd00::201:1:1:1
01:28.947       ID:1    Adding neighbor with ip addr fd00::202:2:2:2 link addr 00:02:00:02:00:02:00:02 state 2
01:28.947       ID:1    Sending NA to fd00::202:2:2:2 from fd00::201:1:1:1 with target address fd00::201:1:1:1
01:28.947       ID:1    tcpip_ipv6_output: nbr cache entry stale moving to delay
01:28.952       ID:2    Received NA from fd00::201:1:1:1 to fd00::202:2:2:2 with target address fd00::201:1:1:1
01:28.952       ID:2    uip_ds6_nbr_update_lladdr(): new_ll_addr is associated with another IPv6 address

(failed to update the NC for the link-local address)

I have another idea to deal with the issue arose when a link-local address is associated more than one IPv6 address. I'll push another commit later which implements the idea.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1984#issuecomment-275137637,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","@laurentderu It'd be better to discuss how to manage multiple IPv6 addresses for a single link-layer address at a separate PR. So, I removed the code to test ping to global IPv6 addresses from cooja-ping6.js, that is applied in the different branch for the new PR...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/laurentderu,7,https://github.com/contiki-os/contiki/pull/1984#issuecomment-275333837,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","@yatch agreed, this PR otherwise will not converge and get merged.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1984,2016-12-10T02:36:24Z,,2017-02-06T17:53:12Z,OPEN,False,1190,319,11,https://github.com/yatch,Bugfix in Address Resolution / Neighbor Unreachability Detetion,10,[],https://github.com/contiki-os/contiki/pull/1984,https://github.com/yatch,8,https://github.com/contiki-os/contiki/pull/1984#issuecomment-277759425,"Summary
As a result of the address resolution with NS/NA, a Contiki node has a neighbor cache of the REACHABLE state for the peer, the link-layer address of which is the broadcast address or linkaddr_null. This PR resolves this bug.
Test
regression-tests/11-ipv6/22-cooja-ping6.csc provides a test for this bugfix. You can run the test as follows:
$ cd regression-tests/11-ipv6/
$ make 22-cooja-ping6.testlog
Running test 22-cooja-ping6 with random Seed 1: ............. OK
In the simulation, four pairs of IPv6 nodes are generated: ""CSMA"", ""CSMA + IEEE 802.15.4e-2012"", ""TSCH"", and ""RPL"". A node in each pair, called requester, sends a ICMPv6 Echo Request to the other node one time. NS/NA exchange happens if necessary.
The test criteria are

Each requester receives an ICMPv6 Echo Reply from its peer.
Each requester has a neighbor cache for its peer in which a non-broadcast address is registered as a link-layer address.

Here is the summary of node configurations:



Node Type
MAC
Frame Version
RPL




CSMA
CSMA
FRAME802154_IEEE802154_2006
Disabled


CSMA + IEEE 802.15.4e-2012
CSMA
FRAME802154_IEEE802154E_2012
Disabled


TSCH
TSCH
FRAME802154_IEEE802154E_2012
Disabled


RPL
CSMA
FRAME802154_IEEE802154_2006
Enabled



Only ""RPL"" passes the test, others fails on the tip of the master branch. The following is a part of the test log.
14980456 8 ping6 OK - 20 bytes from fe80::207:7:7:7 ttl=64
14980456 8 post-ping: uip_ds6_nbr_get_ll() returns 00:07:00:07:00:07:00:07 for fe80::207:7:7:7
14980456 8 0.8: Contiki>
14988616 2 ping6 OK - 20 bytes from fe80::201:1:1:1 ttl=64
14988616 2 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::201:1:1:1
14988616 2 0.2: Contiki>
14988680 6 ping6 OK - 20 bytes from fe80::205:5:5:5 ttl=64
14988680 6 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::205:5:5:5
14988680 6 0.6: Contiki>
15007392 4 ping6 OK - 20 bytes from fe80::203:3:3:3 ttl=64
15007392 4 post-ping: uip_ds6_nbr_get_ll() returns 00:00:00:00:00:00:00:00 for fe80::203:3:3:3
CSMA:                       NG
CSMA + IEEE 802.15.4e-2012: NG
TSCH:                       NG
RPL:                        OK
TEST FAILED
Fix
There are two essential changes:

make uip_ds6_nbr_refresh_reachable_state() not to change the state of a specified neighbor cache to REACHABLE if its (current) state is INCOMPLETE
use the newly introduced function called uip_ds6_nbr_update_lladdr() to change the link-layer address of a specified neighbor cache instead of nbr_table_update_lladdr()

It seems that uip_ds6_nbr_refresh_reachable_state() is supposed to be used by a protocol other than Neighbor Unreachability Detection (NUD) so that its packet can refresh the neighbor cache state for a peer with REACHABLE. The problem here is, While transition from INCOMPLETE to REACHABLE should be done only by NUD, the function changes the neighbor cache state regardless of its current state. This is one of things to fix. Then, it'll be compliant with the following paragraph in Section 7.3.3, RFC 4861
   When a reachability confirmation is received (either through upper-
   layer advice or a solicited Neighbor Advertisement), an entry's state
   changes to REACHABLE.  The one exception is that upper-layer advice
   has no effect on entries in the INCOMPLETE state (e.g., for which no
   link-layer address is cached).

The other thing is nbr_table_update_lladdr(). This function is called to update the link-layer address of a neighbor cache with a specified address when a solicited NA is received.
Typically, a neighbor cache has the broadcast address, linkaddr_null, as its link-layer address when a NS is being sent. On receiving a solicited NA, the broadcast address is going to be replaced (updated) with a link-layer address stored in the target link-layer address field of the NA. nbr_table_update_lladdr() is called for this purpose, however, it fails because there is a nbr_table entry of the new address for some reason. I suspect sicslowpan_driver.input() installs an entry for the new address before nbr_table_update_lladdr() is called since I saw  a nbr_table entry with the reason of NBR_TABLE_REASON_LINK_STATS in a failed test.
The point is, a neighbor cache should be able to have a new link-layer address even if it's already registered in nbr_table as long as there is no neighbor cache associated with the new address. uip_ds6_nbr_update_lladdr(), which is newly introduced, takes this into account and update the link-layer address of a neighbor cache as expected. This PR replaces nbr_table_update_lladdr() with uip_ds6_nbr_update_lladdr in uip-nd6.c.
Discussion
This is a topic related to this PR; but no change has been made for this.
I don't think uip_process()  is an appropriate place where uip_ds6_nbr_refresh_reachable_state() is called. The IPv6 header of an incoming packet alone does not provide ""forward progress"" on the connection. IPv6 is not an upper-layer protocol of NUD/ICMPv6 in the first place.
I'd say that we should put uip_ds6_nbr_refresh_reachable_state() in TCP, RPL, and other ""upper-layer"" protocols instead of IPv6. A lower-layer protocol, for example, IEEE 802.15.4 may be able to confirm reachability to a neighboring node. However, it is not aware of its upper layer addresses, that is, IPv6 address. Because of that, such a lower-layer protocol cannot be a place for uip_ds6_nbr_refresh_reachable_state(), either.
Related PRs

#1394
#1400","@laurentderu It took longer than I thought. I've created a new PR, #2098, which hopefully solves the issue you pointed out.
Your solution or workaround is reasonable as long as a node doesn't communicate with different IPv6 destinations at the same time which are associated with an identical link-layer address. A good thing is it's simple.
My idea was registering a peer IPv6 address as an IPv6 routing entry if there is another IPv6 address with the same link-layer address in the neighbor cache. The destination address of the routing entry is the peer IPv6 address, and the next-hop address is the address in the neighbor cache. A drawback of this idea is we cannot track the NUD state of peer IPv6 addresses registered in the routing table.
So, I decided to try the ""not-trivial"" thing. üòÑ

As modifying the neighbor table to support more than one entry with the same MAC is not trivial, I tried a simpler workaround

As I mentioned before, tests with ping to global IPv6 addresses are introduced at the new PR. Your comments are very welcome!!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1986,2016-12-10T23:14:46Z,2016-12-11T20:59:15Z,2016-12-15T11:33:16Z,CLOSED,False,35,4,1,https://github.com/yatch,"Attempt to resolve Travis failure by ""java.lang.ClassCastException""",2,[],https://github.com/contiki-os/contiki/pull/1986,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1986,"Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment","Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1986,2016-12-10T23:14:46Z,2016-12-11T20:59:15Z,2016-12-15T11:33:16Z,CLOSED,False,35,4,1,https://github.com/yatch,"Attempt to resolve Travis failure by ""java.lang.ClassCastException""",2,[],https://github.com/contiki-os/contiki/pull/1986,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1986#issuecomment-266276195,"Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment","Hi. The idea with the MessageListText and MessageListUI was to avoid ever getting the UI classes (Swing, etc) when we run in travis. Somehow I did not fix this fully last time. But I will take a look and see if I can improve the code so that there will never be any swing code active during Travis tests. When COOJA runs without UI there should be no Swing active at all so I think we should aim to fix that rather to ensure that. I will try to dig into this ASAP - hopefully sometime next week. Is there a consistent way to trigger this? Or is it at ""random""?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1986,2016-12-10T23:14:46Z,2016-12-11T20:59:15Z,2016-12-15T11:33:16Z,CLOSED,False,35,4,1,https://github.com/yatch,"Attempt to resolve Travis failure by ""java.lang.ClassCastException""",2,[],https://github.com/contiki-os/contiki/pull/1986,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/1986#issuecomment-266279252,"Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment","@joakimeriksson Thanks for your comment!! Unfortunately, there is no explicit trigger to this issue as far as I know...
#1638 must be what you said ""last time."" I put the reference to the merged PR in this PR message.  Ah, we should leverage visAvaiable passed to configureAndInit() method of ContikiMoteType class.
[ContikiMoteType.java]
 229   @Override
 230   public boolean configureAndInit(Container parentContainer, Simulation simulation,
 231                                   boolean visAvailable) throws MoteTypeCreationException {
 232     myConfig = simulation.getCooja().getProjectConfig().clone();
 233
 234     if (visAvailable) {
(snip)
 247     } else {
(snip)
 363     }
 364
 365     /* Load compiled library */
 366     doInit();
 367     return true;
 368   }
CoreComm::compileSourceFile is called through doInit() shown above, by the way.

I will try to dig into this ASAP - hopefully sometime next week.

Wow... But, take your time ;-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1986,2016-12-10T23:14:46Z,2016-12-11T20:59:15Z,2016-12-15T11:33:16Z,CLOSED,False,35,4,1,https://github.com/yatch,"Attempt to resolve Travis failure by ""java.lang.ClassCastException""",2,[],https://github.com/contiki-os/contiki/pull/1986,https://github.com/joakimeriksson,4,https://github.com/contiki-os/contiki/pull/1986#issuecomment-266280393,"Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment","No I guess there is not solid trigger, but since I think we know what cause it. I will take a round of searching for any part of the code that might still have the Swing version active (e.g. without the UI check).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1986,2016-12-10T23:14:46Z,2016-12-11T20:59:15Z,2016-12-15T11:33:16Z,CLOSED,False,35,4,1,https://github.com/yatch,"Attempt to resolve Travis failure by ""java.lang.ClassCastException""",2,[],https://github.com/contiki-os/contiki/pull/1986,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/1986#issuecomment-266306601,"Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment",I did a quick pass now - and have submitted another PR that should make COOJA not use Message List UI when being headless or the -nogui parameter.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1986,2016-12-10T23:14:46Z,2016-12-11T20:59:15Z,2016-12-15T11:33:16Z,CLOSED,False,35,4,1,https://github.com/yatch,"Attempt to resolve Travis failure by ""java.lang.ClassCastException""",2,[],https://github.com/contiki-os/contiki/pull/1986,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1986#issuecomment-266307418,"Issue
Travis failures by java.lang.ClassCastException have been experienced randomly. This is a Travis job which failed with the exception. Here is an excerpt of the log.
Contiki library '/home/travis/build/contiki-os/contiki/regression-tests/12-rpl/code/obj_cooja/mtype280.cooja
FATAL [main] (Cooja.java:1337) - Exception when loading simulation: 
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: javax.swing.plaf.BorderUIResource cannot be cast to java.lang.Boolean
(snip)
	at org.contikios.cooja.dialogs.MessageListUI.<init>(MessageListUI.java:85)
	at org.contikios.cooja.CoreComm.compileSourceFile(CoreComm.java:207)
	at org.contikios.cooja.CoreComm.createCoreComm(CoreComm.java:328)
	at org.contikios.cooja.contikimote.ContikiMoteType.doInit(ContikiMoteType.java:405)
	at org.contikios.cooja.contikimote.ContikiMoteType.configureAndInit(ContikiMoteType.java:366)
	at org.contikios.cooja.contikimote.ContikiMoteType.setConfigXML(ContikiMoteType.java:1333)
	at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:691)
	at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3431)
	... 3 more
What the Internet told me
I found a post about a similar situation on Stack Overflow. The best answer says the issue could be caused by improper handling of the Swing threading. Further googling gave me other helpful articles listed below. The point is, any operation on a Swing object should be done in Event Dispatcher Thread.

http://bugs.java.com/view_bug.do?bug_id=6785663
http://stackoverflow.com/questions/26834078/how-to-initialize-gui-objects-in-a-thread-safe-manner-in-java-swing
https://docs.oracle.com/javase/tutorial/uiswing/concurrency/initial.html
http://javarevisited.blogspot.ch/2011/09/invokeandwait-invokelater-swing-example.html

Possible Cause and Proposed Change
At line 207 of tools/cooja/java/org/contikios/cooja/CoreComm.java, an instance of MessageListUI, a sub class of a Swing component, is created in the current thread. This might be wrong according to the web articles.
 197   /**
 198    * Compiles Java class.
 199    *
 200    * @param className
 201    *          Java class name (without extension)
 202    * @throws MoteTypeCreationException
 203    *           If Java class compilation error occurs
 204    */
 205   public static void compileSourceFile(String className)
 206       throws MoteTypeCreationException {
 207     MessageListUI compilationOutput = new MessageListUI();
 208     OutputStream compilationStandardStream = compilationOutput
 209         .getInputStream(MessageListUI.NORMAL);
 210     OutputStream compilationErrorStream = compilationOutput
 211         .getInputStream(MessageList.ERROR);
Since operations on the MessageListUI instance other than instantiation are also done in compileSourceFile() method, I changed the code to make the whole contents of the original compileSourceFile() done in Event Dispatcher Thread (EDT).
According to the latest Travis job on my account, my change doesn't break anything in Contiki/Cooja at least...
Need Help :-)
Honestly, I'm not sure the change I made could resolve the issue. I have little knowledge and experience on Java... But, I want it resolved; failures by the exception are annoying... Please some Java programmers help me (>_<)
Related PR/Issue

#1987 made this issue PR closed!
#819 is still open closed (Dec 15, 2016); but could be closed by #1987 ?
#1638: see this comment",@joakimeriksson Awesome! Thank you for your help!!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/joakimeriksson,1,https://github.com/contiki-os/contiki/pull/1987,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1987#issuecomment-266409801,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,"Bugfix needed.
@yatch do you have any comment on the content?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/1987#issuecomment-266413813,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,I believe @joakimeriksson did resolve the issue in a right way ;-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/1987#issuecomment-266415130,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,Now I read the related discussions I also agree. Setting timeout üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1987#issuecomment-266485068,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,@nvt could you also take a look at this?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/nfi,6,https://github.com/contiki-os/contiki/pull/1987#issuecomment-267200248,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,"I found a few more places where COOJA code still used the UI MessageList and @joakimeriksson has already merged those changes into this PR.
This PR should solve some of the Travis issues and I think it looks good.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1987#issuecomment-267259691,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,"OK, enough trusted opinions here, merging now!
Thanks :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/yatch,8,https://github.com/contiki-os/contiki/pull/1987#issuecomment-267297769,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,"This issue, #819 , can be also closed?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1987#issuecomment-267304137,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,I think so!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1987,2016-12-11T20:44:53Z,2016-12-15T07:40:03Z,2016-12-15T11:32:07Z,MERGED,True,68,34,21,https://github.com/joakimeriksson,Fixed COOJA to avoid using UI based message list when not using UI.,3,['timed out'],https://github.com/contiki-os/contiki/pull/1987,https://github.com/yatch,10,https://github.com/contiki-os/contiki/pull/1987#issuecomment-267306261,This hopefully fixes a few of the last parts of the COOJA code that still made use of the MessageList with UI that sometimes cause strange class cast exceptions when running in travis. Fixing the parts of the code that cause the problems that is mentioned in PR #1986.,@simonduq Thanks for closing the issue :-),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1989,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/joakimeriksson,2,https://github.com/contiki-os/contiki/pull/1989#issuecomment-266973776,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Can anyone please ""pull"" my fixes for Cooja in #1987 so that we know if these things will happen again? (e.g. the fail for this travis test in RPL tests with Cooja. I am eager to know if the fix actually works or not...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1989#issuecomment-266986496,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Great! Did you check the tsch non-regression tests? (they are now not enabled in travis, because the linker for z1 fails randomly...).
Any chance you could split this in several PRs, one per feature?
@joakimeriksson yes, eager to find out too!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267009666,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@joakimeriksson I'm happy to do what I can do :-) Ah, OK, this branch had the same failure as the issue. I did ""pull"" your branch. Let's see if the failure is gone.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267010342,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq Yeah, I know this PR has become eventually big... I'll make some new PRs derived from this later. :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267035707,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@joakimeriksson Now, Travis gets green. I bet it's thanks to your changes! Interestingly, the failure always happens on a test for non-storing, BUILD_TYPE=non-storing. I have the failure on my another branch, https://travis-ci.org/yatch/contiki/jobs/183911836 . That's just for your information.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267036423,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Yeah I've seen it occur on other simulations just as well, e.g.
https://travis-ci.org/contiki-os/contiki/jobs/181255620",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,8,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267049837,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq With regard to tsch non-regression tests, I didn't notice even their existence... Now I ran the following tests; it seems good. Is there any other test I should run?

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,9,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267054361,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",these are the 3 tests I had in mind yes :) thanks,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,10,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267054848,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",@simonduq OK; I'll run the tests again after reshaping this branch later.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,11,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267073572,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Updated the branch and the PR message. Hope I didn't miss anything... Anyway, I'll rebase the branch after all the dependent PRs are merged and confirm if all the tests are passed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267290997,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",All commits but the two last could be merged as is (other PR?),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,13,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267307849,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",@simonduq  I don't think I have any other PR related to this PR for now. Your comment on EACK is a really good point. I'll see #880 and think about how to deal with it. Thanks for your review!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,14,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267320024,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","I meant, couldn't easily have a ""misc tsch fixes"" PR with only the 6 first commits of this pr?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,15,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267324582,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq Aha, definitely. The last two commits need more time. I agree with you; let me split this PR further.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,16,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267326773,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq Kept the commits on tsch_packet_create_eack() and tsch_packet_create_eb() and dropped the others from this branch. And, rebased. It's got lean!! Thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,17,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267398830,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq Updated the commits; I realized we don't need to take a backup of packetbuf in either tsch_packet_create_eack() or tsch_packet_create_eb().
In tsch_rx_slot(), a received frame is copied into current_input->payload before tsch_packet_create_eack() is called. So, tsch_packet_create_eack() can use packetbuf for its own job.
 719 /*---------------------------------------------------------------------------*/
 720 static
 721 PT_THREAD(tsch_rx_slot(struct pt *pt, struct rtimer *t))
 722 {
(snip)
 746     static struct input_packet *current_input;
(snip)
 759     current_input = &input_array[input_index];
(snip)
 794         current_input->len = NETSTACK_RADIO.read((void *)current_input->payload, TSCH_PACKET_MAX_LEN);
 795         NETSTACK_RADIO.get_value(RADIO_PARAM_LAST_RSSI, &radio_last_rssi);
(snip)
 860               /* Build ACK frame */
 861               ack_len = tsch_packet_create_eack(ack_buf, sizeof(ack_buf),
 862                   &source_address, frame.seq, (int16_t)RTIMERTICKS_TO_US(estimated_drift), do_nack);
Regarding tsch_packet_create_eb(), this is called from tsch_send_eb_process() with the pointer to packetbuf. Apparently, tsch_packet_create_eb() doesn't need to take a backup of packetbuf.
 709 /*---------------------------------------------------------------------------*/
 710 /* A periodic process to send TSCH Enhanced Beacons (EB) */
 711 PROCESS_THREAD(tsch_send_eb_process, ev, data)
 712 {
(snip)
 750         eb_len = tsch_packet_create_eb(packetbuf_dataptr(), PACKETBUF_SIZE,
 751             &hdr_len, &tsch_sync_ie_offset);
Please note that the signatures of both functions are changed. They don't need buf and buf_size any more.
After all the dependent PRs are merged, I'll rebase it and confirm if the tests are passed with this branch.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,18,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267585377,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Yes, but the problem is that packets travel through packetbuf at the interface with upper layers. Specifically, send_packet and tsch_rx_process_pending might have data in packetbuf when TSCH interrupts to run a slot.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,19,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267593938,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq Aha, OK. I think I understand more about your concerns. I forgot the important thing you pointed out...
In tsch_packet_create_eack() case, it's called in tsch_rx_slot thread, which runs in the (rtimer) interrupt context. Therefore, there can be another process working with packetbuf when tsch_packet_create_eack() accesses packetbuf. That's why the original code uses the separate memory, ack_buf[], allocated by tsch_rx_slot instead of packetbuf. That is what you mentioned yesterday.
That ""another process"" may be using send_packet() or tsch_rx_process_pending(), or accessing packetbuf directly.
So, for sure, the latest change for tsch_packet_create_eack() still has a chance to ruin packetbuf to be processed by others. For tsch_packet_create_eb(), packetbuf can be used. I'll think it again ;-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,20,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267608283,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","Yep, 100% on the same page now :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,21,https://github.com/contiki-os/contiki/pull/1989#issuecomment-267609036,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",It might be that keeping tsch_packet_create_eack() as is (i.e. not FRAMER-based) is the best option (depending on how much changes to FRAMER are required otherwise).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,22,https://github.com/contiki-os/contiki/pull/1989#issuecomment-271023604,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq I extracted the logic setting up frame802154_t params from create_frame() and created a new function with it. This new function, framer_802154_setup_params(), sets values to params appropriately based on packetbuf attributes. This function takes a getter function (get_attr) as an argument so that it can access packetbuf attributes other than stored in packetbuf_attrs defined in packetbuf.c.
tsch_packet_create_eack() uses a local packetbuf_attr array instead of packetbuf_attrs that may be used by another process. It gets a ready-to-use frame802154_t data with framer_802154_setup_params() and builds an EACK in a given buffer with frame802154_create().
If this version of tsch_packet_create_eack() has any critical problem, I'll revert all the changes on the function. This is the last try üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/simonduq,23,https://github.com/contiki-os/contiki/pull/1989#issuecomment-271229832,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",Great :) I think this should work. Am ready for a detailed review as soon as Travis is green ;),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,24,https://github.com/contiki-os/contiki/pull/1989#issuecomment-271257399,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","@simonduq I'll rebase this branch after both of PR/#1998 and PR/#2002 are merged. Then, I'll make sure that Travis gets green as well as non-regression tests are passed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/kkrentz,25,https://github.com/contiki-os/contiki/pull/1989#issuecomment-272189103,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()","BTW, in #880, I also adapted the creation and parsing of EACKs and EBs to reuse code of the framer.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1989,2016-12-13T02:26:27Z,,2017-01-12T15:38:21Z,OPEN,False,666,210,6,https://github.com/yatch,Refactoring tsch-packet,4,[],https://github.com/contiki-os/contiki/pull/1989,https://github.com/yatch,26,https://github.com/contiki-os/contiki/pull/1989#issuecomment-272195557,"Summary
The original purpose of this refactoring is to make tsch_packet_create_eack() and tsch_packet_create_eb() not build a IEEE 802.15.4 frame by themselves, instead, let NETSTACK_FRAMER.create() do its job for them. That is, there is duplicate code in tsch-packet.c which is similar to what create_frame() of  framer_802154 does.
Test
Regression Test
regression-tests/25-ieee802154/02-tsch-packet-create.csc provides regression tests for tsch_packet_create_eack() and tsch_packet_create_eb().
$ cd regression-tests/25-ieee802154
$ make 02-tsch-packet-create.testlog
Running test 02-tsch-packet-create with random Seed 1: .......... OK
There are three configuration sets used in the tests:

DEFAULT: use the default configuration parameters
SECURITY_ON: enable the security feature by the following settings:

#undef LLSEC802154_CONF_ENABLED
#define LLSEC802154_CONF_ENABLED 1
#undef LLSEC802154_CONF_USES_EXPLICIT_KEYS
#define LLSEC802154_CONF_USES_EXPLICIT_KEYS 1
#undef LLSEC802154_CONF_USES_FRAME_COUNTER
#define LLSEC802154_CONF_USES_FRAME_COUNTER 0

ALL_ENABLED: enable all the features other than security, that affects tsch_packet_create_eack() and tsch_packet_create_eb() behaviors

#undef TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_DEST_ADDR 1
#undef TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR
#define TSCH_PACKET_CONF_EACK_WITH_SRC_ADDR 1
#undef TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING
#define TSCH_PACKET_CONF_EB_WITH_TIMESLOT_TIMING 1
#undef TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE
#define TSCH_PACKET_CONF_EB_WITH_HOPPING_SEQUENCE 1
#undef TSCH_PACKET_EB_WITH_SLOTFRAME_AND_LINK
#define TSCH_PACKET_CONF_EB_WITH_SLOTFRAME_AND_LINK 1
Non-Regression Test
The following tests under regression-tests/11-ipv6/ should be passed as well as the Travis regression test:

19-z1-rpl-tsch.csc.flaky
20-z1-rpl-tsch-orchestra.csc.flaky
21-z1-rpl-tsch-security.csc.flaky

Disadvantage
<obsolete>
The static variable named tmp_pktbuf is introduced in tsch-packet.c in order to keep the original contents of packetbuf during tsch_packet_create_eack() and tsch_packet_create_eack(). This could impact on memory constrained platforms.
</obsolete>
Dependencies
PR/#1998
This PR depends on three new packetbuf attributes shown below:

PACKETBUF_ATTR_MAC_METADATA: set with 1 if Information Element is present in a frame
PACKETBUF_ATTR_MAC_NO_SRC_ADDR: set with 1 if source address is omitted
PACKETBUF_ATTR_MAC_NO_DEST_ADDR: set with 1 if destination address is omitted

[merged] PR/#1997
This PR uses packetbuf_remaininglen()` in its changes.
[merged] PR/#1994
It turned out that create_frame() of framer_802154 always set linkaddr_node_addr to the source address of an IEEE 802.15.4 frame.
[framer-802154.c]
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
This bug is fixed to set the address of PACKETBUF_ADDR_SENDER instead.
By this bugfix, two regression tests, 11-ipv6/04-exp5438-udp-fragmentation-contikimac and 13-ipv6-apps/01-sky-servreg-hack1, got to failure. Looking into frames In these tests, the all zero address was set to the source link-layer address of frames. This prevents a recipient from building the correct source address of a compressed IPv6 packet. This issue is resolved by making qsend_list() of contikimac_driver set PACKETBUF_ADDR_SENDER with linkaddr_node_addr before calling NETSTACK_FRAMER.create(). Although I'm not sure if setting the source address at the RDC layer is a right thing, I just borrowed the idea that is already there; the same thing has been done in send_packet() of contikimac_driver.
Similarly, now send_packet() of tschmac_driver needs to set PACKETBUF_ADDR_SENDER since it bypasses the RDC layer to transmit a frame.
[merged] PR/#1993
regression-tests/04-rime/07-sky-collect failed after applying PR/#1994 . The interesting thing is this test succeeded on my local PC but failed on Travis-CI.  One packet loss caused the test failure according to the failure log on Travis. I could not find any problem in the Contiki stack code. My conclusion is that the packet was lost by chance.
During the investigation, I found a bug in examples/rime/example-collect.c, a source file used in the test. Each node in the simulation is supposed to send a message every 30 seconds. However, it sends messages more frequently because of the bug. This may cause collision and packet loss. After fixing the bug, the packet loss disappeared and the test succeeded.
PR/#2002 :

Indentation fixes
Put tsch_ prefix to some global names
Add missing error checks
Add the const modifier to dest addr in tsch_packet_create_eack()",@kkrentz Thanks for the info. üòÑ,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1993,2016-12-14T12:44:33Z,2016-12-15T09:46:04Z,2016-12-15T09:46:04Z,MERGED,True,16,16,2,https://github.com/yatch,Bugfix on regression-tests/04-rime/07-sky-collect.csc,2,[],https://github.com/contiki-os/contiki/pull/1993,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1993,"Mainly two fixes:

04-rime/07-sky-collect.csc: while a received seqno is supposed to be less than 10 in the test script, it doesn't handle a case where  seqno is larger than or equal to 10.
example-collect.c: a node sends messages more frequently than expected, every 30 seconds.

Other changes are trivial: indentation fix and shortening time to wait in case of test failure.","Mainly two fixes:

04-rime/07-sky-collect.csc: while a received seqno is supposed to be less than 10 in the test script, it doesn't handle a case where  seqno is larger than or equal to 10.
example-collect.c: a node sends messages more frequently than expected, every 30 seconds.

Other changes are trivial: indentation fix and shortening time to wait in case of test failure.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1993,2016-12-14T12:44:33Z,2016-12-15T09:46:04Z,2016-12-15T09:46:04Z,MERGED,True,16,16,2,https://github.com/yatch,Bugfix on regression-tests/04-rime/07-sky-collect.csc,2,[],https://github.com/contiki-os/contiki/pull/1993,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1993#issuecomment-267283502,"Mainly two fixes:

04-rime/07-sky-collect.csc: while a received seqno is supposed to be less than 10 in the test script, it doesn't handle a case where  seqno is larger than or equal to 10.
example-collect.c: a node sends messages more frequently than expected, every 30 seconds.

Other changes are trivial: indentation fix and shortening time to wait in case of test failure.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1993,2016-12-14T12:44:33Z,2016-12-15T09:46:04Z,2016-12-15T09:46:04Z,MERGED,True,16,16,2,https://github.com/yatch,Bugfix on regression-tests/04-rime/07-sky-collect.csc,2,[],https://github.com/contiki-os/contiki/pull/1993,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1993#issuecomment-267284713,"Mainly two fixes:

04-rime/07-sky-collect.csc: while a received seqno is supposed to be less than 10 in the test script, it doesn't handle a case where  seqno is larger than or equal to 10.
example-collect.c: a node sends messages more frequently than expected, every 30 seconds.

Other changes are trivial: indentation fix and shortening time to wait in case of test failure.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1994,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.","Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267284304,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",aren't the other instances of NETSTACK_FRAMER.create() also affected?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267307121,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.","@simonduq The Travis test told me that there is no other NETSTACK_FRAMER.create() affected by this change ;-)
I'll take another look at other protocol modules later. If I find something else, it's time to add a new regression test for it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267333119,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",@simonduq OK; I have to do something for sicslowmac üò∞,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267334665,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.","That sucks :/
I'd definitely approve getting rid of sicslowmac but I'm afraid some dependencies might make this not such an easy task..",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267335392,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.","@simonduq Sorry, my bad. sicslowmac is nothing wrong. Updated the table in the PR message.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/yatch,7,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267336145,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",Rebased.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/1994#issuecomment-267336307,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",thanks! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1994#issuecomment-269944040,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",Is this ready to be merged? any additional comments?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/yatch,10,https://github.com/contiki-os/contiki/pull/1994#issuecomment-270361460,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.","@alignan I think so; to me, it seems ready to be merged.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1994,2016-12-14T13:12:17Z,2017-01-04T13:10:58Z,2017-01-04T14:19:56Z,MERGED,True,15,1,3,https://github.com/yatch,Bugfix on source address setting in framer_802154.create(),3,[],https://github.com/contiki-os/contiki/pull/1994,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1994#issuecomment-270366832,"Here is an excerpt from the code of  create_frame() in framer-802154.c:
 172   /*
 173    * Set up the source address using only the long address mode for
 174    * phase 1.
 175    */
 176   linkaddr_copy((linkaddr_t *)&params.src_addr, &linkaddr_node_addr);
 177
 178   params.payload = packetbuf_dataptr();
 179   params.payload_len = packetbuf_datalen();
 180   hdr_len = frame802154_hdrlen(&params);
 181   if(!do_create) {
 182     /* Only calculate header length */
 183     return hdr_len;
 184   } else if(packetbuf_hdralloc(hdr_len)) {
 185     frame802154_create(&params, packetbuf_hdrptr());
It always sets linkaddr_node_addr to the source address of a newly creating frame at Line 176. It should take the address of PACKETBUF_ADDR_SENDER into account.
<obsolete>
As far as I know, there are two protocols which depend on this bug: ContikiMAC and TSCH. They are supposed to set an address to PACKET_ADDR_SENDER by themselves to specify what address should be used as the source address of their frame.
</obsolete>
We have six RDC protocols in the code base:
$ find core -name \*.c | xargs grep rdc_driver | grep const
core/net/mac/sicslowmac/sicslowmac.c:const struct rdc_driver sicslowmac_driver = {
core/net/mac/nullrdc.c:const struct rdc_driver nullrdc_driver = {
core/net/mac/cxmac/cxmac.c:const struct rdc_driver cxmac_driver =
core/net/mac/nullrdc-noframer.c:const struct rdc_driver nullrdc_noframer_driver = {
core/net/mac/nordc.c:const struct rdc_driver nordc_driver = {
core/net/mac/contikimac/contikimac.c:const struct rdc_driver contikimac_driver = {
Only contikimac gets affected by this bugfix. The following table shows whether each RDC protocol sets PACKETBUF_ADDR_SENDER in its APIs for transmission ( ‚úîÔ∏è ) or not ( ‚úñÔ∏è ).



Protocol
send()
send_list()
Note




sicslowmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L148


nullrdc
‚úîÔ∏è
‚úîÔ∏è
send_one_packet() takes care for both cases at L119. However, it doesn't have a !NETSTACK_CONF_BRIDGE_MODE guard.


cxmac
‚úîÔ∏è
‚úîÔ∏è
send_packet() takes care for both cases at L431


nullrdc-noframer
N/A
N/A
This doesn't create any MAC frame by itself.


nordc
N/A
N/A
This doesn't create any MAC frame by itself.


contikimac
‚úîÔ∏è
‚úñÔ∏è
send_packet() takes care for the send(), qsend_packet(), case. The send_list(), qsend_list(), case is handled by this PR



nullrdc-noframer and nordc doesn't create a MAC frame by themselves. Instead, an upper layer protocol should set PACKETBUF_ADDR_SENDER if it's depends on NETSTACK_FRAMER.create().
An upper protocol using nullrdc_driver could be affected by this PR. But, in the code base, only nullmac is used with nullrdc_driver. Regarding this particular case, we don't have to anything for it.
Contiki TSCH assumes  it has nordc as a RDC protocol. This case is handled by this PR.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,1,https://github.com/contiki-os/contiki/pull/1995,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",True,{'THUMBS_UP': ['https://github.com/rfuentess']}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1995#issuecomment-271511984,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Thanks a lot @cladmi , DTLS support in upstream has been long overdue...
Could you take a look at the doxygen failure in Travis?
One question will be regarding licenses. TinyDTLS is under the Eclipse Distribution License. How compatible is that with Contiki's BSD? What happens to BSD software statically linked to Eclipse?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/1995#issuecomment-272096259,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","DTLS support is indeed welcome. There are a few Contiki ports of TinyDTLS out there, including one in the Sparrow application layer. What are the long-term development/maintenance plans for this module?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,4,https://github.com/contiki-os/contiki/pull/1995#issuecomment-272219983,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@simonduq
I will soon to take a look at the travis/doxygen error when I have time.
Regarding Licensing, I currently have no idea. The nearest I find is this
https://eclipse.org/legal/eplfaq.php#COMPILEWOMOD
I think it means that it would require understanding what are the difference in the distribution of a compiled version between BSD and EPL.
@nvt
The TinyDTLS port which is in 'sparrow' is just a copy of the one from eclipse project which already has contiki support.
The module in my repository is only temporary. I mainly changed packaging to allow running it without 'autoreconf; ./configure', cosmetic changes and two real bug fixes.
The patches are currently being reviewed by the maintainer and some already have positive code reviews.
https://git.eclipse.org/r/#/q/project:tinydtls/org.eclipse.tinydtls",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,5,https://github.com/contiki-os/contiki/pull/1995#issuecomment-272221614,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Also, I currently only tested this on our non-officially supported boards.
What would be the platform to test this ? I tried compiling for cooja and had problems because of not enough ROM.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/1995#issuecomment-272223427,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I could test for the RE-Mote and Firefly, as most mergers already have one it will simplify testing",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/nvt,7,https://github.com/contiki-os/contiki/pull/1995#issuecomment-272390511,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@cladmi OK, that sounds reasonable. During an initial test, I noticed that there are some warnings and filename collisions that occur when compiling for the ""native"" and ""zoul"" platforms. crypto.[ch] and ccm.[ch] exist in both apps/tinydtls/ and cpu/cc2538/dev, for instance.
If you want to test it in Cooja, it might fit in the Wismote platform's ROM, but you might have to tune the configuration to reduce RAM and ROM requirements since the er-rest-dtls/project-conf.h uses most of the default configuration. Furthermore, it is important to use the right compiler version (mspgcc 4.7.2) in order to enable the full use of the Wismote's ROM. If you don't have this version, you can see in contiki/.travis.yml where to retrieve it from. Otherwise you should at least be able to run it in native mode under Cooja.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,8,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274810955,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I tested and got the following:
using saved target 'zoul'
  CC        ../../cpu/cc2538/./ieee-addr.c
  CC        ../../cpu/cc2538/cc2538.lds
  CC        ../../cpu/cc2538/./startup-gcc.c
  CC        er-example-server.c
  LD        er-example-server.elf
obj_zoul/dtls.o: In function `dtls_add_ecdsa_signature_elem':
dtls.c:(.text.dtls_add_ecdsa_signature_elem+0x10): undefined reference to `dtls_ec_key_from_uint32_asn1'
dtls.c:(.text.dtls_add_ecdsa_signature_elem+0x20): undefined reference to `dtls_ec_key_from_uint32_asn1'
obj_zoul/dtls.o: In function `dtls_prepare_record.isra.7':
dtls.c:(.text.dtls_prepare_record.isra.7+0x1c8): undefined reference to `dtls_encrypt'
obj_zoul/dtls.o: In function `calculate_key_block.isra.12':
dtls.c:(.text.calculate_key_block.isra.12+0x12): undefined reference to `dtls_security_free'
dtls.c:(.text.calculate_key_block.isra.12+0x16): undefined reference to `dtls_security_new'
dtls.c:(.text.calculate_key_block.isra.12+0x8e): undefined reference to `dtls_psk_pre_master_secret'
dtls.c:(.text.calculate_key_block.isra.12+0xd2): undefined reference to `dtls_ecdh_pre_master_secret'
dtls.c:(.text.calculate_key_block.isra.12+0x148): undefined reference to `dtls_prf'
dtls.c:(.text.calculate_key_block.isra.12+0x17c): undefined reference to `dtls_prf'
obj_zoul/dtls.o: In function `dtls_send_finished.constprop.22':
dtls.c:(.text.dtls_send_finished.constprop.22+0x40): undefined reference to `dtls_prf'
obj_zoul/dtls.o: In function `dtls_send_certificate_verify_ecdh.isra.17':
dtls.c:(.text.dtls_send_certificate_verify_ecdh.isra.17+0x32): undefined reference to `dtls_ecdsa_create_sig_hash'
obj_zoul/dtls.o: In function `handle_handshake_msg':
dtls.c:(.text.handle_handshake_msg+0x35e): undefined reference to `dtls_ecdsa_verify_sig'
dtls.c:(.text.handle_handshake_msg+0x470): undefined reference to `dtls_ecdsa_generate_key'
dtls.c:(.text.handle_handshake_msg+0x748): undefined reference to `dtls_prf'
dtls.c:(.text.handle_handshake_msg+0x7ec): undefined reference to `dtls_handshake_free'
dtls.c:(.text.handle_handshake_msg+0x93e): undefined reference to `dtls_ecdsa_verify_sig_hash'
dtls.c:(.text.handle_handshake_msg+0xa4e): undefined reference to `dtls_handshake_new'
dtls.c:(.text.handle_handshake_msg+0xd88): undefined reference to `dtls_ecdsa_generate_key'
dtls.c:(.text.handle_handshake_msg+0xdb0): undefined reference to `dtls_ecdsa_create_sig'
dtls.c:(.text.handle_handshake_msg+0xf18): undefined reference to `dtls_handshake_new'
obj_zoul/dtls.o: In function `dtls_renegotiate':
dtls.c:(.text.dtls_renegotiate+0x1a): undefined reference to `dtls_handshake_new'
obj_zoul/dtls.o: In function `dtls_handle_message':
dtls.c:(.text.dtls_handle_message+0x1b2): undefined reference to `dtls_decrypt'
dtls.c:(.text.dtls_handle_message+0x1dc): undefined reference to `dtls_security_free'
obj_zoul/dtls.o: In function `dtls_connect_peer':
dtls.c:(.text.dtls_connect_peer+0x1e): undefined reference to `dtls_handshake_new'
obj_zoul/peer.o: In function `dtls_free_peer':
peer.c:(.text.dtls_free_peer+0x6): undefined reference to `dtls_handshake_free'
peer.c:(.text.dtls_free_peer+0xc): undefined reference to `dtls_security_free'
peer.c:(.text.dtls_free_peer+0x12): undefined reference to `dtls_security_free'
obj_zoul/peer.o: In function `dtls_new_peer':
peer.c:(.text.dtls_new_peer+0x2a): undefined reference to `dtls_security_new'
collect2: error: ld returned 1 exit status
make: *** [er-example-server.elf] Error 1
rm obj_zoul/startup-gcc.o er-example-server.co",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,9,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274813806,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",@nvt Are the undefined references what you meant in your comment?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/nvt,10,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274814154,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@alignan Yes, I had to change the names of some files and functions to get it to compile.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,11,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274815356,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I tried the same and renamed to cc2538-crypto, probably it will make sense to prefix aes and sha256 with the specific platform implementation as well.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,12,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274844925,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I think I got it working now üòÑ
As this is a new feature it would benefit from having a proven testing tool (i.e the TinyDTLS tests or Californium), could you add instructions on how to test with any preferred one?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,13,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274869789,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I have no ""proven"" / external testing tool available right now.
I could not manage to find a working example with instructions on how to compile with californium‚Ä¶
So when testing, I only run contiki client and server.
In our project, I ran the client with a californium implemented server but I currently don't have any source code or instructions on how to run one, and I was not the one starting it.
When testing tinydts alone, I was using these examples here: https://github.com/spark/tinydtls/blob/master/examples/contiki/dtls-client.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,14,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274874110,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Fair enough, I'm building (and cursing) Californium now, I will try to provide instructions.  A basic TinyDTLS test would be appreciated nevertheless, mostly as said before, this is a new feature and likely one that will increase the number of messages over the mailing list.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,15,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274878456,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Too bad 'copper' does not support dtls, it would be far easier than using californium.
What would be a good user interface for a test ?
A shell with a command and the server address passed as argument, or like in the dtls-client example, a compile time configuration ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,16,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274878957,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Also, I would be glade to have feedback on the actual implementation, and the interface for the configuration.
As copied from cetic implementation, this er-coap-dtls wrapper currently only provides PSK support with a single client identity.
It's possible and quite easy to add support for multiple identity depending on the server (a map of server_identity->identity+key) and also add support for ecdsa key.
However, the question would be how to configure them.
Or should firmwares overwrites some functions, variables and so declare them weak in the wrapper ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/joakimeriksson,17,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274887315,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",@cladmi I would suggest using LWM2M to test CoAP + DTLS - there are good LWM2M servers around and they support DTLS / PSK and are easy to configure the PSK-key in see leshan.eclipse.org .,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alignan,18,https://github.com/contiki-os/contiki/pull/1995#issuecomment-274963426,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@joakimeriksson that's a great suggestion.
However I wanted to test californium, I'm using the californium.tools and the cf-client, but failing to configure the Californium.properties file properly, @laurentderu do you have any example? I think this was used to test the 6lbr's CoAP DTLS server example",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/laurentderu,19,https://github.com/contiki-os/contiki/pull/1995#issuecomment-275331941,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@alignan I used Californium + Scandium in the past, but it did not work out of the box, you had to modify the code to use your own keys and identity. So for testing TinyDTLS integration I switched to the dtls-server provided with TinyDTLS.
@cladmi When I wrote that code (a long time ago), ECDSA was broken in TInyDTLS and also could not fit in some platform (like Econotag) so I did not provide the code for the ECDSA key management. But I think now it can be added again. For the key management, I would move they keycap structure psk out of get_psk_info() and wrap it with conditional macro, like other customisable structs in Contiki, so that by default the code provide support for one key, but if one would like to have multiple identities he could define its own struct.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/obgm,20,https://github.com/contiki-os/contiki/pull/1995#issuecomment-275333763,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Laurent Deru <notifications@github.com> writes:
 @cladmi When I wrote that code (a long time ago), ECDSA was broken in
 TInyDTLS and also could not fit in some platform (like Econotag) so I
 did not provide the code for the ECDSA key management. But I think now
 it can be added again.
Small heads-up here: The currently existing very slow ECC implementation
will be replaced by micro-ecc within the next couple of weeks.

Gr√º√üe
Olaf",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/laurentderu,21,https://github.com/contiki-os/contiki/pull/1995#issuecomment-275335063,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@simonduq I asked someone here who is versed into open source license, according to him (and why I understood) the BSD and EPL license can coexist, both license don't have restriction on the code covered by another license in a same program. However, the included code still keep the EPL license. One consequence is that the source code of the portion covered by the EPL must be provided upon request (but not the whole source code of the program), also it must be mentioned that the program contains code licensed under the EPL.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,22,https://github.com/contiki-os/contiki/pull/1995#issuecomment-288729253,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",I sent an email to license at eclipse dot org to have an official answer on what should be done.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,23,https://github.com/contiki-os/contiki/pull/1995#issuecomment-288747508,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Answer from eclipse:

Ga√´tan,
The Eclipse tinydtls project is actually dual licensed under both the EPL and the BSD-3[1][2]. You can choose which of those licenses you wish to distribute tinydtls under. Given your circumstances, I would recommend selecting the BSD.
I hope that helps.
[1] https://projects.eclipse.org/projects/iot.tinydtls
[2] https://www.eclipse.org/org/documents/edl-v10.php

So tinydtls is also under BSD so there may be nothing to do.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,24,https://github.com/contiki-os/contiki/pull/1995#issuecomment-288758729,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",I removed apps/tinydtls from doxygen generation to fix travis and rebased on #2156,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/simonduq,25,https://github.com/contiki-os/contiki/pull/1995#issuecomment-288778140,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",great news for the license! I think the files would then need the BSD header,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/obgm,26,https://github.com/contiki-os/contiki/pull/1995#issuecomment-288783432,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Note that as an Eclipse project, these files must have the EPL/EDL header, i.e. changes affecting this header could not go back upstream.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,27,https://github.com/contiki-os/contiki/pull/1995#issuecomment-294331336,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I just got an idea regarding License, and also code organization.
Code organization
In ""er-coap-dtls.c"" I defined functions specific to Tinydtls but not to er-coap only.
I someone wants to use tinydtls in a single test or example, he would also need to define these ones.
In another repository, I tried adding another ""app"" that was defining these generic functions, but it was kinda bulky, you needed to include both apps to make it work.
So my idea, why not just add a ""apps/dtls"" directory and clone ""tinydtls in ""apps/dtls/tinydtls"".
This way some of the common handling could be done in ""apps/dtls"" like saying ""hey, you should init your submodules to use this"" instead of putting it in ""er-coap"". And also group tinydtls specific code here.
And if someone would like to use another implementation, he could put it a separate ""dtls"" subdirectory.
License
Now on licenses, the problem I understood, is that people think that when using contiki ""everything is BSD"" and we want to be sure that they agree to use EPL/LGPL code too. This way if they distribute contiki in their product, they would know they must say they are also distributing this code which is not contiki.
In this ""dtls"" directory, I could add
ifneq ($(I_ACCEPT_TINYDTLS_LICENSE_EPL), 1)
$(error You are building a firmware with TinyDTLS under EPL license,  be sure to respect the license. If that is the case, define the I_ACCEPT_TINYDTLS_LICENSE_EPL to 1)
endif

Horrible to use, but its to give an idea.
It could be better to generalize it by setting the current Makefile license, like LICENSES += EPL-1.0.
And then in the global Makefile, a sub-target checking that all LICENSES are defined in ACCEPTED_LICENSES which would by default be set to BSD-3-clause.
However, with only LICENSES, you would loose that its tinydtls that requires EPL-1.0 and that you should say its included in your product. So maybe not use a licenses variable but MODULES_LICENSES += ""TinyDTLS_EPL-1.0"" and so you would need to acknowledge both module and license.
And it could be possible to add a file at the repository root Makefile.accepted_licenses to define these.
(I am just thinking that this may not require the sub-directory I mentioned earlier if its included in the upstream Makefile but my thoughts started from there.)
Would something like this be an acceptable solution ? The discussion can be moved to another issue/PR if necessary.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,28,https://github.com/contiki-os/contiki/pull/1995#issuecomment-307145827,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","It is the last day of my current job so I will not be able to work on this anymore.
Feel free to fork/update/change what I have done.
Regards, cladmi",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/tarakanov,29,https://github.com/contiki-os/contiki/pull/1995#issuecomment-325267211,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",Hi! I just want to know what is the progress here? Does anybody test this PR?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/tarakanov,30,https://github.com/contiki-os/contiki/pull/1995#issuecomment-325886700,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",This coap-dtls works well for me. I tested it on Sensortag (cc2650) with lwm2m serve Leshan (local server and at leshan.eclipse.org).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/ushiang,31,https://github.com/contiki-os/contiki/pull/1995#issuecomment-325906386,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Hi! please, i got the following error while trying to compile for the Zolertia Re-mote
mkdir obj_zoul CC        ../../cpu/cc2538/./ieee-addr.c CC        ../../cpu/cc2538/cc2538.lds CC        ../../cpu/cc2538/./startup-gcc.c CC        ../../apps/er-coap/er-coap.c CC        ../../apps/er-coap/er-coap-engine.c CC        ../../apps/er-coap/er-coap-transactions.c CC        ../../apps/er-coap/er-coap-observe.c CC        ../../apps/er-coap/er-coap-separate.c CC        ../../apps/er-coap/er-coap-res-well-known-core.c CC        ../../apps/er-coap/er-coap-block1.c CC        ../../apps/er-coap/er-coap-observe-client.c CC        ../../apps/er-coap/er-coap-dtls.c ../../apps/er-coap/er-coap-dtls.c:20:12: error: 'coap_dtls_send_to_peer' undeclared here (not in a function) .write = coap_dtls_send_to_peer, ^ ../../apps/er-coap/er-coap-dtls.c:21:11: error: 'coap_dtls_read_from_peer' undeclared here (not in a function) .read = coap_dtls_read_from_peer, ^ ../../apps/er-coap/er-coap-dtls.c:24:19: error: 'coap_dtls_get_psk_info' undeclared here (not in a function) .get_psk_info = coap_dtls_get_psk_info, ^ ../../apps/er-coap/er-coap-dtls.c: In function 'coap_init_communication_layer': ../../apps/er-coap/er-coap-dtls.c:46:33: error: 'COAP_DTLS_CALLBACK' undeclared (first use in this function) dtls_set_handler(dtls_ctx, &COAP_DTLS_CALLBACK); ^ ../../apps/er-coap/er-coap-dtls.c:46:33: note: each undeclared identifier is reported only once for each function it appears in ../../apps/er-coap/er-coap-dtls.c: In function 'coap_dtls_get_psk_info': ../../apps/er-coap/er-coap-dtls.c:97:24: error: 'DTLS_IDENTITY' undeclared (first use in this function) { (unsigned char *)DTLS_IDENTITY, DTLS_IDENTITY_LENGTH, (unsigned char *)DTLS_PSK_KEY_VALUE, DTLS_PSK_KEY_VALUE_LENGTH }, ^ ../../apps/er-coap/er-coap-dtls.c:97:39: error: 'DTLS_IDENTITY_LENGTH' undeclared (first use in this function) { (unsigned char *)DTLS_IDENTITY, DTLS_IDENTITY_LENGTH, (unsigned char *)DTLS_PSK_KEY_VALUE, DTLS_PSK_KEY_VALUE_LENGTH }, ^ ../../apps/er-coap/er-coap-dtls.c:97:78: error: 'DTLS_PSK_KEY_VALUE' undeclared (first use in this function) { (unsigned char *)DTLS_IDENTITY, DTLS_IDENTITY_LENGTH, (unsigned char *)DTLS_PSK_KEY_VALUE, DTLS_PSK_KEY_VALUE_LENGTH }, ^ ../../apps/er-coap/er-coap-dtls.c:97:98: error: 'DTLS_PSK_KEY_VALUE_LENGTH' undeclared (first use in this function) { (unsigned char *)DTLS_IDENTITY, DTLS_IDENTITY_LENGTH, (unsigned char *)DTLS_PSK_KEY_VALUE, DTLS_PSK_KEY_VALUE_LENGTH }, ^ ../../apps/er-coap/er-coap-dtls.c: At top level: ../../apps/er-coap/er-coap-dtls.c:19:23: warning: 'coap_dtls_callback' defined but not used [-Wunused-variable] static dtls_handler_t coap_dtls_callback = { ^ make: *** [obj_zoul/er-coap-dtls.o] Error 1 rm obj_zoul/startup-gcc.o 
I'll be glad with any suggestions on how to fix this please. Thanks in advance",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/tarakanov,32,https://github.com/contiki-os/contiki/pull/1995#issuecomment-326239481,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","Try to add #include ""er-coap-dtls.h"" to er-coap-dtls.c file",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/cladmi,33,https://github.com/contiki-os/contiki/pull/1995#issuecomment-326318417,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","This may have been broken by my last commit: c7de205
Including er-coap-dtls.h should fix it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/arurke,34,https://github.com/contiki-os/contiki/pull/1995#issuecomment-333298899,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I have been using the 6lbr coap app for some time, but would love to test this. Curious about removing the context, @laurentderu do you have any comments? I guess it would be a benefit if 6lbr and contiki coap app are aligned.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/laurentderu,35,https://github.com/contiki-os/contiki/pull/1995#issuecomment-335801492,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","In TinyDTLS, the context object is used to manage the list of packets to be sent, the list of peers, the callbacks towards the application and the session cookie. So, to have more than one session active at a time you can not share the same context. Theoretically you could move the cookie into the session object, but still you would have a common send queue, and one peer not responding would block all the sessions.
On the other hand, I'm not convinced that in a typical application you would have more than one session active at at time, that's why when I integrated TinyDTLS into er-coap I took a hybrid approach of defining a default context that would be used unless specified otherwise. That would have been enough for 99% of the applications, the last % would just need to override the context when needed.
Removing the default context would only hurt the application that needed to have more than one active session, so I don't think it's a great loss. And as @arurke said, reconciling the 6LBR and Contiki versions could be more beneficial.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/KaneRoot,36,https://github.com/contiki-os/contiki/pull/1995#issuecomment-361281448,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","I don't know where this is going, but at least I managed to get this fork of contiki work with CoAP and TinyDTLS on an avr-zigduino:
https://github.com/Gr3yh0und/tinydtls
https://github.com/Gr3yh0und/contiki
https://github.com/Gr3yh0und/YaCoAP
Of course, check the memory usage, it's quite big and needs a few tricks to get it working on a chip with only 32KB RAM (remove ECC in TinyDTLS, limit the number of routes, etc).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/beleyj,37,https://github.com/contiki-os/contiki/pull/1995#issuecomment-371019667,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi",Has been working great on the SensorTag CC2650. I even have room to implement and use the device's various sensors within my code.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alemusix,38,https://github.com/contiki-os/contiki/pull/1995#issuecomment-397821727,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@KaneRoot
I understand that you've managed to integrate TinyDTLS with CoAP, please I need assistant.
I'd like to run a CoAPs example in Cooja.
I've downloaded your contiki fork
https://github.com/Gr3yh0und/contiki
and TinyDTLS
https://github.com/Gr3yh0und/tinydtls
and placed TinyDTLS inside the contiki/app folder. Next I've launched the command

git submodule update --init --recursive

to download all missing file. Then inside the contiki/apps/TinyDTLS folder I've launched the command

autoreconf && ./configure --with-contiki --without-ecc

After that I deployed 3 wismote nodes in Cooja:
1 6LoWPAN Border router flashed with the firmware
(contiki/examples/ipv6/rpl-border-router/border-router.c)
1 CoAPS client* flashed with the firmware (
contiki/examples/er-rest-example/er-example-client.c)
1 CoAPS server* flashed with the firmware (
contiki/examples/er-rest-example/er-example-server.c)
After I've launched the simulation the mote output is not showing anything regarding DTLS handshake but only the er-coap example outuput. What am I doing wrong?
*In the er-rest-example makefile I've added
APPS += tinydtls/aes tinydtls/sha2 tinydtls/ecc tinydtls",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/KaneRoot,39,https://github.com/contiki-os/contiki/pull/1995#issuecomment-401969538,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@alemusix
First, I want to say that I did integrate CoAP and TinyDTLS but I dropped everything since I could not remove RPL, amongst other minor problems. Connection and request worked, though.
From what I remember, I had to modify the code in order to compile, and er-coap-example didn't had any DTLS code in it. Did you check? You have to use the good sketch, where you can see DTLS files (dtls_*). I may have copied a sketch from yet-another-fork of Contiki to get it right.
Also, I never used Cooja, so if your problem comes from Cooja, I can't help.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/Viktoriia55,40,https://github.com/contiki-os/contiki/pull/1995#issuecomment-562166323,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@alemusix Hello! Have you solved this problem with DTLS in Cooja? If yes, please help me, I really need that.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/alemusix,41,https://github.com/contiki-os/contiki/pull/1995#issuecomment-562242148,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@alemusix Hello! Have you solved this problem with DTLS in Cooja? If yes, please help me, I really need that.

Hi @Viktoriia55 unfortunately I never managed to solve the problem in Cooja, so I can't help you.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1995,2016-12-14T13:41:33Z,,2019-12-05T20:33:52Z,OPEN,False,616,38,18,https://github.com/cladmi,Er-coap-dtls: integration of tinydtls and using it in er-coap,10,[],https://github.com/contiki-os/contiki/pull/1995,https://github.com/Viktoriia55,42,https://github.com/contiki-os/contiki/pull/1995#issuecomment-562305834,"Hello,
this set of patches adds support for er-coap-dtls using 'tinydtls' as a submodule and code modified from cetic/6lbr er-coap adaptations.
They still need to be cleaned-up, wait for tinydtls patch integration, fix contribution informations.
But they are a starting point for discussing what you think about this and test them.
More information on the changes:
Tinydtls
The given version is currently my maintained version where I fixed several issues with contiki, which include¬†:

a regression in dtls_retransmit_process where a node should be popped from the queue before calling transmit
a bug where structs are defined differently because a #define which is not imported in all files.
Make tinydtls work without requiring autoreconf; ./configure --with-contiti

These have been reported upstream and should soon be reviewed by the maintainer @obgm .
You may also want to take a look at what was done in this repository https://github.com/iot-lab/armour-tinydtls so I can give other feedbacks upstream.
er-coap
I copied the changes from https://github.com/cetic/6lbr @laurentderu which are under the same license as Contiki: https://github.com/cetic/6lbr/wiki#licence
Currently, there is no contribution information from them but I will gladly add it when I know what to put. I slightly adapted them but the fixes have been removed by the following patches.
After using them, I removed the new ""context"" argument which was not necessary.
This removed the need for the additional headers and made the connection management only to the ""communication"" layer implementation. It's still done in separate commits to see the difference.
er-rest-dtls
Example copied from er-rest-example with features removed and a specific project-conf.h.
I removed the netstack configuration and set a big UIP_CONF_BUFFER_SIZE, which should be the same on the border router.
It works on my motes (cortex-m3 based with lot of ram) but did not tested it on other platforms.
The only requirement to make an er-rest example work with dtls is to set ""WITH_DTLS_COAP=1"" in the makefile and have a big enough UIP_CONF_BUFFER_SIZE (not tested the minimal value).
What do you think ?
Regards,
cladmi","@alemusix Hello! Have you solved this problem with DTLS in Cooja? If yes, please help me, I really need that.

Hi @Viktoriia55 unfortunately I never managed to solve the problem in Cooja, so I can't help you.

very sorry, thank you!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1997,2016-12-14T14:42:57Z,2016-12-27T21:38:15Z,2017-01-04T14:20:12Z,MERGED,True,19,6,2,https://github.com/yatch,Introduce packetbuf_remaininglen(),3,[],https://github.com/contiki-os/contiki/pull/1997,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1997,"As far as I know, we don't have any API to get the length of remaining data space in packetbuf. packetbuf_remaininglen() provides this.","As far as I know, we don't have any API to get the length of remaining data space in packetbuf. packetbuf_remaininglen() provides this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1997,2016-12-14T14:42:57Z,2016-12-27T21:38:15Z,2017-01-04T14:20:12Z,MERGED,True,19,6,2,https://github.com/yatch,Introduce packetbuf_remaininglen(),3,[],https://github.com/contiki-os/contiki/pull/1997,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/1997#issuecomment-267284499,"As far as I know, we don't have any API to get the length of remaining data space in packetbuf. packetbuf_remaininglen() provides this.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1997,2016-12-14T14:42:57Z,2016-12-27T21:38:15Z,2017-01-04T14:20:12Z,MERGED,True,19,6,2,https://github.com/yatch,Introduce packetbuf_remaininglen(),3,[],https://github.com/contiki-os/contiki/pull/1997,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/1997#issuecomment-269386276,"As far as I know, we don't have any API to get the length of remaining data space in packetbuf. packetbuf_remaininglen() provides this.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1998,2016-12-14T15:48:03Z,,2017-10-27T09:00:28Z,OPEN,False,36,22,3,https://github.com/yatch,Introduce new packetbuf attributes for the IEEE 802.15.4 frame,3,[],https://github.com/contiki-os/contiki/pull/1998,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/1998,"Summary
An IEEE 802.15.4 frame could have a metadata, Information Element, which is part of the header and may be part of payload. To handle this type of data in packetbuf at the IEEE 802.15.4 layer, PACKETBUF_ATTR_MAC_METADATA is introduced.
In addition, an IEEE 802.15.4 frame may not have the source address in the header. It may not have the destination address. To express such a situation, PACKET_ATTR_NO_SRC_ADDR and PACKET_ATTR_NO_DEST_ADDR are introduced.
The newly introduced attributes are used in frame802154.c and framer-802154.c.
Dependency
**This PR depends on #1994 **.
Two failures in the Travis test, BUILD_TYPE=ipv6 and BUILD_TYPE=ipv6-apps will be resolved by #1994 .","Summary
An IEEE 802.15.4 frame could have a metadata, Information Element, which is part of the header and may be part of payload. To handle this type of data in packetbuf at the IEEE 802.15.4 layer, PACKETBUF_ATTR_MAC_METADATA is introduced.
In addition, an IEEE 802.15.4 frame may not have the source address in the header. It may not have the destination address. To express such a situation, PACKET_ATTR_NO_SRC_ADDR and PACKET_ATTR_NO_DEST_ADDR are introduced.
The newly introduced attributes are used in frame802154.c and framer-802154.c.
Dependency
**This PR depends on #1994 **.
Two failures in the Travis test, BUILD_TYPE=ipv6 and BUILD_TYPE=ipv6-apps will be resolved by #1994 .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1998,2016-12-14T15:48:03Z,,2017-10-27T09:00:28Z,OPEN,False,36,22,3,https://github.com/yatch,Introduce new packetbuf attributes for the IEEE 802.15.4 frame,3,[],https://github.com/contiki-os/contiki/pull/1998,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/1998#issuecomment-267303019,"Summary
An IEEE 802.15.4 frame could have a metadata, Information Element, which is part of the header and may be part of payload. To handle this type of data in packetbuf at the IEEE 802.15.4 layer, PACKETBUF_ATTR_MAC_METADATA is introduced.
In addition, an IEEE 802.15.4 frame may not have the source address in the header. It may not have the destination address. To express such a situation, PACKET_ATTR_NO_SRC_ADDR and PACKET_ATTR_NO_DEST_ADDR are introduced.
The newly introduced attributes are used in frame802154.c and framer-802154.c.
Dependency
**This PR depends on #1994 **.
Two failures in the Travis test, BUILD_TYPE=ipv6 and BUILD_TYPE=ipv6-apps will be resolved by #1994 .",@simonduq Thank you for your comments! Addresses them and rebased to have the Cooja bugfix.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1998,2016-12-14T15:48:03Z,,2017-10-27T09:00:28Z,OPEN,False,36,22,3,https://github.com/yatch,Introduce new packetbuf attributes for the IEEE 802.15.4 frame,3,[],https://github.com/contiki-os/contiki/pull/1998,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/1998#issuecomment-267304058,"Summary
An IEEE 802.15.4 frame could have a metadata, Information Element, which is part of the header and may be part of payload. To handle this type of data in packetbuf at the IEEE 802.15.4 layer, PACKETBUF_ATTR_MAC_METADATA is introduced.
In addition, an IEEE 802.15.4 frame may not have the source address in the header. It may not have the destination address. To express such a situation, PACKET_ATTR_NO_SRC_ADDR and PACKET_ATTR_NO_DEST_ADDR are introduced.
The newly introduced attributes are used in frame802154.c and framer-802154.c.
Dependency
**This PR depends on #1994 **.
Two failures in the Travis test, BUILD_TYPE=ipv6 and BUILD_TYPE=ipv6-apps will be resolved by #1994 .",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1998,2016-12-14T15:48:03Z,,2017-10-27T09:00:28Z,OPEN,False,36,22,3,https://github.com/yatch,Introduce new packetbuf attributes for the IEEE 802.15.4 frame,3,[],https://github.com/contiki-os/contiki/pull/1998,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/1998#issuecomment-270948339,"Summary
An IEEE 802.15.4 frame could have a metadata, Information Element, which is part of the header and may be part of payload. To handle this type of data in packetbuf at the IEEE 802.15.4 layer, PACKETBUF_ATTR_MAC_METADATA is introduced.
In addition, an IEEE 802.15.4 frame may not have the source address in the header. It may not have the destination address. To express such a situation, PACKET_ATTR_NO_SRC_ADDR and PACKET_ATTR_NO_DEST_ADDR are introduced.
The newly introduced attributes are used in frame802154.c and framer-802154.c.
Dependency
**This PR depends on #1994 **.
Two failures in the Travis test, BUILD_TYPE=ipv6 and BUILD_TYPE=ipv6-apps will be resolved by #1994 .",Rebased and resolved the conflict.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,1998,2016-12-14T15:48:03Z,,2017-10-27T09:00:28Z,OPEN,False,36,22,3,https://github.com/yatch,Introduce new packetbuf attributes for the IEEE 802.15.4 frame,3,[],https://github.com/contiki-os/contiki/pull/1998,https://github.com/alexrayne,5,https://github.com/contiki-os/contiki/pull/1998#issuecomment-339915166,"Summary
An IEEE 802.15.4 frame could have a metadata, Information Element, which is part of the header and may be part of payload. To handle this type of data in packetbuf at the IEEE 802.15.4 layer, PACKETBUF_ATTR_MAC_METADATA is introduced.
In addition, an IEEE 802.15.4 frame may not have the source address in the header. It may not have the destination address. To express such a situation, PACKET_ATTR_NO_SRC_ADDR and PACKET_ATTR_NO_DEST_ADDR are introduced.
The newly introduced attributes are used in frame802154.c and framer-802154.c.
Dependency
**This PR depends on #1994 **.
Two failures in the Travis test, BUILD_TYPE=ipv6 and BUILD_TYPE=ipv6-apps will be resolved by #1994 .","Hallow. imho instead 2 attrs PACKET_ATTR_NO_SRC/DST_ADDR can be use one attr like PACKET_ATTR_DROP with values denotes exact elements to drop from frame.
this is saves 1 attr memory, and allows enhance for some other values to drop",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/joakimeriksson,1,https://github.com/contiki-os/contiki/pull/2001,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.","The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/2001#issuecomment-267411294,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.","Oh, I need this fix! ‚ú®",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2001#issuecomment-269943911,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.",@joakimeriksson is this good to go?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/joakimeriksson,4,https://github.com/contiki-os/contiki/pull/2001#issuecomment-270075704,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.","Yes, I would say so!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/2001#issuecomment-270075739,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/yatch,6,https://github.com/contiki-os/contiki/pull/2001#issuecomment-271974251,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.","It seems that Cooja still needs one click to start in the quickmode...
For example, I need to click the ""Compile"" button on the small window named ""Create Mote Type"" in Cooja when I start a simulation by followings:
$ cd regression-tests/25-ieee802154
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -quickstart=01-panid-handling.csc  -contiki=../..

Is it an expected behavior? I think Cooja used to start up in the quickstart mode without any click... For example,  back to the commit of ac2a314, it worked as I thought.
Sidenote: I got an error with the nogui mode which was not seen at the commit of ac2a314. I have no idea whether it's relevant or not...
 INFO [main] (ContikiMoteType.java:404) - Creating core communicator between Java class Lib1 and Contiki library '/home/yatch/work/contiki/regression-tests/25-ieee802154/code/obj_cooja/mtype80.cooja'
javac 1.8.0_111
org/contikios/cooja/corecomm/Lib1.java:40: error: cannot find symbol
public class Lib1 extends CoreComm {
                          ^
  symbol: class CoreComm
1 error",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2001,2016-12-15T10:52:58Z,2017-01-03T09:26:53Z,2017-01-11T20:34:00Z,MERGED,True,33,21,14,https://github.com/joakimeriksson,fixed so that Cooja can run in quick mode when having UI,1,[],https://github.com/contiki-os/contiki/pull/2001,https://github.com/joakimeriksson,7,https://github.com/contiki-os/contiki/pull/2001#issuecomment-271985893,"The fix for travis (#1987) made the regular UI mode a bit boring to use since the ""quick"" mode did not work anymore so that everybody need to click 10 times to start the simulation. This fix re-enabled quick mode when using UI again and make using Cooja. Now any component that is configured at startup should respect simulator.isQuickSetup() if it supports quick mode.",Thanks for the feedback - I will check if there is more places where the quick mode needs to be handled!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2002,2016-12-15T13:21:07Z,2017-01-10T13:05:36Z,2017-01-10T13:09:00Z,MERGED,True,804,89,21,https://github.com/yatch,TSCH Miscelleneous updates,6,[],https://github.com/contiki-os/contiki/pull/2002,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2002,"Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes","Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2002,2016-12-15T13:21:07Z,2017-01-10T13:05:36Z,2017-01-10T13:09:00Z,MERGED,True,804,89,21,https://github.com/yatch,TSCH Miscelleneous updates,6,[],https://github.com/contiki-os/contiki/pull/2002,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2002#issuecomment-267334826,"Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2002,2016-12-15T13:21:07Z,2017-01-10T13:05:36Z,2017-01-10T13:09:00Z,MERGED,True,804,89,21,https://github.com/yatch,TSCH Miscelleneous updates,6,[],https://github.com/contiki-os/contiki/pull/2002,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/2002#issuecomment-271542440,"Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes","üëç, but there are some conflicts that need to be resolved first.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2002,2016-12-15T13:21:07Z,2017-01-10T13:05:36Z,2017-01-10T13:09:00Z,MERGED,True,804,89,21,https://github.com/yatch,TSCH Miscelleneous updates,6,[],https://github.com/contiki-os/contiki/pull/2002,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/2002#issuecomment-271542935,"Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes",@nvt Indeed. I'll resolve the conflicts soon.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2002,2016-12-15T13:21:07Z,2017-01-10T13:05:36Z,2017-01-10T13:09:00Z,MERGED,True,804,89,21,https://github.com/yatch,TSCH Miscelleneous updates,6,[],https://github.com/contiki-os/contiki/pull/2002,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/2002#issuecomment-271560463,"Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes","The conflicts have been resolved. And, Travis got green. üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2002,2016-12-15T13:21:07Z,2017-01-10T13:05:36Z,2017-01-10T13:09:00Z,MERGED,True,804,89,21,https://github.com/yatch,TSCH Miscelleneous updates,6,[],https://github.com/contiki-os/contiki/pull/2002,https://github.com/alignan,6,https://github.com/contiki-os/contiki/pull/2002#issuecomment-271562820,"Put tsch_ prefix to some global names
Add the const modifier to dest addr in tsch_packet_create_eack()
Add missing error checks / fix a wrong return value
Add regression tests for APIs in implemented tsch-packet.c
Indentation fixes",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2004,2016-12-15T18:39:43Z,2017-01-10T10:23:56Z,2017-01-10T12:13:53Z,MERGED,True,37,21,2,https://github.com/yatch,Trivial Updates on tsch-security.[ch],3,[],https://github.com/contiki-os/contiki/pull/2004,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2004,"Add brief explanations for the APIs (tsch-packet.h)
Fix indentation in tsch-packet.c
Change the return type of the APIs from 'int' to 'unsigned int'","Add brief explanations for the APIs (tsch-packet.h)
Fix indentation in tsch-packet.c
Change the return type of the APIs from 'int' to 'unsigned int'",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2004,2016-12-15T18:39:43Z,2017-01-10T10:23:56Z,2017-01-10T12:13:53Z,MERGED,True,37,21,2,https://github.com/yatch,Trivial Updates on tsch-security.[ch],3,[],https://github.com/contiki-os/contiki/pull/2004,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2004#issuecomment-271536477,"Add brief explanations for the APIs (tsch-packet.h)
Fix indentation in tsch-packet.c
Change the return type of the APIs from 'int' to 'unsigned int'",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2004,2016-12-15T18:39:43Z,2017-01-10T10:23:56Z,2017-01-10T12:13:53Z,MERGED,True,37,21,2,https://github.com/yatch,Trivial Updates on tsch-security.[ch],3,[],https://github.com/contiki-os/contiki/pull/2004,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2004#issuecomment-271539092,"Add brief explanations for the APIs (tsch-packet.h)
Fix indentation in tsch-packet.c
Change the return type of the APIs from 'int' to 'unsigned int'",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2008,2016-12-20T17:32:11Z,2016-12-21T02:30:20Z,2016-12-29T09:14:14Z,MERGED,True,3,1,1,https://github.com/alignan,zoul: default cc2538-bsl baudrate to 460800,1,['bug'],https://github.com/contiki-os/contiki/pull/2008,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2008,"This PR brings back having the baudrate set at the platform's Makefile, instead of defaulting to the maximum value in the cc2538-bsl script.  Now the default (and tested) baudrate is 460800.
After testing several batches of platforms, we found the 3% have timing issues, related probably to the on-board PIC governing the flashing process, thus using the default 500000 yielded in errors, whereas other baudrates are OK:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 500000
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
ERROR: Timeout waiting for ACK/NACK after 'Mem Read (0x2A)'
make: *** [zoul-demo./dev/ttyUSB0] Error 1
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 460800
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
CC2538 PG2.0: 512KB Flash, 32KB SRAM, CCFG at 0x0027FFD4
Primary IEEE Address: 00:12:4B:00:06:0D:67:F1
Erasing 524288 bytes starting at address 0x00200000
    Erase done
Writing 516096 bytes starting at address 0x00202000
Write 8 bytes at 0x0027FFF8F00
    Write done                                
Verifying by comparing CRC32 calculations.
    Verified (match: 0x2492f289)
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800 is a good trade-off as it is close to the maximum 500000, and it will work 100% of the times in 100% of boards.","This PR brings back having the baudrate set at the platform's Makefile, instead of defaulting to the maximum value in the cc2538-bsl script.  Now the default (and tested) baudrate is 460800.
After testing several batches of platforms, we found the 3% have timing issues, related probably to the on-board PIC governing the flashing process, thus using the default 500000 yielded in errors, whereas other baudrates are OK:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 500000
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
ERROR: Timeout waiting for ACK/NACK after 'Mem Read (0x2A)'
make: *** [zoul-demo./dev/ttyUSB0] Error 1
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 460800
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
CC2538 PG2.0: 512KB Flash, 32KB SRAM, CCFG at 0x0027FFD4
Primary IEEE Address: 00:12:4B:00:06:0D:67:F1
Erasing 524288 bytes starting at address 0x00200000
    Erase done
Writing 516096 bytes starting at address 0x00202000
Write 8 bytes at 0x0027FFF8F00
    Write done                                
Verifying by comparing CRC32 calculations.
    Verified (match: 0x2492f289)
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800 is a good trade-off as it is close to the maximum 500000, and it will work 100% of the times in 100% of boards.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2008,2016-12-20T17:32:11Z,2016-12-21T02:30:20Z,2016-12-29T09:14:14Z,MERGED,True,3,1,1,https://github.com/alignan,zoul: default cc2538-bsl baudrate to 460800,1,['bug'],https://github.com/contiki-os/contiki/pull/2008,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2008#issuecomment-268351481,"This PR brings back having the baudrate set at the platform's Makefile, instead of defaulting to the maximum value in the cc2538-bsl script.  Now the default (and tested) baudrate is 460800.
After testing several batches of platforms, we found the 3% have timing issues, related probably to the on-board PIC governing the flashing process, thus using the default 500000 yielded in errors, whereas other baudrates are OK:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 500000
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
ERROR: Timeout waiting for ACK/NACK after 'Mem Read (0x2A)'
make: *** [zoul-demo./dev/ttyUSB0] Error 1
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 460800
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
CC2538 PG2.0: 512KB Flash, 32KB SRAM, CCFG at 0x0027FFD4
Primary IEEE Address: 00:12:4B:00:06:0D:67:F1
Erasing 524288 bytes starting at address 0x00200000
    Erase done
Writing 516096 bytes starting at address 0x00202000
Write 8 bytes at 0x0027FFF8F00
    Write done                                
Verifying by comparing CRC32 calculations.
    Verified (match: 0x2492f289)
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800 is a good trade-off as it is close to the maximum 500000, and it will work 100% of the times in 100% of boards.",Antonio do you want to allow users to override from the command line too? üëç otherwise,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2008,2016-12-20T17:32:11Z,2016-12-21T02:30:20Z,2016-12-29T09:14:14Z,MERGED,True,3,1,1,https://github.com/alignan,zoul: default cc2538-bsl baudrate to 460800,1,['bug'],https://github.com/contiki-os/contiki/pull/2008,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2008#issuecomment-268355324,"This PR brings back having the baudrate set at the platform's Makefile, instead of defaulting to the maximum value in the cc2538-bsl script.  Now the default (and tested) baudrate is 460800.
After testing several batches of platforms, we found the 3% have timing issues, related probably to the on-board PIC governing the flashing process, thus using the default 500000 yielded in errors, whereas other baudrates are OK:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 500000
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
ERROR: Timeout waiting for ACK/NACK after 'Mem Read (0x2A)'
make: *** [zoul-demo./dev/ttyUSB0] Error 1
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 460800
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
CC2538 PG2.0: 512KB Flash, 32KB SRAM, CCFG at 0x0027FFD4
Primary IEEE Address: 00:12:4B:00:06:0D:67:F1
Erasing 524288 bytes starting at address 0x00200000
    Erase done
Writing 516096 bytes starting at address 0x00202000
Write 8 bytes at 0x0027FFF8F00
    Write done                                
Verifying by comparing CRC32 calculations.
    Verified (match: 0x2492f289)
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800 is a good trade-off as it is close to the maximum 500000, and it will work 100% of the times in 100% of boards.","Using i.e BSL_SPEED=115200 should override the default, I tested earlier, got any other suggestion?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2008,2016-12-20T17:32:11Z,2016-12-21T02:30:20Z,2016-12-29T09:14:14Z,MERGED,True,3,1,1,https://github.com/alignan,zoul: default cc2538-bsl baudrate to 460800,1,['bug'],https://github.com/contiki-os/contiki/pull/2008,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2008#issuecomment-268375539,"This PR brings back having the baudrate set at the platform's Makefile, instead of defaulting to the maximum value in the cc2538-bsl script.  Now the default (and tested) baudrate is 460800.
After testing several batches of platforms, we found the 3% have timing issues, related probably to the on-board PIC governing the flashing process, thus using the default 500000 yielded in errors, whereas other baudrates are OK:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 500000
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
ERROR: Timeout waiting for ACK/NACK after 'Mem Read (0x2A)'
make: *** [zoul-demo./dev/ttyUSB0] Error 1
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 460800
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
CC2538 PG2.0: 512KB Flash, 32KB SRAM, CCFG at 0x0027FFD4
Primary IEEE Address: 00:12:4B:00:06:0D:67:F1
Erasing 524288 bytes starting at address 0x00200000
    Erase done
Writing 516096 bytes starting at address 0x00202000
Write 8 bytes at 0x0027FFF8F00
    Write done                                
Verifying by comparing CRC32 calculations.
    Verified (match: 0x2492f289)
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800 is a good trade-off as it is close to the maximum 500000, and it will work 100% of the times in 100% of boards.","I was thinking something along the lines
ifeq ($(BSL_SPEED),)
  BSL_SPEED = 115200 
endif

or something like that, but the way it is now looks good to me if you can't be bothered!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2008,2016-12-20T17:32:11Z,2016-12-21T02:30:20Z,2016-12-29T09:14:14Z,MERGED,True,3,1,1,https://github.com/alignan,zoul: default cc2538-bsl baudrate to 460800,1,['bug'],https://github.com/contiki-os/contiki/pull/2008,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/2008#issuecomment-268417650,"This PR brings back having the baudrate set at the platform's Makefile, instead of defaulting to the maximum value in the cc2538-bsl script.  Now the default (and tested) baudrate is 460800.
After testing several batches of platforms, we found the 3% have timing issues, related probably to the on-board PIC governing the flashing process, thus using the default 500000 yielded in errors, whereas other baudrates are OK:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 500000
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
ERROR: Timeout waiting for ACK/NACK after 'Mem Read (0x2A)'
make: *** [zoul-demo./dev/ttyUSB0] Error 1
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800:
$ make TARGET=zoul BOARD=firefly-reva zoul-demo.upload
  CC        ../../../cpu/cc2538/./ieee-addr.c
  CC        ../../../cpu/cc2538/cc2538.lds
  CC        ../../../cpu/cc2538/./startup-gcc.c
  CC        zoul-demo.c
  LD        zoul-demo.elf
arm-none-eabi-objcopy -O binary --gap-fill 0xff zoul-demo.elf zoul-demo.bin
Flashing /dev/ttyUSB0
Opening port /dev/ttyUSB0, baud 460800
Reading data from zoul-demo.bin
Firmware file: Raw Binary
Connecting to target...
CC2538 PG2.0: 512KB Flash, 32KB SRAM, CCFG at 0x0027FFD4
Primary IEEE Address: 00:12:4B:00:06:0D:67:F1
Erasing 524288 bytes starting at address 0x00200000
    Erase done
Writing 516096 bytes starting at address 0x00202000
Write 8 bytes at 0x0027FFF8F00
    Write done                                
Verifying by comparing CRC32 calculations.
    Verified (match: 0x2492f289)
rm obj_zoul/startup-gcc.o zoul-demo.co

Using 460800 is a good trade-off as it is close to the maximum 500000, and it will work 100% of the times in 100% of boards.",Never mind me!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2011,2016-12-21T14:07:41Z,2017-01-10T08:07:27Z,2017-01-11T21:20:23Z,MERGED,True,11,5,3,https://github.com/jdede,Enable llsec on Z1 nodes,2,[],https://github.com/contiki-os/contiki/pull/2011,https://github.com/jdede,1,https://github.com/contiki-os/contiki/pull/2011,This PR add the required includes and commands to use link layer security (llsec) with Zolertia Z1 nodes (copied from Sky platform).,This PR add the required includes and commands to use link layer security (llsec) with Zolertia Z1 nodes (copied from Sky platform).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2011,2016-12-21T14:07:41Z,2017-01-10T08:07:27Z,2017-01-11T21:20:23Z,MERGED,True,11,5,3,https://github.com/jdede,Enable llsec on Z1 nodes,2,[],https://github.com/contiki-os/contiki/pull/2011,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2011#issuecomment-271511082,This PR add the required includes and commands to use link layer security (llsec) with Zolertia Z1 nodes (copied from Sky platform).,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2011,2016-12-21T14:07:41Z,2017-01-10T08:07:27Z,2017-01-11T21:20:23Z,MERGED,True,11,5,3,https://github.com/jdede,Enable llsec on Z1 nodes,2,[],https://github.com/contiki-os/contiki/pull/2011,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2011#issuecomment-271511134,This PR add the required includes and commands to use link layer security (llsec) with Zolertia Z1 nodes (copied from Sky platform).,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2012,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)","The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2012#issuecomment-271511025,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)","Hi @laurentderu did you also test this with TSCH?
Please note Travis is not happy, there is a warning on jn516x",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/2012#issuecomment-272870321,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)","@simonduq The root cause of travis issue is I believe due to the fact that the version of JN516 SDK used by Travis is a bit older and does not include the definition of function vMMAC_SetChannelAndPower(), the latest one does (in Components/MMAC/Include/MMAC.h).
I haven't really tested with TSCH as my idea was to still use the raw radio layer to TSCH.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/neophob,4,https://github.com/contiki-os/contiki/pull/2012#issuecomment-284737496,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)","any news on this PR? I've tested it (using the older JN SDK) and it improves connection reliability, especially if you send larger packages (for example via coap)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/2012#issuecomment-285004211,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)","Sorry for the delay. @laurentderu , rebasing after #2129 is merged should do!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/2012#issuecomment-285052820,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)","#2129 now merged, can you rebase this?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/laurentderu,7,https://github.com/contiki-os/contiki/pull/2012#issuecomment-285084454,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)",Rebased and now travis is green,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2012,2016-12-22T08:18:58Z,2017-03-09T07:53:48Z,2018-10-24T06:59:57Z,MERGED,True,190,32,4,https://github.com/laurentderu,JN516x: Add support for hardware MAC,3,[],https://github.com/contiki-os/contiki/pull/2012,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/2012#issuecomment-285280116,"The PR allows the micromac driver of the JN516x platform to use the hardware MAC layer engine provided by NXP.
At first I wanted to have a JN516 framer to create a specific frame for micromac, however there are so many pieces of code that assume that the content of a packetbuf is a real 802.15.4 frame, that the complexity of the change were skyrocketing... Instead, the driver receives the 802.15.4 frame from the RDC layer and dissect it to create the JN516 specific frame and send it to the micromac driver. Similarly, when a frame is received from the microbic layer, the driver recreates a full 802.15.4 frame.
This driver has been tested with NullRDC and ContikiMAC, but without LLSEC, this would require additional changes to support the security header.
By default the hardware mac layer is still disabled, it can be activated using  MICROMAC_CONF_RADIO_MAC macro. However, the default configuration in contiki-conf.h of JN516x reference csma_driver and nullrdc_driver which requires the hardware MAC to be enabled, so in the future either the contiki-conf.h should be modified to activate it by default and modify the TSCH examples to disable it explicitly or make TSCH the default MAC layer for JN516x :)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,1,https://github.com/contiki-os/contiki/pull/2023,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/andynnd,2,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269743751,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","Hi Peretuset,
The automatic bootloading mode can work with baudrate 450000 or 115200, cannot work with baudrate 500000. Mean that using below script
BSL_FLAGS += -e --bootloader-invert-lines -w -v -b 450000 or
BSL_FLAGS += -e --bootloader-invert-lines -w -v -b 115200.
Regards,",True,{'THUMBS_UP': ['https://github.com/ngovanmao']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,3,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269745748,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","@marknnd, can you please check that you using the OpenUSB rev.A1 board? We have tested it in various computers and operating systems and it worked well in all at 500000 bauds/s.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/andynnd,4,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269746490,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","I test on OpenUSB Rev.A1, Openmote Rev.E.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,5,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269747933,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","What OS?
Pere",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/andynnd,6,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269748208,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",Ubuntu 14.04 32bits,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,7,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269748317,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","Allright, thanks!
Ubuntu is working natively or on a VM?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/andynnd,8,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269748574,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","On a VM, plug directly, no USB hub.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,9,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269748923,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","I see. Could you try on a Ubuntu machine that runs natively? On my side I will try with a Ubuntu VM to see if there is any effect. So far, we only tried with machines natively, but if there are some side effects we can reduce the baudrate to make sure it works well on all platforms.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/andynnd,10,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269753120,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","After test on native Ubuntu PC, it still cannot work at 500000 baudrate. I think we need to reduce a little bit.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,11,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269756408,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","I've tried myself within a Ubuntu 16.04 VM (64 bit) and it work just fine at 500000; I tried it several times with various boards and it was reliable. I will try with other operating system configurations and computers and see if this is a general or specific to certain environments to help decide. In the mean time, please use 450000 baudrate to continue working if that works reliably for you.
By the way, what computer are you using (i.e., specs)?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/andynnd,12,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269776307,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",I am using a Dell Desktop PC with CPU core i5.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/msloth,13,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269833558,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","Many times when such issues arise it might be as simple as a poor USB
cable. I'd suggest trying with another cable, and for this pr to use the
slightly slower speed that will give less support issues at the cost of a
neglible slower flash speed.
‚Ä¶
On Dec 30, 2016 3:16 PM, ""Marknnd"" ***@***.***> wrote:
 I am using a Dell Desktop PC with CPU core i5.

 ‚Äî
 You are receiving this because you are subscribed to this thread.
 Reply to this email directly, view it on GitHub
 <#2023 (comment)>,
 or mute the thread
 <https://github.com/notifications/unsubscribe-auth/AAm1pB-GRvAuELbC-AHB5xJgXG2AFxVWks5rNRJEgaJpZM4LXhk6>
 .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,14,https://github.com/contiki-os/contiki/pull/2023#issuecomment-269913275,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","100% agreed!
By the way, happy new year to you @msloth and to all... üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/simonduq,15,https://github.com/contiki-os/contiki/pull/2023#issuecomment-271510657,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",Is this ready to get in?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,16,https://github.com/contiki-os/contiki/pull/2023#issuecomment-271534050,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","I've just reduced the bootloader baudrate to be on the safe side, so it should be okay to merge in.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,17,https://github.com/contiki-os/contiki/pull/2023#issuecomment-271726180,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",It seems to me that the build is failing but is not caused by the last commit. Can you please double-check?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/simonduq,18,https://github.com/contiki-os/contiki/pull/2023#issuecomment-271805831,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",Seems unrelated indeed. Restarted the job,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,19,https://github.com/contiki-os/contiki/pull/2023#issuecomment-272133659,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","Seems good now, feel free to merge in when ready.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/simonduq,20,https://github.com/contiki-os/contiki/pull/2023#issuecomment-272135677,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/peretuset,21,https://github.com/contiki-os/contiki/pull/2023#issuecomment-276785509,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.",Is there a plan on merge this in any time soon?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2023,2016-12-29T11:36:48Z,2017-02-02T07:47:07Z,2017-02-02T07:47:08Z,MERGED,True,11,4,2,https://github.com/peretuset,Adding support for OpenMote-CC2538 Rev.A1 and OpenUSB,4,[],https://github.com/contiki-os/contiki/pull/2023,https://github.com/simonduq,22,https://github.com/contiki-os/contiki/pull/2023#issuecomment-276889573,"This PR adds support for the OpenMote-CC2538 Rev.A1 board, which uses the CC2538SF23 (256 KB Flash) instead of the CC2538SF53 (512 KB Flash), and the new OpenUSB carrier board, which includes a Texas Instruments CC1200 radio transceiver for 868/915 MHz and has support for automatic bootloading using the cc2538-bsl Python script.","Let's get this merged, thanks!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2024,2016-12-29T12:06:12Z,2017-01-09T21:03:45Z,2017-01-09T21:03:45Z,MERGED,True,1870,1,23,https://github.com/alignan,Zolertia Orion ethernet router with active POE support,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2024,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2024,"This PR creates a new Zolertia device: the Orion Ethernet Router.
Orion has a Zoul (CC2538 + CC1200) plus an ENC28J60 ethernet module and support for Active POE (Power Over Ethernet).
For more information please refer to:

Orion Product page
Orion technical information","This PR creates a new Zolertia device: the Orion Ethernet Router.
Orion has a Zoul (CC2538 + CC1200) plus an ENC28J60 ethernet module and support for Active POE (Power Over Ethernet).
For more information please refer to:

Orion Product page
Orion technical information",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2024,2016-12-29T12:06:12Z,2017-01-09T21:03:45Z,2017-01-09T21:03:45Z,MERGED,True,1870,1,23,https://github.com/alignan,Zolertia Orion ethernet router with active POE support,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2024,https://github.com/adamdunkels,2,https://github.com/contiki-os/contiki/pull/2024#issuecomment-269902286,"This PR creates a new Zolertia device: the Orion Ethernet Router.
Orion has a Zoul (CC2538 + CC1200) plus an ENC28J60 ethernet module and support for Active POE (Power Over Ethernet).
For more information please refer to:

Orion Product page
Orion technical information","Great! Look like it has IP64 support from the start, right?
üëç from me!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2024,2016-12-29T12:06:12Z,2017-01-09T21:03:45Z,2017-01-09T21:03:45Z,MERGED,True,1870,1,23,https://github.com/alignan,Zolertia Orion ethernet router with active POE support,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2024,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2024#issuecomment-269943786,"This PR creates a new Zolertia device: the Orion Ethernet Router.
Orion has a Zoul (CC2538 + CC1200) plus an ENC28J60 ethernet module and support for Active POE (Power Over Ethernet).
For more information please refer to:

Orion Product page
Orion technical information","Yes! that's the main feature, it is able to ""talk"" directly to IPv4-based services üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2024,2016-12-29T12:06:12Z,2017-01-09T21:03:45Z,2017-01-09T21:03:45Z,MERGED,True,1870,1,23,https://github.com/alignan,Zolertia Orion ethernet router with active POE support,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2024,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/2024#issuecomment-270645269,"This PR creates a new Zolertia device: the Orion Ethernet Router.
Orion has a Zoul (CC2538 + CC1200) plus an ENC28J60 ethernet module and support for Active POE (Power Over Ethernet).
For more information please refer to:

Orion Product page
Orion technical information",,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2024,2016-12-29T12:06:12Z,2017-01-09T21:03:45Z,2017-01-09T21:03:45Z,MERGED,True,1870,1,23,https://github.com/alignan,Zolertia Orion ethernet router with active POE support,1,"['new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2024,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/2024#issuecomment-271407112,"This PR creates a new Zolertia device: the Orion Ethernet Router.
Orion has a Zoul (CC2538 + CC1200) plus an ENC28J60 ethernet module and support for Active POE (Power Over Ethernet).
For more information please refer to:

Orion Product page
Orion technical information",üëç tested. This is sweet,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2025,2016-12-29T12:26:26Z,,2017-01-14T17:23:58Z,OPEN,False,48,4,3,https://github.com/alignan,Override HTTP host/path lenght and updated http-socket example,2,['enhancement'],https://github.com/contiki-os/contiki/pull/2025,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2025,"This PR allows to override the maximum host and path lenght used by the http-socket library, and adds reconnections attempts to the http-socket example.","This PR allows to override the maximum host and path lenght used by the http-socket library, and adds reconnections attempts to the http-socket example.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2026,2016-12-29T12:42:36Z,2016-12-29T17:00:50Z,2016-12-29T17:00:52Z,MERGED,True,8,4,2,https://github.com/alignan,Minor documentation fixes,3,"['enhancement', 'documentation']",https://github.com/contiki-os/contiki/pull/2026,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2026,Updated documentation and fixed broken links,Updated documentation and fixed broken links,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2026,2016-12-29T12:42:36Z,2016-12-29T17:00:50Z,2016-12-29T17:00:52Z,MERGED,True,8,4,2,https://github.com/alignan,Minor documentation fixes,3,"['enhancement', 'documentation']",https://github.com/contiki-os/contiki/pull/2026,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2026#issuecomment-269659755,Updated documentation and fixed broken links,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2027,2016-12-29T13:20:41Z,2017-01-09T21:02:21Z,2017-01-09T21:02:21Z,MERGED,True,2,1,1,https://github.com/alignan,zoul: fix a bitmask bug in channels used,1,"['bug', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2027,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2027,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2028,2016-12-29T15:36:33Z,2017-01-10T08:07:51Z,2017-01-10T08:07:51Z,MERGED,True,4,1,2,https://github.com/joakimeriksson,added support for 6-bytes link-layer address,2,[],https://github.com/contiki-os/contiki/pull/2028,https://github.com/joakimeriksson,1,https://github.com/contiki-os/contiki/pull/2028,This PR adds the ability for the nbr table to use 6-bytes link-layer address. Should improve things for cases where Ethernet is used instead of 802.15.4 (8 or 2 bytes). Also fixed config for minimal-net to use the 6-bytes address as it make use of a TAP (ethernet) to hook into the IP-stack of the host.,This PR adds the ability for the nbr table to use 6-bytes link-layer address. Should improve things for cases where Ethernet is used instead of 802.15.4 (8 or 2 bytes). Also fixed config for minimal-net to use the 6-bytes address as it make use of a TAP (ethernet) to hook into the IP-stack of the host.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2028,2016-12-29T15:36:33Z,2017-01-10T08:07:51Z,2017-01-10T08:07:51Z,MERGED,True,4,1,2,https://github.com/joakimeriksson,added support for 6-bytes link-layer address,2,[],https://github.com/contiki-os/contiki/pull/2028,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2028#issuecomment-271510485,This PR adds the ability for the nbr table to use 6-bytes link-layer address. Should improve things for cases where Ethernet is used instead of 802.15.4 (8 or 2 bytes). Also fixed config for minimal-net to use the 6-bytes address as it make use of a TAP (ethernet) to hook into the IP-stack of the host.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2028,2016-12-29T15:36:33Z,2017-01-10T08:07:51Z,2017-01-10T08:07:51Z,MERGED,True,4,1,2,https://github.com/joakimeriksson,added support for 6-bytes link-layer address,2,[],https://github.com/contiki-os/contiki/pull/2028,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2028#issuecomment-271511189,This PR adds the ability for the nbr table to use 6-bytes link-layer address. Should improve things for cases where Ethernet is used instead of 802.15.4 (8 or 2 bytes). Also fixed config for minimal-net to use the 6-bytes address as it make use of a TAP (ethernet) to hook into the IP-stack of the host.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2029,2016-12-30T11:16:00Z,2017-01-02T08:18:55Z,2017-01-02T08:18:55Z,MERGED,True,1,1,1,https://github.com/t-than,Minor typo change,1,[],https://github.com/contiki-os/contiki/pull/2029,https://github.com/t-than,1,https://github.com/contiki-os/contiki/pull/2029,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2029,2016-12-30T11:16:00Z,2017-01-02T08:18:55Z,2017-01-02T08:18:55Z,MERGED,True,1,1,1,https://github.com/t-than,Minor typo change,1,[],https://github.com/contiki-os/contiki/pull/2029,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2029#issuecomment-269762750,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2032,2017-01-04T10:03:54Z,2017-01-10T07:47:31Z,2017-10-27T20:05:33Z,MERGED,True,7,0,1,https://github.com/simonduq,TSCH bugfix: reset keep-alive timeout when switching time source,1,['bug'],https://github.com/contiki-os/contiki/pull/2032,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/2032,The bug was created when adding adaptive sync traffic with #1741,The bug was created when adding adaptive sync traffic with #1741,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2032,2017-01-04T10:03:54Z,2017-01-10T07:47:31Z,2017-10-27T20:05:33Z,MERGED,True,7,0,1,https://github.com/simonduq,TSCH bugfix: reset keep-alive timeout when switching time source,1,['bug'],https://github.com/contiki-os/contiki/pull/2032,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2032#issuecomment-271507731,The bug was created when adding adaptive sync traffic with #1741,I've been using this and testing extensively. Merging very soon unless somebody suggests otherwise,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2032,2017-01-04T10:03:54Z,2017-01-10T07:47:31Z,2017-10-27T20:05:33Z,MERGED,True,7,0,1,https://github.com/simonduq,TSCH bugfix: reset keep-alive timeout when switching time source,1,['bug'],https://github.com/contiki-os/contiki/pull/2032,https://github.com/alignan,3,https://github.com/contiki-os/contiki/pull/2032#issuecomment-271507882,The bug was created when adding adaptive sync traffic with #1741,"It is a straightforward fix, merging right away üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2033,2017-01-04T12:02:46Z,,2017-01-04T15:56:58Z,OPEN,False,18,11,4,https://github.com/afonsomota,"Step 3 of ""Cooja mote configuration wizard"" now passing in Instant Contiki",2,[],https://github.com/contiki-os/contiki/pull/2033,https://github.com/afonsomota,1,https://github.com/contiki-os/contiki/pull/2033,"In response to #1991
Altered regex expressions in external_tools.config to fit the output of the nm -aP $(LIBFILE) command.
Also added a method to get variables out of SectionParser to easily retrieve variables from the parsed document: the code to parse the variables was in the parser class, but this information was not being retrieved by the configuration wizard. Also some configuration strings were wrong.
Did not do the Map, from what I could see the generated map file does not have the information of a variable size in one line for variables in the data section. Is it required to get the current line holding the variable's address and name and the address in the next line to get the size? I did not do it as it seems to be working as is using the nm command.
I also fixed the nmandsize script in tools/cooja/examples/jni_test/mac_users since it was an easy fix. The awk command was missing the --non-decimal-data argument in order to sum hexadecimal values.
As for the memory replacement test, it is not being completed successfully: it freezes in memory.setMemorySegment(relDataSectionAddr, initialDataSection);. The problems seems to be that the test is missing the memory segment creation part: addMemorySegment is never called in the test if I am not mistaken.
Cheers,
Afonso","In response to #1991
Altered regex expressions in external_tools.config to fit the output of the nm -aP $(LIBFILE) command.
Also added a method to get variables out of SectionParser to easily retrieve variables from the parsed document: the code to parse the variables was in the parser class, but this information was not being retrieved by the configuration wizard. Also some configuration strings were wrong.
Did not do the Map, from what I could see the generated map file does not have the information of a variable size in one line for variables in the data section. Is it required to get the current line holding the variable's address and name and the address in the next line to get the size? I did not do it as it seems to be working as is using the nm command.
I also fixed the nmandsize script in tools/cooja/examples/jni_test/mac_users since it was an easy fix. The awk command was missing the --non-decimal-data argument in order to sum hexadecimal values.
As for the memory replacement test, it is not being completed successfully: it freezes in memory.setMemorySegment(relDataSectionAddr, initialDataSection);. The problems seems to be that the test is missing the memory segment creation part: addMemorySegment is never called in the test if I am not mistaken.
Cheers,
Afonso",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2034,2017-01-04T19:02:14Z,2017-01-12T06:49:31Z,2017-01-12T21:14:47Z,MERGED,True,3,2,1,https://github.com/Vinggui,Fixing Avr-Zigbit Makefile not compiling.,2,[],https://github.com/contiki-os/contiki/pull/2034,https://github.com/Vinggui,1,https://github.com/contiki-os/contiki/pull/2034,"I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.","I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2034,2017-01-04T19:02:14Z,2017-01-12T06:49:31Z,2017-01-12T21:14:47Z,MERGED,True,3,2,1,https://github.com/Vinggui,Fixing Avr-Zigbit Makefile not compiling.,2,[],https://github.com/contiki-os/contiki/pull/2034,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2034#issuecomment-271227181,"I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.","I see that this fixes the compilation for avr-zigbit, but could you quickly revise the commit message so that it briefly explains the technical modification only?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2034,2017-01-04T19:02:14Z,2017-01-12T06:49:31Z,2017-01-12T21:14:47Z,MERGED,True,3,2,1,https://github.com/Vinggui,Fixing Avr-Zigbit Makefile not compiling.,2,[],https://github.com/contiki-os/contiki/pull/2034,https://github.com/Vinggui,3,https://github.com/contiki-os/contiki/pull/2034#issuecomment-271700487,"I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.","Sure, I will revise it, but, as I did it online, I don't know where to do it. Or should I make another commit over this one?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2034,2017-01-04T19:02:14Z,2017-01-12T06:49:31Z,2017-01-12T21:14:47Z,MERGED,True,3,2,1,https://github.com/Vinggui,Fixing Avr-Zigbit Makefile not compiling.,2,[],https://github.com/contiki-os/contiki/pull/2034,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2034#issuecomment-271806464,"I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.",Here is a description of how to change it: https://help.github.com/articles/changing-a-commit-message/,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2034,2017-01-04T19:02:14Z,2017-01-12T06:49:31Z,2017-01-12T21:14:47Z,MERGED,True,3,2,1,https://github.com/Vinggui,Fixing Avr-Zigbit Makefile not compiling.,2,[],https://github.com/contiki-os/contiki/pull/2034,https://github.com/Vinggui,5,https://github.com/contiki-os/contiki/pull/2034#issuecomment-271943023,"I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.","I think I've done it. As I said, I did these changes here in the online editor, so that brought me this doubt. Anything else, just say and I'll try to fix it.
Ty",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2034,2017-01-04T19:02:14Z,2017-01-12T06:49:31Z,2017-01-12T21:14:47Z,MERGED,True,3,2,1,https://github.com/Vinggui,Fixing Avr-Zigbit Makefile not compiling.,2,[],https://github.com/contiki-os/contiki/pull/2034,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/2034#issuecomment-272089794,"I just tried to compile this platform for my Zigbit mote (AT86RF230) here in a hello-world example, but it didn't work.
I reviewed this makefile and found that the request to compile ""frame.c"" was not necessary and bring up a missing error:
""make: *** No rule to make target obj_avr-zigbit/frame.o', needed by contiki-avr-zigbit.a'.  Stop.""
Frame.c is already inserted in radio's makefile.
Another problem was the undefined reference created by the missing module ""core/net"":
""contiki-avr-zigbit.a(sicslowpan.o): In function input':"" ""contiki/examples/hello-world/../../core/net/ipv6/sicslowpan.c:1521: undefined reference to link_stats_input_callback'""
Both solved now. Hope it helps someone else.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2035,2017-01-05T11:12:48Z,2017-01-09T07:45:50Z,2017-10-27T20:05:31Z,MERGED,True,3,1,1,https://github.com/simonduq,CSMA bugfix: do not use field on a struct that may have been deallocated,1,['bug'],https://github.com/contiki-os/contiki/pull/2035,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/2035,"free_packet de-allocates a packet and, if this was the last packet in queue, also frees the neighbor. Hence, we need to store n->transmissions before free_packet in order to return it safely.","free_packet de-allocates a packet and, if this was the last packet in queue, also frees the neighbor. Hence, we need to store n->transmissions before free_packet in order to return it safely.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2035,2017-01-05T11:12:48Z,2017-01-09T07:45:50Z,2017-10-27T20:05:31Z,MERGED,True,3,1,1,https://github.com/simonduq,CSMA bugfix: do not use field on a struct that may have been deallocated,1,['bug'],https://github.com/contiki-os/contiki/pull/2035,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2035#issuecomment-271225527,"free_packet de-allocates a packet and, if this was the last packet in queue, also frees the neighbor. Hence, we need to store n->transmissions before free_packet in order to return it safely.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2037,2017-01-07T19:54:54Z,,2017-01-07T19:54:54Z,OPEN,False,1758,3,4,https://github.com/samgmansfield,This commit introduces TerrainLOS a terrain-based radio medium for COOJA,1,[],https://github.com/contiki-os/contiki/pull/2037,https://github.com/samgmansfield,1,https://github.com/contiki-os/contiki/pull/2037,"TerrainLOS uses real terrain data provided by the SRTM. TerrainLOS is divided into two files, the medium itself in radiomediums/TerrainLOSRadioMedium, and the visualizer in plugins/skins/TerrainLOSVisualizerSkin. In addition two config files were modified cooja_applet.config and cooja_default.config in order for TerrainLOS to be selected as a radio medium using the new simulation gui.
TerrainLOS was created by myself, Sam Mansfield, Kerry Veenstra, Sidharth Gilela, and Katia Obraczka as part of the Inter-networking Research Group (I-NRG) at University of California, Santa Cruz.
TerrainLOS was recently published in MASCOTS 2016 to compare network graphs and metrics against UDGM as well as routing protocols, RPL and ORPL. An extended paper is currently in the works where TerrainLOS will be compared against Ray Tracing and where we will also compare simulation running times.
Please let me know if there is any additional information I can provide.
Sam Mansfield","TerrainLOS uses real terrain data provided by the SRTM. TerrainLOS is divided into two files, the medium itself in radiomediums/TerrainLOSRadioMedium, and the visualizer in plugins/skins/TerrainLOSVisualizerSkin. In addition two config files were modified cooja_applet.config and cooja_default.config in order for TerrainLOS to be selected as a radio medium using the new simulation gui.
TerrainLOS was created by myself, Sam Mansfield, Kerry Veenstra, Sidharth Gilela, and Katia Obraczka as part of the Inter-networking Research Group (I-NRG) at University of California, Santa Cruz.
TerrainLOS was recently published in MASCOTS 2016 to compare network graphs and metrics against UDGM as well as routing protocols, RPL and ORPL. An extended paper is currently in the works where TerrainLOS will be compared against Ray Tracing and where we will also compare simulation running times.
Please let me know if there is any additional information I can provide.
Sam Mansfield",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/e120guru,1,https://github.com/contiki-os/contiki/pull/2043,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.","The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271879768,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.","You should be right. COOJA_CONF_SIMULATE_TURNAROUND needs to be set with 0 when you're using TSCH with Cooja mote as I mentioned in the Introduction section of #1661.
Sorry for the inconvenience. I should have added something about COOJA_CONF_SIMULATE_TURNAROUND into README of TSCH.  I'll send a PR to update the README.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271886645,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.","Right, would be a good idea to centralize the TSCH-related configs somewhere, at least in the readme! Note that we have some both at the beginning and the end of the project-conf examples..",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271886798,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.","I agree the def of COOJA_CONF_TRANSMIT_ON_CCA does not seem needed. Other than that, thanks for the catch!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/e120guru,5,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271893872,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.","PR updated, removed redundant line",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271894254,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.","thanks. if you could just squash the two commits into one, this is ready to merge!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/e120guru,7,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271903622,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.",PR updated,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2043,2017-01-11T13:25:54Z,2017-01-11T17:15:44Z,2017-01-11T17:15:44Z,MERGED,True,5,0,1,https://github.com/e120guru,Fixed rime-tsch sync problem in Cooja,1,[],https://github.com/contiki-os/contiki/pull/2043,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/2043#issuecomment-271904511,"The rime-tsch example does not sync properly in cooja when using cooja motes. Compiling for instance a sky mote works.
As it turns out there seems to be lacking the directive to simulate the turnaround time in this example.
This PR adds a fix for this, after applying this fix cooja motes syncronize as expected even when using cooja motes.",Thanks! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2044,2017-01-11T17:03:06Z,,2017-04-04T01:03:11Z,OPEN,False,218,3,2,https://github.com/yatch,TSCH: Configuration Guide Improvement,2,"['Core', 'Network']",https://github.com/contiki-os/contiki/pull/2044,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2044,"Add sample-project-conf.h under core/net/mac/tsch which is made of examples/ipv6/rpl-tsch/project-conf.h.
Update README.md to include the Cooja Mote specific configuration and to refer to the sample project-conf.h.","Add sample-project-conf.h under core/net/mac/tsch which is made of examples/ipv6/rpl-tsch/project-conf.h.
Update README.md to include the Cooja Mote specific configuration and to refer to the sample project-conf.h.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2044,2017-01-11T17:03:06Z,,2017-04-04T01:03:11Z,OPEN,False,218,3,2,https://github.com/yatch,TSCH: Configuration Guide Improvement,2,"['Core', 'Network']",https://github.com/contiki-os/contiki/pull/2044,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2044#issuecomment-290954729,"Add sample-project-conf.h under core/net/mac/tsch which is made of examples/ipv6/rpl-tsch/project-conf.h.
Update README.md to include the Cooja Mote specific configuration and to refer to the sample project-conf.h.",@simonduq @atiselsts this seems to be mainly about documentation / configuration and should be easy to review. Any thoughts?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2045,2017-01-11T18:01:19Z,2017-01-12T09:44:32Z,2017-01-12T09:44:32Z,CLOSED,False,2,1,1,None,Improve pic32 spi,2,[],https://github.com/contiki-os/contiki/pull/2045,None,1,https://github.com/contiki-os/contiki/pull/2045,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2045,2017-01-11T18:01:19Z,2017-01-12T09:44:32Z,2017-01-12T09:44:32Z,CLOSED,False,2,1,1,None,Improve pic32 spi,2,[],https://github.com/contiki-os/contiki/pull/2045,None,2,https://github.com/contiki-os/contiki/pull/2045#issuecomment-272118691,,SPI##x##BUF is defined as volatile in microchip pic32 headers. So no need for this pull request.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2046,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/neophob,2,https://github.com/contiki-os/contiki/pull/2046#issuecomment-272391901,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","Great catch. I saw that the JN platform uses the ringbufindex code as well, what's the impact there?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/2046#issuecomment-272460535,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","@neophob I don't think this change has any impact on platform/jn516x/dev/micromac-radio.c.
To my understanding, you don't have any problem with this bug as long as you don't use an index returned by ringbufindex_get(). The JN platform gets an index with ringbufindex_peek_get() and uses ringbufindex_get() just to remove the first element in the ringbuf. In fact, ringbufindex_get() removes a different element from one returned by ringbufindex_peek_get(). But, still, consistency is maintained.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/2046#issuecomment-272462658,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","Right, if I'm correct it looks like everything was off-by-one, causing no problem (jn nor tsch), but that is definitely unwanted indeed  :p
How does  19-z1-rpl-tsch.csc.flaky fail? It should randomly fail to link. But when it links, it normally runs successfully (the run is not flaky).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/2046#issuecomment-272981859,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","@simonduq Regarding 19-z1-rpl-tsch.csc.flaky, the number of ""routing links"" on node-1 doesn't get to 8 within the simulation time. I think I've found a bug, which is not in ringbufindex. I'll send a PR later.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/2046#issuecomment-273042649,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","Right, looking forward to the PR then :) I guess the bug simply slipped in now with the test disabled :/",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,7,https://github.com/contiki-os/contiki/pull/2046#issuecomment-273593438,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","@simonduq I've created a new PR, #2079.  My conclusion is, 19-z1-rpl-tsch.csc.flaky fails because some RPL nodes fail to receive broadcast frames including DIOs. This is caused by a bug in the frame filtering feature of the simulated CC2420 device.
At first, I noticed that the test failed on the commit of bfef0b5, although it succeeded before that. So, I suspected the adaptive scheduling, but I was wrong. I guess, some timing change by bfef0b5 triggers the test failure by chance.
A TSCH node is initialized with frame filtering disabled. As long as the frame filtering is disabled, the node doesn't suffer from the bug of CC2420. The filter is enabled once it sends a unicast (ACK-required) frame. Therefore, if it receives a broadcasted DIO before sending any unicast frame, it can join a DODAG. Otherwise, it cannot not. This happens in a failed test of  19-z1-rpl-tsch.csc.flaky. I'm confused why the frame filtering needs to be turned on and off in TSCH, though.
Anyway, the failure of the test is nothing to do with ringbufindex.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/2046#issuecomment-273596136,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","Could it be the recent changes to MAC header that result in frames that the emulated cc2420 filters out?
Maybe it would be wiser to unset TSCH_HW_FRAME_FILTERING by default. It's already manually disabled on the cc2538 platforms in some project-conf.h files.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,9,https://github.com/contiki-os/contiki/pull/2046#issuecomment-273615124,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","@simonduq In the first place, why does TSCH needs the frame filtering disabled during scanning and waiting for an ACK...? (it's totally off-topic, by the way... üòÖ)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/2046#issuecomment-273746966,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","On some platforms (at least cc2420, which was our initial development platform), the radio would filter out enhanced ACKs, probably due to the len different from 3.
Scanning should work both with and without filtering.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,11,https://github.com/contiki-os/contiki/pull/2046#issuecomment-273768050,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","@simonduq Thank you for the information! Now I understand what the following comment means, that is found in tsch-slot-operation.c.
/* Entering promiscuous mode so that the radio accepts the enhanced ACK */",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/2046#issuecomment-284989330,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","Good. I've used the fix in multiple testbeds, successfully.
Could you enable in Travis the test added in #2108 ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,13,https://github.com/contiki-os/contiki/pull/2046#issuecomment-285234449,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000","@simonduq Sure, I can do that today :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/yatch,14,https://github.com/contiki-os/contiki/pull/2046#issuecomment-285331716,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000",Added one commit enabling TSCH regression testing. Travis ran the test and got green.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,15,https://github.com/contiki-os/contiki/pull/2046#issuecomment-285334341,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2046,2017-01-11T22:00:51Z,2017-03-09T12:06:34Z,2017-03-09T12:07:57Z,MERGED,True,646,13,8,https://github.com/yatch,Bugfix in ringbufindex,5,[],https://github.com/contiki-os/contiki/pull/2046,https://github.com/simonduq,16,https://github.com/contiki-os/contiki/pull/2046#issuecomment-285334360,"There are two bugs in ringbufindex. They are similar.
While ringbufindex_peek_put() is supposed to return the index of the next element to be added, it returns the next index of the adding element. ringbufindex_peek_get() returns the next index of the first element.
Travis got green on my account. However, 19-z1-rpl-tsch.csc.flaky failed, that is one of non-regression tests of TSCH. Since this one fails even on the tip of the master branch, I would say, this PR doesn't cause the failure...
A regression test for ringbufindex has been introduced under regression-tests/03-base as 04-ringbufindex. Without the fixes, two of them fails.
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= FAILED   - PeekPut: exit at L104
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= FAILED   - PeekGet: exit at L168
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
TEST FAILED
Test ended at simulation time: 10149000
 FAIL ‡≤†_‡≤†
All the tests pass on this branch.
$ make 04-ringbufindex.testlog
Running test 04-ringbufindex with random Seed 1: ..... OK

$ cat 04-ringbufindex.testlog
Random seed: 1
549000 node-1 Rime started with address 0.1.0.1.0.1.0.1
549000 node-1 MAC 00:01:00:01:00:01:00:01 sicslowpan/CSMA/nullrdc, channel check rate 1000 Hz
549000 node-1 Tentative link-local IPv6 address fe80:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Tentative global IPv6 address fd00:0000:0000:0000:0201:0001:0001:0001
549000 node-1 Starting 'ringbuf-index.c test'
549000 node-1 Run unit-test
549000 node-1 ---
549000 node-1 =check-me= SUCEEDED - Init
549000 node-1 =check-me= SUCEEDED - Put
549000 node-1 =check-me= SUCEEDED - PeekPut
549000 node-1 =check-me= SUCEEDED - Get
549000 node-1 =check-me= SUCEEDED - PeekGet
549000 node-1 =check-me= SUCEEDED - Size
549000 node-1 =check-me= SUCEEDED - Elements
549000 node-1 =check-me= SUCEEDED - Full
549000 node-1 =check-me= SUCEEDED - Empty
549000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 549000",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2047,2017-01-12T10:23:55Z,2017-01-15T15:06:23Z,2017-01-15T15:06:26Z,MERGED,True,1,1,1,https://github.com/alignan,Orion: update motelist string,1,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/2047,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2047,Updates the expected motelist string,Updates the expected motelist string,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2047,2017-01-12T10:23:55Z,2017-01-15T15:06:23Z,2017-01-15T15:06:26Z,MERGED,True,1,1,1,https://github.com/alignan,Orion: update motelist string,1,"['enhancement', 'tools']",https://github.com/contiki-os/contiki/pull/2047,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2047#issuecomment-272700872,Updates the expected motelist string,Harmless fix üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2052,2017-01-13T10:50:51Z,2017-01-13T15:07:10Z,2018-10-24T07:00:27Z,MERGED,True,9,3,3,https://github.com/laurentderu,Make RPL route lifetime RFC compliant,1,[],https://github.com/contiki-os/contiki/pull/2052,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2052,"RPL RFC states that if the path lifetime in a DAO transit option is set to 0xFF, it means that the path lifetime is infinite. On the other hand, a lifetime unit of 0xFFFF has not peculiar meaning.
   Path Lifetime: 8-bit unsigned integer.  The length of time in
         Lifetime Units (obtained from the Configuration option) that
         the prefix is valid for route determination.  The period starts
         when a new Path Sequence is seen.  A value of all one bits
         (0xFF) represents infinity.","RPL RFC states that if the path lifetime in a DAO transit option is set to 0xFF, it means that the path lifetime is infinite. On the other hand, a lifetime unit of 0xFFFF has not peculiar meaning.
   Path Lifetime: 8-bit unsigned integer.  The length of time in
         Lifetime Units (obtained from the Configuration option) that
         the prefix is valid for route determination.  The period starts
         when a new Path Sequence is seen.  A value of all one bits
         (0xFF) represents infinity.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2052,2017-01-13T10:50:51Z,2017-01-13T15:07:10Z,2018-10-24T07:00:27Z,MERGED,True,9,3,3,https://github.com/laurentderu,Make RPL route lifetime RFC compliant,1,[],https://github.com/contiki-os/contiki/pull/2052,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2052#issuecomment-272417340,"RPL RFC states that if the path lifetime in a DAO transit option is set to 0xFF, it means that the path lifetime is infinite. On the other hand, a lifetime unit of 0xFFFF has not peculiar meaning.
   Path Lifetime: 8-bit unsigned integer.  The length of time in
         Lifetime Units (obtained from the Configuration option) that
         the prefix is valid for route determination.  The period starts
         when a new Path Sequence is seen.  A value of all one bits
         (0xFF) represents infinity.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2053,2017-01-13T10:52:01Z,2017-01-20T10:08:44Z,2018-10-24T07:00:00Z,MERGED,True,9,9,3,https://github.com/laurentderu,Use RPL_DAG_LIFETIME when computing dag lifetime,1,[],https://github.com/contiki-os/contiki/pull/2053,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2053,"When updating the dag lifetime, the multiplication constant RPL_DAG_LIFETIME must be used (or it has no use at all :) )","When updating the dag lifetime, the multiplication constant RPL_DAG_LIFETIME must be used (or it has no use at all :) )",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2053,2017-01-13T10:52:01Z,2017-01-20T10:08:44Z,2018-10-24T07:00:00Z,MERGED,True,9,9,3,https://github.com/laurentderu,Use RPL_DAG_LIFETIME when computing dag lifetime,1,[],https://github.com/contiki-os/contiki/pull/2053,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2053#issuecomment-272417415,"When updating the dag lifetime, the multiplication constant RPL_DAG_LIFETIME must be used (or it has no use at all :) )",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2053,2017-01-13T10:52:01Z,2017-01-20T10:08:44Z,2018-10-24T07:00:00Z,MERGED,True,9,9,3,https://github.com/laurentderu,Use RPL_DAG_LIFETIME when computing dag lifetime,1,[],https://github.com/contiki-os/contiki/pull/2053,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/2053#issuecomment-272866981,"When updating the dag lifetime, the multiplication constant RPL_DAG_LIFETIME must be used (or it has no use at all :) )","Forgot to update the event timing in the non-regression test related to multi dag, if the lifetime is multiplied by 3 so must be the test...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2053,2017-01-13T10:52:01Z,2017-01-20T10:08:44Z,2018-10-24T07:00:00Z,MERGED,True,9,9,3,https://github.com/laurentderu,Use RPL_DAG_LIFETIME when computing dag lifetime,1,[],https://github.com/contiki-os/contiki/pull/2053,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2053#issuecomment-274032414,"When updating the dag lifetime, the multiplication constant RPL_DAG_LIFETIME must be used (or it has no use at all :) )",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2053,2017-01-13T10:52:01Z,2017-01-20T10:08:44Z,2018-10-24T07:00:00Z,MERGED,True,9,9,3,https://github.com/laurentderu,Use RPL_DAG_LIFETIME when computing dag lifetime,1,[],https://github.com/contiki-os/contiki/pull/2053,https://github.com/arurke,5,https://github.com/contiki-os/contiki/pull/2053#issuecomment-280172467,"When updating the dag lifetime, the multiplication constant RPL_DAG_LIFETIME must be used (or it has no use at all :) )","I'll just add a related comment/question here on the DAG lifetime (which is also related to #912 by @laurentderu ).
I noticed during testing that a node never leaves a DAG due to DAG lifetime. The function which has a chance to do this is rpl_purge_dags(), added in #912, however it requires the ""joined"" flag to be 0, which can only happen if the node has switched to an alternative DAG (or has become root itself). Hence a node will forever be joined to the single DAG even if its lifetime is expired.
Now, this might not necessarily be unintended or bad behavior. The only effect I can think of is that this blocks the node from sending DIS messages in search for a new DAG, however glancing at the RFC I cannot see any req. for this to actually happen either.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2054,2017-01-13T11:00:16Z,2017-01-13T15:08:00Z,2018-10-24T07:00:19Z,MERGED,True,4,1,1,https://github.com/laurentderu,Reject parents with invalid rank,1,[],https://github.com/contiki-os/contiki/pull/2054,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2054,"A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)","A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2054,2017-01-13T11:00:16Z,2017-01-13T15:08:00Z,2018-10-24T07:00:19Z,MERGED,True,4,1,1,https://github.com/laurentderu,Reject parents with invalid rank,1,[],https://github.com/contiki-os/contiki/pull/2054,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2054#issuecomment-272418239,"A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)","Looks good, but could you prepend the debug message with ""RPL: ""?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2054,2017-01-13T11:00:16Z,2017-01-13T15:08:00Z,2018-10-24T07:00:19Z,MERGED,True,4,1,1,https://github.com/laurentderu,Reject parents with invalid rank,1,[],https://github.com/contiki-os/contiki/pull/2054,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/2054#issuecomment-272423125,"A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)",Done,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2054,2017-01-13T11:00:16Z,2017-01-13T15:08:00Z,2018-10-24T07:00:19Z,MERGED,True,4,1,1,https://github.com/laurentderu,Reject parents with invalid rank,1,[],https://github.com/contiki-os/contiki/pull/2054,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/2054#issuecomment-272464993,"A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2054,2017-01-13T11:00:16Z,2017-01-13T15:08:00Z,2018-10-24T07:00:19Z,MERGED,True,4,1,1,https://github.com/laurentderu,Reject parents with invalid rank,1,[],https://github.com/contiki-os/contiki/pull/2054,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/2054#issuecomment-272466675,"A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)",Why checking this in best_parent and not when adding / updating a node's rank?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2054,2017-01-13T11:00:16Z,2017-01-13T15:08:00Z,2018-10-24T07:00:19Z,MERGED,True,4,1,1,https://github.com/laurentderu,Reject parents with invalid rank,1,[],https://github.com/contiki-os/contiki/pull/2054,https://github.com/laurentderu,6,https://github.com/contiki-os/contiki/pull/2054#issuecomment-272865000,"A parent with a rank lower than the DODAG Root rank can not exist by definition and therefore should never be selected.
(Sadly I don't remember which condition triggered the bug, but I guess it does not hurt to add this extra check)","@simonduq honestly I did this fix a long time ago and I don't remember if there was a real motivation to do it there or if it was just easier. I believe it's the latter though, otherwise the rank should be checked at several other place.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2055,2017-01-13T11:37:27Z,2018-10-24T07:00:26Z,2018-10-24T07:00:26Z,CLOSED,False,10,8,1,https://github.com/laurentderu,Don't autoconfigure address on RPL Root,1,[],https://github.com/contiki-os/contiki/pull/2055,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2055,"Currently a DODAG Root with a manually configured address will lose this address when rpl_set_prefix() is called and/or will receive an auto configured address based on the IID and the prefix.
A Root should always be administratively configured and not rely on self configuration (now I hope not too many examples rely on this behaviour...)","Currently a DODAG Root with a manually configured address will lose this address when rpl_set_prefix() is called and/or will receive an auto configured address based on the IID and the prefix.
A Root should always be administratively configured and not rely on self configuration (now I hope not too many examples rely on this behaviour...)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2056,2017-01-13T11:41:49Z,2018-10-24T07:00:20Z,2018-10-24T07:00:20Z,CLOSED,False,11,16,1,https://github.com/laurentderu,Always try to find the best dag,1,[],https://github.com/contiki-os/contiki/pull/2056,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2056,"Currently select_dag() search first in the current DODAG, then and only if there are no suitable parent, it will search in the other DODAGS. This means that a node will always select the current dag, even if it's rank is worse than the rank in the other DODAGs it belongs to.
With this fix, all the DODAGs are explored and the the best parent across all is then selected.","Currently select_dag() search first in the current DODAG, then and only if there are no suitable parent, it will search in the other DODAGS. This means that a node will always select the current dag, even if it's rank is worse than the rank in the other DODAGs it belongs to.
With this fix, all the DODAGs are explored and the the best parent across all is then selected.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2057,2017-01-13T11:45:06Z,2018-10-24T07:00:22Z,2018-10-24T07:00:22Z,CLOSED,False,20,1,2,https://github.com/laurentderu,Do RPL probing on all the known DAG,1,[],https://github.com/contiki-os/contiki/pull/2057,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2057,"The current RPL probing function does probing only in the current dag. With this PR, all the known dodag are probed in a round-robin manner. This improves a lot DODAG switching.
The code could be made conditional using RPL_MAX_DAG_PER_INSTANCE and only used if the number of dag is >= 2","The current RPL probing function does probing only in the current dag. With this PR, all the known dodag are probed in a round-robin manner. This improves a lot DODAG switching.
The code could be made conditional using RPL_MAX_DAG_PER_INSTANCE and only used if the number of dag is >= 2",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2057,2017-01-13T11:45:06Z,2018-10-24T07:00:22Z,2018-10-24T07:00:22Z,CLOSED,False,20,1,2,https://github.com/laurentderu,Do RPL probing on all the known DAG,1,[],https://github.com/contiki-os/contiki/pull/2057,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2057#issuecomment-274034764,"The current RPL probing function does probing only in the current dag. With this PR, all the known dodag are probed in a round-robin manner. This improves a lot DODAG switching.
The code could be made conditional using RPL_MAX_DAG_PER_INSTANCE and only used if the number of dag is >= 2","Nice feature, but I feel this should be up to the probing target selection function. How about using the instance as parameter and letting the function do the round-robin on dags?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2057,2017-01-13T11:45:06Z,2018-10-24T07:00:22Z,2018-10-24T07:00:22Z,CLOSED,False,20,1,2,https://github.com/laurentderu,Do RPL probing on all the known DAG,1,[],https://github.com/contiki-os/contiki/pull/2057,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/2057#issuecomment-274035892,"The current RPL probing function does probing only in the current dag. With this PR, all the known dodag are probed in a round-robin manner. This improves a lot DODAG switching.
The code could be made conditional using RPL_MAX_DAG_PER_INSTANCE and only used if the number of dag is >= 2","That's a good remark, and moving it to the probing function allows one to use another probing function that would use something more smart than a simple round robin between the DAGs.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2057,2017-01-13T11:45:06Z,2018-10-24T07:00:22Z,2018-10-24T07:00:22Z,CLOSED,False,20,1,2,https://github.com/laurentderu,Do RPL probing on all the known DAG,1,[],https://github.com/contiki-os/contiki/pull/2057,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/2057#issuecomment-274036575,"The current RPL probing function does probing only in the current dag. With this PR, all the known dodag are probed in a round-robin manner. This improves a lot DODAG switching.
The code could be made conditional using RPL_MAX_DAG_PER_INSTANCE and only used if the number of dag is >= 2",yep!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2058,2017-01-13T14:14:45Z,2018-10-24T07:00:17Z,2018-10-24T07:00:17Z,CLOSED,False,5,5,4,https://github.com/laurentderu,Add missing UIP_LLH_LEN,1,[],https://github.com/contiki-os/contiki/pull/2058,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2058,"At a few places, UIP_BUFSIZE is used without removing UIP_LLH_LEN, which could lead to buffer overflow.
Most of the time the macros used to calculate header or packet size already take into account UIP_LLH_LEN, these are the only places where UIP_BUF_SIZE is used directly and UIP_LLH_LEN is not subtracted.","At a few places, UIP_BUFSIZE is used without removing UIP_LLH_LEN, which could lead to buffer overflow.
Most of the time the macros used to calculate header or packet size already take into account UIP_LLH_LEN, these are the only places where UIP_BUF_SIZE is used directly and UIP_LLH_LEN is not subtracted.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2058,2017-01-13T14:14:45Z,2018-10-24T07:00:17Z,2018-10-24T07:00:17Z,CLOSED,False,5,5,4,https://github.com/laurentderu,Add missing UIP_LLH_LEN,1,[],https://github.com/contiki-os/contiki/pull/2058,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2058#issuecomment-272638105,"At a few places, UIP_BUFSIZE is used without removing UIP_LLH_LEN, which could lead to buffer overflow.
Most of the time the macros used to calculate header or packet size already take into account UIP_LLH_LEN, these are the only places where UIP_BUF_SIZE is used directly and UIP_LLH_LEN is not subtracted.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2059,2017-01-13T14:16:35Z,2018-10-24T07:00:14Z,2018-10-24T07:00:14Z,CLOSED,False,0,4,1,https://github.com/laurentderu,Always use uip_ds6_select_src when sending back an icmp error,1,[],https://github.com/contiki-os/contiki/pull/2059,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2059,"If the host is not a router, the source address of ICMP error messages is wrong, it is the address of the originating packet instead of the address of the host.","If the host is not a router, the source address of ICMP error messages is wrong, it is the address of the originating packet instead of the address of the host.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2060,2017-01-13T14:23:15Z,2018-10-24T07:00:15Z,2018-10-24T07:00:15Z,CLOSED,False,7,9,2,https://github.com/laurentderu,Properly update IPv6 proto in remove_ext_hdr(),1,"['Core', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2060,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2060,"Instead of explicitly update the proto field of the IPV6 packet after calling remove_ext_hdr() which is error prone, this PR updates the field inside remove_ext_hdr() directly.","Instead of explicitly update the proto field of the IPV6 packet after calling remove_ext_hdr() which is error prone, this PR updates the field inside remove_ext_hdr() directly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2060,2017-01-13T14:23:15Z,2018-10-24T07:00:15Z,2018-10-24T07:00:15Z,CLOSED,False,7,9,2,https://github.com/laurentderu,Properly update IPv6 proto in remove_ext_hdr(),1,"['Core', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2060,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2060#issuecomment-290954436,"Instead of explicitly update the proto field of the IPV6 packet after calling remove_ext_hdr() which is error prone, this PR updates the field inside remove_ext_hdr() directly.",This seems to be something we need to look at. @simonduq @nvt any thoughts?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2061,2017-01-13T14:50:33Z,2017-02-21T20:52:18Z,2018-10-24T07:00:04Z,MERGED,True,38,36,4,https://github.com/laurentderu,Various updates for NAT64,4,[],https://github.com/contiki-os/contiki/pull/2061,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2061,"This PR contains various small updated for the NAT64 modules :

Support for runtime configuration of the NAT64 prefix used, but default it's still the ::FFFF:/96 prefix
Removal of the servername in the outgoing DHCP request
Replace printf() with PRINTF() macros
Update of the nameserver using the information received in the DHCP reply (Note that the update is only done if no server is already configured or if it was already configured by NAT64)","This PR contains various small updated for the NAT64 modules :

Support for runtime configuration of the NAT64 prefix used, but default it's still the ::FFFF:/96 prefix
Removal of the servername in the outgoing DHCP request
Replace printf() with PRINTF() macros
Update of the nameserver using the information received in the DHCP reply (Note that the update is only done if no server is already configured or if it was already configured by NAT64)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2061,2017-01-13T14:50:33Z,2017-02-21T20:52:18Z,2018-10-24T07:00:04Z,MERGED,True,38,36,4,https://github.com/laurentderu,Various updates for NAT64,4,[],https://github.com/contiki-os/contiki/pull/2061,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2061#issuecomment-272637962,"This PR contains various small updated for the NAT64 modules :

Support for runtime configuration of the NAT64 prefix used, but default it's still the ::FFFF:/96 prefix
Removal of the servername in the outgoing DHCP request
Replace printf() with PRINTF() macros
Update of the nameserver using the information received in the DHCP reply (Note that the update is only done if no server is already configured or if it was already configured by NAT64)",Looks good!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2061,2017-01-13T14:50:33Z,2017-02-21T20:52:18Z,2018-10-24T07:00:04Z,MERGED,True,38,36,4,https://github.com/laurentderu,Various updates for NAT64,4,[],https://github.com/contiki-os/contiki/pull/2061,https://github.com/adamdunkels,3,https://github.com/contiki-os/contiki/pull/2061#issuecomment-272977433,"This PR contains various small updated for the NAT64 modules :

Support for runtime configuration of the NAT64 prefix used, but default it's still the ::FFFF:/96 prefix
Removal of the servername in the outgoing DHCP request
Replace printf() with PRINTF() macros
Update of the nameserver using the information received in the DHCP reply (Note that the update is only done if no server is already configured or if it was already configured by NAT64)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2062,2017-01-13T14:51:30Z,2017-01-17T07:21:51Z,2018-10-24T07:00:05Z,MERGED,True,7,0,2,https://github.com/laurentderu,Adding uip_ds6_defrt_list_head(),1,[],https://github.com/contiki-os/contiki/pull/2062,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2062,Trivial PR adding the missing uip_ds6_defrt_list_head() function to retrieve the first element of the default router list.,Trivial PR adding the missing uip_ds6_defrt_list_head() function to retrieve the first element of the default router list.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2062,2017-01-13T14:51:30Z,2017-01-17T07:21:51Z,2018-10-24T07:00:05Z,MERGED,True,7,0,2,https://github.com/laurentderu,Adding uip_ds6_defrt_list_head(),1,[],https://github.com/contiki-os/contiki/pull/2062,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2062#issuecomment-272841382,Trivial PR adding the missing uip_ds6_defrt_list_head() function to retrieve the first element of the default router list.,"The other function in this module that returns a list head is called uip_ds6_route_head, so it would be good for consistency if both functions either have ""list"" in the name or not.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2062,2017-01-13T14:51:30Z,2017-01-17T07:21:51Z,2018-10-24T07:00:05Z,MERGED,True,7,0,2,https://github.com/laurentderu,Adding uip_ds6_defrt_list_head(),1,[],https://github.com/contiki-os/contiki/pull/2062,https://github.com/laurentderu,3,https://github.com/contiki-os/contiki/pull/2062#issuecomment-272857858,Trivial PR adding the missing uip_ds6_defrt_list_head() function to retrieve the first element of the default router list.,I removed the _list part of the function name for default router.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2062,2017-01-13T14:51:30Z,2017-01-17T07:21:51Z,2018-10-24T07:00:05Z,MERGED,True,7,0,2,https://github.com/laurentderu,Adding uip_ds6_defrt_list_head(),1,[],https://github.com/contiki-os/contiki/pull/2062,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2062#issuecomment-273040148,Trivial PR adding the missing uip_ds6_defrt_list_head() function to retrieve the first element of the default router list.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2063,2017-01-13T14:52:15Z,2017-01-17T07:22:53Z,2018-10-24T07:00:10Z,MERGED,True,16,0,1,https://github.com/laurentderu,Make all NDP configuration parameters user configurable,1,[],https://github.com/contiki-os/contiki/pull/2063,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2063,Trivial PR allowing user configuration of all the NDP parameters related to Router Advertisement.,Trivial PR allowing user configuration of all the NDP parameters related to Router Advertisement.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2063,2017-01-13T14:52:15Z,2017-01-17T07:22:53Z,2018-10-24T07:00:10Z,MERGED,True,16,0,1,https://github.com/laurentderu,Make all NDP configuration parameters user configurable,1,[],https://github.com/contiki-os/contiki/pull/2063,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2063#issuecomment-273040284,Trivial PR allowing user configuration of all the NDP parameters related to Router Advertisement.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2063,2017-01-13T14:52:15Z,2017-01-17T07:22:53Z,2018-10-24T07:00:10Z,MERGED,True,16,0,1,https://github.com/laurentderu,Make all NDP configuration parameters user configurable,1,[],https://github.com/contiki-os/contiki/pull/2063,https://github.com/greg-king5,3,https://github.com/contiki-os/contiki/pull/2063#issuecomment-274302038,Trivial PR allowing user configuration of all the NDP parameters related to Router Advertisement.,"I'm sorry that I got to this PR five days too late.
The new configuration names are spelled wrong.  They should start with the name of the module: ""uip-nd6"".  Example: UIP_ND6_CONF_MAX_RTR_SOLICITATION_DELAY",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2064,2017-01-13T14:59:06Z,2018-10-24T06:59:58Z,2018-10-24T06:59:58Z,CLOSED,False,117,25,2,https://github.com/laurentderu,Add basic support for static routes,1,[],https://github.com/contiki-os/contiki/pull/2064,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2064,"This PR add support for static routes. The difference between static routes and current routes in Contiki is that the static routes do not depend on an entry in the neighbor table or their link layer address resolution.
Static routes can therefore be created at any time, even if the configured next hop is not reachable yet, and will not be deleted if the neighbor table is full or if the next hop is temporarily unreachable.
Static routes will be needed to support Route Information Option (RIO) in Router Advertisement messages (which is part of an upcoming PR).
For this implementation, instead of creating a complete new set of configuration data, I kept the route object and used the content of the neighborroutes field to distinguish between static routes and dynamic routes. If the field is set to NULL, it means that the route entry is a static one.","This PR add support for static routes. The difference between static routes and current routes in Contiki is that the static routes do not depend on an entry in the neighbor table or their link layer address resolution.
Static routes can therefore be created at any time, even if the configured next hop is not reachable yet, and will not be deleted if the neighbor table is full or if the next hop is temporarily unreachable.
Static routes will be needed to support Route Information Option (RIO) in Router Advertisement messages (which is part of an upcoming PR).
For this implementation, instead of creating a complete new set of configuration data, I kept the route object and used the content of the neighborroutes field to distinguish between static routes and dynamic routes. If the field is set to NULL, it means that the route entry is a static one.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2064,2017-01-13T14:59:06Z,2018-10-24T06:59:58Z,2018-10-24T06:59:58Z,CLOSED,False,117,25,2,https://github.com/laurentderu,Add basic support for static routes,1,[],https://github.com/contiki-os/contiki/pull/2064,https://github.com/laurentderu,2,https://github.com/contiki-os/contiki/pull/2064#issuecomment-273053650,"This PR add support for static routes. The difference between static routes and current routes in Contiki is that the static routes do not depend on an entry in the neighbor table or their link layer address resolution.
Static routes can therefore be created at any time, even if the configured next hop is not reachable yet, and will not be deleted if the neighbor table is full or if the next hop is temporarily unreachable.
Static routes will be needed to support Route Information Option (RIO) in Router Advertisement messages (which is part of an upcoming PR).
For this implementation, instead of creating a complete new set of configuration data, I kept the route object and used the content of the neighborroutes field to distinguish between static routes and dynamic routes. If the field is set to NULL, it means that the route entry is a static one.",Forgot to squash in the support for RPL,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2064,2017-01-13T14:59:06Z,2018-10-24T06:59:58Z,2018-10-24T06:59:58Z,CLOSED,False,117,25,2,https://github.com/laurentderu,Add basic support for static routes,1,[],https://github.com/contiki-os/contiki/pull/2064,https://github.com/KaneRoot,3,https://github.com/contiki-os/contiki/pull/2064#issuecomment-361289234,"This PR add support for static routes. The difference between static routes and current routes in Contiki is that the static routes do not depend on an entry in the neighbor table or their link layer address resolution.
Static routes can therefore be created at any time, even if the configured next hop is not reachable yet, and will not be deleted if the neighbor table is full or if the next hop is temporarily unreachable.
Static routes will be needed to support Route Information Option (RIO) in Router Advertisement messages (which is part of an upcoming PR).
For this implementation, instead of creating a complete new set of configuration data, I kept the route object and used the content of the neighborroutes field to distinguish between static routes and dynamic routes. If the field is set to NULL, it means that the route entry is a static one.","Why has this PR not making its way to the master branch yet? It seems important. Please, provide a feedback.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2064,2017-01-13T14:59:06Z,2018-10-24T06:59:58Z,2018-10-24T06:59:58Z,CLOSED,False,117,25,2,https://github.com/laurentderu,Add basic support for static routes,1,[],https://github.com/contiki-os/contiki/pull/2064,https://github.com/laurentderu,4,https://github.com/contiki-os/contiki/pull/2064#issuecomment-362196328,"This PR add support for static routes. The difference between static routes and current routes in Contiki is that the static routes do not depend on an entry in the neighbor table or their link layer address resolution.
Static routes can therefore be created at any time, even if the configured next hop is not reachable yet, and will not be deleted if the neighbor table is full or if the next hop is temporarily unreachable.
Static routes will be needed to support Route Information Option (RIO) in Router Advertisement messages (which is part of an upcoming PR).
For this implementation, instead of creating a complete new set of configuration data, I kept the route object and used the content of the neighborroutes field to distinguish between static routes and dynamic routes. If the field is set to NULL, it means that the route entry is a static one.",People have moved to Contiki-NG so I don't think it will ever be merged. I will in the near future make a PR in Contiki-NG with that functionality.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2065,2017-01-13T15:02:42Z,2018-10-24T07:00:13Z,2018-10-24T07:00:13Z,CLOSED,False,11,13,2,https://github.com/laurentderu,RDNSS and DNSSL do not rely on O Flag,1,[],https://github.com/contiki-os/contiki/pull/2065,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2065,"According to NDP RFC, the 'O' flag in Router Advertisement messages indicates that some or all the network configuration is provided by another configuration protocol (usually DHCP). However, in Contiki the meaning of the flag has been inverted for RDNSS and DNSSL options.
This PR fixes this by always setting the 'O' flag to 0, and always processing the incoming RDNSS option.","According to NDP RFC, the 'O' flag in Router Advertisement messages indicates that some or all the network configuration is provided by another configuration protocol (usually DHCP). However, in Contiki the meaning of the flag has been inverted for RDNSS and DNSSL options.
This PR fixes this by always setting the 'O' flag to 0, and always processing the incoming RDNSS option.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2066,2017-01-13T15:57:36Z,2019-12-02T18:24:59Z,2019-12-02T18:24:59Z,CLOSED,False,17,13,3,https://github.com/RomeroMalaquias,Avoiding conditional directives that break statements,3,[],https://github.com/contiki-os/contiki/pull/2066,https://github.com/RomeroMalaquias,1,https://github.com/contiki-os/contiki/pull/2066,"Hello, this change is only aesthetic, it's a suggestion to avoid the use of conditional directives that break statements i think that kind of concern can improve your code guidelines, do you agree?
This pull request is based on #1407","Hello, this change is only aesthetic, it's a suggestion to avoid the use of conditional directives that break statements i think that kind of concern can improve your code guidelines, do you agree?
This pull request is based on #1407",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2069,2017-01-14T21:56:36Z,2017-01-15T11:52:10Z,2017-01-15T11:52:10Z,MERGED,True,3,0,1,https://github.com/alignan,Explicitly specify light sensor model in example,1,['documentation'],https://github.com/contiki-os/contiki/pull/2069,https://github.com/alignan,1,https://github.com/contiki-os/contiki/pull/2069,"Minor documentation: explicitly specify the light sensor model in the example, so users know how to switch between the TSL2536 and TSL2561","Minor documentation: explicitly specify the light sensor model in the example, so users know how to switch between the TSL2536 and TSL2561",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2071,2017-01-15T12:42:44Z,2017-01-21T00:17:50Z,2017-04-02T12:47:28Z,MERGED,True,40,31,2,https://github.com/g-oikonomou,Make the number of Prop Mode RX Buffers easy to configure,3,"['bug', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2071,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/2071,"This pull makes the number of RX buffers for CC13xx prop mode easily configurable via a simple define.
Can be used to fix #1878, possibly also #1933 and #1999.","This pull makes the number of RX buffers for CC13xx prop mode easily configurable via a simple define.
Can be used to fix #1878, possibly also #1933 and #1999.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2071,2017-01-15T12:42:44Z,2017-01-21T00:17:50Z,2017-04-02T12:47:28Z,MERGED,True,40,31,2,https://github.com/g-oikonomou,Make the number of Prop Mode RX Buffers easy to configure,3,"['bug', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2071,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/2071#issuecomment-273918197,"This pull makes the number of RX buffers for CC13xx prop mode easily configurable via a simple define.
Can be used to fix #1878, possibly also #1933 and #1999.","No surprises, but can confirm this PR fixes #1878 . Tested with PROP_MODE_CONF_RX_BUF_CNT 8 on SLIP.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2071,2017-01-15T12:42:44Z,2017-01-21T00:17:50Z,2017-04-02T12:47:28Z,MERGED,True,40,31,2,https://github.com/g-oikonomou,Make the number of Prop Mode RX Buffers easy to configure,3,"['bug', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2071,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/2071#issuecomment-273939206,"This pull makes the number of RX buffers for CC13xx prop mode easily configurable via a simple define.
Can be used to fix #1878, possibly also #1933 and #1999.",üëç thanks for the feedback,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2071,2017-01-15T12:42:44Z,2017-01-21T00:17:50Z,2017-04-02T12:47:28Z,MERGED,True,40,31,2,https://github.com/g-oikonomou,Make the number of Prop Mode RX Buffers easy to configure,3,"['bug', 'nominated', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2071,https://github.com/bbhagasra1,4,https://github.com/contiki-os/contiki/pull/2071#issuecomment-277190853,"This pull makes the number of RX buffers for CC13xx prop mode easily configurable via a simple define.
Can be used to fix #1878, possibly also #1933 and #1999.","I used PROP_MODE_CONF_RX_BUF_CNT 8 but problem occurs , smartrf_settings_cmd_prop_rx_adv.status is 0x3801........what else we can do??
periodic_timer() also not working after this .........",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2072,2017-01-16T12:30:45Z,,2017-03-18T14:19:37Z,OPEN,False,16,2,2,https://github.com/atiselsts,CC26xx: enable phase lock in ContikiMAC,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/2072,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2072,"Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.","Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2072,2017-01-16T12:30:45Z,,2017-03-18T14:19:37Z,OPEN,False,16,2,2,https://github.com/atiselsts,CC26xx: enable phase lock in ContikiMAC,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/2072,https://github.com/atiselsts,2,https://github.com/contiki-os/contiki/pull/2072#issuecomment-274934051,"Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.","With this,  the cc26xx-web-demo fails to compile because of running out of RAM. Not sure if there's an easy way to fix it, and we might need to reduce the web demo memory usage in any case: see pull request #2089.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2072,2017-01-16T12:30:45Z,,2017-03-18T14:19:37Z,OPEN,False,16,2,2,https://github.com/atiselsts,CC26xx: enable phase lock in ContikiMAC,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/2072,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/2072#issuecomment-276471571,"Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.",Updated the cc26xx-web-demo to explicitly disable phase locking; now it can be linked and Travis is green.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2072,2017-01-16T12:30:45Z,,2017-03-18T14:19:37Z,OPEN,False,16,2,2,https://github.com/atiselsts,CC26xx: enable phase lock in ContikiMAC,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/2072,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2072#issuecomment-287493295,"Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.",I'm keen to merge this. Just waiting for minor adjustments/responses as per my comments.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2072,2017-01-16T12:30:45Z,,2017-03-18T14:19:37Z,OPEN,False,16,2,2,https://github.com/atiselsts,CC26xx: enable phase lock in ContikiMAC,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/2072,https://github.com/atiselsts,5,https://github.com/contiki-os/contiki/pull/2072#issuecomment-287537382,"Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.","I consider this an experimental feature, tested on the table for a few minutes with a few motes. Would be more happy if someone reported results from a real system - as I have done with the code from other pull requests recently submitted. (We're not using ContikiMAC in our production systems, so this PR is not a priority...)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2072,2017-01-16T12:30:45Z,,2017-03-18T14:19:37Z,OPEN,False,16,2,2,https://github.com/atiselsts,CC26xx: enable phase lock in ContikiMAC,1,['Platform / CPU / ARM / CC13xx-CC26xx'],https://github.com/contiki-os/contiki/pull/2072,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/2072#issuecomment-287549198,"Phase lock did not work on CC26xx with the default settings. in particular, the guard time was insufficient as the CC26xx radio chip is quite slow. This pull adds new ContikiMAC phase lock configuration settings and enables it on this platform.
Tested in a star network with 5 nodes. Larger scale testing might be helpful to better find the optimal value of the settings in terms of energy/robustness tradeoff.","Yes, I understand you are considering this experimental. Which is why I think that contiki-conf.h should default to disabling phase optimisation and then the web demo's project-conf.h doesn't need to do anything. Also, to change the configuration in project-conf.h, you only need to #define, you don't need to #undef first.
Perhaps we can demonstrate that it can be enabled at own risk in the simple demo.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2073,2017-01-16T13:29:07Z,2017-01-20T12:18:44Z,2018-10-24T07:00:02Z,MERGED,True,73,59,19,https://github.com/laurentderu,Fix semantic of UIP_ND6_SEND_NA and add UIP_ND6_SEND_NS,1,[],https://github.com/contiki-os/contiki/pull/2073,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2073,"The compilation flag UIP_ND6_SEND_NA is used to disable NS and NA messages handling. However the name is misleading as actually we mean to disable NS sending and so disable NUD and DAD processes. Also it is not possible currently to disable them yet to still respond to incoming NS messages from full NDP peers.
This FR renames UIP_ND6_SEND_NA into UIP_ND6_SEND_NS in most places and introduces UIP_ND6_SEND_NA to still support incoming NS handling. By default on a RPL host, SEND_NS is deactivated and SEND_NA is still activated.
There was also a potential bug in rpl-dag.c where the compilation flag definition was tested instead of its actual value, and so the code was always included.
This PR should also fix one of the issues reported in #1858","The compilation flag UIP_ND6_SEND_NA is used to disable NS and NA messages handling. However the name is misleading as actually we mean to disable NS sending and so disable NUD and DAD processes. Also it is not possible currently to disable them yet to still respond to incoming NS messages from full NDP peers.
This FR renames UIP_ND6_SEND_NA into UIP_ND6_SEND_NS in most places and introduces UIP_ND6_SEND_NA to still support incoming NS handling. By default on a RPL host, SEND_NS is deactivated and SEND_NA is still activated.
There was also a potential bug in rpl-dag.c where the compilation flag definition was tested instead of its actual value, and so the code was always included.
This PR should also fix one of the issues reported in #1858",True,"{'THUMBS_UP': ['https://github.com/yatch', 'https://github.com/OSPro']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,2073,2017-01-16T13:29:07Z,2017-01-20T12:18:44Z,2018-10-24T07:00:02Z,MERGED,True,73,59,19,https://github.com/laurentderu,Fix semantic of UIP_ND6_SEND_NA and add UIP_ND6_SEND_NS,1,[],https://github.com/contiki-os/contiki/pull/2073,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2073#issuecomment-274033636,"The compilation flag UIP_ND6_SEND_NA is used to disable NS and NA messages handling. However the name is misleading as actually we mean to disable NS sending and so disable NUD and DAD processes. Also it is not possible currently to disable them yet to still respond to incoming NS messages from full NDP peers.
This FR renames UIP_ND6_SEND_NA into UIP_ND6_SEND_NS in most places and introduces UIP_ND6_SEND_NA to still support incoming NS handling. By default on a RPL host, SEND_NS is deactivated and SEND_NA is still activated.
There was also a potential bug in rpl-dag.c where the compilation flag definition was tested instead of its actual value, and so the code was always included.
This PR should also fix one of the issues reported in #1858",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2073,2017-01-16T13:29:07Z,2017-01-20T12:18:44Z,2018-10-24T07:00:02Z,MERGED,True,73,59,19,https://github.com/laurentderu,Fix semantic of UIP_ND6_SEND_NA and add UIP_ND6_SEND_NS,1,[],https://github.com/contiki-os/contiki/pull/2073,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/2073#issuecomment-274059439,"The compilation flag UIP_ND6_SEND_NA is used to disable NS and NA messages handling. However the name is misleading as actually we mean to disable NS sending and so disable NUD and DAD processes. Also it is not possible currently to disable them yet to still respond to incoming NS messages from full NDP peers.
This FR renames UIP_ND6_SEND_NA into UIP_ND6_SEND_NS in most places and introduces UIP_ND6_SEND_NA to still support incoming NS handling. By default on a RPL host, SEND_NS is deactivated and SEND_NA is still activated.
There was also a potential bug in rpl-dag.c where the compilation flag definition was tested instead of its actual value, and so the code was always included.
This PR should also fix one of the issues reported in #1858",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2074,2017-01-16T17:24:35Z,,2017-01-16T17:24:35Z,OPEN,False,32,0,2,None,pic32: spi: Add spi_transfer function,1,[],https://github.com/contiki-os/contiki/pull/2074,None,1,https://github.com/contiki-os/contiki/pull/2074,Signed-off-by: Francois Berder francois.berder@imgtec.com,Signed-off-by: Francois Berder francois.berder@imgtec.com,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2076,2017-01-17T08:22:46Z,2018-10-24T06:59:59Z,2018-10-24T06:59:59Z,CLOSED,False,36,0,2,https://github.com/laurentderu,Native monotonic timer,2,[],https://github.com/contiki-os/contiki/pull/2076,https://github.com/laurentderu,1,https://github.com/contiki-os/contiki/pull/2076,"Currently on native platform we use gettimeofday() to create the time of all the timers, however gettimeofday() is not an absolute monotonic time source. When the system clock is updated (either because of drift, DST or user configuration) the time returned is shifted. This breaks completely the Contiki timer, resulting in timers already expired before even starting or times scheduled billions of seconds later in time...
With this PR, I switched to clock_gettime(CLOCK_MONOTONIC) on linux and mach_absolute_time() on MacOS-X. These two functions are guaranteed to always return a monotonic time, independent of any clock change on the platform.","Currently on native platform we use gettimeofday() to create the time of all the timers, however gettimeofday() is not an absolute monotonic time source. When the system clock is updated (either because of drift, DST or user configuration) the time returned is shifted. This breaks completely the Contiki timer, resulting in timers already expired before even starting or times scheduled billions of seconds later in time...
With this PR, I switched to clock_gettime(CLOCK_MONOTONIC) on linux and mach_absolute_time() on MacOS-X. These two functions are guaranteed to always return a monotonic time, independent of any clock change on the platform.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2076,2017-01-17T08:22:46Z,2018-10-24T06:59:59Z,2018-10-24T06:59:59Z,CLOSED,False,36,0,2,https://github.com/laurentderu,Native monotonic timer,2,[],https://github.com/contiki-os/contiki/pull/2076,https://github.com/pengi,2,https://github.com/contiki-os/contiki/pull/2076#issuecomment-299104091,"Currently on native platform we use gettimeofday() to create the time of all the timers, however gettimeofday() is not an absolute monotonic time source. When the system clock is updated (either because of drift, DST or user configuration) the time returned is shifted. This breaks completely the Contiki timer, resulting in timers already expired before even starting or times scheduled billions of seconds later in time...
With this PR, I switched to clock_gettime(CLOCK_MONOTONIC) on linux and mach_absolute_time() on MacOS-X. These two functions are guaranteed to always return a monotonic time, independent of any clock change on the platform.","For the record, clock_gettime(CLOCK_MONOTONIC, ...) is available on mac too. No extra libraries is needed though, but it would make it possible to use the same implementation on both linux and mac.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2078,2017-01-18T16:19:24Z,,2017-02-21T20:50:35Z,OPEN,False,409,5,4,https://github.com/JSgarri,Added HP206C sensor to Zoul-based platform,2,[],https://github.com/contiki-os/contiki/pull/2078,https://github.com/JSgarri,1,https://github.com/contiki-os/contiki/pull/2078,"This PW adds the HP206C Barometer sensor driver and test example, sold by differents vendors, such as Grove, Controleverything, etc...
https://github.com/Zolertia/Resources/wiki/HP206C","This PW adds the HP206C Barometer sensor driver and test example, sold by differents vendors, such as Grove, Controleverything, etc...
https://github.com/Zolertia/Resources/wiki/HP206C",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2079,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721","Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2079#issuecomment-273593867,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721","Cool!
What would you think about switching this and the existing rpl-tsch test to platform Cooja, such as we can (re-)enable them in Travis? After all, the real goal is to test TSCH with the upper layers, rather than validate z1 / cc2420.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/2079#issuecomment-273595260,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721","@simonduq Agree. In fact, I tried doing that yesterday with replacing z1 related lines with cooja ones in csc files. This didn't work well somehow. I can try it again, maybe soon.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/simonduq,4,https://github.com/contiki-os/contiki/pull/2079#issuecomment-273596699,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721",Yeah I think changing target directly in .csc files takes more than just a search and replace unfortunately. Different targets load different plugins etc. You might have to create cooja motes by hand (GUI) and look at the resulting csc.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/2079#issuecomment-273612003,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721",@simonduq Something was wrong with me yesterday... See #2080.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/2079#issuecomment-273813996,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721",Planning on porting this one as well to platform cooja?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/yatch,7,https://github.com/contiki-os/contiki/pull/2079#issuecomment-273920193,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721","@simonduq I was not; but it's a piece of cake. I've updated the branch with 22-cooja-tsch-simple-ipv6-test.csc. I made the test a little bit more robust by checking the link-layer destination address of a received frame.
I believe Travis will get red due to #1984.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/2079#issuecomment-274021096,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721",test-driven development :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2079,2017-01-18T20:02:43Z,,2017-01-20T11:08:05Z,OPEN,False,708,0,8,https://github.com/yatch,TSCH: simple IPv6 communication test,2,[],https://github.com/contiki-os/contiki/pull/2079,https://github.com/yatch,9,https://github.com/contiki-os/contiki/pull/2079#issuecomment-274047196,"Summary
This PR introduces a regression test to confirm if basic IPv6 communication is done successfully with TSCH and the z1 platform.
In the test, two nodes, TSCH Coordinator and TSCH Node, are created with the z1 platform. As soon as TSCH Node joins a network formed by TSCH Coordinator, the node sends a unicast packet and a broadcast packet to the coordinator by UDP. The coordinator sends back the received message to the node with the same communication type as the received packet, unicast or broadcast.
If and only if both of them receive one unicast message and one broadcast message, the test ends with success. Otherwise, the test fails.
It is said that some link error randomly occurs for the z1 platform, and it causes test failure. To prevent such a failure from making Travis red, the new test is marked with flaky as 19-z1-rpl-tsch.csc.flaky and others.
[UPDATE]
The same test for the cooja platform is also introduced.
Dependency
The test fails with the latest codebase. To make this test succeed, the following changes are needed:

#1984
contiki-os/mspsim#8

How to Run
$ cd regression-tests/11-ipv6
$ java -Xshare:on -jar ../../tools/cooja/dist/cooja.jar -nogui=22-z1-tsch-simple-ipv6-test.csc.flaky  -contiki=../..
The test result can be found in COOJA.testlog
[success case]
$ tail COOJA.testlog
4147363 1 TSCH: send packet to 255 with seqno 2, queue 0 1, len 16 71
4149456 1 APP: send a broadcast packet
4150165 1 APP: done
4155176 1 TSCH: {asn-0.bd link-0-7-0-0 ch-25} bc-1-0 71 rx 2, edr 6
4244482 2 TSCH: received from 1 with seqno 65535
4245391 1 TSCH: {asn-0.c4 link-0-7-0-0 ch-15} bc-1-0 71 tx 0, st 0-1
4247260 2 APP: receive a broadcast packet
4247969 2 APP: done
TEST OK
Test ended at simulation time: 4247969
[failure case]
$ tail COOJA.testlog
7716816 2 TSCH: received from 1 with seqno 2
7718924 1 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 tx 2, st 0-1
7723552 2 TSCH: send packet to 1 with seqno 1, queue 0 1, len 21 64
7727475 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} drift 0
7732976 2 TSCH: {asn-0.1ab link-0-7-0-0 ch-20} uc-1-0 64 rx 1, dr 0, edr 0
7821243 1 TSCH: received from 2 with seqno 1
7824741 2 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 tx 1, st 0-1, dr 6
7827127 1 TSCH: {asn-0.1b2 link-0-7-0-0 ch-26} uc-1-0 64 rx 2, edr 6
TEST FAILED
Test ended at simulation time: 10016721","@simonduq Yup, I like that style of development üòÑ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2080,2017-01-18T21:46:41Z,2017-01-19T15:53:22Z,2017-01-19T21:08:40Z,MERGED,True,188,161,5,https://github.com/yatch,TSCH: re-enable TSCH regression tests,4,[],https://github.com/contiki-os/contiki/pull/2080,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2080,"The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));","The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2080,2017-01-18T21:46:41Z,2017-01-19T15:53:22Z,2017-01-19T21:08:40Z,MERGED,True,188,161,5,https://github.com/yatch,TSCH: re-enable TSCH regression tests,4,[],https://github.com/contiki-os/contiki/pull/2080,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/2080#issuecomment-273620507,"The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));","Looks good. https://travis-ci.org/contiki-os/contiki/jobs/193198432
$ make -C regression-tests/??-$BUILD_TYPE RUNALL=true summary
make: Entering directory `/home/travis/build/contiki-os/contiki/regression-tests/11-ipv6'
Running test 01-cooja-ipv6-udp with random Seed 1: ................ OK
Running test 04-exp5438-udp-fragmentation-contikimac with random Seed 1: ..................... OK
Running test 05-exp5438-udp-fragmentation-nullrdc with random Seed 1: .................. OK
Running test 06-exp5438-udp-fragmentation-contikimac-large-sender with random Seed 1: .................... OK
Running test 07-exp5438-udp-fragmentation-nullrdc-large-sender with random Seed 1: .................. OK
Running test 08-exp5438-udp-fragmentation-contikimac-too-large-sender with random Seed 1: .................. OK
Running test 09-exp5438-udp-fragmentation-nullrdc-too-large-sender with random Seed 1: .................. OK
Running test 11-exp5438-unicast-fragmentation-nullrdc with random Seed 1: .................... OK
Running test 12-exp5438-unicast-fragmentation-contikimac-large-sender with random Seed 1: ................. OK
Running test 13-exp5438-unicast-fragmentation-nullrdc-large-sender with random Seed 1: ................. OK
Running test 14-exp5438-unicast-fragmentation-contikimac-too-large-sender with random Seed 1: ................. OK
Running test 15-exp5438-unicast-fragmentation-nullrdc-too-large-sender with random Seed 1: ..................... OK
Running test 16-sky-ipv6-rpl-collect with random Seed 1: ........................... OK
Running test 17-cooja-multicast-11-hops with random Seed 1: ............ OK
Running test 18-cooja-multicast-31-hops with random Seed 1: ........ OK
Running test 19-rpl-tsch with random Seed 1: ............... OK
Running test 20-rpl-tsch-orchestra with random Seed 1: ................. OK
Running test 21-rpl-tsch-security with random Seed 1: ................. OK
make: Leaving directory `/home/travis/build/contiki-os/contiki/regression-tests/11-ipv6'",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2080,2017-01-18T21:46:41Z,2017-01-19T15:53:22Z,2017-01-19T21:08:40Z,MERGED,True,188,161,5,https://github.com/yatch,TSCH: re-enable TSCH regression tests,4,[],https://github.com/contiki-os/contiki/pull/2080,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/2080#issuecomment-273746491,"The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));","Wonderful!! Very helpful :)
I wonder why you had to increase the link count from 8 to 9. Would you have the mote output with list of links at hand? (on the go and unable to run it now..)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2080,2017-01-18T21:46:41Z,2017-01-19T15:53:22Z,2017-01-19T21:08:40Z,MERGED,True,188,161,5,https://github.com/yatch,TSCH: re-enable TSCH regression tests,4,[],https://github.com/contiki-os/contiki/pull/2080,https://github.com/yatch,4,https://github.com/contiki-os/contiki/pull/2080#issuecomment-273774583,"The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));","@simonduq Here is the output by print_network_status() in node.c when the test succeeds:
02:00.382       ID:1    --- Network status ---
02:00.382       ID:1    - Server IPv6 addresses:
02:00.382       ID:1    -- fd00::201:1:1:1
02:00.382       ID:1    -- fe80::201:1:1:1
02:00.382       ID:1    - Default route:
02:00.382       ID:1    -- None
02:00.382       ID:1    - Routing links (9 in total):
02:00.382       ID:1    -- fd00::202:2:2:2 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    -- fd00::206:6:6:6 to fd00::202:2:2:2 (lifetime: 1748 seconds)
02:00.382       ID:1    -- fd00::203:3:3:3 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    -- fd00::204:4:4:4 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    -- fd00::208:8:8:8 to fd00::204:4:4:4 (lifetime: 1791 seconds)
02:00.382       ID:1    -- fd00::207:7:7:7 to fd00::208:8:8:8 (lifetime: 1764 seconds)
02:00.382       ID:1    -- fd00::209:9:9:9 to fd00::208:8:8:8 (lifetime: 1770 seconds)
02:00.382       ID:1    -- fd00::205:5:5:5 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    ----------------------
The number of the printed entries is 8, however there is another which is for the root node.
I'd say this was a bug. Sorry for my laziness. I should have made a separate commit to change the test criteria. Besides, it'd be nice to print an entry which doesn't have its parent, that is, the root node in order to keep consistency between a return value by rpl_ns_num_nodes() and the printed list.
This is the output by a new version of print_network_status(), which will be pushed later.
02:00.382       ID:1    --- Network status ---
02:00.382       ID:1    - Server IPv6 addresses:
02:00.382       ID:1    -- fd00::201:1:1:1
02:00.382       ID:1    -- fe80::201:1:1:1
02:00.382       ID:1    - Default route:
02:00.382       ID:1    -- None
02:00.382       ID:1    - Routing links (9 in total):
02:00.382       ID:1    -- fd00::201:1:1:1 --- DODAG root  (lifetime: 4294967295 seconds)
02:00.382       ID:1    -- fd00::202:2:2:2 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    -- fd00::206:6:6:6 to fd00::202:2:2:2 (lifetime: 1748 seconds)
02:00.382       ID:1    -- fd00::203:3:3:3 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    -- fd00::204:4:4:4 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    -- fd00::208:8:8:8 to fd00::204:4:4:4 (lifetime: 1791 seconds)
02:00.382       ID:1    -- fd00::207:7:7:7 to fd00::208:8:8:8 (lifetime: 1764 seconds)
02:00.382       ID:1    -- fd00::209:9:9:9 to fd00::208:8:8:8 (lifetime: 1770 seconds)
02:00.382       ID:1    -- fd00::205:5:5:5 to fd00::201:1:1:1 (lifetime: 1779 seconds)
02:00.382       ID:1    ----------------------",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2080,2017-01-18T21:46:41Z,2017-01-19T15:53:22Z,2017-01-19T21:08:40Z,MERGED,True,188,161,5,https://github.com/yatch,TSCH: re-enable TSCH regression tests,4,[],https://github.com/contiki-os/contiki/pull/2080,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/2080#issuecomment-273778642,"The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));","Updates the PR:

rename .csc files including -cooja- in their names to express which platform is used
make a separate commit to change the test criteria
make print_network_status() in node.c to print an entry for the root",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2080,2017-01-18T21:46:41Z,2017-01-19T15:53:22Z,2017-01-19T21:08:40Z,MERGED,True,188,161,5,https://github.com/yatch,TSCH: re-enable TSCH regression tests,4,[],https://github.com/contiki-os/contiki/pull/2080,https://github.com/simonduq,6,https://github.com/contiki-os/contiki/pull/2080#issuecomment-273779828,"The main change is to use cooja mote instead of z1.
Two other changes:

20-rpl-tsch-orchestra.csc failed because of a link error for nbr_routes. This is resolved by adding a #if guard in orchestra-rule-unicast-per-neighbor-rpl-storing.c. There could be a better solution.
The test criteria seem incorrect. They are updated by the following.

-WAIT_UNTIL(msg.endsWith(""Routing links (8 in total):""));
+WAIT_UNTIL(msg.endsWith(""Routing links (9 in total):""));","Awesome, thanks! üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,1,https://github.com/contiki-os/contiki/pull/2082,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2082#issuecomment-273787431,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","Nice addition!
I would suggest to open a different PR for the IP64 changes, and keep this PR solely to bring the platform to Contiki.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,3,https://github.com/contiki-os/contiki/pull/2082#issuecomment-273790103,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","Thank you!
Before I break anything, let me just double check, this is my first PR: I will rebase this so I have one branch ""enc28j60-ip64-mac-address"" that branches off from master with the IP64 changes, and then this branch ""weptech-gateway"" that branches off from ""enc28j60-ip64-mac-address"" (It needs those commits!), or from master (We just have to make sure that the other PR merges before this one)?
And when I'm done with the rebasing, I git push --force this branch to github, and this PR will update automatically?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/alignan,4,https://github.com/contiki-os/contiki/pull/2082#issuecomment-273791095,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas",We can add the wait for another PR to wait for the enc28j60-ip64-mac-address to be merged first (you can add in the PR description a reference to this branch).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,5,https://github.com/contiki-os/contiki/pull/2082#issuecomment-273791796,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas",Thanks. Incoming!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/adamdunkels,6,https://github.com/contiki-os/contiki/pull/2082#issuecomment-274059493,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","This is a great addition! As a Swede I also appreciate the IKEAesque name üòÑ
I haven't looked through the code thoroughly, but did notice a bunch of code style problems (like (void*) instead of (void *)). You should run the code style script on all the new files and check the result against the style guide (the script isn't perfect).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,7,https://github.com/contiki-os/contiki/pull/2082#issuecomment-274091529,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","I ran uncrustify, reviewed its suggestions, and for the files I touched committed the suggestions that made sense as to slowly reduce the amount of style bugs. Because that's a hassle to review and I know what I actually changed in terms of code, I added comments in this PR that indicate where I actually changed something, hoping that makes reviewing easier for you.
As to the name, the naming scheme is birds - The saker falcon is called Tatarfalk in swedish, and now I really hope there's no such thing like the Snopp hawk or some other Nissan-Pajero-like pitfall...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/adamdunkels,8,https://github.com/contiki-os/contiki/pull/2082#issuecomment-274173669,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","Great! I found two more things, added comments.
The Swedish word saker means things (the plural form of the word sak) - quite fitting üòÉ",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,9,https://github.com/contiki-os/contiki/pull/2082#issuecomment-281099900,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","I forgot to mention: If anyone wants to test this and go through the README, we will of course provide a Saker board, just drop me an email with your snail mail address (preferably something that I can verify through a second channel). If there is anything else needed for the review, please ask for that, too.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/jonnteolsson,10,https://github.com/contiki-os/contiki/pull/2082#issuecomment-309261495,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","@thomas-blank Great addition, the community really lacks a embedded gateway that works off the shelf! Possible to send me a few boards?
Did you test also wth contikiMAC on sub-1GHz and 2.4GHz, or only nullRDC?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,11,https://github.com/contiki-os/contiki/pull/2082#issuecomment-309358379,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","Hi, Jonas, (edit: tagging @jonnteolsson )
We tested with ContikiMAC on both bands. Nodes that we tested with are the SRF06 Development Kit with the CC2538, CC1310, and CC1350, Sensortags with CC1350 and CC2650, and the CC1310 Launchpads - all worked well and I have no complaints from customers so far.
Sure, the offer stands, I can send you boards. How many do you need, and which address should I ship them to? Leave a support ticket at https://www.weptech.de/en/support.html, those tickets land right in my inbox.
Thanks for your help,
Thomas",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/jonnteolsson,12,https://github.com/contiki-os/contiki/pull/2082#issuecomment-309362098,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","Hi,

Thank for the feedback, that sounds good!

I‚Äôve send you a request using your support system.
‚Ä¶
-Jonas

From: Thomas Blank [mailto:notifications@github.com]
Sent: 19. juni 2017 09:17
To: contiki-os/contiki
Cc: Olsson, Jonas; Comment
Subject: Re: [contiki-os/contiki] Weptech Saker Gateway (#2082)


Hi, Jonas,

We tested with ContikiMAC on both bands. Nodes that we tested with are the SRF06 Development Kit with the CC2538, CC1310, and CC1350, Sensortags with CC1350 and CC2650, and the CC1310 Launchpads - all worked well and I have no complaints from customers so far.

Sure, the offer stands, I can send you boards. How many do you need, and which address should I ship them to? Leave a support ticket at https://www.weptech.de/en/support.html, those tickets land right in my inbox.

Thanks for your help,
Thomas

‚Äî
You are receiving this because you commented.
Reply to this email directly, view it on GitHub<#2082 (comment)>, or mute the thread<https://github.com/notifications/unsubscribe-auth/ADIbdvmxHlemcKUoIsVz1QLRj3zu8BlKks5sFiCDgaJpZM4LoJUu>.

Texas Instruments Norway AS, Postboks 264 Sk√∏yen, Hoffsveien 70 C, NO-0213 Oslo, Norway. Org. NO 980499480 MVA",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2082,2017-01-19T14:05:51Z,,2017-09-12T08:09:44Z,OPEN,False,4504,94,31,https://github.com/thomas-blank,Weptech Saker Gateway,6,"['enhancement', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2082,https://github.com/thomas-blank,13,https://github.com/contiki-os/contiki/pull/2082#issuecomment-328775834,"Hi, there,
This pull request adds support for the Saker platform, formerly and more commonly known as ""The Weptech Gateway.""
The actual platform and example code that adds the functionality sits on the very top in one single commit. All other changes, fixes etc. that I made during development to accommodate the platform are individual commits underneath. Like this, if anyone feels that any of these changes should be discussed in a separate pull request, we can easily do so.
The platform has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
We tested to make sure that everything in the README.md works both in the 2.4GHz band as well as SubGHz:

The ip64-rpl-border-router example borrows heavily from all the different border-router examples. It can be compiled with different webserver apps and with either SLIP and IPv6 or Ethernet and IP64. Other combinations, like IPv6 over Ethernet are not supported at this point.
Sniffing with Sensniff.

This PR relies on the changes to the IP64 subsystem being made in PR #2083.
In CONTRIBUTING.md it is stated that all new platforms need a maintainer. I am employed with Weptech and willing and committed to maintain this platform, just to make this official.
Cheers and Thank you very much,
Thomas","@jonnteolsson Sorry if I'm nagging, but by now I'm wondering if the emails I send you are just landing in your spam folder (26-07-17 and 05-09-17).
Can you please drop me just a short line on whether I can help you with something; whether I should just wait for some time (any time frame is fine, I know it's a favour you're giving me); or whether you won't be able to come around to this so I should go and look for other testers?
Thanks a lot,
Thomas",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2083,2017-01-19T14:43:43Z,,2017-04-03T08:44:14Z,OPEN,False,174,151,5,https://github.com/thomas-blank,Enc28j60 ip64 mac address,3,[],https://github.com/contiki-os/contiki/pull/2083,https://github.com/thomas-blank,1,https://github.com/contiki-os/contiki/pull/2083,"This PR adds and changes a few behaviours in the IP64 module. They were developed while developing #2082 . That PR relies on these changes here.
The Saker Gateway has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
Commit ce574d9 ""Allow to provide MAC addresses to the enc28j60-ip64-driver."" adds functionality to get the MAC address from the EEPROM passed on into the ethrenet driver. I wrote a commit message that contains all my thoughts on why I solved that problem the way I solved it. While I think that it's the best solution that I'm aware of, I'm still not entirely sure that it's the way to go, so please advise.
The other commit that is not completely trivial is 03c9d47 ""Fixed first IP64 port mapping not being randomized."" Please also refer to the commit message.","This PR adds and changes a few behaviours in the IP64 module. They were developed while developing #2082 . That PR relies on these changes here.
The Saker Gateway has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
Commit ce574d9 ""Allow to provide MAC addresses to the enc28j60-ip64-driver."" adds functionality to get the MAC address from the EEPROM passed on into the ethrenet driver. I wrote a commit message that contains all my thoughts on why I solved that problem the way I solved it. While I think that it's the best solution that I'm aware of, I'm still not entirely sure that it's the way to go, so please advise.
The other commit that is not completely trivial is 03c9d47 ""Fixed first IP64 port mapping not being randomized."" Please also refer to the commit message.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2083,2017-01-19T14:43:43Z,,2017-04-03T08:44:14Z,OPEN,False,174,151,5,https://github.com/thomas-blank,Enc28j60 ip64 mac address,3,[],https://github.com/contiki-os/contiki/pull/2083,https://github.com/thomas-blank,2,https://github.com/contiki-os/contiki/pull/2083#issuecomment-274091887,"This PR adds and changes a few behaviours in the IP64 module. They were developed while developing #2082 . That PR relies on these changes here.
The Saker Gateway has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
Commit ce574d9 ""Allow to provide MAC addresses to the enc28j60-ip64-driver."" adds functionality to get the MAC address from the EEPROM passed on into the ethrenet driver. I wrote a commit message that contains all my thoughts on why I solved that problem the way I solved it. While I think that it's the best solution that I'm aware of, I'm still not entirely sure that it's the way to go, so please advise.
The other commit that is not completely trivial is 03c9d47 ""Fixed first IP64 port mapping not being randomized."" Please also refer to the commit message.",I ran uncrustify on the files that I touched and have marked the actual changes with comments to make the review easier.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2083,2017-01-19T14:43:43Z,,2017-04-03T08:44:14Z,OPEN,False,174,151,5,https://github.com/thomas-blank,Enc28j60 ip64 mac address,3,[],https://github.com/contiki-os/contiki/pull/2083,https://github.com/thomas-blank,3,https://github.com/contiki-os/contiki/pull/2083#issuecomment-291082987,"This PR adds and changes a few behaviours in the IP64 module. They were developed while developing #2082 . That PR relies on these changes here.
The Saker Gateway has and uses Contiki's own drivers for the CC1200 SubGHz radio chip, the ENC28J60 Ethernet chip, and the CC2538 SoC including the 2,4GHz radio core. It additionally features a Microchip 24AA02E48 EEPROM that is accessible via I2C and that comes with a globally unique EUI48 (i.e. MAC Address) for the ethernet interface.
Commit ce574d9 ""Allow to provide MAC addresses to the enc28j60-ip64-driver."" adds functionality to get the MAC address from the EEPROM passed on into the ethrenet driver. I wrote a commit message that contains all my thoughts on why I solved that problem the way I solved it. While I think that it's the best solution that I'm aware of, I'm still not entirely sure that it's the way to go, so please advise.
The other commit that is not completely trivial is 03c9d47 ""Fixed first IP64 port mapping not being randomized."" Please also refer to the commit message.","Due to updates in master, the ip64-ipv4-dhcp module in this branch conflicted with with it, so I rebased my changes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2084,2017-01-19T16:19:01Z,,2017-09-28T13:34:27Z,OPEN,False,494,0,4,https://github.com/minecet,RFID for Z1 platform,6,[],https://github.com/contiki-os/contiki/pull/2084,https://github.com/minecet,1,https://github.com/contiki-os/contiki/pull/2084,This pull request introduces a new driver for NXP MFRC522 Contacless RFID Reader for the Z1 platform.,This pull request introduces a new driver for NXP MFRC522 Contacless RFID Reader for the Z1 platform.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2084,2017-01-19T16:19:01Z,,2017-09-28T13:34:27Z,OPEN,False,494,0,4,https://github.com/minecet,RFID for Z1 platform,6,[],https://github.com/contiki-os/contiki/pull/2084,https://github.com/alignan,2,https://github.com/contiki-os/contiki/pull/2084#issuecomment-273823259,This pull request introduces a new driver for NXP MFRC522 Contacless RFID Reader for the Z1 platform.,"Nice!
Please run uncrustify, the code style needs some lovin'
https://github.com/contiki-os/contiki/wiki/Code-Contributions#code-formatting",True,{'THUMBS_UP': ['https://github.com/minecet']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2084,2017-01-19T16:19:01Z,,2017-09-28T13:34:27Z,OPEN,False,494,0,4,https://github.com/minecet,RFID for Z1 platform,6,[],https://github.com/contiki-os/contiki/pull/2084,https://github.com/msloth,3,https://github.com/contiki-os/contiki/pull/2084#issuecomment-274156169,This pull request introduces a new driver for NXP MFRC522 Contacless RFID Reader for the Z1 platform.,"Cool stuff adding RFID, and if I'm not mistaken this particular RFID reader is highly integrated, meaning there's no need to get knee-deep in the ISO14443/15693 (etc) this and that, making it quick and simple to add RFID-reading capabilities to a device :)
There's a file in the apps folder that contains AUTOSTART_PROCESSES, I'm guessing that's not intended since that's not what's expected from a driver. Instead, you'd want sth like mfrc522_init() which starts the RFID reader process. That file also got the wrong line endings (you can run eg d2u yourfile.c) - see the diff to see what I mean. Further, the filename case is not following the style.
Finally I don't think adding apps/ here is good (platform/CPU-specific). I'd instead suggest adding an example file in the appropriate folder to show how to use it.",True,"{'THUMBS_UP': ['https://github.com/minecet', 'https://github.com/jdede']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,2084,2017-01-19T16:19:01Z,,2017-09-28T13:34:27Z,OPEN,False,494,0,4,https://github.com/minecet,RFID for Z1 platform,6,[],https://github.com/contiki-os/contiki/pull/2084,https://github.com/minecet,4,https://github.com/contiki-os/contiki/pull/2084#issuecomment-276617441,This pull request introduces a new driver for NXP MFRC522 Contacless RFID Reader for the Z1 platform.,"Hi,
I made the changes that you have mentioned. Hopefully, I haven't missed anything. Please let me know if you have any further comments. Could you have a look again?
Thanks!",True,{'THUMBS_UP': ['https://github.com/jdede']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2084,2017-01-19T16:19:01Z,,2017-09-28T13:34:27Z,OPEN,False,494,0,4,https://github.com/minecet,RFID for Z1 platform,6,[],https://github.com/contiki-os/contiki/pull/2084,https://github.com/jdede,5,https://github.com/contiki-os/contiki/pull/2084#issuecomment-332837777,This pull request introduces a new driver for NXP MFRC522 Contacless RFID Reader for the Z1 platform.,"What is the status of this piece of code? What shall we do to get it merged into Contiki? @alignan @msloth, do you have any recommendations and ideas?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2087,2017-01-24T10:45:16Z,2017-01-24T10:49:38Z,2017-01-24T10:49:38Z,CLOSED,False,2552,26,41,https://github.com/mahshadkoohi,Literature extensions,59,[],https://github.com/contiki-os/contiki/pull/2087,https://github.com/mahshadkoohi,1,https://github.com/contiki-os/contiki/pull/2087,pull,pull,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2089,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/laurentderu,2,https://github.com/contiki-os/contiki/pull/2089#issuecomment-275333266,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","üëç from me, this is really an interesting feature !
Why are you using bytes to fill and check the stack however, a cpu word (16/32bits) would be more efficient.
Could you also add a simpler test to test the bottom of the stack so it could be added into the main loop of Contiki (with a compilation option of course) and so detect a soon as possible a stack overflow without having to scan the whole stack.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/2089#issuecomment-275390021,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Changed the logic to use a 16-bit word when filling and checking the stack, thanks for the feedback. 16-bit as I'd prefer a single version of the code for both 16-bit and 32-bit CPUs.
Including this in the main loop is possible, are platform maintainers ok with that? @g-oikonomou @alignan",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/oliverschmidt,4,https://github.com/contiki-os/contiki/pull/2089#issuecomment-275390813,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","I personally would prefer ""stack check"" over ""stack checker""...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/alignan,5,https://github.com/contiki-os/contiki/pull/2089#issuecomment-275390998,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.",I would be more on-board if this was also extended to the CC2538-based platforms üòÑ,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,6,https://github.com/contiki-os/contiki/pull/2089#issuecomment-275393769,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Hi Antonio,
deciding the RAM size and address on cc2538 looks tricky, as they are dependent on many defines in  dev/cc2538-dev.h and the linker script cc2538.lds.
When I now think about this, maybe it's better to make this less accurate but also less platform dependent and just assume that the stack bottom is an address of a local variable in the main() function, rather than requiring a platform-specific #define.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/alignan,7,https://github.com/contiki-os/contiki/pull/2089#issuecomment-275394364,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Probably yes, I think this is a great feature and somehow everyone ends up doing their own way, that's why I was hopping for a broader approach.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,8,https://github.com/contiki-os/contiki/pull/2089#issuecomment-276403824,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Added CC2538DK and Zoul to the platforms. Now #define STACK_ORIGIN is optional; if not defined, the stack origin is assumed. So it's very easy to add more platforms, at the minimum just one #include and a call to stack_check_init() from the main().
Also renamed the library to ""stack_check"" and took the watchdog pinging out of the for loops.
I did not add the periodic checks in the main loops yet and would prefer to leave that to maintainers (or at least get explicit ok) as that might be quite intrusive I think.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/arurke,9,https://github.com/contiki-os/contiki/pull/2089#issuecomment-279105104,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","I'll just add that I tested it on a cc1310 custom board, unsurprisingly it worked fine. Regarding the 500 byte reservation you mention, is this it? üòï
_Min_Stack_Size = 0x100;",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,10,https://github.com/contiki-os/contiki/pull/2089#issuecomment-279164139,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Thanks and yes, that's what I meant. So in mainline Contiki that's actually only 256 bytes reserved for the stack, not 512 (0x200) as was in our fork.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/bthebaudeau,11,https://github.com/contiki-os/contiki/pull/2089#issuecomment-279227235,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","watchdog_periodic() should not be useful in stack_check_init().
memset() would be more efficient than your loop in stack_check_init(), provided that it is available on all the targeted platforms.
stack_check_init() should just fill the stack from bottom to top, without this &local hack, which could fail since local and p may be placed in any order in the stack relatively to each other. Just define symbols for bottom and top of stack, and make sure that stack_check_init() does not use the stack (which could be an issue on some platforms). Another, simpler way, would be to just drop local and to instead use the address before that of p.
The stack is already in use in main(), so calling stack_check_init() from main() is a destructive operation (though not as much as it would be with a true stack fill, thanks to your &local hack), and it does not allow to trace the first operations using the stack. For instance, on CC2538, it should be called at the beginning of reset_handler() in cpu/cc2538/startup-gcc.c, which would also avoid duplicating this call in all the CC2538 contiki-main.c files.
stack_check_init() slightly slows down boot, so it should actually do something only if some dedicated configuration option is enabled (debug vs. release). And your other stack functions should be adapted accordingly to do nothing and return neutral results (i.e. that would not be interpreted as a stack overflow).
In the linker scripts, _end can be used to mean various things. It would be better to use a more meaningful naming. _ebss is already defined to the same value in the linker scripts where you have defined _end, but you could also use names such as _stack or _edatabss.
What is the point of the empty examples/stack/project-conf.h?
trigerred -> triggered.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,12,https://github.com/contiki-os/contiki/pull/2089#issuecomment-286513073,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Hello, let me address your comments  @bthebaudeau.

watchdog_periodic() should not be useful in stack_check_init().

Because at the point where it's called watchdog is not started yet? Not sure if that's guaranteed. And any, someone might want to reinitialize this library for some reason in the future, so better to be safe.

memset() would be more efficient than your loop in stack_check_init(), provided that it is available on all the targeted platforms.

Not sure how to call it in a safe way, as a function call requires the stack to remain intact in order to jump back to the calling function.

stack_check_init() should just fill the stack from bottom to top, without this &local hack, which could fail since local and p may be placed in any order in the stack relatively to each other. Just define symbols for bottom and top of stack, and make sure that stack_check_init() does not use the stack (which could be an issue on some platforms). Another, simpler way, would be to just drop local and to instead use the address before that of p.

True, don't need the local variable at all. Updated.

The stack is already in use in main(), so calling stack_check_init() from main() is a destructive operation (though not as much as it would be with a true stack fill, thanks to your &local hack), and it does not allow to trace the first operations using the stack. For instance, on CC2538, it should be called at the beginning of reset_handler() in cpu/cc2538/startup-gcc.c, which would also avoid duplicating this call in all the CC2538 contiki-main.c files.

The idea was to call this after serial port is already initialized, so the user can do some printing in the init function(that's why there's some printf code left there, only commented out). It's not overwritting the stack used by main().

stack_check_init() slightly slows down boot, so it should actually do something only if some dedicated configuration option is enabled (debug vs. release). And your other stack functions should be adapted accordingly to do nothing and return neutral results (i.e. that would not be interpreted as a stack overflow).

Good point, done. STACK_CHECK_CONF_ENABLED controls this now. It's left enabled by default, as I think defensive programming is the way to go.

In the linker scripts, _end can be used to mean various things. It would be better to use a more meaningful naming. _ebss is already defined to the same value in the linker scripts where you have defined _end, but you could also use names such as _stack or _edatabss.

That's a standard name on msp430. The difference is that msp430 linker scripts are no included in Contiki itself, while CC2538 and CC26xx are. So it's either using _end or different names for different platforms, which is ugly for other reasons...
Additionally I reverted back to filling the stack by a single byte. As the checker can now be easily disabled, I prefer to go with prettier code rather than small improvement in boot speed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/g-oikonomou,13,https://github.com/contiki-os/contiki/pull/2089#issuecomment-287493512,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Where are we here? Overall, this is a desirable feature but keen on reading more thoughts in terms of its actual implementation. @bthebaudeau @simonduq @laurentderu",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/bthebaudeau,14,https://github.com/contiki-os/contiki/pull/2089#issuecomment-287657926,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","@atiselsts


watchdog_periodic() should not be useful in stack_check_init().

Because at the point where it's called watchdog is not started yet? Not sure if that's guaranteed. And any, someone might want to reinitialize this library for some reason in the future, so better to be safe.

If stack_check_init() may be called from several places, then it may set stack_origin to different values, so stack_check_get_usage() may then report inaccurate values.
In platform/zoul/contiki-main.c, you call stack_check_init() after watchdog_init(). My comment was assuming that this call is moved before main() as suggested in one of my next comments. So yes, one reason is that the watchdog has not yet been started at this point. But my comment is still valid without this assumption, because another reason is that the .data and .bss sections can be safely initialized without taking care of the watchdog. I mean: the stack is never gigantic on MCUs, so a memset() over it should be pretty fast, and the watchdog timeouts are usually very long. Otherwise, no buffer could be initialized without triggering the watchdog.
Moreover, stack_check_init() resets the watchdog only before and after the actual stack initialization, which is assuming that there is a long operation that could take place either before or after this function without resetting the watchdog, rather than assuming that this function could take too much time by itself.
Lastly, the call to stack_check_init() cannot be moved before main() if stack_check_init() resets the watchdog, because watchdog_init() is called only in main().


memset() would be more efficient than your loop in stack_check_init(), provided that it is available on all the targeted platforms.

Not sure how to call it in a safe way, as a function call requires the stack to remain intact in order to jump back to the calling function.

This actually depends on the MCU architecture and on the ABI. This is indeed true in some cases. But your loop does not guarantee anything either, as the compiler may generate code using the stack below p for it, even if this is unlikely. A reasonably safe way would be to consider that some stack area below p should not be touched. The only strictly safe way is to use assembly code, preferably at the beginning of the reset handler.


stack_check_init() should just fill the stack from bottom to top, without this &local hack, which could fail since local and p may be placed in any order in the stack relatively to each other. Just define symbols for bottom and top of stack, and make sure that stack_check_init() does not use the stack (which could be an issue on some platforms). Another, simpler way, would be to just drop local and to instead use the address before that of p.

True, don't need the local variable at all. Updated.

You're still filling the stack from top to bottom, which is usually slower.
The result of the 1st iteration of your loop is undefined because the -- and the = operations target the same address (that of p). This loop should exclude &p.


The stack is already in use in main(), so calling stack_check_init() from main() is a destructive operation (though not as much as it would be with a true stack fill, thanks to your &local hack), and it does not allow to trace the first operations using the stack. For instance, on CC2538, it should be called at the beginning of reset_handler() in cpu/cc2538/startup-gcc.c, which would also avoid duplicating this call in all the CC2538 contiki-main.c files.

The idea was to call this after serial port is already initialized, so the user can do some printing in the init function(that's why there's some printf code left there, only commented out).

This is not required: it is only a debug printf() to debug the stack debug code. üòâ

It's not overwritting the stack used by main().

No, but it's destroying the stack usage information regarding what occurred before main().


stack_check_init() slightly slows down boot, so it should actually do something only if some dedicated configuration option is enabled (debug vs. release). And your other stack functions should be adapted accordingly to do nothing and return neutral results (i.e. that would not be interpreted as a stack overflow).

Good point, done. STACK_CHECK_CONF_ENABLED controls this now.

Good. However, it would be better to move the empty definitions into the header file as macros, so that they can just be optimized away.

It's left enabled by default, as I think defensive programming is the way to go.

This code does nothing more than waste time if the stack_check_*() functions are not called, which is the case everywhere except in this example, so it should be disabled by default.


In the linker scripts, _end can be used to mean various things. It would be better to use a more meaningful naming. _ebss is already defined to the same value in the linker scripts where you have defined _end, but you could also use names such as _stack or _edatabss.

That's a standard name on msp430. The difference is that msp430 linker scripts are no included in Contiki itself, while CC2538 and CC26xx are. So it's either using _end or different names for different platforms, which is ugly for other reasons...

At least on ARM, _end is usually the end of the stuff before the heap, i.e. the beginning of the heap (if the heap is used). It would be easy to use the same meaningful name for all platforms. E.g. for MSP430, you could use --defsym=_stack=_end with ld (if the _stack symbol name is not already used).

Additionally I reverted back to filling the stack by a single byte. As the checker can now be easily disabled, I prefer to go with prettier code rather than small improvement in boot speed.

Agreed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,15,https://github.com/contiki-os/contiki/pull/2089#issuecomment-288721298,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Hi, thanks for the in-depth discussion - appreciated even if i don't agree with all.
Let me clarify the intention. The goal of patch is to allow easier debugging and fault detection of user applications. Therefore checking what happens with the stack at the start of and before main() is not relevant from my perspective. If a platform has code that overflows the stack in the first few lines of main() or before that, that platform should not even be part of Contiki anyway, no? The stack usage there is not measured for the same reason, say, energest energy usage is not measured right from the very start. Can you think of any counterexamples for this?

At least on ARM, _end is usually the end of the stuff before the heap, i.e. the beginning of the heap (if the heap is used). It would be easy to use the same meaningful name for all platforms. E.g. for MSP430, you could use --defsym=_stack=_end with ld (if the _stack symbol name is not already used).

Agree about what _end means and added a comment in the loader scripts to clarify that. Still, I think that _end symbol should be added for cc2650 and cc2538, even if separately from this patch (but platform maintainers can override me of course). No one at the moment knows what the symbol _stack means, but many programmers do known what _end means.
And it's not just msp430 that has the _end symbol - for example, the AVR platforms and x86 (the ""native"" platform) do have it too.

The result of the 1st iteration of your loop is undefined

Ok, that's fair point, this looks like UB and now is changed.

A reasonably safe way would be to consider that some stack area below p should not be touched.

Is there a strong argument for a specific value of N rather than N+1 bytes? If not, then N==0 is an good as any other value, provided it's empirically known to work on all tested platforms, compilers and optimization settings - which is the case so far.

If stack_check_init() may be called from several places, then it may set stack_origin to different values, so stack_check_get_usage() may then report inaccurate values.

I can easily imagine an application where the the use re-init the stack once a minute or so, to keep track of the dynamics of stack usage. The API should allow this and be robust enough to work from any state (even almost expired WDT) and clean after itself. Please don't ask for removal of robustness features.

the .data and .bss sections can be safely initialized without taking care of the watchdog. I mean: the stack is never gigantic on MCUs, so a memset() over it should be pretty fast, and the watchdog timeouts are usually very long. Otherwise, no buffer could be initialized without triggering the watchdog.

It it indeed a known problem on msp430 that applications may fail to enter main() if there are too large .data and .bss buffers that need to be initialized.  (See here for an example). As far as I remember, GCC on msp430 does disable the WDT by default as the very first thing, but not all compilers do that.That's why my patch initially had watchdog_periodic() inside the loops - until testing convinced me that it's probably an overkill.

Good. However, it would be better to move the empty definitions into the header file as macros, so that they can just be optimized away.

I agree from efficiency's point of view, however, here I was following the typical Contiki API code style, which typically does have function definitions in .c files - probably for reasons keeping the .h files cleaner - for example, energest_init() is always defined.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/bthebaudeau,16,https://github.com/contiki-os/contiki/pull/2089#issuecomment-288885748,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Hi @atiselsts,

Let me clarify the intention. The goal of patch is to allow easier debugging and fault detection of user applications. Therefore checking what happens with the stack at the start of and before main() is not relevant from my perspective. If a platform has code that overflows the stack in the first few lines of main() or before that, that platform should not even be part of Contiki anyway, no? The stack usage there is not measured for the same reason, say, energest energy usage is not measured right from the very start. Can you think of any counterexamples for this?

For energest, it does not matter much, because the devices do not reboot very often. There is however the specific case of MCUs that have to go through the boot process in order to get out of their most deep sleep states. In that case, it would be interesting to have the energest info for the boot too. If that's not what's implemented, it's probably more because it's complicated than because it's not wanted.
Early stack overflows or not less important than later ones. Bugs should be detected and fixed as much as possible. If a platform has a bug, it should not be rejected from Contiki, but fixed. It is a common practice to use the linker scripts and/or the startup code to automatically fill the stack with a debug pattern such as 0xcd, only once, and at the very beginning of the execution, before main(), or even before the execution (think debugger). Then, it's easy to determine the maximum stack usage at any time. Some IDEs also provide this feature.
However, if it makes things much simpler here not to handle early stack overflows, that's good enough for me.


At least on ARM, _end is usually the end of the stuff before the heap, i.e. the beginning of the heap (if the heap is used). It would be easy to use the same meaningful name for all platforms. E.g. for MSP430, you could use --defsym=_stack=_end with ld (if the _stack symbol name is not already used).

Agree about what _end means and added a comment in the loader scripts to clarify that. Still, I think that _end symbol should be added for cc2650 and cc2538, even if separately from this patch (but platform maintainers can override me of course). No one at the moment knows what the symbol _stack means, but many programmers do known what _end means.
And it's not just msp430 that has the _end symbol - for example, the AVR platforms and x86 (the ""native"" platform) do have it too.

I agree, and my point was based on this argument. What I meant is that the usual definition of _end is the end of BSS as you pointed out, which often coincides with the beginning of the heap on MCUs. So defining _end as you suggest for CC2538 and CC2650 would be fine. But my point was that:

custom linker scripts may follow other conventions,
_end is usually the end of BSS, not necessarily the beginning of the stack.

Consequently, using _end to fill the stack is wrong because it may touch other things than the stack, e.g. the heap, especially if you do this after main(). That's why introducing a custom symbol pointing to the beginning of the stack would be better.


The result of the 1st iteration of your loop is undefined

Ok, that's fair point, this looks like UB and now is changed.

You're doing pointer arithmetic on void *. This is non-standard. It is a GCC extension, and not all the compilers used by the Contiki platforms are GCC-based. You're still filling the stack from top to bottom. The trigerred typo has not been fixed everywhere. Why not just do the following (a bit like what you do in stack_check_get_usage())?
static uint8_t *stack_origin;
/* [...] */
void
stack_check_init(void)
{
  uint8_t *p;

  stack_origin = &p;
  p = &_stack; /* Assuming my previous suggestion */

  /* Make sure WDT is not triggered */
  watchdog_periodic();

  while(p < stack_origin) {
    *p++ = STACK_FILL;
  }

  /* Make sure WDT is not triggered */
  watchdog_periodic();
}



A reasonably safe way would be to consider that some stack area below p should not be touched.

Is there a strong argument for a specific value of N rather than N+1 bytes? If not, then N==0 is an good as any other value, provided it's empirically known to work on all tested platforms, compilers and optimization settings - which is the case so far.

I'm fine with N==0 if it has been thoroughly tested as you say.


If stack_check_init() may be called from several places, then it may set stack_origin to different values, so stack_check_get_usage() may then report inaccurate values.

I can easily imagine an application where the the use re-init the stack once a minute or so, to keep track of the dynamics of stack usage. The API should allow this and be robust enough to work from any state (even almost expired WDT) and clean after itself. Please don't ask for removal of robustness features.

Isn't the goal here to detect stack overflows? What would be the point of tracking the stack depth over time? The stack may do whatever it wants as long as there is a margin large enough to make sure that it may never overflow. Only tracking the stack maximum depth over time is useful to detect when a stack overflow occurred, which requires a single stack fill. Then, it's again about the early stack fill discussion, so as I said above, it's just good enough as you did.


the .data and .bss sections can be safely initialized without taking care of the watchdog. I mean: the stack is never gigantic on MCUs, so a memset() over it should be pretty fast, and the watchdog timeouts are usually very long. Otherwise, no buffer could be initialized without triggering the watchdog.

It it indeed a known problem on msp430 that applications may fail to enter main() if there are too large .data and .bss buffers that need to be initialized.  (See here for an example). As far as I remember, GCC on msp430 does disable the WDT by default as the very first thing, but not all compilers do that.That's why my patch initially had watchdog_periodic() inside the loops - until testing convinced me that it's probably an overkill.

In that case, let's keep your watchdog resets as a precaution.


Good. However, it would be better to move the empty definitions into the header file as macros, so that they can just be optimized away.

I agree from efficiency's point of view, however, here I was following the typical Contiki API code style, which typically does have function definitions in .c files - probably for reasons keeping the .h files cleaner - for example, energest_init() is always defined.

With what I suggest, there would be functions defined in the .c with the option enabled, and macros defined in the .h otherwise, not functions, which is fine with the rules in Contiki. What has been done for energest_init() is a choice, not a rule. See ENERGEST_ON() for an example of a macro defined in a header file.
Travis failed, but it does not want to display the job log right now, so I can't analyze why.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,17,https://github.com/contiki-os/contiki/pull/2089#issuecomment-291828521,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Updated the pull request. I believe we're towards reaching a consensus here. Anyone else wants to have a say?
Updates:

define _stack symbol on CC2538 and CC2650 in the linker script files, and an as alias to _end in Makefile.msp430
also keep the _end symbol in CC2538 and CC2650 linker scripts as it's a fairly standard thing to have
stack filling logic is now as suggested",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/bthebaudeau,18,https://github.com/contiki-os/contiki/pull/2089#issuecomment-292015632,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Very good! Thanks. The only remaining issues that I see are:

the default value of STACK_CHECK_ENABLED, which has no reason to be 1, because the check functions are called nowhere except in this example,
the build failure of Travis on 6502 because of a RAM overflow of 73 bytes, but it does not seem to be related to this PR.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/atiselsts,19,https://github.com/contiki-os/contiki/pull/2089#issuecomment-292152358,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","Yes, Travis is failing on all recent PRs, so it's unrelated.
About being enabled by default - I know you had this complaint in the past and I did not respond to it. I would go for enabled by default as:

The longer-term idea is (I hope) to actually make more use of this in the main events loops of some platforms. Adding this code to a platform should be as simple as possible instead of requiring to put stuff in platform-conf.h files which already are quite hard to manage
Beta testing of this feature (with odd compiler versions, settings etc.) is not really going to happen unless it's enabled by default
Just the fact itself that the stack is filled with 0xcd sometimes does make a difference - it can be helpful when looking at memory dumps in mspsim or by using gdb a big region of 0xcd will clearly indicate untouched stack

The downside is slightly higher flash and RAM usage, and a difference in startup time that no-one will notice unless looking for it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2089,2017-01-24T20:46:24Z,,2017-11-27T21:58:59Z,OPEN,False,519,0,21,https://github.com/atiselsts,"Add stack usage checker feature on msp430, CC26xx, and CC2538 based platforms",4,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx', 'new feature', 'Platform / CPU / ARM / CC2538']",https://github.com/contiki-os/contiki/pull/2089,https://github.com/bthebaudeau,20,https://github.com/contiki-os/contiki/pull/2089#issuecomment-292302523,"This patch adds library code for estimation on run-time stack usage with the aim to make software development for Contiki more robust.
Using the estimator is as simple as:
  printf(""stack usage: %u permitted: %u\n"",
         stack_check_get_usage(), stack_check_get_reserved_size());

For more, see examples/stack/main.c.
The idea behind the implementation is to pre-fill the stack region at the system's initialization with a known patter and then check the boundaries of that pattern during run-time.
When evaluating the checker on some of the example applications in Contiki I was not able to find any that overflows the stack region immediately after starting up. However, cc26xx-web-demo on TI SensorTag likely does that as soon it has to do any serious job such as handling some requests. Immediately after startup there's less than 100 bytes free, as stack usage is 560 bytes from the maximal 658 bytes. Meanwhile, functions such as coap_notify_observers_sub() in the CoAP implementation use literally hundreds of bytes of stack space on their own.
The amount of stack ""reserved"" on CC26xx by default by the linker script (cpu/cc26xx-cc13xx/cc26xx.ld) is just 0x200 or 512 bytes, which is woefully inadequate in my opinion. (This ""reservation"" does not ensure the stack does not overflow during runtime, it just creates a compile-time error if there are less-than-this bytes free after the end of the .data segment). For our projects in University of Bristol we have changed that to 0x500 or 0x700 depending on the project. In particular, in a real deployment that uses the CoAP / 6LoWPAN / TSCH  / IEEE 802.15.4 network stack I've observed stack usage up to 1750 bytes using this checker library.","This is a debugging feature. Users should not have to know that they need to disable it to optimize their binaries. On the other hand, they should know that this features exists whenever they need it, and it should be easy to use. If it is disabled by default, well documented in the Wiki, and integrated in the main event loops of most platforms, then it is easy to enable on a per-project basis thanks to project-conf.h, as you did in your example. There would be nothing about this feature in platform-conf.h in that case. We could even go further and introduce a global DEBUG make switch (maybe it already exists?) that would enable most debug features if set, and optimize performance and size for release if unset, like the default debug and release project configurations found in most IDEs. What do you think? One more thing: if enabled by default and integrated in the main event loops of most platforms, the associated periodic printf() would pollute the text output of the examples, unless it prints something only in case of stack overflow, but that could be too late to be able to print anything.
It's Travis' job, using your example. Actually, I see that this example has not been added to the test suite for the supported platforms. Please do so. You can do it like for the cfs-coffee example. E.g., see https://github.com/contiki-os/contiki/blob/master/regression-tests/18-compile-arm-ports/Makefile .
Yes, that would be useful. Perhaps it could be enabled by default if mspsim is used. As to the gdb case, it's a typical debugging context that could use project-conf.h when needed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2090,2017-01-26T13:32:50Z,2017-02-18T22:25:02Z,2017-02-18T22:25:02Z,MERGED,True,4,3,1,https://github.com/atiselsts,CC26xx IEEE mode radio: fix LQI reading,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2090,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2090,"LQI reading was taken with an incorrect offset in the received packet buffer.
Also, the mask for the LQI in the status word should be 0x3f, not 0x7f, as the bit 0x40 refers to the frame filtering status of the packet.","LQI reading was taken with an incorrect offset in the received packet buffer.
Also, the mask for the LQI in the status word should be 0x3f, not 0x7f, as the bit 0x40 refers to the frame filtering status of the packet.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2090,2017-01-26T13:32:50Z,2017-02-18T22:25:02Z,2017-02-18T22:25:02Z,MERGED,True,4,3,1,https://github.com/atiselsts,CC26xx IEEE mode radio: fix LQI reading,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2090,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2090#issuecomment-275390156,"LQI reading was taken with an incorrect offset in the received packet buffer.
Also, the mask for the LQI in the status word should be 0x3f, not 0x7f, as the bit 0x40 refers to the frame filtering status of the packet.","Nice catch Atis, üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2091,2017-01-26T23:21:34Z,2017-01-27T10:34:45Z,2017-01-28T16:05:09Z,MERGED,True,14,17,5,https://github.com/oliverschmidt,Revert to static Ethernet driver for the ATARI.,1,[],https://github.com/contiki-os/contiki/pull/2091,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2091,After all there's no momentum for a W5100-based Ethernet solution on the ATARI. So I revert to static linkage of the CS8900A driver as this improves program load times.,After all there's no momentum for a W5100-based Ethernet solution on the ATARI. So I revert to static linkage of the CS8900A driver as this improves program load times.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2091,2017-01-26T23:21:34Z,2017-01-27T10:34:45Z,2017-01-28T16:05:09Z,MERGED,True,14,17,5,https://github.com/oliverschmidt,Revert to static Ethernet driver for the ATARI.,1,[],https://github.com/contiki-os/contiki/pull/2091,https://github.com/oliverschmidt,2,https://github.com/contiki-os/contiki/pull/2091#issuecomment-275856524,After all there's no momentum for a W5100-based Ethernet solution on the ATARI. So I revert to static linkage of the CS8900A driver as this improves program load times.,"Thanks for the review and pointing out :-)
I'll fix it with an upcoming pull request - the one I prepared for with the renaming...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2093,2017-01-30T11:13:05Z,2017-03-17T23:08:45Z,2017-03-20T07:44:04Z,MERGED,True,2,0,1,https://github.com/thomas-blank,Fix Bug in MQTT App: Refused Connections should not be pursued.,1,[],https://github.com/contiki-os/contiki/pull/2093,https://github.com/thomas-blank,1,https://github.com/contiki-os/contiki/pull/2093,"If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.","If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2093,2017-01-30T11:13:05Z,2017-03-17T23:08:45Z,2017-03-20T07:44:04Z,MERGED,True,2,0,1,https://github.com/thomas-blank,Fix Bug in MQTT App: Refused Connections should not be pursued.,1,[],https://github.com/contiki-os/contiki/pull/2093,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2093#issuecomment-285189387,"If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.","This is a good catch. You are not explicitly resetting the connection's state to MQTT_CONN_STATE_NOT_CONNECTED. I only had a quick look and it seems to me it is not required, but can you confirm that this is indeed the case and you are doing this intentionally?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2093,2017-01-30T11:13:05Z,2017-03-17T23:08:45Z,2017-03-20T07:44:04Z,MERGED,True,2,0,1,https://github.com/thomas-blank,Fix Bug in MQTT App: Refused Connections should not be pursued.,1,[],https://github.com/contiki-os/contiki/pull/2093,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/2093#issuecomment-285190812,"If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.","In fact I'm wrong, we do need to reset the MQTT connection's state. There are also question marks regarding the state of the TCP connection. Perhaps a better approach to fix this would be to call abort_connection().",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2093,2017-01-30T11:13:05Z,2017-03-17T23:08:45Z,2017-03-20T07:44:04Z,MERGED,True,2,0,1,https://github.com/thomas-blank,Fix Bug in MQTT App: Refused Connections should not be pursued.,1,[],https://github.com/contiki-os/contiki/pull/2093,https://github.com/thomas-blank,4,https://github.com/contiki-os/contiki/pull/2093#issuecomment-285449704,"If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.","I had a close look at network traffic while I presented the IBM MQTT broker with a few intentionally broken IDs. While on the MQTT level giving a wrong ID gives only that Connect Ack with the error bits set, on a TCP level the whole exchange stays civilized: The server sends the Connect Ack and then closes the connection with a TCP FIN. We handle that TCP event in lines 1104ff with all the necessary resets and cleanups. That is why the code works as was, and was correct in a certain way: The MQTT connection does not advance out of the CONNECTING state. The TCP connection underneath stays untouched by this and is closed separately, for different reasons.
On the other hand, relying on the server to close the connection sounds stupid once I type it out loud, you're right.
I used the TCP event handling code as a reference to see what needs to be cleaned up. Calling abort_connection() is pretty much it. We do not need to stop the keep_alive_timer because it's not started yet.
What I do not understand about the TCP handler once I look at it is why it also posts a mqtt_abort_now_event - That should cause the mqtt_process to call abort_connection(), too, but in practice I don't see that happening: When I do both in handle_connack(), aborting the connection and posting the event, abort_connection is still only called once. Why does the process not run/get the event/ call abort_connection?
But this is off topic and possibly I'm just not understanding correctly what's going on. I tested this version both with liberal printf use and by checking wireshark and believe this way it's correct.
Should I do anything about the TCP event handler once this fix is through? Should I try to get to the root of the smell, just to make sure there's nothing wrong with the code?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2093,2017-01-30T11:13:05Z,2017-03-17T23:08:45Z,2017-03-20T07:44:04Z,MERGED,True,2,0,1,https://github.com/thomas-blank,Fix Bug in MQTT App: Refused Connections should not be pursued.,1,[],https://github.com/contiki-os/contiki/pull/2093,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/2093#issuecomment-287492841,"If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.","I cannot say I can immediately understand what you are asking there, but it seems as though we are both on the same page in terms of having to abort the connection attempt client-side. Thus, merging this in good faith! :) üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2093,2017-01-30T11:13:05Z,2017-03-17T23:08:45Z,2017-03-20T07:44:04Z,MERGED,True,2,0,1,https://github.com/thomas-blank,Fix Bug in MQTT App: Refused Connections should not be pursued.,1,[],https://github.com/contiki-os/contiki/pull/2093,https://github.com/thomas-blank,6,https://github.com/contiki-os/contiki/pull/2093#issuecomment-287693332,"If the MQTT connection is acked by the broker with an error, like when the given client ID is not accepted by the server, the MQTT app recognizes that error, sends a corresponding event to the app user process, but then continues to use the connection as if the connection had been acked without an error, including sending another event to the app user process.","Yes, we're on the same page there
The question was whether anything should be done about The TCP Event Handler in line 1109ff: https://github.com/contiki-os/contiki/blob/master/apps/mqtt/mqtt.c#L1106 - That code does a lot more, sets the status of the connection, calls abort_connection(), and dispatches a mqtt_abort_now_event. With the mqtt_abort_now_event, the main mqtt process should call abort_connection() again. But with a printf()-statement in abort_connection(), I could see that abort_connection() is called only once. I see that as a code smell with something potentially being wrong.
The question was: Can you tell if that code is correct and I just misunderstood something, or do you agree that this lost double call to abort_connection looks weird, then I'll take the time to have another look at that and maybe prepare another pull request?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2097,2017-02-05T22:26:30Z,2017-02-13T19:05:57Z,2017-02-13T19:05:57Z,MERGED,True,5,39,7,https://github.com/oliverschmidt,Removed artifacts of former uip_appdata handling.,1,[],https://github.com/contiki-os/contiki/pull/2097,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2097,"Adam Dunkels writes on 2/5/2017 on the Contiki mailing list:
[...] the original idea was that the application could just point the uip_appdata pointer to wherever the data was, but we then changed it so that the data actually had to be copied into the uip_aligned_buf buffer. So, yes, the network device driver should only need to read from this buffer. [...]
This change removes comments on the possibility of uip_appdata pointing somewhere outside the uip_aligned_buf. And it removes code in the SLIP drivers not necessary anymore.
Additionally it makes code in a SLIP driver optional that takes care of the Microsoft-specific CLIENT / SERVER / CLIENTSERVER chat.","Adam Dunkels writes on 2/5/2017 on the Contiki mailing list:
[...] the original idea was that the application could just point the uip_appdata pointer to wherever the data was, but we then changed it so that the data actually had to be copied into the uip_aligned_buf buffer. So, yes, the network device driver should only need to read from this buffer. [...]
This change removes comments on the possibility of uip_appdata pointing somewhere outside the uip_aligned_buf. And it removes code in the SLIP drivers not necessary anymore.
Additionally it makes code in a SLIP driver optional that takes care of the Microsoft-specific CLIENT / SERVER / CLIENTSERVER chat.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2097,2017-02-05T22:26:30Z,2017-02-13T19:05:57Z,2017-02-13T19:05:57Z,MERGED,True,5,39,7,https://github.com/oliverschmidt,Removed artifacts of former uip_appdata handling.,1,[],https://github.com/contiki-os/contiki/pull/2097,https://github.com/oliverschmidt,2,https://github.com/contiki-os/contiki/pull/2097#issuecomment-279088101,"Adam Dunkels writes on 2/5/2017 on the Contiki mailing list:
[...] the original idea was that the application could just point the uip_appdata pointer to wherever the data was, but we then changed it so that the data actually had to be copied into the uip_aligned_buf buffer. So, yes, the network device driver should only need to read from this buffer. [...]
This change removes comments on the possibility of uip_appdata pointing somewhere outside the uip_aligned_buf. And it removes code in the SLIP drivers not necessary anymore.
Additionally it makes code in a SLIP driver optional that takes care of the Microsoft-specific CLIENT / SERVER / CLIENTSERVER chat.",If noone vetos against it I'll merge this soon...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2098,2017-02-06T17:39:14Z,,2017-02-07T14:40:52Z,OPEN,False,3296,372,29,https://github.com/yatch,Multiple Neighbor Cache Entries per Link-Layer Address,22,[],https://github.com/contiki-os/contiki/pull/2098,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2098,"Summary
This PR enables multiple IPv6 addresses to be associated with a single link-layer address.
Background
Currently, we can have only a single neighbor cache entry per link-layer address. This limitation could cause an communication issue when a node talks to different IPv6 addresses which are associated with an identical link-layer address. This is what @laurentderu pointed out in #1984 (comment).
Major Changes

Associate IPv6 routes with a particular neighbor cache entry instead of a corresponding link-layer address
Associate neighbor cache entries with a corresponding link-layer address

These changes should be enabled only if UIP_DS6_NBR_MULTI_IPV6_ADDRS is set with non-zero. This can be done setting 1 to UIP_DS6_NBR_CONF_MULTI_IPV6_ADDRS in your project-conf.h.
Test
Regression tests for uip_ds6_route and uip_ds6_nbr APIs are introduced under regression-tests/03-base.
$ make 05-cooja-uip-ds6-route.testlog
Running test 05-cooja-uip-ds6-route with random Seed 1: ........................... OK

$ make 06-cooja-uip-ds6-nbr.testlog
Running test 06-cooja-uip-ds6-nbr with random Seed 1: ........................... OK
Dependency
This PR depends on #1984. Now, it has all the dependent commits which will be removed once #1984 is merged.
Differences with the branch for #1984 are found at yatch/contiki@pr/nud-bugfix...yatch:pr/extend-nc-management.
Disadvantages
Apparently, the feature enabled by UIP_DS6_NBR_MULTI_IPV6_ADDRS consumes more memory than the current implementation. And, code accessing ds6_neighbors directly will need to be replaced. A part of the replacement is done in core/net/rpl/rpl-nbr-policy.c.","Summary
This PR enables multiple IPv6 addresses to be associated with a single link-layer address.
Background
Currently, we can have only a single neighbor cache entry per link-layer address. This limitation could cause an communication issue when a node talks to different IPv6 addresses which are associated with an identical link-layer address. This is what @laurentderu pointed out in #1984 (comment).
Major Changes

Associate IPv6 routes with a particular neighbor cache entry instead of a corresponding link-layer address
Associate neighbor cache entries with a corresponding link-layer address

These changes should be enabled only if UIP_DS6_NBR_MULTI_IPV6_ADDRS is set with non-zero. This can be done setting 1 to UIP_DS6_NBR_CONF_MULTI_IPV6_ADDRS in your project-conf.h.
Test
Regression tests for uip_ds6_route and uip_ds6_nbr APIs are introduced under regression-tests/03-base.
$ make 05-cooja-uip-ds6-route.testlog
Running test 05-cooja-uip-ds6-route with random Seed 1: ........................... OK

$ make 06-cooja-uip-ds6-nbr.testlog
Running test 06-cooja-uip-ds6-nbr with random Seed 1: ........................... OK
Dependency
This PR depends on #1984. Now, it has all the dependent commits which will be removed once #1984 is merged.
Differences with the branch for #1984 are found at yatch/contiki@pr/nud-bugfix...yatch:pr/extend-nc-management.
Disadvantages
Apparently, the feature enabled by UIP_DS6_NBR_MULTI_IPV6_ADDRS consumes more memory than the current implementation. And, code accessing ds6_neighbors directly will need to be replaced. A part of the replacement is done in core/net/rpl/rpl-nbr-policy.c.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2101,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/2101#issuecomment-278188986,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Oops, something wrong with the sequence number of a DAO with a multicast address for the target... I feel I hit another bug. I'm looking into it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,3,https://github.com/contiki-os/contiki/pull/2101#issuecomment-278198866,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","I've pushed another commit which hopefully resolves the issue found in the DAO sequence number management. It might be better to discuss the commit in a separate PR...
RPL_LOLLIPOP_INCREMENT(dao_sequence); has been moved from dao_output_target() to dao_output() by #1634 so that a correct sequence number is stored in my_dao_seqno. However, to my understanding, this causes a DAO for multicast routes to have the same sequence number as the last DAO for unicast routes sent by dao_output().
I reverted the change with taking into account my_dao_seqno.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/lcharpenwi6labs,4,https://github.com/contiki-os/contiki/pull/2101#issuecomment-278265830,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Hello
Thanks for the correction.
I tested it but I am not sure it's the best solution.
According to me, it's good to keep the route state even if it's a multicast route.
Here is my proposal:
In uip-macst6-route.h:
/** \brief An entry in the multicast routing table */
typedef struct uip_mcast6_route {
  struct uip_mcast6_route *next; /**< Routes are arranged in a linked list */
  uip_ipaddr_t group; /**< The multicast group */
  uint32_t lifetime; /**< Entry lifetime seconds */
  void *dag; /**< Pointer to an rpl_dag_t struct */
+#ifdef UIP_DS6_ROUTE_STATE_TYPE
+ UIP_DS6_ROUTE_STATE_TYPE state;
+#endif
} uip_mcast6_route_t;

Then, in rpl_icmpv6.c
/* prepare for forwarding of DAO */
static uint8_t
prepare_for_dao_multicast_fwd(uint8_t sequence, uip_mcast6_route_t *rep)
{

  /* not pending - or pending but not a retransmission */
  RPL_LOLLIPOP_INCREMENT(dao_sequence);

  /* set DAO pending and sequence numbers */
  rep->state.dao_seqno_in = sequence;
  rep->state.dao_seqno_out = dao_sequence;
  RPL_ROUTE_SET_DAO_PENDING(rep);

  return dao_sequence;
}

static void
dao_input_storing(void)
{
....
      if(RPL_ROUTE_IS_DAO_PENDING(rep) &&
         rep->state.dao_seqno_in == sequence) {
        /* keep the same seq-no as before for parent also */
        out_seq = rep->state.dao_seqno_out;
      } else if((uip_is_addr_mcast_global(&prefix)) && (mcast_group != NULL)) {
        out_seq = prepare_for_dao_multicast_fwd(sequence, mcast_group);
      } else if(rep != NULL) {
        out_seq = prepare_for_dao_fwd(sequence, rep);
      }
....",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,5,https://github.com/contiki-os/contiki/pull/2101#issuecomment-278311863,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","@lcharpenwi6labs Thank you for your comment! I was going to do a similar thing as your idea adding the UIP_DS6_ROUTE_STATE_TYPE state member to uip_mcast6_route_t. I think there are two issues with the idea. One is major and the other is minor.

[major issue] rpl_route_entry_t assumes an associated route is registered by a single neighbor. This is the case for a unicast route in most cases. Not for a multicast route. And, I don't think it's trivial to handle the multicast route case in the current code base...
[minor issue] Since uip_mcast6_route has already lifetime and dag,  simply adding rpl_route_entry_t to uip_mcast6_route would waste memory. rpl_route_entry_t has also lifetime and dag members.

For the issues mentioned above, I decided to give up the End-to-End DAO-ACK for multicast for now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/lcharpenwi6labs,6,https://github.com/contiki-os/contiki/pull/2101#issuecomment-278333473,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Thanks for your feedback
I understand your point and I agree with you.
We have tested it and it works fine.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,7,https://github.com/contiki-os/contiki/pull/2101#issuecomment-278334817,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",@lcharpenwi6labs Thank you for your testing. I'll update the body message of this PR to close the issue automatically once it's merged.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/simonduq,8,https://github.com/contiki-os/contiki/pull/2101#issuecomment-284995919,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Doesn't the PR contain multiple different fixes? Shouldn't be split in mupltiple PRs?
There seems to be the NULL pointer fix and then some other changes in logic with DAO sequence and ACK.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,9,https://github.com/contiki-os/contiki/pull/2101#issuecomment-285236893,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",@simonduq You're right; this contains changes on DAO handling for multicast. I found two changes in 1d67b94 are irrelevant to the NULL pointer fix. I'll send a separate PR having the two and f3126dc.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/simonduq,10,https://github.com/contiki-os/contiki/pull/2101#issuecomment-285279520,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,11,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286030164,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","I've removed irrelevant changes and performed rebase with solving conflicts. Once this PR gets merged, I'll send a PR on DAO-ACK handling for multicast routes.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/simonduq,12,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286040565,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",thanks for catching and fixing! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,13,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286308398,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Resolved the comment from @simonduq's code review. In addition, put ""make clean"" before each command buidling a test firmware in 11-rpl-multicast.csc.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,14,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286328781,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Oops, something wrong. I'm looking into it. üòì",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,15,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286374963,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","It turned out that including ""rpl-private.h"" within project-conf.h is not a good idea... I've updated the branch and Travis got green.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,16,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286375823,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",I strongly prefer leaving the example's Makefile untouched and controlling the contents of your build directly through project-conf.h. Any particular reason why you need to use make variables to manipulate your build's configuration?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,17,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286379479,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Any particular reason why you need to use make variables to manipulate your build's configuration?

It's purely to get the correct build params for the travis test, right?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,18,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286617255,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","@g-oikonomou Thank you for your comment :-)
Yes, it is; I need firmwares supporting SMRF and DAO-ACK in order for the test for this particular fix. üòä
I found examples/ipv6/multicast was a nice set of code for my purpose, but they didn't meet my requirements, SMRF and DAO-ACK support.
However I didn't want to change the default configuration of them since, as you know, this example is used in other regression tests, 17-cooja-multicast-11-hops.csc and 18-cooja-multicast-31-hops.csc, in 11-ipv6, and may be used somewhere else with assumption that it's using UIP_MCAST6_ENGINE_ROLL_TM. So, I added a couple of variables into Makefile and an #ifdef block in project-conf.h so that we can switch configuration settings easily from the command line interface, like make WITH_SMRF=1, with keeping the default configuration. The command with make WITH_SMRF=1 WITH_DAO_ACK=1 is used in the newly created .csc file, 11-rpl-multicast.csc, to create test firmwares.
Any other, nicer way to do this without touching the Makefile...?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,19,https://github.com/contiki-os/contiki/pull/2101#issuecomment-286769059,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","I would recommending using the DEFINES make variable. Have you tried this:
$ make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=1,PROJECT_CONF_H=""\\\""""project-conf.h""\\\""""
For this to work, you will have to change project-conf.h to only define UIP_MCAST6_CONF_ENGINE if not already defined.
You do not need to set RPL_CONF_MOP to RPL_MOP_STORING_MULTICAST, enabling SMRF will do this automatically.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,20,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287004629,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","@g-oikonomou I got the idea, overriding DEFINES whose value will be used in CFLAGS. I've updated the branch following your recommendation.. üòÑ Let's see what color Travis will be.
Just out of curiosity; why changing Makefile is a bad idea in this case? It would be acceptable if it were not an example project? I'd appreciate it if you could share your thoughts.
In addition, I'm going to leave some comments here:

How can we escape double quotes in .csc file...? PROJECT_CONF_H=""\\\""""project-conf.h""\\\"""" doesn't work in ... of a .csc file.
RPL_CONF_MOP is not set with RPL_MOP_STORING_MULTICAST by  UIP_MCAST6_CONF_ENGINE=1 or UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF.

Regarding the second comment, you'll get an error as follows unless RPL_CONF_MOP is set explicitly.
../../../core/net/rpl/rpl-private.h:258:2: error: #error ""RPL Multicast requires RPL_MOP_DEFAULT==3. Check contiki-conf.h""
 #error ""RPL Multicast requires RPL_MOP_DEFAULT==3. Check contiki-conf.h""
  ^
../../../Makefile.include:240: recipe for target 'obj_native/uip6.o' failed
make: *** [obj_native/uip6.o] Error 1
When UIP_MCAST6_ENGINE_SMRF is specified as UIP_MCAST6_ENGINE, RPL_WITH_MULTICAST is set with 1 in core/net/ipv6/multicast/uip-mcast6.h and this is supposed to make RPL_MOP_DEFAULT become RPL_MOP_STORING_MULTICAST. The following is an excerpt from rpl-private.h:
    208 /* RPL Mode of operation */
    209 #ifdef  RPL_CONF_MOP
    210 #define RPL_MOP_DEFAULT                 RPL_CONF_MOP
    211 #else /* RPL_CONF_MOP */
    212 #if RPL_WITH_MULTICAST
    213 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_MULTICAST
    214 #else
    215 #define RPL_MOP_DEFAULT                 RPL_MOP_STORING_NO_MULTICAST
    216 #endif /* RPL_WITH_MULTICAST */
    217 #endif /* RPL_CONF_MOP */
However, RPL_CONF_MOP could be defined at the time reading rpl-private.h. contiki-default-conf.h sets RPL_MOP_STORING_NO_MULTICAST to RPL_CONF_MOP unless RPL_CONF_MOP is defined. To my understanding,  contiki-default-conf.h is included before rpl-private.h in the error case shown above.
    151 /* RPL_CONF_MOP specifies the RPL mode of operation that will be
    152  * advertised by the RPL root. Possible values: RPL_MOP_NO_DOWNWARD_ROUTES,
    153  * RPL_MOP_NON_STORING, RPL_MOP_STORING_NO_MULTICAST, RPL_MOP_STORING_MULTICAST */
    154 #ifndef RPL_CONF_MOP
    155 #define RPL_CONF_MOP RPL_MOP_STORING_NO_MULTICAST
    156 #endif /* RPL_CONF_MOP */
Thank you!!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,21,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287005066,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Oh, I clicked the wrong button by mistake... Re-opened this PR. Sorry for the noise.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,22,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287382310,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Just out of curiosity; why changing Makefile is a bad idea in this case? It would be acceptable if it were not an example project? I'd appreciate it if you could share your thoughts.

Because to change the configuration of an example the user would have to make changes in possibly two different places. Also because changing the value of a make variable sometimes requires a make clean (which some users don't realise and some other users simply forget).

How can we escape double quotes in .csc file...? PROJECT_CONF_H=""\""""project-conf.h""\"""" doesn't work in ... of a .csc file.

Sorry, I don't have a clue about this. This is how one needs to escape from the command line, perhaps if you typed it directly in the respective cooja window the csc file would get updated correctly?

Regarding the second comment, you'll get an error as follows unless RPL_CONF_MOP is set explicitly.

This is not intended :( I'm looking at right now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,23,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287393300,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",So basically the example was broken at some point in the past by some change that I cannot dig out right at this moment. The example is now unable to switch between engines the way it is meant to (i.e. simply by changing the engine in project-conf.h). We need to fix this in a separate pull.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,24,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287489759,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","#2145 should fix the problem with the configuration of RPL MOP. When it gets merged, it should be possible to switch between engines simply by changing UIP_MCAST6_CONF_ENGINE. Once this has been done, then this pull can be updated to leave the makefile untouched as per my request.
Other than that üëç for the pointer fix and the respective travis test.
Thank you for your contribution here!",True,{'THUMBS_UP': ['https://github.com/yatch']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/greg-king5,25,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287619937,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","How can we escape double quotes in a .csc file?

PROJECT_CONF_H=""\\\""""project-conf.h""\\\""""
doesn't work in a <command> section of a .csc file.

$ echo PROJECT_H=""\\\""""project.h""\\\""""
PROJECT_H=\""project.h\""
$ echo PROJECT_H=\\\""project.h\\\""
PROJECT_H=\""project.h\""
$ echo PROJECT_H=\\\\\\\\\\\""project.h\\\\\\\\\\\""
PROJECT_H=\\\""project.h\\\""
I don't know if the CSC scanner is as crazy as the shell's scanner; but, you should try eleven (!) back-slashes on each side.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,26,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287621283,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","Far from ideal... There are two acceptable workarounds:
Either we change the Makefile to specify PROJECT_CONF_H like so:
CFLAGS += -DPROJECT_CONF_H=\""project-conf.h\""
or we change the Makefile to use the override directive for DEFINES, like so:
override DEFINES += PROJECT_CONF_H=\""project-conf.h\""
In both cases, we no longer have to specify PROJECT_CONF_H in the command line. It should be possible to simply run:
make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=1",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/greg-king5,27,https://github.com/contiki-os/contiki/pull/2101#issuecomment-287631014,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","I assume that the DEFINES+= method is used to encourage people to modify ""project-conf.h"" instead of doing
make savedefines DEFINES=...
In that case, it should be override DEFINES+=.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,28,https://github.com/contiki-os/contiki/pull/2101#issuecomment-288003055,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","@g-oikonomou @greg-king5 Thank you for your comments! Regarding the escape thing, I cannot still specify PROJECT_CONF_H within a .csc file nor in the corresponding cooja window named ""Create Mote Type"", although I tried the ""eleven baskslash"" method by @greg-king5 üòÜ Cooja always takes away double quotes out of ""compile commands""...
By the way, the idea by @g-oikonomou is nice. I'd like it. üòÑ

In both cases, we no longer have to specify PROJECT_CONF_H in the command line. It should be possible to simply run:
make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=1",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,29,https://github.com/contiki-os/contiki/pull/2101#issuecomment-288829258,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","With #2145 merged, it should be possible to now simply switch engines through project-conf.h. This means we can also do make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=1 to build as per previous posts.
We also need to change project-conf.h like so:
$ git diff -- project-conf.h
diff --git a/examples/ipv6/multicast/project-conf.h b/examples/ipv6/multicast/project-conf.h
index 0c47ab5..7ce29af 100644
--- a/examples/ipv6/multicast/project-conf.h
+++ b/examples/ipv6/multicast/project-conf.h
@@ -44,7 +44,9 @@
 #include ""net/ipv6/multicast/uip-mcast6-engines.h""
 
 /* Change this to switch engines. Engine codes in uip-mcast6-engines.h */
+#ifndef UIP_MCAST6_CONF_ENGINE
 #define UIP_MCAST6_CONF_ENGINE UIP_MCAST6_ENGINE_ROLL_TM
+#endif
 
 /* For Imin: Use 16 over NullRDC, 64 over Contiki MAC */
 #define ROLL_TM_CONF_IMIN_1         64",True,{'THUMBS_UP': ['https://github.com/yatch']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,30,https://github.com/contiki-os/contiki/pull/2101#issuecomment-290954363,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",@yatch it appears as though you have addressed all my comments here about not changing the example's Makefile. Are you ready for this to be considered?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,31,https://github.com/contiki-os/contiki/pull/2101#issuecomment-291089097,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","@g-oikonomou Thanks! I've performed rebase and updated the branch with removing RPL_CONF_MOP=RPL_MOP_STORING_MULTICAST from make command lines as follows:
index c4981de..cd985d9 100644
--- a/regression-tests/12-rpl/11-rpl-multicast.csc
+++ b/regression-tests/12-rpl/11-rpl-multicast.csc
@@ -27,7 +27,7 @@
       <description>Cooja Mote Type #1</description>
       <source>[CONTIKI_DIR]/examples/ipv6/multicast/root.c</source>
       <commands>make clean TARGET=cooja
-      make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF,RPL_CONF_MOP=RPL_MOP_STORING_MULTICAST root.cooja TARGET=cooja</commands>
+      make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF root.cooja TARGET=cooja</commands>
       <moteinterface>org.contikios.cooja.interfaces.Position</moteinterface>
       <moteinterface>org.contikios.cooja.interfaces.Battery</moteinterface>
       <moteinterface>org.contikios.cooja.contikimote.interfaces.ContikiVib</moteinterface>
@@ -53,7 +53,7 @@
       <description>Cooja Mote Type #2</description>
       <source>[CONTIKI_DIR]/examples/ipv6/multicast/sink.c</source>
       <commands>make clean TARGET=cooja
-      make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF,RPL_CONF_MOP=RPL_MOP_STORING_MULTICAST sink.cooja TARGET=cooja</commands>
+      make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF sink.cooja TARGET=cooja</commands>
       <moteinterface>org.contikios.cooja.interfaces.Position</moteinterface>
       <moteinterface>org.contikios.cooja.interfaces.Battery</moteinterface>
       <moteinterface>org.contikios.cooja.contikimote.interfaces.ContikiVib</moteinterface>
@@ -79,7 +79,7 @@
       <description>Cooja Mote Type #3</description>
       <source>[CONTIKI_DIR]/examples/ipv6/multicast/intermediate.c</source>
       <commands>make clean TARGET=cooja
-      make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF,RPL_CONF_MOP=RPL_MOP_STORING_MULTICAST intermediate.cooja TARGET=cooja</commands>
+      make DEFINES=RPL_CONF_WITH_DAO_ACK=1,UIP_MCAST6_CONF_ENGINE=UIP_MCAST6_ENGINE_SMRF intermediate.cooja TARGET=cooja</commands>
       <moteinterface>org.contikios.cooja.interfaces.Position</moteinterface>
       <moteinterface>org.contikios.cooja.interfaces.Battery</moteinterface>
       <moteinterface>org.contikios.cooja.contikimote.interfaces.ContikiVib</moteinterface>
Let's see if Travis gets green...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,32,https://github.com/contiki-os/contiki/pull/2101#issuecomment-291118946,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","The way things are now, this regression test ignores the example's project-conf.h. Can you confirm this is what you intend?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/yatch,33,https://github.com/contiki-os/contiki/pull/2101#issuecomment-291346785,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","@g-oikonomou Yes; it should be fine.
I used project-conf.h in order to define RPL_CONF_WITH_DAO_ACK and UIP_MCAST6_CONF_ENGINE as per arguments of  the make command. Now, I learned how to define those macros directly from a command line, using DEFINES,  which appears to work well. :-)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/g-oikonomou,34,https://github.com/contiki-os/contiki/pull/2101#issuecomment-292673076,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK","üëç from me here, just need someone to quickly double check the RPL-related code, just in case",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2101,2017-02-07T23:32:43Z,2017-04-18T14:09:06Z,2017-05-08T04:42:50Z,MERGED,True,445,173,2,https://github.com/yatch,RPL: fix a bug accessing an uninitialized pointer,3,"['bug', 'nominated', 'RPL']",https://github.com/contiki-os/contiki/pull/2101,https://github.com/nvt,35,https://github.com/contiki-os/contiki/pull/2101#issuecomment-294856267,"This PR aims to resolve #2031.
A new regression test, 11-rpl-multicast.csc, is introduced under regression-tests/12-rpl/.
Without the change, the test fails like this:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ............../../regression-tests/simexec.sh: line 70: 83680 Aborted                 (core dumped) java -Xshare:on -j
(snip)
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007fb713def1f3, pid=83680, tid=0x00007fb712844700
#
# JRE version: OpenJDK Runtime Environment (8.0_121-b13) (build 1.8.0_121-8u121-b13-0ubuntu1.16.04.2-b13)
# Java VM: OpenJDK 64-Bit Server VM (25.121-b13 mixed mode, sharing linux-amd64 compressed oops)
On the tip of the branch, the test succeeds:
$ cd regression-tests/12-rpl
$ make 11-rpl-multicast.testlog
Running test 11-rpl-multicast with random Seed 1: ................. OK",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2102,2017-02-07T23:54:36Z,2017-03-10T14:11:32Z,2017-03-10T14:11:32Z,MERGED,True,4,5,1,https://github.com/yatch,RPL: move a debug message for RPL_LEAF_ONLY to a correct place,1,['timed out'],https://github.com/contiki-os/contiki/pull/2102,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2102,"A debug message output for RPL_LEAF_ONLY seems to have been added at a wrong place in rpl-icmp6.c by PR #142. Here is the relevant part. While L223 is within the case where the destination is a unicast address, the debug message is talking about ""Multicast DIS.""
    221 #if RPL_LEAF_ONLY
    222       if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    226         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    227         rpl_reset_dio_timer(instance);
    228       } else {
    229 #endif /* !RPL_LEAF_ONLY */
The following is my proposal.
    221       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    222 #if RPL_LEAF_ONLY
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    226         rpl_reset_dio_timer(instance);
    227 #endif /* !RPL_LEAF_ONLY */
    228       } else {","A debug message output for RPL_LEAF_ONLY seems to have been added at a wrong place in rpl-icmp6.c by PR #142. Here is the relevant part. While L223 is within the case where the destination is a unicast address, the debug message is talking about ""Multicast DIS.""
    221 #if RPL_LEAF_ONLY
    222       if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    226         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    227         rpl_reset_dio_timer(instance);
    228       } else {
    229 #endif /* !RPL_LEAF_ONLY */
The following is my proposal.
    221       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    222 #if RPL_LEAF_ONLY
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    226         rpl_reset_dio_timer(instance);
    227 #endif /* !RPL_LEAF_ONLY */
    228       } else {",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2102,2017-02-07T23:54:36Z,2017-03-10T14:11:32Z,2017-03-10T14:11:32Z,MERGED,True,4,5,1,https://github.com/yatch,RPL: move a debug message for RPL_LEAF_ONLY to a correct place,1,['timed out'],https://github.com/contiki-os/contiki/pull/2102,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2102#issuecomment-284992483,"A debug message output for RPL_LEAF_ONLY seems to have been added at a wrong place in rpl-icmp6.c by PR #142. Here is the relevant part. While L223 is within the case where the destination is a unicast address, the debug message is talking about ""Multicast DIS.""
    221 #if RPL_LEAF_ONLY
    222       if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    226         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    227         rpl_reset_dio_timer(instance);
    228       } else {
    229 #endif /* !RPL_LEAF_ONLY */
The following is my proposal.
    221       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    222 #if RPL_LEAF_ONLY
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    226         rpl_reset_dio_timer(instance);
    227 #endif /* !RPL_LEAF_ONLY */
    228       } else {",thanks! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2102,2017-02-07T23:54:36Z,2017-03-10T14:11:32Z,2017-03-10T14:11:32Z,MERGED,True,4,5,1,https://github.com/yatch,RPL: move a debug message for RPL_LEAF_ONLY to a correct place,1,['timed out'],https://github.com/contiki-os/contiki/pull/2102,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/2102#issuecomment-284992566,"A debug message output for RPL_LEAF_ONLY seems to have been added at a wrong place in rpl-icmp6.c by PR #142. Here is the relevant part. While L223 is within the case where the destination is a unicast address, the debug message is talking about ""Multicast DIS.""
    221 #if RPL_LEAF_ONLY
    222       if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    226         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    227         rpl_reset_dio_timer(instance);
    228       } else {
    229 #endif /* !RPL_LEAF_ONLY */
The following is my proposal.
    221       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    222 #if RPL_LEAF_ONLY
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    226         rpl_reset_dio_timer(instance);
    227 #endif /* !RPL_LEAF_ONLY */
    228       } else {",setting timeout for merging,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2102,2017-02-07T23:54:36Z,2017-03-10T14:11:32Z,2017-03-10T14:11:32Z,MERGED,True,4,5,1,https://github.com/yatch,RPL: move a debug message for RPL_LEAF_ONLY to a correct place,1,['timed out'],https://github.com/contiki-os/contiki/pull/2102,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2102#issuecomment-285678191,"A debug message output for RPL_LEAF_ONLY seems to have been added at a wrong place in rpl-icmp6.c by PR #142. Here is the relevant part. While L223 is within the case where the destination is a unicast address, the debug message is talking about ""Multicast DIS.""
    221 #if RPL_LEAF_ONLY
    222       if(!uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    226         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    227         rpl_reset_dio_timer(instance);
    228       } else {
    229 #endif /* !RPL_LEAF_ONLY */
The following is my proposal.
    221       if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
    222 #if RPL_LEAF_ONLY
    223         PRINTF(""RPL: LEAF ONLY Multicast DIS will NOT reset DIO timer\n"");
    224 #else /* !RPL_LEAF_ONLY */
    225         PRINTF(""RPL: Multicast DIS => reset DIO timer\n"");
    226         rpl_reset_dio_timer(instance);
    227 #endif /* !RPL_LEAF_ONLY */
    228       } else {",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/andrewbrannan,1,https://github.com/contiki-os/contiki/pull/2103,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.","When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/yatch,2,https://github.com/contiki-os/contiki/pull/2103#issuecomment-278417447,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.","How about updating rpl_update_header() itself? Here is my idea, although I don't perform any test with this change...
$ git diff
diff --git a/core/net/rpl/rpl-ext-header.c b/core/net/rpl/rpl-ext-header.c
index 80de287..b0563af 100644
--- a/core/net/rpl/rpl-ext-header.c
+++ b/core/net/rpl/rpl-ext-header.c
@@ -644,10 +644,16 @@ rpl_update_header(void)
     /* At the root, remove headers if any, and insert SRH or HBH
      * (SRH is inserted only if the destination is in the DODAG) */
     rpl_remove_header();
-    if(RPL_IS_NON_STORING(default_instance)) {
-      return insert_srh_header();
+    if(rpl_get_dag(&UIP_IP_BUF->destipaddr) != NULL) {
+      /* dest is in a DODAG; the packet is going down. */
+      if(RPL_IS_NON_STORING(default_instance)) {
+        return insert_srh_header();
+      } else {
+        return insert_hbh_header(default_instance);
+      }
     } else {
-      return insert_hbh_header(default_instance);
+      /* dest is outside of DODAGs; no ext header is needed. */
+      return 1;
     }
   } else {
     if(uip_ds6_is_my_addr(&UIP_IP_BUF->srcipaddr)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/2103#issuecomment-284991862,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.","Thanks @stringr9 for pointing this out and suggesting a fix.
I find @yatch 's fix easier to read though. @yatch , could you PR?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/andrewbrannan,4,https://github.com/contiki-os/contiki/pull/2103#issuecomment-285031674,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.","@simonduq I incorporated @yatch 's  fix into this PR, hope that's ok.  Have done a quick test here and it seems to work well.",True,{'HOORAY': ['https://github.com/yatch']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/2103#issuecomment-285052687,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.",great! if you could just rebase and squash the two commits I'll be happy to support this PR :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/andrewbrannan,6,https://github.com/contiki-os/contiki/pull/2103#issuecomment-285057032,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.",done!,True,{'THUMBS_UP': ['https://github.com/yatch']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/2103#issuecomment-285081335,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2103,2017-02-08T16:56:45Z,2017-03-23T13:27:06Z,2017-03-23T13:27:07Z,MERGED,True,10,4,1,https://github.com/andrewbrannan,Don't drop packets bound for outside the RPL mesh in non-storing mode,1,[],https://github.com/contiki-os/contiki/pull/2103,https://github.com/nvt,8,https://github.com/contiki-os/contiki/pull/2103#issuecomment-288718517,"When running a network in non-storing mode, the RPL root will drop any packets bound for outside the network  because rpl_update_header() returns 0 when root in non-storing mode if the destination ip address in the IP buffer isn't in a known DAG.
This adds an additional check to not drop the packet if we're in non-storing mode and the packet destination isn't in a known DAG.  Though this seems to work for me, suggestions for a better way to handle this are welcome.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2108,2017-02-10T16:33:41Z,2017-03-08T09:18:42Z,2020-07-29T01:14:18Z,MERGED,True,451,0,9,https://github.com/yatch,TSCH: POC of a bug in tsch_queue_flush_nbr_queue(),2,[],https://github.com/contiki-os/contiki/pull/2108,https://github.com/yatch,1,https://github.com/contiki-os/contiki/pull/2108,"This PR doesn't fix anything; just demonstrates a bug in tsch_queue_flush_nbr_queue(), which could be related to discussions in Issue/#1766 and Issue/#2105.
The test introduced by this PR does the following: Please note QUEUEBUF_CONF_NUM is set with 1.

add one packet by `tsch_queue_add_packet(); should succeed
add one more packet by `tsch_queue_add_packet(); should fail because of lack of memory
call tsch_queue_reset() to invoke tsch_queue_flush_nbr_queue()
add one packet by `tsch_queue_add_packet(); should succeed

You can find the test code in regression-tests/27-tsch/code/test-flush-nbr-queue.c.
Here is the result on the tip of the master branch:
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: ..................................Message:  CC        ../../../core/net/mac/nullmac.c
Message:  CC        ../../../core/net/mac/nullrdc-noframer.c
(snip)
../Makefile.simulation-test:60: recipe for target '01-cooja-flush-nbr-queue.testlog' failed
make: *** [01-cooja-flush-nbr-queue.testlog] Error 1
$ tail 01-cooja-flush-nbr-queue.1.faillog
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe588680620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue: packet is deleted packet=(nil)
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 =check-me= FAILED   - flush_nbr_queue() should delete all the packet in the queue: exit at L79
1550000 node-1 =check-me= DONE
TEST FAILED
Test ended at simulation time: 2093020
 FAIL ‡≤†_‡≤†
The root cause of the bug seems to exist in ringbufferindex, that can be resolved by PR/#2046.  With the changes from PR/#2046, the test passes.
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: .............................. OK
$ tail 01-cooja-flush-nbr-queue.testlog
1549000 node-1 TSCH-queue: packet is added put_index=0, packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe1fcf6d800 1 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue:! flushing packet
1549000 node-1 TSCH-queue: packet is deleted packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe1fcf6d620
1549000 node-1 =check-me= SUCCEEDED - flush_nbr_queue() should delete all the packet in the queue
1550000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 2161020
Because of the bug in ringbufferindex, some problem could arise if an index returned by ringbufferindex_get() is used meaningfully. In this case, tsch_queue_remove_packet_from_queue(), that is called by tsch_queue_flush_nbr_queue(), returns the pointer of a tsch_packet which is retrieved by such an index. The tsch_packet is NOT what is expected to be removed or freed.
 286 struct tsch_packet *
 287 tsch_queue_remove_packet_from_queue(struct tsch_neighbor *n)
 288 {
 289   if(!tsch_is_locked()) {
 290     if(n != NULL) {
 291       /* Get and remove packet from ringbuf (remove committed through an atomic operation */
 292       int16_t get_index = ringbufindex_get(&n->tx_ringbuf);
 293       if(get_index != -1) {
 294         PRINTF(""TSCH-queue: packet is removed, get_index=%u\n"", get_index);
 295         return n->tx_array[get_index];
tsch_queue_flush_nbr_queue() frees the memory pointed by p returned from tsch_queue_remove_packet_from_queue(). Again, p does NOT point to the memory that we want to free. When p is NULL, tsch_queue_free_packet(p) is not called. This leads to memory leak.
 191 static void
 192 tsch_queue_flush_nbr_queue(struct tsch_neighbor *n)
 193 {
 194   while(!tsch_queue_is_empty(n)) {
 195     struct tsch_packet *p = tsch_queue_remove_packet_from_queue(n);
 196     if(p != NULL) {
 197       /* Set return status for packet_sent callback */
 198       p->ret = MAC_TX_ERR;
 199       PRINTF(""TSCH-queue:! flushing packet\n"");
 200       /* Call packet_sent callback */
 201       mac_call_sent_callback(p->sent, p->ptr, p->ret, p->transmissions);
 202       /* Free packet queuebuf */
 203       tsch_queue_free_packet(p);
 204     }","This PR doesn't fix anything; just demonstrates a bug in tsch_queue_flush_nbr_queue(), which could be related to discussions in Issue/#1766 and Issue/#2105.
The test introduced by this PR does the following: Please note QUEUEBUF_CONF_NUM is set with 1.

add one packet by `tsch_queue_add_packet(); should succeed
add one more packet by `tsch_queue_add_packet(); should fail because of lack of memory
call tsch_queue_reset() to invoke tsch_queue_flush_nbr_queue()
add one packet by `tsch_queue_add_packet(); should succeed

You can find the test code in regression-tests/27-tsch/code/test-flush-nbr-queue.c.
Here is the result on the tip of the master branch:
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: ..................................Message:  CC        ../../../core/net/mac/nullmac.c
Message:  CC        ../../../core/net/mac/nullrdc-noframer.c
(snip)
../Makefile.simulation-test:60: recipe for target '01-cooja-flush-nbr-queue.testlog' failed
make: *** [01-cooja-flush-nbr-queue.testlog] Error 1
$ tail 01-cooja-flush-nbr-queue.1.faillog
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe588680620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue: packet is deleted packet=(nil)
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 =check-me= FAILED   - flush_nbr_queue() should delete all the packet in the queue: exit at L79
1550000 node-1 =check-me= DONE
TEST FAILED
Test ended at simulation time: 2093020
 FAIL ‡≤†_‡≤†
The root cause of the bug seems to exist in ringbufferindex, that can be resolved by PR/#2046.  With the changes from PR/#2046, the test passes.
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: .............................. OK
$ tail 01-cooja-flush-nbr-queue.testlog
1549000 node-1 TSCH-queue: packet is added put_index=0, packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe1fcf6d800 1 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue:! flushing packet
1549000 node-1 TSCH-queue: packet is deleted packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe1fcf6d620
1549000 node-1 =check-me= SUCCEEDED - flush_nbr_queue() should delete all the packet in the queue
1550000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 2161020
Because of the bug in ringbufferindex, some problem could arise if an index returned by ringbufferindex_get() is used meaningfully. In this case, tsch_queue_remove_packet_from_queue(), that is called by tsch_queue_flush_nbr_queue(), returns the pointer of a tsch_packet which is retrieved by such an index. The tsch_packet is NOT what is expected to be removed or freed.
 286 struct tsch_packet *
 287 tsch_queue_remove_packet_from_queue(struct tsch_neighbor *n)
 288 {
 289   if(!tsch_is_locked()) {
 290     if(n != NULL) {
 291       /* Get and remove packet from ringbuf (remove committed through an atomic operation */
 292       int16_t get_index = ringbufindex_get(&n->tx_ringbuf);
 293       if(get_index != -1) {
 294         PRINTF(""TSCH-queue: packet is removed, get_index=%u\n"", get_index);
 295         return n->tx_array[get_index];
tsch_queue_flush_nbr_queue() frees the memory pointed by p returned from tsch_queue_remove_packet_from_queue(). Again, p does NOT point to the memory that we want to free. When p is NULL, tsch_queue_free_packet(p) is not called. This leads to memory leak.
 191 static void
 192 tsch_queue_flush_nbr_queue(struct tsch_neighbor *n)
 193 {
 194   while(!tsch_queue_is_empty(n)) {
 195     struct tsch_packet *p = tsch_queue_remove_packet_from_queue(n);
 196     if(p != NULL) {
 197       /* Set return status for packet_sent callback */
 198       p->ret = MAC_TX_ERR;
 199       PRINTF(""TSCH-queue:! flushing packet\n"");
 200       /* Call packet_sent callback */
 201       mac_call_sent_callback(p->sent, p->ptr, p->ret, p->transmissions);
 202       /* Free packet queuebuf */
 203       tsch_queue_free_packet(p);
 204     }",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2108,2017-02-10T16:33:41Z,2017-03-08T09:18:42Z,2020-07-29T01:14:18Z,MERGED,True,451,0,9,https://github.com/yatch,TSCH: POC of a bug in tsch_queue_flush_nbr_queue(),2,[],https://github.com/contiki-os/contiki/pull/2108,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2108#issuecomment-284989033,"This PR doesn't fix anything; just demonstrates a bug in tsch_queue_flush_nbr_queue(), which could be related to discussions in Issue/#1766 and Issue/#2105.
The test introduced by this PR does the following: Please note QUEUEBUF_CONF_NUM is set with 1.

add one packet by `tsch_queue_add_packet(); should succeed
add one more packet by `tsch_queue_add_packet(); should fail because of lack of memory
call tsch_queue_reset() to invoke tsch_queue_flush_nbr_queue()
add one packet by `tsch_queue_add_packet(); should succeed

You can find the test code in regression-tests/27-tsch/code/test-flush-nbr-queue.c.
Here is the result on the tip of the master branch:
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: ..................................Message:  CC        ../../../core/net/mac/nullmac.c
Message:  CC        ../../../core/net/mac/nullrdc-noframer.c
(snip)
../Makefile.simulation-test:60: recipe for target '01-cooja-flush-nbr-queue.testlog' failed
make: *** [01-cooja-flush-nbr-queue.testlog] Error 1
$ tail 01-cooja-flush-nbr-queue.1.faillog
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe588680620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue: packet is deleted packet=(nil)
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 =check-me= FAILED   - flush_nbr_queue() should delete all the packet in the queue: exit at L79
1550000 node-1 =check-me= DONE
TEST FAILED
Test ended at simulation time: 2093020
 FAIL ‡≤†_‡≤†
The root cause of the bug seems to exist in ringbufferindex, that can be resolved by PR/#2046.  With the changes from PR/#2046, the test passes.
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: .............................. OK
$ tail 01-cooja-flush-nbr-queue.testlog
1549000 node-1 TSCH-queue: packet is added put_index=0, packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe1fcf6d800 1 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue:! flushing packet
1549000 node-1 TSCH-queue: packet is deleted packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe1fcf6d620
1549000 node-1 =check-me= SUCCEEDED - flush_nbr_queue() should delete all the packet in the queue
1550000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 2161020
Because of the bug in ringbufferindex, some problem could arise if an index returned by ringbufferindex_get() is used meaningfully. In this case, tsch_queue_remove_packet_from_queue(), that is called by tsch_queue_flush_nbr_queue(), returns the pointer of a tsch_packet which is retrieved by such an index. The tsch_packet is NOT what is expected to be removed or freed.
 286 struct tsch_packet *
 287 tsch_queue_remove_packet_from_queue(struct tsch_neighbor *n)
 288 {
 289   if(!tsch_is_locked()) {
 290     if(n != NULL) {
 291       /* Get and remove packet from ringbuf (remove committed through an atomic operation */
 292       int16_t get_index = ringbufindex_get(&n->tx_ringbuf);
 293       if(get_index != -1) {
 294         PRINTF(""TSCH-queue: packet is removed, get_index=%u\n"", get_index);
 295         return n->tx_array[get_index];
tsch_queue_flush_nbr_queue() frees the memory pointed by p returned from tsch_queue_remove_packet_from_queue(). Again, p does NOT point to the memory that we want to free. When p is NULL, tsch_queue_free_packet(p) is not called. This leads to memory leak.
 191 static void
 192 tsch_queue_flush_nbr_queue(struct tsch_neighbor *n)
 193 {
 194   while(!tsch_queue_is_empty(n)) {
 195     struct tsch_packet *p = tsch_queue_remove_packet_from_queue(n);
 196     if(p != NULL) {
 197       /* Set return status for packet_sent callback */
 198       p->ret = MAC_TX_ERR;
 199       PRINTF(""TSCH-queue:! flushing packet\n"");
 200       /* Call packet_sent callback */
 201       mac_call_sent_callback(p->sent, p->ptr, p->ret, p->transmissions);
 202       /* Free packet queuebuf */
 203       tsch_queue_free_packet(p);
 204     }","Great, thanks so much for your rigorous development practices üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2108,2017-02-10T16:33:41Z,2017-03-08T09:18:42Z,2020-07-29T01:14:18Z,MERGED,True,451,0,9,https://github.com/yatch,TSCH: POC of a bug in tsch_queue_flush_nbr_queue(),2,[],https://github.com/contiki-os/contiki/pull/2108,https://github.com/garyJune,3,https://github.com/contiki-os/contiki/pull/2108#issuecomment-665374189,"This PR doesn't fix anything; just demonstrates a bug in tsch_queue_flush_nbr_queue(), which could be related to discussions in Issue/#1766 and Issue/#2105.
The test introduced by this PR does the following: Please note QUEUEBUF_CONF_NUM is set with 1.

add one packet by `tsch_queue_add_packet(); should succeed
add one more packet by `tsch_queue_add_packet(); should fail because of lack of memory
call tsch_queue_reset() to invoke tsch_queue_flush_nbr_queue()
add one packet by `tsch_queue_add_packet(); should succeed

You can find the test code in regression-tests/27-tsch/code/test-flush-nbr-queue.c.
Here is the result on the tip of the master branch:
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: ..................................Message:  CC        ../../../core/net/mac/nullmac.c
Message:  CC        ../../../core/net/mac/nullrdc-noframer.c
(snip)
../Makefile.simulation-test:60: recipe for target '01-cooja-flush-nbr-queue.testlog' failed
make: *** [01-cooja-flush-nbr-queue.testlog] Error 1
$ tail 01-cooja-flush-nbr-queue.1.faillog
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe588680620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue: packet is deleted packet=(nil)
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe588680800 2 (nil) (nil)
1549000 node-1 =check-me= FAILED   - flush_nbr_queue() should delete all the packet in the queue: exit at L79
1550000 node-1 =check-me= DONE
TEST FAILED
Test ended at simulation time: 2093020
 FAIL ‡≤†_‡≤†
The root cause of the bug seems to exist in ringbufferindex, that can be resolved by PR/#2046.  With the changes from PR/#2046, the test passes.
$ make 01-cooja-flush-nbr-queue.testlog
Running test 01-cooja-flush-nbr-queue with random Seed 1: .............................. OK
$ tail 01-cooja-flush-nbr-queue.testlog
1549000 node-1 TSCH-queue: packet is added put_index=0, packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue:! add packet failed: 0 0x7fe1fcf6d800 1 (nil) (nil)
1549000 node-1 TSCH-queue: packet is removed, get_index=0
1549000 node-1 TSCH-queue:! flushing packet
1549000 node-1 TSCH-queue: packet is deleted packet=0x7fe1fcf6d620
1549000 node-1 TSCH-queue: packet is added put_index=1, packet=0x7fe1fcf6d620
1549000 node-1 =check-me= SUCCEEDED - flush_nbr_queue() should delete all the packet in the queue
1550000 node-1 =check-me= DONE
TEST OK
Test ended at simulation time: 2161020
Because of the bug in ringbufferindex, some problem could arise if an index returned by ringbufferindex_get() is used meaningfully. In this case, tsch_queue_remove_packet_from_queue(), that is called by tsch_queue_flush_nbr_queue(), returns the pointer of a tsch_packet which is retrieved by such an index. The tsch_packet is NOT what is expected to be removed or freed.
 286 struct tsch_packet *
 287 tsch_queue_remove_packet_from_queue(struct tsch_neighbor *n)
 288 {
 289   if(!tsch_is_locked()) {
 290     if(n != NULL) {
 291       /* Get and remove packet from ringbuf (remove committed through an atomic operation */
 292       int16_t get_index = ringbufindex_get(&n->tx_ringbuf);
 293       if(get_index != -1) {
 294         PRINTF(""TSCH-queue: packet is removed, get_index=%u\n"", get_index);
 295         return n->tx_array[get_index];
tsch_queue_flush_nbr_queue() frees the memory pointed by p returned from tsch_queue_remove_packet_from_queue(). Again, p does NOT point to the memory that we want to free. When p is NULL, tsch_queue_free_packet(p) is not called. This leads to memory leak.
 191 static void
 192 tsch_queue_flush_nbr_queue(struct tsch_neighbor *n)
 193 {
 194   while(!tsch_queue_is_empty(n)) {
 195     struct tsch_packet *p = tsch_queue_remove_packet_from_queue(n);
 196     if(p != NULL) {
 197       /* Set return status for packet_sent callback */
 198       p->ret = MAC_TX_ERR;
 199       PRINTF(""TSCH-queue:! flushing packet\n"");
 200       /* Call packet_sent callback */
 201       mac_call_sent_callback(p->sent, p->ptr, p->ret, p->transmissions);
 202       /* Free packet queuebuf */
 203       tsch_queue_free_packet(p);
 204     }","Hello,
I ran into a similar issue when conducting a TSCH + UDP experiment, following is the log:
365239000 TSCH-queue: packet is added put_index=2, packet=0x65ebbdb0
365239000 TSCH: send packet to 7 with seqno 53, queue 1 2, len 21 107
366236000 TSCH-queue:! add packet failed: 0 0x65ebbe58 9 (nil) (nil)
366236000 TSCH:! can't send packet to 255 with seqno 53, queue 0 0
I have changed QUEUEBUF_CONF_NUM to 32 as advised in #2105 ,  is there other configuration that might cause the issue?
Thank you",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,1,https://github.com/contiki-os/contiki/pull/2109,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/tonnenpinguin,2,https://github.com/contiki-os/contiki/pull/2109#issuecomment-279673682,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Looks a lot better now :)
Please also have a look at the code formatting guidelines .
I've noticed you are using tabs for intendation at some places",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,3,https://github.com/contiki-os/contiki/pull/2109#issuecomment-279720893,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,Just use uncrustify-fix-style.sh to format the changed files and commit again.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,4,https://github.com/contiki-os/contiki/pull/2109#issuecomment-280197978,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,Revise my code according to greg's suggestions and commit it.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,5,https://github.com/contiki-os/contiki/pull/2109#issuecomment-280235508,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,I have no idea about fixing this CI build failed. Can anyone help?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/tonnenpinguin,6,https://github.com/contiki-os/contiki/pull/2109#issuecomment-280337360,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"If you address @arurke's comments (use ti_lib_[...] for all calls, change unit conversion code) I guess we're good!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,7,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287549819,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@chenek thank you for this useful contribution. Quick question: The web demo is meant to work off-the-shelf for launchpad, Srf+EM, SensorTag. For which of those boards will the ADC feature work? Presumably none of them because there is nothing connected to DIO23? I am thinking we should default to disabled?
Also, when disabled, there are various parts of the code that should be defined out. I'm working on a commit on top of your branch.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/arurke,8,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287550475,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"I just noticed, would it make more sense to use the adc_sensor from https://github.com/contiki-os/contiki/blob/master/cpu/cc26xx-cc13xx/dev/adc-sensor.c ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,9,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287550616,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,Now that's somewhat of a valid comment!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,10,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287550969,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"My code works on launchpad, Srf+EM and SensorTag. If you input a voltage to DIO23, it would get the reading.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,11,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287551144,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Thanks @chenek , exactly my point: One has to first connect something external for this to do anything. Hence my recommendation to disable by default.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,12,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287551746,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Sure, I agree with your point!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,13,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287552425,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,I'll merge this when travis passes. We can switch to using the ADC sensor driver under cpu/ at a later stage. Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,14,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287553545,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Thinking about this a bit more, perhaps we also want to integrate the Srf ALS into this demo at some point: also uses ADC.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/arurke,15,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287554643,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"if so, you might want to review my comment from Feb 15 on the conversion: Using the TI libs to get mV (and increased accuracy), instead of magic numbering",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,16,https://github.com/contiki-os/contiki/pull/2109#issuecomment-287560195,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@arurke Andreas, you are talking about something like #2131, right?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,17,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290954686,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@chenek where are we on this one? I contributed a couple of commits on top of your pull the other day and you accepted them, but I can no longer see them included here?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,18,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290958323,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,@g-oikonomou I did merge your code but Jenkins generate build error. I do some revision and comit agin to fix Jenkins build problem. I am not familiar with this process so can you check again and advise what I can help to move forward?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,19,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290983458,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"I made a mistake in a define in my commits, but you seemed to have committed a fix on top of that and that seemed fine to me. It must be some subsequent rebase that caused them to disappear.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,20,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290984794,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,I have pushed contrib/web-demo-adc. This basically puts my changes back in the pull and tidies up history. If you set your cc26xx-web-demo-adc-demo branch to point to my contrib/web-demo-adc and push it to your repo we should be good to go.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,21,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290985811,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,@g-oikonomou I am sorry that I have no idea how to do this. Can you elaborate so I can know how to do it?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,22,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290986170,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Something like this should do it
git remote add george https://github.com/g-oikonomou/contiki.git
git fetch george
git checkout cc26xx-web-demo-adc-demo
git branch some-branch-name-in-case-things-go-wrong
git reset --hard george/contrib/web-demo-adc
git push -f cc26xx-web-demo-adc-demo <the name of chenek/contiki>",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,23,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290990759,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"When I do ""git checkout cc26xx-web-demo-adc-demo"", I get ""error: pathspec 'cc26xx-web-demo-adc-demo' did not match any file(s) known to git."" What should I do?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,24,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290991043,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@g-oikonomou Should I use ""git checkout web-demo-adc"" instead of ""git checkout cc26xx-web-demo-adc-demo""?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,25,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290992591,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"You should checkout the branch that you used to create the pull request. On your github I can see this branch: https://github.com/chenek/contiki/tree/cc26xx-web-demo-adc-demo hence my saying to checkout cc26xx-web-demo-adc-demo.
You didn't clone from scratch did you? You are still using the local copy that you used to create the pull, right?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,26,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290993084,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@g-oikonomou Yes, I still have local copy. I tried to do ""git checkout https://github.com/chenek/contiki/tree/cc26xx-web-demo-adc-demo"" but still get ""error: pathspec 'https://github.com/chenek/contiki/tree/cc26xx-web-demo-adc-demo' did not match any file(s) known to git.""",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,27,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290993577,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Do you still have your original pull request's branch in your local copy?
I cannot think of any reasons why git checkout cc26xx-web-demo-adc-demo fails other than the branch having been deleted or renamed.
git branch will show you local branches, and the branch you used to open the pull should exist there somewhere. git branch -a will also show you locally cached branches for every remote that you have fetched.
There is no point in trying to checkout random strings until something works ;)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,28,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290994296,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@g-oikonomou I am sorry that I run it with wrong folder. Now, I can go to last step ""git push -f cc26xx-web-demo-adc-demo <the name of chenek/contiki>"" if I use correct one. I am afraid I mess up anything so can you specify what I should put in <the name of chenek/contiki> of ""git push -f cc26xx-web-demo-adc-demo <the name of chenek/contiki>""",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,29,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290994957,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Firstly, sorry, it should be
git push -f <the name of chenek/contiki> cc26xx-web-demo-adc-demo
and not
git push -f cc26xx-web-demo-adc-demo <the name of chenek/contiki>
(I wrote the name of the remote and the branch in the wrong order).
Every remote has a local friendly name. You can see those by doing git remote -v show. This is specific to your local setup, I cannot know what it is. For example, mine is:
$ git remote -v show
geo-devel       git@github.com:g-oikonomou/contiki.git (fetch)
geo-devel       git@github.com:g-oikonomou/contiki.git (push)
[...more]
upstream        https://github.com/contiki-os/contiki.git (fetch)
upstream        https://github.com/contiki-os/contiki.git (push)

Therefore, if I want to push a branch to g-oikonomou/contiki, I will git push geo-devel <branch name>. I am guessing that in your local setup chenek/contiki will be called origin, in which case you would want to git push -f origin cc26xx-web-demo-adc-demo.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,30,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290995022,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"I am guessing that in your local setup chenek/contiki will be called origin, in which case you would want to git push -f origin cc26xx-web-demo-adc-demo.

But I cannot be certain obviously for the reasons above, so you should check first.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,31,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290995688,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"@g-oikonomou I do ""git remote -v show"" and get the followings:
george	https://github.com/g-oikonomou/contiki.git (fetch)
george	https://github.com/g-oikonomou/contiki.git (push)
origin	https://github.com/chenek/contiki/ (fetch)
origin	https://github.com/chenek/contiki/ (push)
Do you think it's OK to do ""git push -f origin cc26xx-web-demo-adc-demo""?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,32,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290995815,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"Yap, that's exactly what you want to do. Also, to double check what you are pushing is correct, this is what you should be seeing:
$ git log --oneline -4
e823ead Tidy up web demo ADC code style
474dc33 Wrap web demo ADC functionality inside #if blocks
22b262c Add ADC example to cc26xx-web-demo
55f3a92 Merge pull request #2168 from tarakanov/sensortag-spi

That's our 3 commits on top of 55f3a92.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/chenek,33,https://github.com/contiki-os/contiki/pull/2109#issuecomment-290996126,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,"I have done git push and confirm git log --oneline -4
e823ead Tidy up web demo ADC code style
474dc33 Wrap web demo ADC functionality inside #if blocks
22b262c Add ADC example to cc26xx-web-demo
55f3a92 Merge pull request #2168 from tarakanov/sensortag-spi",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2109,2017-02-13T08:51:32Z,2017-04-03T11:21:04Z,2017-04-03T11:21:04Z,MERGED,True,130,1,5,https://github.com/chenek,add ADC example to cc26xx-web-demo,3,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2109,https://github.com/g-oikonomou,34,https://github.com/contiki-os/contiki/pull/2109#issuecomment-291115328,Add ADC reading (from DIO23 pin on CC26xx/CC13xx) example to cc26xx-web-demo and connect it to COAP/MQTT.,Leaving the conversion handling and usage of the generic driver under cpu/ for a separate pull.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2116,2017-02-22T14:28:45Z,,2017-08-10T08:23:10Z,OPEN,False,197,142,11,https://github.com/Avinash95,cpu/pic32: Prepare for upcoming pic32 platform and cleanup,9,[],https://github.com/contiki-os/contiki/pull/2116,https://github.com/Avinash95,1,https://github.com/contiki-os/contiki/pull/2116,"Contiki currently has support for PIC32MX795F512L(PIC32 model), which is used by SEED EYE board.
We have extended this(cpu/pic32) module to support PIC32MX470F512H in order to support Mikro-e 6LoWPAN Clicker board.","Contiki currently has support for PIC32MX795F512L(PIC32 model), which is used by SEED EYE board.
We have extended this(cpu/pic32) module to support PIC32MX470F512H in order to support Mikro-e 6LoWPAN Clicker board.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2116,2017-02-22T14:28:45Z,,2017-08-10T08:23:10Z,OPEN,False,197,142,11,https://github.com/Avinash95,cpu/pic32: Prepare for upcoming pic32 platform and cleanup,9,[],https://github.com/contiki-os/contiki/pull/2116,https://github.com/evilaliv3,2,https://github.com/contiki-os/contiki/pull/2116#issuecomment-321485393,"Contiki currently has support for PIC32MX795F512L(PIC32 model), which is used by SEED EYE board.
We have extended this(cpu/pic32) module to support PIC32MX470F512H in order to support Mikro-e 6LoWPAN Clicker board.","@Avinash95 i'm sorry for not having reviewed this till now.
The pull request seems legit to me and more than correct.
do you confirm that your work is still functional?
@g-oikonomou @nvt maybe this addition could be of value for other users?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2118,2017-02-23T20:45:23Z,2017-02-24T19:53:56Z,2017-02-24T19:53:56Z,MERGED,True,2,0,1,https://github.com/oliverschmidt,Made rest of Microsoft-specific chat optional.,1,[],https://github.com/contiki-os/contiki/pull/2118,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2118,Made code rest of the code in the SLIP driver optional that takes care of the Microsoft-specific CLIENT / SERVER / CLIENTSERVER chat.,Made code rest of the code in the SLIP driver optional that takes care of the Microsoft-specific CLIENT / SERVER / CLIENTSERVER chat.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2129,2017-03-08T10:24:55Z,2017-03-08T14:20:32Z,2017-10-27T20:04:47Z,MERGED,True,1,3,2,https://github.com/simonduq,jn516x: update SDK,2,[],https://github.com/contiki-os/contiki/pull/2129,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/2129,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2131,2017-03-08T13:58:12Z,2017-03-08T22:18:58Z,2017-03-08T22:18:58Z,MERGED,True,7,3,1,https://github.com/t-than,Adjust CC26xx/CC13xx ADC reading for gain and offset,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2131,https://github.com/t-than,1,https://github.com/contiki-os/contiki/pull/2131,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2131,2017-03-08T13:58:12Z,2017-03-08T22:18:58Z,2017-03-08T22:18:58Z,MERGED,True,7,3,1,https://github.com/t-than,Adjust CC26xx/CC13xx ADC reading for gain and offset,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2131,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2131#issuecomment-285052945,,"This looks reasonable, thanks.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2131,2017-03-08T13:58:12Z,2017-03-08T22:18:58Z,2017-03-08T22:18:58Z,MERGED,True,7,3,1,https://github.com/t-than,Adjust CC26xx/CC13xx ADC reading for gain and offset,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2131,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/2131#issuecomment-285053390,,Do you think you could put the code through uncrustify?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2131,2017-03-08T13:58:12Z,2017-03-08T22:18:58Z,2017-03-08T22:18:58Z,MERGED,True,7,3,1,https://github.com/t-than,Adjust CC26xx/CC13xx ADC reading for gain and offset,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2131,https://github.com/t-than,4,https://github.com/contiki-os/contiki/pull/2131#issuecomment-285060097,,"I haven't done it before, but I am more than willing to try.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2131,2017-03-08T13:58:12Z,2017-03-08T22:18:58Z,2017-03-08T22:18:58Z,MERGED,True,7,3,1,https://github.com/t-than,Adjust CC26xx/CC13xx ADC reading for gain and offset,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2131,https://github.com/g-oikonomou,5,https://github.com/contiki-os/contiki/pull/2131#issuecomment-285060431,,"https://github.com/contiki-os/contiki/wiki/Code-Contributions#code-formatting
Just push -f using the same branch when you are ready.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2131,2017-03-08T13:58:12Z,2017-03-08T22:18:58Z,2017-03-08T22:18:58Z,MERGED,True,7,3,1,https://github.com/t-than,Adjust CC26xx/CC13xx ADC reading for gain and offset,2,"['enhancement', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2131,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/2131#issuecomment-285188150,,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/JoaoS,1,https://github.com/contiki-os/contiki/pull/2132,"This platform did not have the Energest functions to measure CPU rticks, so they were added.","This platform did not have the Energest functions to measure CPU rticks, so they were added.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2132#issuecomment-285188489,"This platform did not have the Energest functions to measure CPU rticks, so they were added.",@herjulf Robert any thoughts here?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/herjulf,3,https://github.com/contiki-os/contiki/pull/2132#issuecomment-285338326,"This platform did not have the Energest functions to measure CPU rticks, so they were added.","Hello. Thanks.
Yes It seems to missing. energest_init() could have a better place in the initialize() function where we keep initializations.
Joao is testing a new rtimer arch. I think?
Cheers",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/JoaoS,4,https://github.com/contiki-os/contiki/pull/2132#issuecomment-285340643,"This platform did not have the Energest functions to measure CPU rticks, so they were added.","The place where energest_init() is located could be inside the initialize because it is just initializing arrays to zero.
No i am not testing a new rtimer, i am however testing placements to update the Energest CPU values when sleep mode is inactive",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/herjulf,5,https://github.com/contiki-os/contiki/pull/2132#issuecomment-285657511,"This platform did not have the Energest functions to measure CPU rticks, so they were added.","Please put energest_init() in initialize() directly,
Well I got the impression that you had problems with the timers on your Atmel board.
Cheers",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/herjulf,6,https://github.com/contiki-os/contiki/pull/2132#issuecomment-286213140,"This platform did not have the Energest functions to measure CPU rticks, so they were added.",Thanks. I'm fine that.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/JoaoS,7,https://github.com/contiki-os/contiki/pull/2132#issuecomment-286459476,"This platform did not have the Energest functions to measure CPU rticks, so they were added.","I thought my issue was with the rtimer, however i found the problem should rather be related with energest, i have ran it 25 times during 1 hour tests and get a drift of 3.77% in the expected number of rticks",True,{'THUMBS_UP': ['https://github.com/herjulf']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/g-oikonomou,8,https://github.com/contiki-os/contiki/pull/2132#issuecomment-287498397,"This platform did not have the Energest functions to measure CPU rticks, so they were added.",Are we happy to merge this one folks?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2132,2017-03-08T16:15:47Z,2017-03-18T13:17:51Z,2017-03-18T13:17:51Z,MERGED,True,8,0,1,https://github.com/JoaoS,add CPU energest measurements that were lacking in this platform,2,[],https://github.com/contiki-os/contiki/pull/2132,https://github.com/herjulf,9,https://github.com/contiki-os/contiki/pull/2132#issuecomment-287531551,"This platform did not have the Energest functions to measure CPU rticks, so they were added.",Yes. Thanks.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2138,2017-03-14T19:48:02Z,2017-03-17T23:09:11Z,2017-03-17T23:09:11Z,MERGED,True,58,25,2,https://github.com/atiselsts,CC26xx IEEE mode driver fixes and robustness improvements,3,[],https://github.com/contiki-os/contiki/pull/2138,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2138,"This patch add a fix for the radio driver that limits the time it spends in busywaiting operations. At the moment it can lock up in case turning off the radio Rx mode fails, leading to a reboot of the system.
The patch also makes the radio timer (RAT) handling more robust.
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","This patch add a fix for the radio driver that limits the time it spends in busywaiting operations. At the moment it can lock up in case turning off the radio Rx mode fails, leading to a reboot of the system.
The patch also makes the radio timer (RAT) handling more robust.
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2138,2017-03-14T19:48:02Z,2017-03-17T23:09:11Z,2017-03-17T23:09:11Z,MERGED,True,58,25,2,https://github.com/atiselsts,CC26xx IEEE mode driver fixes and robustness improvements,3,[],https://github.com/contiki-os/contiki/pull/2138,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2138#issuecomment-287492896,"This patch add a fix for the radio driver that limits the time it spends in busywaiting operations. At the moment it can lock up in case turning off the radio Rx mode fails, leading to a reboot of the system.
The patch also makes the radio timer (RAT) handling more robust.
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2139,2017-03-14T19:50:27Z,2017-03-17T23:04:19Z,2017-03-17T23:04:19Z,MERGED,True,30,17,1,https://github.com/atiselsts,CC26xx SensorTag I2C: add and use LIMITED_BUSYWAIT macro,1,[],https://github.com/contiki-os/contiki/pull/2139,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2139,"This limits the busywaiting time of the SensorTag I2C driver as a robustness improvements. We have not experienced any problems with SensorTag as such; however, on a custom platform that does not have all the SensorTag sensors attached the code would occasionally lock up when trying to read a non-attached sensor, leading to a system reboot.
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","This limits the busywaiting time of the SensorTag I2C driver as a robustness improvements. We have not experienced any problems with SensorTag as such; however, on a custom platform that does not have all the SensorTag sensors attached the code would occasionally lock up when trying to read a non-attached sensor, leading to a system reboot.
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2139,2017-03-14T19:50:27Z,2017-03-17T23:04:19Z,2017-03-17T23:04:19Z,MERGED,True,30,17,1,https://github.com/atiselsts,CC26xx SensorTag I2C: add and use LIMITED_BUSYWAIT macro,1,[],https://github.com/contiki-os/contiki/pull/2139,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2139#issuecomment-287492191,"This limits the busywaiting time of the SensorTag I2C driver as a robustness improvements. We have not experienced any problems with SensorTag as such; however, on a custom platform that does not have all the SensorTag sensors attached the code would occasionally lock up when trying to read a non-attached sensor, leading to a system reboot.
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2140,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/simonduq,2,https://github.com/contiki-os/contiki/pull/2140#issuecomment-286702394,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","Hmm, I have seen something similar, I wonder if that was the same issue or not. I think the problem was when skipping a slot (lock or non-active slot), we would directly try and schedule the next slot, although we had not even reached the real start of the current timeslot (we'd be 1 or 2 ticks before, but now looking at tsch_schedule_slot_operation I'm no longer sure why this was the case).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/2140#issuecomment-286703583,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","Now about the fix: I'm worried that in cases we really did miss the deadline (e.g. join, or any slot operation that took too long), we'll end up busy-waiting (wait for a rtimer wrap)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/atiselsts,4,https://github.com/contiki-os/contiki/pull/2140#issuecomment-286709256,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","@simonduq that sounds like another thing that would trigger the same behavior: the bug here is triggered because it looks like check_timer_miss() only works correctly if the reference time is not in the future. If there are any doubts anywhere that it might happen, may be better to add something like if(!RTIMER_CLOCK_LT(RTIMER_NOW(), ref_time + RTIMER_GUARD)) condition in the calling code?
(As a side note, I feel that this sort of thing, the core operation of TSCH, is crying for a randomized brute force testing...)

I'm worried that in cases we really did miss the deadline (e.g. join, or any slot operation that took too long), we'll end up busy-waiting (wait for a rtimer wrap)

The waiting will happen while RTIMER_CLOCK_LT(RTIMER_NOW(), (t0) + (offset) returns true. So if the waiting is started more than half the rtimer period in the future (1 second of the 2 period on msp430) then indeed it will wait for the wraparound. However, if this huge delay ever happens it just means that there's another bug somewhere and the system is already broken :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/simonduq,5,https://github.com/contiki-os/contiki/pull/2140#issuecomment-286712308,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","(As a side note, I feel that this sort of thing, the core operation of TSCH, is crying for a randomized brute force testing...)

I love the idea :)

However, if this huge delay ever happens it just means that there's another bug somewhere and the system is already broken :)

Right, but the problem remains whenever tsch_schedule_slot_operation is called directly. For instance when joining, we often have a few deadline missed.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/atiselsts,6,https://github.com/contiki-os/contiki/pull/2140#issuecomment-286723218,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","I think it's a reasonable assumption to make that the scheduling will not be missed by more than 1 second, even on msp430.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2140,2017-03-14T19:59:44Z,,2017-03-15T14:36:41Z,OPEN,False,10,10,1,https://github.com/atiselsts,TSCH: fix a bug in slot scheduling,1,[],https://github.com/contiki-os/contiki/pull/2140,https://github.com/simonduq,7,https://github.com/contiki-os/contiki/pull/2140#issuecomment-286761044,"The scheduling of a new TSCH timeslot at the end of tsch_slot_operation() will enter a count-to-infinity loop if called less or equal-to RTIMER_GUARD ticks before the start of the next TSCH timeslot (i.e. 1 or 2 ticks on most platforms on which RTIMER_GUARD==2). This patch fixes this behavior by busywaiting until the start of the next slot in that case.
In order to avoid double busywaiting, the busywait code is now executed in TSCH_SCHEDULE_AND_YIELD if and only if it was not done in tsch_schedule_slot_operation().
This code was developed as part of the SPHERE project (http://irc-sphere.ac.uk/)","Right, I agree. üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2144,2017-03-17T18:22:13Z,2017-03-17T22:19:50Z,2017-03-17T22:19:50Z,MERGED,True,1,1,1,https://github.com/MohamedSeliem,"fix a macro related to multicast, which are not user configuration",1,[],https://github.com/contiki-os/contiki/pull/2144,https://github.com/MohamedSeliem,1,https://github.com/contiki-os/contiki/pull/2144,"fix a macro related to multicast, which are not user configuration

RPL_CONF_MULTICAST      -> RPL_WITH_MULTICAST","fix a macro related to multicast, which are not user configuration

RPL_CONF_MULTICAST      -> RPL_WITH_MULTICAST",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2145,2017-03-17T22:43:05Z,2017-03-23T12:43:09Z,2017-04-02T12:47:16Z,MERGED,True,0,7,1,https://github.com/g-oikonomou,Don't force RPL MOP configuration in contiki-default-conf.h,1,"['bug', 'Core', 'RPL']",https://github.com/contiki-os/contiki/pull/2145,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/2145,"We are trying to set the default MOP in two places:

rpl-private.h: Considers multicast engine selection and correctly allows MOP to be set to 3 when required.
contiki-default-conf.h is not only redundant but also fails to handle situations where RPL multicast is required.

When selecting a multicast engine that requires RPL to be in MOP 3, compilation fails with the error shown in #2143.
This pull simply removes RPL MOP-related configuration from contiki-default-conf.h and allows user-provided configuration to take care of things, with rpl-private.h setting correct defaults if required.
Fixes #2143","We are trying to set the default MOP in two places:

rpl-private.h: Considers multicast engine selection and correctly allows MOP to be set to 3 when required.
contiki-default-conf.h is not only redundant but also fails to handle situations where RPL multicast is required.

When selecting a multicast engine that requires RPL to be in MOP 3, compilation fails with the error shown in #2143.
This pull simply removes RPL MOP-related configuration from contiki-default-conf.h and allows user-provided configuration to take care of things, with rpl-private.h setting correct defaults if required.
Fixes #2143",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2145,2017-03-17T22:43:05Z,2017-03-23T12:43:09Z,2017-04-02T12:47:16Z,MERGED,True,0,7,1,https://github.com/g-oikonomou,Don't force RPL MOP configuration in contiki-default-conf.h,1,"['bug', 'Core', 'RPL']",https://github.com/contiki-os/contiki/pull/2145,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2145#issuecomment-288706739,"We are trying to set the default MOP in two places:

rpl-private.h: Considers multicast engine selection and correctly allows MOP to be set to 3 when required.
contiki-default-conf.h is not only redundant but also fails to handle situations where RPL multicast is required.

When selecting a multicast engine that requires RPL to be in MOP 3, compilation fails with the error shown in #2143.
This pull simply removes RPL MOP-related configuration from contiki-default-conf.h and allows user-provided configuration to take care of things, with rpl-private.h setting correct defaults if required.
Fixes #2143",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2146,2017-03-18T13:21:50Z,2017-03-18T14:56:07Z,2017-03-20T11:59:46Z,MERGED,True,611,268,27,https://github.com/oliverschmidt,Add SLIP support to retro platforms.,4,[],https://github.com/contiki-os/contiki/pull/2146,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2146,"The cc65 tool chain comes with V.24 drivers so it seems reasonable to use the existing Contiki SLIP driver to implement network access via SLIP as alternative to Ethernet.
Some notes:

The Ethernet configuration was simplified in order to allow share it with SLIP.
The Contiki SLIP driver presumes an interrupt driven serial receiver to write into the SLIP buffer. However the cc65 V.24 drivers aren't up to that. Therefore the main loops were extended to pull received data from the V.24 buffers and push it into the SLIP buffer.
As far as I understand the serial sender is supposed to block until the data is sent. Therefore a loop calls the non-blocking V.24 driver until the data is sent.

On all platforms there's only one V.24 driver available. Therefore V.24 drivers are always loaded statically.
On the Apple][ the mouse driver is now loaded statically - independently from SLIP vs. Ethernet. After all there's only one mouse driver available. However there's a major benefit with SLIP: Here all drivers are loaded statically. Therefore the dynamic module loader isn't necessary at all. And without the loader the heap manager isn't necessary at all. This allows for a reduction in code size roughly compensating for the size of the SLIP buffer.","The cc65 tool chain comes with V.24 drivers so it seems reasonable to use the existing Contiki SLIP driver to implement network access via SLIP as alternative to Ethernet.
Some notes:

The Ethernet configuration was simplified in order to allow share it with SLIP.
The Contiki SLIP driver presumes an interrupt driven serial receiver to write into the SLIP buffer. However the cc65 V.24 drivers aren't up to that. Therefore the main loops were extended to pull received data from the V.24 buffers and push it into the SLIP buffer.
As far as I understand the serial sender is supposed to block until the data is sent. Therefore a loop calls the non-blocking V.24 driver until the data is sent.

On all platforms there's only one V.24 driver available. Therefore V.24 drivers are always loaded statically.
On the Apple][ the mouse driver is now loaded statically - independently from SLIP vs. Ethernet. After all there's only one mouse driver available. However there's a major benefit with SLIP: Here all drivers are loaded statically. Therefore the dynamic module loader isn't necessary at all. And without the loader the heap manager isn't necessary at all. This allows for a reduction in code size roughly compensating for the size of the SLIP buffer.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2147,2017-03-18T14:03:21Z,2017-03-18T17:23:41Z,2017-03-18T17:23:47Z,MERGED,True,3,2,1,https://github.com/g-oikonomou,Add missing variable declaration,1,['bug'],https://github.com/contiki-os/contiki/pull/2147,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/2147,#1972 removed the declaration of i from various locations. In one of those locations it is still needed. This commit puts it back.,#1972 removed the declaration of i from various locations. In one of those locations it is still needed. This commit puts it back.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2148,2017-03-21T12:24:05Z,2017-04-18T13:19:58Z,2017-04-18T13:19:58Z,MERGED,True,2,0,1,https://github.com/niziak,native-border-router: fix for disappearing timer 'uip_ds6_timer_perio‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/2148,https://github.com/niziak,1,https://github.com/contiki-os/contiki/pull/2148,"‚Ä¶dic'
When UIP_ND6_SEND_NS is enabled, I've noticed that unreachable
neighbours still remains in REACHABLE state even if lifetime
(nbr->reachable) expired.
During network init 'tcpip_process' is scheduling
'uip_ds6_timer_periodic' is to tick every 100ms and make necessary
expiration.
When MAC address is received from slip-radio (from 'etimer_process'
context), network is ""reinitialized"" and timer 'uip_ds6_timer_periodic'
is set again with wrong process.","‚Ä¶dic'
When UIP_ND6_SEND_NS is enabled, I've noticed that unreachable
neighbours still remains in REACHABLE state even if lifetime
(nbr->reachable) expired.
During network init 'tcpip_process' is scheduling
'uip_ds6_timer_periodic' is to tick every 100ms and make necessary
expiration.
When MAC address is received from slip-radio (from 'etimer_process'
context), network is ""reinitialized"" and timer 'uip_ds6_timer_periodic'
is set again with wrong process.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2148,2017-03-21T12:24:05Z,2017-04-18T13:19:58Z,2017-04-18T13:19:58Z,MERGED,True,2,0,1,https://github.com/niziak,native-border-router: fix for disappearing timer 'uip_ds6_timer_perio‚Ä¶,1,[],https://github.com/contiki-os/contiki/pull/2148,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2148#issuecomment-294840687,"‚Ä¶dic'
When UIP_ND6_SEND_NS is enabled, I've noticed that unreachable
neighbours still remains in REACHABLE state even if lifetime
(nbr->reachable) expired.
During network init 'tcpip_process' is scheduling
'uip_ds6_timer_periodic' is to tick every 100ms and make necessary
expiration.
When MAC address is received from slip-radio (from 'etimer_process'
context), network is ""reinitialized"" and timer 'uip_ds6_timer_periodic'
is set again with wrong process.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2149,2017-03-21T15:35:48Z,,2017-03-21T15:35:48Z,OPEN,False,7,0,1,https://github.com/herjulf,Adding RPL_CONF_ACCEPT_DEFAULT_INSTANCE_ONLY to filter DIO,1,[],https://github.com/contiki-os/contiki/pull/2149,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2149,"Config option to accept DIO's only from DEFAULT_INSTANCE
modified:   core/net/rpl/rpl-dag.c","Config option to accept DIO's only from DEFAULT_INSTANCE
modified:   core/net/rpl/rpl-dag.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2150,2017-03-21T15:51:45Z,2017-04-24T15:04:57Z,2017-04-24T15:04:57Z,MERGED,True,24,20,2,https://github.com/posjodin,Several changes to fix and harden mqtt code.,4,"['fix required: needs-rebase', 'MQTT']",https://github.com/contiki-os/contiki/pull/2150,https://github.com/posjodin,1,https://github.com/contiki-os/contiki/pull/2150,"The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.","The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2150,2017-03-21T15:51:45Z,2017-04-24T15:04:57Z,2017-04-24T15:04:57Z,MERGED,True,24,20,2,https://github.com/posjodin,Several changes to fix and harden mqtt code.,4,"['fix required: needs-rebase', 'MQTT']",https://github.com/contiki-os/contiki/pull/2150,https://github.com/herjulf,2,https://github.com/contiki-os/contiki/pull/2150#issuecomment-288129741,"The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.",Peter maybe you should also say that is patch has been used in the GreenIoT pilot for quite some time.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2150,2017-03-21T15:51:45Z,2017-04-24T15:04:57Z,2017-04-24T15:04:57Z,MERGED,True,24,20,2,https://github.com/posjodin,Several changes to fix and harden mqtt code.,4,"['fix required: needs-rebase', 'MQTT']",https://github.com/contiki-os/contiki/pull/2150,https://github.com/alexandruioanp,3,https://github.com/contiki-os/contiki/pull/2150#issuecomment-290745359,"The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.",This looks pretty reasonable to me.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2150,2017-03-21T15:51:45Z,2017-04-24T15:04:57Z,2017-04-24T15:04:57Z,MERGED,True,24,20,2,https://github.com/posjodin,Several changes to fix and harden mqtt code.,4,"['fix required: needs-rebase', 'MQTT']",https://github.com/contiki-os/contiki/pull/2150,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2150#issuecomment-290747102,"The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.","Thanks for the input @herjulf  and @alexandruioanp
@posjodin, I see you are indenting using tabs. Please put the modified files through uncrustify to fix the indentation (we use 2 spaces) and push again.
Let me know when it's done, I'm otherwise happy to merge this.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2150,2017-03-21T15:51:45Z,2017-04-24T15:04:57Z,2017-04-24T15:04:57Z,MERGED,True,24,20,2,https://github.com/posjodin,Several changes to fix and harden mqtt code.,4,"['fix required: needs-rebase', 'MQTT']",https://github.com/contiki-os/contiki/pull/2150,https://github.com/posjodin,5,https://github.com/contiki-os/contiki/pull/2150#issuecomment-293356978,"The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.","The tabs are gone now. Uncrustify changed other things as well, so I used emacs untabify instead.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2150,2017-03-21T15:51:45Z,2017-04-24T15:04:57Z,2017-04-24T15:04:57Z,MERGED,True,24,20,2,https://github.com/posjodin,Several changes to fix and harden mqtt code.,4,"['fix required: needs-rebase', 'MQTT']",https://github.com/contiki-os/contiki/pull/2150,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/2150#issuecomment-296697415,"The PT_MQTT_WAIT_SEND() macro has several issues:



It does not check the return value from process_post(), which
sometimes returns an error code. See next issue.


Each time the macro is called, is posts an event to itself. The idea
seems to be that the event should be absorbed by the macro itself, so
when the macro terminates there is NOT a net growth of the event
queue. This does not work.  The reason is that the
PROCESS_WAIT_EVENT() sometimes absorbs a broadcast event instead of
its own event, and then the number of events in the event queue
increases. This leads to event explosions and overflow in the event
queue.


The macro cannot call PT_EXIT(). This will expand to a return
statement, causing a return from the function calling the macro
(mqtt_process), rather then exiting the protothread (which was
probably the intention). Protothreads have lexical scope...


Fixes: 1) Check return value from process_post() 2) Loop until the
event posted to itself is absorbed (rather than just absorbing the
next event) 3) Replace PT_EXIT() with PT_INIT() (doesn't really make a
difference, could probably just be removed).


Change order of the checks in the protothread-calling loops in
mqtt_process().  Reason: When a protothread has been cleared by
PT_MQTT_WAIT_SEND(), it will not return a value, so checking against
PT_EXITED does not make sense.


PT_MQTT_WRITE_BYTES() should initialize conn->out_write_pos to 0.
When PT_MQTT_WRITE_BYTES() does not finish (due to TCP disconnect for
instance), it may leave conn->out_write_pos with a non-zero
value. Next time PT_MQTT_WRITE_BYTES() is called, it will take data
from the wrong place.


Put MQTT_CONN_STATE_ABORT_IMMEDIATE before
MQTT_CONN_STATE_NOT_CONNECTED in the enum list, so that the check
if(conn->state > MQTT_CONN_STATE_NOT_CONNECTED) in mqtt_connect()
fails when in state MQTT_CONN_STATE_ABORT_IMMEDIATE. Otherwise, it
will deadlock and not reattempt connections while in this state.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2153,2017-03-22T14:22:27Z,2017-03-22T16:06:31Z,2017-03-22T16:06:31Z,CLOSED,False,6851,23,34,https://github.com/Maxilicious,Pdr test,123,[],https://github.com/contiki-os/contiki/pull/2153,https://github.com/Maxilicious,1,https://github.com/contiki-os/contiki/pull/2153,Hej!,Hej!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2153,2017-03-22T14:22:27Z,2017-03-22T16:06:31Z,2017-03-22T16:06:31Z,CLOSED,False,6851,23,34,https://github.com/Maxilicious,Pdr test,123,[],https://github.com/contiki-os/contiki/pull/2153,https://github.com/herjulf,2,https://github.com/contiki-os/contiki/pull/2153#issuecomment-288445275,Hej!,"Max
I'll assume you've pressed the wrong buttons... IMO should close this PR,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2155,2017-03-23T14:18:36Z,2017-03-30T12:14:03Z,2017-04-11T09:37:01Z,MERGED,True,12,12,5,https://github.com/cladmi,er-coap: Fix style and add missing `addr` argument,2,[],https://github.com/contiki-os/contiki/pull/2155,https://github.com/cladmi,1,https://github.com/contiki-os/contiki/pull/2155,"Er-coap style cleanup (uncrustify-fix-style.sh).
I wanted to clean up the style before contributing new code (#1995).
I also added a missing attribute name in the header.","Er-coap style cleanup (uncrustify-fix-style.sh).
I wanted to clean up the style before contributing new code (#1995).
I also added a missing attribute name in the header.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2155,2017-03-23T14:18:36Z,2017-03-30T12:14:03Z,2017-04-11T09:37:01Z,MERGED,True,12,12,5,https://github.com/cladmi,er-coap: Fix style and add missing `addr` argument,2,[],https://github.com/contiki-os/contiki/pull/2155,https://github.com/cladmi,2,https://github.com/contiki-os/contiki/pull/2155#issuecomment-288959183,"Er-coap style cleanup (uncrustify-fix-style.sh).
I wanted to clean up the style before contributing new code (#1995).
I also added a missing attribute name in the header.",I think travis build broke for unrelated reasons.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2155,2017-03-23T14:18:36Z,2017-03-30T12:14:03Z,2017-04-11T09:37:01Z,MERGED,True,12,12,5,https://github.com/cladmi,er-coap: Fix style and add missing `addr` argument,2,[],https://github.com/contiki-os/contiki/pull/2155,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/2155#issuecomment-290392638,"Er-coap style cleanup (uncrustify-fix-style.sh).
I wanted to clean up the style before contributing new code (#1995).
I also added a missing attribute name in the header.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/cladmi,1,https://github.com/contiki-os/contiki/pull/2156,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.","Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/cladmi,2,https://github.com/contiki-os/contiki/pull/2156#issuecomment-288959197,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.",I think travis build broke for unrelated reasons.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/2156#issuecomment-290397499,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.",I restarted the Travis tests in case it was a transient problem.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/cladmi,4,https://github.com/contiki-os/contiki/pull/2156#issuecomment-290398816,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.","I currently added no license/author/doxygen informations.
If you like the changes this way I will add them. I preferred getting a review before taking time on it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/joakimeriksson,5,https://github.com/contiki-os/contiki/pull/2156#issuecomment-290526139,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.","Hi,
This is a bit similar to what we have been doing with CoAP in our LWM2M standalone implementation where we have made CoAP independent of transport layer and also independent of addressing model. This was in order to enable things like using LWM2M over serial links or SMS (as specified in the LWM2M specification). Examples of implementations on top of the regular linux stack (or posix) and also over HEX serial line is available here:
https://github.com/sics-iot/lwm2m-contiki/tree/lwm2m-standalone/examples/oma-lwm2m/standalone
(where you also can find the implementation and some brief description on the wiki pages).
We defined something we called coap_transport that is similar to your communication layer abstraction. We also defined a coap_endpoint that takes care of addressing (IPv4/6 or whatever is the addressing model). The we finally removed any other specifics such as processes and other things so that it is fully independent of anything else also - to make it possible to only use CoAP + LWM2M in any environment (just by implementing a very basic timer and the transport/endpoint abstractions).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/cladmi,6,https://github.com/contiki-os/contiki/pull/2156#issuecomment-291135294,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.","I looked at your implementation. I see the two different parts

Allow overwriting the whole network layer and using ""endpoints"" instead of address and port

This requires also moving ""uip"" management in a separate file as you may not depend on it anymore to receive messages


Moving parts of the contiki ""process"" management out.

My PR, addresses using the same transport layer as before, but adding the possibility to modify packets content on the fly (session/presentation layer). Still relying on uip below.
So we are doing a similar thing but for a different goal.
And I think, none on us currently handles the other one problem.
If I would try to add DTLS on top of your stack, I would need to copy all the er-coap-uip code to create dtls+uip layer. (I think it would only require prefixing your functions names so I could re-use the uip layer and add #define configuration).
And saying you could replace the ""communication layer"" with my PR is wrong as it still relies on uip only.
How where these problems addressed in other parts on the code ? Because it looks like a problem that can happen in other places.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2156,2017-03-23T14:41:47Z,,2017-06-08T15:51:55Z,OPEN,False,78,36,9,https://github.com/cladmi,er-coap: separate communication layer,3,[],https://github.com/contiki-os/contiki/pull/2156,https://github.com/cladmi,7,https://github.com/contiki-os/contiki/pull/2156#issuecomment-307145909,"Separates the communication layer in separate source file.
This will allow changing the communication layer, for example to dtls, by replacing er-coap-udp.c.
This code was copied and modified from https://github.com/cetic/6lbr written by Laurent Deru @laurentderu
This commit is based on #2155.
This commit is a part of #1995.","It is the last day of my current job so I will not be able to work on this anymore.
Feel free to fork/update/change what I have done.
Regards, cladmi",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2159,2017-03-24T16:49:54Z,2017-03-30T14:30:47Z,2017-03-30T14:48:12Z,MERGED,True,55,284,12,https://github.com/herjulf,avr-rss2 platform fixes,9,[],https://github.com/contiki-os/contiki/pull/2159,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2159,avr-rss2 platform. Serial line input bugfix. Misc. clean-up. Private sniffer app removed.,avr-rss2 platform. Serial line input bugfix. Misc. clean-up. Private sniffer app removed.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2159,2017-03-24T16:49:54Z,2017-03-30T14:30:47Z,2017-03-30T14:48:12Z,MERGED,True,55,284,12,https://github.com/herjulf,avr-rss2 platform fixes,9,[],https://github.com/contiki-os/contiki/pull/2159,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2159#issuecomment-290428827,avr-rss2 platform. Serial line input bugfix. Misc. clean-up. Private sniffer app removed.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2159,2017-03-24T16:49:54Z,2017-03-30T14:30:47Z,2017-03-30T14:48:12Z,MERGED,True,55,284,12,https://github.com/herjulf,avr-rss2 platform fixes,9,[],https://github.com/contiki-os/contiki/pull/2159,https://github.com/herjulf,3,https://github.com/contiki-os/contiki/pull/2159#issuecomment-290434469,avr-rss2 platform. Serial line input bugfix. Misc. clean-up. Private sniffer app removed.,Gott!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2161,2017-03-28T10:35:30Z,,2018-04-26T18:06:39Z,OPEN,False,50,21,3,https://github.com/niziak,PROP mode: RX_BUF_FULL handling,3,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2161,https://github.com/niziak,1,https://github.com/contiki-os/contiki/pull/2161,"Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts","Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2161,2017-03-28T10:35:30Z,,2018-04-26T18:06:39Z,OPEN,False,50,21,3,https://github.com/niziak,PROP mode: RX_BUF_FULL handling,3,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2161,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2161#issuecomment-289735832,"Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts",Thanks for this very detailed contribution. I'll look at it ASAP!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2161,2017-03-28T10:35:30Z,,2018-04-26T18:06:39Z,OPEN,False,50,21,3,https://github.com/niziak,PROP mode: RX_BUF_FULL handling,3,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2161,https://github.com/niziak,3,https://github.com/contiki-os/contiki/pull/2161#issuecomment-293272451,"Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts",Can you start again Travis build?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2161,2017-03-28T10:35:30Z,,2018-04-26T18:06:39Z,OPEN,False,50,21,3,https://github.com/niziak,PROP mode: RX_BUF_FULL handling,3,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2161,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2161#issuecomment-299702166,"Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts","This pull seems to have some merit, but it also has some issues.

In the current master, we first make sure the RF core is powered before we access RFCPEIFG (or other interrupt-related registers). You have added code that bypasses those checks, and there is no obvious reason for doing so. Add: We need those checks because access to those registers with the RF core powered down leads to bus fault.
I am not convinced by your argument in Scenario 1. It strikes me as though putting the radio in RX is for convenience, and not because this is the state it should really be in. I need to see a better justification as to why this is always the case, or some better logic. As discussed elsewhere, the main root of this bug is the check in rf_is_on. This is where we should be focusing (as well as handling the interrupt of course).
I'll need all length-related changes to be isolated in their own commit. DOT_4G_MAX_FRAME_LEN should stay 2047: This define is meant to represent what the standard says. So let's leave that one as-is and use something else to define RX_BUF_DATA_SECTION_SIZE. I like your proposal about RX_BUF_SIZE
Code style will need tidied up.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2161,2017-03-28T10:35:30Z,,2018-04-26T18:06:39Z,OPEN,False,50,21,3,https://github.com/niziak,PROP mode: RX_BUF_FULL handling,3,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2161,https://github.com/marcomilazzo,5,https://github.com/contiki-os/contiki/pull/2161#issuecomment-384732300,"Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts","Hi
How do i enable IRQ_RX_BUF_FULL   ?
How to add RX status checks in scenario 3?
I  still don't understand  the rpl ! i'm a begginer !
I have 1 udp_server and 10 udp_clients  in non storing mode on cc1310
Occasionally i get resets ! wich drive me crazy
Thank's for any help
Marco :)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2161,2017-03-28T10:35:30Z,,2018-04-26T18:06:39Z,OPEN,False,50,21,3,https://github.com/niziak,PROP mode: RX_BUF_FULL handling,3,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2161,https://github.com/marcomilazzo,6,https://github.com/contiki-os/contiki/pull/2161#issuecomment-384735564,"Will fix #1878 and derivatives.
Issue
Sometimes, in heavy traffic environment radio RX-ing part stop working.
TX-ing of frames works correctly, other nodes can see DIS frames transmitted from problematic node.
Background
RX part of radio is initialized using predefined command structure smartrf_settings_cmd_prop_rx_adv.
In this structure, user has to pass pointer (smartrf_settings_cmd_prop_rx_adv.pQueue) to another structure allocated in RAM which describes Data Entry Queue.
Data Entry Queue contains description and buffers available for RX. See References section at end.
When lots of frames are received in burst, and Contiki OS is busy (calculating RPL or printing lots of debug info) all buffers in queue can be used.
When there is no space in queue, radio receiver goes into error state and further receiving is disabled. This state is signaled by:

status flag smartrf_settings_cmd_prop_rx_adv.status = RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF (0x3801)
interrupt IRQ_RX_BUF_FULL (but not handled and disabled in Contiki)

Additionally, above status flag is used commonly as radio ON indicator (smartrf_settings_cmd_prop_rx_adv.status != RF_CORE_RADIO_OP_STATUS_ACTIVE).
So, when RX buffer full occurs, all other components treats radio as disabled, which produces some side effects like entering into LPM_MODE_MAX_SUPPORTED=LPM_MODE_DEEP_SLEEP
power saving mode.
TX-ing works OK, because radio is re-enabled for TX operation, and previous radio state (radio off) is restored after transmit.
In current version of Contiki, Data Entry Structure contains 4 (PROP_MODE_RX_BUF_CNT) buffers of RX_BUF_SIZE=140 bytes each.
Number of buffers was increased from 2 to 4 to make workaround for issue #1878.
TI recommends to use at least 2 buffers, where one RX buffer can be processed by application and second buffer can be filled by RF core in the same time.
Scenario 1
With each new frame, interrupt RX_FRAME_IRQ is generated. Interrupt handler trigger Contiki OS to activate rf_core_process.
This process is only responsible for reading frames from buffers (NETSTACK_RADIO.read()) and pass it to Contiki (NETSTACK_RDC.input())
If Contiki is busy, frames cannot be processed and all buffers are used. Next received frame will cause RX_BUF_FULL error.
Solution for problem is to re-enable radio just after buffer is read and marked as free for RX-ing.
Fix was implemented in prop-mode.c. At the end of read_frame function, one RX buffer is free and ready to use, so radio can be re-enabled.
read_frame(void *buf, unsigned short buf_len)
{
  ...
  if (smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF)
  {
    PRINTF(""RXQ was full, re-enabling radio!\n"");
    rx_on_prop();
  }
  return len;
}
With this fix, node works very well even with PROP_MODE_RX_BUF_CNT set to 1!
Scenario 2
With very high traffic, RF part immediately fills all buffers and goes into RX_BUFF_ERROR state. Without triggering RX_FRAME_IRQ. It is not possible to handle this situation with fix above.
To fix it, error interrupt IRQ_RX_BUF_FULL is enabled and handled to trigger Contiki OS to activate rf_core_process.
Scenario 3
Sometimes, before Contiki switches to rf_core_process and NETSTACK_RADIO.read() can read frame and restore correct RX operating state, it is possible that other processes execute one of function:

get_rssi(),
transmit(),
channel_clear(),
set_value().
Above function needs to turn on radio RX to operate and restores original RX state before exit. Original radio state is obtained from simple call to rf_is_on(), where condition looks like: smartrf_settings_cmd_prop_rx_adv.status == RF_CORE_RADIO_OP_STATUS_ACTIVE.
From rf_is_on() function point of view, radio is disabled, so after finished transmission, radio is switched off, and smartrf_settings_cmd_prop_rx_adv.status is set RF_CORE_RADIO_OP_STATUS_IDLE and previously set status RF_CORE_RADIO_OP_STATUS_PROP_ERROR_RXBUF is lost.

To fix it, the RX status checks is added at beginning function rf_is_on(), so when error occurs, radio is restored to previous state RF_CORE_RADIO_OP_STATUS_ACTIVE.
Scenario 4
If received frame is too big to fit into configured buffer, RX_BUFF_ERROR also occurs.
To fix it, frame filtering by packet size was changed from 2047 (DOT_4G_MAX_FRAME_LEN) to real size defined by NETSTACK_RADIO_MAX_PAYLOAD_LEN + DOT_4G_PHR_LEN.
Also RX buffers sizes are calculated from DOT_4G_MAX_FRAME_LEN.
References

23.3.2.7 Data Entry Structures
23.7.4.1 Receive Buffers
23.7.5.4.2 Advanced Receive Command, CMD_PROP_RX_ADV
Working with data queues
Howto clear interrupts: 23.2.2.1 RF Command and Packet Engine Interrupts","i sow the commits !
sorry
thank's anyway",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2162,2017-03-28T17:08:07Z,2017-03-31T11:24:56Z,2017-03-31T13:02:28Z,MERGED,True,343,29,4,https://github.com/herjulf,Updates for  Atmel radio ,3,[],https://github.com/contiki-os/contiki/pull/2162,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2162,"including register update for MAC symbol counter. Basic functions for get/set-value
parameter setting added. SPI radios needs to be tested.
modified:   cpu/avr/radio/rf230bb/atmega256rfr2_registermap.h
modified:   cpu/avr/radio/rf230bb/rf230bb.c","including register update for MAC symbol counter. Basic functions for get/set-value
parameter setting added. SPI radios needs to be tested.
modified:   cpu/avr/radio/rf230bb/atmega256rfr2_registermap.h
modified:   cpu/avr/radio/rf230bb/rf230bb.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2162,2017-03-28T17:08:07Z,2017-03-31T11:24:56Z,2017-03-31T13:02:28Z,MERGED,True,343,29,4,https://github.com/herjulf,Updates for  Atmel radio ,3,[],https://github.com/contiki-os/contiki/pull/2162,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2162#issuecomment-290687618,"including register update for MAC symbol counter. Basic functions for get/set-value
parameter setting added. SPI radios needs to be tested.
modified:   cpu/avr/radio/rf230bb/atmega256rfr2_registermap.h
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Looks sane to me.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2162,2017-03-28T17:08:07Z,2017-03-31T11:24:56Z,2017-03-31T13:02:28Z,MERGED,True,343,29,4,https://github.com/herjulf,Updates for  Atmel radio ,3,[],https://github.com/contiki-os/contiki/pull/2162,https://github.com/herjulf,3,https://github.com/contiki-os/contiki/pull/2162#issuecomment-290696081,"including register update for MAC symbol counter. Basic functions for get/set-value
parameter setting added. SPI radios needs to be tested.
modified:   cpu/avr/radio/rf230bb/atmega256rfr2_registermap.h
modified:   cpu/avr/radio/rf230bb/rf230bb.c","Thanks,
Yes it should now be possible slip-radio and your sensniff for Atmel platforms. We're using sensniff and I did removed the ptatform specific sniffer to remove some code. Also the set/get_value are needed by TSCH etc.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2162,2017-03-28T17:08:07Z,2017-03-31T11:24:56Z,2017-03-31T13:02:28Z,MERGED,True,343,29,4,https://github.com/herjulf,Updates for  Atmel radio ,3,[],https://github.com/contiki-os/contiki/pull/2162,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2162#issuecomment-290705865,"including register update for MAC symbol counter. Basic functions for get/set-value
parameter setting added. SPI radios needs to be tested.
modified:   cpu/avr/radio/rf230bb/atmega256rfr2_registermap.h
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Feel free to extend the sensniff example with support for this platform (and of course to remove anything that you believe is no longer needed). It's good to see AVR platforms getting some love.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2164,2017-03-31T15:48:10Z,2017-04-01T23:32:53Z,2017-04-01T23:32:53Z,MERGED,True,2,4,1,https://github.com/alexstanoev,Zero out httpd_state before deallocating,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2164,https://github.com/alexstanoev,1,https://github.com/contiki-os/contiki/pull/2164,"When a connection is aborted by the HTTP server while it's still being processed it is possible to hit a null pointer dereference issue by jumping back to a protothread (outputpt) after its httpd_state has been freed. This can be triggered by sending a POST to any form in the CC26xx web demo server using Firefox.
This patch prevents that by zeroing out httpd_state structs before freeing them, thus also clearing the httpd_state->outputpt field.
Tested using Firefox 55.0a1 on a CC2650 LaunchPad.","When a connection is aborted by the HTTP server while it's still being processed it is possible to hit a null pointer dereference issue by jumping back to a protothread (outputpt) after its httpd_state has been freed. This can be triggered by sending a POST to any form in the CC26xx web demo server using Firefox.
This patch prevents that by zeroing out httpd_state structs before freeing them, thus also clearing the httpd_state->outputpt field.
Tested using Firefox 55.0a1 on a CC2650 LaunchPad.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2164,2017-03-31T15:48:10Z,2017-04-01T23:32:53Z,2017-04-01T23:32:53Z,MERGED,True,2,4,1,https://github.com/alexstanoev,Zero out httpd_state before deallocating,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2164,https://github.com/alexstanoev,2,https://github.com/contiki-os/contiki/pull/2164#issuecomment-290764430,"When a connection is aborted by the HTTP server while it's still being processed it is possible to hit a null pointer dereference issue by jumping back to a protothread (outputpt) after its httpd_state has been freed. This can be triggered by sending a POST to any form in the CC26xx web demo server using Firefox.
This patch prevents that by zeroing out httpd_state structs before freeing them, thus also clearing the httpd_state->outputpt field.
Tested using Firefox 55.0a1 on a CC2650 LaunchPad.",This also fixes the issue where headers sometimes show twice up after a POST request:,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2164,2017-03-31T15:48:10Z,2017-04-01T23:32:53Z,2017-04-01T23:32:53Z,MERGED,True,2,4,1,https://github.com/alexstanoev,Zero out httpd_state before deallocating,1,"['bug', 'Platform / CPU / ARM / CC13xx-CC26xx']",https://github.com/contiki-os/contiki/pull/2164,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/2164#issuecomment-290954195,"When a connection is aborted by the HTTP server while it's still being processed it is possible to hit a null pointer dereference issue by jumping back to a protothread (outputpt) after its httpd_state has been freed. This can be triggered by sending a POST to any form in the CC26xx web demo server using Firefox.
This patch prevents that by zeroing out httpd_state structs before freeing them, thus also clearing the httpd_state->outputpt field.
Tested using Firefox 55.0a1 on a CC2650 LaunchPad.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2165,2017-03-31T16:30:45Z,2017-04-01T23:33:43Z,2017-04-01T23:33:43Z,MERGED,True,13,6,2,https://github.com/alexandruioanp,Check broker IP conversion. Adjust state machine accordingly,1,"['bug', 'MQTT']",https://github.com/contiki-os/contiki/pull/2165,https://github.com/alexandruioanp,1,https://github.com/contiki-os/contiki/pull/2165,"The result of converting the IP address of the broker wasn't checked. As a result, if an invalid IP address was entered, the pointer was left uninitialised and the IPv6 address used for connecting was some random data. The function now returns an error. Before connect_to_broker is called, mqtt_register is executed, which memsets conn to 0, making its state 0 (MQTT_CONN_STATE_ERROR). In order to recover from this error state, the extra check was added in the MQTT_CLIENT_STATE_NEWCONFIG state.
This was discovered by @jackmcbride using CodeSonar.","The result of converting the IP address of the broker wasn't checked. As a result, if an invalid IP address was entered, the pointer was left uninitialised and the IPv6 address used for connecting was some random data. The function now returns an error. Before connect_to_broker is called, mqtt_register is executed, which memsets conn to 0, making its state 0 (MQTT_CONN_STATE_ERROR). In order to recover from this error state, the extra check was added in the MQTT_CLIENT_STATE_NEWCONFIG state.
This was discovered by @jackmcbride using CodeSonar.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2165,2017-03-31T16:30:45Z,2017-04-01T23:33:43Z,2017-04-01T23:33:43Z,MERGED,True,13,6,2,https://github.com/alexandruioanp,Check broker IP conversion. Adjust state machine accordingly,1,"['bug', 'MQTT']",https://github.com/contiki-os/contiki/pull/2165,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2165#issuecomment-290954239,"The result of converting the IP address of the broker wasn't checked. As a result, if an invalid IP address was entered, the pointer was left uninitialised and the IPv6 address used for connecting was some random data. The function now returns an error. Before connect_to_broker is called, mqtt_register is executed, which memsets conn to 0, making its state 0 (MQTT_CONN_STATE_ERROR). In order to recover from this error state, the extra check was added in the MQTT_CLIENT_STATE_NEWCONFIG state.
This was discovered by @jackmcbride using CodeSonar.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2166,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c","More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2166#issuecomment-290954179,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Good stuff. It appears as though those new functions in rf230bb.c  could be static?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/herjulf,3,https://github.com/contiki-os/contiki/pull/2166#issuecomment-290975510,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Agree. I'll fix that.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2166#issuecomment-290983291,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c","@heipei  Robert, ready here?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/herjulf,5,https://github.com/contiki-os/contiki/pull/2166#issuecomment-291012245,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c","Hello, hmm, Do we miscommunicate or something I'm missing?
The rename was done in  commit aed5457 for 11h ago.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/g-oikonomou,6,https://github.com/contiki-os/contiki/pull/2166#issuecomment-291012327,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Just checking whether this is all done or whether you were planning to add more :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/herjulf,7,https://github.com/contiki-os/contiki/pull/2166#issuecomment-291012747,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Thanks. Ok. Understand. Well more will come but need to care some other duties for some days now.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2166,2017-03-31T16:47:50Z,2017-04-02T20:32:00Z,2017-04-02T20:32:00Z,MERGED,True,67,33,2,https://github.com/herjulf,Updates for Atmel radio part II,2,[],https://github.com/contiki-os/contiki/pull/2166,https://github.com/g-oikonomou,8,https://github.com/contiki-os/contiki/pull/2166#issuecomment-291012817,"More get/set_value fixes and get_obj RADIO_PARAM_LAST_PACKET_TIMESTAMP support.
modified:   cpu/avr/radio/rf230bb/halbb.c
modified:   cpu/avr/radio/rf230bb/rf230bb.c",Thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2167,2017-03-31T18:03:05Z,2017-04-01T23:29:11Z,2017-04-01T23:29:11Z,MERGED,True,84,0,4,https://github.com/herjulf,Adding sensniff support for Atmel via avr-rss2 platform,1,[],https://github.com/contiki-os/contiki/pull/2167,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2167,Title says it. Gives a very useful app with wireshark. Use 500 kbaud (default) or 1 Mbaud which goes well with the UART XTAL at 16Mhz. Tested on AtMega256RFR2.,Title says it. Gives a very useful app with wireshark. Use 500 kbaud (default) or 1 Mbaud which goes well with the UART XTAL at 16Mhz. Tested on AtMega256RFR2.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2167,2017-03-31T18:03:05Z,2017-04-01T23:29:11Z,2017-04-01T23:29:11Z,MERGED,True,84,0,4,https://github.com/herjulf,Adding sensniff support for Atmel via avr-rss2 platform,1,[],https://github.com/contiki-os/contiki/pull/2167,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2167#issuecomment-290954044,Title says it. Gives a very useful app with wireshark. Use 500 kbaud (default) or 1 Mbaud which goes well with the UART XTAL at 16Mhz. Tested on AtMega256RFR2.,Splendid! üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2168,2017-04-02T08:33:40Z,2017-04-02T12:26:30Z,2017-06-19T05:50:23Z,MERGED,True,4,0,1,https://github.com/tarakanov,Correct SPI pins,1,[],https://github.com/contiki-os/contiki/pull/2168,https://github.com/tarakanov,1,https://github.com/contiki-os/contiki/pull/2168,I make some changes to SPI pin definition for Sensortag so it will be similar to launchpad. I successfully use this to connect ENC28J60 module and run 6lbr (eth-module and external flash works).,I make some changes to SPI pin definition for Sensortag so it will be similar to launchpad. I successfully use this to connect ENC28J60 module and run 6lbr (eth-module and external flash works).,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2168,2017-04-02T08:33:40Z,2017-04-02T12:26:30Z,2017-06-19T05:50:23Z,MERGED,True,4,0,1,https://github.com/tarakanov,Correct SPI pins,1,[],https://github.com/contiki-os/contiki/pull/2168,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2168#issuecomment-290983195,I make some changes to SPI pin definition for Sensortag so it will be similar to launchpad. I successfully use this to connect ENC28J60 module and run 6lbr (eth-module and external flash works).,"I'm not so sure that using the same pins for an external flash and for the ENC28J60 is a good idea, but this pull request is valid.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2168,2017-04-02T08:33:40Z,2017-04-02T12:26:30Z,2017-06-19T05:50:23Z,MERGED,True,4,0,1,https://github.com/tarakanov,Correct SPI pins,1,[],https://github.com/contiki-os/contiki/pull/2168,https://github.com/tarakanov,3,https://github.com/contiki-os/contiki/pull/2168#issuecomment-304515207,I make some changes to SPI pin definition for Sensortag so it will be similar to launchpad. I successfully use this to connect ENC28J60 module and run 6lbr (eth-module and external flash works).,"Indeed, when I move to dedicated spi pins for ENC, 6lbr become more stable.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2170,2017-04-03T12:47:26Z,,2017-04-05T08:26:35Z,OPEN,False,11,3,1,https://github.com/fmag7,'Step instruction' button in 'Instructions' tab of 'Msp Code Watcher',2,[],https://github.com/contiki-os/contiki/pull/2170,https://github.com/fmag7,1,https://github.com/contiki-os/contiki/pull/2170,"This is a small but helpful enhancement of Cooja. When debugging with the ""Msp Code Watcher"", stepping through instructions was only possible in the ""Source code"" tab but not in the ""Instructions"" tab. This commit adds this feature.","This is a small but helpful enhancement of Cooja. When debugging with the ""Msp Code Watcher"", stepping through instructions was only possible in the ""Source code"" tab but not in the ""Instructions"" tab. This commit adds this feature.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2170,2017-04-03T12:47:26Z,,2017-04-05T08:26:35Z,OPEN,False,11,3,1,https://github.com/fmag7,'Step instruction' button in 'Instructions' tab of 'Msp Code Watcher',2,[],https://github.com/contiki-os/contiki/pull/2170,https://github.com/fabricio-godoi,2,https://github.com/contiki-os/contiki/pull/2170#issuecomment-291565020,"This is a small but helpful enhancement of Cooja. When debugging with the ""Msp Code Watcher"", stepping through instructions was only possible in the ""Source code"" tab but not in the ""Instructions"" tab. This commit adds this feature.","Greetings,
It's a nice modification, it's annoying to have to change view all the time to debug some assembly. I made the changes and notice some bug, that I think isn't wanted with this change.
When the Source code tab set a source file, the Code Watcher view is changed to the ""Source code"" tab with every ""Step Instruction"" done in the Instructions tab.
I added this lines to prevent updating the view, check if it's useful.
In the MspCodeWatcher class (arround line 93)
private static final int INSTRUCTIONS = 1;
In function displaySourceFile (arround line 295)
if(mainPane.getSelectedIndex() != INSTRUCTIONS){
mainPane.setSelectedIndex(SOURCECODE); /* code */
}
Thanks,
Best regards!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2170,2017-04-03T12:47:26Z,,2017-04-05T08:26:35Z,OPEN,False,11,3,1,https://github.com/fmag7,'Step instruction' button in 'Instructions' tab of 'Msp Code Watcher',2,[],https://github.com/contiki-os/contiki/pull/2170,https://github.com/fmag7,3,https://github.com/contiki-os/contiki/pull/2170#issuecomment-291790495,"This is a small but helpful enhancement of Cooja. When debugging with the ""Msp Code Watcher"", stepping through instructions was only possible in the ""Source code"" tab but not in the ""Instructions"" tab. This commit adds this feature.","Thanks for your fix, indeed this tab switch wasn't intended.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2171,2017-04-03T15:10:11Z,2017-04-18T11:56:42Z,2017-04-18T11:56:42Z,CLOSED,False,1924,4,15,https://github.com/onurrrrrr,Z1x,8,[],https://github.com/contiki-os/contiki/pull/2171,https://github.com/onurrrrrr,1,https://github.com/contiki-os/contiki/pull/2171,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2171,2017-04-03T15:10:11Z,2017-04-18T11:56:42Z,2017-04-18T11:56:42Z,CLOSED,False,1924,4,15,https://github.com/onurrrrrr,Z1x,8,[],https://github.com/contiki-os/contiki/pull/2171,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2171#issuecomment-291534866,,"Please look at https://github.com/contiki-os/contiki/wiki/Code-Contributions for a list of some issues regarding new platforms that should be clarified in the description of the PR.
The code also seems to have been developed by @atiselsts, but he is not the originator of the PR. Any comments on this?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2171,2017-04-03T15:10:11Z,2017-04-18T11:56:42Z,2017-04-18T11:56:42Z,CLOSED,False,1924,4,15,https://github.com/onurrrrrr,Z1x,8,[],https://github.com/contiki-os/contiki/pull/2171,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/2171#issuecomment-291830963,,"@onurrrrrr , please contact me privately if you're interested in contributing to this. My contact details are easily available online. I recommend closing this pull request.
About the platform - this is just a simple clone of the Z1 platform, but with more flash and RAM memory. It's not based on a real sensor node, but intended to be used by Cooja simulations. We're finding it very useful to use it for TSCH testing in particular, and also in general, as a mock up of our CC2650 platform in the SPHERE project (no Cooja support for ARM based MCUs, as you know), to run regression tests on the complete system etc.
The main reason why I haven't made a pull request of this personally is that it also requires updating the mspsim code. Perhaps if there's interest we can move forward?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2171,2017-04-03T15:10:11Z,2017-04-18T11:56:42Z,2017-04-18T11:56:42Z,CLOSED,False,1924,4,15,https://github.com/onurrrrrr,Z1x,8,[],https://github.com/contiki-os/contiki/pull/2171,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2171#issuecomment-292990947,,"@atiselsts Would the exp5438 or Wismote platforms be sufficient for your experiments on MSP430-based systems? I'm not so sure that building a ""virtual"" platform based on the old Z1 is the right way to go for the official repository.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2171,2017-04-03T15:10:11Z,2017-04-18T11:56:42Z,2017-04-18T11:56:42Z,CLOSED,False,1924,4,15,https://github.com/onurrrrrr,Z1x,8,[],https://github.com/contiki-os/contiki/pull/2171,https://github.com/atiselsts,5,https://github.com/contiki-os/contiki/pull/2171#issuecomment-293203010,,"At least at the point when this Z1x code was developed, TSCH support on Wismote's radio (CC2520) was problematic. Don't know about the state now. I'd still rather use CC2420 than CC2520 any time, as CC2420 is so well know and supported.
Another reason was that we were interested in having the same sensors as on TI SensorTag, not whatever Wismote / exp5438 has.
I will not push for it you don't think it's appropriate to the mainline, sure.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2171,2017-04-03T15:10:11Z,2017-04-18T11:56:42Z,2017-04-18T11:56:42Z,CLOSED,False,1924,4,15,https://github.com/onurrrrrr,Z1x,8,[],https://github.com/contiki-os/contiki/pull/2171,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/2171#issuecomment-294806413,,"Closing this PR as @atiselsts recommended above. We'll see if there is interest from other mergers to include this platform in Contiki, in which case a new PR could perhaps be opened with support from the original authors.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2172,2017-04-03T17:06:03Z,,2017-05-23T14:50:21Z,OPEN,False,557,1,6,https://github.com/herjulf,RPL interactive serial line monitoring. show dag/show routes/show neighbor etc,5,[],https://github.com/contiki-os/contiki/pull/2172,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2172,"I don't know if this is of common interest.. Anyway this code for monitoring RPL network within the GreenIoT project i Stockolm/Uppsala. Code has been useful. Code has been cleaned up and moved into a Contiki app to be used with different projects. Assume that the most people running RPL can have some instrumentation and debugging. Anyway this our one take.
The  PR organized in two parts and should be straight-forward to use.

app/cli
an example: Adding support for the Ethernet IP64BR in the avr-rss2 platform

Much code is reused from other projects... see cli.c","I don't know if this is of common interest.. Anyway this code for monitoring RPL network within the GreenIoT project i Stockolm/Uppsala. Code has been useful. Code has been cleaned up and moved into a Contiki app to be used with different projects. Assume that the most people running RPL can have some instrumentation and debugging. Anyway this our one take.
The  PR organized in two parts and should be straight-forward to use.

app/cli
an example: Adding support for the Ethernet IP64BR in the avr-rss2 platform

Much code is reused from other projects... see cli.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2173,2017-04-04T12:17:43Z,2017-04-06T14:06:29Z,2017-10-27T20:04:44Z,MERGED,True,6,4,1,https://github.com/simonduq,Updating TSCH readme file,2,[],https://github.com/contiki-os/contiki/pull/2173,https://github.com/simonduq,1,https://github.com/contiki-os/contiki/pull/2173,"Added link to new reference paper, to appear in DCOSS 2017, which details the design and implementation of Contiki's TSCH+6TiSCH;
Minor updates: 802.15.4-2015 and 6TiSCH.","Added link to new reference paper, to appear in DCOSS 2017, which details the design and implementation of Contiki's TSCH+6TiSCH;
Minor updates: 802.15.4-2015 and 6TiSCH.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2173,2017-04-04T12:17:43Z,2017-04-06T14:06:29Z,2017-10-27T20:04:44Z,MERGED,True,6,4,1,https://github.com/simonduq,Updating TSCH readme file,2,[],https://github.com/contiki-os/contiki/pull/2173,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2173#issuecomment-291528779,"Added link to new reference paper, to appear in DCOSS 2017, which details the design and implementation of Contiki's TSCH+6TiSCH;
Minor updates: 802.15.4-2015 and 6TiSCH.","üëç
As a side note, it appears that the telnet-server example does not build for the atarixl target, which is of course unrelated to this README update.

ld65 -o webbrowser.atarixl -t atarixl -m contiki-atarixl.map -D __STACKSIZE__=0x200 -u _main webbrowser.co contiki-atarixl.a atarixl.lib
ld65: Warning: /tmp/cc65/cfg/atarixl.cfg(35): Segment SHADOW_RAM2' overflows memory area HIDDEN_RAM2' by 73 bytes
ld65: Error: Cannot generate most of the files due to memory area overflow",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2176,2017-04-05T11:27:06Z,2017-04-07T23:11:06Z,2017-04-07T23:11:06Z,MERGED,True,1,1,1,https://github.com/atiselsts,Fix HDC sensor reading conversion,1,[],https://github.com/contiki-os/contiki/pull/2176,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2176,"HDC sensor on SensorTag is currently having invalid values when temperature >+42.x degrees Celsius.
The cast to int16_t in this line seems to be at fault:
*temp = ((double)(int16_t)raw_temp / 65536) * 165 - 40;
Casting to signed is just not necessary here, as raw_temp can never be negative. raw_temp of zero corresponds to -40 degrees Celsius, which is the minimal value the sensor can read according to datasheet.","HDC sensor on SensorTag is currently having invalid values when temperature >+42.x degrees Celsius.
The cast to int16_t in this line seems to be at fault:
*temp = ((double)(int16_t)raw_temp / 65536) * 165 - 40;
Casting to signed is just not necessary here, as raw_temp can never be negative. raw_temp of zero corresponds to -40 degrees Celsius, which is the minimal value the sensor can read according to datasheet.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2176,2017-04-05T11:27:06Z,2017-04-07T23:11:06Z,2017-04-07T23:11:06Z,MERGED,True,1,1,1,https://github.com/atiselsts,Fix HDC sensor reading conversion,1,[],https://github.com/contiki-os/contiki/pull/2176,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2176#issuecomment-291854811,"HDC sensor on SensorTag is currently having invalid values when temperature >+42.x degrees Celsius.
The cast to int16_t in this line seems to be at fault:
*temp = ((double)(int16_t)raw_temp / 65536) * 165 - 40;
Casting to signed is just not necessary here, as raw_temp can never be negative. raw_temp of zero corresponds to -40 degrees Celsius, which is the minimal value the sensor can read according to datasheet.",üëç just restarted the failed travis task.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2180,2017-04-08T14:09:38Z,2017-04-21T15:59:40Z,2017-04-21T15:59:41Z,MERGED,True,4,0,1,https://github.com/atiselsts,Keep CoAP 'observe' option length <= 3 bytes,1,[],https://github.com/contiki-os/contiki/pull/2180,https://github.com/atiselsts,1,https://github.com/contiki-os/contiki/pull/2180,"Currently Contiki generates Observe notifications with the observe counter going up to 4 bytes. Yet RFC 7641(https://tools.ietf.org/html/rfc7641) clearly shows that the Observe option may have length from 0 to 3 bytes.
This causes problems for out application because with 4 byte observe option some packets will get too large to be sent over the air.","Currently Contiki generates Observe notifications with the observe counter going up to 4 bytes. Yet RFC 7641(https://tools.ietf.org/html/rfc7641) clearly shows that the Observe option may have length from 0 to 3 bytes.
This causes problems for out application because with 4 byte observe option some packets will get too large to be sent over the air.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2180,2017-04-08T14:09:38Z,2017-04-21T15:59:40Z,2017-04-21T15:59:41Z,MERGED,True,4,0,1,https://github.com/atiselsts,Keep CoAP 'observe' option length <= 3 bytes,1,[],https://github.com/contiki-os/contiki/pull/2180,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2180#issuecomment-294819606,"Currently Contiki generates Observe notifications with the observe counter going up to 4 bytes. Yet RFC 7641(https://tools.ietf.org/html/rfc7641) clearly shows that the Observe option may have length from 0 to 3 bytes.
This causes problems for out application because with 4 byte observe option some packets will get too large to be sent over the air.","Looks reasonable, but would it make sense to do the masking just once in coap_set_header_observe?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2180,2017-04-08T14:09:38Z,2017-04-21T15:59:40Z,2017-04-21T15:59:41Z,MERGED,True,4,0,1,https://github.com/atiselsts,Keep CoAP 'observe' option length <= 3 bytes,1,[],https://github.com/contiki-os/contiki/pull/2180,https://github.com/atiselsts,3,https://github.com/contiki-os/contiki/pull/2180#issuecomment-295183733,"Currently Contiki generates Observe notifications with the observe counter going up to 4 bytes. Yet RFC 7641(https://tools.ietf.org/html/rfc7641) clearly shows that the Observe option may have length from 0 to 3 bytes.
This causes problems for out application because with 4 byte observe option some packets will get too large to be sent over the air.","I went for the current approach to keep the internal state consistent with what is sent over-the-air. Otherwise the obs_counter variable sometimes will have different values from what's inside the CoAP packets, which would be a little confusing, to me at least.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2180,2017-04-08T14:09:38Z,2017-04-21T15:59:40Z,2017-04-21T15:59:41Z,MERGED,True,4,0,1,https://github.com/atiselsts,Keep CoAP 'observe' option length <= 3 bytes,1,[],https://github.com/contiki-os/contiki/pull/2180,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2180#issuecomment-296231135,"Currently Contiki generates Observe notifications with the observe counter going up to 4 bytes. Yet RFC 7641(https://tools.ietf.org/html/rfc7641) clearly shows that the Observe option may have length from 0 to 3 bytes.
This causes problems for out application because with 4 byte observe option some packets will get too large to be sent over the air.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2182,2017-04-10T09:10:23Z,2017-04-10T09:46:09Z,2017-04-10T09:46:09Z,MERGED,True,1,1,1,https://github.com/oliverschmidt,Adjusted cc65 compiler options to recent cc65 option handling change.,1,[],https://github.com/contiki-os/contiki/pull/2182,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2182,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2188,2017-04-11T13:25:06Z,2017-04-21T15:59:13Z,2017-04-21T15:59:13Z,MERGED,True,3,2,3,https://github.com/tonnenpinguin,Fix several uninitialized variables,1,[],https://github.com/contiki-os/contiki/pull/2188,https://github.com/tonnenpinguin,1,https://github.com/contiki-os/contiki/pull/2188,This fixes several potentially unitinitialized variables found by codesonar.,This fixes several potentially unitinitialized variables found by codesonar.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2188,2017-04-11T13:25:06Z,2017-04-21T15:59:13Z,2017-04-21T15:59:13Z,MERGED,True,3,2,3,https://github.com/tonnenpinguin,Fix several uninitialized variables,1,[],https://github.com/contiki-os/contiki/pull/2188,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2188#issuecomment-294836971,This fixes several potentially unitinitialized variables found by codesonar.,"SDCC complains about the way that you initialize a variable in rpl-icmp6.: uip_ipaddr_t prefix = {0};. A possible fix is to always do memset(&prefix, 0, sizeof(prefix)); before the option processing, instead just within the processing of the RPL target option.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2188,2017-04-11T13:25:06Z,2017-04-21T15:59:13Z,2017-04-21T15:59:13Z,MERGED,True,3,2,3,https://github.com/tonnenpinguin,Fix several uninitialized variables,1,[],https://github.com/contiki-os/contiki/pull/2188,https://github.com/tonnenpinguin,3,https://github.com/contiki-os/contiki/pull/2188#issuecomment-295166538,This fixes several potentially unitinitialized variables found by codesonar.,"That's weird. Initializing to zero like that should be standard compliant, shouldn't it?
I'll update my pr.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2188,2017-04-11T13:25:06Z,2017-04-21T15:59:13Z,2017-04-21T15:59:13Z,MERGED,True,3,2,3,https://github.com/tonnenpinguin,Fix several uninitialized variables,1,[],https://github.com/contiki-os/contiki/pull/2188,https://github.com/greg-king5,4,https://github.com/contiki-os/contiki/pull/2188#issuecomment-295179905,This fixes several potentially unitinitialized variables found by codesonar.,"Look in ""core/net/ip/uip.h"".  uip_ipaddr_t is a union of arrays.  Therefore, its initializer needs two pairs of braces.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2188,2017-04-11T13:25:06Z,2017-04-21T15:59:13Z,2017-04-21T15:59:13Z,MERGED,True,3,2,3,https://github.com/tonnenpinguin,Fix several uninitialized variables,1,[],https://github.com/contiki-os/contiki/pull/2188,https://github.com/tonnenpinguin,5,https://github.com/contiki-os/contiki/pull/2188#issuecomment-296188466,This fixes several potentially unitinitialized variables found by codesonar.,Touch√©!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2188,2017-04-11T13:25:06Z,2017-04-21T15:59:13Z,2017-04-21T15:59:13Z,MERGED,True,3,2,3,https://github.com/tonnenpinguin,Fix several uninitialized variables,1,[],https://github.com/contiki-os/contiki/pull/2188,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/2188#issuecomment-296231024,This fixes several potentially unitinitialized variables found by codesonar.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2189,2017-04-11T13:35:25Z,2017-04-18T14:39:34Z,2017-04-18T14:39:35Z,MERGED,True,7,7,2,https://github.com/tonnenpinguin,Fix potentially unterminated strings,1,[],https://github.com/contiki-os/contiki/pull/2189,https://github.com/tonnenpinguin,1,https://github.com/contiki-os/contiki/pull/2189,"This fixes some potential issues with strings being copied using strncpy, which causes char arrays that are used as strings later on to be non-terminated.
I have also changed the typecasts in the tolower function calls to unsigned char.
Fixes #2185","This fixes some potential issues with strings being copied using strncpy, which causes char arrays that are used as strings later on to be non-terminated.
I have also changed the typecasts in the tolower function calls to unsigned char.
Fixes #2185",True,{'THUMBS_UP': ['https://github.com/darconeous']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2189,2017-04-11T13:35:25Z,2017-04-18T14:39:34Z,2017-04-18T14:39:35Z,MERGED,True,7,7,2,https://github.com/tonnenpinguin,Fix potentially unterminated strings,1,[],https://github.com/contiki-os/contiki/pull/2189,https://github.com/darconeous,2,https://github.com/contiki-os/contiki/pull/2189#issuecomment-294013454,"This fixes some potential issues with strings being copied using strncpy, which causes char arrays that are used as strings later on to be non-terminated.
I have also changed the typecasts in the tolower function calls to unsigned char.
Fixes #2185","I would remove the unrelated change to the casts. tolower() is supposed to take an int. I'm not sure what's up with the unsigned part, but that's not really important at this point. I would rather the fix for the strncat issue to be clean.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2189,2017-04-11T13:35:25Z,2017-04-18T14:39:34Z,2017-04-18T14:39:35Z,MERGED,True,7,7,2,https://github.com/tonnenpinguin,Fix potentially unterminated strings,1,[],https://github.com/contiki-os/contiki/pull/2189,https://github.com/greg-king5,3,https://github.com/contiki-os/contiki/pull/2189#issuecomment-294028612,"This fixes some potential issues with strings being copied using strncpy, which causes char arrays that are used as strings later on to be non-terminated.
I have also changed the typecasts in the tolower function calls to unsigned char.
Fixes #2185","name points to type char.  The original programmer wanted to guarantee that the promotion to int doesn't extend the sign bit (if a compiler implements char as signed).
I don't see any advantage in changing those casts.  The result is the same: char to  signed int without sign extension.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2189,2017-04-11T13:35:25Z,2017-04-18T14:39:34Z,2017-04-18T14:39:35Z,MERGED,True,7,7,2,https://github.com/tonnenpinguin,Fix potentially unterminated strings,1,[],https://github.com/contiki-os/contiki/pull/2189,https://github.com/tonnenpinguin,4,https://github.com/contiki-os/contiki/pull/2189#issuecomment-294175734,"This fixes some potential issues with strings being copied using strncpy, which causes char arrays that are used as strings later on to be non-terminated.
I have also changed the typecasts in the tolower function calls to unsigned char.
Fixes #2185","@darconeous i removed the unrelated changes.
@greg-king5 I handled the second strncat issue as well!",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2189,2017-04-11T13:35:25Z,2017-04-18T14:39:34Z,2017-04-18T14:39:35Z,MERGED,True,7,7,2,https://github.com/tonnenpinguin,Fix potentially unterminated strings,1,[],https://github.com/contiki-os/contiki/pull/2189,https://github.com/nvt,5,https://github.com/contiki-os/contiki/pull/2189#issuecomment-294865870,"This fixes some potential issues with strings being copied using strncpy, which causes char arrays that are used as strings later on to be non-terminated.
I have also changed the typecasts in the tolower function calls to unsigned char.
Fixes #2185","Good to see security fixes, but we could at a later point also consider to provide an indication to the user somehow when buffers are insufficiently large for copying, instead of silent truncation.
üëç",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/posjodin,1,https://github.com/contiki-os/contiki/pull/2194,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","Intended for devices that attach via serial interface, such as
Plantower dust sensors.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/posjodin,2,https://github.com/contiki-os/contiki/pull/2194#issuecomment-293570404,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.",We use this for the PMS5003 dust sensor from Plantower. The sensor driver comes in a separate pull request.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/posjodin,3,https://github.com/contiki-os/contiki/pull/2194#issuecomment-293571321,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","The differences between this and the regular serial-line driver aren't very large. An alternative design could be to have just a single driver, and use a #define to select buffer mode at compile time.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2194#issuecomment-294852376,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","@posjodin Yes, I think that it would be more elegant to have a single driver with configurable buffering like setvbuf() in stdio or as compile-time option. There might be a backward-compatibility issue, however, if the API names should become more generic rather than line-oriented, as is currently the case with the serial-line driver.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/herjulf,5,https://github.com/contiki-os/contiki/pull/2194#issuecomment-295226780,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","@nvt
You mean just a simple compile-time option as  SERIAL_LINE_CONF_RAW to serial_line.c?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/nvt,6,https://github.com/contiki-os/contiki/pull/2194#issuecomment-296230226,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","A couple of issues make this a bit tricky to solve without requiring a number of code changes among the modules that depend on the serial-line module.


The module and function names including ""LINE"" are no longer so suitable if more buffer modes are to be supported.


Rather than incurring the overhead of sending a broadcast event for each byte, we may prefer to have a common callback-based API for all buffer modes, where a buffer and a length are delivered,


A quicker option could be to circumvent these API discussions and build something directly on top of the UART API in your driver.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/herjulf,7,https://github.com/contiki-os/contiki/pull/2194#issuecomment-296246345,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","Right.
From what I understand Peter was considering something based on the UART API.
We'll see.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/posjodin,8,https://github.com/contiki-os/contiki/pull/2194#issuecomment-296249989,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","Yes, I put the sensor driver directly on top of the UART API.
After considering this some more, I feel that Integrating the two buffer modes into the same code may not be a very elegant solution after all. There would be too many conditionals cluttering up the code...
In terms of functionality, the main difference between serial-raw and the UART API is really the broadcast. With only one consumer, one may as well use the UART API.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/nvt,9,https://github.com/contiki-os/contiki/pull/2194#issuecomment-296720787,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.",Sounds good. Shall we close this one then?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/herjulf,10,https://github.com/contiki-os/contiki/pull/2194#issuecomment-299842351,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.",Just talked to Peter. Yes I think so. He just forgot to close.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2194,2017-04-12T13:07:10Z,2017-05-08T11:40:12Z,2017-05-08T11:40:12Z,CLOSED,False,168,0,2,https://github.com/posjodin,Added serial-raw driver for unbuffered and unprocessed serial input.,2,[],https://github.com/contiki-os/contiki/pull/2194,https://github.com/posjodin,11,https://github.com/contiki-os/contiki/pull/2194#issuecomment-299844389,"Intended for devices that attach via serial interface, such as
Plantower dust sensors.","Yes, sorry. Closing now.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2203,2017-04-24T13:27:16Z,2017-06-22T12:14:17Z,2017-06-24T17:32:14Z,MERGED,True,413,0,8,https://github.com/herjulf,Atmel radio AES128 crypto engine support.,3,[],https://github.com/contiki-os/contiki/pull/2203,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2203,Support for the builtin Atmel radio AES128 engine. Did this code many moons ago but it's now updated for Contiki. Integration to security layers and stuffing MIC in is needed. Atmel crypto engine is pretty generic and can be used for several purposes. A small test-program is in included.,Support for the builtin Atmel radio AES128 engine. Did this code many moons ago but it's now updated for Contiki. Integration to security layers and stuffing MIC in is needed. Atmel crypto engine is pretty generic and can be used for several purposes. A small test-program is in included.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2203,2017-04-24T13:27:16Z,2017-06-22T12:14:17Z,2017-06-24T17:32:14Z,MERGED,True,413,0,8,https://github.com/herjulf,Atmel radio AES128 crypto engine support.,3,[],https://github.com/contiki-os/contiki/pull/2203,https://github.com/herjulf,2,https://github.com/contiki-os/contiki/pull/2203#issuecomment-310268124,Support for the builtin Atmel radio AES128 engine. Did this code many moons ago but it's now updated for Contiki. Integration to security layers and stuffing MIC in is needed. Atmel crypto engine is pretty generic and can be used for several purposes. A small test-program is in included.,Nicolas. Thanks for reviewing. Did you have more comments?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2203,2017-04-24T13:27:16Z,2017-06-22T12:14:17Z,2017-06-24T17:32:14Z,MERGED,True,413,0,8,https://github.com/herjulf,Atmel radio AES128 crypto engine support.,3,[],https://github.com/contiki-os/contiki/pull/2203,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/2203#issuecomment-310362245,Support for the builtin Atmel radio AES128 engine. Did this code many moons ago but it's now updated for Contiki. Integration to security layers and stuffing MIC in is needed. Atmel crypto engine is pretty generic and can be used for several purposes. A small test-program is in included.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2203,2017-04-24T13:27:16Z,2017-06-22T12:14:17Z,2017-06-24T17:32:14Z,MERGED,True,413,0,8,https://github.com/herjulf,Atmel radio AES128 crypto engine support.,3,[],https://github.com/contiki-os/contiki/pull/2203,https://github.com/herjulf,4,https://github.com/contiki-os/contiki/pull/2203#issuecomment-310852578,Support for the builtin Atmel radio AES128 engine. Did this code many moons ago but it's now updated for Contiki. Integration to security layers and stuffing MIC in is needed. Atmel crypto engine is pretty generic and can be used for several purposes. A small test-program is in included.,Thanks...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2204,2017-04-25T17:33:32Z,,2017-04-25T17:33:32Z,OPEN,False,4,2,2,https://github.com/mcr,remove callee-super-interworking from econotag build,1,[],https://github.com/contiki-os/contiki/pull/2204,https://github.com/mcr,1,https://github.com/contiki-os/contiki/pull/2204,"After two years away from econotag builds, I resumed only to find that new options do not work with currently available crop of compilers.  Perhaps we need to switch on some gcc version here.
gcc-arm-none-eabi                                                                                         4.8.4-1+11-1
removing this option seems to let things compile. I will test it later today.  I assume it changes the register model in some way that is faster, but incompatible with official ARM ABI.","After two years away from econotag builds, I resumed only to find that new options do not work with currently available crop of compilers.  Perhaps we need to switch on some gcc version here.
gcc-arm-none-eabi                                                                                         4.8.4-1+11-1
removing this option seems to let things compile. I will test it later today.  I assume it changes the register model in some way that is faster, but incompatible with official ARM ABI.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2206,2017-04-28T09:55:54Z,,2017-10-13T06:01:29Z,OPEN,False,14,13,1,https://github.com/pengi,Load platform before apps,1,[],https://github.com/contiki-os/contiki/pull/2206,https://github.com/pengi,1,https://github.com/contiki-os/contiki/pull/2206,"Some code can be reused between platform, so makeing platforms being
able to load apps helps.
For example, different platforms might still use the same segger-rtt
interface, similar handling of debug io
This patch makes it possible to add ""APPS += my_app"" to the platform
makefile","Some code can be reused between platform, so makeing platforms being
able to load apps helps.
For example, different platforms might still use the same segger-rtt
interface, similar handling of debug io
This patch makes it possible to add ""APPS += my_app"" to the platform
makefile",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2206,2017-04-28T09:55:54Z,,2017-10-13T06:01:29Z,OPEN,False,14,13,1,https://github.com/pengi,Load platform before apps,1,[],https://github.com/contiki-os/contiki/pull/2206,https://github.com/pengi,2,https://github.com/contiki-os/contiki/pull/2206#issuecomment-333092476,"Some code can be reused between platform, so makeing platforms being
able to load apps helps.
For example, different platforms might still use the same segger-rtt
interface, similar handling of debug io
This patch makes it possible to add ""APPS += my_app"" to the platform
makefile","bump?
This isn't anything that can be added to contiki? Would really help us if it was, and I can't really see that it will break or affect anything within contiki at the moment.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2206,2017-04-28T09:55:54Z,,2017-10-13T06:01:29Z,OPEN,False,14,13,1,https://github.com/pengi,Load platform before apps,1,[],https://github.com/contiki-os/contiki/pull/2206,https://github.com/fleutot,3,https://github.com/contiki-os/contiki/pull/2206#issuecomment-336358490,"Some code can be reused between platform, so makeing platforms being
able to load apps helps.
For example, different platforms might still use the same segger-rtt
interface, similar handling of debug io
This patch makes it possible to add ""APPS += my_app"" to the platform
makefile",I'd appreciate that too.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2213,2017-05-05T23:14:34Z,2017-06-02T21:37:53Z,2017-06-02T21:37:53Z,MERGED,True,47,5,2,https://github.com/alexstanoev,Validate MQTT broker IP and escape quotes when displaying,1,[],https://github.com/contiki-os/contiki/pull/2213,https://github.com/alexstanoev,1,https://github.com/contiki-os/contiki/pull/2213,"This commit implements address validation for the broker address in the MQTT configuration page of the CC26XX web demo example. Additionally, the Type ID, Org ID, Auth Token, Command Type and Event Type ID fields have quotes escaped ("" -> "") to prevent XSS/broken page issues when displaying user-sourced input in HTML input fields.","This commit implements address validation for the broker address in the MQTT configuration page of the CC26XX web demo example. Additionally, the Type ID, Org ID, Auth Token, Command Type and Event Type ID fields have quotes escaped ("" -> "") to prevent XSS/broken page issues when displaying user-sourced input in HTML input fields.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2213,2017-05-05T23:14:34Z,2017-06-02T21:37:53Z,2017-06-02T21:37:53Z,MERGED,True,47,5,2,https://github.com/alexstanoev,Validate MQTT broker IP and escape quotes when displaying,1,[],https://github.com/contiki-os/contiki/pull/2213,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2213#issuecomment-299699863,"This commit implements address validation for the broker address in the MQTT configuration page of the CC26XX web demo example. Additionally, the Type ID, Org ID, Auth Token, Command Type and Event Type ID fields have quotes escaped ("" -> "") to prevent XSS/broken page issues when displaying user-sourced input in HTML input fields.","Alex, I think we need a little bit more work here.
Correct me if I'm wrong, we are relying on the source string to be null-terminated. If it is not, we shall overrun it and keep reading up to a possible HTML_ESCAPED_BUFFER_SIZE bytes, right?
By looking at mqtt-client.c (those _post_handler functions), it appears as though some of the source strings here may under circumstances not be null-terminated (mqtt_config.type_id and .mqtt_config.org_id are the ones I looked at). This needs fixed in a separate pull.
For the purposes of this pull, I think we should be able to handle bad inputs (not null-terminated). One way of doing that is by having this function accept source length as an additional argument. Then the if statement at L318 should also check for source overrun. This should handle situations where the input is not null-terminated, while it will still truncate the destination correctly.
Can I also ask to remove variable declarations from inside for statements? This is C99, dstpos should be defined near srcpos.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2213,2017-05-05T23:14:34Z,2017-06-02T21:37:53Z,2017-06-02T21:37:53Z,MERGED,True,47,5,2,https://github.com/alexstanoev,Validate MQTT broker IP and escape quotes when displaying,1,[],https://github.com/contiki-os/contiki/pull/2213,https://github.com/alexstanoev,3,https://github.com/contiki-os/contiki/pull/2213#issuecomment-299702492,"This commit implements address validation for the broker address in the MQTT configuration page of the CC26XX web demo example. Additionally, the Type ID, Org ID, Auth Token, Command Type and Event Type ID fields have quotes escaped ("" -> "") to prevent XSS/broken page issues when displaying user-sourced input in HTML input fields.","Yes, this would expect the input to be properly null terminated. I'll add another argument and pass it the source buffer lengths defined in mqtt-client.h.
I'll have a go at sorting out mqtt-client.c too, it does indeed seem that there's no space for a null terminator if the input string is exactly the length of the buffer.
I'll move out the variable declaration and squash all these commits after everything seems fine, thanks.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2215,2017-05-07T14:49:37Z,,2017-07-23T13:08:15Z,OPEN,False,42,45,1,https://github.com/alexandruioanp,Fix uninitialised variables,1,[],https://github.com/contiki-os/contiki/pull/2215,https://github.com/alexandruioanp,1,https://github.com/contiki-os/contiki/pull/2215,"If fcf (the Frame Control Field) is NULL, frame802154_has_panid will return before initialising has_dest_pan_id and has_src_pan_id. A consequence of this was caught and fixed in 848f801, but this fixes the root cause by initialising the two variables before the function returns.
This was discovered by @jackmcbride using CodeSonar.","If fcf (the Frame Control Field) is NULL, frame802154_has_panid will return before initialising has_dest_pan_id and has_src_pan_id. A consequence of this was caught and fixed in 848f801, but this fixes the root cause by initialising the two variables before the function returns.
This was discovered by @jackmcbride using CodeSonar.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2215,2017-05-07T14:49:37Z,,2017-07-23T13:08:15Z,OPEN,False,42,45,1,https://github.com/alexandruioanp,Fix uninitialised variables,1,[],https://github.com/contiki-os/contiki/pull/2215,https://github.com/greg-king5,2,https://github.com/contiki-os/contiki/pull/2215#issuecomment-299713151,"If fcf (the Frame Control Field) is NULL, frame802154_has_panid will return before initialising has_dest_pan_id and has_src_pan_id. A consequence of this was caught and fixed in 848f801, but this fixes the root cause by initialising the two variables before the function returns.
This was discovered by @jackmcbride using CodeSonar.","A more efficient way to do it is to change the test to
if(fcf != NULL) {
And, put all of the code that accesses fcf into the body of that if() statement.
The code at the end of the function always will be executed; the return-variables always will be given proper values.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2215,2017-05-07T14:49:37Z,,2017-07-23T13:08:15Z,OPEN,False,42,45,1,https://github.com/alexandruioanp,Fix uninitialised variables,1,[],https://github.com/contiki-os/contiki/pull/2215,https://github.com/g-oikonomou,3,https://github.com/contiki-os/contiki/pull/2215#issuecomment-317251943,"If fcf (the Frame Control Field) is NULL, frame802154_has_panid will return before initialising has_dest_pan_id and has_src_pan_id. A consequence of this was caught and fixed in 848f801, but this fixes the root cause by initialising the two variables before the function returns.
This was discovered by @jackmcbride using CodeSonar.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2216,2017-05-08T11:24:05Z,2017-06-02T21:40:28Z,2017-06-02T21:40:28Z,MERGED,True,338,11,6,https://github.com/herjulf,Atmel radio; Support for RADIO_PARAM_CCA_THRESHOLD plus rf_environment example,10,[],https://github.com/contiki-os/contiki/pull/2216,https://github.com/herjulf,1,https://github.com/contiki-os/contiki/pull/2216,"Missing set/get CCA functions for Atmel radio.
Also rf_environment example.
Non-intrusive monitoring of the RF-environment
rf_environment runs the clear channel assessment (CCA) test over all 802.15.4 channels and reports stats per channel. The CCA test is run for different CCA thresholds from -60dBm to -90dBm. CCA is
a non-destructive for the rf-environment as it's just listens. Best and worst channel is printed as average rf activity. Probability for not passing a CCA check in percent per channel. 3-minute samples.","Missing set/get CCA functions for Atmel radio.
Also rf_environment example.
Non-intrusive monitoring of the RF-environment
rf_environment runs the clear channel assessment (CCA) test over all 802.15.4 channels and reports stats per channel. The CCA test is run for different CCA thresholds from -60dBm to -90dBm. CCA is
a non-destructive for the rf-environment as it's just listens. Best and worst channel is printed as average rf activity. Probability for not passing a CCA check in percent per channel. 3-minute samples.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2217,2017-05-09T08:12:22Z,2017-06-01T12:22:09Z,2017-06-02T13:17:58Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Fix Doxygen PPA location,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/2217,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/2217,This pull fixes the current travis build failure by changing the PPA for Doxygen,This pull fixes the current travis build failure by changing the PPA for Doxygen,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2217,2017-05-09T08:12:22Z,2017-06-01T12:22:09Z,2017-06-02T13:17:58Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Fix Doxygen PPA location,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/2217,https://github.com/herjulf,2,https://github.com/contiki-os/contiki/pull/2217#issuecomment-305474799,This pull fixes the current travis build failure by changing the PPA for Doxygen,"Hello,
This fixes the travis doxigen fails?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2217,2017-05-09T08:12:22Z,2017-06-01T12:22:09Z,2017-06-02T13:17:58Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Fix Doxygen PPA location,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/2217,https://github.com/simonduq,3,https://github.com/contiki-os/contiki/pull/2217#issuecomment-305477259,This pull fixes the current travis build failure by changing the PPA for Doxygen,yes it does üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2217,2017-05-09T08:12:22Z,2017-06-01T12:22:09Z,2017-06-02T13:17:58Z,MERGED,True,1,1,1,https://github.com/g-oikonomou,Fix Doxygen PPA location,1,"['bug', 'travis']",https://github.com/contiki-os/contiki/pull/2217,https://github.com/herjulf,4,https://github.com/contiki-os/contiki/pull/2217#issuecomment-305485499,This pull fixes the current travis build failure by changing the PPA for Doxygen,Thanks. The maintainers just wanted to rest for a while. :),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2222,2017-05-11T08:01:06Z,,2020-02-01T12:25:32Z,OPEN,False,34655,5127,211,https://github.com/mnsabagwa,RF256RF2 receive test,110,[],https://github.com/contiki-os/contiki/pull/2222,https://github.com/mnsabagwa,1,https://github.com/contiki-os/contiki/pull/2222,bc.c from ATMEGA128RFA1 adapted for ATMEGA256RFR2. Debug version.,bc.c from ATMEGA128RFA1 adapted for ATMEGA256RFR2. Debug version.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2223,2017-05-12T15:13:32Z,2017-10-10T08:51:27Z,2017-10-10T08:51:27Z,CLOSED,False,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors.,4,[],https://github.com/contiki-os/contiki/pull/2223,https://github.com/posjodin,1,https://github.com/contiki-os/contiki/pull/2223,Platform-specific files for avr-rss2.,Platform-specific files for avr-rss2.,True,{'THUMBS_UP': ['https://github.com/herjulf']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2223,2017-05-12T15:13:32Z,2017-10-10T08:51:27Z,2017-10-10T08:51:27Z,CLOSED,False,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors.,4,[],https://github.com/contiki-os/contiki/pull/2223,https://github.com/herjulf,2,https://github.com/contiki-os/contiki/pull/2223#issuecomment-310851750,Platform-specific files for avr-rss2.,And after reading up about different air-quality projects I see the Plantower PMSX003 dust sensors are getting widely used. So having a driver is an advantage. The driver should work for most models.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2223,2017-05-12T15:13:32Z,2017-10-10T08:51:27Z,2017-10-10T08:51:27Z,CLOSED,False,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors.,4,[],https://github.com/contiki-os/contiki/pull/2223,https://github.com/herjulf,3,https://github.com/contiki-os/contiki/pull/2223#issuecomment-323048035,Platform-specific files for avr-rss2.,"You have not added the latest update of the duty cycling patches?
And the review of the PMS5003 sensor seems very interesting. So driver comes in handy...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2223,2017-05-12T15:13:32Z,2017-10-10T08:51:27Z,2017-10-10T08:51:27Z,CLOSED,False,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors.,4,[],https://github.com/contiki-os/contiki/pull/2223,https://github.com/posjodin,4,https://github.com/contiki-os/contiki/pull/2223#issuecomment-324861055,Platform-specific files for avr-rss2.,"I made an update with revised logic for duty cycling with runtime-configurable timers. It also adds support for reading dust size counters for sensors that have that (PMS5003, at least).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2223,2017-05-12T15:13:32Z,2017-10-10T08:51:27Z,2017-10-10T08:51:27Z,CLOSED,False,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors.,4,[],https://github.com/contiki-os/contiki/pull/2223,https://github.com/posjodin,5,https://github.com/contiki-os/contiki/pull/2223#issuecomment-324866624,Platform-specific files for avr-rss2.,It seems that a Travis check fails with a Java error in Cooja. Not much I can do about that I guess.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2223,2017-05-12T15:13:32Z,2017-10-10T08:51:27Z,2017-10-10T08:51:27Z,CLOSED,False,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors.,4,[],https://github.com/contiki-os/contiki/pull/2223,https://github.com/posjodin,6,https://github.com/contiki-os/contiki/pull/2223#issuecomment-335405582,Platform-specific files for avr-rss2.,Rebased and resubmitted as PR #2347.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2226,2017-05-16T06:55:41Z,,2017-06-15T14:50:21Z,OPEN,False,3,1,1,https://github.com/niziak,native: fix 100% CPU usage when started from systemd,1,[],https://github.com/contiki-os/contiki/pull/2226,https://github.com/niziak,1,https://github.com/contiki-os/contiki/pull/2226,"systemd starts process with stdin redirected to /dev/null.
In this case we shouldn't read from stdin.","systemd starts process with stdin redirected to /dev/null.
In this case we shouldn't read from stdin.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2226,2017-05-16T06:55:41Z,,2017-06-15T14:50:21Z,OPEN,False,3,1,1,https://github.com/niziak,native: fix 100% CPU usage when started from systemd,1,[],https://github.com/contiki-os/contiki/pull/2226,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2226#issuecomment-308754327,"systemd starts process with stdin redirected to /dev/null.
In this case we shouldn't read from stdin.","A possible concern here is that isatty() will exclude more than just /dev/null. For example, some may wish to use pipes or files as standard input. Perhaps we need to check more information regarding the file descriptor; e.g., involving a call to fstat() and looking the st_mode field of the stat structure.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2228,2017-05-19T22:17:30Z,2017-09-25T12:28:45Z,2017-09-25T12:28:45Z,MERGED,True,6,4,1,https://github.com/alexandruioanp,Terminate websocket strings,1,[],https://github.com/contiki-os/contiki/pull/2228,https://github.com/alexandruioanp,1,https://github.com/contiki-os/contiki/pull/2228,"Explicitly terminate the field strings when registering a websocket client.
Spotted by @ArthurTaggart using Coverity.","Explicitly terminate the field strings when registering a websocket client.
Spotted by @ArthurTaggart using Coverity.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2228,2017-05-19T22:17:30Z,2017-09-25T12:28:45Z,2017-09-25T12:28:45Z,MERGED,True,6,4,1,https://github.com/alexandruioanp,Terminate websocket strings,1,[],https://github.com/contiki-os/contiki/pull/2228,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2228#issuecomment-317251965,"Explicitly terminate the field strings when registering a websocket client.
Spotted by @ArthurTaggart using Coverity.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2228,2017-05-19T22:17:30Z,2017-09-25T12:28:45Z,2017-09-25T12:28:45Z,MERGED,True,6,4,1,https://github.com/alexandruioanp,Terminate websocket strings,1,[],https://github.com/contiki-os/contiki/pull/2228,https://github.com/adamdunkels,3,https://github.com/contiki-os/contiki/pull/2228#issuecomment-317632948,"Explicitly terminate the field strings when registering a websocket client.
Spotted by @ArthurTaggart using Coverity.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2231,2017-05-23T23:17:15Z,,2017-05-23T23:17:43Z,OPEN,False,2,0,2,https://github.com/casaroli,"cc26xx-web-demo: ""fix warning: implicit declaration of function 'strncasecmp'""",1,[],https://github.com/contiki-os/contiki/pull/2231,https://github.com/casaroli,1,https://github.com/contiki-os/contiki/pull/2231,this fixes two warnings adding #include <strings.h> to two more files for the examples to compile cleanly with gcc-arm-none-eabi-5_4-2016q3,this fixes two warnings adding #include <strings.h> to two more files for the examples to compile cleanly with gcc-arm-none-eabi-5_4-2016q3,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2232,2017-05-23T23:34:12Z,,2017-06-20T22:09:32Z,OPEN,False,24,24,74,https://github.com/casaroli,"rename ""srf06-cc26xx"" to ""cc26xx""",1,[],https://github.com/contiki-os/contiki/pull/2232,https://github.com/casaroli,1,https://github.com/contiki-os/contiki/pull/2232,"This simply renames the srf06-cc26xx platform by renaming files and replacing all occurrences of ""srf06-cc26xx"" with just ""cc26xx"".
Using ""srf06"" in the platform name is misleading when used in other platforms such as the launchpad.
This has already been discussed in the past http://contiki-developers.narkive.com/ASbH7YQr/rename-platform-srf06-cc26xx
So, here is the PR. I hope it does gets accepted. :)
Thanks","This simply renames the srf06-cc26xx platform by renaming files and replacing all occurrences of ""srf06-cc26xx"" with just ""cc26xx"".
Using ""srf06"" in the platform name is misleading when used in other platforms such as the launchpad.
This has already been discussed in the past http://contiki-developers.narkive.com/ASbH7YQr/rename-platform-srf06-cc26xx
So, here is the PR. I hope it does gets accepted. :)
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2232,2017-05-23T23:34:12Z,,2017-06-20T22:09:32Z,OPEN,False,24,24,74,https://github.com/casaroli,"rename ""srf06-cc26xx"" to ""cc26xx""",1,[],https://github.com/contiki-os/contiki/pull/2232,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/2232#issuecomment-309906050,"This simply renames the srf06-cc26xx platform by renaming files and replacing all occurrences of ""srf06-cc26xx"" with just ""cc26xx"".
Using ""srf06"" in the platform name is misleading when used in other platforms such as the launchpad.
This has already been discussed in the past http://contiki-developers.narkive.com/ASbH7YQr/rename-platform-srf06-cc26xx
So, here is the PR. I hope it does gets accepted. :)
Thanks","Would it not make more sense to rename this to cc26xx-cc13xx or something similar to indicate that it actually holds both platforms? With this PR you would get conterintuitive situations like
make PLATFORM=cc26xx BOARD=launchpad/cc1310",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2235,2017-05-31T08:42:30Z,,2017-06-06T07:35:19Z,OPEN,False,40,24,2,https://github.com/kkrentz,Fix to nbr-table,1,[],https://github.com/contiki-os/contiki/pull/2235,https://github.com/kkrentz,1,https://github.com/contiki-os/contiki/pull/2235,"I came across a problem in nbr-table, which may prevent adding new neighbors at some point. Specifically, if RPL's policy for freeing neighbor slots gets an unknown reason, such as NBR_TABLE_REASON_MAC, it returns NULL. As a result, nbr-table thinks that it may not remove any neighbor. Ultimately, this may result in a deadlock, e.g., if the MAC layer can not add further neighbors. I therefore added an additional parameter that governs whether nbr-table may resort to its normal policy for freeing neighbor slots.
BTW, another strange behavior of nbr-table is that it also deletes locked neighbors if RPL's policy says so.","I came across a problem in nbr-table, which may prevent adding new neighbors at some point. Specifically, if RPL's policy for freeing neighbor slots gets an unknown reason, such as NBR_TABLE_REASON_MAC, it returns NULL. As a result, nbr-table thinks that it may not remove any neighbor. Ultimately, this may result in a deadlock, e.g., if the MAC layer can not add further neighbors. I therefore added an additional parameter that governs whether nbr-table may resort to its normal policy for freeing neighbor slots.
BTW, another strange behavior of nbr-table is that it also deletes locked neighbors if RPL's policy says so.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2236,2017-05-31T08:51:32Z,,2017-07-27T12:49:02Z,OPEN,False,5,14,1,https://github.com/kkrentz,Fix to rtimer,1,[],https://github.com/contiki-os/contiki/pull/2236,https://github.com/kkrentz,1,https://github.com/contiki-os/contiki/pull/2236,"I noticed that rtimer_arch_schedule gets called twice if rtimer_set is called from within the rtimer ISR, which is often the case. This PR fixes this issue.","I noticed that rtimer_arch_schedule gets called twice if rtimer_set is called from within the rtimer ISR, which is often the case. This PR fixes this issue.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2236,2017-05-31T08:51:32Z,,2017-07-27T12:49:02Z,OPEN,False,5,14,1,https://github.com/kkrentz,Fix to rtimer,1,[],https://github.com/contiki-os/contiki/pull/2236,https://github.com/awolokita,2,https://github.com/contiki-os/contiki/pull/2236#issuecomment-318351990,"I noticed that rtimer_arch_schedule gets called twice if rtimer_set is called from within the rtimer ISR, which is often the case. This PR fixes this issue.",This patch helps quite a bit with avoiding missed slots when scheduling slots in TSCH.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2237,2017-05-31T17:37:17Z,,2017-07-23T13:08:56Z,OPEN,False,2,2,1,https://github.com/alexandruioanp,Fix UIP buffer overrun,1,[],https://github.com/contiki-os/contiki/pull/2237,https://github.com/alexandruioanp,1,https://github.com/contiki-os/contiki/pull/2237,"When copying data to the uip buffer, the size of the MTU was checked,
but not the size of the actual buffer. Each platform can set this size
to a different value (often times smaller than the MTU). This would
results in an overrun when creating an ICMPv6 error packet.
Caught by @jackmcbride using CodeSonar, and described by @tonnenpinguin in #2186.","When copying data to the uip buffer, the size of the MTU was checked,
but not the size of the actual buffer. Each platform can set this size
to a different value (often times smaller than the MTU). This would
results in an overrun when creating an ICMPv6 error packet.
Caught by @jackmcbride using CodeSonar, and described by @tonnenpinguin in #2186.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2237,2017-05-31T17:37:17Z,,2017-07-23T13:08:56Z,OPEN,False,2,2,1,https://github.com/alexandruioanp,Fix UIP buffer overrun,1,[],https://github.com/contiki-os/contiki/pull/2237,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2237#issuecomment-317251992,"When copying data to the uip buffer, the size of the MTU was checked,
but not the size of the actual buffer. Each platform can set this size
to a different value (often times smaller than the MTU). This would
results in an overrun when creating an ICMPv6 error packet.
Caught by @jackmcbride using CodeSonar, and described by @tonnenpinguin in #2186.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2244,2017-06-02T22:03:04Z,2017-06-02T23:00:23Z,2017-06-02T23:00:27Z,MERGED,True,5,47,2,https://github.com/g-oikonomou,"Revert ""Validate MQTT broker IP and escape quotes when displaying""",1,[],https://github.com/contiki-os/contiki/pull/2244,https://github.com/g-oikonomou,1,https://github.com/contiki-os/contiki/pull/2244,Reverts #2213,Reverts #2213,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2245,2017-06-02T22:53:01Z,2017-06-03T12:28:23Z,2017-06-03T12:28:23Z,MERGED,True,52,5,2,https://github.com/alexstanoev,Validate MQTT broker IP and escape quotes when displaying,1,[],https://github.com/contiki-os/contiki/pull/2245,https://github.com/alexstanoev,1,https://github.com/contiki-os/contiki/pull/2245,"This pull request implements address validation for the broker address in the MQTT configuration page of the CC26XX web demo example. Additionally, the Type ID, Org ID, Auth Token, Command Type and Event Type ID fields have quotes escaped ("" -> "") to prevent XSS/broken page issues when displaying user-sourced input in HTML input fields.
This pull includes several changes which were accidentally removed from 2213.","This pull request implements address validation for the broker address in the MQTT configuration page of the CC26XX web demo example. Additionally, the Type ID, Org ID, Auth Token, Command Type and Event Type ID fields have quotes escaped ("" -> "") to prevent XSS/broken page issues when displaying user-sourced input in HTML input fields.
This pull includes several changes which were accidentally removed from 2213.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2249,2017-06-14T16:10:57Z,2017-06-15T12:56:59Z,2017-06-15T12:56:59Z,MERGED,True,13,0,1,https://github.com/nfi,Added boundary checks when parsing CoAP packets.,1,[],https://github.com/contiki-os/contiki/pull/2249,https://github.com/nfi,1,https://github.com/contiki-os/contiki/pull/2249,"This should address the issues reported in #2238, #2239 and #2240. Thanks to Stephan Zeisberg for reporting the issues and for the excellent test cases.","This should address the issues reported in #2238, #2239 and #2240. Thanks to Stephan Zeisberg for reporting the issues and for the excellent test cases.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2249,2017-06-14T16:10:57Z,2017-06-15T12:56:59Z,2017-06-15T12:56:59Z,MERGED,True,13,0,1,https://github.com/nfi,Added boundary checks when parsing CoAP packets.,1,[],https://github.com/contiki-os/contiki/pull/2249,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2249#issuecomment-308721580,"This should address the issues reported in #2238, #2239 and #2240. Thanks to Stephan Zeisberg for reporting the issues and for the excellent test cases.",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2249,2017-06-14T16:10:57Z,2017-06-15T12:56:59Z,2017-06-15T12:56:59Z,MERGED,True,13,0,1,https://github.com/nfi,Added boundary checks when parsing CoAP packets.,1,[],https://github.com/contiki-os/contiki/pull/2249,https://github.com/nvt,3,https://github.com/contiki-os/contiki/pull/2249#issuecomment-308721678,"This should address the issues reported in #2238, #2239 and #2240. Thanks to Stephan Zeisberg for reporting the issues and for the excellent test cases.","With this fix, there is no longer a segmentation fault for any of the three mentioned issues.",True,{'THUMBS_UP': ['https://github.com/stze']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,1,https://github.com/contiki-os/contiki/pull/2250,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur",True,"{'THUMBS_UP': ['https://github.com/ngovanmao', 'https://github.com/tonnenpinguin']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Tidone,2,https://github.com/contiki-os/contiki/pull/2250#issuecomment-311591973,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Hello,
first of all, thank you for your ble stack.
Unfortunately we can't get it to work on our devices.
I used the current contiki main-branch and your pr, together with a sensortag and a launchpad.
We used your ble-gatt-demo to try to connect to the motes.
I also used the nordic nrf app to read the sensor values (Android 7.1.2) and tried to disable the sensors one by one (temp, humidity, pressure, ...).
The app can connect to the sensortag, but when it tries to discover the services, nothing happens anymore.
To get some output I enabled the debugging outputs in rf-core.c, ble-mode.c, ble-hal-cc26xx.c and rf-ble-cmd.c
Relevant output:
command status: 0x0001; connection event counter: 0
command_status_flags: crc_err: 0, ignored: 0, md: 0, ack: 0
rf_ble_cmd_send() could not send cmd
CMDSTA: SCHEDULING_ERR
Status: IDLE
connection error; event counter: 1
Slave command
command status: 0x1401; connection event counter: 1
command_status_flags: crc_err: 0, ignored: 0, md: 0, ack: 0
Slave command
Data type : 0
received control LL
feature request
Slave command
Slave command
Data type : 0
received control LL
Version ind
Slave command
Slave command
Data type : 0
received control LL
parse_ll_ctrl_msg() opcode: 0x00 received
Slave command
Data type : 0
received DATA LL
GET GROUP
ble-mode send() 18 bytes
Slave command
Slave command
Data type : 0
received DATA LL
GET GROUP
ble-mode send() 18 bytes
Slave command
Slave command
Data type : 0
received DATA LL
GET GROUP
ble-mode send() 12 bytes
Slave command
Slave command
Data type : 0
received DATA LL
GET GROUP
ble-mode send() 9 bytes
command status: 0x1401; connection event counter: 15
command_status_flags: crc_err: 0, ignored: 0, md: 0, ack: 1
Slave command

After that the last three lines are repeated hundreds of times and the event counter is incremented each time.
Can you help us getting yout pull request to work?
I attached the full log in case you need it.
output_2017-06-28_10-05-23.zip",True,"{'THUMBS_UP': ['https://github.com/tonnenpinguin', 'https://github.com/Cyfell']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,3,https://github.com/contiki-os/contiki/pull/2250#issuecomment-311599082,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Thanks for trying ! :)
I don't have a launchpad for testing but as far as i can see the BLE connection hold the link and radio packet are well sent. in general when i get nothing by the nordic application it's because one data sent by the Sensortag isn't well formed... I will rerun tests and keep you updated",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,4,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312197820,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Hi Tidone, every thing works well on my side, can you enable logs on ble-att.c, gatt.c, ble-mac.c and give me the result ? Also can you try with BlueZ stack ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Tidone,5,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312234937,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Here is the output with logs enabled.
output_2017-06-30_11-50-47.zip
Unfortunately we don't have a PC, laptop, or bluetooth stick, which support BLE, so we can't test with BlueZ.
In the meantime I tested your example with a different phone with Android 6, but the error stays the same.
Are you also using the latest contiki main branch? If not, can you try your pull request with vanilla contiki?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,6,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312282634,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","I cleaned all and started from fresh contiki + PR and it works... If you have you wifi on, it can interfering with BLE on the phone, I think you have a lot of
command status: 0x1401; connection event counter: 19 command_status_flags: crc_err: 0, ignored: 0, md: 0, ack: 1
becouse of that, try without. And disable all sensors in gatt_config (there will always be two generic GATT attributes to show on nordic app)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Tidone,7,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312297013,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Thank you, I will try again on monday and keep you updated.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Tidone,8,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312569511,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Still no luck.
This time I turned off Wifi and our 6lowpan-router, but the result is still the same.
I uploaded the binary for the sensortag. Can you test it on your hardware to rule out software/compiler bugs?
Can you also upload a working version so I can test it on my hardware?
ble-gatt-demo.zip",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,9,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312821747,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","it works well on my side with your bin file...(it's quite frustrating xD)
here is mine :
ble-gatt-demo.zip
maybe its an android problem, or my stack has a problem not handled with my android version but corrected with yours.... I dont have an other phone for testing...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,10,https://github.com/contiki-os/contiki/pull/2250#issuecomment-312836631,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","ok i found an android 7.X phone and effectively it does the same as you... 0x1401 means that the reply from the phone doesn't come back in the time window defined in the sensortag (or doesn't come back at all).
you can found more info maybe here http://www.ti.com/lit/ug/swcu117g/swcu117g.pdf page 1661
a bit of this error is not dramatic but in this case it prevent the phone to communicate with the Sensortag.
at first I think the error come from rf-ble-cmd.c...
I'm not very available this week to investigate this problem...",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/tonnenpinguin,11,https://github.com/contiki-os/contiki/pull/2250#issuecomment-318110832,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur","Hi @Cyfell!
Did you get a chance to look into this issue?
Is there any way one can help to move this forward?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2250,2017-06-16T15:37:21Z,2017-12-14T08:33:20Z,2017-12-14T08:33:20Z,CLOSED,False,8329,17,54,https://github.com/Cyfell,Cc2650 ble stack,11,[],https://github.com/contiki-os/contiki/pull/2250,https://github.com/Cyfell,12,https://github.com/contiki-os/contiki/pull/2250#issuecomment-351642881,"Hi all,
I'm proposing a Bluetooth Low Energy stack for Contiki and CC2650.
I started with Spoerk's pull request (c2f8b58) for implementing ATT protocol and GATT over it.
ATT protocol is not fully implemented but the main functionalities are here.
I have tested with gatttool from BlueZ and it works very well. I can access all sensors values and getting update notifications.
I have also tested with a nexus phone (Android 4.4) and ""nordic nrf connect"" application. For a good running of the application,  I had to disable two sensors among temp, humidity and pressure.
Part of the stack is under core/ but is not cpu dependant for now because the sensor API is sensor dependant...
ATT functionalities implemented are :

ATT_ERROR_RESPONSE is used to state that a given request cannot be performed, and to provide the reason.
ATT_MTU_RESPONSE is sent in reply to a received Exchange MTU Request.
ATT_INFORMATION_RESPONSE contains the correlation between handles and uuids.
ATT_READ_BY_TYPE_RESPONSE contains multiple attributes values.
ATT_READ_RESPONSE contains the value of one attribute.
ATT_READ_BY_GROUP_TYPE_RESPONSE contains multiple attributes values and the end of the current group.
ATT_WRITE_RESPONSE used as acknowledgement of  ATT_WRITE_REQUEST, in order to modificate one attribute value.
ATT_HANDLE_VALUE_INDICATION contains a value notification of one attribute.

GATT profile is as follow :

Generic access (contains device name)
Information service (contains Contiki version)
Battery service
Environmental sensors (contains Temperature, Humidity and Barometer sensors)
Luxometer sensor
MPU sensor
LED control
Buttons sensors
Reed relay sensor

This GATT organisation is modular so you can remove sensors expositions like you want.
Thank you for looking at it. I stay open for any comment or way of improvements.
Arthur",It will be back...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2251,2017-06-17T21:36:08Z,2017-06-22T14:41:55Z,2017-06-22T14:41:55Z,MERGED,True,29,30,6,https://github.com/arurke,Minor cleanup to RPL debug output,2,[],https://github.com/contiki-os/contiki/pull/2251,https://github.com/arurke,1,https://github.com/contiki-os/contiki/pull/2251,Cleans up some annoying anomalies I noticed while debugging RPL.,Cleans up some annoying anomalies I noticed while debugging RPL.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2251,2017-06-17T21:36:08Z,2017-06-22T14:41:55Z,2017-06-22T14:41:55Z,MERGED,True,29,30,6,https://github.com/arurke,Minor cleanup to RPL debug output,2,[],https://github.com/contiki-os/contiki/pull/2251,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2251#issuecomment-310401119,Cleans up some annoying anomalies I noticed while debugging RPL.,üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2254,2017-06-20T11:28:54Z,,2017-06-21T07:36:26Z,OPEN,False,1,1,1,https://github.com/bschwand,fix overflow in RPL timer,1,[],https://github.com/contiki-os/contiki/pull/2254,https://github.com/bschwand,1,https://github.com/contiki-os/contiki/pull/2254,"when RPL_CONF_DIO_INTERVAL_MIN + RPL_CONF_DIO_INTERVAL_DOUBLINGS
is large, leading to DIO spamming because the calculated timer
interval would be too small","when RPL_CONF_DIO_INTERVAL_MIN + RPL_CONF_DIO_INTERVAL_DOUBLINGS
is large, leading to DIO spamming because the calculated timer
interval would be too small",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2259,2017-06-30T01:00:00Z,2017-07-23T13:06:51Z,2017-07-23T13:06:51Z,MERGED,True,16,6,1,https://github.com/arurke,CC26xx/CC13xx: Support uni-directional UART,1,[],https://github.com/contiki-os/contiki/pull/2259,https://github.com/arurke,1,https://github.com/contiki-os/contiki/pull/2259,"This PR removes the requirement for both UART TX and RX to be set, thus adding support for boards which only have one or the other.","This PR removes the requirement for both UART TX and RX to be set, thus adding support for boards which only have one or the other.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2262,2017-07-11T01:00:01Z,2022-02-24T20:10:55Z,2022-02-24T20:10:55Z,CLOSED,False,6,1,1,https://github.com/drudru,Make explicit the maximum in the function doc,1,[],https://github.com/contiki-os/contiki/pull/2262,https://github.com/drudru,1,https://github.com/contiki-os/contiki/pull/2262,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2263,2017-07-11T13:51:28Z,,2017-07-28T06:46:26Z,OPEN,False,1,3,1,https://github.com/posjodin,Fixed issues with MQTT keep alive timer,1,[],https://github.com/contiki-os/contiki/pull/2263,https://github.com/posjodin,1,https://github.com/contiki-os/contiki/pull/2263,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2263,2017-07-11T13:51:28Z,,2017-07-28T06:46:26Z,OPEN,False,1,3,1,https://github.com/posjodin,Fixed issues with MQTT keep alive timer,1,[],https://github.com/contiki-os/contiki/pull/2263,https://github.com/alexandruioanp,2,https://github.com/contiki-os/contiki/pull/2263#issuecomment-318186006,,This looks okay. The missing ctimer_restart is a good catch. What issues were you encountering that required the changes in disconnect_tcp?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2263,2017-07-11T13:51:28Z,,2017-07-28T06:46:26Z,OPEN,False,1,3,1,https://github.com/posjodin,Fixed issues with MQTT keep alive timer,1,[],https://github.com/contiki-os/contiki/pull/2263,https://github.com/posjodin,3,https://github.com/contiki-os/contiki/pull/2263#issuecomment-318574743,,"The issue with disconnect_tcp() is that after a keepalive timeout, MQTT ends up in a stale state where nothing happens.
In the original code, disconnect_tcp() clears the socket structure without waiting for TCP to close.
Then there will be no more events to keep the state machine going. By just calling tcp_socket_close() instead, without wiping the socket, there will be a callback event from TCP when the socket has been closed, which will trigger MQTT to reconnect.
It's only the keepalive timer that uses disconnect_tcp(), by the way.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2265,2017-07-13T21:47:32Z,,2017-08-04T09:28:21Z,OPEN,False,10,4,2,https://github.com/lanwan,sync code,1,[],https://github.com/contiki-os/contiki/pull/2265,https://github.com/lanwan,1,https://github.com/contiki-os/contiki/pull/2265,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2265,2017-07-13T21:47:32Z,,2017-08-04T09:28:21Z,OPEN,False,10,4,2,https://github.com/lanwan,sync code,1,[],https://github.com/contiki-os/contiki/pull/2265,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2265#issuecomment-316332026,,"IMHO this check should optional, and selectable for release and debug stages.
possibly this checks could print failure, since c->u == NULL  not normal for most cases.
possibly better introduce CONF macro with behaviour of check",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2265,2017-07-13T21:47:32Z,,2017-08-04T09:28:21Z,OPEN,False,10,4,2,https://github.com/lanwan,sync code,1,[],https://github.com/contiki-os/contiki/pull/2265,https://github.com/greg-king5,3,https://github.com/contiki-os/contiki/pull/2265#issuecomment-316448770,,"""c->u == NULL"" can be normal.  If a ""connection"" only transmits, and one doesn't need to know when the packets actually are sent, then the callbacks aren't needed.  Therefore, the connection would be openned with a NULL as the callback argument.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2265,2017-07-13T21:47:32Z,,2017-08-04T09:28:21Z,OPEN,False,10,4,2,https://github.com/lanwan,sync code,1,[],https://github.com/contiki-os/contiki/pull/2265,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2265#issuecomment-316640666,,"agree, but is it general situation? on examples a saw - all connections have callbacks.
thus my mention can be reclasified to:  selectable for generic and full defined applications. Where full defined - have all connections with callbacks, and threfore a bit more optimised.
this economy is small - a few bytes of code, a few tacts for cpu. for avr, msp430 mcu it can be sufficient.
but maybe it negligible, to have more work on this patch.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2265,2017-07-13T21:47:32Z,,2017-08-04T09:28:21Z,OPEN,False,10,4,2,https://github.com/lanwan,sync code,1,[],https://github.com/contiki-os/contiki/pull/2265,https://github.com/alexrayne,5,https://github.com/contiki-os/contiki/pull/2265#issuecomment-320203312,,"lanwan, you post it patch from ""unknown repository"", can you publish it on you public repos, where i can take it?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2271,2017-07-31T15:16:44Z,,2017-08-02T13:02:40Z,OPEN,False,19,1,1,https://github.com/alexrayne,make for —Å—Å26-13 generates hex only if  srec exist,3,[],https://github.com/contiki-os/contiki/pull/2271,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2271,"hex generate only if srec_cat exist. this patch helps avoid make errors if srecord absent.
*when build on windows host, there are hard to achieve srecord. and now this is not a problem - elf images, and binaries are enough. So, with this patch hex generation just ignored, and make - success","hex generate only if srec_cat exist. this patch helps avoid make errors if srecord absent.
*when build on windows host, there are hard to achieve srecord. and now this is not a problem - elf images, and binaries are enough. So, with this patch hex generation just ignored, and make - success",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2272,2017-07-31T15:17:58Z,,2017-07-31T15:17:58Z,OPEN,False,11,1,1,https://github.com/alexrayne,fix make deps generation on windows,1,[],https://github.com/contiki-os/contiki/pull/2272,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2272,"fixed FINALIZE_DEPENDENCY to work with windows pathes. need to build on cygwin.
*just suggest that dep item starts with single path until "": "" delimiter. this rule helps
accept windows path starts with drive letter ""x:""","fixed FINALIZE_DEPENDENCY to work with windows pathes. need to build on cygwin.
*just suggest that dep item starts with single path until "": "" delimiter. this rule helps
accept windows path starts with drive letter ""x:""",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2273,2017-07-31T15:33:08Z,,2018-05-14T09:31:59Z,OPEN,False,841,263,8,https://github.com/alexrayne,enhance cc26 prop-mode rf-core to support tsch,27,[],https://github.com/contiki-os/contiki/pull/2273,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2273,"Here is an set of patches, for cc26xx prop-mode rf-core driver, that provides minimal functionality enough for TSCH.

for aside work - was deployed RAT timer syncronise-monitor code from ieee-mode driver into stanalone object rf-rat-monitor.
optimised set_value operation for speed - now it not on/off rf-core if one powerdowned. this gives speed effort this method. this affects radio-chanel and tx-power setup parameters.
appends agressive RAT sync checking mode - this will checks that retrieved rx-operation timestamp is valid, and if not - checks sincronisation of RAT vs RTtimer.
a bit optimised code for size
provides lightweight TX power change - nothing to do if  no actial changes need.
provide config RF_CORE_CONF_PENDING - style as pending_packets calculates. new style RF_CORE_PENDING_READS provides calculation of packets that surely can be read(xxx).","Here is an set of patches, for cc26xx prop-mode rf-core driver, that provides minimal functionality enough for TSCH.

for aside work - was deployed RAT timer syncronise-monitor code from ieee-mode driver into stanalone object rf-rat-monitor.
optimised set_value operation for speed - now it not on/off rf-core if one powerdowned. this gives speed effort this method. this affects radio-chanel and tx-power setup parameters.
appends agressive RAT sync checking mode - this will checks that retrieved rx-operation timestamp is valid, and if not - checks sincronisation of RAT vs RTtimer.
a bit optimised code for size
provides lightweight TX power change - nothing to do if  no actial changes need.
provide config RF_CORE_CONF_PENDING - style as pending_packets calculates. new style RF_CORE_PENDING_READS provides calculation of packets that surely can be read(xxx).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2273,2017-07-31T15:33:08Z,,2018-05-14T09:31:59Z,OPEN,False,841,263,8,https://github.com/alexrayne,enhance cc26 prop-mode rf-core to support tsch,27,[],https://github.com/contiki-os/contiki/pull/2273,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2273#issuecomment-347214053,"Here is an set of patches, for cc26xx prop-mode rf-core driver, that provides minimal functionality enough for TSCH.

for aside work - was deployed RAT timer syncronise-monitor code from ieee-mode driver into stanalone object rf-rat-monitor.
optimised set_value operation for speed - now it not on/off rf-core if one powerdowned. this gives speed effort this method. this affects radio-chanel and tx-power setup parameters.
appends agressive RAT sync checking mode - this will checks that retrieved rx-operation timestamp is valid, and if not - checks sincronisation of RAT vs RTtimer.
a bit optimised code for size
provides lightweight TX power change - nothing to do if  no actial changes need.
provide config RF_CORE_CONF_PENDING - style as pending_packets calculates. new style RF_CORE_PENDING_READS provides calculation of packets that surely can be read(xxx).","added hotfix for  ightweight TX power change.
also add conf RF_CORE_CONF_PENDING - denotes behaviour, how pending_packets are calculated. old behaviour of pending_packet was not the same as for read packet. that is why possibility to have some buffered packets, but read cant get anything. this situation leads strange errors.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2273,2017-07-31T15:33:08Z,,2018-05-14T09:31:59Z,OPEN,False,841,263,8,https://github.com/alexrayne,enhance cc26 prop-mode rf-core to support tsch,27,[],https://github.com/contiki-os/contiki/pull/2273,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2273#issuecomment-352016238,"Here is an set of patches, for cc26xx prop-mode rf-core driver, that provides minimal functionality enough for TSCH.

for aside work - was deployed RAT timer syncronise-monitor code from ieee-mode driver into stanalone object rf-rat-monitor.
optimised set_value operation for speed - now it not on/off rf-core if one powerdowned. this gives speed effort this method. this affects radio-chanel and tx-power setup parameters.
appends agressive RAT sync checking mode - this will checks that retrieved rx-operation timestamp is valid, and if not - checks sincronisation of RAT vs RTtimer.
a bit optimised code for size
provides lightweight TX power change - nothing to do if  no actial changes need.
provide config RF_CORE_CONF_PENDING - style as pending_packets calculates. new style RF_CORE_PENDING_READS provides calculation of packets that surely can be read(xxx).","More work on reqcv que handling - sometimes my cc1310 looks leave curents slot in PENDING state, and goes to next. read_frame() stalls on this slot. so RF_CORE_PENDING_READSANY mode provided for this - read_frame scans all que, skips PENDING slots until FINISHED one.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2273,2017-07-31T15:33:08Z,,2018-05-14T09:31:59Z,OPEN,False,841,263,8,https://github.com/alexrayne,enhance cc26 prop-mode rf-core to support tsch,27,[],https://github.com/contiki-os/contiki/pull/2273,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2273#issuecomment-387087862,"Here is an set of patches, for cc26xx prop-mode rf-core driver, that provides minimal functionality enough for TSCH.

for aside work - was deployed RAT timer syncronise-monitor code from ieee-mode driver into stanalone object rf-rat-monitor.
optimised set_value operation for speed - now it not on/off rf-core if one powerdowned. this gives speed effort this method. this affects radio-chanel and tx-power setup parameters.
appends agressive RAT sync checking mode - this will checks that retrieved rx-operation timestamp is valid, and if not - checks sincronisation of RAT vs RTtimer.
a bit optimised code for size
provides lightweight TX power change - nothing to do if  no actial changes need.
provide config RF_CORE_CONF_PENDING - style as pending_packets calculates. new style RF_CORE_PENDING_READS provides calculation of packets that surely can be read(xxx).","fixed bad sync RAT - RTC when current time is large - more then 18hours.
there was incorrect RAT overloads calculation, since used contiki RTIMER time insteard RTC 64 bit value. RF core uses 64bit value for sync.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2274,2017-07-31T15:40:26Z,,2017-07-31T15:40:26Z,OPEN,False,22,0,3,https://github.com/alexrayne,"TSCH: protect against invalid slot-time drift, caused invalid timestamps",1,[],https://github.com/contiki-os/contiki/pull/2274,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2274,"If radio-driver returns invalid timestamp on received packet, it evaluates disaster drift value. Wich cause unsync with coordinator, when applyed.
this patch add checks that drift value is in time-slot limits, and ommit drift, if it goes out of slot bounds.
    such a disaster can be caused by RAT miss-sinc. if not ommit this failed drift,
    it surely breaks slots sinchronising","If radio-driver returns invalid timestamp on received packet, it evaluates disaster drift value. Wich cause unsync with coordinator, when applyed.
this patch add checks that drift value is in time-slot limits, and ommit drift, if it goes out of slot bounds.
    such a disaster can be caused by RAT miss-sinc. if not ommit this failed drift,
    it surely breaks slots sinchronising",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2275,2017-07-31T15:42:27Z,,2017-11-02T15:44:44Z,OPEN,False,19,10,1,https://github.com/alexrayne,TSCH: frequency scan -  use task yelding instead ob blocking wait,3,[],https://github.com/contiki-os/contiki/pull/2275,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2275,"Here a bit scaner code optimised -  it now yelds on radio listening vs blocking wait


     also used explicit chanel setup on every hop, even if not change.
          this should helps when chanel changed aside","Here a bit scaner code optimised -  it now yelds on radio listening vs blocking wait


     also used explicit chanel setup on every hop, even if not change.
          this should helps when chanel changed aside",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2276,2017-07-31T15:47:30Z,,2017-08-11T13:39:21Z,OPEN,False,17,4,4,https://github.com/alexrayne,TSCH: times - add prefetching slot time for slow RF on(),2,[],https://github.com/contiki-os/contiki/pull/2276,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2276,"add guard time - prepending slot start for turn RF on.


TSCH_CONF_FRON_GUARD_TIME




this time need when too slow radio turn-on violates with tsch_ts_rx/tx_offset
timeout.
tsch_timings[tsch_ts_rfon_prepslot_guard] forces to start slot operation before slot start time,
therefore activates radio before slot start, and can be ready rigth when it need","add guard time - prepending slot start for turn RF on.


TSCH_CONF_FRON_GUARD_TIME




this time need when too slow radio turn-on violates with tsch_ts_rx/tx_offset
timeout.
tsch_timings[tsch_ts_rfon_prepslot_guard] forces to start slot operation before slot start time,
therefore activates radio before slot start, and can be ready rigth when it need",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2277,2017-07-31T15:49:35Z,,2017-08-02T07:52:59Z,OPEN,False,57,18,3,https://github.com/alexrayne,TSCH:  ACK time position estimates from receive/transmit operation end,3,[],https://github.com/contiki-os/contiki/pull/2277,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2277,"This patch gives ACK time position estimates from receive/transmit operation end  vs op-start+calculated packet time. This behaviour rejects dependence on accurate packet time calculation.
+TSCH:conf: TSCH_ACK_TIMING_STYLE - provides selection of ACK timing behaviour between new and old one.


conf: RADIO_RSSI_DETECT_DELAY - enhances ACK wait time for preamble delay, that need by receiving detection.




if radio driver realises accuracy blocking receive/send so that operation ends
right after radio packet, we can use operation end-time, instead of calculation
packet time. so ACK will be functional even with invalid packet time formula.
for RF settimgs with low baudrate, RSSI detection time can be sufficient, therefore
need enhance ACK wait time for this delay. By default calculate it as TSCH_PACKET_DURATION(0)","This patch gives ACK time position estimates from receive/transmit operation end  vs op-start+calculated packet time. This behaviour rejects dependence on accurate packet time calculation.
+TSCH:conf: TSCH_ACK_TIMING_STYLE - provides selection of ACK timing behaviour between new and old one.


conf: RADIO_RSSI_DETECT_DELAY - enhances ACK wait time for preamble delay, that need by receiving detection.




if radio driver realises accuracy blocking receive/send so that operation ends
right after radio packet, we can use operation end-time, instead of calculation
packet time. so ACK will be functional even with invalid packet time formula.
for RF settimgs with low baudrate, RSSI detection time can be sufficient, therefore
need enhance ACK wait time for this delay. By default calculate it as TSCH_PACKET_DURATION(0)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2278,2017-07-31T15:56:18Z,,2017-11-27T15:12:12Z,OPEN,False,120,34,9,https://github.com/alexrayne,TSCH: conf -  set of configuration TSCH stack,16,[],https://github.com/contiki-os/contiki/pull/2278,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2278,"Here provided configuring on TSCH capability.


can enabled/disabled Coordinator functionality via define TSCH_IS_COORDINATOR. this is eliminats code of coordinator, when TSCH_IS_COORDINATOR=0. Or eliminates scaner code, when TSCH_IS_COORDINATOR=1 If this macro not defiined, original behaviour with both functions avail.


disable generator EB :  if TSCH_EB_MAX_PERIOD==0 - beacons not sends and code for them eliminated.


disable KeepAlaves generator when TSCH_MAX_KEEPALIVE_TIMEOUT=0 -  eliminate code for  keepalives.


more flexible config TSCH_DEFAULT_TS_MAX_ACK, TSCH_DEFAULT_TS_MAX_TX via config defines TSCH_CONF_TS_MAX_TX/ACK. This allow to define timings in project config, and use predefined timings from tsch-conf.h


define TSCH_DEBUG_NO_TIMING_FROM_EB - prevents loading timings from EB. this helpful for debug.


introduced PRINTF_FAIL printer, this one intends for reducing code size, in release code. via TSCH_LOG_LEVEL < 0, code for printing failures can be eliminated.


RTIMER_GUARD_TIME - not use hardcoded guard time for slot operations, use
TSCH_CONF_RTIMER_GUARD def, or use RTIMER_GUARD_TIME provided by rtimer.h.


also provided a bit speedup TSCH code","Here provided configuring on TSCH capability.


can enabled/disabled Coordinator functionality via define TSCH_IS_COORDINATOR. this is eliminats code of coordinator, when TSCH_IS_COORDINATOR=0. Or eliminates scaner code, when TSCH_IS_COORDINATOR=1 If this macro not defiined, original behaviour with both functions avail.


disable generator EB :  if TSCH_EB_MAX_PERIOD==0 - beacons not sends and code for them eliminated.


disable KeepAlaves generator when TSCH_MAX_KEEPALIVE_TIMEOUT=0 -  eliminate code for  keepalives.


more flexible config TSCH_DEFAULT_TS_MAX_ACK, TSCH_DEFAULT_TS_MAX_TX via config defines TSCH_CONF_TS_MAX_TX/ACK. This allow to define timings in project config, and use predefined timings from tsch-conf.h


define TSCH_DEBUG_NO_TIMING_FROM_EB - prevents loading timings from EB. this helpful for debug.


introduced PRINTF_FAIL printer, this one intends for reducing code size, in release code. via TSCH_LOG_LEVEL < 0, code for printing failures can be eliminated.


RTIMER_GUARD_TIME - not use hardcoded guard time for slot operations, use
TSCH_CONF_RTIMER_GUARD def, or use RTIMER_GUARD_TIME provided by rtimer.h.


also provided a bit speedup TSCH code",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2278,2017-07-31T15:56:18Z,,2017-11-27T15:12:12Z,OPEN,False,120,34,9,https://github.com/alexrayne,TSCH: conf -  set of configuration TSCH stack,16,[],https://github.com/contiki-os/contiki/pull/2278,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2278#issuecomment-344524803,"Here provided configuring on TSCH capability.


can enabled/disabled Coordinator functionality via define TSCH_IS_COORDINATOR. this is eliminats code of coordinator, when TSCH_IS_COORDINATOR=0. Or eliminates scaner code, when TSCH_IS_COORDINATOR=1 If this macro not defiined, original behaviour with both functions avail.


disable generator EB :  if TSCH_EB_MAX_PERIOD==0 - beacons not sends and code for them eliminated.


disable KeepAlaves generator when TSCH_MAX_KEEPALIVE_TIMEOUT=0 -  eliminate code for  keepalives.


more flexible config TSCH_DEFAULT_TS_MAX_ACK, TSCH_DEFAULT_TS_MAX_TX via config defines TSCH_CONF_TS_MAX_TX/ACK. This allow to define timings in project config, and use predefined timings from tsch-conf.h


define TSCH_DEBUG_NO_TIMING_FROM_EB - prevents loading timings from EB. this helpful for debug.


introduced PRINTF_FAIL printer, this one intends for reducing code size, in release code. via TSCH_LOG_LEVEL < 0, code for printing failures can be eliminated.


RTIMER_GUARD_TIME - not use hardcoded guard time for slot operations, use
TSCH_CONF_RTIMER_GUARD def, or use RTIMER_GUARD_TIME provided by rtimer.h.


also provided a bit speedup TSCH code","Updates PR description.
Revert last change, since it breaks compatibility with native failure printing behaviour.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2278,2017-07-31T15:56:18Z,,2017-11-27T15:12:12Z,OPEN,False,120,34,9,https://github.com/alexrayne,TSCH: conf -  set of configuration TSCH stack,16,[],https://github.com/contiki-os/contiki/pull/2278,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2278#issuecomment-347211662,"Here provided configuring on TSCH capability.


can enabled/disabled Coordinator functionality via define TSCH_IS_COORDINATOR. this is eliminats code of coordinator, when TSCH_IS_COORDINATOR=0. Or eliminates scaner code, when TSCH_IS_COORDINATOR=1 If this macro not defiined, original behaviour with both functions avail.


disable generator EB :  if TSCH_EB_MAX_PERIOD==0 - beacons not sends and code for them eliminated.


disable KeepAlaves generator when TSCH_MAX_KEEPALIVE_TIMEOUT=0 -  eliminate code for  keepalives.


more flexible config TSCH_DEFAULT_TS_MAX_ACK, TSCH_DEFAULT_TS_MAX_TX via config defines TSCH_CONF_TS_MAX_TX/ACK. This allow to define timings in project config, and use predefined timings from tsch-conf.h


define TSCH_DEBUG_NO_TIMING_FROM_EB - prevents loading timings from EB. this helpful for debug.


introduced PRINTF_FAIL printer, this one intends for reducing code size, in release code. via TSCH_LOG_LEVEL < 0, code for printing failures can be eliminated.


RTIMER_GUARD_TIME - not use hardcoded guard time for slot operations, use
TSCH_CONF_RTIMER_GUARD def, or use RTIMER_GUARD_TIME provided by rtimer.h.


also provided a bit speedup TSCH code",Update PR for TSCH_CONF_RTIMER_GUARD config - allow supports rtimer.h:RTIMER_GUARD_TIME,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2279,2017-08-02T19:36:26Z,2017-11-07T00:55:16Z,2017-11-07T00:55:16Z,CLOSED,False,8,6,1,https://github.com/e120guru,TSCH: Fixes crash due to missing check for NULL pointer,1,[],https://github.com/contiki-os/contiki/pull/2279,https://github.com/e120guru,1,https://github.com/contiki-os/contiki/pull/2279,"A missing check for NULL in the keepalive_send crashes TSCH if tsch_queue_get_time_source returns NULL.
More specifically this happened when we tried updating the schedules dynamically in run-time. Seemed to be a race condition that resulted in NULL being returned (the lock perhaps?).","A missing check for NULL in the keepalive_send crashes TSCH if tsch_queue_get_time_source returns NULL.
More specifically this happened when we tried updating the schedules dynamically in run-time. Seemed to be a race condition that resulted in NULL being returned (the lock perhaps?).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2282,2017-08-10T10:25:08Z,,2017-08-10T10:25:08Z,OPEN,False,3,0,1,https://github.com/alexrayne,fix make drop of builded intermediate objects,1,[],https://github.com/contiki-os/contiki/pull/2282,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2282,"Here patch for prevent remove objects files, that not in contiki lib - project and target start files.
that objects treats as intermediate  - and to prevent ones drop, it declares as secondary","Here patch for prevent remove objects files, that not in contiki lib - project and target start files.
that objects treats as intermediate  - and to prevent ones drop, it declares as secondary",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2283,2017-08-10T10:34:46Z,,2017-08-10T18:00:11Z,OPEN,False,8,3,1,https://github.com/alexrayne,Fix make deps,4,[],https://github.com/contiki-os/contiki/pull/2283,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2283,"Here is patch on make:

generate dependance list from objects list - gives more relyable .d file path-names, and it more adecvate to compiler units
look like TARGET_STARTFILES forgotten, so append to link prerequesites rule and deps list","Here is patch on make:

generate dependance list from objects list - gives more relyable .d file path-names, and it more adecvate to compiler units
look like TARGET_STARTFILES forgotten, so append to link prerequesites rule and deps list",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2284,2017-08-10T12:06:15Z,,2017-08-17T07:29:26Z,OPEN,False,13,0,1,https://github.com/sumanpanchal,Wismote: Added login feature,1,[],https://github.com/contiki-os/contiki/pull/2284,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/2284,"@nvt
Added login feature for Wismote platform. Please provide your feedback.","@nvt
Added login feature for Wismote platform. Please provide your feedback.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2284,2017-08-10T12:06:15Z,,2017-08-17T07:29:26Z,OPEN,False,13,0,1,https://github.com/sumanpanchal,Wismote: Added login feature,1,[],https://github.com/contiki-os/contiki/pull/2284,https://github.com/sumanpanchal,2,https://github.com/contiki-os/contiki/pull/2284#issuecomment-322175039,"@nvt
Added login feature for Wismote platform. Please provide your feedback.","@greg-king5
Thanks for input. I did the changes as per your suggestion.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2285,2017-08-10T17:41:59Z,,2017-11-22T10:07:16Z,OPEN,False,46,7,6,https://github.com/alexrayne,TSCH: rtimer us_to_rtimerticks/rtimerticks_to_us - routines prefer macros,4,[],https://github.com/contiki-os/contiki/pull/2285,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2285,"Here is rtimer.h provided:

convertion routines us_to_rtimerticks/rtimerticks_to_us - static code wraps version of RTIMERTICKS_TO_US/US_TO_RTIMERTICKS macro, that intends to common code optimise.
rtime_expired(t) - test for expiration time. it utilises common code like RTIMER_CLOCK_LT(t, RTIMER_NOW()) to one single function call. this helps to save a few code size.

*Note: rtime-us convertion is not trivial, often use mul/div. so better to provide routines
for variable conversion, vs macro - uses only for constansts evaluation","Here is rtimer.h provided:

convertion routines us_to_rtimerticks/rtimerticks_to_us - static code wraps version of RTIMERTICKS_TO_US/US_TO_RTIMERTICKS macro, that intends to common code optimise.
rtime_expired(t) - test for expiration time. it utilises common code like RTIMER_CLOCK_LT(t, RTIMER_NOW()) to one single function call. this helps to save a few code size.

*Note: rtime-us convertion is not trivial, often use mul/div. so better to provide routines
for variable conversion, vs macro - uses only for constansts evaluation",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2285,2017-08-10T17:41:59Z,,2017-11-22T10:07:16Z,OPEN,False,46,7,6,https://github.com/alexrayne,TSCH: rtimer us_to_rtimerticks/rtimerticks_to_us - routines prefer macros,4,[],https://github.com/contiki-os/contiki/pull/2285,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2285#issuecomment-346303226,"Here is rtimer.h provided:

convertion routines us_to_rtimerticks/rtimerticks_to_us - static code wraps version of RTIMERTICKS_TO_US/US_TO_RTIMERTICKS macro, that intends to common code optimise.
rtime_expired(t) - test for expiration time. it utilises common code like RTIMER_CLOCK_LT(t, RTIMER_NOW()) to one single function call. this helps to save a few code size.

*Note: rtime-us convertion is not trivial, often use mul/div. so better to provide routines
for variable conversion, vs macro - uses only for constansts evaluation",migrates some more tsch code to rtimerticks_to_us/us_to_rtimerticks,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2286,2017-08-10T17:44:19Z,,2017-08-10T17:44:20Z,OPEN,False,8,16,2,https://github.com/alexrayne,*TSCH:time_source - fast implementation tsch_queue_get_time_source,1,[],https://github.com/contiki-os/contiki/pull/2286,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2286,"here is trivial optimisation tsch_queue_get_time_source - that relyes to only one timesource supports at present code. So this source is cahed in variable, instead of search one source through all neboughors","here is trivial optimisation tsch_queue_get_time_source - that relyes to only one timesource supports at present code. So this source is cahed in variable, instead of search one source through all neboughors",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2287,2017-08-10T17:46:05Z,,2017-08-10T17:46:05Z,OPEN,False,7,0,1,https://github.com/alexrayne,!TSCH:join/leave events looks forgotten,1,[],https://github.com/contiki-os/contiki/pull/2287,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2287,add events JOINING/LEAVING_NETWORK callbacks invoke on coordinator start and disassociate.,add events JOINING/LEAVING_NETWORK callbacks invoke on coordinator start and disassociate.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2288,2017-08-10T17:47:45Z,,2017-08-11T20:47:35Z,OPEN,False,63,0,56,https://github.com/alexrayne,supress warns on DEBUG define to compiler,2,[],https://github.com/contiki-os/contiki/pull/2288,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2288,"now undef DEBUG everywhere it redefines, to supress compiler warning about redefine

usual way to note compiler about release/debug target is provide DEBUG definition.
contiki code usualy localy override it, so build with DEBUG generates a lot of warnings","now undef DEBUG everywhere it redefines, to supress compiler warning about redefine

usual way to note compiler about release/debug target is provide DEBUG definition.
contiki code usualy localy override it, so build with DEBUG generates a lot of warnings",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2289,2017-08-10T17:49:38Z,,2017-08-11T11:39:22Z,OPEN,False,78,8,4,https://github.com/alexrayne,adjust cc26xx rtimer resolution,3,[],https://github.com/contiki-os/contiki/pull/2289,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2289,"cc26xx:RTIMER_CONF_ARCH_SECOND - provide RTC resolution setup. now tick of RTC can be setup.
*Note: this patch overrides default RTC setup, if user provides differ RTIMER_CONF_ARCH_SECOND
RTC SEC and SUBSEC register are loose their mean in this case.
RTC compare registers maped to SEC[0:15]SUBSEC[31:16] - so looks like fixed point of sec.subsec
with new settings, this point moves into SUBSEC, and provide more bits for seconds.
So now RTC can operate with more time range, with penalty of less precision

on cc13/26xx RTC always run with 32kHz, but default setup gives it 16 bits, so
override RTIMER_CONF_ARCH_SECOND to 32k will not loose precision, but give twice time range","cc26xx:RTIMER_CONF_ARCH_SECOND - provide RTC resolution setup. now tick of RTC can be setup.
*Note: this patch overrides default RTC setup, if user provides differ RTIMER_CONF_ARCH_SECOND
RTC SEC and SUBSEC register are loose their mean in this case.
RTC compare registers maped to SEC[0:15]SUBSEC[31:16] - so looks like fixed point of sec.subsec
with new settings, this point moves into SUBSEC, and provide more bits for seconds.
So now RTC can operate with more time range, with penalty of less precision

on cc13/26xx RTC always run with 32kHz, but default setup gives it 16 bits, so
override RTIMER_CONF_ARCH_SECOND to 32k will not loose precision, but give twice time range",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2292,2017-08-11T11:24:43Z,,2017-08-11T11:24:43Z,OPEN,False,6,1,1,https://github.com/alexrayne,+TSCH: TSCH_CONF_H - provide project specific header for TSCH setup,1,[],https://github.com/contiki-os/contiki/pull/2292,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2292,"TSCH_CONF_H - provide project specific header for TSCH,  this header intends to lightweight rebuild on tsch parameters change


unsupported TSCH_CONF_DEFAULT_TS_TIMESLOT_LENGTH now relyes to project conf","TSCH_CONF_H - provide project specific header for TSCH,  this header intends to lightweight rebuild on tsch parameters change


unsupported TSCH_CONF_DEFAULT_TS_TIMESLOT_LENGTH now relyes to project conf",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2293,2017-08-11T11:28:29Z,,2020-06-29T07:52:11Z,OPEN,False,285,55,9,https://github.com/alexrayne,TSCH: log more log messages instead print,12,[],https://github.com/contiki-os/contiki/pull/2293,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2293,"tsch-ques used PRINTF, and thererfore introduced large delays in timeslot processing. migrating to log makes timeslot more robust.
also provided more kinds of log messages:

tsch_log_text  -add printer of constant text string
tsch_log_fmt - formated string with 3 args
tsch_log_packet[_verbose] - prints formated messages with packet info
tsch_log_change_timesrc - prints chnging time source message
+introduced TSCH_PUTS/PRINTF/ANNOTATE wrapers for debug PRINTF/ANNOTATE replacement
this messages intends for more light log
node adress prints as HEX","tsch-ques used PRINTF, and thererfore introduced large delays in timeslot processing. migrating to log makes timeslot more robust.
also provided more kinds of log messages:

tsch_log_text  -add printer of constant text string
tsch_log_fmt - formated string with 3 args
tsch_log_packet[_verbose] - prints formated messages with packet info
tsch_log_change_timesrc - prints chnging time source message
+introduced TSCH_PUTS/PRINTF/ANNOTATE wrapers for debug PRINTF/ANNOTATE replacement
this messages intends for more light log
node adress prints as HEX",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2293,2017-08-11T11:28:29Z,,2020-06-29T07:52:11Z,OPEN,False,285,55,9,https://github.com/alexrayne,TSCH: log more log messages instead print,12,[],https://github.com/contiki-os/contiki/pull/2293,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2293#issuecomment-347212878,"tsch-ques used PRINTF, and thererfore introduced large delays in timeslot processing. migrating to log makes timeslot more robust.
also provided more kinds of log messages:

tsch_log_text  -add printer of constant text string
tsch_log_fmt - formated string with 3 args
tsch_log_packet[_verbose] - prints formated messages with packet info
tsch_log_change_timesrc - prints chnging time source message
+introduced TSCH_PUTS/PRINTF/ANNOTATE wrapers for debug PRINTF/ANNOTATE replacement
this messages intends for more light log
node adress prints as HEX",change TSCH log prints nodes adress as hex. imho ti si handy,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2293,2017-08-11T11:28:29Z,,2020-06-29T07:52:11Z,OPEN,False,285,55,9,https://github.com/alexrayne,TSCH: log more log messages instead print,12,[],https://github.com/contiki-os/contiki/pull/2293,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2293#issuecomment-348577665,"tsch-ques used PRINTF, and thererfore introduced large delays in timeslot processing. migrating to log makes timeslot more robust.
also provided more kinds of log messages:

tsch_log_text  -add printer of constant text string
tsch_log_fmt - formated string with 3 args
tsch_log_packet[_verbose] - prints formated messages with packet info
tsch_log_change_timesrc - prints chnging time source message
+introduced TSCH_PUTS/PRINTF/ANNOTATE wrapers for debug PRINTF/ANNOTATE replacement
this messages intends for more light log
node adress prints as HEX","change TSCH log prints nodes adress as hex, and fix a bit compiler warnings with TSCH_LOGF",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2293,2017-08-11T11:28:29Z,,2020-06-29T07:52:11Z,OPEN,False,285,55,9,https://github.com/alexrayne,TSCH: log more log messages instead print,12,[],https://github.com/contiki-os/contiki/pull/2293,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2293#issuecomment-353596437,"tsch-ques used PRINTF, and thererfore introduced large delays in timeslot processing. migrating to log makes timeslot more robust.
also provided more kinds of log messages:

tsch_log_text  -add printer of constant text string
tsch_log_fmt - formated string with 3 args
tsch_log_packet[_verbose] - prints formated messages with packet info
tsch_log_change_timesrc - prints chnging time source message
+introduced TSCH_PUTS/PRINTF/ANNOTATE wrapers for debug PRINTF/ANNOTATE replacement
this messages intends for more light log
node adress prints as HEX",more TSCH log prints nodes adress as hex,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2293,2017-08-11T11:28:29Z,,2020-06-29T07:52:11Z,OPEN,False,285,55,9,https://github.com/alexrayne,TSCH: log more log messages instead print,12,[],https://github.com/contiki-os/contiki/pull/2293,https://github.com/alexrayne,5,https://github.com/contiki-os/contiki/pull/2293#issuecomment-354459243,"tsch-ques used PRINTF, and thererfore introduced large delays in timeslot processing. migrating to log makes timeslot more robust.
also provided more kinds of log messages:

tsch_log_text  -add printer of constant text string
tsch_log_fmt - formated string with 3 args
tsch_log_packet[_verbose] - prints formated messages with packet info
tsch_log_change_timesrc - prints chnging time source message
+introduced TSCH_PUTS/PRINTF/ANNOTATE wrapers for debug PRINTF/ANNOTATE replacement
this messages intends for more light log
node adress prints as HEX","fixed TACH_LOGF( ) - macro args - that one should be in commas, to avoid errors wth complex expressions",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2294,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2294#issuecomment-346302674,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","fixes situations when slot leaves powered on. this can cause by previous prefetching and skip slot.
introduce tsch_ts_netwide_count - amount of timings shared by net.
refactores ies:ie_tsch_timeslot parser/serialiser against hardcode - use tsch_ts_netwide_count to denote size of timings",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2294#issuecomment-354458448,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","provides a bit optimisation of prognose to next slot time - just use evaluated slot time as parameter in scheduler. This helps when use tryky evaluaion of slot time.
for TSCH_RADIO_ON_DURING_TIMESLOT ==0 - time tsch_ts_rfon_prepslot_guard takes into account. if this time disabled, use native behaviour - turn off/on within slot. if this time mentionabe - do not rf off within slot, just at end of slot.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2294#issuecomment-384246889,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.",fast fixed  broken  RFcore power-on prefetching by inactive slots.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/arurke,5,https://github.com/contiki-os/contiki/pull/2294#issuecomment-384323542,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","@alexrayne You might want to consider posting your PRs on https://github.com/contiki-ng/contiki-ng instead as I believe most maintainers have moved there (that is, if you aim for feedback and merging).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/alexrayne,6,https://github.com/contiki-os/contiki/pull/2294#issuecomment-384599048,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","aruke: do you mean that contiki-ng - is the develop sandbox for this one - main contiki repo? Or it is standalone project?
I alredy provide much PRs, there is much work to duplicate them. wich PRs you ready to examine or accept, and witch - not?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/arurke,7,https://github.com/contiki-os/contiki/pull/2294#issuecomment-384666877,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","It is a standalone project. Some of the authors of the modules your PRs touch are maintainers there, so I am sure they would appreciate your input.
I am not a maintainer in either contiki or contiki-ng so I cannot say which is relevant. Contiki-ng has a gitter which might be useful for you in this regard: https://gitter.im/contiki-ng/",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2294,2017-08-11T14:01:26Z,,2020-05-16T09:45:11Z,OPEN,False,116,17,7,https://github.com/alexrayne,TSCH: prognose for close active slot to ommit rf power off,12,[],https://github.com/contiki-os/contiki/pull/2294,https://github.com/alexrayne,8,https://github.com/contiki-os/contiki/pull/2294#issuecomment-389494834,"This patch demands(includes) PR #2276
Here estimates time to next active slot, when demanded rf turn off.
if next active slot too close, rf leave on, to avoid loose of time on rf off-on cycle. this helps to awake next slot in time.
*Note: this patch relyes on that current slot operation ends not too late, so that ASN of current operation is correct.","when timeslot estimation supress RF turnoff, cc26xx receiver can get some packets from air.
thouse packets can be accepted as desiren in receive slot, or as ack in tx slot. therefore need to ensure that RF packest buffer is empty before slot.
Now provided patches, that read and drop packets from RF before slot starts.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2302,2017-08-21T14:08:34Z,,2017-09-04T13:59:55Z,OPEN,False,17,0,1,https://github.com/sumanpanchal,Openmote: Added login feature,1,[],https://github.com/contiki-os/contiki/pull/2302,https://github.com/sumanpanchal,1,https://github.com/contiki-os/contiki/pull/2302,Login feature for Openmote-cc2538 has been added.,Login feature for Openmote-cc2538 has been added.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2307,2017-08-26T21:51:54Z,,2017-08-26T21:51:54Z,OPEN,False,8,2,1,https://github.com/mabeett,border-router: user may set sio device in tunslip6,1,[],https://github.com/contiki-os/contiki/pull/2307,https://github.com/mabeett,1,https://github.com/contiki-os/contiki/pull/2307,"with this patch the user may set the sio device to be used by tunslip6.
Please make me know if you consider this should be propagated to another Makefiles in examples
Thanks","with this patch the user may set the sio device to be used by tunslip6.
Please make me know if you consider this should be propagated to another Makefiles in examples
Thanks",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2308,2017-08-27T15:20:32Z,,2017-08-27T15:20:32Z,OPEN,False,6,2,1,https://github.com/lane-westlund,Send PROCESS_EVENT_EXITED only to running processes,1,[],https://github.com/contiki-os/contiki/pull/2308,https://github.com/lane-westlund,1,https://github.com/contiki-os/contiki/pull/2308,"I use process events quite heavily for inter-process communication.  Because of this, I wanted to raise an alarm if call_process is called targeting a process which is not in a state to receive the call.
What I found, was that this happens frequently, but only with PROCESS_EVENT_EXITED.  The reason being: exit_process goes through all processes, regardless of their state, and notifies them.  Although there is no adverse effect of doing this, it is somewhat wasteful since it is not necessary to attempt to notify non-running processes that another process has exited.
So I made this little patch to send PROCESS_EVENT_EXITED only to processes with the state PROCESS_STATE_RUNNING","I use process events quite heavily for inter-process communication.  Because of this, I wanted to raise an alarm if call_process is called targeting a process which is not in a state to receive the call.
What I found, was that this happens frequently, but only with PROCESS_EVENT_EXITED.  The reason being: exit_process goes through all processes, regardless of their state, and notifies them.  Although there is no adverse effect of doing this, it is somewhat wasteful since it is not necessary to attempt to notify non-running processes that another process has exited.
So I made this little patch to send PROCESS_EVENT_EXITED only to processes with the state PROCESS_STATE_RUNNING",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2309,2017-08-28T07:25:27Z,,2017-08-28T07:26:01Z,OPEN,False,11,11,6,https://github.com/coolbacon,Release 3 1,2,[],https://github.com/contiki-os/contiki/pull/2309,https://github.com/coolbacon,1,https://github.com/contiki-os/contiki/pull/2309,Version 3.1,Version 3.1,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2310,2017-08-28T13:25:54Z,,2017-08-28T13:25:54Z,OPEN,False,4,0,1,https://github.com/alexrayne,!TSCH - correct init attributes PACKETBUF_ATTR_TSCH_SLOTFRAME,1,[],https://github.com/contiki-os/contiki/pull/2310,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2310,"using TSCH with TSCH_WITH_LINK_SELECTOR requres corect initialisation for PACKETBUF_ATTR_TSCH_SLOTFRAME/TIMESLOT, that looks like forgotten.

TSCH uses thouse attributes with ignore value ~0 (0xffff), if it will not be correct
initialised before send, packet can be ommited for send, and can breaks neiboughor queue.
So packetbuf_attr_clear need to initialise attributes to valid defaults, to allow normaly schedule
packets, even for tsch internals - keepalive, EBs.","using TSCH with TSCH_WITH_LINK_SELECTOR requres corect initialisation for PACKETBUF_ATTR_TSCH_SLOTFRAME/TIMESLOT, that looks like forgotten.

TSCH uses thouse attributes with ignore value ~0 (0xffff), if it will not be correct
initialised before send, packet can be ommited for send, and can breaks neiboughor queue.
So packetbuf_attr_clear need to initialise attributes to valid defaults, to allow normaly schedule
packets, even for tsch internals - keepalive, EBs.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2311,2017-08-29T09:55:17Z,2017-09-01T16:26:20Z,2017-09-01T16:26:20Z,CLOSED,False,604,2,7,https://github.com/alexrayne,+cc26xx:uart:tx:buffer - UART_TXBUFSIZE enables buffer for uart output.,6,[],https://github.com/contiki-os/contiki/pull/2311,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2311,"Hallow! here provided:

buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced  cc26xx_uart api :
- cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.

*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.","Hallow! here provided:

buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced  cc26xx_uart api :
- cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.

*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2311,2017-08-29T09:55:17Z,2017-09-01T16:26:20Z,2017-09-01T16:26:20Z,CLOSED,False,604,2,7,https://github.com/alexrayne,+cc26xx:uart:tx:buffer - UART_TXBUFSIZE enables buffer for uart output.,6,[],https://github.com/contiki-os/contiki/pull/2311,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2311#issuecomment-326624711,"Hallow! here provided:

buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced  cc26xx_uart api :
- cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.

*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.","have to reopen PR, cause this on dirty by mistakes",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2312,2017-08-29T10:39:25Z,,2018-02-19T15:28:02Z,OPEN,False,5114,47,36,https://github.com/spoerk,BLEach: a fully open source IPv6-over-BLE stack for the TI CC26xx platform,28,[],https://github.com/contiki-os/contiki/pull/2312,https://github.com/spoerk,1,https://github.com/contiki-os/contiki/pull/2312,"This pull request implements BLEach, a fully open source IPv6-over-BLE stack for the Texas Instruments CC26xx hardware platform. BLEach implements support for IPv6-over-BLE node and border router devices according to the RFC 7668 specification. Devices running this IPv6-over-BLE stack are interoperable with any RFC 7668 compliant border router (e.g. Raspberry Pi, smartphone, laptops, ...).
Features:

IPv6-over-BLE node implementation compliant to RFC 7668
IPv6-over-BLE border router implementation compliant to RFC 7668
BLE link layer support according to the Bluetooth Specification v4.1 for BLE advertisement, BLE initiating, BLE connection slave, and BLE connection master.

The website www.iti.tugraz.at/BLEach provides a more detailed description of the features and the code structure of BLEach.
The code documentation for BLEach can be found in this README.md.
For a detailed description and evaluation of BLEach, see our paper BLEach: Exploiting the Full Potential of IPv6 over BLE in Constrained Embedded IoT Devices, ACM SenSys'17.
This implementation includes new implementations of the radio, RDC, and MAC layer of Contiki that are tailored to support IPv6-over-BLE communication. Therefore, BLEach is agnostic to the application running in Contiki; developers may run the same application using IPv6 over IEEE 802.15.4 or IPv6 over BLE by simply changing the project's configuration file at compile time.
This pull request provides two example projects: a simple UDP client that exchanges UDP packets over IPv6 over BLE with a server, and a simple UDP server that listens for packets from a client over IPv6 over BLE.
This pull request updates the pull request #1936.
This pull request uses the multiple access for the rtimer from pull request #1290.","This pull request implements BLEach, a fully open source IPv6-over-BLE stack for the Texas Instruments CC26xx hardware platform. BLEach implements support for IPv6-over-BLE node and border router devices according to the RFC 7668 specification. Devices running this IPv6-over-BLE stack are interoperable with any RFC 7668 compliant border router (e.g. Raspberry Pi, smartphone, laptops, ...).
Features:

IPv6-over-BLE node implementation compliant to RFC 7668
IPv6-over-BLE border router implementation compliant to RFC 7668
BLE link layer support according to the Bluetooth Specification v4.1 for BLE advertisement, BLE initiating, BLE connection slave, and BLE connection master.

The website www.iti.tugraz.at/BLEach provides a more detailed description of the features and the code structure of BLEach.
The code documentation for BLEach can be found in this README.md.
For a detailed description and evaluation of BLEach, see our paper BLEach: Exploiting the Full Potential of IPv6 over BLE in Constrained Embedded IoT Devices, ACM SenSys'17.
This implementation includes new implementations of the radio, RDC, and MAC layer of Contiki that are tailored to support IPv6-over-BLE communication. Therefore, BLEach is agnostic to the application running in Contiki; developers may run the same application using IPv6 over IEEE 802.15.4 or IPv6 over BLE by simply changing the project's configuration file at compile time.
This pull request provides two example projects: a simple UDP client that exchanges UDP packets over IPv6 over BLE with a server, and a simple UDP server that listens for packets from a client over IPv6 over BLE.
This pull request updates the pull request #1936.
This pull request uses the multiple access for the rtimer from pull request #1290.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2312,2017-08-29T10:39:25Z,,2018-02-19T15:28:02Z,OPEN,False,5114,47,36,https://github.com/spoerk,BLEach: a fully open source IPv6-over-BLE stack for the TI CC26xx platform,28,[],https://github.com/contiki-os/contiki/pull/2312,https://github.com/BoKarolis,2,https://github.com/contiki-os/contiki/pull/2312#issuecomment-328555141,"This pull request implements BLEach, a fully open source IPv6-over-BLE stack for the Texas Instruments CC26xx hardware platform. BLEach implements support for IPv6-over-BLE node and border router devices according to the RFC 7668 specification. Devices running this IPv6-over-BLE stack are interoperable with any RFC 7668 compliant border router (e.g. Raspberry Pi, smartphone, laptops, ...).
Features:

IPv6-over-BLE node implementation compliant to RFC 7668
IPv6-over-BLE border router implementation compliant to RFC 7668
BLE link layer support according to the Bluetooth Specification v4.1 for BLE advertisement, BLE initiating, BLE connection slave, and BLE connection master.

The website www.iti.tugraz.at/BLEach provides a more detailed description of the features and the code structure of BLEach.
The code documentation for BLEach can be found in this README.md.
For a detailed description and evaluation of BLEach, see our paper BLEach: Exploiting the Full Potential of IPv6 over BLE in Constrained Embedded IoT Devices, ACM SenSys'17.
This implementation includes new implementations of the radio, RDC, and MAC layer of Contiki that are tailored to support IPv6-over-BLE communication. Therefore, BLEach is agnostic to the application running in Contiki; developers may run the same application using IPv6 over IEEE 802.15.4 or IPv6 over BLE by simply changing the project's configuration file at compile time.
This pull request provides two example projects: a simple UDP client that exchanges UDP packets over IPv6 over BLE with a server, and a simple UDP server that listens for packets from a client over IPv6 over BLE.
This pull request updates the pull request #1936.
This pull request uses the multiple access for the rtimer from pull request #1290.","Hi, this is very nice, have you tested it on debian stretch? I could not make it work, it could be related to the new interface naming method they've implemented. It works fine on jessie though.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2312,2017-08-29T10:39:25Z,,2018-02-19T15:28:02Z,OPEN,False,5114,47,36,https://github.com/spoerk,BLEach: a fully open source IPv6-over-BLE stack for the TI CC26xx platform,28,[],https://github.com/contiki-os/contiki/pull/2312,https://github.com/spoerk,3,https://github.com/contiki-os/contiki/pull/2312#issuecomment-328749149,"This pull request implements BLEach, a fully open source IPv6-over-BLE stack for the Texas Instruments CC26xx hardware platform. BLEach implements support for IPv6-over-BLE node and border router devices according to the RFC 7668 specification. Devices running this IPv6-over-BLE stack are interoperable with any RFC 7668 compliant border router (e.g. Raspberry Pi, smartphone, laptops, ...).
Features:

IPv6-over-BLE node implementation compliant to RFC 7668
IPv6-over-BLE border router implementation compliant to RFC 7668
BLE link layer support according to the Bluetooth Specification v4.1 for BLE advertisement, BLE initiating, BLE connection slave, and BLE connection master.

The website www.iti.tugraz.at/BLEach provides a more detailed description of the features and the code structure of BLEach.
The code documentation for BLEach can be found in this README.md.
For a detailed description and evaluation of BLEach, see our paper BLEach: Exploiting the Full Potential of IPv6 over BLE in Constrained Embedded IoT Devices, ACM SenSys'17.
This implementation includes new implementations of the radio, RDC, and MAC layer of Contiki that are tailored to support IPv6-over-BLE communication. Therefore, BLEach is agnostic to the application running in Contiki; developers may run the same application using IPv6 over IEEE 802.15.4 or IPv6 over BLE by simply changing the project's configuration file at compile time.
This pull request provides two example projects: a simple UDP client that exchanges UDP packets over IPv6 over BLE with a server, and a simple UDP server that listens for packets from a client over IPv6 over BLE.
This pull request updates the pull request #1936.
This pull request uses the multiple access for the rtimer from pull request #1290.","Nice that this is of interest to you.
We have only tested it for Raspbian Jessie and not for Stretch.
Thanks for the tip that they renamed their interfaces. I will have a look.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2312,2017-08-29T10:39:25Z,,2018-02-19T15:28:02Z,OPEN,False,5114,47,36,https://github.com/spoerk,BLEach: a fully open source IPv6-over-BLE stack for the TI CC26xx platform,28,[],https://github.com/contiki-os/contiki/pull/2312,https://github.com/BoKarolis,4,https://github.com/contiki-os/contiki/pull/2312#issuecomment-330243260,"This pull request implements BLEach, a fully open source IPv6-over-BLE stack for the Texas Instruments CC26xx hardware platform. BLEach implements support for IPv6-over-BLE node and border router devices according to the RFC 7668 specification. Devices running this IPv6-over-BLE stack are interoperable with any RFC 7668 compliant border router (e.g. Raspberry Pi, smartphone, laptops, ...).
Features:

IPv6-over-BLE node implementation compliant to RFC 7668
IPv6-over-BLE border router implementation compliant to RFC 7668
BLE link layer support according to the Bluetooth Specification v4.1 for BLE advertisement, BLE initiating, BLE connection slave, and BLE connection master.

The website www.iti.tugraz.at/BLEach provides a more detailed description of the features and the code structure of BLEach.
The code documentation for BLEach can be found in this README.md.
For a detailed description and evaluation of BLEach, see our paper BLEach: Exploiting the Full Potential of IPv6 over BLE in Constrained Embedded IoT Devices, ACM SenSys'17.
This implementation includes new implementations of the radio, RDC, and MAC layer of Contiki that are tailored to support IPv6-over-BLE communication. Therefore, BLEach is agnostic to the application running in Contiki; developers may run the same application using IPv6 over IEEE 802.15.4 or IPv6 over BLE by simply changing the project's configuration file at compile time.
This pull request provides two example projects: a simple UDP client that exchanges UDP packets over IPv6 over BLE with a server, and a simple UDP server that listens for packets from a client over IPv6 over BLE.
This pull request updates the pull request #1936.
This pull request uses the multiple access for the rtimer from pull request #1290.","Another thing, I don't know if you are aware, but with the cc26xx-ble-client-demo fails after ~1060 seconds. The output on the terminal becomes choppy, bluetooth connection dies and after 10 more seconds the node reboots.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2312,2017-08-29T10:39:25Z,,2018-02-19T15:28:02Z,OPEN,False,5114,47,36,https://github.com/spoerk,BLEach: a fully open source IPv6-over-BLE stack for the TI CC26xx platform,28,[],https://github.com/contiki-os/contiki/pull/2312,https://github.com/spoerk,5,https://github.com/contiki-os/contiki/pull/2312#issuecomment-330428520,"This pull request implements BLEach, a fully open source IPv6-over-BLE stack for the Texas Instruments CC26xx hardware platform. BLEach implements support for IPv6-over-BLE node and border router devices according to the RFC 7668 specification. Devices running this IPv6-over-BLE stack are interoperable with any RFC 7668 compliant border router (e.g. Raspberry Pi, smartphone, laptops, ...).
Features:

IPv6-over-BLE node implementation compliant to RFC 7668
IPv6-over-BLE border router implementation compliant to RFC 7668
BLE link layer support according to the Bluetooth Specification v4.1 for BLE advertisement, BLE initiating, BLE connection slave, and BLE connection master.

The website www.iti.tugraz.at/BLEach provides a more detailed description of the features and the code structure of BLEach.
The code documentation for BLEach can be found in this README.md.
For a detailed description and evaluation of BLEach, see our paper BLEach: Exploiting the Full Potential of IPv6 over BLE in Constrained Embedded IoT Devices, ACM SenSys'17.
This implementation includes new implementations of the radio, RDC, and MAC layer of Contiki that are tailored to support IPv6-over-BLE communication. Therefore, BLEach is agnostic to the application running in Contiki; developers may run the same application using IPv6 over IEEE 802.15.4 or IPv6 over BLE by simply changing the project's configuration file at compile time.
This pull request provides two example projects: a simple UDP client that exchanges UDP packets over IPv6 over BLE with a server, and a simple UDP server that listens for packets from a client over IPv6 over BLE.
This pull request updates the pull request #1936.
This pull request uses the multiple access for the rtimer from pull request #1290.","Thanks for pointing this out.
I am aware of this problem and I am working on solving it.
The problem is caused by an overflow of the radio core timer.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2315,2017-09-01T16:28:02Z,,2017-12-29T15:21:17Z,OPEN,False,641,8,5,https://github.com/alexrayne,+cc26xx uart tx buffer - UART_TXBUFSIZE enables buffer for uart output,13,[],https://github.com/contiki-os/contiki/pull/2315,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2315,"Hallow! here provided:
buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced cc26xx_uart api :

cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.
*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.","Hallow! here provided:
buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced cc26xx_uart api :

cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.
*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2315,2017-09-01T16:28:02Z,,2017-12-29T15:21:17Z,OPEN,False,641,8,5,https://github.com/alexrayne,+cc26xx uart tx buffer - UART_TXBUFSIZE enables buffer for uart output,13,[],https://github.com/contiki-os/contiki/pull/2315,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2315#issuecomment-352015374,"Hallow! here provided:
buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced cc26xx_uart api :

cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.
*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.","fixes` :

TX IRQ enabling - when TX_BUFFER defined, UART IRQ enables now even if RX receive handle disabled. UART IRQ always need in buffered mode
LPM request has loose chars that are in send registers, so should wait for UART transmiter empty before DEEP_SLEEP",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2315,2017-09-01T16:28:02Z,,2017-12-29T15:21:17Z,OPEN,False,641,8,5,https://github.com/alexrayne,+cc26xx uart tx buffer - UART_TXBUFSIZE enables buffer for uart output,13,[],https://github.com/contiki-os/contiki/pull/2315,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2315#issuecomment-353866122,"Hallow! here provided:
buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced cc26xx_uart api :

cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.
*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.",fixed work USRT in LPM SLEEP mode - now USRT leaves work in sleep state. Now UART can flush fifo values during cpu sleep.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2315,2017-09-01T16:28:02Z,,2017-12-29T15:21:17Z,OPEN,False,641,8,5,https://github.com/alexrayne,+cc26xx uart tx buffer - UART_TXBUFSIZE enables buffer for uart output,13,[],https://github.com/contiki-os/contiki/pull/2315,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2315#issuecomment-354458864,"Hallow! here provided:
buffering uart output, that can be enabled by UART_TXBUFSIZE configuration macro.
enhanced cc26xx_uart api :

cc26xx_uart_write_bytes - nonbocking write to uart fifo optimised to buffering driver
-cc26xx_uart_space_avail - status of tx fifo
putchar:puts, dbg_send_bytes - migrates to cc26xx_uart_write_bytes for optimisation.
a bit optimised UART ISR - more light check for power and clock.
*Note - using buffering (via UART_TXBUFSIZE) skips waiting for send completion in
routines puts, dbg_send_bytes - that was used for to protect vs poweroff
during transfer.","fixes LPM mode evaluation when TX buffer empty - only way to detect that UART transmiter is empty, is poll UART flags. so, keem AWAKE LPM mode while polling.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2317,2017-09-02T17:38:09Z,2017-09-21T08:03:31Z,2017-09-21T08:03:33Z,MERGED,True,2,0,1,https://github.com/adamdunkels,"Due to a travis update on September 1, 2017, sudo: and dist: are requ‚Ä¶",1,[],https://github.com/contiki-os/contiki/pull/2317,https://github.com/adamdunkels,1,https://github.com/contiki-os/contiki/pull/2317,‚Ä¶ired,‚Ä¶ired,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2320,2017-09-09T05:54:36Z,,2017-09-09T05:54:36Z,OPEN,False,12,12,7,https://github.com/wasifhamdani,Release 3 0,4,[],https://github.com/contiki-os/contiki/pull/2320,https://github.com/wasifhamdani,1,https://github.com/contiki-os/contiki/pull/2320,Thesis work,Thesis work,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2326,2017-09-14T15:20:21Z,2017-10-11T14:00:24Z,2017-10-11T14:00:24Z,CLOSED,False,55,2,2,https://github.com/alexrayne,lib/list.h more inlines - optimise code a bit,2,[],https://github.com/contiki-os/contiki/pull/2326,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2326,here is a trivial code optimisation via inlines of some lib/list.h routines,here is a trivial code optimisation via inlines of some lib/list.h routines,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2326,2017-09-14T15:20:21Z,2017-10-11T14:00:24Z,2017-10-11T14:00:24Z,CLOSED,False,55,2,2,https://github.com/alexrayne,lib/list.h more inlines - optimise code a bit,2,[],https://github.com/contiki-os/contiki/pull/2326,https://github.com/msloth,2,https://github.com/contiki-os/contiki/pull/2326#issuecomment-332461915,here is a trivial code optimisation via inlines of some lib/list.h routines,"What is the gain of the optimization (ie is it useful), do you have any measurement? The cost is more complexity, duplicated code, and another configuration option in a mature lib, so imo the gain must be >> the cost.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2326,2017-09-14T15:20:21Z,2017-10-11T14:00:24Z,2017-10-11T14:00:24Z,CLOSED,False,55,2,2,https://github.com/alexrayne,lib/list.h more inlines - optimise code a bit,2,[],https://github.com/contiki-os/contiki/pull/2326,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2326#issuecomment-332504282,here is a trivial code optimisation via inlines of some lib/list.h routines,"there is no ""another configuration options"" used. it uses alredy behaviour from packetbuf.h
the same questions you can ask AdamDunkels about packetbuf.h:PACKETBUF_CONF_ATTRS_INLINE usage and reson.
about profit. use arm with O1 optimisation gives:
list_init - inline uses 1 extra instruction vs routine call
list_head - routine-call use 1-2 extra instructions, vs inline.
list_copy not used in any code, so i catn inspect it

in both cases i not counts cpu cycles use - surely inline wins about 2 or more cycles.
So, looks better to get off list_init optimisation.
and i will remove GNUC define from inline usage condition. it will uses only with PACKETBUF_CONF_ATTRS_INLINE",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2326,2017-09-14T15:20:21Z,2017-10-11T14:00:24Z,2017-10-11T14:00:24Z,CLOSED,False,55,2,2,https://github.com/alexrayne,lib/list.h more inlines - optimise code a bit,2,[],https://github.com/contiki-os/contiki/pull/2326,https://github.com/nvt,4,https://github.com/contiki-os/contiki/pull/2326#issuecomment-335819518,here is a trivial code optimisation via inlines of some lib/list.h routines,"Thanks for the contribution, but I agree with @msloth here. There are a few issues with the PR: 1) it duplicates code and makes the implementation harder to read, 2) it introduces a dependency on a packetbuf configuration variable in list.h, and 3) Contiki coding style and naming conventions are not followed entirely. Hence, I am closing this PR unfortunately.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/ivan-alekhin,1,https://github.com/contiki-os/contiki/pull/2328,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330795871,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","can you describe how tou use it?
–º–æ–∂–Ω–æ –ø–æ–¥—Ä–æ–±–Ω–µ–µ –∫–∞–∫ —ç—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/ivan-alekhin,3,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330820261,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","@alexrayne, I just need to make changes in Cooja interfaces (i want to add new interfaces), but I cannot change in-tree source, because we are using out-of-tree development (https://github.com/contiki-os/contiki/wiki/Out-of-Tree-Development). So, I just added new platform (like mychip-cooja). The issue appears when I tried to build sample with this platform: mychip-cooja platform proivdes Makefile.customrules-mychip-cooja file, but contiki cannot find it because this file doesn't exists on contiki source tree (include $(CONTIKI)/platform/$(TARGET)/Makefile.customrules-$(TARGET)).
So, I propose to allow contiki to search Makefile.customrules-$(TARGET) in $TARGETDIRS.
Is there some another way? Could you suggest something?
–ú–Ω–µ –Ω—É–∂–Ω–æ –≤–Ω–µ—Å—Ç–∏ –ø—Ä–∞–≤–∫–∏ –≤ —Å–ø–∏—Å–æ–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–≤, –ø—Ä–∏—á—ë–º —è –Ω–µ –º–æ–≥—É –¥–µ–ª–∞—Ç—å –ø—Ä–∞–≤–∫–∏ –≤ –∫–æ–¥–µ contiki, —Ç.–∫. –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º out-of-tree –≤–µ—Ä—Å–∏—é –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, —è –ø—Ä–æ—Å—Ç–æ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–ª cooja-–ø–ª–∞—Ç—Ñ–æ—Ä–º—É –∏ –ø–æ–º–µ–Ω—è–ª —Ç–∞–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã. –ù–æ —Å–æ–±–∏—Ä–∞—Ç—å —Ç–∞–∫–æ–µ –Ω–µ–ª—å–∑—è, —Ç.–∫. contiki –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å Makefile.customrules –≤–Ω–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –∏—Å—Ö–æ–¥–Ω–∏–∫–æ–≤. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ, —è –ø—Ä–µ–¥–ª–∞–≥–∞—é —Ä–∞–∑—Ä–µ—à–∏—Ç—å –ø–æ–∏—Å–∫ —ç—Ç–∏—Ö —Ñ–∞–π–ª–æ–≤ –≤ –¥—Ä—É–≥–∏—Ö –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è—Ö (–≤–Ω–µ –¥–µ—Ä–µ–≤–∞ contiki). –ú–æ–∂–µ—Ç –±—ã—Ç—å —ç—Ç—É –∑–∞–¥–∞—á—É –º–æ–∂–Ω–æ –∫–∞–∫-—Ç–æ –ø–æ-–¥—Ä—É–≥–æ–º—É —Ä–µ—à–∏—Ç—å?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330830350,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","—É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ø—Ä–∞–≤–∏–ª–æ –≤–∫–ª—é—á–∞—é—â–µ–µ
${foreach TDIR, $(TARGETDIRS), $(TDIR)/$(TARGET)/Makefile.$(TARGET)}
—Ç–æ–µ—Å—Ç—å, –ø–æ –∏–¥–µ–µ —Ä–∞–∑ –≤—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–ª–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É, –º–æ–∂–Ω–æ –¥–∞—Ç—å –µ–π —Å–≤–æ–µ —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è, –∏ –ø–æ–¥—Ü–µ–ø–∏—Ç—å —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/alexrayne,5,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330831084,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","—Ç–µ–º–Ω–µ –º–µ–Ω–µ–µ –º–Ω–µ –≤–∞—à –ø–∞—Ç—á –Ω—Ä–∞–≤–∏—Ç—Å—è. –Ω–æ –æ–Ω –ø–æ–ª—É—á–∞–µ—Ç—Å—è –Ω–µ –Ω–∞ –≤–∞—à—É –∑–∞–¥–∞—á—É —Ä–∞—Å—á–∏—Ç–∞–Ω. –≤—ã –≤–µ–¥—å –ø—Ä–∏–∫—Ä—É—Ç–∏–ª–∏ –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—é —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã.
–∞ –µ—Å–ª–∏ –≤—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞–ª–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É, —Ç–æ –∫–∞–∫ –±—ã —Å–æ–∑–¥–∞–ª–∏ –Ω–æ–≤—É—é, –∏ —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ cestomrules-xxx –Ω–µ –∞–∫—Ç—É–∞–ª—å–Ω–∞?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/ivan-alekhin,6,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330834007,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","customrules –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π –≤–µ—Ä—Å–∏–∏ cooja –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã. –¢–∞–∫ —á—Ç–æ –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ —Ç–æ–≥–æ, –¥–µ–ª–∞–µ–º –º—ã –Ω–æ–≤—É—é –ø–ª–∞—Ç—Ñ–æ—Ä–º—É –∏–ª–∏ –Ω–µ—Ç, –Ω–∞–º –Ω–∞–¥–æ –±—É–¥–µ—Ç –¥–µ–ª–∞—Ç—å customrules, –µ—Å–ª–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ —Ç—Ä–µ–±—É–µ—Ç –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ —Å–±–æ—Ä–∫–∏ (–¥–ª—è —Å–ª—É—á–∞—è out-of-tree –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã). –ù–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è cooja —ç—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã JNI –±–∏–±–ª–∏–æ—Ç–µ–∫—É —Å–æ–±–∏—Ä–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ (–Ω–∞—Å–∫–æ–ª—å–∫–æ —è –ø–æ–Ω—è–ª).
–í–æ–∑–º–æ–∂–Ω–æ, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏–∑ Makefiles.customrules-$(TARGET) –º–æ–∂–Ω–æ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –≤ Makefile.$(TARGET), –Ω–æ –º–Ω–µ –∫–∞–∂–µ—Ç—Å—è —Ç–∞–∫ —Å–¥–µ–ª–∞—Ç—å –Ω–µ –ø–æ–ª—É—á–∏—Ç—Å—è, —Ç.–∫. –µ—Å–ª–∏ –±—ã —ç—Ç–æ –±—ã–ª–æ –≤–æ–∑–º–æ–∂–Ω–æ, —Ç–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–¥–µ–ª–∞–ª–∏ –±—ã —Ç–∞–∫ —Å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π cooja.
–ß—Ç–æ –≤—ã –¥—É–º–∞–µ—Ç–µ –ø–æ —ç—Ç–æ–º—É –ø–æ–≤–æ–¥—É?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/alexrayne,7,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330837965,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","–¥–ª—è –º–µ–Ω—è –≤–æ–æ–±—â–µ —Ç–µ–º–µ–Ω —Å–º—ã—Å–ª Makefile.customrules-$(TARGET)  –≤ –∫–∞—Ç–∞–ª–æ–≥–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã. –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –∫–∞–∫–æ–π—Ç–æ –º–µ–ª–∫–∏–π –∫–æ—Å—Ç—ã–ª—å.  –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω—ã–π –¥–ª—è –≤–Ω–µ—Å–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –ø—Ä–∞–≤–∏–ª —Å–±–æ—Ä–∫–∏ –∑–∞–¥–∞–Ω–Ω—ã—Ö —Ä–∞–Ω–µ–µ CPU_FAMILY. —Ç–æ–µ—Å—Ç—å –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏—è –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–∞–ª–∞—Å—å –Ω–µ –¥–ª—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∞ –¥–ª—è –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Å–±–æ—Ä–∫–∏ –∫—Ä–æ—Å—Å-–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –ø–æ–¥ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É.
–∏–º—Ö–æ, –í–∞—à –ø–∞—Ç—á –ø—Ä–∏–¥–∞–µ—Ç –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏–∏ –±–æ–ª–µ–µ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–π —Å–º—ã—Å–ª, –∞ —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ –∏—Å–ø—Ä–∞–≤–ª—è–µ—Ç –±–∞–≥—É.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/alexrayne,8,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330840426,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","–∫—Å—Ç–∞—Ç–µ, –í—ã –æ—Å—Ç–∞–≤–∏–ª–∏ —Å–≤–æ–π –ø–∞—Ç—á –≤ –≤–µ—Ç–∫–µ master. –∞ —ç—Ç–æ –∑–Ω–∞—á–∏—Ç —á—Ç–æ –∫–∞–∂–¥—ã–π –Ω–æ–≤—ã–π –∫–æ–º–º–∏—Ç –±—ã–¥–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è –≤ —ç—Ç–æ—Ç PR. –ª—É—á—à–µ–±—ã –≤–∞–º –Ω–∞–∑–Ω–∞—á–∏—Ç—å –≤–∞—à –ø–∞—Ç—á –≤ –¥—Ä—É–≥—É—é –≤–µ—Ç–∫—É, –∞ —Ä–∞–±–æ—Ç–∞—Ç—å –≤ –º–∞—Å—Ç–µ—Ä–µ.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2328,2017-09-19T10:33:28Z,2017-09-20T14:00:54Z,2017-09-20T14:09:12Z,CLOSED,False,0,0,0,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories.",0,[],https://github.com/contiki-os/contiki/pull/2328,https://github.com/ivan-alekhin,9,https://github.com/contiki-os/contiki/pull/2328#issuecomment-330863304,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","@alexrayne, —Å–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–º–æ—â—å, —è –ø–æ–ø—Ä–∞–≤–∏–ª —ç—Ç–æ –∏ —Å–¥–µ–ª–∞–ª –Ω–æ–≤—ã–π PR (#2332).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2329,2017-09-20T09:18:34Z,,2017-09-20T09:18:34Z,OPEN,False,8,0,1,https://github.com/alexrayne,"!lib/assert - fix for c++ usage, since it overrides standart lib header",1,[],https://github.com/contiki-os/contiki/pull/2329,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2329,"since assert.h is a standart lib header, so need to protect it for c++ usage.
<assert.h> natively must be compatible with c++, since it is compatible in standart lib.","since assert.h is a standart lib header, so need to protect it for c++ usage.
<assert.h> natively must be compatible with c++, since it is compatible in standart lib.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2330,2017-09-20T09:19:54Z,,2017-09-20T09:19:54Z,OPEN,False,10,14,1,https://github.com/alexrayne,frame802154_extract_linkaddr - tolerant for LINKADDR_SIZE,1,[],https://github.com/contiki-os/contiki/pull/2330,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2330,"frame builder just copy linkaddr at frame802154 dst/src adress, and requres only fit linkaddr into frame`s space.
So extracting linkaddr from frame sould be same.
Old behaviour strictly cheks that frame adress must be exact same as linkadress, therefore
when LINKADDR_SIZE != 8, incoming frames not recognised even if them was builded on same system.


          a bit more optimised for NULL arguments","frame builder just copy linkaddr at frame802154 dst/src adress, and requres only fit linkaddr into frame`s space.
So extracting linkaddr from frame sould be same.
Old behaviour strictly cheks that frame adress must be exact same as linkadress, therefore
when LINKADDR_SIZE != 8, incoming frames not recognised even if them was builded on same system.


          a bit more optimised for NULL arguments",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2332,2017-09-20T14:07:17Z,,2017-11-02T09:32:56Z,OPEN,False,2,1,1,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories (fixed source branch).",1,[],https://github.com/contiki-os/contiki/pull/2332,https://github.com/ivan-alekhin,1,https://github.com/contiki-os/contiki/pull/2332,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2332,2017-09-20T14:07:17Z,,2017-11-02T09:32:56Z,OPEN,False,2,1,1,https://github.com/ivan-alekhin,"Allow to search ""customrules"" in additional directories (fixed source branch).",1,[],https://github.com/contiki-os/contiki/pull/2332,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2332#issuecomment-330979271,"This PR allows to define Makefile.customrules-$(TARGET) files outside of Contiki source tree (for instance, to define custom out-of-tree version of cooja target).","–º–æ–∂–µ—Ç –í—ã –µ—â–µ issue#2327 –∏–Ω—Å–ø–µ–∫—Ç–∏—Ä—É–µ—Ç–µ, —Ä–∞–∑ —ç—Ç–æ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º–æ–π –∑–∞–Ω—è–ª–∏—Å—å?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2334,2017-09-22T12:07:38Z,,2018-05-16T11:59:30Z,OPEN,False,70,15,4,https://github.com/alexrayne,*TSCH:tsch_XXX_process_pending  smarter events pending,3,[],https://github.com/contiki-os/contiki/pull/2334,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2334,"make pending TSCH events thread more granular:

yields on every pending step
and log processing with less prioritete - prefer rx/tx pendings


this patch should make tsch events fater response, and more flexibe for pt scheduling","make pending TSCH events thread more granular:

yields on every pending step
and log processing with less prioritete - prefer rx/tx pendings


this patch should make tsch events fater response, and more flexibe for pt scheduling",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2334,2017-09-22T12:07:38Z,,2018-05-16T11:59:30Z,OPEN,False,70,15,4,https://github.com/alexrayne,*TSCH:tsch_XXX_process_pending  smarter events pending,3,[],https://github.com/contiki-os/contiki/pull/2334,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2334#issuecomment-387086663,"make pending TSCH events thread more granular:

yields on every pending step
and log processing with less prioritete - prefer rx/tx pendings


this patch should make tsch events fater response, and more flexibe for pt scheduling",provided trivial fix for robustness over proto-thread,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2334,2017-09-22T12:07:38Z,,2018-05-16T11:59:30Z,OPEN,False,70,15,4,https://github.com/alexrayne,*TSCH:tsch_XXX_process_pending  smarter events pending,3,[],https://github.com/contiki-os/contiki/pull/2334,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2334#issuecomment-389493352,"make pending TSCH events thread more granular:

yields on every pending step
and log processing with less prioritete - prefer rx/tx pendings


this patch should make tsch events fater response, and more flexibe for pt scheduling","now provided choose of tsch_polling _event thread code by config TSCH_CONF_POLLING_STYLE
provided style TSCH_POLLING_STRONG and TSCH_POLLING_RELAXED. relaxed style use PROCESS_PAUSE for yielding.
also in relaxed style fixed - now TX events process surely before RECV events. This is must provide order that event for packet sent invokes before received answer packet.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2338,2017-09-26T16:48:21Z,2017-10-04T08:59:39Z,2017-10-09T13:31:38Z,MERGED,True,1,1,1,https://github.com/tim-ist,cc26xx/sensortag: Use correct calibration data structure size,1,[],https://github.com/contiki-os/contiki/pull/2338,https://github.com/tim-ist,1,https://github.com/contiki-os/contiki/pull/2338,"The CALIB_DATA_SIZE was set to 24 while the actual structure size is 28.
Because of this, some other variables in the module were overwritten after the sensor read operation. This, for example, prevented reading the temperature immediately after the pressure (or vice versa), because the ""enabled"" static variable contained garbage.","The CALIB_DATA_SIZE was set to 24 while the actual structure size is 28.
Because of this, some other variables in the module were overwritten after the sensor read operation. This, for example, prevented reading the temperature immediately after the pressure (or vice versa), because the ""enabled"" static variable contained garbage.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2338,2017-09-26T16:48:21Z,2017-10-04T08:59:39Z,2017-10-09T13:31:38Z,MERGED,True,1,1,1,https://github.com/tim-ist,cc26xx/sensortag: Use correct calibration data structure size,1,[],https://github.com/contiki-os/contiki/pull/2338,https://github.com/msloth,2,https://github.com/contiki-os/contiki/pull/2338#issuecomment-334090101,"The CALIB_DATA_SIZE was set to 24 while the actual structure size is 28.
Because of this, some other variables in the module were overwritten after the sensor read operation. This, for example, prevented reading the temperature immediately after the pressure (or vice versa), because the ""enabled"" static variable contained garbage.","üëç looks good, and is correct",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2343,2017-10-06T12:14:31Z,2017-10-06T12:15:40Z,2017-10-06T12:15:46Z,CLOSED,False,1,0,1,https://github.com/fleutot,Make git ignore generated *.co files,1,[],https://github.com/contiki-os/contiki/pull/2343,https://github.com/fleutot,1,https://github.com/contiki-os/contiki/pull/2343,"*.co files are generated in regressions tests' code folder. These clutter the result of git status, it is especially annoying when working in a repo that has contiki as a submodule.","*.co files are generated in regressions tests' code folder. These clutter the result of git status, it is especially annoying when working in a repo that has contiki as a submodule.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2344,2017-10-06T12:24:08Z,,2017-10-06T12:24:08Z,OPEN,False,1,0,1,https://github.com/fleutot,Make git ignore generated *.co files,1,[],https://github.com/contiki-os/contiki/pull/2344,https://github.com/fleutot,1,https://github.com/contiki-os/contiki/pull/2344,"*.co files are generated in regressions tests' code folder among others. These clutter the result of git status, it is especially annoying when working in a repo that has contiki as a submodule.","*.co files are generated in regressions tests' code folder among others. These clutter the result of git status, it is especially annoying when working in a repo that has contiki as a submodule.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2346,2017-10-09T11:56:08Z,,2017-10-10T08:15:07Z,OPEN,False,1,1,1,https://github.com/fleutot,Set Orchestra's default debug output level to none,1,[],https://github.com/contiki-os/contiki/pull/2346,https://github.com/fleutot,1,https://github.com/contiki-os/contiki/pull/2346,"Debug printf is meant for development. An application using Orchestra
does not want output on by default.","Debug printf is meant for development. An application using Orchestra
does not want output on by default.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2346,2017-10-09T11:56:08Z,,2017-10-10T08:15:07Z,OPEN,False,1,1,1,https://github.com/fleutot,Set Orchestra's default debug output level to none,1,[],https://github.com/contiki-os/contiki/pull/2346,https://github.com/fleutot,2,https://github.com/contiki-os/contiki/pull/2346#issuecomment-335396400,"Debug printf is meant for development. An application using Orchestra
does not want output on by default.","Regression test for tsch-orchestra fails, since it expects the output to check if Orchestra started.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2347,2017-10-10T08:49:39Z,2017-10-11T13:47:36Z,2017-10-13T07:51:26Z,MERGED,True,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors. ,4,[],https://github.com/contiki-os/contiki/pull/2347,https://github.com/posjodin,1,https://github.com/contiki-os/contiki/pull/2347,"Support for UART and I2C communication, with configurable duty cycling. Works also with PMS 3003 (and probably other PMS X003 sensors).
(Previously submitted as pull request #2223)","Support for UART and I2C communication, with configurable duty cycling. Works also with PMS 3003 (and probably other PMS X003 sensors).
(Previously submitted as pull request #2223)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2347,2017-10-10T08:49:39Z,2017-10-11T13:47:36Z,2017-10-13T07:51:26Z,MERGED,True,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors. ,4,[],https://github.com/contiki-os/contiki/pull/2347,https://github.com/nvt,2,https://github.com/contiki-os/contiki/pull/2347#issuecomment-335815178,"Support for UART and I2C communication, with configurable duty cycling. Works also with PMS 3003 (and probably other PMS X003 sensors).
(Previously submitted as pull request #2223)",üëç,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2347,2017-10-10T08:49:39Z,2017-10-11T13:47:36Z,2017-10-13T07:51:26Z,MERGED,True,976,0,9,https://github.com/posjodin,Driver for Plantower PMS 5003 dust sensors. ,4,[],https://github.com/contiki-os/contiki/pull/2347,https://github.com/posjodin,3,https://github.com/contiki-os/contiki/pull/2347#issuecomment-336378007,"Support for UART and I2C communication, with configurable duty cycling. Works also with PMS 3003 (and probably other PMS X003 sensors).
(Previously submitted as pull request #2223)",Many thanks!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2349,2017-10-11T11:00:41Z,2017-10-11T14:34:29Z,2017-10-11T14:34:29Z,CLOSED,False,67,0,6,https://github.com/alexrayne,cc26xx:rtc isr ch2 handler support,2,[],https://github.com/contiki-os/contiki/pull/2349,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2349,Here provided patch adding handler soc_rtc_on_isr_ch2 - for RTC irq on CH2 compare,Here provided patch adding handler soc_rtc_on_isr_ch2 - for RTC irq on CH2 compare,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2349,2017-10-11T11:00:41Z,2017-10-11T14:34:29Z,2017-10-11T14:34:29Z,CLOSED,False,67,0,6,https://github.com/alexrayne,cc26xx:rtc isr ch2 handler support,2,[],https://github.com/contiki-os/contiki/pull/2349,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2349#issuecomment-335831335,Here provided patch adding handler soc_rtc_on_isr_ch2 - for RTC irq on CH2 compare,accasionaly here is PR#2351,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2350,2017-10-11T11:02:44Z,,2017-10-11T11:02:44Z,OPEN,False,5,8,1,https://github.com/alexrayne,*cc26xx:clock:clock_seconds - trivial optimisation,1,[],https://github.com/contiki-os/contiki/pull/2350,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2350,"code for cc26xx clock_time takes strange global IE mask no single register access.
just remove this GIE disable/enable code, since it useless","code for cc26xx clock_time takes strange global IE mask no single register access.
just remove this GIE disable/enable code, since it useless",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2351,2017-10-11T11:04:46Z,,2019-04-19T18:27:46Z,OPEN,False,60,0,4,https://github.com/alexrayne,+cc26xx:prop-mode:rf on timeout - prevents code hung when OSC not start,3,[],https://github.com/contiki-os/contiki/pull/2351,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2351,"turn on radio checks HF OSC for timeout, ant fails if OSC not ready for RF_CORE_CONF_HFOSC_STARTUP_TOUS
+cc26xx:oscillators:oscillators_wait_ready_hf_xosc - waiting HF OSC ready until timeout
*Note - if OSC is bad, and can`t start, therefore mcu hung forever. when RF_CORE_CONF_HFOSC_STARTUP_TOUS defined, it checks with this timeout and reports failure","turn on radio checks HF OSC for timeout, ant fails if OSC not ready for RF_CORE_CONF_HFOSC_STARTUP_TOUS
+cc26xx:oscillators:oscillators_wait_ready_hf_xosc - waiting HF OSC ready until timeout
*Note - if OSC is bad, and can`t start, therefore mcu hung forever. when RF_CORE_CONF_HFOSC_STARTUP_TOUS defined, it checks with this timeout and reports failure",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2351,2017-10-11T11:04:46Z,,2019-04-19T18:27:46Z,OPEN,False,60,0,4,https://github.com/alexrayne,+cc26xx:prop-mode:rf on timeout - prevents code hung when OSC not start,3,[],https://github.com/contiki-os/contiki/pull/2351,https://github.com/amitbhanja,2,https://github.com/contiki-os/contiki/pull/2351#issuecomment-484394433,"turn on radio checks HF OSC for timeout, ant fails if OSC not ready for RF_CORE_CONF_HFOSC_STARTUP_TOUS
+cc26xx:oscillators:oscillators_wait_ready_hf_xosc - waiting HF OSC ready until timeout
*Note - if OSC is bad, and can`t start, therefore mcu hung forever. when RF_CORE_CONF_HFOSC_STARTUP_TOUS defined, it checks with this timeout and reports failure",Thanks for the commit. What should be the value of RF_CORE_HFOSC_STARTUP_TOUS ?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2351,2017-10-11T11:04:46Z,,2019-04-19T18:27:46Z,OPEN,False,60,0,4,https://github.com/alexrayne,+cc26xx:prop-mode:rf on timeout - prevents code hung when OSC not start,3,[],https://github.com/contiki-os/contiki/pull/2351,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2351#issuecomment-484651805,"turn on radio checks HF OSC for timeout, ant fails if OSC not ready for RF_CORE_CONF_HFOSC_STARTUP_TOUS
+cc26xx:oscillators:oscillators_wait_ready_hf_xosc - waiting HF OSC ready until timeout
*Note - if OSC is bad, and can`t start, therefore mcu hung forever. when RF_CORE_CONF_HFOSC_STARTUP_TOUS defined, it checks with this timeout and reports failure","Thanks for the commit. What should be the value of RF_CORE_HFOSC_STARTUP_TOUS ?

RF_CORE_HFOSC_STARTUP_TOUS  - is a timeout in [us]. for cc1350 OSC should wakeup less then  300-500us. so, i guess, 700us enough",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2351,2017-10-11T11:04:46Z,,2019-04-19T18:27:46Z,OPEN,False,60,0,4,https://github.com/alexrayne,+cc26xx:prop-mode:rf on timeout - prevents code hung when OSC not start,3,[],https://github.com/contiki-os/contiki/pull/2351,https://github.com/richarddonkin,4,https://github.com/contiki-os/contiki/pull/2351#issuecomment-484979176,"turn on radio checks HF OSC for timeout, ant fails if OSC not ready for RF_CORE_CONF_HFOSC_STARTUP_TOUS
+cc26xx:oscillators:oscillators_wait_ready_hf_xosc - waiting HF OSC ready until timeout
*Note - if OSC is bad, and can`t start, therefore mcu hung forever. when RF_CORE_CONF_HFOSC_STARTUP_TOUS defined, it checks with this timeout and reports failure","Thanks for the commit. What should be the value of RF_CORE_HFOSC_STARTUP_TOUS ?

I use 1000 (as in the commented #define). It seems to work well.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2352,2017-10-11T11:07:24Z,,2020-06-13T19:22:42Z,OPEN,False,61,21,2,https://github.com/alexrayne,!TSCH:on/off control  - fixed for sure deactivate TSCH stack,4,[],https://github.com/contiki-os/contiki/pull/2352,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2352,"tsch MAC stack off() now can surely deactivate TSCH until on()
!     tschmac_driver.off - now disassociates. there was leaving associated state
after turn_off. it looks - invalid behaviour.
!     tsch_process - now waits activation before start net association/coordinator


tsch_status - provides more complex.tsch states scheme - append ACTIVE phase.
          also a bit optimisation about memory usage.





bool args - a bit optimisation on code and memoty via use bool, that can be smaller then int



*Note: tsch_process was try to start association/coordinator always when it not associated.
this process is turn on rf. so there is no way to turn RF activity off with TSCH.
now introduces tschACTIVE phase for tsch state. and tschmac_driver.on/off are
control over it. so invoke NETSTACK_MAC.on()/off() is enough to completely control
RF activity RF and TSCH stack.","tsch MAC stack off() now can surely deactivate TSCH until on()
!     tschmac_driver.off - now disassociates. there was leaving associated state
after turn_off. it looks - invalid behaviour.
!     tsch_process - now waits activation before start net association/coordinator


tsch_status - provides more complex.tsch states scheme - append ACTIVE phase.
          also a bit optimisation about memory usage.





bool args - a bit optimisation on code and memoty via use bool, that can be smaller then int



*Note: tsch_process was try to start association/coordinator always when it not associated.
this process is turn on rf. so there is no way to turn RF activity off with TSCH.
now introduces tschACTIVE phase for tsch state. and tschmac_driver.on/off are
control over it. so invoke NETSTACK_MAC.on()/off() is enough to completely control
RF activity RF and TSCH stack.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2353,2017-10-11T14:37:36Z,,2017-10-11T14:37:36Z,OPEN,False,8,0,2,https://github.com/alexrayne,+cc26xx:RTC - add handle of RTC CH2 event.,1,[],https://github.com/contiki-os/contiki/pull/2353,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2353,"Here provided patch adding handler soc_rtc_on_isr_ch2 - for RTC irq on CH2 compare

this handle executes RTC ISR, so user can provide it own handle, an got it`s events","Here provided patch adding handler soc_rtc_on_isr_ch2 - for RTC irq on CH2 compare

this handle executes RTC ISR, so user can provide it own handle, an got it`s events",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2361,2017-10-25T10:09:48Z,,2017-10-31T15:33:45Z,OPEN,False,93,5,2,https://github.com/alexrayne,+lib:crc16:lookup8 - append faster lookup citt crc16 ,2,[],https://github.com/contiki-os/contiki/pull/2361,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2361,"append implementation on citt crc16 via lookup table.
contiki configuration choose implementation by macro :CRC16_STYLE
0 -  basic slowest citt
1 -  fast lookup citt","append implementation on citt crc16 via lookup table.
contiki configuration choose implementation by macro :CRC16_STYLE
0 -  basic slowest citt
1 -  fast lookup citt",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2362,2017-10-25T10:12:49Z,,2017-11-03T14:13:53Z,OPEN,False,31,11,4,https://github.com/alexrayne,+TSCH:phantom neibohor adress - for organise sending que,2,[],https://github.com/contiki-os/contiki/pull/2362,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2362,"provided ability to override adress used by TSCH system, over receiver adress provided for other net stack. this done via packetbuf  adress attribute PACKETBUF_ADDR_TSCH_RECEIVER
+tsch:conf:TSCH_CONF_WITH_PHANTOM_NBR - allows support for phantom tsch adress.


TSCH collects sending packets in queues - personal one for every neibohour. this
directs strong sending order for neibohour over all links/time slots.
Since nebohours enumerates by ones net adress, this queuing leads to confuses on
broadcast adress. if need to organise mutiple independent streams on different links
need to introduce personal nebohour, with its own que, for every stream. that is for phantom adress provided - this is adress, that TSCH uses to access to neibohour and its links and que. real receiver adress, packed into sending packet
can be everithing.


Using:



allocate some tsch links binded for phantom adress (vaddr).
pass vaddr to packetbuf attribute PACKETBUF_ADDR_TSCH_RECEIVER before send.


this is not an exact alternative for PACKETBUF_ATTR_TSCH_SLOTFRAME/TIMESLOT
thouse attributes keeps sending order to receiver as is, in cost of skips timeslots
until apropriated comes.
Introduced phantom adress  denoted for break sending order via indepndent queue.
sending order on phandom  ebohour que still strong.
So you can pass into this pantom adress multiple packets  to different receivers,
and them sends in exact order.","provided ability to override adress used by TSCH system, over receiver adress provided for other net stack. this done via packetbuf  adress attribute PACKETBUF_ADDR_TSCH_RECEIVER
+tsch:conf:TSCH_CONF_WITH_PHANTOM_NBR - allows support for phantom tsch adress.


TSCH collects sending packets in queues - personal one for every neibohour. this
directs strong sending order for neibohour over all links/time slots.
Since nebohours enumerates by ones net adress, this queuing leads to confuses on
broadcast adress. if need to organise mutiple independent streams on different links
need to introduce personal nebohour, with its own que, for every stream. that is for phantom adress provided - this is adress, that TSCH uses to access to neibohour and its links and que. real receiver adress, packed into sending packet
can be everithing.


Using:



allocate some tsch links binded for phantom adress (vaddr).
pass vaddr to packetbuf attribute PACKETBUF_ADDR_TSCH_RECEIVER before send.


this is not an exact alternative for PACKETBUF_ATTR_TSCH_SLOTFRAME/TIMESLOT
thouse attributes keeps sending order to receiver as is, in cost of skips timeslots
until apropriated comes.
Introduced phantom adress  denoted for break sending order via indepndent queue.
sending order on phandom  ebohour que still strong.
So you can pass into this pantom adress multiple packets  to different receivers,
and them sends in exact order.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2368,2017-11-01T13:57:25Z,,2017-11-03T04:13:52Z,OPEN,False,254,0,1,https://github.com/xioabudian,smartrf-settings-868MHz-625bps.c,1,[],https://github.com/contiki-os/contiki/pull/2368,https://github.com/xioabudian,1,https://github.com/contiki-os/contiki/pull/2368,"THE PARAMETERS OF THESE COMMANDS AND THE REGISTER PARAMETERS ARE FROM SMARTRF STUDIO 2.6.0
AND CC26XX-CC13XX. THEY TESTED ON  CC1310-LAUNCHPAD REV 1.4
testing platform:CC1310-LaunchPad Rev 1.4
frequency:868MHz
mode:long range mode
rate: 625bps","THE PARAMETERS OF THESE COMMANDS AND THE REGISTER PARAMETERS ARE FROM SMARTRF STUDIO 2.6.0
AND CC26XX-CC13XX. THEY TESTED ON  CC1310-LAUNCHPAD REV 1.4
testing platform:CC1310-LaunchPad Rev 1.4
frequency:868MHz
mode:long range mode
rate: 625bps",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2368,2017-11-01T13:57:25Z,,2017-11-03T04:13:52Z,OPEN,False,254,0,1,https://github.com/xioabudian,smartrf-settings-868MHz-625bps.c,1,[],https://github.com/contiki-os/contiki/pull/2368,https://github.com/xioabudian,2,https://github.com/contiki-os/contiki/pull/2368#issuecomment-341114052,"THE PARAMETERS OF THESE COMMANDS AND THE REGISTER PARAMETERS ARE FROM SMARTRF STUDIO 2.6.0
AND CC26XX-CC13XX. THEY TESTED ON  CC1310-LAUNCHPAD REV 1.4
testing platform:CC1310-LaunchPad Rev 1.4
frequency:868MHz
mode:long range mode
rate: 625bps","We create a radio configuration about long range mode on CC1310-LaunchPad Rev 1.4,named smartrf-settings-868MHz-625bps.c file",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2368,2017-11-01T13:57:25Z,,2017-11-03T04:13:52Z,OPEN,False,254,0,1,https://github.com/xioabudian,smartrf-settings-868MHz-625bps.c,1,[],https://github.com/contiki-os/contiki/pull/2368,https://github.com/xioabudian,3,https://github.com/contiki-os/contiki/pull/2368#issuecomment-341619373,"THE PARAMETERS OF THESE COMMANDS AND THE REGISTER PARAMETERS ARE FROM SMARTRF STUDIO 2.6.0
AND CC26XX-CC13XX. THEY TESTED ON  CC1310-LAUNCHPAD REV 1.4
testing platform:CC1310-LaunchPad Rev 1.4
frequency:868MHz
mode:long range mode
rate: 625bps","Hi, I want to push cc1310 long range configuration to contiki-os,but i encounter doxygen warnings [https://travis-ci.org/contiki-os/contiki/builds/296602698],anyone else could tell me how to fix these warnings?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2369,2017-11-02T04:03:17Z,,2017-11-03T08:28:48Z,OPEN,False,275,0,1,https://github.com/xioabudian,add long range mode configuration on cc1310-launchpad rev 1.4,9,[],https://github.com/contiki-os/contiki/pull/2369,https://github.com/xioabudian,1,https://github.com/contiki-os/contiki/pull/2369,"/*

THE PARAMETERS OF THESE COMMANDS AND THE REGISTER PARAMETERS ARE FROM SMARTRF STUDIO 2.6.0
AND CC26XX-CC13XX. THEY TESTED ON  CC1310-LAUNCHPAD REV 1.4
testing platform:CC1310-LaunchPad Rev 1.4
frequency:868MHz
mode:long range mode
rate: 625bps
*/","/*

THE PARAMETERS OF THESE COMMANDS AND THE REGISTER PARAMETERS ARE FROM SMARTRF STUDIO 2.6.0
AND CC26XX-CC13XX. THEY TESTED ON  CC1310-LAUNCHPAD REV 1.4
testing platform:CC1310-LaunchPad Rev 1.4
frequency:868MHz
mode:long range mode
rate: 625bps
*/",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2371,2017-11-02T15:57:57Z,,2017-11-02T15:57:57Z,OPEN,False,11,5,1,https://github.com/alexrayne,+TSCH:TSCH_ON_SLOT_TX/RX - provide hooks calls after slot completes,1,[],https://github.com/contiki-os/contiki/pull/2371,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2371,"here provided hook callbacks at completion of slots.:
TSCH:TSCH_ON_SLOT_TX(mac_tx_status) - called afer tx slot
TSCH_ON_SLOT_RX(frame_valid) - on rx slot
such callbacks are called in context of rtimer isr, so it should be used carefuly.","here provided hook callbacks at completion of slots.:
TSCH:TSCH_ON_SLOT_TX(mac_tx_status) - called afer tx slot
TSCH_ON_SLOT_RX(frame_valid) - on rx slot
such callbacks are called in context of rtimer isr, so it should be used carefuly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2372,2017-11-02T16:02:10Z,,2017-12-22T13:15:21Z,OPEN,False,56,27,4,https://github.com/alexrayne,TSCH boolean flasg optimisations,4,[],https://github.com/contiki-os/contiki/pull/2372,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2372,"here provided an trivial optimisations:

for some null pointer chesks
for boolean values allocation. uses bool type from ""stdbool.h"", unstead int. this could give a bit less data mamory usage .
also provide optimisations via inline checks of bool flags","here provided an trivial optimisations:

for some null pointer chesks
for boolean values allocation. uses bool type from ""stdbool.h"", unstead int. this could give a bit less data mamory usage .
also provide optimisations via inline checks of bool flags",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2372,2017-11-02T16:02:10Z,,2017-12-22T13:15:21Z,OPEN,False,56,27,4,https://github.com/alexrayne,TSCH boolean flasg optimisations,4,[],https://github.com/contiki-os/contiki/pull/2372,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2372#issuecomment-353596349,"here provided an trivial optimisations:

for some null pointer chesks
for boolean values allocation. uses bool type from ""stdbool.h"", unstead int. this could give a bit less data mamory usage .
also provide optimisations via inline checks of bool flags",append boolean migration for tsch_que_is_empty,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2373,2017-11-03T07:58:36Z,2018-05-07T13:01:50Z,2018-05-07T13:01:50Z,CLOSED,False,4,0,1,https://github.com/alexrayne,!TSCH:seq:ffff - avoid this value in counter,1,[],https://github.com/contiki-os/contiki/pull/2373,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2373,"framer 802154 treats value of seq=ffff as invalid, so avoid one in seq counter of TSCH stack","framer 802154 treats value of seq=ffff as invalid, so avoid one in seq counter of TSCH stack",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2373,2017-11-03T07:58:36Z,2018-05-07T13:01:50Z,2018-05-07T13:01:50Z,CLOSED,False,4,0,1,https://github.com/alexrayne,!TSCH:seq:ffff - avoid this value in counter,1,[],https://github.com/contiki-os/contiki/pull/2373,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2373#issuecomment-387057150,"framer 802154 treats value of seq=ffff as invalid, so avoid one in seq counter of TSCH stack","look like TSCH use 1byte seq, so check value ffff is not actual",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2374,2017-11-03T08:02:31Z,,2017-11-16T07:13:58Z,OPEN,False,15,0,2,https://github.com/alexrayne,+TSCH provides initialisation packet seq from RT,1,[],https://github.com/contiki-os/contiki/pull/2374,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2374,"TSCH_CONF_SEQ_FROMRT allows use RT for initalisation SEQ counter. this helps pass through duplicates filter.
When node frequently restarts, and seq value freese in init state. Therefore all sended packets, by frequently resets node, are filter out.","TSCH_CONF_SEQ_FROMRT allows use RT for initalisation SEQ counter. this helps pass through duplicates filter.
When node frequently restarts, and seq value freese in init state. Therefore all sended packets, by frequently resets node, are filter out.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2375,2017-11-03T14:18:20Z,,2017-12-29T15:11:21Z,OPEN,False,19,7,3,https://github.com/alexrayne,+TSCH:log:sec keys - append logging used security keys,2,[],https://github.com/contiki-os/contiki/pull/2375,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2375,"Here is provided enhancement for TSCH log, that shows frame type and security keyid","Here is provided enhancement for TSCH log, that shows frame type and security keyid",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2375,2017-11-03T14:18:20Z,,2017-12-29T15:11:21Z,OPEN,False,19,7,3,https://github.com/alexrayne,+TSCH:log:sec keys - append logging used security keys,2,[],https://github.com/contiki-os/contiki/pull/2375,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2375#issuecomment-354457667,"Here is provided enhancement for TSCH log, that shows frame type and security keyid",provided a smal fix for trivial buf - rx frames log ketid incorrect,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2377,2017-11-06T09:01:42Z,,2017-12-02T12:39:11Z,OPEN,False,8,1,1,https://github.com/alexrayne,!TSCH:tsch_security_init_nonce - fixed vs LINKADDR_SIZE < 8,2,[],https://github.com/contiki-os/contiki/pull/2377,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2377,"tsch nonce generated in stack variable, but it not cleanup whie fill in. also it denoted only for 8byte adress.
here provided patch fixes cleanup nonce nonused bytes to 0.
tested with ADDR_SIZE=4","tsch nonce generated in stack variable, but it not cleanup whie fill in. also it denoted only for 8byte adress.
here provided patch fixes cleanup nonce nonused bytes to 0.
tested with ADDR_SIZE=4",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2379,2017-11-07T19:18:38Z,,2017-11-07T19:18:38Z,OPEN,False,1560,0,11,https://github.com/alexrayne,"+cc26xx:crypto devices - aes, ccm, ccm-star drivers",1,[],https://github.com/contiki-os/contiki/pull/2379,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2379,"here provided ports of cc2538/crypto drivers for cc26xx:

cc26xx_ccm_star_driver
cc26xx_aes_128_driver","here provided ports of cc2538/crypto drivers for cc26xx:

cc26xx_ccm_star_driver
cc26xx_aes_128_driver",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2380,2017-11-07T19:22:01Z,,2017-11-07T19:22:01Z,OPEN,False,92,14,5,https://github.com/alexrayne,TSCH adaptive sync estimation of sync timeut,2,[],https://github.com/contiki-os/contiki/pull/2380,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2380,"+TSCH:tsch_timesync_estimate_sync_timeout - provides estimation for in-sync time. estimation calculates
from absolute maximum drifts, provided for learning.


TSCH_DESYNC_THRESHOLD_SLOTS() - provides hook for network leave timeout. used
                          by slots to detect loose of net, when time-source packets are loose



TSCH_TIMESYNC_ON_DRIFT(...) - hook for timesync_learn_drift_ticks, allows reacts on drift learning changes","+TSCH:tsch_timesync_estimate_sync_timeout - provides estimation for in-sync time. estimation calculates
from absolute maximum drifts, provided for learning.


TSCH_DESYNC_THRESHOLD_SLOTS() - provides hook for network leave timeout. used
                          by slots to detect loose of net, when time-source packets are loose



TSCH_TIMESYNC_ON_DRIFT(...) - hook for timesync_learn_drift_ticks, allows reacts on drift learning changes",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2381,2017-11-07T19:24:37Z,,2017-11-07T19:24:37Z,OPEN,False,11,5,1,https://github.com/alexrayne,*sys:proc:PROCESS_CONF_STATS  debug enhanced,1,[],https://github.com/contiki-os/contiki/pull/2381,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2381,"for debug puposes, when used PROCESS_CONF_STATS, remove ""static"" specifiers from variables. this static  hiding internal process events que so that debuger can`t show them like other global symblos.","for debug puposes, when used PROCESS_CONF_STATS, remove ""static"" specifiers from variables. this static  hiding internal process events que so that debuger can`t show them like other global symblos.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2382,2017-11-07T19:31:29Z,,2017-11-07T19:31:29Z,OPEN,False,180,42,8,https://github.com/alexrayne,TSCH user security keys an policy,6,[],https://github.com/contiki-os/contiki/pull/2382,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2382,"here provided set of patches:

provide info about received packets security in packetbuf attibutes
TSCH_SEC_KEY(key index, adress) - hook function, that provides user specified key for packets encription.
TSCH_SECURITY_CONF_STRICT - configuration set of options that control strictness  of security checks:
TSCH_SECURITY_STRICT_PAN_RELAX - allow unsecured packets in secured PAN/secured packets in unsecured PAN
TSCH_SECURITY_STRICT_KEYID_RELAX - allow use any key_id for secured frames, regards frame-type

So now

can be provided unsecured net with secured connections, and vice versa. Depends on user policy.
And for every nebohour can be provided specific set of keys.
Application can select security keys for encription.","here provided set of patches:

provide info about received packets security in packetbuf attibutes
TSCH_SEC_KEY(key index, adress) - hook function, that provides user specified key for packets encription.
TSCH_SECURITY_CONF_STRICT - configuration set of options that control strictness  of security checks:
TSCH_SECURITY_STRICT_PAN_RELAX - allow unsecured packets in secured PAN/secured packets in unsecured PAN
TSCH_SECURITY_STRICT_KEYID_RELAX - allow use any key_id for secured frames, regards frame-type

So now

can be provided unsecured net with secured connections, and vice versa. Depends on user policy.
And for every nebohour can be provided specific set of keys.
Application can select security keys for encription.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2383,2017-11-08T09:44:50Z,,2017-11-08T09:44:50Z,OPEN,False,1,1,1,https://github.com/alexrayne,!TSCH:orchestra - trivial fix,1,[],https://github.com/contiki-os/contiki/pull/2383,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2383,"Hallow!
looks like orchesta stay with a trivial bug about LINK_SEL attribute - it by default =9","Hallow!
looks like orchesta stay with a trivial bug about LINK_SEL attribute - it by default =9",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2384,2017-11-08T09:50:05Z,,2017-11-08T09:50:05Z,OPEN,False,18,1,4,https://github.com/alexrayne,TSCH LINK_SEL attribute for received packets,2,[],https://github.com/contiki-os/contiki/pull/2384,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2384,"Here provided option provides attributes PACKETBUF_ATTR_TSCH_SLOTFRAME/TIMESLOT for received packets.
this ability enables by setup TSCH_CONF_WITH_LINK_SELECTOR =2","Here provided option provides attributes PACKETBUF_ATTR_TSCH_SLOTFRAME/TIMESLOT for received packets.
this ability enables by setup TSCH_CONF_WITH_LINK_SELECTOR =2",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2385,2017-11-08T14:34:42Z,,2017-11-08T14:34:42Z,OPEN,False,1,1,1,https://github.com/MBradbury,When creating a MicaZ mote allow the source to be missing if the firmware is specified and vice versa,1,[],https://github.com/contiki-os/contiki/pull/2385,https://github.com/MBradbury,1,https://github.com/contiki-os/contiki/pull/2385,"MicaZ motes cannot be created in COOJA unless both source and firmware are specified. I would like to create a csc file where no source file is specified and only a firmware.
Sky and Z1 mote types currently allow this behaviour.","MicaZ motes cannot be created in COOJA unless both source and firmware are specified. I would like to create a csc file where no source file is specified and only a firmware.
Sky and Z1 mote types currently allow this behaviour.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2386,2017-11-08T16:29:38Z,,2017-11-08T16:29:38Z,OPEN,False,7,1,1,https://github.com/MBradbury,Correctly set the node id when running TinyOS binaries in Cooja with MicaZ motes,1,[],https://github.com/contiki-os/contiki/pull/2386,https://github.com/MBradbury,1,https://github.com/contiki-os/contiki/pull/2386,"When running TinyOS binaries in Cooja with MicaZ motes the error shown below is thrown. This is because TinyOS changes the variable name ""ActiveMessageAddressC$addr"" to ""ActiveMessageAddressC__addr"". This patch sets ActiveMessageAddressC__addr if it exists and otherwise falls back to setting the $ variable version. This is similar to how MspMoteID achieves this.
FATAL [main] (Cooja.java:1337) - Exception when loading simulation:
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: Unknown variable name: ActiveMessageAddressC$addr
at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3454)
at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3361)
at org.contikios.cooja.Cooja.quickStartSimulationConfig(Cooja.java:1330)
at org.contikios.cooja.Cooja.main(Cooja.java:3239)
Caused by: org.contikios.cooja.mote.memory.UnknownVariableException: Unknown variable name: ActiveMessageAddressC$addr
at org.contikios.cooja.mote.memory.VarMemory.getVariable(VarMemory.java:104)
at org.contikios.cooja.mote.memory.VarMemory.setIntValueOf(VarMemory.java:323)
at org.contikios.cooja.avrmote.interfaces.MicaZID.setMoteID(MicaZID.java:141)
at org.contikios.cooja.avrmote.interfaces.MicaZID.setConfigXML(MicaZID.java:171)
at org.contikios.cooja.avrmote.MicaZMote.setConfigXML(MicaZMote.java:259)
at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:734)
at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3432)
... 3 more","When running TinyOS binaries in Cooja with MicaZ motes the error shown below is thrown. This is because TinyOS changes the variable name ""ActiveMessageAddressC$addr"" to ""ActiveMessageAddressC__addr"". This patch sets ActiveMessageAddressC__addr if it exists and otherwise falls back to setting the $ variable version. This is similar to how MspMoteID achieves this.
FATAL [main] (Cooja.java:1337) - Exception when loading simulation:
org.contikios.cooja.Cooja$SimulationCreationException: Unknown error: Unknown variable name: ActiveMessageAddressC$addr
at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3454)
at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3361)
at org.contikios.cooja.Cooja.quickStartSimulationConfig(Cooja.java:1330)
at org.contikios.cooja.Cooja.main(Cooja.java:3239)
Caused by: org.contikios.cooja.mote.memory.UnknownVariableException: Unknown variable name: ActiveMessageAddressC$addr
at org.contikios.cooja.mote.memory.VarMemory.getVariable(VarMemory.java:104)
at org.contikios.cooja.mote.memory.VarMemory.setIntValueOf(VarMemory.java:323)
at org.contikios.cooja.avrmote.interfaces.MicaZID.setMoteID(MicaZID.java:141)
at org.contikios.cooja.avrmote.interfaces.MicaZID.setConfigXML(MicaZID.java:171)
at org.contikios.cooja.avrmote.MicaZMote.setConfigXML(MicaZMote.java:259)
at org.contikios.cooja.Simulation.setConfigXML(Simulation.java:734)
at org.contikios.cooja.Cooja.loadSimulationConfig(Cooja.java:3432)
... 3 more",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2388,2017-11-10T17:37:56Z,,2017-11-22T10:09:04Z,OPEN,False,67,34,3,https://github.com/alexrayne,+TSCH:tsch_packet_parse_my_eb - deploed EB parse and validity test.,3,[],https://github.com/contiki-os/contiki/pull/2388,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2388,"this patch exposes tsch scan resources for app usage. Now this resources can be used by application to provide own scan RF-air schemes.

tsch_temp_packet  - temporary input packet used by tsch_scan. This packet variable is surely included, when tsch_scan used. Now application can use it for it`s own purposes too.
tsch_packet_parse_my_eb  - tsch_scan EB parse and valifation procedure. This routine used by tsch_associate, it parse, and validate EB`s fo association. now App can use it too.
move struct input_packet to tsch-packet.h  - looks there is more native place","this patch exposes tsch scan resources for app usage. Now this resources can be used by application to provide own scan RF-air schemes.

tsch_temp_packet  - temporary input packet used by tsch_scan. This packet variable is surely included, when tsch_scan used. Now application can use it for it`s own purposes too.
tsch_packet_parse_my_eb  - tsch_scan EB parse and valifation procedure. This routine used by tsch_associate, it parse, and validate EB`s fo association. now App can use it too.
move struct input_packet to tsch-packet.h  - looks there is more native place",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2388,2017-11-10T17:37:56Z,,2017-11-22T10:09:04Z,OPEN,False,67,34,3,https://github.com/alexrayne,+TSCH:tsch_packet_parse_my_eb - deploed EB parse and validity test.,3,[],https://github.com/contiki-os/contiki/pull/2388,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2388#issuecomment-346303717,"this patch exposes tsch scan resources for app usage. Now this resources can be used by application to provide own scan RF-air schemes.

tsch_temp_packet  - temporary input packet used by tsch_scan. This packet variable is surely included, when tsch_scan used. Now application can use it for it`s own purposes too.
tsch_packet_parse_my_eb  - tsch_scan EB parse and valifation procedure. This routine used by tsch_associate, it parse, and validate EB`s fo association. now App can use it too.
move struct input_packet to tsch-packet.h  - looks there is more native place","fix strange gcc6-arm optimisation bug - static function optimises stack-frame, and it make  loose local variables",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2389,2017-11-10T17:39:25Z,,2017-11-14T19:40:32Z,OPEN,False,16,0,2,https://github.com/alexrayne,+process:process_abort - silent exit process,1,[],https://github.com/contiki-os/contiki/pull/2389,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2389,"process_abort provides extit process silently, without any events broadcast. this helps save cpu time on scheduler, when some process starts frequently.

after ending process, scheduler broadcats message PROCESS_EVENT_EXITED for all active processes.
(this is not happen at process_start - it only messages PROCESS_EVENT_INIT for started process)
process_abort imidiately set state of current process to NONE state, that breaks any process activity.

Usage:
// this process is starts frequently, to execute some simple thig, IO operation or else.
//    we no need any notification about finish, owner of this process alredy know all need.
//    so, if it ends silent, we save much cpu time on scheduler.
PROCESS_THREAD(rare_starts_process, ev, data){
    PROCESS_BEGIN();

    //.... here is some work
    if(some){
        PROCESS_ABORT(); // save cpu time on scheduler here
        PROCESS_EXIT();
    }
    //.... here is some work

    PROCESS_ABORT(); // save cpu time on scheduler here
    PROCESS_END();

}","process_abort provides extit process silently, without any events broadcast. this helps save cpu time on scheduler, when some process starts frequently.

after ending process, scheduler broadcats message PROCESS_EVENT_EXITED for all active processes.
(this is not happen at process_start - it only messages PROCESS_EVENT_INIT for started process)
process_abort imidiately set state of current process to NONE state, that breaks any process activity.

Usage:
// this process is starts frequently, to execute some simple thig, IO operation or else.
//    we no need any notification about finish, owner of this process alredy know all need.
//    so, if it ends silent, we save much cpu time on scheduler.
PROCESS_THREAD(rare_starts_process, ev, data){
    PROCESS_BEGIN();

    //.... here is some work
    if(some){
        PROCESS_ABORT(); // save cpu time on scheduler here
        PROCESS_EXIT();
    }
    //.... here is some work

    PROCESS_ABORT(); // save cpu time on scheduler here
    PROCESS_END();

}",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2389,2017-11-10T17:39:25Z,,2017-11-14T19:40:32Z,OPEN,False,16,0,2,https://github.com/alexrayne,+process:process_abort - silent exit process,1,[],https://github.com/contiki-os/contiki/pull/2389,https://github.com/msloth,2,https://github.com/contiki-os/contiki/pull/2389#issuecomment-344341004,"process_abort provides extit process silently, without any events broadcast. this helps save cpu time on scheduler, when some process starts frequently.

after ending process, scheduler broadcats message PROCESS_EVENT_EXITED for all active processes.
(this is not happen at process_start - it only messages PROCESS_EVENT_INIT for started process)
process_abort imidiately set state of current process to NONE state, that breaks any process activity.

Usage:
// this process is starts frequently, to execute some simple thig, IO operation or else.
//    we no need any notification about finish, owner of this process alredy know all need.
//    so, if it ends silent, we save much cpu time on scheduler.
PROCESS_THREAD(rare_starts_process, ev, data){
    PROCESS_BEGIN();

    //.... here is some work
    if(some){
        PROCESS_ABORT(); // save cpu time on scheduler here
        PROCESS_EXIT();
    }
    //.... here is some work

    PROCESS_ABORT(); // save cpu time on scheduler here
    PROCESS_END();

}","What's the use case with this PR? What benefit does it add?
You have about 45 open PRs (of the 150 open PRs). I hope you don't mind, I had a look at a couple, and have some general feedback that I hope you are open to.
You rarely state the benefit of the change, ie why it should be accepted. That users are given more choice (as this PR) is not really enough - things can be done in many ways, and adding more ways (and more code) is not necessarily a good thing. You need to provide a reason why something should be changed. Some PR messages claim performance gains, or code size reductions. Then, please add an example or two.
You generally need to work on code style. Naming of variables is mixed, extra whitespace added, and so on. I don't really follow your commit message style either, you seem to use chars like + and * to mean some various things. Spelling errors and similar sloppiness don't add confidence.
You often push more commits to old PRs long (months) after opening them, without explaining what changed or why, making it harder to review. Suppose someone is in the middle of testing or reviewing your PR and you then push more commits? Please do at least write a comment when you do this. Otherwise, how can someone know when the PR is ready to be reviewed? Ideally, it should be ready before the PR is opened.
I for one appreciate efforts in contributing, but I hope you understand the efforts required by mergers (of which I'm not) is most often much, much more. Finally, I hope you accept this as constructive feedback and an opportunity to improve.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2389,2017-11-10T17:39:25Z,,2017-11-14T19:40:32Z,OPEN,False,16,0,2,https://github.com/alexrayne,+process:process_abort - silent exit process,1,[],https://github.com/contiki-os/contiki/pull/2389,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2389#issuecomment-344373694,"process_abort provides extit process silently, without any events broadcast. this helps save cpu time on scheduler, when some process starts frequently.

after ending process, scheduler broadcats message PROCESS_EVENT_EXITED for all active processes.
(this is not happen at process_start - it only messages PROCESS_EVENT_INIT for started process)
process_abort imidiately set state of current process to NONE state, that breaks any process activity.

Usage:
// this process is starts frequently, to execute some simple thig, IO operation or else.
//    we no need any notification about finish, owner of this process alredy know all need.
//    so, if it ends silent, we save much cpu time on scheduler.
PROCESS_THREAD(rare_starts_process, ev, data){
    PROCESS_BEGIN();

    //.... here is some work
    if(some){
        PROCESS_ABORT(); // save cpu time on scheduler here
        PROCESS_EXIT();
    }
    //.... here is some work

    PROCESS_ABORT(); // save cpu time on scheduler here
    PROCESS_END();

}","msloth:


well, i provide explanation and reason as much as i can for this PR. is that enoungh? For other PR i take revision for some time. What example you mention for? is example in comment well?
i don`t made examples cause i not understand examples folder structure, and how work tests system.


i make many smapp PR, insteard one big sequence. to allow maintainer choose any one. is it bad?


for mixed variables names - looks i need to point it. normaly i try to use same naming style as other code.


what spaces are problem? can you point it?


5)about + and * - do you mean that i should not use it in commit message? why?
6)about my PR evolution - since PR is not accepted\rejected, i have no any sence that some one work with it (Travis always do 8) ). i places hotfix, or minor changes that not affects PR sentence. As saw other PRs, they includes fixes and changes during some conversation. So, i thought, this is normal practice. isn`t it?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2391,2017-11-13T00:17:18Z,2017-11-13T00:17:39Z,2017-11-13T00:17:39Z,CLOSED,False,1707,0,8,https://github.com/carlotapares,Ubidots demo,5,[],https://github.com/contiki-os/contiki/pull/2391,https://github.com/carlotapares,1,https://github.com/contiki-os/contiki/pull/2391,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2393,2017-11-13T18:00:42Z,,2017-12-12T13:38:25Z,OPEN,False,1831,2,19,https://github.com/stebosisio,Stm32nucleo st7580,5,[],https://github.com/contiki-os/contiki/pull/2393,https://github.com/stebosisio,1,https://github.com/contiki-os/contiki/pull/2393,"The port supports the following boards from ST:
- NUCLEO-L152RE board, based on the STM32L152RET6 ultra-low power microcontroller
- X-NUCLEO-PLM01A1 based on the ST7580 FSK, PSK multi-mode power line networking
system-on-chip expansion board

The port follows the same idea/structure of our already integrated stm32nucleo-spirit1 platform and we have kept in mind issues already discussed in the past for it (e.g. use a git submodule for CMSIS and for our existing headers/sources files that are kept unchanged, put long term maintainers' names in the readme file...)
ST CLAB team","The port supports the following boards from ST:
- NUCLEO-L152RE board, based on the STM32L152RET6 ultra-low power microcontroller
- X-NUCLEO-PLM01A1 based on the ST7580 FSK, PSK multi-mode power line networking
system-on-chip expansion board

The port follows the same idea/structure of our already integrated stm32nucleo-spirit1 platform and we have kept in mind issues already discussed in the past for it (e.g. use a git submodule for CMSIS and for our existing headers/sources files that are kept unchanged, put long term maintainers' names in the readme file...)
ST CLAB team",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2393,2017-11-13T18:00:42Z,,2017-12-12T13:38:25Z,OPEN,False,1831,2,19,https://github.com/stebosisio,Stm32nucleo st7580,5,[],https://github.com/contiki-os/contiki/pull/2393,https://github.com/stebosisio,2,https://github.com/contiki-os/contiki/pull/2393#issuecomment-344195674,"The port supports the following boards from ST:
- NUCLEO-L152RE board, based on the STM32L152RET6 ultra-low power microcontroller
- X-NUCLEO-PLM01A1 based on the ST7580 FSK, PSK multi-mode power line networking
system-on-chip expansion board

The port follows the same idea/structure of our already integrated stm32nucleo-spirit1 platform and we have kept in mind issues already discussed in the past for it (e.g. use a git submodule for CMSIS and for our existing headers/sources files that are kept unchanged, put long term maintainers' names in the readme file...)
ST CLAB team","I see that only doxygen regression test is failing, due to warnings, but these are also on contiki core's files. In fact I see that this test is failing on all the newest pull requests.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2393,2017-11-13T18:00:42Z,,2017-12-12T13:38:25Z,OPEN,False,1831,2,19,https://github.com/stebosisio,Stm32nucleo st7580,5,[],https://github.com/contiki-os/contiki/pull/2393,https://github.com/stebosisio,3,https://github.com/contiki-os/contiki/pull/2393#issuecomment-351053530,"The port supports the following boards from ST:
- NUCLEO-L152RE board, based on the STM32L152RET6 ultra-low power microcontroller
- X-NUCLEO-PLM01A1 based on the ST7580 FSK, PSK multi-mode power line networking
system-on-chip expansion board

The port follows the same idea/structure of our already integrated stm32nucleo-spirit1 platform and we have kept in mind issues already discussed in the past for it (e.g. use a git submodule for CMSIS and for our existing headers/sources files that are kept unchanged, put long term maintainers' names in the readme file...)
ST CLAB team","Hello,
we didn't receive any feedback on this PR... Can we have, at least, an initial feedback and/or some instructions on the next steps needed to propose a new platform for evaluation?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2394,2017-11-14T16:32:56Z,,2017-11-14T16:32:56Z,OPEN,False,11,1,2,https://github.com/alexrayne,*process:PROCESS_PAUSE - a bit optimised instantiation of pause,1,[],https://github.com/contiki-os/contiki/pull/2394,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2394,This patch introduce specialised function   process_post_pause  for posting PAUSE event.  this helps save a few bytes of code with no cost.,This patch introduce specialised function   process_post_pause  for posting PAUSE event.  this helps save a few bytes of code with no cost.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2397,2017-11-24T20:25:14Z,,2017-11-24T20:31:55Z,OPEN,False,107,0,2,https://github.com/therudo,Fixed issue with duplicate messages when ACK is lost. fix  #2085,2,[],https://github.com/contiki-os/contiki/pull/2397,https://github.com/therudo,1,https://github.com/contiki-os/contiki/pull/2397,"Added a list of packages already processed, so in case the ACK is missed the retransmitted message is not handled again.
Messages are identified by the MID, ip address and port.
There are two configurable parameters:

COAP_CHECK_DUPLICATES_LIST_SIZE
Define the maximum number of messages to track
COAP_CHECK_DUPLICATES_MAX_SECONDS
Amount of seconds to wait until a message on the list","Added a list of packages already processed, so in case the ACK is missed the retransmitted message is not handled again.
Messages are identified by the MID, ip address and port.
There are two configurable parameters:

COAP_CHECK_DUPLICATES_LIST_SIZE
Define the maximum number of messages to track
COAP_CHECK_DUPLICATES_MAX_SECONDS
Amount of seconds to wait until a message on the list",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2399,2017-12-01T18:56:23Z,2017-12-02T11:39:17Z,2017-12-02T11:40:05Z,CLOSED,False,14,2,3,https://github.com/alexrayne,fix TSCH - stop slots  operations on disassociate and some rtimer issue,1,[],https://github.com/contiki-os/contiki/pull/2399,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2399,"provide explisit slot operations stop on disassciaton. this helpful when need to sutdown after TSCH off.
also fix slot rtimer override - cancels slots rtimer before start new operation,
cause some implementation of rtimer cant override current running rtimer, and therefore slot not starts on expired rtimer. this situation leads to block whole tsch activity. ive got this issue wih PR#1290","provide explisit slot operations stop on disassciaton. this helpful when need to sutdown after TSCH off.
also fix slot rtimer override - cancels slots rtimer before start new operation,
cause some implementation of rtimer cant override current running rtimer, and therefore slot not starts on expired rtimer. this situation leads to block whole tsch activity. ive got this issue wih PR#1290",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2399,2017-12-01T18:56:23Z,2017-12-02T11:39:17Z,2017-12-02T11:40:05Z,CLOSED,False,14,2,3,https://github.com/alexrayne,fix TSCH - stop slots  operations on disassociate and some rtimer issue,1,[],https://github.com/contiki-os/contiki/pull/2399,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2399#issuecomment-348686445,"provide explisit slot operations stop on disassciaton. this helpful when need to sutdown after TSCH off.
also fix slot rtimer override - cancels slots rtimer before start new operation,
cause some implementation of rtimer cant override current running rtimer, and therefore slot not starts on expired rtimer. this situation leads to block whole tsch activity. ive got this issue wih PR#1290",closed for rearrange patch contents,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2400,2017-12-02T12:36:01Z,,2017-12-25T12:24:02Z,OPEN,False,16,2,3,https://github.com/alexrayne,fix TSCH - stop slots operations on disassociate with some rtimer issue,3,[],https://github.com/contiki-os/contiki/pull/2400,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2400,"here fixed some issues of rtimer use vs disassociation TSCH.

provide explisit slot operations stop on disassciaton. this helpful when need to sutdown after TSCH off.
also fix slot rtimer override - cancels slots rtimer before start new operation,
rtimer doesnot override current running rtimer. But some implementation even block running rtimer set again. Therefore slot not starts on rinning rtimer. this situation leads to block whole tsch activity. ive got this issue wih PR#1290","here fixed some issues of rtimer use vs disassociation TSCH.

provide explisit slot operations stop on disassciaton. this helpful when need to sutdown after TSCH off.
also fix slot rtimer override - cancels slots rtimer before start new operation,
rtimer doesnot override current running rtimer. But some implementation even block running rtimer set again. Therefore slot not starts on rinning rtimer. this situation leads to block whole tsch activity. ive got this issue wih PR#1290",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2400,2017-12-02T12:36:01Z,,2017-12-25T12:24:02Z,OPEN,False,16,2,3,https://github.com/alexrayne,fix TSCH - stop slots operations on disassociate with some rtimer issue,3,[],https://github.com/contiki-os/contiki/pull/2400,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2400#issuecomment-353865982,"here fixed some issues of rtimer use vs disassociation TSCH.

provide explisit slot operations stop on disassciaton. this helpful when need to sutdown after TSCH off.
also fix slot rtimer override - cancels slots rtimer before start new operation,
rtimer doesnot override current running rtimer. But some implementation even block running rtimer set again. Therefore slot not starts on rinning rtimer. this situation leads to block whole tsch activity. ive got this issue wih PR#1290","fixed stop during slot operation. there was leaved tsch lock in captured state, now stop forced TSCH to unlock",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2403,2017-12-04T14:35:18Z,,2017-12-06T13:44:10Z,OPEN,False,71,24,4,https://github.com/alexrayne,TSCH link adr and option lightweight change,3,[],https://github.com/contiki-os/contiki/pull/2403,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2403,"here provided TSCH scheduler methods for faster and blockless change link`s adress and option:

tsch_schedule_link_change_addr
tsch_schedule_link_change_option
This routines are faster vs new link remove/add","here provided TSCH scheduler methods for faster and blockless change link`s adress and option:

tsch_schedule_link_change_addr
tsch_schedule_link_change_option
This routines are faster vs new link remove/add",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2403,2017-12-04T14:35:18Z,,2017-12-06T13:44:10Z,OPEN,False,71,24,4,https://github.com/alexrayne,TSCH link adr and option lightweight change,3,[],https://github.com/contiki-os/contiki/pull/2403,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2403#issuecomment-349643343,"here provided TSCH scheduler methods for faster and blockless change link`s adress and option:

tsch_schedule_link_change_addr
tsch_schedule_link_change_option
This routines are faster vs new link remove/add","publish TSCH queues api functions: tsch_queue_remove_nbr , tsch_queue_flush_nbr - them are gives more control over TSCH heap memory for the app. also allows app drop connection to some disapeared node.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2408,2017-12-09T15:27:16Z,,2018-01-22T14:29:55Z,OPEN,False,1,1,1,https://github.com/cpsw,Small code style change,1,[],https://github.com/contiki-os/contiki/pull/2408,https://github.com/cpsw,1,https://github.com/contiki-os/contiki/pull/2408,Making the operator precedence explicit.,Making the operator precedence explicit.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2408,2017-12-09T15:27:16Z,,2018-01-22T14:29:55Z,OPEN,False,1,1,1,https://github.com/cpsw,Small code style change,1,[],https://github.com/contiki-os/contiki/pull/2408,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2408#issuecomment-350652300,Making the operator precedence explicit.,"why you not make this change everywhere?
you got same code below:
size = (prec || flags & ALT)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2408,2017-12-09T15:27:16Z,,2018-01-22T14:29:55Z,OPEN,False,1,1,1,https://github.com/cpsw,Small code style change,1,[],https://github.com/contiki-os/contiki/pull/2408,https://github.com/cpsw,3,https://github.com/contiki-os/contiki/pull/2408#issuecomment-359192167,Making the operator precedence explicit.,"Hi @alexrayne, I have a tool that can capture all occurrences of this pattern as well as other similar ones. Should I do change the other occurrences also?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2408,2017-12-09T15:27:16Z,,2018-01-22T14:29:55Z,OPEN,False,1,1,1,https://github.com/cpsw,Small code style change,1,[],https://github.com/contiki-os/contiki/pull/2408,https://github.com/alexrayne,4,https://github.com/contiki-os/contiki/pull/2408#issuecomment-359439209,Making the operator precedence explicit.,"imho, better to fix other occurencec too.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2418,2017-12-29T15:28:51Z,,2017-12-29T15:28:51Z,OPEN,False,128,1,2,https://github.com/alexrayne,cc26xx SPI - introduce lpm control,2,[],https://github.com/contiki-os/contiki/pull/2418,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2418,"There is itroduced LPM control for srf06-cc26xx platform board_spi module.
SPI should manage it power domain with os sleep polls. that is for LPM module should preserve SERIAL PD, when need.
when BOARD_SPI_LPM declared some style - SSI clock enabled in sleep mode.
BOARD_SPI_LPM_DEEPSLEEP_OFF - provide most effective power mode. it always turn  off/on SPI when go/out deep-sleep. This most purposes - that PR designed for.","There is itroduced LPM control for srf06-cc26xx platform board_spi module.
SPI should manage it power domain with os sleep polls. that is for LPM module should preserve SERIAL PD, when need.
when BOARD_SPI_LPM declared some style - SSI clock enabled in sleep mode.
BOARD_SPI_LPM_DEEPSLEEP_OFF - provide most effective power mode. it always turn  off/on SPI when go/out deep-sleep. This most purposes - that PR designed for.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2421,2018-01-11T12:12:10Z,2018-01-12T10:48:15Z,2018-01-12T10:49:26Z,CLOSED,False,0,0,0,https://github.com/nkigen,Pull updates from contiki,3,[],https://github.com/contiki-os/contiki/pull/2421,https://github.com/nkigen,1,https://github.com/contiki-os/contiki/pull/2421,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2421,2018-01-11T12:12:10Z,2018-01-12T10:48:15Z,2018-01-12T10:49:26Z,CLOSED,False,0,0,0,https://github.com/nkigen,Pull updates from contiki,3,[],https://github.com/contiki-os/contiki/pull/2421,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2421#issuecomment-357165245,,WTF?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2421,2018-01-11T12:12:10Z,2018-01-12T10:48:15Z,2018-01-12T10:49:26Z,CLOSED,False,0,0,0,https://github.com/nkigen,Pull updates from contiki,3,[],https://github.com/contiki-os/contiki/pull/2421,https://github.com/nkigen,3,https://github.com/contiki-os/contiki/pull/2421#issuecomment-357206570,,Please disregard this.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2422,2018-01-12T20:54:03Z,,2018-01-12T20:54:03Z,OPEN,False,10,10,1,https://github.com/Triple-Z,FIX(powertrace.c): decimal point overflow,1,[],https://github.com/contiki-os/contiki/pull/2422,https://github.com/Triple-Z,1,https://github.com/contiki-os/contiki/pull/2422,Use long long instead of long data type to prevent decimal point data overflow to a negative number.,Use long long instead of long data type to prevent decimal point data overflow to a negative number.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2427,2018-01-16T18:05:16Z,,2018-01-19T05:36:27Z,OPEN,False,385,7,6,https://github.com/nicholasinatel,Magnetometer Sensor Added in cc26xx-web-demo ,4,[],https://github.com/contiki-os/contiki/pull/2427,https://github.com/nicholasinatel,1,https://github.com/contiki-os/contiki/pull/2427,"Here provided modifications in the cc26xx-web-demo example,
magnetometer from the MPU_9250 for the sensortag (TI) board in the srf06-cc26xx platform is active.
Observation: Could only compile the example with some of its features deactivated, when fully activated got error of memory SRAM overflow.
at examples/cc26xx/cc26xx-web-demo/project-conf.h
`/* Enable/Disable Components of this Demo */
#define CC26XX_WEB_DEMO_CONF_MQTT_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_6LBR_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_COAP_SERVER      1
#define CC26XX_WEB_DEMO_CONF_NET_UART         0`","Here provided modifications in the cc26xx-web-demo example,
magnetometer from the MPU_9250 for the sensortag (TI) board in the srf06-cc26xx platform is active.
Observation: Could only compile the example with some of its features deactivated, when fully activated got error of memory SRAM overflow.
at examples/cc26xx/cc26xx-web-demo/project-conf.h
`/* Enable/Disable Components of this Demo */
#define CC26XX_WEB_DEMO_CONF_MQTT_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_6LBR_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_COAP_SERVER      1
#define CC26XX_WEB_DEMO_CONF_NET_UART         0`",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2427,2018-01-16T18:05:16Z,,2018-01-19T05:36:27Z,OPEN,False,385,7,6,https://github.com/nicholasinatel,Magnetometer Sensor Added in cc26xx-web-demo ,4,[],https://github.com/contiki-os/contiki/pull/2427,https://github.com/nicholasinatel,2,https://github.com/contiki-os/contiki/pull/2427#issuecomment-358364255,"Here provided modifications in the cc26xx-web-demo example,
magnetometer from the MPU_9250 for the sensortag (TI) board in the srf06-cc26xx platform is active.
Observation: Could only compile the example with some of its features deactivated, when fully activated got error of memory SRAM overflow.
at examples/cc26xx/cc26xx-web-demo/project-conf.h
`/* Enable/Disable Components of this Demo */
#define CC26XX_WEB_DEMO_CONF_MQTT_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_6LBR_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_COAP_SERVER      1
#define CC26XX_WEB_DEMO_CONF_NET_UART         0`","Hi @g-oikonomou, greetings.
Please i would like to understand how does the continuous-integration/travis-ci/pr works and what it is.
Also if possible, could you explain why the commit was not approved?
I checked the Details link in the ( continuous-integration/travis-ci/pr ‚Äî The Travis CI build could not complete due to an error ) and didn't understand what happened.
In my Fedora27, compiling and testing in the Sensortag/CC1350 with an RPL Bourder Router, the CoAP works fine.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2427,2018-01-16T18:05:16Z,,2018-01-19T05:36:27Z,OPEN,False,385,7,6,https://github.com/nicholasinatel,Magnetometer Sensor Added in cc26xx-web-demo ,4,[],https://github.com/contiki-os/contiki/pull/2427,https://github.com/nicholasinatel,3,https://github.com/contiki-os/contiki/pull/2427#issuecomment-358441002,"Here provided modifications in the cc26xx-web-demo example,
magnetometer from the MPU_9250 for the sensortag (TI) board in the srf06-cc26xx platform is active.
Observation: Could only compile the example with some of its features deactivated, when fully activated got error of memory SRAM overflow.
at examples/cc26xx/cc26xx-web-demo/project-conf.h
`/* Enable/Disable Components of this Demo */
#define CC26XX_WEB_DEMO_CONF_MQTT_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_6LBR_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_COAP_SERVER      1
#define CC26XX_WEB_DEMO_CONF_NET_UART         0`","Hi @casaroli, greetings
I ask you please to take a review in my code and why it was refused by continuous-integration/travis-ci/pr when you are able to.
Best Regards",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2427,2018-01-16T18:05:16Z,,2018-01-19T05:36:27Z,OPEN,False,385,7,6,https://github.com/nicholasinatel,Magnetometer Sensor Added in cc26xx-web-demo ,4,[],https://github.com/contiki-os/contiki/pull/2427,https://github.com/ql1179,4,https://github.com/contiki-os/contiki/pull/2427#issuecomment-358869361,"Here provided modifications in the cc26xx-web-demo example,
magnetometer from the MPU_9250 for the sensortag (TI) board in the srf06-cc26xx platform is active.
Observation: Could only compile the example with some of its features deactivated, when fully activated got error of memory SRAM overflow.
at examples/cc26xx/cc26xx-web-demo/project-conf.h
`/* Enable/Disable Components of this Demo */
#define CC26XX_WEB_DEMO_CONF_MQTT_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_6LBR_CLIENT      0
#define CC26XX_WEB_DEMO_CONF_COAP_SERVER      1
#define CC26XX_WEB_DEMO_CONF_NET_UART         0`","Hi,
I am interested in this driver. I just found there is a 10ms delay before access magnetometer. I tried to remove/reduce it, which resulted in failure in data reading. So is this delay necessary? Is it possible to reduce it to around 1ms, which is what I need. Thank you.
Regards",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2435,2018-02-01T09:38:56Z,,2018-02-07T09:03:16Z,OPEN,False,44,4,2,https://github.com/keyfour,Add function to setup UART dynamically on cc13xx/cc26xx devices,2,[],https://github.com/contiki-os/contiki/pull/2435,https://github.com/keyfour,1,https://github.com/contiki-os/contiki/pull/2435,"There is useful to have ability to change UART parameters on working device with running program. I ran into this when connects different devices with serial interfaces on remote working device. I added function
to cc26xx UART driver which re-configure device with custom parameters.","There is useful to have ability to change UART parameters on working device with running program. I ran into this when connects different devices with serial interfaces on remote working device. I added function
to cc26xx UART driver which re-configure device with custom parameters.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2435,2018-02-01T09:38:56Z,,2018-02-07T09:03:16Z,OPEN,False,44,4,2,https://github.com/keyfour,Add function to setup UART dynamically on cc13xx/cc26xx devices,2,[],https://github.com/contiki-os/contiki/pull/2435,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2435#issuecomment-363702083,"There is useful to have ability to change UART parameters on working device with running program. I ran into this when connects different devices with serial interfaces on remote working device. I added function
to cc26xx UART driver which re-configure device with custom parameters.","Hallow Keyfour!
IMHO, this new feature better be optional, since your requrements to change setup is rare. Most projects no need this, therefore your new code useless for them.
You may introduce config definition like UART_SETUP_ENABLE to enable new function. and without that - uses constants only.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2436,2018-02-01T17:12:09Z,2018-02-01T17:57:00Z,2018-02-01T17:57:00Z,CLOSED,False,417,29,6,https://github.com/cquijano,[CPU cc26xx-cc13xx] Select power mode on config,10,[],https://github.com/contiki-os/contiki/pull/2436,https://github.com/cquijano,1,https://github.com/contiki-os/contiki/pull/2436,Set the LPM on cc26xx and cc13xx thought config,Set the LPM on cc26xx and cc13xx thought config,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2437,2018-02-01T18:00:39Z,,2019-12-26T17:07:24Z,OPEN,False,4,0,1,https://github.com/cquijano,Lpm cc26xx cc13xx config,2,[],https://github.com/contiki-os/contiki/pull/2437,https://github.com/cquijano,1,https://github.com/contiki-os/contiki/pull/2437,Add Config for lpm on cc26xx and cc13xx devices,Add Config for lpm on cc26xx and cc13xx devices,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2437,2018-02-01T18:00:39Z,,2019-12-26T17:07:24Z,OPEN,False,4,0,1,https://github.com/cquijano,Lpm cc26xx cc13xx config,2,[],https://github.com/contiki-os/contiki/pull/2437,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2437#issuecomment-568891369,Add Config for lpm on cc26xx and cc13xx devices,why you need it? What pupose of such conf you intends?,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2437,2018-02-01T18:00:39Z,,2019-12-26T17:07:24Z,OPEN,False,4,0,1,https://github.com/cquijano,Lpm cc26xx cc13xx config,2,[],https://github.com/contiki-os/contiki/pull/2437,https://github.com/cquijano,3,https://github.com/contiki-os/contiki/pull/2437#issuecomment-569092907,Add Config for lpm on cc26xx and cc13xx devices,"I do not always want to set the CPU ON LPM_MODE_SHUTDOWN , some times I want set the LPM on the cc26xx  to LPM_MODE_DEEP_SLEEP, for example, When on the application  is no external interrupt to wake up the CPU.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2442,2018-02-13T11:52:52Z,,2018-02-13T11:52:52Z,OPEN,False,1,1,1,https://github.com/ivan-alekhin,Route loopback packets via UIP_FALLBACK_INTERFACE.,1,[],https://github.com/contiki-os/contiki/pull/2442,https://github.com/ivan-alekhin,1,https://github.com/contiki-os/contiki/pull/2442,"tcpip_ipv6_output doesn't check the destination address of the packet when it tries to send the packet to one of the default routes. That could lead to the scenario when the packet with dst_addr == ::1 will
be redirected to the 6lowpan network instead of being routed to the fallback interface.","tcpip_ipv6_output doesn't check the destination address of the packet when it tries to send the packet to one of the default routes. That could lead to the scenario when the packet with dst_addr == ::1 will
be redirected to the 6lowpan network instead of being routed to the fallback interface.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2443,2018-02-15T14:20:51Z,,2018-02-15T14:20:51Z,OPEN,False,42,38,1,https://github.com/alexrayne,TSCH frame802154_has_panid code size and speed optmise,1,[],https://github.com/contiki-os/contiki/pull/2443,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2443,here is rewriten frame802154_has_panid function. on ARM new code have size less for 80bytes,here is rewriten frame802154_has_panid function. on ARM new code have size less for 80bytes,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2444,2018-02-15T14:23:51Z,,2018-02-15T14:23:51Z,OPEN,False,3,1,1,https://github.com/alexrayne,Makefile.include - prevents '.' path reposition ,1,[],https://github.com/contiki-os/contiki/pull/2444,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2444,"When PROJECTDIRS have '.' path, application  suposes that position not changes.  but makefile.include forces it to first.
So, here is patch that prevents '.' path emit, when it alredy provided by app in PROJECTDIRS","When PROJECTDIRS have '.' path, application  suposes that position not changes.  but makefile.include forces it to first.
So, here is patch that prevents '.' path emit, when it alredy provided by app in PROJECTDIRS",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2445,2018-02-15T14:28:22Z,,2019-12-27T12:18:14Z,OPEN,False,112,4,6,https://github.com/alexrayne,cc26xx RF prop-mode GLDO power mode for less rf-noise,5,[],https://github.com/contiki-os/contiki/pull/2445,https://github.com/alexrayne,1,https://github.com/contiki-os/contiki/pull/2445,"Here provide using GLDO onchip power during RF operation. This can give lesser noise on rf-receive.
This PR ralated to PR#2351. But it can be allpyed independently on master.
*Use - need setup radio device parameter RADIO_CC26_POWER_STYLE to RADIO_POWER_STYLE_GLDO
   NETSTACK_RADIO.set_value(RADIO_CC26_POWER_STYLE, RADIO_POWER_STYLE_GLDO);
this switch onchip dc to GLDO when radio on, and switch back to previous mode, when radio off.","Here provide using GLDO onchip power during RF operation. This can give lesser noise on rf-receive.
This PR ralated to PR#2351. But it can be allpyed independently on master.
*Use - need setup radio device parameter RADIO_CC26_POWER_STYLE to RADIO_POWER_STYLE_GLDO
   NETSTACK_RADIO.set_value(RADIO_CC26_POWER_STYLE, RADIO_POWER_STYLE_GLDO);
this switch onchip dc to GLDO when radio on, and switch back to previous mode, when radio off.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2449,2018-03-08T16:24:52Z,2018-03-08T17:43:22Z,2018-03-08T17:43:22Z,MERGED,True,80,80,2,https://github.com/oliverschmidt,Adjusted to cc65 2.17 which generates AppleSingle files.,1,[],https://github.com/contiki-os/contiki/pull/2449,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2449,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2457,2018-03-28T22:21:48Z,2022-03-23T22:40:23Z,2022-03-23T22:40:23Z,CLOSED,False,7,1,1,https://github.com/Vinggui,Provide exclude source list for development flexibility,2,[],https://github.com/contiki-os/contiki/pull/2457,https://github.com/Vinggui,1,https://github.com/contiki-os/contiki/pull/2457,"This new parameter is a list capable of ignoring specific source files during compilation. which will allow more flexibility for developers.
One example is that ""nullradio.c"" and ""nullradio.h"" (inside core/dev) was not wanted, since I'm building a new network architecture.
To ignore this files, I added the following definition into my makefile:
# For the .h
CFLAGS += -DRADIO_H_=1
#for the .c
IGNORE_SOURCE_FILE_LIST += nullradio.c","This new parameter is a list capable of ignoring specific source files during compilation. which will allow more flexibility for developers.
One example is that ""nullradio.c"" and ""nullradio.h"" (inside core/dev) was not wanted, since I'm building a new network architecture.
To ignore this files, I added the following definition into my makefile:
# For the .h
CFLAGS += -DRADIO_H_=1
#for the .c
IGNORE_SOURCE_FILE_LIST += nullradio.c",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2457,2018-03-28T22:21:48Z,2022-03-23T22:40:23Z,2022-03-23T22:40:23Z,CLOSED,False,7,1,1,https://github.com/Vinggui,Provide exclude source list for development flexibility,2,[],https://github.com/contiki-os/contiki/pull/2457,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2457#issuecomment-569258247,"This new parameter is a list capable of ignoring specific source files during compilation. which will allow more flexibility for developers.
One example is that ""nullradio.c"" and ""nullradio.h"" (inside core/dev) was not wanted, since I'm building a new network architecture.
To ignore this files, I added the following definition into my makefile:
# For the .h
CFLAGS += -DRADIO_H_=1
#for the .c
IGNORE_SOURCE_FILE_LIST += nullradio.c","You would rewrite PR name, for better readability? some about  - ""provide exclude source list"" ?",True,{'THUMBS_UP': ['https://github.com/Vinggui']}
contiki-os/contiki,https://github.com/contiki-os/contiki,2458,2018-03-29T12:10:03Z,,2018-04-23T07:43:57Z,OPEN,False,1,1,1,https://github.com/Marc-Aurele,cpu/cc26xx-cc13xx : own linker script can be used,1,[],https://github.com/contiki-os/contiki/pull/2458,https://github.com/Marc-Aurele,1,https://github.com/contiki-os/contiki/pull/2458,"It is possible to use your own linker script in your project
directory.
Signed-off-by: Aurelien Fillau aurelien.fillau@gmail.com","It is possible to use your own linker script in your project
directory.
Signed-off-by: Aurelien Fillau aurelien.fillau@gmail.com",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2463,2018-04-07T12:59:10Z,,2019-06-28T20:19:02Z,OPEN,False,1123,273,16,https://github.com/AmnahAlabdi,"Multi-instance support, DIO DAG metric container enhancement, .. (see‚Ä¶",1,[],https://github.com/contiki-os/contiki/pull/2463,https://github.com/AmnahAlabdi,1,https://github.com/contiki-os/contiki/pull/2463,‚Ä¶ Jeremy Dubrulle master thesis for full list),‚Ä¶ Jeremy Dubrulle master thesis for full list),True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2475,2018-05-15T00:52:22Z,,2018-05-15T05:44:12Z,OPEN,False,48,25,1,https://github.com/mofosyne,Update coap_content_type_t to iana registered ids,3,[],https://github.com/contiki-os/contiki/pull/2475,https://github.com/mofosyne,1,https://github.com/contiki-os/contiki/pull/2475,#2474,#2474,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2494,2018-07-11T14:03:39Z,,2018-07-11T14:03:39Z,OPEN,False,109,1,2,https://github.com/soburi,Implements multithreading API for JN516x platform,1,[],https://github.com/contiki-os/contiki/pull/2494,https://github.com/soburi,1,https://github.com/contiki-os/contiki/pull/2494,"This pull request is multithreading implementation for JN516x.
I was verify it with 'examples/multi-threading' is work fine. (with JN5164, JN5169)
At boot up, enabling Stack overflow detection (contiki/platform/jn516x/contiki-jn516x-main.c, main), but it can't work same time with multithreading.
So, disable Stack overflow detection at starting multithread.
(this patch is no affect if not using multithreading)","This pull request is multithreading implementation for JN516x.
I was verify it with 'examples/multi-threading' is work fine. (with JN5164, JN5169)
At boot up, enabling Stack overflow detection (contiki/platform/jn516x/contiki-jn516x-main.c, main), but it can't work same time with multithreading.
So, disable Stack overflow detection at starting multithread.
(this patch is no affect if not using multithreading)",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/danielinux,1,https://github.com/contiki-os/contiki/pull/2500,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/akmcomau,2,https://github.com/contiki-os/contiki/pull/2500#issuecomment-435812730,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","Thanks for the great work!
I managed to get this working on an AVR xmega with the PSK-NULL-SHA256 cipher.  This patch has saved me a lot of time, although without native sockets I did need to add a few more process yields and checks for the SSL_ERROR_WANT_READ error and retry calling functions.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/danielinux,3,https://github.com/contiki-os/contiki/pull/2500#issuecomment-436134987,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","@akmcomau thank you for using this patch. Could you share the code modifications you made for your non-native-socket app? It might be really useful to improve this PR. Thanks in advance,
-- @danielinux / @wolfSSL",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/akmcomau,4,https://github.com/contiki-os/contiki/pull/2500#issuecomment-436160701,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","@danielinux I didn't really have to change that much, I don't think you want my whole contiki branch, as it has a large number of changes.  I don't have it as a simple commit that I can push to github, but I can make if you like. Here is a summary of what I changed:
In apps/wolfssl/wolfssl.c I removed the calls to wolfSSL_set_using_nonblock() as this didn't seem to be defined in my wolfssl configuration.
Here would be an example of an example server.  But there may be more modifications required to also support the SSL_ERROR_WANT_WRITE error code.
`PROCESS_THREAD(server_process, ev, data)
{
PROCESS_BEGIN();
/* make new ssl context */
if ( !(sk = tls_socket_register(wolfTLSv1_2_server_method())) ) {
PRINTF(""wolfSSL_CTX_new error\n"");
}
/* use psk suite for security */
wolfSSL_CTX_set_psk_server_callback(sk->ctx, my_psk_server_cb);
wolfSSL_CTX_use_psk_identity_hint(sk->ctx, ""Identity"");
if (wolfSSL_CTX_set_cipher_list(sk->ctx, ""PSK-NULL-SHA256"") != SSL_SUCCESS) {
printf(""Server can't set cipher list\n"");
}
tcp_socket_listen(&sk->conn.tcp, SERVER_PORT);
printf(""Listening on %d\n"", SERVER_PORT);
while(1) {
int len;
int ret;
do {
  PROCESS_WAIT_EVENT();
  printf(""Connection Request or Accept Continuation\n"");
  ret = tls_socket_accept(sk);
} while (wolfSSL_get_error(sk->ssl, ret) == SSL_ERROR_WANT_READ);
if (ret < 0) {
  printf(""Accept returned %d\r\n"", ret);
  continue;
}

printf(""Connection accepted\r\n"");
do {
  memset(http_request, 0, sizeof(http_request));
  do {
    PROCESS_WAIT_EVENT();
    len = wolfSSL_read(sk->ssl, http_request, sizeof(http_request));
  } while (wolfSSL_get_error(sk->ssl, len) == SSL_ERROR_WANT_READ);
  printf(""Recv request (%d bytes)\r\n"", len);
} while (len < 4 && len != -1);

if (len != -1) {
  printf(""Sending response...\r\n"");
  wolfSSL_write(sk->ssl, Contiki_http_string, sizeof(Contiki_http_string));
  PROCESS_WAIT_EVENT();
}

printf(""Closing connection.\r\n"");
tls_socket_close(sk);
sk->ssl = NULL;
printf(""Waiting for another connection on %d\n"", SERVER_PORT);

}
PROCESS_END();
}`",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/danielinux,5,https://github.com/contiki-os/contiki/pull/2500#issuecomment-436166435,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","@akmcomau this is very helpful, thank you. Indeed I do not need a commit, just curious of what you had to change to make it work in your case. Your description is sufficient for me to adjust my PR.
Once again, thank you for the feedback!
--
@danielinux / @wolfSSL",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/hcnhcn012,6,https://github.com/contiki-os/contiki/pull/2500#issuecomment-493732083,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","Hello, @danielinux, Thanks for porting wolfSSL to contiki. But I have problems in building this, when I copy wolfSSL source dir to /apps/wolfssl then autogen+configure+make  at the same time. Then I just tried to build ssl_server in examples, then throws error: dereferencing pointer to incomplete type. It seems that the library is not been linked correctly.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/danielinux,7,https://github.com/contiki-os/contiki/pull/2500#issuecomment-493735529,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL","Hello, @danielinux, Thanks for porting wolfSSL to contiki. But I have problems in building this, when I copy wolfSSL source dir to /apps/wolfssl then autogen+configure+make at the same time. Then I just tried to build ssl_server in examples, then throws error: dereferencing pointer to incomplete type. It seems that the library is not been linked correctly.

Hi @hcnhcn012.
You don't have to copy and compile the library yourself, git can retrieve it as submodule, and contiki integrates it in your application automatically.
Please clone with
git clone --recurse-submodules https://github.com/danielinux/contiki.git

or use
git submodule update --init
after a fresh clone, so that the directory apps/wolfssl is populated.
ssl_server in examples already has APPS=wolfssl in the makefile, so it will build the library as dependency. All you need to do is invoking make with the selected target.
The examples have been successfully tested with make TARGET=minimal-net over a tap device.
For a real-hardware example based on this port, see also our contiki-nRF52 secure boot/secure firmware update demo",True,"{'THUMBS_UP': ['https://github.com/hcnhcn012', 'https://github.com/rfuentess']}"
contiki-os/contiki,https://github.com/contiki-os/contiki,2500,2018-07-27T09:53:22Z,,2019-05-25T07:14:26Z,OPEN,False,1330,0,23,https://github.com/danielinux,WolfSSL port to provide TLS/DLTS sockets,8,[],https://github.com/contiki-os/contiki/pull/2500,https://github.com/hcnhcn012,8,https://github.com/contiki-os/contiki/pull/2500#issuecomment-493741760,"This PR is a proposal to integrate basic TLS/DTLS support, wrapping the existing uIP sockets.
The TLS/DTLS support is provided via wolfSSL. A module in apps/wolfssl can be linked with an application to access TLS/DTLS capabilities.
A few extra examples, integrating the wolfSSL module are provided:

ssl-server
ssl-client
dtls (server/client)

Examples have been successfully tested on the minimal-net target, using both IPv4 and IPv6, and on the nRF52x development board, using IPv6 over 6LoWPAN.
On the nRF52, the watchdog is disabled when wolfSSL is in use. This prevents the system to be rebooted if the TLS/DTLS handshake is taking longer than the watchdog interval.
The wolfssl submodule temporarily points to a wolfSSL fork which adds support in the library for uIP and contiki, that's being validated and considered for inclusion. Later versions of this PR will point to the official wolfSSL repository.
Please provide feedback and comments about the approach.
Looking forward to hearing from the contiki community.
--
@danielinux / @wolfSSL",@danielinux Great! Don't know why but tested successfully on my contiki too :). Really appreciate that!,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2501,2018-08-02T11:04:12Z,2018-08-02T11:04:36Z,2018-08-02T11:04:36Z,CLOSED,False,137695,138,271,https://github.com/kacoster,Iot workshop,52,[],https://github.com/contiki-os/contiki/pull/2501,https://github.com/kacoster,1,https://github.com/contiki-os/contiki/pull/2501,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2538,2018-11-03T15:18:30Z,2018-11-03T15:18:38Z,2018-11-03T15:18:38Z,MERGED,True,0,1,1,https://github.com/oliverschmidt,Removed Apple][ mouse driver file.,1,[],https://github.com/contiki-os/contiki/pull/2538,https://github.com/oliverschmidt,1,https://github.com/contiki-os/contiki/pull/2538,The Apple][ mouse driver file became obsolete with https://github.com/oliverschmidt/contiki/commit/91beb8670f9c8000330c11e54ed46c8e5ac4049f.,The Apple][ mouse driver file became obsolete with https://github.com/oliverschmidt/contiki/commit/91beb8670f9c8000330c11e54ed46c8e5ac4049f.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2542,2018-11-29T13:44:18Z,,2018-11-29T13:44:18Z,OPEN,False,0,6105,44,https://github.com/wbober,nrf52dk: remove support for nrf52dk platform and nrf52832 cpu,1,[],https://github.com/contiki-os/contiki/pull/2542,https://github.com/wbober,1,https://github.com/contiki-os/contiki/pull/2542,"This PR removes support for nRF52 platform and cpu from the project. The platform support is long broken and is causing confusion for our customers. We do not intend to maintain it any longer hence the PR.
Signed-off-by: Wojciech Bober wojciech.bober@nordicsemi.no","This PR removes support for nRF52 platform and cpu from the project. The platform support is long broken and is causing confusion for our customers. We do not intend to maintain it any longer hence the PR.
Signed-off-by: Wojciech Bober wojciech.bober@nordicsemi.no",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2544,2018-12-05T08:21:06Z,,2018-12-05T17:47:44Z,OPEN,False,36,10,1,https://github.com/audeoudh,Add a handler for ICMP Destination Unreachable,2,[],https://github.com/contiki-os/contiki/pull/2544,https://github.com/audeoudh,1,https://github.com/contiki-os/contiki/pull/2544,"Previously, they were silently ignored, because of no handler.  Now, some debug information message is written on serial, that's all.","Previously, they were silently ignored, because of no handler.  Now, some debug information message is written on serial, that's all.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2544,2018-12-05T08:21:06Z,,2018-12-05T17:47:44Z,OPEN,False,36,10,1,https://github.com/audeoudh,Add a handler for ICMP Destination Unreachable,2,[],https://github.com/contiki-os/contiki/pull/2544,https://github.com/g-oikonomou,2,https://github.com/contiki-os/contiki/pull/2544#issuecomment-444416621,"Previously, they were silently ignored, because of no handler.  Now, some debug information message is written on serial, that's all.","In principle that's fine, but... perhaps we should wrap everything inside DEBUG to make sure we can actually disable it in its entirety? I mean including the handler definition and registration",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2544,2018-12-05T08:21:06Z,,2018-12-05T17:47:44Z,OPEN,False,36,10,1,https://github.com/audeoudh,Add a handler for ICMP Destination Unreachable,2,[],https://github.com/contiki-os/contiki/pull/2544,https://github.com/audeoudh,3,https://github.com/contiki-os/contiki/pull/2544#issuecomment-444427130,"Previously, they were silently ignored, because of no handler.  Now, some debug information message is written on serial, that's all.","I'm OK for a ICMP_DESTINATION_UNREACHABLE_SUPPORT macro, that deactivates these code ‚Äî even though one more new macro is debatable ‚Äî but I don't see why we should process this type of message only in debug mode.  We can expect the system reacts to a Destination Unreachable error (error pushed to the TCP stack, or even in the UDP one, not implemented now), so having no handler at all for this type of message is surprising.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2544,2018-12-05T08:21:06Z,,2018-12-05T17:47:44Z,OPEN,False,36,10,1,https://github.com/audeoudh,Add a handler for ICMP Destination Unreachable,2,[],https://github.com/contiki-os/contiki/pull/2544,https://github.com/g-oikonomou,4,https://github.com/contiki-os/contiki/pull/2544#issuecomment-444463107,"Previously, they were silently ignored, because of no handler.  Now, some debug information message is written on serial, that's all.","I was thinking more along the lines of wrapping things inside #if DEBUG blocks, not of establishing a new macro. As you say, it makes sense to actually process this message and do something useful when we receive it. But this pull does not add any functionality other than debugging and I am disinclined to increase code/RAM footprint (even if minimal) because of code that does exactly nothing if DEBUG is 0.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2544,2018-12-05T08:21:06Z,,2018-12-05T17:47:44Z,OPEN,False,36,10,1,https://github.com/audeoudh,Add a handler for ICMP Destination Unreachable,2,[],https://github.com/contiki-os/contiki/pull/2544,https://github.com/audeoudh,5,https://github.com/contiki-os/contiki/pull/2544#issuecomment-444577832,"Previously, they were silently ignored, because of no handler.  Now, some debug information message is written on serial, that's all.","I understand your point.  I did not think at the memory footprint.  However, I do not share the conclusion.  Not really about the memory footprint itself, but because of the code clarity.  I feel unclear to find a debug-independant code in a #if DEBUG block, because the rationale of these blocks is obscure when one hasn't read this debate.
Feel free to cherry-pick the commit I did for my tests if you stick to your opinion : drakkar-lig/contiki@6708fae
For information (not for the debate : I  understand this is not a question of quantity, but a question of principle), I tested it: the handler & registration code is 64B more in .txt, 12B in .data, and 8B in .bss.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2579,2019-04-16T01:49:08Z,,2019-12-25T12:01:18Z,OPEN,False,1,1,1,https://github.com/LittleFatHero,fix a bug in the file contiki/core/sys/lc-switch.h,1,[],https://github.com/contiki-os/contiki/pull/2579,https://github.com/LittleFatHero,1,https://github.com/contiki-os/contiki/pull/2579,"the bug is in the line 65. the ';' should be removed, it is redundant and may cause problem.
for example:
#define LC_INIT(s)   s = 0;
#define PT_INIT(pt)   LC_INIT((pt)->lc)
if we use PT_INIT just like it is use in the dhcpc.c fileÔºö
PT_INIT(&s.pt);
it is equal to :
s.pt->lc = 0**;;**
there will be two ';' in the codeÔºåso may be a problem sometimes in some conditions.
by the way , every version of contiki has this problem","the bug is in the line 65. the ';' should be removed, it is redundant and may cause problem.
for example:
#define LC_INIT(s)   s = 0;
#define PT_INIT(pt)   LC_INIT((pt)->lc)
if we use PT_INIT just like it is use in the dhcpc.c fileÔºö
PT_INIT(&s.pt);
it is equal to :
s.pt->lc = 0**;;**
there will be two ';' in the codeÔºåso may be a problem sometimes in some conditions.
by the way , every version of contiki has this problem",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2579,2019-04-16T01:49:08Z,,2019-12-25T12:01:18Z,OPEN,False,1,1,1,https://github.com/LittleFatHero,fix a bug in the file contiki/core/sys/lc-switch.h,1,[],https://github.com/contiki-os/contiki/pull/2579,https://github.com/alexrayne,2,https://github.com/contiki-os/contiki/pull/2579#issuecomment-568891629,"the bug is in the line 65. the ';' should be removed, it is redundant and may cause problem.
for example:
#define LC_INIT(s)   s = 0;
#define PT_INIT(pt)   LC_INIT((pt)->lc)
if we use PT_INIT just like it is use in the dhcpc.c fileÔºö
PT_INIT(&s.pt);
it is equal to :
s.pt->lc = 0**;;**
there will be two ';' in the codeÔºåso may be a problem sometimes in some conditions.
by the way , every version of contiki has this problem","what a problem you realy got? can you describe your situation?
s.pt->lc = 0**;;**
here is no problem for compiler, just skip it",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2587,2019-05-02T18:16:12Z,2022-03-28T16:46:33Z,2022-03-28T16:46:33Z,CLOSED,False,48,48,28,https://github.com/taigrr,Spellchecked root level files and apps,1,[],https://github.com/contiki-os/contiki/pull/2587,https://github.com/taigrr,1,https://github.com/contiki-os/contiki/pull/2587,Manually ran spellcheck across root level text files and all files in the /apps folder.,Manually ran spellcheck across root level text files and all files in the /apps folder.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2587,2019-05-02T18:16:12Z,2022-03-28T16:46:33Z,2022-03-28T16:46:33Z,CLOSED,False,48,48,28,https://github.com/taigrr,Spellchecked root level files and apps,1,[],https://github.com/contiki-os/contiki/pull/2587,https://github.com/taigrr,2,https://github.com/contiki-os/contiki/pull/2587#issuecomment-488852689,Manually ran spellcheck across root level text files and all files in the /apps folder.,"Almost completely comments/docstring updates. Only changed one misspelled variable name and one debug print line, in case that info makes accepting the PR faster.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2587,2019-05-02T18:16:12Z,2022-03-28T16:46:33Z,2022-03-28T16:46:33Z,CLOSED,False,48,48,28,https://github.com/taigrr,Spellchecked root level files and apps,1,[],https://github.com/contiki-os/contiki/pull/2587,https://github.com/taotailiang,3,https://github.com/contiki-os/contiki/pull/2587#issuecomment-525582431,Manually ran spellcheck across root level text files and all files in the /apps folder.,‰Ω†Â•Ω,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2599,2019-06-19T23:39:29Z,,2019-12-22T17:28:55Z,OPEN,False,457,1,4,https://github.com/Lavr18,Add board-i2c library for the launchpad,6,[],https://github.com/contiki-os/contiki/pull/2599,https://github.com/Lavr18,1,https://github.com/contiki-os/contiki/pull/2599,"I and other people (e.g here here here) didn't find any i2c driver for the launchpad. Thus, I adopted the sensortag board-i2c library to the launchpad.
What I have done is:

Copied the board-i2c.c/h files from the sensortag to the launchpad directory.
Removed the interface parameter from board_i2c_select() function and removed several lines regarding the pins setup, which are not relevant to the launchpad, because the launchpad only has a single i2c interface.
Registered the board-i2c.c file in the Makefile.launchpad
Modified the board.c:
a) Included board-i2c.h
b) Added a call to board_i2c_wakeup() in board_init()
c) Added a shutdown handler (just as board.c in srf06-cc26x/sensortag) which calls
board_i2c_shutdown()

The driver was tested on the CC1310.
I was inspired by this thread, where most of the steps I've described are provided.
The last commit about the small syntax fix was to correct my own mistake, so don't pay too much attention to it.","I and other people (e.g here here here) didn't find any i2c driver for the launchpad. Thus, I adopted the sensortag board-i2c library to the launchpad.
What I have done is:

Copied the board-i2c.c/h files from the sensortag to the launchpad directory.
Removed the interface parameter from board_i2c_select() function and removed several lines regarding the pins setup, which are not relevant to the launchpad, because the launchpad only has a single i2c interface.
Registered the board-i2c.c file in the Makefile.launchpad
Modified the board.c:
a) Included board-i2c.h
b) Added a call to board_i2c_wakeup() in board_init()
c) Added a shutdown handler (just as board.c in srf06-cc26x/sensortag) which calls
board_i2c_shutdown()

The driver was tested on the CC1310.
I was inspired by this thread, where most of the steps I've described are provided.
The last commit about the small syntax fix was to correct my own mistake, so don't pay too much attention to it.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2599,2019-06-19T23:39:29Z,,2019-12-22T17:28:55Z,OPEN,False,457,1,4,https://github.com/Lavr18,Add board-i2c library for the launchpad,6,[],https://github.com/contiki-os/contiki/pull/2599,https://github.com/Lavr18,2,https://github.com/contiki-os/contiki/pull/2599#issuecomment-503943250,"I and other people (e.g here here here) didn't find any i2c driver for the launchpad. Thus, I adopted the sensortag board-i2c library to the launchpad.
What I have done is:

Copied the board-i2c.c/h files from the sensortag to the launchpad directory.
Removed the interface parameter from board_i2c_select() function and removed several lines regarding the pins setup, which are not relevant to the launchpad, because the launchpad only has a single i2c interface.
Registered the board-i2c.c file in the Makefile.launchpad
Modified the board.c:
a) Included board-i2c.h
b) Added a call to board_i2c_wakeup() in board_init()
c) Added a shutdown handler (just as board.c in srf06-cc26x/sensortag) which calls
board_i2c_shutdown()

The driver was tested on the CC1310.
I was inspired by this thread, where most of the steps I've described are provided.
The last commit about the small syntax fix was to correct my own mistake, so don't pay too much attention to it.",This is weird that the PR did not pass a Travis check. I was able to build the code on my machine without errors and warnings.,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2599,2019-06-19T23:39:29Z,,2019-12-22T17:28:55Z,OPEN,False,457,1,4,https://github.com/Lavr18,Add board-i2c library for the launchpad,6,[],https://github.com/contiki-os/contiki/pull/2599,https://github.com/alexrayne,3,https://github.com/contiki-os/contiki/pull/2599#issuecomment-568284861,"I and other people (e.g here here here) didn't find any i2c driver for the launchpad. Thus, I adopted the sensortag board-i2c library to the launchpad.
What I have done is:

Copied the board-i2c.c/h files from the sensortag to the launchpad directory.
Removed the interface parameter from board_i2c_select() function and removed several lines regarding the pins setup, which are not relevant to the launchpad, because the launchpad only has a single i2c interface.
Registered the board-i2c.c file in the Makefile.launchpad
Modified the board.c:
a) Included board-i2c.h
b) Added a call to board_i2c_wakeup() in board_init()
c) Added a shutdown handler (just as board.c in srf06-cc26x/sensortag) which calls
board_i2c_shutdown()

The driver was tested on the CC1310.
I was inspired by this thread, where most of the steps I've described are provided.
The last commit about the small syntax fix was to correct my own mistake, so don't pay too much attention to it.",there is nothig pass travis since looooong time ago...,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2611,2019-08-27T03:15:35Z,,2019-08-27T03:15:35Z,OPEN,False,888,0,7,https://github.com/bernardoyla,upload the mlbot files,1,[],https://github.com/contiki-os/contiki/pull/2611,https://github.com/bernardoyla,1,https://github.com/contiki-os/contiki/pull/2611,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/nehalrohit,1,https://github.com/contiki-os/contiki/pull/2616,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/KavinduS,2,https://github.com/contiki-os/contiki/pull/2616#issuecomment-557858233,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done cd /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?

Hi rohith,
I am using cc2650. I am facing a simillar issue. How did you resolve it?
kavindu",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/nehalrohit,3,https://github.com/contiki-os/contiki/pull/2616#issuecomment-558600991,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","Hello kavindu,
For this issue you need one boarder router hardware. Build and run rpl-border-router code on your boarder router let say cc1310.
Build using make TAREGT=srf06-cc26xx BOARD=launchpad/cc1310 command and upload it.
Run it using  sudo ./../../../tools/tunslip6 -s /dev/ttyACM0 bbbb::1/64
wait for connection of ota-bootloader to border router than it start accepting Co-AP requests.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/KavinduS,4,https://github.com/contiki-os/contiki/pull/2616#issuecomment-561514741,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","HI ,
Thank you I resolved the issue, But after the download of the new firmware the lauchpad resets. After the reboot the new firmware does not work,",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/nehalrohit,5,https://github.com/contiki-os/contiki/pull/2616#issuecomment-561570692,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","Hello,
have you changed firmware version number? because downgrade version will not work.",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/KavinduS,6,https://github.com/contiki-os/contiki/pull/2616#issuecomment-561571500,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","Yes I changed it. Apparently I can‚Äôt access the external flash. Do you know
how to delete the content of the external flash?
‚Ä¶
On Wed, Dec 4, 2019 at 15:43, Nehal_Rohit ***@***.***> wrote:
 Hello,
 have you changed firmware version number? because downgrade version will
 not work.

 ‚Äî
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub
 <#2616?email_source=notifications&email_token=AMPN7K3NZG5BOJX2HTLBOXLQW57ETA5CNFSM4IXBMOW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEF4OHBA#issuecomment-561570692>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AMPN7K7IBVXJEUDPQW6G5ILQW57ETANCNFSM4IXBMOWQ>
 .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/nehalrohit,7,https://github.com/contiki-os/contiki/pull/2616#issuecomment-561573011,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","**CLEAR_OTA_SLOTS=1 | Use this flag if you want the bootloader to erase all OTA slots in external flash before running any other code**.
try to this  make Bootloader.hex CLEAR_OTA_SLOTS=1",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2616,2019-09-16T12:12:02Z,2019-09-17T04:28:56Z,2019-12-04T10:24:17Z,CLOSED,False,3475,76,45,https://github.com/nehalrohit, contiki-OTA with LAUNCHXL-CC1310,311,[],https://github.com/contiki-os/contiki/pull/2616,https://github.com/KavinduS,8,https://github.com/contiki-os/contiki/pull/2616#issuecomment-561575166,"Hello,
I follow this link
https://marksolters.com/programming/2016/06/07/contiki-ota.html
here I m done  cd  /contiki/examples/cc26xx-cc13xx-ota-bootloader
change board (launchpad/cc1310) in Makefile .and  build with "" make master hex"" using uni-flash firmware.hex file download in cc1310. it run succesfully.
and  other terminal run OTA server as given below.

But I have some problem.

is it possible to OTA with LAUNCHXL-CC1310 ?","Hi Rohith,
I tried doing this, Did not work.
‚Ä¶
On Wed, Dec 4, 2019 at 3:49 PM Nehal_Rohit ***@***.***> wrote:
 **CLEAR_OTA_SLOTS=1 | Use this flag if you want the bootloader to erase
 all OTA slots in external flash before running any other code**.
 try to this make Bootloader.hex CLEAR_OTA_SLOTS=1

 ‚Äî
 You are receiving this because you commented.
 Reply to this email directly, view it on GitHub
 <#2616?email_source=notifications&email_token=AMPN7K3B32363B272VBJGWLQW574FA5CNFSM4IXBMOW2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEF4OZEY#issuecomment-561573011>,
 or unsubscribe
 <https://github.com/notifications/unsubscribe-auth/AMPN7K3EVQZEKRZ42KKQ4ULQW574FANCNFSM4IXBMOWQ>
 .",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2619,2019-10-03T00:10:51Z,2019-10-03T00:11:52Z,2019-10-03T00:12:26Z,CLOSED,False,1,1,5,https://github.com/MarlonWSantos,Cooja,3,[],https://github.com/contiki-os/contiki/pull/2619,https://github.com/MarlonWSantos,1,https://github.com/contiki-os/contiki/pull/2619,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2623,2019-10-29T10:59:22Z,2019-10-29T11:00:45Z,2019-10-29T11:03:39Z,CLOSED,False,424094,85,334,https://github.com/Rjlmota,Aggregation,10000,[],https://github.com/contiki-os/contiki/pull/2623,https://github.com/Rjlmota,1,https://github.com/contiki-os/contiki/pull/2623,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2639,2020-02-12T16:52:35Z,,2020-02-12T16:52:35Z,OPEN,False,69,69,1,https://github.com/gefa,"fix indentation, use python2 - not compatible with python3",1,[],https://github.com/contiki-os/contiki/pull/2639,https://github.com/gefa,1,https://github.com/contiki-os/contiki/pull/2639,"This solves the error(s) when uploading code to sky (telos b) device:
msp430-objcopy throughput-test.sky -O ihex throughput-test.ihex
make IHEXFILE=throughput-test.ihex sky-reset sky-upload
make[1]: Entering directory '/home/gefa/workspace/contiki-forked/examples/sky'
make -k -j 20 sky-reset-sequence
make[2]: Entering directory '/home/gefa/workspace/contiki-forked/examples/sky'
../../tools/sky/msp430-bsl-linux --telosb -c /dev/ttyUSB1 -r
 File ""../../tools/sky/msp430-bsl-linux"", line 272
   self.swapRSTTEST = 0
                      ^
TabError: inconsistent use of tabs and spaces in indentation
make[2]: *** [../../platform/sky/Makefile.common:155: sky-r._dev_ttyUSB1] Error 1
make[2]: Target 'sky-reset-sequence' not remade because of errors.
make[2]: Leaving directory '/home/gefa/workspace/contiki-forked/examples/sky'
make[1]: *** [../../platform/sky/Makefile.common:141: sky-reset] Error 2
make[1]: Leaving directory '/home/gefa/workspace/contiki-forked/examples/sky'
make: *** [../../platform/sky/Makefile.common:119: throughput-test.upload] Error 2
rm throughput-test.ihex","This solves the error(s) when uploading code to sky (telos b) device:
msp430-objcopy throughput-test.sky -O ihex throughput-test.ihex
make IHEXFILE=throughput-test.ihex sky-reset sky-upload
make[1]: Entering directory '/home/gefa/workspace/contiki-forked/examples/sky'
make -k -j 20 sky-reset-sequence
make[2]: Entering directory '/home/gefa/workspace/contiki-forked/examples/sky'
../../tools/sky/msp430-bsl-linux --telosb -c /dev/ttyUSB1 -r
 File ""../../tools/sky/msp430-bsl-linux"", line 272
   self.swapRSTTEST = 0
                      ^
TabError: inconsistent use of tabs and spaces in indentation
make[2]: *** [../../platform/sky/Makefile.common:155: sky-r._dev_ttyUSB1] Error 1
make[2]: Target 'sky-reset-sequence' not remade because of errors.
make[2]: Leaving directory '/home/gefa/workspace/contiki-forked/examples/sky'
make[1]: *** [../../platform/sky/Makefile.common:141: sky-reset] Error 2
make[1]: Leaving directory '/home/gefa/workspace/contiki-forked/examples/sky'
make: *** [../../platform/sky/Makefile.common:119: throughput-test.upload] Error 2
rm throughput-test.ihex",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2647,2020-05-02T14:10:38Z,2020-05-02T14:14:20Z,2020-05-10T23:23:10Z,CLOSED,False,750,7,24,https://github.com/xanderhendriks-uts,Feature/add level sensor,9,[],https://github.com/contiki-os/contiki/pull/2647,https://github.com/xanderhendriks-uts,1,https://github.com/contiki-os/contiki/pull/2647,Added the discrete level sensor,Added the discrete level sensor,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2658,2020-08-10T16:32:04Z,2020-08-10T16:32:47Z,2020-08-10T16:32:47Z,CLOSED,False,441,14,6,https://github.com/yurimses,Powertrace Prof Andr√©,1,[],https://github.com/contiki-os/contiki/pull/2658,https://github.com/yurimses,1,https://github.com/contiki-os/contiki/pull/2658,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2660,2020-09-25T19:53:38Z,,2020-09-25T19:54:56Z,OPEN,False,209,0,1,https://github.com/rana509, openmote-websense.c,1,[],https://github.com/contiki-os/contiki/pull/2660,https://github.com/rana509,1,https://github.com/contiki-os/contiki/pull/2660,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2661,2020-09-25T20:05:46Z,,2020-09-25T20:05:46Z,OPEN,False,23,0,1,https://github.com/rana509, Makefile,1,[],https://github.com/contiki-os/contiki/pull/2661,https://github.com/rana509,1,https://github.com/contiki-os/contiki/pull/2661,this make file is proposed to run openmote-websense.c,this make file is proposed to run openmote-websense.c,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2665,2020-11-02T21:46:36Z,,2020-11-02T21:47:38Z,OPEN,False,3,0,1,https://github.com/gptshubham595,Cooja windows,2,[],https://github.com/contiki-os/contiki/pull/2665,https://github.com/gptshubham595,1,https://github.com/contiki-os/contiki/pull/2665,"I tried and was able to run cooja on windows directly but after wasting much time
So I wanted to share this so I added their a link to my GitHub //ALL CREDITS TO YOU üôè
For those who want cooja in windows they run it following steps there with a video link also","I tried and was able to run cooja on windows directly but after wasting much time
So I wanted to share this so I added their a link to my GitHub //ALL CREDITS TO YOU üôè
For those who want cooja in windows they run it following steps there with a video link also",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2671,2020-12-08T07:32:55Z,2020-12-08T07:54:00Z,2020-12-08T07:54:00Z,CLOSED,False,1,1,1,https://github.com/DimitriPapadopoulos,Fix link to Contiki web site,1,[],https://github.com/contiki-os/contiki/pull/2671,https://github.com/DimitriPapadopoulos,1,https://github.com/contiki-os/contiki/pull/2671,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2684,2021-07-12T15:10:53Z,2021-07-12T15:12:24Z,2021-07-12T15:12:24Z,CLOSED,False,474,18,9,https://github.com/coolhalfing79,RPL with fuzzy metrics,1,[],https://github.com/contiki-os/contiki/pull/2684,https://github.com/coolhalfing79,1,https://github.com/contiki-os/contiki/pull/2684,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2690,2021-08-25T14:50:36Z,,2021-08-27T09:48:43Z,OPEN,False,319,13,7,https://github.com/Nirhar,Cooja with dynamically moving motes,2,[],https://github.com/contiki-os/contiki/pull/2690,https://github.com/Nirhar,1,https://github.com/contiki-os/contiki/pull/2690,"I have added a new facility to cooja, where the motes can change their position on the run, by dynamically taking decisions. This feature will help the community to advance in Research related to MANETS, VANETS etc, where the interaction between communication and mobility-concerned decision making of the motes will be tightly linked.
I have also given an option in the Cooja GUI so that only those who need this facility will be able to track the motes in the GUI, where as the rest can use Cooja just as before.
For more details about this feature kindly have a look at ""tools/cooja/Readme_mobility.md"" in the contiki folder.
closes #2689","I have added a new facility to cooja, where the motes can change their position on the run, by dynamically taking decisions. This feature will help the community to advance in Research related to MANETS, VANETS etc, where the interaction between communication and mobility-concerned decision making of the motes will be tightly linked.
I have also given an option in the Cooja GUI so that only those who need this facility will be able to track the motes in the GUI, where as the rest can use Cooja just as before.
For more details about this feature kindly have a look at ""tools/cooja/Readme_mobility.md"" in the contiki folder.
closes #2689",True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2691,2021-09-03T23:41:00Z,,2021-09-03T23:41:00Z,OPEN,False,3,3,1,https://github.com/ngammarano,Correct Markdown headings syntaxis in Erbium Readme,1,[],https://github.com/contiki-os/contiki/pull/2691,https://github.com/ngammarano,1,https://github.com/contiki-os/contiki/pull/2691,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2692,2021-09-03T23:52:22Z,,2021-09-03T23:52:22Z,OPEN,False,24,19,1,https://github.com/ngammarano,Correct code syntax in Erbium (Er) Readme,1,[],https://github.com/contiki-os/contiki/pull/2692,https://github.com/ngammarano,1,https://github.com/contiki-os/contiki/pull/2692,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2693,2021-09-04T03:36:59Z,,2021-09-04T03:36:59Z,OPEN,False,3,3,3,https://github.com/ngammarano,Correct some typos in error messages,3,[],https://github.com/contiki-os/contiki/pull/2693,https://github.com/ngammarano,1,https://github.com/contiki-os/contiki/pull/2693,,,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2694,2021-09-11T11:26:18Z,,2021-09-11T13:07:50Z,OPEN,False,1,1,1,https://github.com/ngammarano,Correct broken link in TSCH README,1,[],https://github.com/contiki-os/contiki/pull/2694,https://github.com/ngammarano,1,https://github.com/contiki-os/contiki/pull/2694,Correct broken link to standard IEEE 802.15.4e-2021 amendment,Correct broken link to standard IEEE 802.15.4e-2021 amendment,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2694,2021-09-11T11:26:18Z,,2021-09-11T13:07:50Z,OPEN,False,1,1,1,https://github.com/ngammarano,Correct broken link in TSCH README,1,[],https://github.com/contiki-os/contiki/pull/2694,https://github.com/arurke,2,https://github.com/contiki-os/contiki/pull/2694#issuecomment-917404926,Correct broken link to standard IEEE 802.15.4e-2021 amendment,A heads-up: There has not been a merge into contiki for years. Most (or all) maintainers have moved on to a fork: https://github.com/contiki-ng/contiki-ng,True,{}
contiki-os/contiki,https://github.com/contiki-os/contiki,2695,2021-10-03T12:28:33Z,,2021-10-03T12:28:33Z,OPEN,False,15,33,7,https://github.com/ngammarano,Replace ENERGEST_OFF+_ON with ENERGEST_SWITCH,7,[],https://github.com/contiki-os/contiki/pull/2695,https://github.com/ngammarano,1,https://github.com/contiki-os/contiki/pull/2695,,,True,{}
